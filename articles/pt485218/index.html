<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôàÔ∏è ü¶á üëá Reservando constantes e ganchos Git em C # ü§ë ‚ôâÔ∏è üèùÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Deixe-me contar uma hist√≥ria. Era uma vez dois desenvolvedores: Sam e Bob. Eles trabalharam juntos em um projeto no qual havia um banco de dados. Quan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Reservando constantes e ganchos Git em C #</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485218/"><p> Deixe-me contar uma hist√≥ria.  Era uma vez dois desenvolvedores: Sam e Bob.  Eles trabalharam juntos em um projeto no qual havia um banco de dados.  Quando o desenvolvedor quis fazer altera√ß√µes, ele teve que criar um arquivo <code>stepNNN.sql</code> , em que NNN √© um determinado n√∫mero.  Para evitar conflitos desses n√∫meros entre diferentes desenvolvedores, eles usaram um servi√ßo da Web simples.  Cada desenvolvedor, antes de come√ßar a gravar o arquivo SQL, precisava ir para este servi√ßo e reservar um novo n√∫mero para o arquivo da etapa. </p><br><p>  Dessa vez, Sam e Bob precisaram fazer altera√ß√µes no banco de dados.  Sam obedientemente foi ao servi√ßo e reservou o n√∫mero 333. E Bob esqueceu de faz√™-lo.  Ele apenas usou 333 para seu arquivo de etapas.  Aconteceu que desta vez Bob foi o primeiro a fazer o upload de suas altera√ß√µes no sistema de controle de vers√£o.  Quando Sam estava pronto para inundar, ele descobriu que o arquivo <code>step333.sql</code> j√° existe.  Ele contatou Bob, explicou-lhe que o n√∫mero 333 estava reservado para ele e pediu para corrigir o conflito.  Mas Bob respondeu: </p><br><p>  - Cara, meu c√≥digo j√° est√° no 'master', v√°rios desenvolvedores j√° o est√£o usando.  Al√©m disso, ele j√° foi bombeado para a produ√ß√£o.  Ent√£o basta consertar tudo o que voc√™ precisa l√°. </p><br><p>  Espero que voc√™ tenha notado o que aconteceu.  A pessoa que seguiu todas as regras foi punida.  Sam teve que mudar seus arquivos, editar seu banco de dados local, etc.  Pessoalmente, eu odeio essas situa√ß√µes.  Vamos ver como podemos evit√°-lo. </p><a name="habracut"></a><br><h2 id="osnovnaya-ideya">  Ideia principal </h2><br><p>  Como evitamos essas coisas?  E se Bob n√£o conseguisse preencher seu c√≥digo se n√£o reservasse o n√∫mero correspondente no servi√ßo da Web? </p><br><p>  E podemos realmente conseguir isso.  Podemos usar ganchos Git para executar c√≥digo personalizado antes de cada confirma√ß√£o.  Este c√≥digo ir√° verificar todas as altera√ß√µes enviadas.  Se eles contiverem um novo arquivo de etapas, o c√≥digo entrar√° em contato com o servi√ßo da Web e verificar√° se o n√∫mero do arquivo de etapas est√° reservado para o desenvolvedor atual.  E se o n√∫mero n√£o estiver reservado, o c√≥digo proibir√° o preenchimento. </p><br><p>  Essa √© a ideia principal.  Vamos aos detalhes. </p><br><h2 id="git-hooki-na-c35">  Ganchos Git em C # </h2><br><p>  O Git n√£o limita voc√™ em quais idiomas voc√™ deve escrever hooks.  Como desenvolvedor de C #, prefiro usar o C # familiar para esses fins.  Posso fazer isso? </p><br><p>  Sim eu posso  A id√©ia b√°sica foi tirada por mim <a href="https://medium.com/%40max.hamulyak/using-c-code-in-your-git-hooks-66e507c01a0f" rel="nofollow">deste artigo</a> escrito por Max Hamuly√°k.  Ele exige que usemos a ferramenta global <a href="https://github.com/filipw/dotnet-script" rel="nofollow">dotnet-script</a> .  Essa ferramenta requer um .NET Core 2.1 + SDK na m√°quina do desenvolvedor.  Acredito que este seja um requisito razo√°vel para os envolvidos no desenvolvimento do .NET.  A instala√ß√£o <code>dotnet-script</code> muito simples: </p><br><pre> <code class="bash hljs">&gt; dotnet tool install -g dotnet-script</code> </pre> <br><p>  Agora podemos escrever ganchos Git em C #.  Para fazer isso, v√° para a pasta <code>.git\hooks</code> do seu projeto e crie um arquivo de <code>pre-commit</code> (sem nenhuma extens√£o): </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script Console.WriteLine("Git hook");</span></span></code> </pre> <br><p>  A partir de agora, sempre que voc√™ fizer um <code>git commit</code> , ver√° o texto do <code>Git hook</code> do <code>Git hook</code> no seu console. </p><br><h2 id="neskolko-obrabotchikov-na-odin-hook">  V√°rios manipuladores por gancho </h2><br><p>  Bem, foi iniciado.  Agora podemos escrever qualquer coisa no arquivo de <code>pre-commit</code> .  Mas eu realmente n√£o gosto dessa id√©ia. </p><br><p>  Em primeiro lugar, trabalhar com um arquivo de script n√£o √© muito conveniente.  Prefiro usar meu IDE favorito com todos os seus recursos.  E eu preferia poder dividir c√≥digo complexo em v√°rios arquivos. </p><br><p>  Mas h√° mais uma coisa que eu n√£o gosto.  Imagine a seguinte situa√ß√£o.  Voc√™ criou uma <code>pre-commit</code> com algum tipo de verifica√ß√£o.  Mais tarde, por√©m, voc√™ precisava adicionar mais verifica√ß√µes.  Voc√™ precisar√° abrir o arquivo, decidir onde colar o seu c√≥digo, como ele ir√° interagir com o c√≥digo antigo etc.  Pessoalmente, prefiro escrever um novo c√≥digo, e n√£o procurar o antigo. </p><br><p>  Vamos lidar com esses problemas, um de cada vez. </p><br><h2 id="vyzov-vneshnego-koda">  Chamar c√≥digo externo </h2><br><p>  √â isso que faremos.  Vamos criar uma pasta separada (por exemplo, <code>gitHookAssemblies</code> ).  Nesta pasta, colocarei o assembly .NET Core (por exemplo, <code>GitHooks</code> ).  Meu script no arquivo de <code>pre-commit</code> apenas chamar√° algum m√©todo deste assembly. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RunHooks</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHook</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Git hook from assembly"</span></span>); } }</code> </pre> <br><p>  Posso criar esse assembly no meu IDE favorito e usar qualquer ferramenta. </p><br><p>  Agora, no arquivo <code>pre-commit</code> , posso escrever: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "../../gitHookAssemblies/GitHooks.dll" GitHooks.RunHooks.RunPreCommitHook();</span></span></code> </pre> <br><p>  √ìtimo, n√£o √©?  Agora s√≥ posso fazer altera√ß√µes na minha compila√ß√£o do <code>GitHooks</code> .  O c√≥digo do arquivo <code>pre-commit</code> nunca ser√° alterado.  Quando precisar adicionar alguma verifica√ß√£o, alterarei o c√≥digo do m√©todo <code>RunPreCommitHook</code> , reconstruir o assembly e coloc√°-lo na pasta <code>gitHookAssemblies</code> .  E √© isso a√≠! </p><br><p>  Bem, na verdade n√£o. </p><br><h2 id="borba-s-keshem">  Lutando contra o cache </h2><br><p>  Vamos tentar seguir o nosso processo.  Altere a mensagem no <code>Console.WriteLine</code> para outra coisa, recrie o assembly e coloque o resultado na pasta <code>gitHookAssemblies</code> .  Depois disso, chame <code>git commit</code> novamente.  O que vamos ver?  Post antigo.  Nossas mudan√ßas n√£o foram detectadas.  Porque </p><br><p>  Permita que seu projeto seja localizado na pasta <code>c:\project</code> .  Isso significa que os scripts de gancho do Git est√£o localizados na pasta <code>c:\project\.git\hooks</code> .  Agora, se voc√™ estiver usando o Windows 10, v√° para a pasta <code>c:\Users\&lt;UserName&gt;\AppData\Local\Temp\scripts\c\project\.git\hooks\</code> .  Aqui <code>&lt;UserName&gt;</code> √© o nome do seu usu√°rio atual.  O que veremos aqui?  Quando executamos o script de <code>pre-commit</code> , uma vers√£o compilada desse script √© criada nesta pasta.  Aqui voc√™ pode encontrar todos os assemblies referenciados pelo script (incluindo nosso <code>GitHooks.dll</code> ).  E na subpasta de <code>execution-cache</code> voc√™ pode encontrar o arquivo SHA256.  Posso assumir que ele cont√©m o hash SHA256 do nosso arquivo de <code>pre-commit</code> .  No momento em que executamos o script, o tempo de execu√ß√£o compara o hash atual do arquivo com o hash armazenado.  Se forem iguais, a vers√£o salva do script compilado ser√° usada. </p><br><p>  Isso significa que, como nunca <code>GitHooks.dll</code> arquivo de <code>pre-commit</code> , as altera√ß√µes no <code>GitHooks.dll</code> nunca atingir√£o o cache e nunca ser√£o usadas. </p><br><p>  O que podemos fazer nessa situa√ß√£o?  Bem, a reflex√£o nos ajudar√°.  Vou reescrever meu script para que ele use o Reflection em vez de referenciar diretamente o assembly <code>GitHooks</code> .  A seguir, como ser√° nosso arquivo de <code>pre-commit</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooks.dll"); var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(assembly == null) { Console.WriteLine($"Can't load assembly from '{assemblyPath}'."); } var collectorsType = assembly.GetType("GitHooks.RunHooks"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(collectorsType == null) { Console.WriteLine("Can't find entry type."); } var method = collectorsType.GetMethod("RunPreCommitHook", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(method == null) { Console.WriteLine("Can't find method for pre-commit hooks."); } method.Invoke(null, new object[0]);</span></span></code> </pre> <br><p>  Agora podemos atualizar o <code>GitHook.dll</code> em nossa pasta <code>gitHookAssemblies</code> a qualquer momento, e todas as altera√ß√µes ser√£o captadas pelo mesmo script.  A modifica√ß√£o do pr√≥prio script n√£o √© mais necess√°ria. </p><br><p>  Tudo isso parece √≥timo, mas h√° outro problema que precisa ser resolvido antes de prosseguir.  Estou falando de assemblies referenciados pelo nosso c√≥digo. </p><br><h2 id="ispolzuemye-sborki">  Montagens usadas </h2><br><p>  Tudo funciona bem, desde que a √∫nica coisa que o m√©todo <code>RunHooks.RunPreCommitHook</code> seja a sa√≠da da string no console.  Mas, francamente, geralmente exibir texto na tela n√£o √© de interesse.  Precisamos fazer coisas mais complexas.  E para isso, precisamos usar outros assemblies e pacotes NuGet.  Vamos ver como fazer isso. </p><br><p>  <code>RunHooks.RunPreCommitHook</code> para que ele use o pacote <code>LibGit2Sharp</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHook</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); Console.WriteLine(repo.Info.WorkingDirectory); }</code> </pre> <br><p>  Agora, se eu executar o <code>git commit</code> , receberei a seguinte mensagem de erro: </p><br><pre> <code class="plaintext hljs">System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocation. ---&gt; System.IO.FileLoadException: Could not load file or assembly 'LibGit2Sharp, Version=0.26.0.0, Culture=neutral, PublicKeyToken=7cbde695407f0333'. General Exception (0x80131500)</code> </pre> <br><p>  Claramente, precisamos de alguma maneira de garantir que os conjuntos a que nos referimos sejam carregados.  A id√©ia b√°sica aqui √©.  Vou colocar todo o c√≥digo do assembly necess√°rio para executar o c√≥digo na mesma pasta <code>gitHookAssemblies</code> junto com o meu <code>GitHooks.dll</code> .  Para obter todos os assemblies necess√°rios, voc√™ pode usar o comando <code>dotnet publish</code> .  No nosso caso, precisamos colocar o <code>LibGit2Sharp.dll</code> e o <code>git2-7ce88e6.dll</code> nessa pasta. </p><br><p>  Tamb√©m temos que mudar o <code>pre-commit</code> .  N√≥s adicionaremos o seguinte c√≥digo a ele: </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooks.dll"); AssemblyLoadContext.Default.Resolving += (context, assemblyName) =&gt; { var assemblyPath = Path.Combine(hooksDirectory, $"{assemblyName.Name}.dll"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(File.Exists(assemblyPath)) { return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); } return null; }; ...</span></span></code> </pre> <br><p>  Esse c√≥digo tentar√° carregar todos os assemblies que o tempo de execu√ß√£o n√£o p√¥de encontrar sozinho na pasta <code>gitHookAssemblies</code> . </p><br><p>  Agora voc√™ pode executar o <code>git commit</code> e ele ser√° executado sem problemas. </p><br><h2 id="uluchshenie-rasshiryaemosti">  Melhoria da extensibilidade </h2><br><p>  Nosso arquivo de <code>pre-commit</code> est√° completo.  N√£o precisamos mais mudar isso.  Mas se voc√™ precisar fazer altera√ß√µes, precisaremos alterar o m√©todo <code>RunHooks.RunPreCommitHook</code> .  Ent√£o, acabamos de mudar o problema para outro n√≠vel.  Pessoalmente, eu preferiria ter algum tipo de sistema de plugins.  Toda vez que eu precisar adicionar alguma a√ß√£o que precise ser executada antes de preencher o c√≥digo, apenas escreverei um novo plug-in e nada precisar√° ser alterado.  Qu√£o dif√≠cil √© conseguir isso? </p><br><p>  Nem um pouco dif√≠cil.  Vamos usar o <a href="https://docs.microsoft.com/en-us/dotnet/framework/mef/" rel="nofollow">MEF</a> .  √â assim que funciona. </p><br><p>  Primeiro, precisamos definir uma interface para nossos manipuladores de gancho: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><p>  Cada manipulador pode receber alguns argumentos de string do Git.  Esses argumentos ser√£o passados ‚Äã‚Äãpelo par√¢metro <code>args</code> .  O m√©todo <code>Process</code> retornar√° <code>true</code> se permitir derramar altera√ß√µes.  Caso contr√°rio, <code>false</code> ser√° retornado. </p><br><p>  Interfaces semelhantes podem ser definidas para todos os ganchos, mas neste artigo focaremos apenas na pr√©-confirma√ß√£o. </p><br><p>  Agora voc√™ precisa escrever uma implementa√ß√£o desta interface: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MessageHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Message hook..."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(args != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Arguments are:"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> args) { Console.WriteLine(arg); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Essas classes podem ser criadas em diferentes montagens, se voc√™ desejar.  N√£o h√° literalmente restri√ß√µes.  O atributo <code>Export</code> √© obtido do pacote NuGet <code>System.ComponentModel.Composition</code> . </p><br><p>  Al√©m disso, vamos criar um m√©todo auxiliar que colete todas as implementa√ß√µes da interface <code>IPreCommitHook</code> marcadas com o atributo <code>Export</code> , execute todas elas e retorne informa√ß√µes sobre se todas elas permitiram o preenchimento.  Coloquei meu manipulador em um assembly <code>GitHooksCollector</code> separado, mas isso n√£o √© t√£o importante: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Collectors</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PreCommitHooks</span></span> { [ImportMany(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IPreCommitHook))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IPreCommitHook[] Hooks { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RunPreCommitHooks</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> directory</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> catalog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DirectoryCatalog(directory, <span class="hljs-string"><span class="hljs-string">"*Hooks.dll"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CompositionContainer(catalog); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PreCommitHooks(); container.ComposeParts(obj); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> success = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hook <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj.Hooks) { success &amp;= hook.Process(args); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> success ? <span class="hljs-number"><span class="hljs-number">0</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><p>  Este c√≥digo tamb√©m usa o pacote NuGet <code>System.ComponentModel.Composition</code> .  Primeiro, dizemos que <code>*Hooks.dll</code> todos os assemblies cujo nome corresponde ao modelo <code>*Hooks.dll</code> na pasta do <code>directory</code>  Voc√™ pode usar qualquer modelo que desejar aqui.  Em seguida, coletamos todas as implementa√ß√µes exportadas da interface <code>IPreCommitHook</code> em um objeto <code>PreCommitHooks</code> .  E, finalmente, iniciamos todos os manipuladores de gancho e coletamos o resultado de sua execu√ß√£o. </p><br><p>  A √∫ltima coisa que precisamos fazer √© uma pequena altera√ß√£o no arquivo de <code>pre-commit</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-meta"><span class="hljs-meta">#!/usr/bin/env dotnet-script #r "nuget: System.Runtime.Loader, 4.3.0" using System.IO; using System.Runtime.Loader; var hooksDirectory = Path.Combine(Environment.CurrentDirectory, "gitHookAssemblies"); var assemblyPath = Path.Combine(hooksDirectory, "GitHooksCollector.dll"); AssemblyLoadContext.Default.Resolving += (context, assemblyName) =&gt; { var assemblyPath = Path.Combine(hooksDirectory, $"{assemblyName.Name}.dll"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(File.Exists(assemblyPath)) { return AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); } return null; }; var assembly = AssemblyLoadContext.Default.LoadFromAssemblyPath(assemblyPath); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(assembly == null) { Console.WriteLine($"Can't load assembly from '{assemblyPath}'."); } var collectorsType = assembly.GetType("GitHooksCollector.Collectors"); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(collectorsType == null) { Console.WriteLine("Can't find collector's type."); } var method = collectorsType.GetMethod("RunPreCommitHooks", System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(method == null) { Console.WriteLine("Can't find collector's method for pre-commit hooks."); } int exitCode = (int) method.Invoke(null, new object[] { Args, hooksDirectory }); Environment.Exit(exitCode);</span></span></code> </pre> <br><p>  E n√£o esque√ßa de colocar todos os assemblies envolvidos na pasta <code>gitHookAssemblies</code> . </p><br><p>  Sim, foi uma longa introdu√ß√£o.  Mas agora temos uma solu√ß√£o totalmente confi√°vel para criar manipuladores de gancho Git em C #.  Tudo o que √© necess√°rio para n√≥s √© alterar o conte√∫do da pasta <code>gitHookAssemblies</code> .  Seu conte√∫do pode ser colocado em um sistema de controle de vers√£o e, assim, distribu√≠do entre todos os desenvolvedores. </p><br><p>  De qualquer forma, √© hora de voltarmos ao nosso problema original. </p><br><h2 id="web-servis-dlya-rezervirovaniya-konstant">  Servi√ßo da Web para reservas constantes </h2><br><p>  Quer√≠amos garantir que os desenvolvedores n√£o pudessem preencher determinadas altera√ß√µes se esquecessem de reservar a constante correspondente no servi√ßo da Web.  Vamos criar um servi√ßo da Web simples para que voc√™ possa trabalhar com ele.  Estou usando o servi√ßo ASP.NET Core Web com autentica√ß√£o do Windows.  Mas, de fato, existem v√°rias op√ß√µes. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Authorization; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Microsoft.AspNetCore.Mvc; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ListsService.Controllers</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListItem</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> owner</span></span></span><span class="hljs-function">)</span></span> { Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; Owner = owner; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Owner { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Lists</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; SqlVersions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">@"DOMAIN\Iakimov"</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; AllLists = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;ListItem&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt;&gt; { {<span class="hljs-number"><span class="hljs-number">1</span></span>, SqlVersions} }; } [Authorize] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListsController</span></span> : <span class="hljs-title"><span class="hljs-title">Controller</span></span> { [Route(<span class="hljs-string"><span class="hljs-string">"/api/lists/{listId}/ownerOf/{itemId}"</span></span>)] [HttpGet] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IActionResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetOwner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Lists.AllLists.ContainsKey(listId)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NotFound(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item = Lists.AllLists[listId].FirstOrDefault(li =&gt; li.Value == itemId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NotFound(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Json(item.Owner); } } }</code> </pre> <br><p>  Aqui, para fins de teste, usei a classe <code>Lists</code> est√°tica como um mecanismo para armazenar listas.  Cada lista ter√° um identificador inteiro.  Cada lista conter√° valores inteiros e informa√ß√µes sobre as pessoas para quem esses valores est√£o reservados.  O m√©todo <code>GetOwner</code> da classe <code>GetOwner</code> permite obter o identificador da pessoa para quem esse item de lista est√° reservado. </p><br><h2 id="proverka-sql-step-faylov">  Validando arquivos de etapa SQL </h2><br><p>  Agora estamos prontos para verificar se podemos fazer upload de um novo arquivo de etapas ou n√£o.  Por defini√ß√£o, suponha que armazenemos arquivos de etapas da seguinte maneira.  A pasta raiz do nosso projeto possui um diret√≥rio <code>sql</code> .  Nele, cada desenvolvedor pode criar uma pasta <code>verXXX</code> , onde <code>XXX</code> √© um determinado n√∫mero que deve ser reservado anteriormente no servi√ßo da Web.  Dentro do diret√≥rio <code>verXXX</code> , pode haver um ou mais arquivos <code>.sql</code> contendo instru√ß√µes para modificar o banco de dados.  N√£o discutiremos o problema de garantir a ordem de execu√ß√£o desses arquivos <code>.sql</code> aqui.  Isso n√£o √© importante para a nossa discuss√£o.  N√≥s apenas queremos fazer o seguinte.  Se um desenvolvedor estiver tentando fazer upload de um novo arquivo contido na <code>sql/verXXX</code> , devemos verificar se a constante <code>XXX</code> reservada para esse desenvolvedor. </p><br><p>  Aqui est√° a apar√™ncia do c√≥digo para o manipulador de gancho Git correspondente: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SqlStepsHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Regex _expr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">"\\bver(\\d+)\\b"</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> items = repo.RetrieveStatus() .Where(i =&gt; !i.State.HasFlag(FileStatus.Ignored)) .Where(i =&gt; i.State.HasFlag(FileStatus.NewInIndex)) .Where(i =&gt; i.FilePath.StartsWith(<span class="hljs-string"><span class="hljs-string">@"sql"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> versions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( items .Select(i =&gt; _expr.Match(i.FilePath)) .Where(m =&gt; m.Success) .Select(m =&gt; m.Groups[<span class="hljs-number"><span class="hljs-number">1</span></span>].Value) .Select(d =&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(d)) ); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> version <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> versions) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ListItemOwnerChecker.DoesCurrentUserOwnListItem(<span class="hljs-number"><span class="hljs-number">1</span></span>, version)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Aqui usamos a classe <code>Repository</code> do pacote <code>LibGit2Sharp</code> .  A vari√°vel <code>items</code> conter√° todos os novos arquivos no √≠ndice Git que est√£o localizados dentro da pasta <code>sql</code> .  Voc√™ pode melhorar o procedimento de pesquisa para esses arquivos, se desejar.  Na vari√°vel de <code>versions</code> , coletamos v√°rias constantes <code>XXX</code> das pastas <code>verXXX</code> .  E, finalmente, o m√©todo <code>ListItemOwnerChecker.DoesCurrentUserOwnListItem</code> verifica se essas vers√µes est√£o registradas para o usu√°rio atual no servi√ßo da Web na lista 1. </p><br><p>  A implementa√ß√£o do <code>ListItemOwnerChecker.DoesCurrentUserOwnListItem</code> bastante simples: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ListItemOwnerChecker</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetListItemOwner</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClientHandler { UseDefaultCredentials = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = client.GetAsync(<span class="hljs-string"><span class="hljs-string">$"https://localhost:44389/api/lists/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">/ownerOf/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">"</span></span>) .ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) .GetAwaiter() .GetResult(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.StatusCode == System.Net.HttpStatusCode.NotFound) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner = response.Content .ReadAsStringAsync() .ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) .GetAwaiter() .GetResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonConvert.DeserializeObject&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(owner); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoesCurrentUserOwnListItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> listId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> itemId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> owner = GetListItemOwner(listId, itemId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"There is no item '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">' in the list '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">' registered on the lists service."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (owner != WindowsIdentity.GetCurrent().Name) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Item '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{itemId}</span></span></span><span class="hljs-string">' in the list '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{listId}</span></span></span><span class="hljs-string">' registered by '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{owner}</span></span></span><span class="hljs-string">' and you are '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{WindowsIdentity.GetCurrent().Name}</span></span></span><span class="hljs-string">'."</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Aqui, solicitamos ao servi√ßo da Web o identificador do usu√°rio que registrou a constante especificada (m√©todo <code>GetListItemOwner</code> ).  Em seguida, o resultado √© comparado com o nome do usu√°rio atual do Windows.  Essa √© apenas uma das muitas maneiras poss√≠veis de implementar essa funcionalidade.  Por exemplo, voc√™ pode usar o nome de usu√°rio ou email da configura√ß√£o do Git. </p><br><p>  Isso √© tudo.  Apenas compile o assembly apropriado e coloque-o na pasta <code>gitHookAssemblies</code> junto com todas as suas depend√™ncias.  E tudo funcionar√° automaticamente. </p><br><h2 id="proverka-znacheniy-enum">  Verificando valores de enumera√ß√£o </h2><br><p>  Isso √© √≥timo!  Agora ningu√©m poder√° fazer upload de altera√ß√µes no banco de dados sem antes ter reservado para si a constante correspondente no servi√ßo da Web.  Mas um m√©todo semelhante pode ser usado em outros lugares onde √© necess√°ria reserva constante. </p><br><p>  Por exemplo, em algum lugar do c√≥digo do projeto voc√™ tem uma enumera√ß√£o.  Cada desenvolvedor pode adicionar novos membros a ele com valores inteiros atribu√≠dos: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Constants { Val1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, Val2 = <span class="hljs-number"><span class="hljs-number">2</span></span>, Val3 = <span class="hljs-number"><span class="hljs-number">3</span></span> }</code> </pre> <br><p>  Queremos evitar uma colis√£o de valores para membros dessa enumera√ß√£o.  Portanto, exigimos uma reserva preliminar das constantes correspondentes no servi√ßo da Web.  Qu√£o dif√≠cil √© implementar a verifica√ß√£o dessa reserva? </p><br><p>  Aqui est√° o c√≥digo para o novo manipulador de ganchos Git: </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Export(typeof(IPreCommitHook))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ConstantValuesHook</span></span> : <span class="hljs-title"><span class="hljs-title">IPreCommitHook</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> repo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Repository(Environment.CurrentDirectory); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> constantsItem = repo.RetrieveStatus() .Staged .FirstOrDefault(i =&gt; i.FilePath == <span class="hljs-string"><span class="hljs-string">@"src/GitInteraction/Constants.cs"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constantsItem == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!constantsItem.State.HasFlag(FileStatus.NewInIndex) &amp;&amp; !constantsItem.State.HasFlag(FileStatus.ModifiedInIndex)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialContent = GetInitialContent(repo, constantsItem); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexContent = GetIndexContent(repo, constantsItem); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> initialConstantValues = GetConstantValues(initialContent); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> indexConstantValues = GetConstantValues(indexContent); indexConstantValues.ExceptWith(initialConstantValues); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexConstantValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> version <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> indexConstantValues) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ListItemOwnerChecker.DoesCurrentUserOwnListItem(<span class="hljs-number"><span class="hljs-number">2</span></span>, version)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } ... }</code> </pre> <br><p>  Primeiro, verificamos se o arquivo que cont√©m nossa enumera√ß√£o foi modificado.  Em seguida, extra√≠mos o conte√∫do desse arquivo da vers√£o mais recente carregada e do √≠ndice Git usando os <code>GetIndexContent</code> e <code>GetIndexContent</code> .  Aqui est√° a sua implementa√ß√£o: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetInitialContent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Repository repo, StatusEntry item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> blob = repo.Head.Tip[item.FilePath]?.Target <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Blob; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (blob == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(blob.GetContentStream(), Encoding.UTF8); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content.ReadToEnd(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIndexContent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Repository repo, StatusEntry item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = repo.Index[item.FilePath]?.Id; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> itemBlob = repo.Lookup&lt;Blob&gt;(id); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (itemBlob == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamReader(itemBlob.GetContentStream(), Encoding.UTF8); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> content.ReadToEnd(); }</code> </pre> <br><p>            .     <code>GetConstantValues</code> .   <a href="https://github.com/dotnet/roslyn" rel="nofollow"><code>Roslyn</code></a>    .      NuGet- <code>Microsoft.CodeAnalysis.CSharp</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> ISet&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetConstantValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileContent</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrWhiteSpace(fileContent)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tree = CSharpSyntaxTree.ParseText(fileContent); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = tree.GetCompilationUnitRoot(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enumDeclaration = root .DescendantNodes() .OfType&lt;EnumDeclarationSyntax&gt;() .FirstOrDefault(e =&gt; e.Identifier.Text == <span class="hljs-string"><span class="hljs-string">"Constants"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(enumDeclaration == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumDeclaration.Members) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.TryParse(member.EqualsValue.Value.ToString(), <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) { result.Add(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>   <code>Roslyn</code>     .   ,     ,    <code>Microsoft.CodeAnalysis.CSharp</code>  <code>3.4.0</code> .       <code>gitHookAssemblies</code> ,    ,        .      .  , <code>dotnet-script</code>    <code>Roslyn</code>   .  ,  -   <code>Microsoft.CodeAnalysis.CSharp</code>     .       <code>3.3.1</code> .           NuGet-,  . </p><br><p> , ,   <code>Process</code>   hook`,           Web-. </p><br><h2 id="napravleniya-dalneyshego-razvitiya">    </h2><br><p>   .      .         ,     . </p><br><ol><li><p>    <code>pre-commit</code> ,      ,      <code>.git\hooks</code>    .     <code>--template</code>  <code>git init</code> .   - : </p><br><pre> <code class="bash hljs">git config init.templatedir git_template_dir git init</code> </pre> <br><p>     <code>core.hooksPath</code>  Git,     Git 2.9   : </p><br><pre> <code class="bash hljs">git config core.hooksPath git_template_dir</code> </pre> <br><p>           . </p><br></li><li><p>        <code>dotnet-script</code> .              .NET Core,         . </p><br></li><li><p>       ,    .  ,       <code>gitHookAssemblies</code> ,    ,      . ,  <code>LibGit2Sharp</code>         .    <code>git2-7ce88e6.dll</code> ,   Win-x64.        ,     . </p><br></li><li><p>        Web-.    Windows-,      .   Web-    UI        . </p><br></li><li><p>   ,        Git hook'  .  ,      . </p><br></li></ol><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>            Git hook`   .NET.        ,            . </p><br><p>  ,      .  Boa sorte </p><br><p> PS         <a href="https://github.com/yakimovim/csharp-git-hooks" rel="nofollow">GitHub</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt485218/">https://habr.com/ru/post/pt485218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt485204/index.html">Retornar ao topo: por que a capitaliza√ß√£o da Amazon em breve exceder√° US $ 1 trilh√£o</a></li>
<li><a href="../pt485206/index.html">Como o Typecript me decepcionou e vale a pena?</a></li>
<li><a href="../pt485208/index.html">Cria√ß√£o de infraestrutura de TI tolerante a falhas. Parte 2. Instalando e configurando o cluster oVirt 4.3</a></li>
<li><a href="../pt485210/index.html">Atirador de zumbis simples no Unity</a></li>
<li><a href="../pt485214/index.html">CLRium # 7: Pr√°tico. Semin√°rio, trabalhos de casa com verifica√ß√£o, orienta√ß√£o</a></li>
<li><a href="../pt485220/index.html">A evolu√ß√£o do Web Application Firewall: dos firewalls aos sistemas de seguran√ßa baseados em nuvem de aprendizado de m√°quina</a></li>
<li><a href="../pt485222/index.html">Como trabalhar com l√≠deres de opini√£o na China? Cinco dicas pr√°ticas</a></li>
<li><a href="../pt485224/index.html">Como a entrega de mercadorias est√° abaixo do limite aduaneiro a partir de 1 de janeiro de 2020</a></li>
<li><a href="../pt485226/index.html">Desenvolvimento da interface do usu√°rio: a quem ouvir - voc√™ ou o usu√°rio?</a></li>
<li><a href="../pt485228/index.html">O que √© aprendizado ativo?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>