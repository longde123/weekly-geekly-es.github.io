<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿 🆕 👨‍👨‍👦‍👦 Minas em desempenho estão esperando nos bastidores ✌🏼 ↖️ 👍🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre minas colocadas sob o desempenho, bem como sua detecção (preferencialmente antes da explosão) e descarte. 
 Uma imagem par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Minas em desempenho estão esperando nos bastidores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443206/"><p>  Neste artigo, falarei sobre minas colocadas sob o desempenho, bem como sua detecção (preferencialmente antes da explosão) e descarte. </p><br><div class="spoiler">  <b class="spoiler_title">Uma imagem para atrair a atenção</b> <div class="spoiler_text"><p><img src="https://ic.pics.livejournal.com/ivagkin/26880913/58954/58954_original.jpg" alt="imagem"></p></div></div><a name="habracut"></a><br><h4 id="chto-takoe-mina">  O que é uma mina? </h4><br><p>  Vamos começar com o que está nas origens de qualquer conhecimento - com definição.  Os antigos disseram que nomear corretamente significa entender corretamente.  Eu acho que a definição de uma mina com desempenho é melhor expressa por contraste com um erro claro, por exemplo, </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... strings)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : strings) { result += str; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Até desenvolvedores iniciantes sabem que as linhas são imutáveis ​​e colá-las em um loop não significa adicionar dados ao final de uma linha existente, mas criar uma <strong>nova</strong> linha a cada passagem.  Se você estiver enganado, não desanime - a “Ideia” o alertará imediatamente sobre o perigo, e o “Sonar” certamente inundará sua assembléia. </p><br><p>  Mas esse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">código</a> atrairá muito menos atenção e a Idea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">antes da versão 2018.2</a> ) ficará em silêncio: </p><br><pre> <code class="java hljs">Long total = <span class="hljs-number"><span class="hljs-number">0L</span></span>; List&lt;Long&gt; totals = query.getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long element : totals) { total += element == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : element; }</code> </pre> <br><p>  O problema aqui é o mesmo: os invólucros para tipos simples são imutáveis, o que significa adicionar 5 unidades ao número do objeto significa criar um novo invólucro e gravar o número 6 nele. </p><br><p>  A piada aqui é a presença em Java de duas representações de certos tipos de dados - simples e objeto, bem como sua transformação automática por meio da própria linguagem.  Por causa disso, muitos desenvolvedores novatos pensam algo assim: "Bem, a execução de alguma forma os transforma lá por si só, é apenas um número". </p><br><p>  De fato, nem tudo é tão simples.  Pegue a <a href="">referência</a> e tente adicionar os números da maneira especificada: </p><br><div class="spoiler">  <b class="spoiler_title">De repente, saiu muito, muito barato (a seguir JDK 11, a menos que explicitamente indicado de outra forma)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> (size) Mode Cnt Score Error Units wrapper 10 avgt 100 23,5 ± 0,1 ns/op wrapper 100 avgt 100 352,3 ± 2,1 ns/op wrapper 1000 avgt 100 4424,5 ± 25,2 ns/op wrapper 10 avgt 100 0 ± 0 B/op wrapper 100 avgt 100 1872 ± 0 B/op wrapper 1000 avgt 100 23472 ± 0 B/op</code> </pre> <br><p>  Compare com um tipo simples: </p><br><pre> <code class="plaintext hljs">primitive 10 avgt 100 6,4 ± 0,0 ns/op primitive 100 avgt 100 39,8 ± 0,1 ns/op primitive 1000 avgt 100 252,5 ± 1,3 ns/op primitive 10 avgt 100 0 ± 0 B/op primitive 100 avgt 100 0 ± 0 B/op primitive 1000 avgt 100 0 ± 0 B/op</code> </pre> </div></div><br><p>  A partir daqui, derivamos uma das definições de minas em desempenho - este é um código que não chama a atenção, não é detectado (pelo menos no momento em que você o encontrou) pelos analisadores estáticos, mas pode desacelerar em alguns usos.  No nosso caso, enquanto a soma não excede 127 objetos, o cache é retirado e <code>Long</code> apenas 4 vezes mais lento que o <code>long</code> .  No entanto, para uma matriz de tamanho 100, a velocidade é quase 10 vezes menor. </p><br><h4 id="bolshie-melochi">  Grandes pequenas coisas </h4><br><p>  Às vezes, uma pequena mudança, que <em>quase</em> não muda o significado da execução, em <em>algumas</em> circunstâncias se torna um freio forte. </p><br><p>  Suponha que tenhamos um código: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); if (info == null) { info = getAlias.apply(alias); cache.put(alias, info); } return info; }</span></span></code> </pre> <br><p>  Como é a lógica do método? </p><br><div class="spoiler">  <b class="spoiler_title">Não se apresse em espionar, pense</b> <div class="spoiler_text"><p>  Este é <code>ConcurrentHashMap::computeIfAbsent</code> ! </p></div></div><br><p>  Temos o "oito" e podemos melhorar o código de maneira interessante: substitua 6 linhas por uma, tornando o código mais curto e fácil de entender.  A propósito, os conhecedores de multithreading provavelmente <code>ConcurrentHashMap::computeIfAbsent</code> outra melhoria que <code>ConcurrentHashMap::computeIfAbsent</code> traz consigo, mas um pouco mais tarde;) </p><br><p>  Vamos realizar um ótimo pensamento: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { return cache.computeIfAbsent(alias, getAlias); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Reunidos, iniciados, choraram</b> <div class="spoiler_text"><p>  Para ver o tamanho completo, clique com o botão direito do mouse na imagem e selecione "Abrir imagem em uma nova guia" <br><img src="https://habrastorage.org/getpro/habr/post_images/9f0/2aa/0e0/9f02aa0e028903e85a63d08207d93509.png" alt="imagem"></p></div></div><br><p>  Enquanto o aplicativo trabalhava com um thread, tudo era mais ou menos bom.  Os fluxos tornaram-se mais e pioraram significativamente.  Verificou- <code>ConcurrentHashMap::computeIfAbsent</code> que <code>ConcurrentHashMap::computeIfAbsent</code> bloqueado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mesmo que a chave <strong>já tenha sido</strong> adicionada ao dicionário</a> .  E esse se tornou o motivo de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bug</a> no Spring Date Mongo. </p><br><p>  Você pode verificar isso com uma <a href="">medição</a> simples ("oito").  Aqui está sua conclusão: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 19,405 ± 0,411 ns/op getAndPut avgt 20 4,578 ± 0,045 ns/op 2 threads computeIfAbsent avgt 20 66,492 ± 2,036 ns/op getAndPut avgt 20 4,454 ± 0,110 ns/op 4 threads computeIfAbsent avgt 20 155,975 ± 8,850 ns/op getAndPut avgt 20 5,616 ± 2,073 ns/op 6 threads computeIfAbsent avgt 20 203,188 ± 10,547 ns/op getAndPut avgt 20 7,024 ± 0,456 ns/op 8 threads computeIfAbsent avgt 20 302,036 ± 31,702 ns/op getAndPut avgt 20 7,990 ± 0,144 ns/op</code> </pre> <br><p>  Isso pode ser claramente considerado um erro pelos desenvolvedores?  Na minha humilde opinião, não, não.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> diz: </p><br><blockquote>  Algumas tentativas de atualização de operações neste mapa por outros encadeamentos podem ser bloqueadas enquanto a computação está em andamento; portanto, a computação deve ser curta e simples e não deve tentar atualizar nenhum outro mapeamento desse mapa. </blockquote><p>  Em outras palavras, <code>ConcurrentHashMap::computeIfAbsent</code> fecha a célula que contém a chave do mundo externo (ao contrário de <code>ConcurrentHashMap::get</code> ), o que geralmente é verdadeiro, pois permite evitar a corrida ao chamar o método de diferentes threads quando a chave ainda não foi adicionada. </p><br><p>  Por outro lado, no modo de operação mais comum, o cálculo do valor e sua ligação com a chave ocorre apenas na primeira chamada e todas as chamadas subsequentes retornam apenas o valor calculado anteriormente.  Portanto, faz sentido alterar a lógica para que o bloqueio seja definido apenas ao alterar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Foi feito aqui</a> . </p><br><p>  Nas edições mais recentes (&gt; 8), <code>ConcurrentHashMap::computeIfAbsent</code> se <code>ConcurrentHashMap::computeIfAbsent</code> : </p><br><pre> <code class="plaintext hljs">JDK 11 Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 6,983 ± 0,066 ns/op getAndPut avgt 20 5,291 ± 1,220 ns/op 2 threads computeIfAbsent avgt 20 7,173 ± 0,249 ns/op getAndPut avgt 20 5,118 ± 0,395 ns/op 4 threads computeIfAbsent avgt 20 7,991 ± 0,447 ns/op getAndPut avgt 20 5,270 ± 0,366 ns/op 6 threads computeIfAbsent avgt 20 11,919 ± 0,865 ns/op getAndPut avgt 20 7,249 ± 0,199 ns/op 8 threads computeIfAbsent avgt 20 14,360 ± 0,892 ns/op getAndPut avgt 20 8,511 ± 0,229 ns/op</code> </pre> <br><p>  Preste atenção à insidiosidade deste exemplo: o conteúdo semântico não mudou muito, porque à primeira vista usamos apenas uma sintaxe mais avançada.  Ao mesmo tempo, enquanto o aplicativo é executado em um thread, o usuário quase não sente a diferença!  É assim que mudanças aparentemente inofensivas <del>  o porco </del>  mina sob nosso desempenho. </p><br><div class="spoiler">  <b class="spoiler_title">Por que eu escrevi 'quase inalterado'</b> <div class="spoiler_text"><p>  <code>ConcurrentHashMap::computeIfAbsent</code> nem sempre é intercambiável com a expressão <code>getAndPut</code> , porque <code>ConcurrentHashMap::computeIfAbsent</code> é uma operação atômica.  No mesmo código </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { info = getAlias.apply(alias); cache.put(alias, info); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; }</code> </pre> <br><p>  devido à falta de sincronização externa <strong>, uma corrida aparece</strong> .  Se a função passada para <code>ConcurrentHashMap::computeIfAbsent</code> para a chave especificada sempre retornar o mesmo valor, então esta é uma corrida "segura", o máximo que enfrentamos é o cálculo do mesmo valor 2 ou mais vezes.  Se não houver tais garantias, uma substituição mecânica estará repleta de falhas na aplicação.  Cuidado! </p></div></div><br><h4 id="eti-ruki-nichego-ne-menyali">  Essas mãos não mudaram nada </h4><br><p>  Também acontece que o código não muda, mas de repente começa a ficar mais lento. </p><br><p>  Imagine que somos confrontados com a tarefa de transformar os elementos de uma matriz em uma coleção.  O mais lógico seria usar o <code>Collection::addAll</code> , mas aqui está a má sorte - ele aceita a coleção: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span></span>; }</code> </pre> <br><p>  A maneira mais fácil é <code>Arrays::asList</code> a matriz em <code>Arrays::asList</code> .  Acontecerá algo como </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.addAll(Arrays.asList(items)); }</code> </pre> <br><p>  Durante a revisão, colegas preocupados com o desempenho provavelmente nos dirão que existem dois problemas neste código ao mesmo tempo: </p><br><ul><li>  agrupando uma matriz em uma lista (objeto extra) </li><li>  criando um iterador (outro objeto extra) e passando por ele </li></ul><br><p>  De fato, na implementação de referência de <code>Collection::addAll</code> , veremos isso: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> modified = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add(e)) modified = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; } }</code> </pre> <br><p>  Portanto, um iterador é criado aqui e os elementos são classificados usando-o.  Portanto, camaradas experientes oferecem sua solução: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Dentro do código, com razão, <em>parecendo</em> mais produtivo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T element : elements) result |= c.add(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Primeiro, um iterador não é criado.  Em segundo lugar, o passe passa no ciclo de contagem usual, além disso, as matrizes se encaixam bem nos caches, seus elementos estão localizados na memória sequencialmente (o que significa que haverá poucas falhas de cache) e o acesso a eles pelo índice é muito rápido.  Bem, também não é criada uma lista de wrapper.  Parece bom e bom som. </p><br><p>  Finalmente, os colegas citam ultima ratio regum: documentation.  E ali, cinza no branco (ou verde no preto) diz: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ... * The behavior of this convenience method is identical to that of * c.addAll(Arrays.asList(elements)), but this method is likely * to run significantly faster under most implementations. &lt;---- * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.5 */</span></span> <span class="hljs-meta"><span class="hljs-meta">@SafeVarargs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Ou seja, os próprios desenvolvedores (e em quem eles devem acreditar, se não eles?) Escreva que, para a maioria das implementações, o método utilitário funciona <em>muito</em> mais rápido.  E ele é realmente mais rápido.  As vezes </p><br><p>  A <a href="">referência</a> , que lançaremos para o <code>HashSet</code> no G8, ajudará a <code>HashSet</code> : </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 155,2 ± 2,8 ns/op addAll HashSet 100 avgt 100 1884,4 ± 37,4 ns/op addAll HashSet 1000 avgt 100 17917,3 ± 298,8 ns/op collectionsAddAll HashSet 10 avgt 100 136,1 ± 0,8 ns/op collectionsAddAll HashSet 100 avgt 100 1538,3 ± 31,4 ns/op collectionsAddAll HashSet 1000 avgt 100 15168,6 ± 289,4 ns/op</code> </pre> <br><p>  Parece que os camaradas mais experientes estavam certos.  Quase. </p><br><p>  Nas edições posteriores (por exemplo, em 11), o brilho do método utilitário desaparecerá um pouco: </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 143,1 ± 0,6 ns/op addAll HashSet 100 avgt 100 1738,4 ± 7,3 ns/op addAll HashSet 1000 avgt 100 16853,9 ± 101,0 ns/op collectionsAddAll HashSet 10 avgt 100 132,1 ± 1,1 ns/op collectionsAddAll HashSet 100 avgt 100 1661,1 ± 7,1 ns/op collectionsAddAll HashSet 1000 avgt 100 15450,9 ± 93,9 ns/op</code> </pre> <br><p>  Pode-se ver que não estamos falando de nenhum "muito mais rápido".  E se repetirmos o experimento para <code>ArrayList</code> -a, acontece que o método utilitário começa a perder muito (quanto mais forte): </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units JDK 8 addAll ArrayList 10 avgt 100 38,5 ± 0,5 ns/op addAll ArrayList 100 avgt 100 188,4 ± 7,0 ns/op addAll ArrayList 1000 avgt 100 1278,8 ± 42,9 ns/op collectionsAddAll ArrayList 10 avgt 100 62,7 ± 0,7 ns/op collectionsAddAll ArrayList 100 avgt 100 495,1 ± 2,0 ns/op collectionsAddAll ArrayList 1000 avgt 100 4892,5 ± 48,0 ns/op JDK 11 addAll ArrayList 10 avgt 100 26,1 ± 0,0 ns/op addAll ArrayList 100 avgt 100 161,1 ± 0,4 ns/op addAll ArrayList 1000 avgt 100 1276,7 ± 3,7 ns/op collectionsAddAll ArrayList 10 avgt 100 41,6 ± 0,0 ns/op collectionsAddAll ArrayList 100 avgt 100 492,6 ± 1,5 ns/op collectionsAddAll ArrayList 1000 avgt 100 6792,7 ± 165,5 ns/op</code> </pre> <br><p>  Não há nada inesperado aqui, o <code>ArrayList</code> construído em torno de um array, portanto os desenvolvedores redefiniram de maneira previdente o <code>Collection::addAll</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ Object[] a = c.toArray(); modCount++; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numNew = a.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Object[] elementData; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew &gt; (elementData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, elementData, s, numNew); &lt;---    size = s + numNew; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Agora de volta às nossas minas.  Suponha que, no entanto, aceitemos a solução proposta na revisão e deixemos este código: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Por enquanto, está tudo bem, mas depois de adicionar novas funcionalidades, o método às vezes fica quente e começa a desacelerar.  Abrimos códigos fonte - o código não mudou.  A quantidade de dados é a mesma.  E o desempenho caiu muito.  Este é outro tipo meu. </p><br><p>  Descubra o depurador e encontre o belo: </p><br><p><img src="https://habrastorage.org/webt/nw/og/mu/nwogmu0_mvl-ix_hdyoxdaoydik.png"></p><br><p>  Observe: não alteramos o algoritmo, a quantidade de dados processados ​​não mudou, mas sua natureza mudou e um problema de desempenho foi iniciado em nosso código: </p><br><pre> <code class="plaintext hljs"> Java 8 Java 11  addAll 10 56,9 25,2 ns/op collectionsAddAll 10 352,2 142,9 ns/op addAll 100 159,9 84,3 ns/op collectionsAddAll 100 4607,1 3964,3 ns/op addAll 1000 1244,2 760,2 ns/op collectionsAddAll 1000 355796,9 364677,0 ns/op</code> </pre> <br><p>  Em matrizes grandes, a diferença entre <code>Collections::addAll</code> e <code>Collection::addAll</code> é modesta em 500 vezes.  O fato é que <code>COWList</code> não apenas expande a matriz existente, mas cria uma nova sempre que elementos são adicionados: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (lock) { Object[] es = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = es.length; es = Arrays.copyOf(es, len + <span class="hljs-number"><span class="hljs-number">1</span></span>); &lt;----    es[len] = e; setArray(es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p><del>  Quem é o culpado? </del></p><br><div class="spoiler">  <b class="spoiler_title">O que fazer</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://bugs.openjdk.java.net/browse/JDK-8193031</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://cr.openjdk.java.net/~martin/webrevs/jdk/Collections-addAll/</a> </p></div></div><br><p>  O principal problema aqui é que o <code>Collections::addAll</code> aceita uma interface, enquanto o método <code>addAll</code> não <code>addAll</code> corpo.  Nenhum corpo - nenhum negócio, portanto, a documentação é escrita com base na implementação existente em <code>AbstractCollection::addAll</code> , que é um algoritmo generalizado aplicável a todas as coleções.  Isso significa que implementações mais específicas de estruturas de dados que estão em um nível mais baixo de abstração podem alterar esse comportamento. </p><br><div class="spoiler">  <b class="spoiler_title">Agora humanamente</b> <div class="spoiler_text"><pre> <code class="java hljs"> Collection::addAll –   AbstractCollection::addAll –   &lt;---    ArrayList::addAll HashSet::addAll –   &lt;---      COWList::addAll</code> </pre> </div></div><br><h4 id="eschyo-ob-abstrakciyah">  Mais sobre abstrações </h4><br><p>  Já que estamos falando de níveis de abstração, vou lhe contar um exemplo da vida. </p><br><p>  Vamos comparar essas duas maneiras de salvar o enésimo número de entidades no banco de dados: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  À primeira vista, o desempenho de ambos os métodos não deve ser muito diferente, porque </p><br><ul><li>  nos dois casos, o mesmo número de entidades será armazenado no banco de dados </li><li>  se a tecla for retirada da sequência, o número de chamadas será o mesmo </li><li>  a quantidade de dados transferidos é a mesma </li></ul><br><p>  <code>SimpleJpaRepository::saveAndFlush</code> para o <code>SimpleJpaRepository::saveAndFlush</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveAndFlush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ S result = save(entity); flush(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ em.flush(); }</code> </pre> <br><p>  O ponto escuro aqui é o método <code>flush()</code> .  Por que burro?  Parece-me que sua divulgação na interface <code>JpaRepository</code> foi um erro dos desenvolvedores.  Vou tentar justificar meu pensamento.  Normalmente, esse método não é usado pelo desenvolvedor, porque a chamada para <code>EntityManager::flush</code> vinculada à conclusão de uma transação controlada pelo Spring: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     @Transactional public void method() { &lt;--  Session::open /*.*/ } &lt;--  Session::flush</span></span></code> </pre> <br><p>  Observe: O <code>EntityManager</code> faz parte da especificação <code>JPA</code> implementada no Hibernate como uma sessão (interface Session e classe SessionImpl, respectivamente).  Spring Date é uma estrutura executada em cima de um ORM, neste caso, em cima do Hibernate.  Acontece que o <code>JpaRepository::saveAndFlush</code> nos dá acesso aos níveis mais baixos da API, embora a tarefa da estrutura seja ocultar os detalhes de baixo nível (a situação é um pouco semelhante à história insegura no JDK). <br>  No nosso caso, ao usar <code>JpaRepository::saveAndFlush</code> entramos nas camadas inferiores do aplicativo, quebrando algo. </p><br><div class="spoiler">  <b class="spoiler_title">Tome seu tempo para espreitar, pense por si mesmo</b> <div class="spoiler_text"><p>  A capacidade do Hibernate de enviar dados em lotes está quebrada, um múltiplo da configuração <code>jdbc.batch_size</code> , especificada em <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate: jdbc.batch_size: 500</code> </pre> <br><p>  O trabalho do Hibernate é baseado em eventos, portanto, quando você salva 1000 entidades como esta </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } }</code> </pre> <br><p>  chamar <code>repository.save(e)</code> não salva instantaneamente.  Em vez disso, é criado um evento que está na fila.  Após a conclusão da transação, os dados são mesclados usando <code>EntityManager::flush</code> , que divide as inserções / atualizações em vários pacotes de <code>jdbc.batch_size</code> e cria solicitações a partir deles.  No nosso caso, <code>jdbc.batch_size: 500</code> , portanto, salvar 1000 entidades na realidade significa apenas 2 solicitações. </p><br><p>  Mas com uma descarga manual da sessão a cada passagem do ciclo </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  a fila é limpa e salvar 1000 entidades significa 1000 consultas. </p></div></div><br><p>  Assim, interferir nas camadas inferiores do aplicativo pode facilmente se tornar uma mina, e não apenas uma mina de produtividade (consulte Inseguro e seu uso não controlado). </p><br><p>  Quanto diminui a velocidade?  Tome o melhor caso (para nós) - o banco de dados está no mesmo host que o aplicativo.  Minha <a href="">medida</a> mostra a seguinte imagem: </p><br><pre> <code class="plaintext hljs"> (entityCount) Mode Cnt Score Error Units bulkSave 10 ss 500 16,613 ± 1,714 ms/op bulkSave 100 ss 500 31,371 ± 1,453 ms/op bulkSave 1000 ss 500 35,687 ± 1,973 ms/op bulkSaveUsingFlush 10 ss 500 32,653 ± 2,166 ms/op bulkSaveUsingFlush 100 ss 500 61,983 ± 6,304 ms/op bulkSaveUsingFlush 1000 ss 500 184,814 ± 6,976 ms/op</code> </pre> <br><p>  Obviamente, se o banco de dados estiver localizado em um host remoto, o custo da transferência de dados diminuirá cada vez mais o desempenho à medida que o volume de dados aumenta. </p><br><p>  Assim, trabalhar no nível errado de abstração pode facilmente criar uma bomba-relógio.  A propósito, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um dos meus artigos anteriores</a> , falei sobre uma tentativa curiosa de melhorar o <code>StringBuilder</code> -a: lá não <code>StringBuilder</code> êxito exatamente ao tentar entrar em um nível de código mais abstrato. </p><br><h4 id="granicy-minnyh-poley">  Fronteiras do campo minado </h4><br><p>  Vamos jogar um sapador?  Encontre o meu: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); Assert.notNull(key, "Null key ..." + context.metadata.operation); // ... return key; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Encontrou?</b>  <b class="spoiler_title">Verifique a resposta correta.</b> <div class="spoiler_text"><pre> <code class="java hljs"> | \ / <span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport | \ / Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); | \ / Assert.notNull(key, "Null key ..." + context.metadata.operation); return key; }</span></span></code> </pre> </div></div><br><p>  "Você está brincando comigo?", Exclama o crítico. "Mas há apenas uma colagem de duas linhas? O que isso significa em E. sangrenta?"  Deixe-me chamar sua atenção para o fato de eu destacar não apenas a colagem de strings, mas também o nome da classe e o nome do método.  De fato, o perigo de colar strings não está em si mesmo, mas no que acontece no método que cria as chaves para o cache, ou seja, em certos cenários, teremos muitos acessos a esse método, o que significa muitas linhas de lixo. <br>  Portanto, uma mensagem de erro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deve ser criada apenas</a> quando esse erro é realmente lançado: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); if (key == null) { throw new IAE("Null key ..." + context.metadata.operation); } // ... return key; }</span></span></code> </pre> <br><p>  Assim, os campos minados têm limites - é a quantidade de dados, a frequência de acesso ao método, etc. indicadores quantitativos, ao atingir e exceder os quais uma leve desvantagem se torna estatisticamente significativa. </p><br><p>  Por outro lado, esse é o recurso, ao qual a complicação do código não oferece uma melhoria significativa (mensurável). </p><br><p>  Essa é outra conclusão para o desenvolvedor: na maioria dos casos, enganar é ruim, levando a uma complicação sem sentido do código.  Em 99 casos em 100, não ganhamos nada. </p><br><p>  Deve-se lembrar que sempre há </p><br><h4 id="tot-samyy-sotyy-sluchay">  O centésimo caso </h4><br><p>  Aqui está o código que Nitzan Wakart fornece em seu artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A volátil surpresa de leitura</a> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopyBenchmarks</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"1024"</span></span>, <span class="hljs-string"><span class="hljs-string">"32768"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bunn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { <span class="hljs-comment"><span class="hljs-comment">// good old C style for (the win?) fox.consume(bunn[y]); } } @Benchmark public void sweetLoop(Blackhole fox) { for (byte bunny : bunn) { // syntactic sugar loop goodness fox.consume(bunny); } } }</span></span></code> </pre> <br><p>  Quando configuramos a experiência, descobriremos uma diferença incrível entre as duas maneiras de iterar em uma matriz: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoop 32 46.630 0.097 ns/op goodOldLoop 1024 1199.338 0.705 ns/op goodOldLoop 32768 37813.600 56.081 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>  Aqui, um desenvolvedor inexperiente pode fazer uma conclusão tão óbvia e comparada: passar por uma matriz usando a nova sintaxe funciona mais rápido que um ciclo de contagem.  Esta é a conclusão errada, porque vale a pena alterar um <code>goodOldLoop</code> o método <code>goodOldLoop</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoopReturns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sunn = bunn; <span class="hljs-comment"><span class="hljs-comment">// make a local copy of the field for (int y = 0; y &lt; sunn.length; y++) { fox.consume(sunn[y]); } }</span></span></code> </pre> <br><p>  e seu desempenho é comparável ao do método <code>sweetLoop</code> "mais rápido": </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoopReturns 32 19.306 0.045 ns/op goodOldLoopReturns 1024 476.493 1.190 ns/op goodOldLoopReturns 32768 14292.286 16.046 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>     <code>Blackhole::consume</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//... public volatile byte b1, b2; public volatile BlackholeL2 nullBait = null; /** * Consume object. This call provides a side effect preventing JIT to eliminate dependent computations. * * @param b object to consume. */ public final void consume(byte b) { if (b == b1 &amp; b == b2) { // SHOULD NEVER HAPPEN nullBait.b1 = b; // implicit null pointer exception } }</span></span></code> </pre> <br><p>         ,    ,      .     <code>goodOldLoop</code>       <code>this.bunn</code>    ,  <code>for-each</code>     ,        (,  Java Concurrency In Practice   "  ").      . </p><br><p>    : "      ?   , <code>Blackhole::consume</code> —   JMH       .  ,  ,       ?" </p><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>   ? ?  ,    : </p><br><pre> <code class="java hljs">E[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;E&gt; fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>  <code>Iterable::forEach</code> !        ,   ,        ,       (   JDK 13): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); } //Arrays$ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } //CopyOnWriteArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (Object x : getArray()) { @SuppressWarnings("unchecked") E e = (E) x; action.accept(e); } } //ArrayDeque public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final Object[] es = elements; for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i &lt; to; i++) action.accept(elementAt(es, i)); if (to == end) { if (end != tail) throw new ConcurrentModificationException(); break; } } }</span></span></code> </pre> <br><p>     ,          . ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> <code>Collections.nCopies()::forEach</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(action); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n; i++) { action.accept(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } }</code> </pre> <br><p>            , . .   <code>this.n</code>  <code>this.element</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopiesList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> E element; CopiesList(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, E e) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; element = e; }</code> </pre> <br><p>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> <code>@Stable</code> . </p><br><p>  :  99   100  ,     ,    1   100,             .     ,     . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a>          "  volatile". </p><br><h4 id="eho-voyny">   </h4><br><p>      ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.Integer @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); }</span></span></code> </pre> <br><p> -   ,         ( <code>java.lang.Integer</code> , <code>java.lang.Long</code> , <code>java.lang.Short</code> , <code>java.lang.Byte</code> , <code>java.lang.Character</code> ).  ,     ,     </p><br><pre> <code class="java hljs">Integer intgr = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>    . </p><br><p>      : </p><br><pre> <code class="java hljs">Integer intgr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>        ,         ,       <code>Integer::valueOf</code>   . </p><br><p>         :      .                ,   ,      ""  (         ).   ,        ,         <code>Integer::valueOf</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"  "</a> . </p><br><p>   . ,              . ,       .      ,    ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443206/">https://habr.com/ru/post/pt443206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443196/index.html">Nem um minuto offline - Escolhendo um roteador LTE industrial</a></li>
<li><a href="../pt443198/index.html">Mark Zuckerberg diz que o Facebook está trabalhando em uma interface neural para ler pensamentos</a></li>
<li><a href="../pt443200/index.html">Hackers iranianos roubam terabytes de dados da Citrix</a></li>
<li><a href="../pt443202/index.html">Comício contra o isolamento do Runet</a></li>
<li><a href="../pt443204/index.html">Frontend Weekly Digest (4-10 de março de 2019)</a></li>
<li><a href="../pt443208/index.html">Mouse corporativo</a></li>
<li><a href="../pt443210/index.html">Tutorial Reagir Parte 21: Segunda lição e workshop de renderização condicional</a></li>
<li><a href="../pt443212/index.html">Tutorial React, Parte 22: Sétima etapa do trabalho em um aplicativo TODO, baixando dados de fontes externas</a></li>
<li><a href="../pt443214/index.html">Tutorial Reagir Parte 23: Primeira lição sobre formulários</a></li>
<li><a href="../pt443216/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 355 (4 a 10 de março de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>