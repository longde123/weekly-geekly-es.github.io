<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø üÜï üë®‚Äçüë®‚Äçüë¶‚Äçüë¶ Minas em desempenho est√£o esperando nos bastidores ‚úåüèº ‚ÜñÔ∏è üëçüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Neste artigo, falarei sobre minas colocadas sob o desempenho, bem como sua detec√ß√£o (preferencialmente antes da explos√£o) e descarte. 
 Uma imagem par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Minas em desempenho est√£o esperando nos bastidores</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443206/"><p>  Neste artigo, falarei sobre minas colocadas sob o desempenho, bem como sua detec√ß√£o (preferencialmente antes da explos√£o) e descarte. </p><br><div class="spoiler">  <b class="spoiler_title">Uma imagem para atrair a aten√ß√£o</b> <div class="spoiler_text"><p><img src="https://ic.pics.livejournal.com/ivagkin/26880913/58954/58954_original.jpg" alt="imagem"></p></div></div><a name="habracut"></a><br><h4 id="chto-takoe-mina">  O que √© uma mina? </h4><br><p>  Vamos come√ßar com o que est√° nas origens de qualquer conhecimento - com defini√ß√£o.  Os antigos disseram que nomear corretamente significa entender corretamente.  Eu acho que a defini√ß√£o de uma mina com desempenho √© melhor expressa por contraste com um erro claro, por exemplo, </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String... strings)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (String str : strings) { result += str; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  At√© desenvolvedores iniciantes sabem que as linhas s√£o imut√°veis ‚Äã‚Äãe col√°-las em um loop n√£o significa adicionar dados ao final de uma linha existente, mas criar uma <strong>nova</strong> linha a cada passagem.  Se voc√™ estiver enganado, n√£o desanime - a ‚ÄúIdeia‚Äù o alertar√° imediatamente sobre o perigo, e o ‚ÄúSonar‚Äù certamente inundar√° sua assembl√©ia. </p><br><p>  Mas esse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo</a> atrair√° muito menos aten√ß√£o e a Idea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">antes da vers√£o 2018.2</a> ) ficar√° em sil√™ncio: </p><br><pre> <code class="java hljs">Long total = <span class="hljs-number"><span class="hljs-number">0L</span></span>; List&lt;Long&gt; totals = query.getResultList(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Long element : totals) { total += element == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : element; }</code> </pre> <br><p>  O problema aqui √© o mesmo: os inv√≥lucros para tipos simples s√£o imut√°veis, o que significa adicionar 5 unidades ao n√∫mero do objeto significa criar um novo inv√≥lucro e gravar o n√∫mero 6 nele. </p><br><p>  A piada aqui √© a presen√ßa em Java de duas representa√ß√µes de certos tipos de dados - simples e objeto, bem como sua transforma√ß√£o autom√°tica por meio da pr√≥pria linguagem.  Por causa disso, muitos desenvolvedores novatos pensam algo assim: "Bem, a execu√ß√£o de alguma forma os transforma l√° por si s√≥, √© apenas um n√∫mero". </p><br><p>  De fato, nem tudo √© t√£o simples.  Pegue a <a href="">refer√™ncia</a> e tente adicionar os n√∫meros da maneira especificada: </p><br><div class="spoiler">  <b class="spoiler_title">De repente, saiu muito, muito barato (a seguir JDK 11, a menos que explicitamente indicado de outra forma)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"> (size) Mode Cnt Score Error Units wrapper 10 avgt 100 23,5 ¬± 0,1 ns/op wrapper 100 avgt 100 352,3 ¬± 2,1 ns/op wrapper 1000 avgt 100 4424,5 ¬± 25,2 ns/op wrapper 10 avgt 100 0 ¬± 0 B/op wrapper 100 avgt 100 1872 ¬± 0 B/op wrapper 1000 avgt 100 23472 ¬± 0 B/op</code> </pre> <br><p>  Compare com um tipo simples: </p><br><pre> <code class="plaintext hljs">primitive 10 avgt 100 6,4 ¬± 0,0 ns/op primitive 100 avgt 100 39,8 ¬± 0,1 ns/op primitive 1000 avgt 100 252,5 ¬± 1,3 ns/op primitive 10 avgt 100 0 ¬± 0 B/op primitive 100 avgt 100 0 ¬± 0 B/op primitive 1000 avgt 100 0 ¬± 0 B/op</code> </pre> </div></div><br><p>  A partir daqui, derivamos uma das defini√ß√µes de minas em desempenho - este √© um c√≥digo que n√£o chama a aten√ß√£o, n√£o √© detectado (pelo menos no momento em que voc√™ o encontrou) pelos analisadores est√°ticos, mas pode desacelerar em alguns usos.  No nosso caso, enquanto a soma n√£o excede 127 objetos, o cache √© retirado e <code>Long</code> apenas 4 vezes mais lento que o <code>long</code> .  No entanto, para uma matriz de tamanho 100, a velocidade √© quase 10 vezes menor. </p><br><h4 id="bolshie-melochi">  Grandes pequenas coisas </h4><br><p>  √Äs vezes, uma pequena mudan√ßa, que <em>quase</em> n√£o muda o significado da execu√ß√£o, em <em>algumas</em> circunst√¢ncias se torna um freio forte. </p><br><p>  Suponha que tenhamos um c√≥digo: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); if (info == null) { info = getAlias.apply(alias); cache.put(alias, info); } return info; }</span></span></code> </pre> <br><p>  Como √© a l√≥gica do m√©todo? </p><br><div class="spoiler">  <b class="spoiler_title">N√£o se apresse em espionar, pense</b> <div class="spoiler_text"><p>  Este √© <code>ConcurrentHashMap::computeIfAbsent</code> ! </p></div></div><br><p>  Temos o "oito" e podemos melhorar o c√≥digo de maneira interessante: substitua 6 linhas por uma, tornando o c√≥digo mais curto e f√°cil de entender.  A prop√≥sito, os conhecedores de multithreading provavelmente <code>ConcurrentHashMap::computeIfAbsent</code> outra melhoria que <code>ConcurrentHashMap::computeIfAbsent</code> traz consigo, mas um pouco mais tarde;) </p><br><p>  Vamos realizar um √≥timo pensamento: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.data.convert.CustomConversions$ConversionTargetsCache Map&lt;Object, TypeInformation&lt;?&gt;&gt; cache = new ConcurrentHashMap&lt;&gt;(); private TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { return cache.computeIfAbsent(alias, getAlias); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Reunidos, iniciados, choraram</b> <div class="spoiler_text"><p>  Para ver o tamanho completo, clique com o bot√£o direito do mouse na imagem e selecione "Abrir imagem em uma nova guia" <br><img src="https://habrastorage.org/getpro/habr/post_images/9f0/2aa/0e0/9f02aa0e028903e85a63d08207d93509.png" alt="imagem"></p></div></div><br><p>  Enquanto o aplicativo trabalhava com um thread, tudo era mais ou menos bom.  Os fluxos tornaram-se mais e pioraram significativamente.  Verificou- <code>ConcurrentHashMap::computeIfAbsent</code> que <code>ConcurrentHashMap::computeIfAbsent</code> bloqueado, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mesmo que a chave <strong>j√° tenha sido</strong> adicionada ao dicion√°rio</a> .  E esse se tornou o motivo de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bug</a> no Spring Date Mongo. </p><br><p>  Voc√™ pode verificar isso com uma <a href="">medi√ß√£o</a> simples ("oito").  Aqui est√° sua conclus√£o: </p><br><pre> <code class="plaintext hljs">Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 19,405 ¬± 0,411 ns/op getAndPut avgt 20 4,578 ¬± 0,045 ns/op 2 threads computeIfAbsent avgt 20 66,492 ¬± 2,036 ns/op getAndPut avgt 20 4,454 ¬± 0,110 ns/op 4 threads computeIfAbsent avgt 20 155,975 ¬± 8,850 ns/op getAndPut avgt 20 5,616 ¬± 2,073 ns/op 6 threads computeIfAbsent avgt 20 203,188 ¬± 10,547 ns/op getAndPut avgt 20 7,024 ¬± 0,456 ns/op 8 threads computeIfAbsent avgt 20 302,036 ¬± 31,702 ns/op getAndPut avgt 20 7,990 ¬± 0,144 ns/op</code> </pre> <br><p>  Isso pode ser claramente considerado um erro pelos desenvolvedores?  Na minha humilde opini√£o, n√£o, n√£o.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> diz: </p><br><blockquote>  Algumas tentativas de atualiza√ß√£o de opera√ß√µes neste mapa por outros encadeamentos podem ser bloqueadas enquanto a computa√ß√£o est√° em andamento; portanto, a computa√ß√£o deve ser curta e simples e n√£o deve tentar atualizar nenhum outro mapeamento desse mapa. </blockquote><p>  Em outras palavras, <code>ConcurrentHashMap::computeIfAbsent</code> fecha a c√©lula que cont√©m a chave do mundo externo (ao contr√°rio de <code>ConcurrentHashMap::get</code> ), o que geralmente √© verdadeiro, pois permite evitar a corrida ao chamar o m√©todo de diferentes threads quando a chave ainda n√£o foi adicionada. </p><br><p>  Por outro lado, no modo de opera√ß√£o mais comum, o c√°lculo do valor e sua liga√ß√£o com a chave ocorre apenas na primeira chamada e todas as chamadas subsequentes retornam apenas o valor calculado anteriormente.  Portanto, faz sentido alterar a l√≥gica para que o bloqueio seja definido apenas ao alterar.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Foi feito aqui</a> . </p><br><p>  Nas edi√ß√µes mais recentes (&gt; 8), <code>ConcurrentHashMap::computeIfAbsent</code> se <code>ConcurrentHashMap::computeIfAbsent</code> : </p><br><pre> <code class="plaintext hljs">JDK 11 Benchmark Mode Cnt Score Error Units 1 thread computeIfAbsent avgt 20 6,983 ¬± 0,066 ns/op getAndPut avgt 20 5,291 ¬± 1,220 ns/op 2 threads computeIfAbsent avgt 20 7,173 ¬± 0,249 ns/op getAndPut avgt 20 5,118 ¬± 0,395 ns/op 4 threads computeIfAbsent avgt 20 7,991 ¬± 0,447 ns/op getAndPut avgt 20 5,270 ¬± 0,366 ns/op 6 threads computeIfAbsent avgt 20 11,919 ¬± 0,865 ns/op getAndPut avgt 20 7,249 ¬± 0,199 ns/op 8 threads computeIfAbsent avgt 20 14,360 ¬± 0,892 ns/op getAndPut avgt 20 8,511 ¬± 0,229 ns/op</code> </pre> <br><p>  Preste aten√ß√£o √† insidiosidade deste exemplo: o conte√∫do sem√¢ntico n√£o mudou muito, porque √† primeira vista usamos apenas uma sintaxe mais avan√ßada.  Ao mesmo tempo, enquanto o aplicativo √© executado em um thread, o usu√°rio quase n√£o sente a diferen√ßa!  √â assim que mudan√ßas aparentemente inofensivas <del>  o porco </del>  mina sob nosso desempenho. </p><br><div class="spoiler">  <b class="spoiler_title">Por que eu escrevi 'quase inalterado'</b> <div class="spoiler_text"><p>  <code>ConcurrentHashMap::computeIfAbsent</code> nem sempre √© intercambi√°vel com a express√£o <code>getAndPut</code> , porque <code>ConcurrentHashMap::computeIfAbsent</code> √© uma opera√ß√£o at√¥mica.  No mesmo c√≥digo </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TypeInformation&lt;?&gt; getFromCacheOrCreate(Alias alias) { TypeInformation&lt;?&gt; info = cache.get(alias); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { info = getAlias.apply(alias); cache.put(alias, info); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; }</code> </pre> <br><p>  devido √† falta de sincroniza√ß√£o externa <strong>, uma corrida aparece</strong> .  Se a fun√ß√£o passada para <code>ConcurrentHashMap::computeIfAbsent</code> para a chave especificada sempre retornar o mesmo valor, ent√£o esta √© uma corrida "segura", o m√°ximo que enfrentamos √© o c√°lculo do mesmo valor 2 ou mais vezes.  Se n√£o houver tais garantias, uma substitui√ß√£o mec√¢nica estar√° repleta de falhas na aplica√ß√£o.  Cuidado! </p></div></div><br><h4 id="eti-ruki-nichego-ne-menyali">  Essas m√£os n√£o mudaram nada </h4><br><p>  Tamb√©m acontece que o c√≥digo n√£o muda, mas de repente come√ßa a ficar mais lento. </p><br><p>  Imagine que somos confrontados com a tarefa de transformar os elementos de uma matriz em uma cole√ß√£o.  O mais l√≥gico seria usar o <code>Collection::addAll</code> , mas aqui est√° a m√° sorte - ele aceita a cole√ß√£o: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span></span>; }</code> </pre> <br><p>  A maneira mais f√°cil √© <code>Arrays::asList</code> a matriz em <code>Arrays::asList</code> .  Acontecer√° algo como </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.addAll(Arrays.asList(items)); }</code> </pre> <br><p>  Durante a revis√£o, colegas preocupados com o desempenho provavelmente nos dir√£o que existem dois problemas neste c√≥digo ao mesmo tempo: </p><br><ul><li>  agrupando uma matriz em uma lista (objeto extra) </li><li>  criando um iterador (outro objeto extra) e passando por ele </li></ul><br><p>  De fato, na implementa√ß√£o de refer√™ncia de <code>Collection::addAll</code> , veremos isso: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Collection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> modified = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (E e : c) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (add(e)) modified = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> modified; } }</code> </pre> <br><p>  Portanto, um iterador √© criado aqui e os elementos s√£o classificados usando-o.  Portanto, camaradas experientes oferecem sua solu√ß√£o: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Dentro do c√≥digo, com raz√£o, <em>parecendo</em> mais produtivo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (T element : elements) result |= c.add(element); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><p>  Primeiro, um iterador n√£o √© criado.  Em segundo lugar, o passe passa no ciclo de contagem usual, al√©m disso, as matrizes se encaixam bem nos caches, seus elementos est√£o localizados na mem√≥ria sequencialmente (o que significa que haver√° poucas falhas de cache) e o acesso a eles pelo √≠ndice √© muito r√°pido.  Bem, tamb√©m n√£o √© criada uma lista de wrapper.  Parece bom e bom som. </p><br><p>  Finalmente, os colegas citam ultima ratio regum: documentation.  E ali, cinza no branco (ou verde no preto) diz: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * ... * The behavior of this convenience method is identical to that of * c.addAll(Arrays.asList(elements)), but this method is likely * to run significantly faster under most implementations. &lt;---- * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@since</span></span></span><span class="hljs-comment"> 1.5 */</span></span> <span class="hljs-meta"><span class="hljs-meta">@SafeVarargs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; c, T... elements)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Ou seja, os pr√≥prios desenvolvedores (e em quem eles devem acreditar, se n√£o eles?) Escreva que, para a maioria das implementa√ß√µes, o m√©todo utilit√°rio funciona <em>muito</em> mais r√°pido.  E ele √© realmente mais r√°pido.  As vezes </p><br><p>  A <a href="">refer√™ncia</a> , que lan√ßaremos para o <code>HashSet</code> no G8, ajudar√° a <code>HashSet</code> : </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 155,2 ¬± 2,8 ns/op addAll HashSet 100 avgt 100 1884,4 ¬± 37,4 ns/op addAll HashSet 1000 avgt 100 17917,3 ¬± 298,8 ns/op collectionsAddAll HashSet 10 avgt 100 136,1 ¬± 0,8 ns/op collectionsAddAll HashSet 100 avgt 100 1538,3 ¬± 31,4 ns/op collectionsAddAll HashSet 1000 avgt 100 15168,6 ¬± 289,4 ns/op</code> </pre> <br><p>  Parece que os camaradas mais experientes estavam certos.  Quase. </p><br><p>  Nas edi√ß√µes posteriores (por exemplo, em 11), o brilho do m√©todo utilit√°rio desaparecer√° um pouco: </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units addAll HashSet 10 avgt 100 143,1 ¬± 0,6 ns/op addAll HashSet 100 avgt 100 1738,4 ¬± 7,3 ns/op addAll HashSet 1000 avgt 100 16853,9 ¬± 101,0 ns/op collectionsAddAll HashSet 10 avgt 100 132,1 ¬± 1,1 ns/op collectionsAddAll HashSet 100 avgt 100 1661,1 ¬± 7,1 ns/op collectionsAddAll HashSet 1000 avgt 100 15450,9 ¬± 93,9 ns/op</code> </pre> <br><p>  Pode-se ver que n√£o estamos falando de nenhum "muito mais r√°pido".  E se repetirmos o experimento para <code>ArrayList</code> -a, acontece que o m√©todo utilit√°rio come√ßa a perder muito (quanto mais forte): </p><br><pre> <code class="plaintext hljs">Benchmark (collection) (size) Mode Cnt Score Error Units JDK 8 addAll ArrayList 10 avgt 100 38,5 ¬± 0,5 ns/op addAll ArrayList 100 avgt 100 188,4 ¬± 7,0 ns/op addAll ArrayList 1000 avgt 100 1278,8 ¬± 42,9 ns/op collectionsAddAll ArrayList 10 avgt 100 62,7 ¬± 0,7 ns/op collectionsAddAll ArrayList 100 avgt 100 495,1 ¬± 2,0 ns/op collectionsAddAll ArrayList 1000 avgt 100 4892,5 ¬± 48,0 ns/op JDK 11 addAll ArrayList 10 avgt 100 26,1 ¬± 0,0 ns/op addAll ArrayList 100 avgt 100 161,1 ¬± 0,4 ns/op addAll ArrayList 1000 avgt 100 1276,7 ¬± 3,7 ns/op collectionsAddAll ArrayList 10 avgt 100 41,6 ¬± 0,0 ns/op collectionsAddAll ArrayList 100 avgt 100 492,6 ¬± 1,5 ns/op collectionsAddAll ArrayList 1000 avgt 100 6792,7 ¬± 165,5 ns/op</code> </pre> <br><p>  N√£o h√° nada inesperado aqui, o <code>ArrayList</code> constru√≠do em torno de um array, portanto os desenvolvedores redefiniram de maneira previdente o <code>Collection::addAll</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span></span></span><span class="hljs-function"> </span></span>{ Object[] a = c.toArray(); modCount++; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numNew = a.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; Object[] elementData; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (numNew &gt; (elementData = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elementData).length - (s = size)) elementData = grow(s + numNew); System.arraycopy(a, <span class="hljs-number"><span class="hljs-number">0</span></span>, elementData, s, numNew); &lt;---    size = s + numNew; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre> <br><p>  Agora de volta √†s nossas minas.  Suponha que, no entanto, aceitemos a solu√ß√£o proposta na revis√£o e deixemos este c√≥digo: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addItems</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;T&gt; collection)</span></span></span><span class="hljs-function"> </span></span>{ T[] items = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Collections.addAll(collection, items); }</code> </pre> <br><p>  Por enquanto, est√° tudo bem, mas depois de adicionar novas funcionalidades, o m√©todo √†s vezes fica quente e come√ßa a desacelerar.  Abrimos c√≥digos fonte - o c√≥digo n√£o mudou.  A quantidade de dados √© a mesma.  E o desempenho caiu muito.  Este √© outro tipo meu. </p><br><p>  Descubra o depurador e encontre o belo: </p><br><p><img src="https://habrastorage.org/webt/nw/og/mu/nwogmu0_mvl-ix_hdyoxdaoydik.png"></p><br><p>  Observe: n√£o alteramos o algoritmo, a quantidade de dados processados ‚Äã‚Äãn√£o mudou, mas sua natureza mudou e um problema de desempenho foi iniciado em nosso c√≥digo: </p><br><pre> <code class="plaintext hljs"> Java 8 Java 11  addAll 10 56,9 25,2 ns/op collectionsAddAll 10 352,2 142,9 ns/op addAll 100 159,9 84,3 ns/op collectionsAddAll 100 4607,1 3964,3 ns/op addAll 1000 1244,2 760,2 ns/op collectionsAddAll 1000 355796,9 364677,0 ns/op</code> </pre> <br><p>  Em matrizes grandes, a diferen√ßa entre <code>Collections::addAll</code> e <code>Collection::addAll</code> √© modesta em 500 vezes.  O fato √© que <code>COWList</code> n√£o apenas expande a matriz existente, mas cria uma nova sempre que elementos s√£o adicionados: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(E e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (lock) { Object[] es = getArray(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = es.length; es = Arrays.copyOf(es, len + <span class="hljs-number"><span class="hljs-number">1</span></span>); &lt;----    es[len] = e; setArray(es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } }</code> </pre> <br><p><del>  Quem √© o culpado? </del></p><br><div class="spoiler">  <b class="spoiler_title">O que fazer</b> <div class="spoiler_text"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://bugs.openjdk.java.net/browse/JDK-8193031</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://cr.openjdk.java.net/~martin/webrevs/jdk/Collections-addAll/</a> </p></div></div><br><p>  O principal problema aqui √© que o <code>Collections::addAll</code> aceita uma interface, enquanto o m√©todo <code>addAll</code> n√£o <code>addAll</code> corpo.  Nenhum corpo - nenhum neg√≥cio, portanto, a documenta√ß√£o √© escrita com base na implementa√ß√£o existente em <code>AbstractCollection::addAll</code> , que √© um algoritmo generalizado aplic√°vel a todas as cole√ß√µes.  Isso significa que implementa√ß√µes mais espec√≠ficas de estruturas de dados que est√£o em um n√≠vel mais baixo de abstra√ß√£o podem alterar esse comportamento. </p><br><div class="spoiler">  <b class="spoiler_title">Agora humanamente</b> <div class="spoiler_text"><pre> <code class="java hljs"> Collection::addAll ‚Äì   AbstractCollection::addAll ‚Äì   &lt;---    ArrayList::addAll HashSet::addAll ‚Äì   &lt;---      COWList::addAll</code> </pre> </div></div><br><h4 id="eschyo-ob-abstrakciyah">  Mais sobre abstra√ß√µes </h4><br><p>  J√° que estamos falando de n√≠veis de abstra√ß√£o, vou lhe contar um exemplo da vida. </p><br><p>  Vamos comparar essas duas maneiras de salvar o en√©simo n√∫mero de entidades no banco de dados: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  √Ä primeira vista, o desempenho de ambos os m√©todos n√£o deve ser muito diferente, porque </p><br><ul><li>  nos dois casos, o mesmo n√∫mero de entidades ser√° armazenado no banco de dados </li><li>  se a tecla for retirada da sequ√™ncia, o n√∫mero de chamadas ser√° o mesmo </li><li>  a quantidade de dados transferidos √© a mesma </li></ul><br><p>  <code>SimpleJpaRepository::saveAndFlush</code> para o <code>SimpleJpaRepository::saveAndFlush</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveAndFlush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ S result = save(entity); flush(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flush</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ em.flush(); }</code> </pre> <br><p>  O ponto escuro aqui √© o m√©todo <code>flush()</code> .  Por que burro?  Parece-me que sua divulga√ß√£o na interface <code>JpaRepository</code> foi um erro dos desenvolvedores.  Vou tentar justificar meu pensamento.  Normalmente, esse m√©todo n√£o √© usado pelo desenvolvedor, porque a chamada para <code>EntityManager::flush</code> vinculada √† conclus√£o de uma transa√ß√£o controlada pelo Spring: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     @Transactional public void method() { &lt;--  Session::open /*.*/ } &lt;--  Session::flush</span></span></code> </pre> <br><p>  Observe: O <code>EntityManager</code> faz parte da especifica√ß√£o <code>JPA</code> implementada no Hibernate como uma sess√£o (interface Session e classe SessionImpl, respectivamente).  Spring Date √© uma estrutura executada em cima de um ORM, neste caso, em cima do Hibernate.  Acontece que o <code>JpaRepository::saveAndFlush</code> nos d√° acesso aos n√≠veis mais baixos da API, embora a tarefa da estrutura seja ocultar os detalhes de baixo n√≠vel (a situa√ß√£o √© um pouco semelhante √† hist√≥ria insegura no JDK). <br>  No nosso caso, ao usar <code>JpaRepository::saveAndFlush</code> entramos nas camadas inferiores do aplicativo, quebrando algo. </p><br><div class="spoiler">  <b class="spoiler_title">Tome seu tempo para espreitar, pense por si mesmo</b> <div class="spoiler_text"><p>  A capacidade do Hibernate de enviar dados em lotes est√° quebrada, um m√∫ltiplo da configura√ß√£o <code>jdbc.batch_size</code> , especificada em <code>application.yml</code> : </p><br><pre> <code class="plaintext hljs">spring: jpa: properties: hibernate: jdbc.batch_size: 500</code> </pre> <br><p>  O trabalho do Hibernate √© baseado em eventos, portanto, quando voc√™ salva 1000 entidades como esta </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.save(e); } }</code> </pre> <br><p>  chamar <code>repository.save(e)</code> n√£o salva instantaneamente.  Em vez disso, √© criado um evento que est√° na fila.  Ap√≥s a conclus√£o da transa√ß√£o, os dados s√£o mesclados usando <code>EntityManager::flush</code> , que divide as inser√ß√µes / atualiza√ß√µes em v√°rios pacotes de <code>jdbc.batch_size</code> e cria solicita√ß√µes a partir deles.  No nosso caso, <code>jdbc.batch_size: 500</code> , portanto, salvar 1000 entidades na realidade significa apenas 2 solicita√ß√µes. </p><br><p>  Mas com uma descarga manual da sess√£o a cada passagem do ciclo </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { SimpleEntity e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleEntity(); repository.saveAndFlush(e); } }</code> </pre> <br><p>  a fila √© limpa e salvar 1000 entidades significa 1000 consultas. </p></div></div><br><p>  Assim, interferir nas camadas inferiores do aplicativo pode facilmente se tornar uma mina, e n√£o apenas uma mina de produtividade (consulte Inseguro e seu uso n√£o controlado). </p><br><p>  Quanto diminui a velocidade?  Tome o melhor caso (para n√≥s) - o banco de dados est√° no mesmo host que o aplicativo.  Minha <a href="">medida</a> mostra a seguinte imagem: </p><br><pre> <code class="plaintext hljs"> (entityCount) Mode Cnt Score Error Units bulkSave 10 ss 500 16,613 ¬± 1,714 ms/op bulkSave 100 ss 500 31,371 ¬± 1,453 ms/op bulkSave 1000 ss 500 35,687 ¬± 1,973 ms/op bulkSaveUsingFlush 10 ss 500 32,653 ¬± 2,166 ms/op bulkSaveUsingFlush 100 ss 500 61,983 ¬± 6,304 ms/op bulkSaveUsingFlush 1000 ss 500 184,814 ¬± 6,976 ms/op</code> </pre> <br><p>  Obviamente, se o banco de dados estiver localizado em um host remoto, o custo da transfer√™ncia de dados diminuir√° cada vez mais o desempenho √† medida que o volume de dados aumenta. </p><br><p>  Assim, trabalhar no n√≠vel errado de abstra√ß√£o pode facilmente criar uma bomba-rel√≥gio.  A prop√≥sito, em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um dos meus artigos anteriores</a> , falei sobre uma tentativa curiosa de melhorar o <code>StringBuilder</code> -a: l√° n√£o <code>StringBuilder</code> √™xito exatamente ao tentar entrar em um n√≠vel de c√≥digo mais abstrato. </p><br><h4 id="granicy-minnyh-poley">  Fronteiras do campo minado </h4><br><p>  Vamos jogar um sapador?  Encontre o meu: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); Assert.notNull(key, "Null key ..." + context.metadata.operation); // ... return key; }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Encontrou?</b>  <b class="spoiler_title">Verifique a resposta correta.</b> <div class="spoiler_text"><pre> <code class="java hljs"> | \ / <span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport | \ / Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); | \ / Assert.notNull(key, "Null key ..." + context.metadata.operation); return key; }</span></span></code> </pre> </div></div><br><p>  "Voc√™ est√° brincando comigo?", Exclama o cr√≠tico. "Mas h√° apenas uma colagem de duas linhas? O que isso significa em E. sangrenta?"  Deixe-me chamar sua aten√ß√£o para o fato de eu destacar n√£o apenas a colagem de strings, mas tamb√©m o nome da classe e o nome do m√©todo.  De fato, o perigo de colar strings n√£o est√° em si mesmo, mas no que acontece no m√©todo que cria as chaves para o cache, ou seja, em certos cen√°rios, teremos muitos acessos a esse m√©todo, o que significa muitas linhas de lixo. <br>  Portanto, uma mensagem de erro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deve ser criada apenas</a> quando esse erro √© realmente lan√ßado: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// org.springframework.cache.interceptor.CacheAspectSupport Object generateKey(CacheOperationContext ctx, Object result) { Object key = ctx.generateKey(result); if (key == null) { throw new IAE("Null key ..." + context.metadata.operation); } // ... return key; }</span></span></code> </pre> <br><p>  Assim, os campos minados t√™m limites - √© a quantidade de dados, a frequ√™ncia de acesso ao m√©todo, etc. indicadores quantitativos, ao atingir e exceder os quais uma leve desvantagem se torna estatisticamente significativa. </p><br><p>  Por outro lado, esse √© o recurso, ao qual a complica√ß√£o do c√≥digo n√£o oferece uma melhoria significativa (mensur√°vel). </p><br><p>  Essa √© outra conclus√£o para o desenvolvedor: na maioria dos casos, enganar √© ruim, levando a uma complica√ß√£o sem sentido do c√≥digo.  Em 99 casos em 100, n√£o ganhamos nada. </p><br><p>  Deve-se lembrar que sempre h√° </p><br><h4 id="tot-samyy-sotyy-sluchay">  O cent√©simo caso </h4><br><p>  Aqui est√° o c√≥digo que Nitzan Wakart fornece em seu artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A vol√°til surpresa de leitura</a> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@BenchmarkMode</span></span>(Mode.AverageTime) <span class="hljs-meta"><span class="hljs-meta">@OutputTimeUnit</span></span>(TimeUnit.NANOSECONDS) <span class="hljs-meta"><span class="hljs-meta">@State</span></span>(Scope.Thread) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoopyBenchmarks</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Param</span></span>({ <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-string"><span class="hljs-string">"1024"</span></span>, <span class="hljs-string"><span class="hljs-string">"32768"</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-meta"><span class="hljs-meta">@Setup</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ bunn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[size]; } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { <span class="hljs-comment"><span class="hljs-comment">// good old C style for (the win?) fox.consume(bunn[y]); } } @Benchmark public void sweetLoop(Blackhole fox) { for (byte bunny : bunn) { // syntactic sugar loop goodness fox.consume(bunny); } } }</span></span></code> </pre> <br><p>  Quando configuramos a experi√™ncia, descobriremos uma diferen√ßa incr√≠vel entre as duas maneiras de iterar em uma matriz: </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoop 32 46.630 0.097 ns/op goodOldLoop 1024 1199.338 0.705 ns/op goodOldLoop 32768 37813.600 56.081 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>  Aqui, um desenvolvedor inexperiente pode fazer uma conclus√£o t√£o √≥bvia e comparada: passar por uma matriz usando a nova sintaxe funciona mais r√°pido que um ciclo de contagem.  Esta √© a conclus√£o errada, porque vale a pena alterar um <code>goodOldLoop</code> o m√©todo <code>goodOldLoop</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoopReturns</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] sunn = bunn; <span class="hljs-comment"><span class="hljs-comment">// make a local copy of the field for (int y = 0; y &lt; sunn.length; y++) { fox.consume(sunn[y]); } }</span></span></code> </pre> <br><p>  e seu desempenho √© compar√°vel ao do m√©todo <code>sweetLoop</code> "mais r√°pido": </p><br><pre> <code class="plaintext hljs">Benchmark (size) Score Score error Units goodOldLoopReturns 32 19.306 0.045 ns/op goodOldLoopReturns 1024 476.493 1.190 ns/op goodOldLoopReturns 32768 14292.286 16.046 ns/op sweetLoop 32 19.304 0.010 ns/op sweetLoop 1024 475.141 1.227 ns/op sweetLoop 32768 14295.800 36.071 ns/op</code> </pre> <br><p>     <code>Blackhole::consume</code> : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//... public volatile byte b1, b2; public volatile BlackholeL2 nullBait = null; /** * Consume object. This call provides a side effect preventing JIT to eliminate dependent computations. * * @param b object to consume. */ public final void consume(byte b) { if (b == b1 &amp; b == b2) { // SHOULD NEVER HAPPEN nullBait.b1 = b; // implicit null pointer exception } }</span></span></code> </pre> <br><p>         ,    ,      .     <code>goodOldLoop</code>       <code>this.bunn</code>    ,  <code>for-each</code>     ,        (,  Java Concurrency In Practice   "  ").      . </p><br><p>    : "      ?   , <code>Blackhole::consume</code> ‚Äî   JMH       .  ,  ,       ?" </p><br><p>          : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">goodOldLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Blackhole fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>   ? ?  ,    : </p><br><pre> <code class="java hljs">E[] bunn; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Consumer&lt;E&gt; fox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; bunn.length; y++) { fox.consume(bunn[y]); } }</code> </pre> <br><p>  <code>Iterable::forEach</code> !        ,   ,        ,       (   JDK 13): </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final int expectedModCount = modCount; final Object[] es = elementData; final int size = this.size; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) action.accept(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); } //Arrays$ArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (E e : a) { action.accept(e); } } //CopyOnWriteArrayList public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); for (Object x : getArray()) { @SuppressWarnings("unchecked") E e = (E) x; action.accept(e); } } //ArrayDeque public void forEach(Consumer&lt;? super E&gt; action) { Objects.requireNonNull(action); final Object[] es = elements; for (int i = head, end = tail, to = (i &lt;= end) ? end : es.length; ; i = 0, to = end) { for (; i &lt; to; i++) action.accept(elementAt(es, i)); if (to == end) { if (end != tail) throw new ConcurrentModificationException(); break; } } }</span></span></code> </pre> <br><p>     ,          . ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a> <code>Collections.nCopies()::forEach</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Consumer&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> E&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ Objects.requireNonNull(action); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n; i++) { action.accept(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } }</code> </pre> <br><p>            , . .   <code>this.n</code>  <code>this.element</code>       : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CopiesList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractList</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RandomAccess</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> E element; CopiesList(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, E e) { <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.n = n; element = e; }</code> </pre> <br><p>  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> <code>@Stable</code> . </p><br><p>  :  99   100  ,     ,    1   100,             .     ,     . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a>          "  volatile". </p><br><h4 id="eho-voyny">   </h4><br><p>      ,   : </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//java.lang.Integer @HotSpotIntrinsicCandidate public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); }</span></span></code> </pre> <br><p> -   ,         ( <code>java.lang.Integer</code> , <code>java.lang.Long</code> , <code>java.lang.Short</code> , <code>java.lang.Byte</code> , <code>java.lang.Character</code> ).  ,     ,     </p><br><pre> <code class="java hljs">Integer intgr = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>    . </p><br><p>      : </p><br><pre> <code class="java hljs">Integer intgr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Integer(<span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br><p>        ,         ,       <code>Integer::valueOf</code>   . </p><br><p>         :      .                ,   ,      ""  (         ).   ,        ,         <code>Integer::valueOf</code> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"  "</a> . </p><br><p>   . ,              . ,       .      ,    ,      . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443206/">https://habr.com/ru/post/pt443206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443196/index.html">Nem um minuto offline - Escolhendo um roteador LTE industrial</a></li>
<li><a href="../pt443198/index.html">Mark Zuckerberg diz que o Facebook est√° trabalhando em uma interface neural para ler pensamentos</a></li>
<li><a href="../pt443200/index.html">Hackers iranianos roubam terabytes de dados da Citrix</a></li>
<li><a href="../pt443202/index.html">Com√≠cio contra o isolamento do Runet</a></li>
<li><a href="../pt443204/index.html">Frontend Weekly Digest (4-10 de mar√ßo de 2019)</a></li>
<li><a href="../pt443208/index.html">Mouse corporativo</a></li>
<li><a href="../pt443210/index.html">Tutorial Reagir Parte 21: Segunda li√ß√£o e workshop de renderiza√ß√£o condicional</a></li>
<li><a href="../pt443212/index.html">Tutorial React, Parte 22: S√©tima etapa do trabalho em um aplicativo TODO, baixando dados de fontes externas</a></li>
<li><a href="../pt443214/index.html">Tutorial Reagir Parte 23: Primeira li√ß√£o sobre formul√°rios</a></li>
<li><a href="../pt443216/index.html">O resumo de materiais frescos do mundo do front-end da √∫ltima semana n ¬∞ 355 (4 a 10 de mar√ßo de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>