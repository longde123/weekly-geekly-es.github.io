<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëï üë©‚Äçüëß‚Äçüëß üë° Interne HashMap in Java ‚ìÇÔ∏è ü§∞üèæ üë´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[Anmerkung des Autors der √úbersetzung] Die √úbersetzung wurde f√ºr die eigenen Bed√ºrfnisse angefertigt, aber wenn sich herausstellt, dass sie f√ºr jemand...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Interne HashMap in Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421179/"><p>  <em>[Anmerkung des Autors der √úbersetzung] Die √úbersetzung wurde f√ºr die eigenen Bed√ºrfnisse angefertigt, aber wenn sich herausstellt, dass sie f√ºr jemanden n√ºtzlich ist, ist die Welt zumindest ein wenig, aber besser geworden!</em>  <em>Originalartikel - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Interne Arbeitsweise von HashMap in Java</a></em> </p><br><p>  In diesem Artikel werden wir sehen, wie die get- und put-Methoden in der HashMap-Auflistung intern funktionieren.  Welche Operationen werden ausgef√ºhrt?  Wie Hashing passiert.  Wie der Wert per Schl√ºssel abgerufen wird.  Wie werden Schl√ºssel-Wert-Paare gespeichert? </p><a name="habracut"></a><br><p>  Wie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vorherigen Artikel</a> enth√§lt HashMap ein Array von Node und Node kann eine Klasse darstellen, die die folgenden Objekte enth√§lt: </p><br><ol><li>  int - hash </li><li>  K ist der Schl√ºssel </li><li>  V ist der Wert </li><li>  Knoten - n√§chster Punkt </li></ol><br><p> Jetzt werden wir sehen, wie alles funktioniert.  Zun√§chst betrachten wir den Hashing-Prozess. </p><br><h2 id="heshirovanie">  Hashing </h2><br><p>  Beim Hashing wird ein Objekt in eine Ganzzahlform konvertiert, die mit der Methode hashCode () ausgef√ºhrt wird.  Es ist sehr wichtig, die hashCode () -Methode korrekt zu implementieren, um die beste Leistung der HashMap-Klasse sicherzustellen. </p><br><p>  Hier verwende ich meine eigene Schl√ºsselklasse und kann auf diese Weise die hashCode () -Methode √ºberschreiben, um verschiedene Skripte zu demonstrieren.  Meine Schl√ºsselklasse: </p><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   Key    hashCode() //  equals() class Key { String key; Key(String key) { this.key = key; } @Override public int hashCode() { return (int)key.charAt(0); } @Override public boolean equals(Object obj) { return key.equals((String)obj); } }</span></span></code> </pre> <br><p>  Hier gibt die √ºberschriebene hashCode () -Methode den ASCII-Code des ersten Zeichens der Zeichenfolge zur√ºck.  Wenn also die ersten Zeichen der Zeichenfolge identisch sind, sind die Hash-Codes identisch.  Verwenden Sie in Ihren Programmen keine √§hnliche Logik. </p><br><p>  Dieser Code dient nur zu Demonstrationszwecken.  Da der HashCode einen Nullschl√ºssel akzeptiert, ist der Null-Hash-Code immer 0. </p><br><h2 id="metod-hashcode">  HashCode () -Methode </h2><br><p>  Die hashCode () -Methode wird verwendet, um den Hash-Code des Objekts abzurufen.  Die hashCode () -Methode der Object-Klasse gibt eine Ganzzahlspeicherreferenz <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">(Identity-Hash-Code</a> ) zur√ºck.  Die Signatur der <code>public native hashCode()</code> -Methode.  Dies deutet darauf hin, dass die Methode als native implementiert ist, da es in Java keine Methode gibt, um einen Verweis auf das Objekt abzurufen.  Sie k√∂nnen Ihre eigene Implementierung der hashCode () -Methode definieren.  In der HashMap-Klasse wird die hashCode () -Methode verwendet, um den Bucket und damit den Index zu berechnen. </p><br><h2 id="metod-equals">  Equals () -Methode </h2><br><p>  Die Methode equals wird verwendet, um zwei Objekte auf Gleichheit zu testen.  Die Methode ist in der Object-Klasse implementiert.  Sie k√∂nnen es in Ihrer eigenen Klasse √ºberschreiben.  In der HashMap-Klasse wird die Methode equals () verwendet, um die Schl√ºsselgleichheit zu √ºberpr√ºfen.  Wenn die Schl√ºssel gleich sind, gibt die Methode equals () true zur√ºck, andernfalls false. </p><br><h2 id="korziny-buckets">  K√∂rbe </h2><br><p>  Bucket ist das einzige Element des HashMap-Arrays.  Es wird zum Speichern von Knoten (Nodes) verwendet.  Zwei oder mehr Knoten k√∂nnen denselben Bucket haben.  In diesem Fall wird eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verkn√ºpfte Listendatenstruktur</a> verwendet, um Knoten zu verkn√ºpfen.  Die Kapazit√§t der Schaufeln ist unterschiedlich (Kapazit√§tseigenschaft).  Die Beziehung zwischen Schaufel und Kapazit√§t ist wie folgt: </p><br><pre> <code class="java hljs">capacity = number of buckets * load factor</code> </pre> <br><p>  Ein Bucket kann mehr als einen Knoten haben, dies h√§ngt von der Implementierung der hashCode () -Methode ab.  Je besser Ihre hashCode () -Methode implementiert ist, desto besser wird Ihr Bucket verwendet. </p><br><h2 id="vychislenie-indeksa-v-hashmap">  HashMap-Indexberechnung </h2><br><p>  Der Schl√ºssel-Hash-Code kann gro√ü genug sein, um ein Array zu erstellen.  Der generierte Hash-Code kann im Bereich eines Integer-Typs liegen. Wenn wir ein Array dieser Gr√∂√üe erstellen, k√∂nnen wir leicht eine outOfMemoryException erhalten.  Daher generieren wir einen Index, um die Gr√∂√üe des Arrays zu minimieren.  Im Wesentlichen wird die folgende Operation ausgef√ºhrt, um den Index zu berechnen: </p><br><pre> <code class="java hljs">index = hashCode(key) &amp; (n-<span class="hljs-number"><span class="hljs-number">1</span></span>).</code> </pre> <br><p>  Dabei ist n gleich der Anzahl der Buckets oder dem Wert der L√§nge des Arrays.  In unserem Beispiel betrachte ich n als Standardwert von 16. </p><br><ul><li>  <strong><em>anf√§nglich hashMap leer:</em></strong> hier ist die <strong><em>Hashmap-</em></strong> Gr√∂√üe 16: </li></ul><br><pre> <code class="java hljs">HashMap map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap();</code> </pre> <br><p>  HashMap: <br><img src="https://habrastorage.org/webt/wb/si/xe/wbsixe1oansrlnt_qfuay5kczra.jpeg"></p><br><ul><li>  <strong><em>Paare einf√ºgen Schl√ºsselwert:</em></strong> F√ºgen Sie am Ende der HashMap einen Paarschl√ºsselwert hinzu </li></ul><br><pre> <code class="java hljs">map.put(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Key(<span class="hljs-string"><span class="hljs-string">"vishal"</span></span>), <span class="hljs-number"><span class="hljs-number">20</span></span>);</code> </pre> <br><p>  Schritte: </p><br><ol><li><p>  Berechnen Sie den Schl√ºsselwert {"vishal"}.  Es wird als 118 generiert. </p><br></li><li><p>  Berechnen Sie den Index mit der <code>index</code> 6. </p><br></li><li><p>  Erstellen Sie ein Knotenobjekt. </p><br><pre> <code class="java hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash = <span class="hljs-number"><span class="hljs-number">118</span></span> <span class="hljs-comment"><span class="hljs-comment">// {"vishal"}  ,  //   Key Key key = {"vishal"} Integer value = 20 Node next = null }</span></span></code> </pre> <br></li><li><p>  Platzieren Sie das Objekt in Position mit Index 6, wenn der Platz frei ist. </p><br></li></ol><br><p>  HashMap sieht jetzt ungef√§hr so ‚Äã‚Äãaus: </p><br><p><img src="https://habrastorage.org/webt/es/4j/78/es4j78e-05gpk3babndygunccgq.jpeg"></p><br><ul><li>  <strong><em>Hinzuf√ºgen eines weiteren Schl√ºssel-Wert-Paares:</em></strong> F√ºgen Sie nun ein weiteres Paar hinzu </li></ul><br><pre> <code class="java hljs">map.put(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Key(<span class="hljs-string"><span class="hljs-string">"sachin"</span></span>), <span class="hljs-number"><span class="hljs-number">30</span></span>);</code> </pre> <br><p>  Schritte: </p><br><ol><li><p>  Berechnen Sie den Schl√ºsselwert {"sachin"}.  Es wird als 115 generiert. </p><br></li><li><p>  Berechnen Sie den Index mit der <code>index</code> 3. </p><br></li><li><p>  Erstellen Sie ein Knotenobjekt. </p><br><pre> <code class="java hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash = <span class="hljs-number"><span class="hljs-number">115</span></span> Key key = {<span class="hljs-string"><span class="hljs-string">"sachin"</span></span>} Integer value = <span class="hljs-number"><span class="hljs-number">30</span></span> Node next = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br></li><li><p>  Platzieren Sie das Objekt mit Index 3, wenn der Platz frei ist. </p><br></li></ol><br><p>  HashMap sieht jetzt ungef√§hr so ‚Äã‚Äãaus: </p><br><p><img src="https://habrastorage.org/webt/4b/ul/ie/4bulietxfhlblgw8vkvsqnnjz_s.jpeg"></p><br><ul><li>  <strong><em>Bei Kollisionen:</em></strong> F√ºgen Sie jetzt ein weiteres Paar hinzu </li></ul><br><pre> <code class="java hljs">map.put(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Key(<span class="hljs-string"><span class="hljs-string">"vaibhav"</span></span>), <span class="hljs-number"><span class="hljs-number">40</span></span>);</code> </pre> <br><p>  Schritte: </p><br><ol><li><p>  Berechnen Sie den Schl√ºsselwert {"vaibhav"}.  Es wird als 118 generiert. </p><br></li><li><p>  Berechnen Sie den Index mit der <code>index</code> 6. </p><br></li><li><p>  Erstellen Sie ein Knotenobjekt. </p><br><pre> <code class="java hljs">{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash = <span class="hljs-number"><span class="hljs-number">118</span></span> Key key = {<span class="hljs-string"><span class="hljs-string">"vaibhav"</span></span>} Integer value = <span class="hljs-number"><span class="hljs-number">20</span></span> Node next = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> }</code> </pre> <br></li><li><p>  Platzieren Sie das Objekt in Position mit Index 6, wenn der Platz frei ist. </p><br></li><li><p>  In diesem Fall existiert bereits ein anderes Objekt an der Position mit Index 6, dieser Fall wird als Kollision bezeichnet. </p><br></li><li><p>  In diesem Fall wird mit den Methoden hashCode () und equals () √ºberpr√ºft, ob beide Schl√ºssel identisch sind. </p><br></li><li><p>  Wenn die Schl√ºssel identisch sind, ersetzen Sie den aktuellen Wert durch einen neuen. </p><br></li><li><p>  Andernfalls verkn√ºpfen Sie das neue und das alte Objekt mithilfe der Datenstruktur "Verkn√ºpfte Liste", indem Sie einen Link zum n√§chsten Objekt im aktuellen Objekt angeben und beide unter Index 6 speichern. </p><br></li></ol><br><p>  HashMap sieht jetzt ungef√§hr so ‚Äã‚Äãaus: </p><br><p><img src="https://habrastorage.org/webt/ba/mo/sr/bamosrcidxmckp1bl_cqu4cn6ug.jpeg"></p><br><p>  <em>[Anmerkung des Autors der √úbersetzung] Das Bild stammt aus dem Originalartikel und enth√§lt zun√§chst einen Fehler.</em>  <em>Der Verweis auf das n√§chste Objekt im vishalen Objekt mit Index 6 ist nicht null, sondern enth√§lt einen Zeiger auf das Vaibhav-Objekt.</em> </p><br><ul><li>  <strong><em>Wir erhalten den Wert durch den Sachin-Schl√ºssel:</em></strong> </li></ul><br><pre> <code class="java hljs">map.get(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Key(<span class="hljs-string"><span class="hljs-string">"sachin"</span></span>));</code> </pre> <br><p>  Schritte: </p><br><ol><li><p>  Berechnen Sie den Hash-Code des {{sachin ¬ª} -Objekts.  Es wurde als 115 generiert. </p><br></li><li><p>  Berechnen Sie den Index mit der <code>index</code> 3. </p><br></li><li><p>  Gehen Sie zu Index 3 und vergleichen Sie den Schl√ºssel des ersten Elements mit dem vorhandenen Wert.  Wenn sie gleich sind, drehen Sie den Wert, andernfalls pr√ºfen Sie, ob das n√§chste Element vorhanden ist. </p><br></li><li><p>  In unserem Fall wird das Element gefunden und der R√ºckgabewert betr√§gt 30. </p><br></li></ol><br><ul><li>  <strong><em>Wir erhalten den Wert durch den Schl√ºssel vaibahv:</em></strong> </li></ul><br><pre> <code class="java hljs">map.get(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Key(<span class="hljs-string"><span class="hljs-string">"vaibhav"</span></span>));</code> </pre> <br><p>  Schritte: </p><br><ol><li><p>  Berechnen Sie den Hash-Code des Objekts {"vaibhav"}.  Es wurde als 118 generiert. </p><br></li><li><p>  Berechnen Sie den Index mit der <code>index</code> 6. </p><br></li><li><p>  Gehen Sie zu Index 6 und vergleichen Sie den Schl√ºssel des ersten Elements mit dem vorhandenen Wert.  Wenn sie gleich sind, drehen Sie den Wert, andernfalls pr√ºfen Sie, ob das n√§chste Element vorhanden ist. </p><br></li><li><p>  In diesem Fall wurde es nicht gefunden und das n√§chste Knotenobjekt ist nicht null. </p><br></li><li><p>  Wenn das n√§chste Knotenobjekt null ist, geben Sie null zur√ºck. </p><br></li><li><p>  Wenn das n√§chste Knotenobjekt nicht null ist, gehen Sie zu ihm und wiederholen Sie die ersten drei Schritte, bis das Element gefunden wird oder das n√§chste Knotenobjekt null ist. </p><br></li></ol><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Java    //   HashMap import java.util.HashMap; class Key { String key; Key(String key) { this.key = key; } @Override public int hashCode() { int hash = (int)key.charAt(0); System.out.println("hashCode for key: " + key + " = " + hash); return hash; } @Override public boolean equals(Object obj) { return key.equals(((Key)obj).key); } } // Driver class public class GFG { public static void main(String[] args) { HashMap map = new HashMap(); map.put(new Key("vishal"), 20); map.put(new Key("sachin"), 30); map.put(new Key("vaibhav"), 40); System.out.println(); System.out.println("Value for key sachin: " + map.get(new Key("sachin"))); System.out.println("Value for key vaibhav: " + map.get(new Key("vaibhav"))); } }</span></span></code> </pre> <br><p>  Fazit: </p><br><pre> <code class="bash hljs">hashCode <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key: vishal = 118 hashCode <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key: sachin = 115 hashCode <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key: vaibhav = 118 hashCode <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key: sachin = 115 Value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key sachin: 30 hashCode <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key: vaibhav = 118 Value <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key vaibhav: 40</code> </pre> <br><h2 id="izmeneniya-v-java-8">  √Ñnderungen in Java 8 </h2><br><p>  Wie wir bereits bei Kollisionen wissen, wird das Knotenobjekt in der Datenstruktur ‚ÄûVerkn√ºpfte Liste‚Äú gespeichert und die Methode equals () zum Vergleichen von Schl√ºsseln verwendet.  Dies sind Vergleiche, um den richtigen Schl√ºssel in einer verkn√ºpften Liste zu finden - eine lineare Operation, und im schlimmsten Fall ist die Komplexit√§t <em>O (n)</em> . </p><br><p>  Um dieses Problem in Java 8 zu beheben, werden nach Erreichen eines bestimmten Schwellenwerts ausgeglichene B√§ume anstelle von verkn√ºpften Listen verwendet.  Dies bedeutet, dass die HashMap zu Beginn die Objekte in einer verkn√ºpften Liste speichert. Nachdem jedoch die Anzahl der Elemente im Hash einen bestimmten Schwellenwert erreicht hat, erfolgt ein √úbergang zu ausgeglichenen B√§umen.  Dies verbessert die Leistung im schlimmsten Fall von O (n) auf O (log n). </p><br><h2 id="vazhnyy-moment">  Wichtiger Punkt </h2><br><ol><li>  Die Komplexit√§t der Operationen get () und put () ist nahezu konstant, bis ein erneutes Hashing durchgef√ºhrt wird. </li><li>  Wenn bei Kollisionen die Indizes von zwei oder mehr Knotenobjekten gleich sind, werden die Knotenobjekte unter Verwendung einer verkn√ºpften Liste verbunden, d. H.  Die Verkn√ºpfung zum zweiten Knotenobjekt wird im ersten, zum dritten im zweiten usw. gespeichert. </li><li>  Wenn der angegebene Schl√ºssel bereits in der HashMap vorhanden ist, wird der Wert √ºberschrieben. </li><li>  Der Null-Hash-Code ist 0. </li><li>  Wenn ein Objekt durch den Schl√ºssel erhalten wird, treten √úberg√§nge durch die verkn√ºpfte Liste auf, bis das Objekt gefunden wird oder die Verkn√ºpfung zum n√§chsten Objekt null ist. </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de421179/">https://habr.com/ru/post/de421179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de421167/index.html">Enge Sicherheitsl√ºcke in Wi-Fi-Controllern von D-Link</a></li>
<li><a href="../de421171/index.html">Stellen Sie DevOps MeetUp bereit</a></li>
<li><a href="../de421173/index.html">Benutzerdefinierte Google-Suchansicht</a></li>
<li><a href="../de421175/index.html">√úberwachung des Kubernetes-Clusters mit Prometheus</a></li>
<li><a href="../de421177/index.html">So gewinnen Sie einen Datenanalysespezialisten, wenn Ihr Unternehmen nicht einmal √ºber eine Website verf√ºgt</a></li>
<li><a href="../de421183/index.html">IBM patentiert Drohnen, die Emotionen unterscheiden und Menschen Kaffee bringen. Und wor√ºber kann man am Freitag noch schreiben?</a></li>
<li><a href="../de421187/index.html">Tiefes Lernen, um Bilder zu identifizieren</a></li>
<li><a href="../de421189/index.html">Migrieren einer Datenbank auf eine √§ltere Version von MS SQL Server</a></li>
<li><a href="../de421191/index.html">Wie einfach es f√ºr einen Handwerker ist, mit einem 3D-Kern zu tr√§umen</a></li>
<li><a href="../de421193/index.html">Audi PB18 e-tron</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>