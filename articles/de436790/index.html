<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♾ 🙏🏿 🏢 256 Zeilen nacktes C ++: Schreiben eines Raytracers von Grund auf in wenigen Stunden 🎎 💎 🙌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich veröffentliche das nächste Kapitel meines Vorlesungskurses über Computergrafik ( hier können Sie das Original auf Russisch lesen , obwohl die engl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256 Zeilen nacktes C ++: Schreiben eines Raytracers von Grund auf in wenigen Stunden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436790/">  Ich veröffentliche das nächste Kapitel meines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlesungskurses über Computergrafik</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier können Sie das</a> Original auf Russisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen</a> , obwohl die englische Version neuer ist).  Dieses Mal ist das Gesprächsthema das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeichnen von Szenen mithilfe von Raytracing</a> .  Wie üblich versuche ich, Bibliotheken von Drittanbietern zu meiden, da die Schüler dadurch unter die Haube schauen. <br><br>  Es gibt bereits viele ähnliche Projekte im Internet, aber fast alle zeigen fertige Programme, die äußerst schwer zu verstehen sind.  Hier zum Beispiel ein sehr berühmtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Programm, das auf eine Visitenkarte passt</a> .  Ein sehr beeindruckendes Ergebnis, aber das Verständnis dieses Codes ist sehr schwierig.  Mein Ziel ist es nicht zu zeigen, wie ich kann, sondern im Detail zu erklären, wie ich dies reproduzieren kann.  Darüber hinaus scheint mir diese Vorlesung nicht einmal als Schulungsmaterial für Computergrafik nützlich zu sein, sondern als Programmierwerkzeug.  Ich werde konsequent zeigen, wie man von Grund auf zum Endergebnis kommt: wie man ein komplexes Problem in elementare lösbare Stufen zerlegt. <br><br>  <i>Achtung: Es macht keinen Sinn, nur meinen Code zu betrachten und diesen Artikel nur mit einer Tasse Tee in der Hand zu lesen.</i>  <i>In diesem Artikel können Sie eine Tastatur greifen und Ihre eigene Engine schreiben.</i>  <i>Er wird sicherlich besser sein als meiner.</i>  <i>Oder ändern Sie einfach die Programmiersprache!</i> <br><br>  Also, heute werde ich zeigen, wie man solche Bilder zeichnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1>  Stufe eins: Speichern Sie das Bild auf der Festplatte </h1><br>  Ich möchte mich nicht mit Fenstermanagern, Maus- / Tastaturverarbeitung und dergleichen beschäftigen.  Das Ergebnis unseres Programms ist ein einfaches Bild, das auf der Festplatte gespeichert wird.  Das erste, was wir tun müssen, ist das Bild auf der Festplatte zu speichern.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> liegt der Code, mit dem Sie dies tun können.  Lassen Sie mich Ihnen die Hauptdatei geben: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br>  In der Hauptfunktion wird nur die Funktion render () aufgerufen, sonst nichts.  Was ist in der Funktion render () enthalten?  Zunächst definiere ich ein Bild als eindimensionales Array von Framebuffer-Werten vom Typ Vec3f. Dies sind einfache dreidimensionale Vektoren, die uns die Farbe (r, g, b) für jedes Pixel geben. <br><br>  Die Vektorklasse befindet sich in der Dateiometry.h, ich werde sie hier nicht beschreiben: Erstens ist dort alles trivial, einfache Manipulation von zwei- und dreidimensionalen Vektoren (Addition, Subtraktion, Zuweisung, Multiplikation mit einem Skalar, Skalarprodukt) und zweitens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">gbg</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat</a> es bereits im Rahmen einer Vorlesung über Computergrafik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausführlich beschrieben</a> . <br><br>  Ich speichere das Bild im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ppm-Format</a> .  Dies ist der einfachste Weg zum Speichern von Bildern, jedoch nicht immer der bequemste für die weitere Anzeige.  Wenn Sie in anderen Formaten speichern möchten, empfehle ich dennoch, eine Bibliothek eines Drittanbieters <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzuschließen</a> , z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stb</a> .  Dies ist eine wunderbare Bibliothek: Es reicht aus, eine Header-Datei stb_image_write.h in das Projekt aufzunehmen, und dies ermöglicht das Speichern auch in PNG, sogar in JPG. <br><br>  Insgesamt besteht das Ziel dieser Phase darin, sicherzustellen, dass wir a) ein Bild im Speicher erstellen und dort verschiedene Farbwerte schreiben können. B) das Ergebnis auf der Festplatte speichern, damit es in einem Programm eines Drittanbieters angezeigt werden kann.  Hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1>  Stufe zwei, die schwierigste: direktes Raytracing </h1><br>  Dies ist die wichtigste und schwierigste Phase der gesamten Kette.  Ich möchte eine Kugel in meinem Code definieren und auf dem Bildschirm anzeigen, ohne mich um Materialien oder Beleuchtung zu kümmern.  So sollte unser Ergebnis aussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br>  Der Einfachheit halber gibt es in meinem Repository ein Commit für jede Phase.  Mit Github können Sie Ihre Änderungen bequem anzeigen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier zum Beispiel</a> , was sich im zweiten Commit gegenüber dem ersten geändert hat. <br><br>  Zunächst: Was brauchen wir, um eine Kugel im Speicher des Computers darzustellen?  Vier Zahlen reichen uns: ein dreidimensionaler Vektor mit dem Mittelpunkt der Kugel und ein Skalar, der den Radius beschreibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  Die einzige nicht triviale Sache in diesem Code ist eine Funktion, mit der Sie überprüfen können, ob ein bestimmter Strahl (der von orig in Richtung dir stammt) unsere Kugel schneidet.  Eine detaillierte Beschreibung des Algorithmus zur Überprüfung des Schnittpunkts von Strahl und Kugel finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . Ich empfehle dringend, dies zu tun und meinen Code zu überprüfen. <br><br>  Wie funktioniert Raytracing?  Sehr einfach.  In der ersten Phase haben wir das Bild einfach mit einem Farbverlauf abgedeckt: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  Jetzt bilden wir für jedes Pixel einen Strahl, der vom Koordinatenzentrum kommt und durch unser Pixel geht, und prüfen, ob dieser Strahl unsere Kugel schneidet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br>  Wenn es keinen Schnittpunkt mit der Kugel gibt, setzen wir Farbe1, andernfalls Farbe2: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { ￼ [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } ￼ [...] }</span></span></code> </pre><br>  An dieser Stelle empfehle ich, einen Bleistift zu nehmen und alle Berechnungen auf Papier zu überprüfen, sowohl den Schnittpunkt eines Strahls mit einer Kugel als auch das Fegen eines Bildes mit Strahlen.  Für alle Fälle wird unsere Kamera von folgenden Faktoren bestimmt: <br><br><ul><li>  Bildbreite </li><li>  Bildhöhe </li><li>  Betrachtungswinkel, fov </li><li>  Kamerastandort, Vec3f (0,0,0) </li><li>  Blickrichtung entlang der z-Achse in Richtung minus unendlich </li></ul><br><h1>  Stufe drei: Fügen Sie weitere Kugeln hinzu </h1><br>  Das Schwierigste liegt hinter uns, jetzt ist unser Weg wolkenlos.  Wenn wir eine Kugel zeichnen können.  dann füge natürlich noch ein paar arbeit hinzu ist nicht schwer.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier sehen Sie</a> Änderungen im Code und hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1>  Stufe vier: Beleuchtung </h1><br>  Jeder ist gut in unserem Bild, aber das ist einfach nicht genug Licht.  Im Rest des Artikels werden wir nur darüber sprechen.  Fügen Sie einige Punktlichtquellen hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br>  Echte Beleuchtung zu betrachten ist eine sehr, sehr schwierige Aufgabe, daher werden wir, wie alle anderen auch, das Auge täuschen, indem wir völlig unphysische, aber wahrscheinlichste plausible Ergebnisse ziehen.  Erste Bemerkung: Warum ist es im Winter kalt und im Sommer heiß?  Denn die Erwärmung der Erdoberfläche hängt vom Einfallswinkel des Sonnenlichts ab.  Je höher die Sonne über dem Horizont ist, desto heller wird die Oberfläche beleuchtet.  Und umgekehrt, je tiefer der Horizont, desto schwächer.  Nun, nachdem die Sonne über dem Horizont untergegangen ist, erreichen uns Photonen überhaupt nicht mehr.  In Bezug auf unsere Kugeln: Hier ist unser Strahl, der von der Kamera emittiert wird (keine Beziehung zu Photonen, aufgepasst!). Schnitt mit der Kugel.  Wie verstehen wir, wie der Schnittpunkt beleuchtet wird?  Sie können einfach den Winkel zwischen dem Normalenvektor an diesem Punkt und dem Vektor betrachten, der die Richtung des Lichts beschreibt.  Je kleiner der Winkel, desto besser wird die Oberfläche beleuchtet.  Um es noch bequemer zu machen, können Sie einfach das Skalarprodukt zwischen dem Normalenvektor und dem Beleuchtungsvektor nehmen.  Ich erinnere mich, dass das Skalarprodukt zwischen zwei Vektoren a und b gleich dem Produkt der Normen der Vektoren durch den Kosinus des Winkels zwischen den Vektoren ist: a * b = | a |  | b |  cos (alpha (a, b)).  Wenn wir Vektoren mit Einheitslänge nehmen, gibt uns das einfachste Skalarprodukt die Intensität der Oberflächenbeleuchtung. <br><br>  Daher geben wir in der cast_ray-Funktion anstelle einer konstanten Farbe die Farbe unter Berücksichtigung der Lichtquellen zurück: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sehen Sie die</a> Änderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , aber das Ergebnis des Programms: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1>  Stufe fünf: Glänzende Oberflächen </h1><br>  Ein Trick mit einem Skalarprodukt zwischen einem Normalenvektor und einem Lichtvektor nähert sich der Beleuchtung von matten Oberflächen recht gut an, was in der Literatur als diffuse Beleuchtung bezeichnet wird.  Was tun, wenn wir glatt und glänzend wollen?  Ich möchte dieses Bild bekommen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br>  Sehen Sie, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie wenig</a> Änderungen vorgenommen werden mussten.  Kurz gesagt, die Reflexionen auf glänzenden Oberflächen sind umso heller, je kleiner der Winkel zwischen der Blickrichtung und der Richtung des <i>reflektierten</i> Lichts ist.  Nun, die Ecken werden wir natürlich genau wie zuvor durch skalare Produkte zählen. <br><br>  Diese Gymnastik mit hellmatten und glänzenden Oberflächen ist als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phong-Modell bekannt</a> .  Das Wiki enthält eine ziemlich detaillierte Beschreibung dieses Beleuchtungsmodells und liest sich gut, wenn es parallel zu meinem Code verglichen wird.  Hier ist ein Schlüsselbild zu verstehen: <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1>  Stufe Sechs: Schatten </h1><br>  Warum haben wir Licht, aber keine Schatten?  Durcheinander!  Ich möchte dieses Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit nur sechs Codezeilen</a> können wir dies erreichen: Beim Zeichnen jedes Punkts stellen wir nur sicher, dass die Lichtquelle die Objekte unserer Szene nicht schneidet. Wenn dies der Fall ist, wird die aktuelle Lichtquelle übersprungen.  Es gibt nur eine kleine Subtilität: Ich verschiebe den Punkt ein wenig in Richtung der Normalen: <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br>  Warum?  Ja, es ist nur so, dass unser Punkt auf der Oberfläche des Objekts liegt und (mit Ausnahme von numerischen Fehlern) jeder Strahl von diesem Punkt unsere Szene durchquert. <br><br><h1>  Schritt sieben: Reflexionen </h1><br>  Das ist unglaublich, aber um unserer Szene Reflexionen hinzuzufügen, müssen wir nur drei Codezeilen hinzufügen: <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Überzeugen Sie sich selbst:</a> Am Schnittpunkt mit dem Objekt zählen wir einfach den reflektierten Strahl (die Funktion aus der Berechnung der Unebenheiten hat sich als nützlich erwiesen!) Und rufen die Funktion cast_ray rekursiv in Richtung des reflektierten Strahls auf.  Stellen Sie sicher, dass Sie mit der <a href="">Rekursionstiefe spielen</a> . Ich setze sie auf vier. Beginnen Sie bei Null. Was wird sich im Bild ändern?  Hier ist mein Ergebnis mit einer funktionierenden Reflexion und einer Tiefe von vier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1>  Stufe acht: Brechung </h1><br>  Durch das Lernen, Reflexionen zu zählen, werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refraktionen genau gleich gezählt</a> .  Eine Funktion, mit der Sie die Richtung des gebrochenen Strahls ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemäß dem</a> Snellschen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesetz</a> ) berechnen können, und drei Codezeilen in unserer rekursiven Funktion cast_ray.  Hier ist das Ergebnis, bei dem die nächste Kugel zu „Glas“ wurde, sie bricht und reflektiert leicht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1>  Stufe neun: Fügen Sie weitere Objekte hinzu </h1><br>  Warum sind wir alle ohne Milch, aber ohne Milch?  Bis zu diesem Moment haben wir nur Kugeln gerendert, da dies eines der einfachsten nicht trivialen mathematischen Objekte ist.  Und fügen wir ein Stück des Flugzeugs hinzu.  Ein Klassiker des Genres ist ein Schachbrett.  Dafür reichen uns ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dutzend Linien</a> in einer Funktion, die den Schnittpunkt des Strahls mit der Szene berücksichtigt. <br><br>  Nun, hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br>  Wie ich versprochen habe, zählen genau 256 Codezeilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">für sich selbst</a> ! <br><br><h1>  Stufe zehn: Hausaufgaben </h1><br>  Wir haben einen ziemlich langen Weg zurückgelegt: Wir haben gelernt, wie man Objekte zur Szene hinzufügt, um eine ziemlich komplizierte Beleuchtung zu berücksichtigen.  Lassen Sie mich zwei Aufgaben als Hausaufgabe hinterlassen.  Absolut alle Vorbereitungsarbeiten wurden bereits im Zweig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">homework_assignment durchgeführt</a> .  Für jeden Job sind maximal zehn Codezeilen erforderlich. <br><br><h3>  Aufgabe eins: Umgebungskarte </h3><br>  Im Moment, wenn der Strahl die Szene nicht kreuzt, setzen wir ihn einfach auf eine konstante Farbe.  Und warum eigentlich dauerhaft?  Nehmen wir ein sphärisches Foto (Datei <a href="">envmap.jpg</a> ) auf und verwenden es als Hintergrund!  Um das Leben einfacher zu machen, habe ich unser Projekt mit der stb-Bibliothek verknüpft, um die Arbeit mit JPEGs zu vereinfachen.  Dies sollte ein Render wie dieser sein: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3>  Die zweite Aufgabe: Quacksalber! </h3><br>  Wir können sowohl Kugeln als auch Ebenen rendern (siehe Schachbrett).  Fügen wir also eine Zeichnung von triangulierten Modellen hinzu!  Ich schrieb Code zum Lesen des Dreiecksgitters und fügte dort eine Strahl-Dreieck-Schnittfunktion hinzu.  Jetzt sollte es völlig trivial sein, unserer Szene eine Ente hinzuzufügen! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1>  Fazit </h1><br>  Meine Hauptaufgabe ist es, Projekte zu zeigen, die interessant (und einfach!) Sind. Zum Programmieren hoffe ich wirklich, dass ich es schaffen kann.  Dies ist sehr wichtig, da ich davon überzeugt bin, dass ein Programmierer viel und mit Geschmack schreiben sollte.  Ich weiß nichts über Sie, aber die persönliche Buchhaltung und ein Pionier mit vergleichbarer Codekomplexität ziehen mich überhaupt nicht an. <br><br>  Zweihundertfünfzig Raytracing-Zeilen können tatsächlich in wenigen Stunden geschrieben werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fünfhundert Zeilen</a> Software-Rasterizer können in wenigen Tagen gemastert werden.  Das nächste Mal werden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rakecasting</a> sortieren und gleichzeitig die einfachsten Spiele zeigen, die meine Schüler im ersten Jahr im Rahmen des Unterrichts in C ++ schreiben.  Bleib dran! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436790/">https://habr.com/ru/post/de436790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436774/index.html">Die Methode zur Entführung von Konten "in großen Mengen" durch Zugriff auf die Dienste eines Mobilfunkbetreibers</a></li>
<li><a href="../de436776/index.html">Von der Komfortzone zu Top-Entwicklern</a></li>
<li><a href="../de436778/index.html">defi.js ist eine reaktive Bibliothek, die auf Object.defineProperty basiert</a></li>
<li><a href="../de436784/index.html">Fingerhut (Mozilla) wechselt zu Glitch</a></li>
<li><a href="../de436788/index.html">Stellen Sie Office 2019 in einer Unternehmensumgebung bereit (für IT-Experten).</a></li>
<li><a href="../de436792/index.html">DEFCON-Konferenz 19. Anonym und wir. Teil 1</a></li>
<li><a href="../de436794/index.html">DEFCON-Konferenz 19. Anonym und wir. Teil 2</a></li>
<li><a href="../de436798/index.html">Professionelle Deformation des Administrators</a></li>
<li><a href="../de436822/index.html">Android Robotics bis 2019: Die wahre Geschichte; in 5 Teilen; Teil 3</a></li>
<li><a href="../de436828/index.html">Der Übergang zu Boost-1.65.1 und aufgetretene Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>