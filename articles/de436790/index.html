<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôæ üôèüèø üè¢ 256 Zeilen nacktes C ++: Schreiben eines Raytracers von Grund auf in wenigen Stunden üéé üíé üôåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich ver√∂ffentliche das n√§chste Kapitel meines Vorlesungskurses √ºber Computergrafik ( hier k√∂nnen Sie das Original auf Russisch lesen , obwohl die engl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>256 Zeilen nacktes C ++: Schreiben eines Raytracers von Grund auf in wenigen Stunden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436790/">  Ich ver√∂ffentliche das n√§chste Kapitel meines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorlesungskurses √ºber Computergrafik</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier k√∂nnen Sie das</a> Original auf Russisch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">lesen</a> , obwohl die englische Version neuer ist).  Dieses Mal ist das Gespr√§chsthema das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zeichnen von Szenen mithilfe von Raytracing</a> .  Wie √ºblich versuche ich, Bibliotheken von Drittanbietern zu meiden, da die Sch√ºler dadurch unter die Haube schauen. <br><br>  Es gibt bereits viele √§hnliche Projekte im Internet, aber fast alle zeigen fertige Programme, die √§u√üerst schwer zu verstehen sind.  Hier zum Beispiel ein sehr ber√ºhmtes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rendering-Programm, das auf eine Visitenkarte passt</a> .  Ein sehr beeindruckendes Ergebnis, aber das Verst√§ndnis dieses Codes ist sehr schwierig.  Mein Ziel ist es nicht zu zeigen, wie ich kann, sondern im Detail zu erkl√§ren, wie ich dies reproduzieren kann.  Dar√ºber hinaus scheint mir diese Vorlesung nicht einmal als Schulungsmaterial f√ºr Computergrafik n√ºtzlich zu sein, sondern als Programmierwerkzeug.  Ich werde konsequent zeigen, wie man von Grund auf zum Endergebnis kommt: wie man ein komplexes Problem in elementare l√∂sbare Stufen zerlegt. <br><br>  <i>Achtung: Es macht keinen Sinn, nur meinen Code zu betrachten und diesen Artikel nur mit einer Tasse Tee in der Hand zu lesen.</i>  <i>In diesem Artikel k√∂nnen Sie eine Tastatur greifen und Ihre eigene Engine schreiben.</i>  <i>Er wird sicherlich besser sein als meiner.</i>  <i>Oder √§ndern Sie einfach die Programmiersprache!</i> <br><br>  Also, heute werde ich zeigen, wie man solche Bilder zeichnet: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><a name="habracut"></a><br><h1>  Stufe eins: Speichern Sie das Bild auf der Festplatte </h1><br>  Ich m√∂chte mich nicht mit Fenstermanagern, Maus- / Tastaturverarbeitung und dergleichen besch√§ftigen.  Das Ergebnis unseres Programms ist ein einfaches Bild, das auf der Festplatte gespeichert wird.  Das erste, was wir tun m√ºssen, ist das Bild auf der Festplatte zu speichern.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier</a> liegt der Code, mit dem Sie dies tun k√∂nnen.  Lassen Sie mich Ihnen die Hauptdatei geben: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;vector&gt; #include "geometry.h" void render() { const int width = 1024; const int height = 768; std::vector&lt;Vec3f&gt; framebuffer(width*height); for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/float(height),i/float(width), 0); } } std::ofstream ofs; // save the framebuffer to file ofs.open("./out.ppm"); ofs &lt;&lt; "P6\n" &lt;&lt; width &lt;&lt; " " &lt;&lt; height &lt;&lt; "\n255\n"; for (size_t i = 0; i &lt; height*width; ++i) { for (size_t j = 0; j&lt;3; j++) { ofs &lt;&lt; (char)(255 * std::max(0.f, std::min(1.f, framebuffer[i][j]))); } } ofs.close(); } int main() { render(); return 0; }</span></span></span></span></code> </pre> <br>  In der Hauptfunktion wird nur die Funktion render () aufgerufen, sonst nichts.  Was ist in der Funktion render () enthalten?  Zun√§chst definiere ich ein Bild als eindimensionales Array von Framebuffer-Werten vom Typ Vec3f. Dies sind einfache dreidimensionale Vektoren, die uns die Farbe (r, g, b) f√ºr jedes Pixel geben. <br><br>  Die Vektorklasse befindet sich in der Dateiometry.h, ich werde sie hier nicht beschreiben: Erstens ist dort alles trivial, einfache Manipulation von zwei- und dreidimensionalen Vektoren (Addition, Subtraktion, Zuweisung, Multiplikation mit einem Skalar, Skalarprodukt) und zweitens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">gbg</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hat</a> es bereits im Rahmen einer Vorlesung √ºber Computergrafik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ausf√ºhrlich beschrieben</a> . <br><br>  Ich speichere das Bild im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ppm-Format</a> .  Dies ist der einfachste Weg zum Speichern von Bildern, jedoch nicht immer der bequemste f√ºr die weitere Anzeige.  Wenn Sie in anderen Formaten speichern m√∂chten, empfehle ich dennoch, eine Bibliothek eines Drittanbieters <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">anzuschlie√üen</a> , z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">stb</a> .  Dies ist eine wunderbare Bibliothek: Es reicht aus, eine Header-Datei stb_image_write.h in das Projekt aufzunehmen, und dies erm√∂glicht das Speichern auch in PNG, sogar in JPG. <br><br>  Insgesamt besteht das Ziel dieser Phase darin, sicherzustellen, dass wir a) ein Bild im Speicher erstellen und dort verschiedene Farbwerte schreiben k√∂nnen. B) das Ergebnis auf der Festplatte speichern, damit es in einem Programm eines Drittanbieters angezeigt werden kann.  Hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/8d8/1f8/ec18d81f825957255d786b50c05c8c4b.jpg"><br><br><h1>  Stufe zwei, die schwierigste: direktes Raytracing </h1><br>  Dies ist die wichtigste und schwierigste Phase der gesamten Kette.  Ich m√∂chte eine Kugel in meinem Code definieren und auf dem Bildschirm anzeigen, ohne mich um Materialien oder Beleuchtung zu k√ºmmern.  So sollte unser Ergebnis aussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b02/143/d02/b02143d02d333d683313d209ec14eb25.jpg"><br><br>  Der Einfachheit halber gibt es in meinem Repository ein Commit f√ºr jede Phase.  Mit Github k√∂nnen Sie Ihre √Ñnderungen bequem anzeigen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier zum Beispiel</a> , was sich im zweiten Commit gegen√ºber dem ersten ge√§ndert hat. <br><br>  Zun√§chst: Was brauchen wir, um eine Kugel im Speicher des Computers darzustellen?  Vier Zahlen reichen uns: ein dreidimensionaler Vektor mit dem Mittelpunkt der Kugel und ein Skalar, der den Radius beschreibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sphere</span></span></span><span class="hljs-class"> {</span></span> Vec3f center; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> radius; Sphere(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;c, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;r) : center(c), radius(r) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ray_intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;t0)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ Vec3f L = center - orig; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tca = L*dir; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d2 = L*L - tca*tca; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 &gt; radius*radius) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> thc = sqrtf(radius*radius - d2); t0 = tca - thc; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t1 = tca + thc; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) t0 = t1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t0 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  Die einzige nicht triviale Sache in diesem Code ist eine Funktion, mit der Sie √ºberpr√ºfen k√∂nnen, ob ein bestimmter Strahl (der von orig in Richtung dir stammt) unsere Kugel schneidet.  Eine detaillierte Beschreibung des Algorithmus zur √úberpr√ºfung des Schnittpunkts von Strahl und Kugel finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . Ich empfehle dringend, dies zu tun und meinen Code zu √ºberpr√ºfen. <br><br>  Wie funktioniert Raytracing?  Sehr einfach.  In der ersten Phase haben wir das Bild einfach mit einem Farbverlauf abgedeckt: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;height; j++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;width; i++) { framebuffer[i+j*width] = Vec3f(j/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(height),i/<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(width), <span class="hljs-number"><span class="hljs-number">0</span></span>); } }</code> </pre><br>  Jetzt bilden wir f√ºr jedes Pixel einen Strahl, der vom Koordinatenzentrum kommt und durch unser Pixel geht, und pr√ºfen, ob dieser Strahl unsere Kugel schneidet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66d/a0e/be3/66da0ebe356e82253f0492e6335f114e.svg"><br><br>  Wenn es keinen Schnittpunkt mit der Kugel gibt, setzen wir Farbe1, andernfalls Farbe2: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sphere_dist = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sphere.ray_intersect(orig, dir, sphere_dist)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec3f(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.8</span></span>); <span class="hljs-comment"><span class="hljs-comment">// background color } return Vec3f(0.4, 0.4, 0.3); } void render(const Sphere &amp;sphere) { Ôøº [...] for (size_t j = 0; j&lt;height; j++) { for (size_t i = 0; i&lt;width; i++) { float x = (2*(i + 0.5)/(float)width - 1)*tan(fov/2.)*width/(float)height; float y = -(2*(j + 0.5)/(float)height - 1)*tan(fov/2.); Vec3f dir = Vec3f(x, y, -1).normalize(); framebuffer[i+j*width] = cast_ray(Vec3f(0,0,0), dir, sphere); } } Ôøº [...] }</span></span></code> </pre><br>  An dieser Stelle empfehle ich, einen Bleistift zu nehmen und alle Berechnungen auf Papier zu √ºberpr√ºfen, sowohl den Schnittpunkt eines Strahls mit einer Kugel als auch das Fegen eines Bildes mit Strahlen.  F√ºr alle F√§lle wird unsere Kamera von folgenden Faktoren bestimmt: <br><br><ul><li>  Bildbreite </li><li>  Bildh√∂he </li><li>  Betrachtungswinkel, fov </li><li>  Kamerastandort, Vec3f (0,0,0) </li><li>  Blickrichtung entlang der z-Achse in Richtung minus unendlich </li></ul><br><h1>  Stufe drei: F√ºgen Sie weitere Kugeln hinzu </h1><br>  Das Schwierigste liegt hinter uns, jetzt ist unser Weg wolkenlos.  Wenn wir eine Kugel zeichnen k√∂nnen.  dann f√ºge nat√ºrlich noch ein paar arbeit hinzu ist nicht schwer.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier sehen Sie</a> √Ñnderungen im Code und hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc0/f37/6c9/fc0f376c9cb8971781f2a24065b47fa5.jpg"><br><br><h1>  Stufe vier: Beleuchtung </h1><br>  Jeder ist gut in unserem Bild, aber das ist einfach nicht genug Licht.  Im Rest des Artikels werden wir nur dar√ºber sprechen.  F√ºgen Sie einige Punktlichtquellen hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Light</span></span></span><span class="hljs-class"> {</span></span> Light(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vec3f &amp;p, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> &amp;i) : position(p), intensity(i) {} Vec3f position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> intensity; };</code> </pre><br>  Echte Beleuchtung zu betrachten ist eine sehr, sehr schwierige Aufgabe, daher werden wir, wie alle anderen auch, das Auge t√§uschen, indem wir v√∂llig unphysische, aber wahrscheinlichste plausible Ergebnisse ziehen.  Erste Bemerkung: Warum ist es im Winter kalt und im Sommer hei√ü?  Denn die Erw√§rmung der Erdoberfl√§che h√§ngt vom Einfallswinkel des Sonnenlichts ab.  Je h√∂her die Sonne √ºber dem Horizont ist, desto heller wird die Oberfl√§che beleuchtet.  Und umgekehrt, je tiefer der Horizont, desto schw√§cher.  Nun, nachdem die Sonne √ºber dem Horizont untergegangen ist, erreichen uns Photonen √ºberhaupt nicht mehr.  In Bezug auf unsere Kugeln: Hier ist unser Strahl, der von der Kamera emittiert wird (keine Beziehung zu Photonen, aufgepasst!). Schnitt mit der Kugel.  Wie verstehen wir, wie der Schnittpunkt beleuchtet wird?  Sie k√∂nnen einfach den Winkel zwischen dem Normalenvektor an diesem Punkt und dem Vektor betrachten, der die Richtung des Lichts beschreibt.  Je kleiner der Winkel, desto besser wird die Oberfl√§che beleuchtet.  Um es noch bequemer zu machen, k√∂nnen Sie einfach das Skalarprodukt zwischen dem Normalenvektor und dem Beleuchtungsvektor nehmen.  Ich erinnere mich, dass das Skalarprodukt zwischen zwei Vektoren a und b gleich dem Produkt der Normen der Vektoren durch den Kosinus des Winkels zwischen den Vektoren ist: a * b = | a |  | b |  cos (alpha (a, b)).  Wenn wir Vektoren mit Einheitsl√§nge nehmen, gibt uns das einfachste Skalarprodukt die Intensit√§t der Oberfl√§chenbeleuchtung. <br><br>  Daher geben wir in der cast_ray-Funktion anstelle einer konstanten Farbe die Farbe unter Ber√ºcksichtigung der Lichtquellen zur√ºck: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec3f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cast_ray</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;orig, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3f &amp;dir, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sphere &amp;sphere)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> diffuse_light_intensity = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;lights.size(); i++) { Vec3f light_dir = (lights[i].position - point).normalize(); diffuse_light_intensity += lights[i].intensity * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(<span class="hljs-number"><span class="hljs-number">0.f</span></span>, light_dir*N); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> material.diffuse_color * diffuse_light_intensity; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sehen Sie die</a> √Ñnderungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , aber das Ergebnis des Programms: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/207/766/76d/20776676d3aff568b466807ef548ea5a.jpg"><br><br><h1>  Stufe f√ºnf: Gl√§nzende Oberfl√§chen </h1><br>  Ein Trick mit einem Skalarprodukt zwischen einem Normalenvektor und einem Lichtvektor n√§hert sich der Beleuchtung von matten Oberfl√§chen recht gut an, was in der Literatur als diffuse Beleuchtung bezeichnet wird.  Was tun, wenn wir glatt und gl√§nzend wollen?  Ich m√∂chte dieses Bild bekommen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2d6/b39/c52/2d6b39c52aaa6a8c8667fd2df19f2e93.jpg"><br><br>  Sehen Sie, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie wenig</a> √Ñnderungen vorgenommen werden mussten.  Kurz gesagt, die Reflexionen auf gl√§nzenden Oberfl√§chen sind umso heller, je kleiner der Winkel zwischen der Blickrichtung und der Richtung des <i>reflektierten</i> Lichts ist.  Nun, die Ecken werden wir nat√ºrlich genau wie zuvor durch skalare Produkte z√§hlen. <br><br>  Diese Gymnastik mit hellmatten und gl√§nzenden Oberfl√§chen ist als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Phong-Modell bekannt</a> .  Das Wiki enth√§lt eine ziemlich detaillierte Beschreibung dieses Beleuchtungsmodells und liest sich gut, wenn es parallel zu meinem Code verglichen wird.  Hier ist ein Schl√ºsselbild zu verstehen: <br><img src="https://habrastorage.org/getpro/habr/post_images/881/d77/0ca/881d770ca8779cc876808a22c0fd8cce.png"><br><br><h1>  Stufe Sechs: Schatten </h1><br>  Warum haben wir Licht, aber keine Schatten?  Durcheinander!  Ich m√∂chte dieses Bild: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8f/fdd/04c/e8ffdd04c72dfc92f0845bb7b079faf7.jpg"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit nur sechs Codezeilen</a> k√∂nnen wir dies erreichen: Beim Zeichnen jedes Punkts stellen wir nur sicher, dass die Lichtquelle die Objekte unserer Szene nicht schneidet. Wenn dies der Fall ist, wird die aktuelle Lichtquelle √ºbersprungen.  Es gibt nur eine kleine Subtilit√§t: Ich verschiebe den Punkt ein wenig in Richtung der Normalen: <br><br><pre> <code class="cpp hljs">Vec3f shadow_orig = light_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>;</code> </pre><br>  Warum?  Ja, es ist nur so, dass unser Punkt auf der Oberfl√§che des Objekts liegt und (mit Ausnahme von numerischen Fehlern) jeder Strahl von diesem Punkt unsere Szene durchquert. <br><br><h1>  Schritt sieben: Reflexionen </h1><br>  Das ist unglaublich, aber um unserer Szene Reflexionen hinzuzuf√ºgen, m√ºssen wir nur drei Codezeilen hinzuf√ºgen: <br><br><pre> <code class="cpp hljs"> Vec3f reflect_dir = reflect(dir, N).normalize(); Vec3f reflect_orig = reflect_dir*N &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? point - N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span> : point + N*<span class="hljs-number"><span class="hljs-number">1e-3</span></span>; <span class="hljs-comment"><span class="hljs-comment">// offset the original point to avoid occlusion by the object itself Vec3f reflect_color = cast_ray(reflect_orig, reflect_dir, spheres, lights, depth + 1);</span></span></code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úberzeugen Sie sich selbst:</a> Am Schnittpunkt mit dem Objekt z√§hlen wir einfach den reflektierten Strahl (die Funktion aus der Berechnung der Unebenheiten hat sich als n√ºtzlich erwiesen!) Und rufen die Funktion cast_ray rekursiv in Richtung des reflektierten Strahls auf.  Stellen Sie sicher, dass Sie mit der <a href="">Rekursionstiefe spielen</a> . Ich setze sie auf vier. Beginnen Sie bei Null. Was wird sich im Bild √§ndern?  Hier ist mein Ergebnis mit einer funktionierenden Reflexion und einer Tiefe von vier: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a9d/1c2/e6d/a9d1c2e6d428aaba07953cae3fa007ea.jpg"><br><br><h1>  Stufe acht: Brechung </h1><br>  Durch das Lernen, Reflexionen zu z√§hlen, werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Refraktionen genau gleich gez√§hlt</a> .  Eine Funktion, mit der Sie die Richtung des gebrochenen Strahls ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gem√§√ü dem</a> Snellschen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gesetz</a> ) berechnen k√∂nnen, und drei Codezeilen in unserer rekursiven Funktion cast_ray.  Hier ist das Ergebnis, bei dem die n√§chste Kugel zu ‚ÄûGlas‚Äú wurde, sie bricht und reflektiert leicht: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c8/14a/56a/8c814a56aafc88609ebeb8c5a6f9a494.jpg"><br><br><h1>  Stufe neun: F√ºgen Sie weitere Objekte hinzu </h1><br>  Warum sind wir alle ohne Milch, aber ohne Milch?  Bis zu diesem Moment haben wir nur Kugeln gerendert, da dies eines der einfachsten nicht trivialen mathematischen Objekte ist.  Und f√ºgen wir ein St√ºck des Flugzeugs hinzu.  Ein Klassiker des Genres ist ein Schachbrett.  Daf√ºr reichen uns ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dutzend Linien</a> in einer Funktion, die den Schnittpunkt des Strahls mit der Szene ber√ºcksichtigt. <br><br>  Nun, hier ist das Ergebnis: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d88/871/a50/d88871a5021eb69cc64c7b9a5915e855.jpg"><br><br>  Wie ich versprochen habe, z√§hlen genau 256 Codezeilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">f√ºr sich selbst</a> ! <br><br><h1>  Stufe zehn: Hausaufgaben </h1><br>  Wir haben einen ziemlich langen Weg zur√ºckgelegt: Wir haben gelernt, wie man Objekte zur Szene hinzuf√ºgt, um eine ziemlich komplizierte Beleuchtung zu ber√ºcksichtigen.  Lassen Sie mich zwei Aufgaben als Hausaufgabe hinterlassen.  Absolut alle Vorbereitungsarbeiten wurden bereits im Zweig <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">homework_assignment durchgef√ºhrt</a> .  F√ºr jeden Job sind maximal zehn Codezeilen erforderlich. <br><br><h3>  Aufgabe eins: Umgebungskarte </h3><br>  Im Moment, wenn der Strahl die Szene nicht kreuzt, setzen wir ihn einfach auf eine konstante Farbe.  Und warum eigentlich dauerhaft?  Nehmen wir ein sph√§risches Foto (Datei <a href="">envmap.jpg</a> ) auf und verwenden es als Hintergrund!  Um das Leben einfacher zu machen, habe ich unser Projekt mit der stb-Bibliothek verkn√ºpft, um die Arbeit mit JPEGs zu vereinfachen.  Dies sollte ein Render wie dieser sein: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e0/531/fa9/3e0531fa9ee361de7580029e818bc5f5.jpg"><br><br><h3>  Die zweite Aufgabe: Quacksalber! </h3><br>  Wir k√∂nnen sowohl Kugeln als auch Ebenen rendern (siehe Schachbrett).  F√ºgen wir also eine Zeichnung von triangulierten Modellen hinzu!  Ich schrieb Code zum Lesen des Dreiecksgitters und f√ºgte dort eine Strahl-Dreieck-Schnittfunktion hinzu.  Jetzt sollte es v√∂llig trivial sein, unserer Szene eine Ente hinzuzuf√ºgen! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/064/50f/65d/06450f65da7c0503838bc008dcaba6a3.jpg"><br><br><h1>  Fazit </h1><br>  Meine Hauptaufgabe ist es, Projekte zu zeigen, die interessant (und einfach!) Sind. Zum Programmieren hoffe ich wirklich, dass ich es schaffen kann.  Dies ist sehr wichtig, da ich davon √ºberzeugt bin, dass ein Programmierer viel und mit Geschmack schreiben sollte.  Ich wei√ü nichts √ºber Sie, aber die pers√∂nliche Buchhaltung und ein Pionier mit vergleichbarer Codekomplexit√§t ziehen mich √ºberhaupt nicht an. <br><br>  Zweihundertf√ºnfzig Raytracing-Zeilen k√∂nnen tats√§chlich in wenigen Stunden geschrieben werden.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºnfhundert Zeilen</a> Software-Rasterizer k√∂nnen in wenigen Tagen gemastert werden.  Das n√§chste Mal werden wir das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Rakecasting</a> sortieren und gleichzeitig die einfachsten Spiele zeigen, die meine Sch√ºler im ersten Jahr im Rahmen des Unterrichts in C ++ schreiben.  Bleib dran! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de436790/">https://habr.com/ru/post/de436790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de436774/index.html">Die Methode zur Entf√ºhrung von Konten "in gro√üen Mengen" durch Zugriff auf die Dienste eines Mobilfunkbetreibers</a></li>
<li><a href="../de436776/index.html">Von der Komfortzone zu Top-Entwicklern</a></li>
<li><a href="../de436778/index.html">defi.js ist eine reaktive Bibliothek, die auf Object.defineProperty basiert</a></li>
<li><a href="../de436784/index.html">Fingerhut (Mozilla) wechselt zu Glitch</a></li>
<li><a href="../de436788/index.html">Stellen Sie Office 2019 in einer Unternehmensumgebung bereit (f√ºr IT-Experten).</a></li>
<li><a href="../de436792/index.html">DEFCON-Konferenz 19. Anonym und wir. Teil 1</a></li>
<li><a href="../de436794/index.html">DEFCON-Konferenz 19. Anonym und wir. Teil 2</a></li>
<li><a href="../de436798/index.html">Professionelle Deformation des Administrators</a></li>
<li><a href="../de436822/index.html">Android Robotics bis 2019: Die wahre Geschichte; in 5 Teilen; Teil 3</a></li>
<li><a href="../de436828/index.html">Der √úbergang zu Boost-1.65.1 und aufgetretene Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>