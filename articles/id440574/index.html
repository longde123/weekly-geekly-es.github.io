<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”¢ ğŸ‘ğŸ¾ ğŸ‘¨â€â¤ï¸â€ğŸ‘¨ Piala AI Rusia 2018, sejarah 9 tempat ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ½ ğŸ• ğŸ‘†ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jadi 


 Nama saya, seperti tahun lalu, adalah Andrei Rybalka, hanya saja saat ini saya berusia 33. Dan, karena saya berada di sepuluh besar, saya mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Piala AI Rusia 2018, sejarah 9 tempat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440574/"><h1 id="itak">  Jadi </h1><br><p>  Nama saya, seperti tahun lalu, adalah Andrei Rybalka, hanya saja saat ini saya berusia 33. Dan, karena saya berada di sepuluh besar, saya memutuskan untuk berbagi pendekatan saya dalam menulis bot permainan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Piala AI Rusia 2018</a> lagi. </p><br><p>  Kali ini tugasnya adalah sepakbola.  Tugas itu sendiri agak mengingatkan pada 2014 RAIC, ketika itu hoki, tetapi solusinya benar-benar berbeda. </p><br><p>  Kali ini dunia tiga dimensi dan tiga dimensi ini digunakan secara penuh.  Permainan itu sendiri paling mengingatkan pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Liga Rocket</a> . </p><br><p>  Saya tidak akan menanggung bagian pengantar, lebih mudah untuk menunjukkan tampilannya.  Anda dapat menonton pertandingan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di situs web</a> atau di video: </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/6g/jb/hf/6gjbhf4gdy_4qqrw74huttfudvq.jpeg"></a> </p><a name="habracut"></a><br><p>  Agar hidup kami tidak terlihat terlalu manis, para pengembang, selain tidak menentukan dunia permainan, juga membagi centang permainan menjadi 100 subwoofer, yang pada awalnya mengakhiri simulasi yang akurat untuk sebagian besar peserta, dan bahkan lebih lagi bagi saya, berniat untuk menulis bot di Jawa lambat. </p><br><p>  Juga, saya harus mengatakan bahwa kejuaraan dibagi menjadi beberapa ronde, yang mungkin akan lebih tepat untuk memanggil ronde. </p><br><h3 id="kratko-o-turnirnoy-sisteme">  Secara singkat tentang sistem turnamen </h3><br><p>  Sebagai permulaan, 2 minggu diberikan untuk pengembangan.  Kemudian babak pertama berlalu.  300 yang terbaik melangkah lebih jauh. </p><br><p>  Setelah putaran, aturan permainan berubah (khusus, nitro ditambahkan ke permainan) dan 2 minggu lagi diberikan, setelah itu putaran kedua berlalu. </p><br><p>  Kemudian aturannya rumit lagi (pemain ketiga ditambahkan), satu minggu lagi diberikan dan kami memainkan final. </p><br><p>  Tapi ini bukan akhirnya.  Setelah final ada satu minggu lagi, di mana sandbox hanya berhenti, dan 6 yang terbaik di dalamnya, tidak termasuk pemenang final, juga diberikan.  Perbedaan mendasar antara final sandbox dan final kejuaraan adalah bahwa di sandbox, permainan dibuat dalam format acak, dan bukan hanya dalam format putaran saat ini. </p><br><h1 id="istorii-uchastiya">  Cerita partisipasi </h1><br><p>  Bagian teknis akan lebih rendah.  Kepada siapa sejarah tidak menarik, Anda dapat menggulir ke bawah sampai menjadi baik. </p><br><h3 id="pervyy-raund">  Babak pertama </h3><br><p>  Dia mulai, seperti kebanyakan, dengan satu minggu beta.  Menghabiskan banyak waktu, 4+ jam setiap malam. <br>  Sebelum Anda mengisi versi pertama, butuh beberapa iterasi <br>  <em>kami kode sampai kami mulai mengalahkan versi sebelumnya - kami kumpulkan - kami mempertimbangkan versi saat ini dari versi sebelumnya - kami ulangi</em> . </p><br><p>  Saya tidak terburu-buru dengan isian pertama dan itu terjadi beberapa hari sebelum putaran.  Dan, sejak, sampai sekarang, bot saya belum bermain dengan siapa pun, saya tidak tahu seperti apa dunia saya dan posisi apa di peringkat yang bisa saya klaim.  Ketika saya melihat bahwa saya telah memenangkan lebih dari 100 pertandingan berturut-turut tanpa kehilangan satu pun, saya menjadi tenang. </p><br><p>  Secara umum, kekalahan pertama, saya pikir, ada di tempat ke-12, berdasarkan batas waktu, dan pertandingan pertama yang hilang berturut-turut sudah ada di 10 besar. </p><br><p>  Singkatnya, saya menyadari bahwa saya memiliki peluang untuk masuk ke babak kedua, di mana 300 teratas masuk. <br>  Karena itu, saya tidak mengejar posisi di dalamnya dan tidak membanjiri yang lain untuk putaran, tetapi hanya terus bekerja. </p><br><p>  Pada saat itu, saya melihat bahwa masih ada banyak ruang untuk perbaikan tanpa menghubungkan nitro (yang muncul setelah ronde 1), jadi saya fokus pada bagian utama dari strategi, menyadari bahwa sebelum ronde kedua akan ada lebih dari 2 minggu atau lebih dan saya akan punya waktu untuk mengikat nitro. </p><br><h3 id="vtoroy-raund">  Babak kedua </h3><br><p>  Minggu pertama saya aktif pemrograman, tetapi masih tidak terhubung nitro.  Saya ingin melakukan ini di minggu kedua.  Tetapi semuanya ternyata berbeda, karena pada akhir minggu pertama saya terjangkit pneumonia.  Saya tidak dapat memprogram, jadi saya hanya mengunggah apa itu, dan, dapat dikatakan, partisipasi aktif dalam kejuaraan bagi saya di tempat ini sudah berakhir. </p><br><p>  Selama 3 minggu ke depan sebelum akhir kejuaraan, saya mengerjakan strategi dalam jumlah mungkin 20 jam. </p><br><p>  Akibatnya, di babak kedua, bot saya, pada prinsipnya, tidak tahu bahwa ada nitro dalam permainan, tetapi entah bagaimana masih menempati posisi ke-16. </p><br><h3 id="final">  Terakhir </h3><br><p>  Di final, pemain ketiga ditambahkan. </p><br><p>  Saya menulis di Jawa lambat, dan bukan di C ++, karena 7 dari 8 orang lebih tinggi dari saya di peringkat, dan sebelum itu bot saya sering jatuh ke dalam batas waktu, jadi dengan munculnya pemain ketiga, mulai turun dalam 100% permainan.  Untungnya, game di kotak pasir dibuat dalam format acak, jadi saya otomatis <br>  kalah hanya setiap pertandingan ketiga dan karena itu terbang tidak terlalu banyak.  Tampaknya telah jatuh ke posisi ke-18. </p><br><p>  Kecuali untuk pemrograman, mengedit koefisien dalam fungsi evaluasi dan menjalankan tes, kemudian untuk pertama kalinya, setelah awal penyakit, saya duduk di bot malam hari sebelum final.  Dia menambahkan nitro yang sangat sederhana yang diarahkan ketat ke atas sehingga dua penyerang akan berhenti berlari pada titik yang sama dan bertabrakan satu sama lain di sana, dan mengurangi semua yang dia bisa untuk permainan 3x3, mulai dari kedalaman render dan berakhir dengan akurasi simulasi, sehingga hanya bot yang tidak mati karena batas waktu. <br>  Dalam bentuk ini, ia memainkan final. </p><br><p>  Dalam selang waktu antara separuh babak final, saya kembali duduk di bot dan menghabiskan beberapa jam yang baik 10. Untuk sebagian besar, perubahan menyangkut pemilihan koefisien yang dinamis, gangguan genetika awal, dll.  Secara umum, saya mencari keseimbangan antara akurasi dan kedalaman dan kecepatan kesalahan perhitungan. <br>  Selain bertarung melawan kecepatan, ia membuat beberapa perubahan lagi: </p><br><ul><li>  Mengirim penyerang jauh (relatif terhadap bola) ke titik di tengah-tengah antara bola dan gawang lawan </li><li>  Saya memperbaiki nitro sedikit (uraiannya ada di bagian teknis).  Itu masih sangat sederhana, tetapi menjadi jauh lebih efisien. </li></ul><br><p>  Total, setelah menjalankan tes dan melihat skor 395: 254 melawan versi sebelumnya, saya menenangkan ini.  Ini memungkinkan saya untuk mengambil tempat ke-9 di final. </p><br><h3 id="final-pesochnicy">  Sandbox Finale </h3><br><p>  Saya terus terluka dan tidak bekerja pada bot untuk hampir sepanjang minggu.  Sehari sebelum akhir, saya melihat bahwa beberapa orang mengunggah versi baru, yang sering menang melawan saya dan dapat membuang kotak pasir dari hadiah.  Jadi saya menghabiskan beberapa jam lagi. </p><br><p>  Satu-satunya perubahan besar adalah saya menggali cabang saya di Git tiga minggu lalu, di mana saya melakukan simulasi gerakan musuh menggunakan algoritma saya yang disederhanakan.  Pada saat itu itu bekerja dengan buruk, tetapi saya membawanya ke pikiran, menjalankan tes, melihat <br>  yang mengungguli versi sebelumnya hampir dua kali lipat dan banjir.  Total, pada saat berhenti, saya berada di posisi ke-10 di tabel keseluruhan, yang sesuai dengan ke-4 di final kotak pasir. </p><br><h1 id="kak-eto-vsyo-rabotaet-tehnicheskaya-chast">  Bagaimana cara kerjanya (bagian teknis) </h1><br><p>  Saya mohon maaf sebelumnya jika ada ketidakakuratan dalam terminologi.  Juga, saya menulis dari memori, jadi mungkin saja di suatu tempat saya tidak akan menjelaskan versi finalnya. </p><br><p>  Jadi, algoritma genetika adalah intinya.  Kromosom terdiri dari beberapa gen: </p><br><ul><li>  Nomor pecahan dalam rentang -PI..PI, menentukan arah gerakan </li><li>  Integer di kisaran 0..10 yang menentukan jumlah pengulangan tindakan ini </li><li>  Angka pecahan dari 0 hingga 1. Jika nilainya di atas ambang tertentu, lakukan lompatan </li></ul><br><p>  Genotipe dapat mencakup jumlah kromosom yang berbeda, tetapi sedemikian rupa sehingga jumlah tindakan (termasuk pengulangan) adalah 40. </p><br><p>  Awalnya, saya membuat beberapa lusin genotipe acak.  Untuk mereka saya tambahkan: </p><br><ul><li>  Lintasan tepat di atas bola </li><li>  Lintasan langsung ke segala arah, hanya 10 buah dengan offset 36 derajat </li><li>  Genotipe yang tidak melakukan apa-apa (tanpanya, bot selalu berjalan di suatu tempat, bahkan jika sudah berada pada titik optimal) </li><li>  Genotipe terbaik dari centang sebelumnya </li></ul><br><p>  Kemudian semuanya disimulasikan dan dijalankan melalui fungsi evaluasi.  N genotipe terbaik "bertahan" dan dikloning M kali dengan mutasi.  Setelah mutasi, setiap gen berubah dalam kisaran yang diberikan dengan probabilitas 10%.  Nah, ini sudah berulang selama beberapa generasi. <br>  Tidak ada persimpangan, dalam masalah ini saya tidak melihat adanya arti di dalamnya. </p><br><p>  Secara total, jumlah lintasan maksimum yang dimungkinkan per kutu per pemain sepak bola adalah sekitar 800, tetapi pada kenyataannya, dalam banyak kasus itu jauh lebih sedikit, karena  dalam beberapa kasus (misalnya, ketika dalam waktu dekat kami pasti tidak akan bisa menyentuh bola), pergerakan pemain digantikan oleh heuristik sederhana.  Selain itu, N, M dan jumlah generasi tergantung pada situasi di lapangan.  Pertama-tama, dari jarak ke bola.  Juga, perhitungan yang salah terganggu sebelum jadwal (tetapi tidak lebih awal dari generasi ke-5) jika lintasan dengan estimasi yang dapat diterima ditemukan. </p><br><h3 id="makro">  Makro </h3><br><p>  Kiper berlari ke titik di depan pusat gawang.  Tes saya menunjukkan bahwa yang terbaik bagi saya adalah bermain sambil berdiri di depan gawang, dan tidak di dalam gawang, seperti kebanyakan pemain di atas. </p><br><p>  Posisi titik menyimpang dari pusat tergantung pada beberapa faktor: posisi dan arah penerbangan bola, titik bola mengenai tujuan saya, jika tujuan direncanakan, lokasi lawan menyerang terdekat, dll. </p><br><p>  Jika bola ada di sisi lawan dan terbang menuju tujuannya, kita bisa pergi untuk nitro. </p><br><p>  Jika kiper saya dapat mengenai bola lebih awal dari penyerang saya (ditambah beberapa kondisi lainnya), maka penyerang mengabaikan bola dan berlari ke titik di tengah antara bola dan gawang lawan.  Saya pergi melalui banyak pilihan, di mana tepatnya dia menjalankan.  Dalam kasus saya, yang ini bekerja paling baik. </p><br><p>  Kalau tidak, jika bola terlalu jauh, penyerang berlari dalam garis lurus ke titik kontak terdekat bola dengan lantai, di mana ia dapat mencegat bola (jika kita tidak punya waktu untuk titik kontak pertama - periksa yang berikutnya, dll) </p><br><p>  Jika tidak (ketika bola mencapai), penyerang berlari ke tempat fungsi evaluasi memberitahunya.  Ya, dan juga, jika nitro terletak di dekatnya dan kami dapat mengambilnya, kami memilihnya. </p><br><p>  Dalam pertandingan 3x3, penyerang kedua lebih cenderung membidik bola dan dengan sedikit berlari ke depan, mengharapkan umpan dari kiper.  Tetapi jika masih berjalan, maka titik lain dipilih - lebih dekat ke garis tengah. </p><br><p>  Juga, setiap tick sekali mensimulasikan bola 100 ticks forward dengan 100 microtics (with caching). </p><br><p>  Lintasan ini telah digunakan di banyak tempat.  Sebagai contoh: </p><br><ul><li>  Untuk menentukan titik sentuh bola dengan lantai </li><li>  Untuk mengetahui apakah bola mengancam gawang saya dan apakah kiper perlu beralih ke mode simulasi </li></ul><br><p>  Lintasan yang persis sama digunakan dalam simulasi lintasan para pemain, agar tidak menghitung bola setiap saat.  Namun hanya sampai tabrakan pertama bola dengan pemain sepakbola apa pun. </p><br><p>  Ngomong-ngomong, menulis Footballist itu malas, kata-kata Player, Robot dicadangkan oleh strategi, <br>  jadi kelas pembungkus saya hanya dipanggil Bung :) </p><br><h3 id="simulyaciya">  Simulasi </h3><br><p>  Dalam kebanyakan kasus, ia berjalan dengan satu mikrotik, tetapi dalam beberapa situasi beralih ke mode akurat dengan sejumlah besar mikrotik (pada awalnya 100, kemudian dikurangi menjadi 50 dalam permainan 2x2, karena tes menunjukkan bahwa perbedaan hasil berada dalam margin kesalahan, dan ke 10). dalam 3x3, karena kalau tidak terbang ke timeout). </p><br><p>  Dalam mode akurat, saya beralih pada saat memantul, atau menjadi sangat dekat dengan bola sehingga tabrakan pada tik berikutnya mungkin terjadi.  Selain itu, ada juga banyak kruk kecil, retasan, optimisasi, di mana saya sendiri tidak akan mengerti. </p><br><p>  Sebagai contoh, bola terbang masih disimulasikan dengan 1 Mikrotik, tetapi jika setelah Mikrotik berikutnya saya melihat bahwa ada tabrakan, ia berguling kembali ke posisi sebelumnya dan disimulasikan lagi dengan akurasi yang lebih besar. </p><br><p>  Selain itu, saya juga berpura-pura menjadi pemain lain (baik saya sendiri dan orang lain) jika mereka ada di udara (dan karena itu lintasan mereka lebih mudah diprediksi), atau dekat dengan bola.  Untuk lawan, versi final menggunakan versi sederhana dari strategi pengambilan keputusan saya sendiri, yang diluncurkan setiap 5 ticks (lebih sering tidak memungkinkan kecepatan). </p><br><p>  Saat mensimulasikan setiap karakter, saya menghitung diri saya sendiri, bola dan pemain sepak bola lainnya 40 kutu di depan (batas saya pada jumlah aksi dalam genotipe) dan kemudian mensimulasikan jumlah kutu yang sama hanya satu bola. </p><br><h3 id="nitro">  Nitro </h3><br><p>  Sederhana hingga tidak senonoh. </p><br><p>  Dalam versi final, nitro selalu dihidupkan jika ya, jika pemain ada di udara, dan jika dia belum mengenai bola dalam beberapa kutu terakhir. </p><br><p>  Pada awalnya, saya selalu mengarahkan nitro lurus ke atas, tetapi kemudian saya mencoba bereksperimen dan opsi untuk pergi tepat ke tengah bola bekerja paling baik.  Saya juga mencoba opsi sehingga arah nitro dipilih oleh genetika. </p><br><p>  Itu bekerja jauh lebih buruk.  Mungkin karena kurangnya kedalaman pencarian. </p><br><h3 id="funkciya-ocenki">  Fungsi peringkat </h3><br><p>  Jumlah skor untuk setiap tick dengan atenuasi 2% per tick. </p><br><p>  Bobot terbesar, tentu saja, punya tujuan.  Beberapa hal memengaruhi berat badannya: </p><br><ul><li>  Jarak dari bola ke gawang musuh pada saat gol (semakin jauh semakin baik) </li><li>  Y mengoordinasikan bola (karena di bagian atas gawang lebih sulit untuk mengenai) </li><li>  Kecepatan bola di sepanjang sumbu Z (yang diarahkan ke gawang musuh) </li></ul><br><p>  Ketika menyerang saya, semuanya persis sama, hanya dengan tanda yang berlawanan. </p><br><p>  Selanjutnya, untuk penyerang, skor keseluruhan bergantung pada: </p><br><ul><li>  Jarak dari pemain ke bola (sehingga dia berlari ke bola bahkan jika dia tidak bisa memukulnya) </li><li>  Penalti untuk lompat (melompat hanya jika itu membawa begitu banyak poin sehingga mereka akan melebihi penalti ini) </li><li>  Jarak pada tick berikutnya dari simulasi dari bola ke lawan </li><li>  Koordinat bola Y (semakin tinggi itu, semakin sedikit peluang musuh untuk mencegatnya) </li><li>  Kosongkan sudut antara arah bola dan pusat gawang musuh </li><li>  Tandai jika saya menyentuh bola </li><li>  Bendera, apakah musuh menyentuh bola </li><li>  Bonus untuk pemilihan nitro </li></ul><br><p>  Juga, ada bonus kecil untuk memukul pemain musuh.  Meski sebenarnya sudah terjadi, tetapi jarang. </p><br><p>  Untuk penjaga gawang: </p><br><ul><li>  Bonus untuk jarak ke bola, kecepatan bola di Z, posisi bola di Y </li><li>  Hukuman untuk lompat </li><li>  Hukuman untuk menemukan bola di daerah di depan gawang saya </li><li>  Jarak ke musuh dan penyerang saya diperhitungkan (sehingga bola akan terbang menjauh dari musuh, tetapi, jika mungkin, terbang lebih dekat ke penyerang saya) </li><li>  Dan beberapa hal kecil lagi. </li></ul><br><h3 id="machine-learning">  Pembelajaran mesin </h3><br><p>  Itu hanya sedikit di salah satu cabang git sebagai percobaan.  Tapi bagi saya sepertinya layak disebut.  Saya tidak berhasil membawanya ke pikiran saya (dan saya tidak yakin apa yang masuk akal). </p><br><p>  Secara umum, saya mencoba memprediksi dengan bantuannya apakah musuh dapat mencegat bola berdasarkan posisi dan kecepatan musuh dan bola.  Saya berencana untuk menggunakan ini dalam fungsi evaluasi.  Menghukum lintasan yang mungkin untuk mencegat. </p><br><p>  Tetapi saya segera mengerti bahwa saya tidak hanya mampu memiliki jaringan saraf, tetapi tidak ada yang serius sama sekali, karena ini harus dilakukan 80 kali per lintasan.  Ya, meskipun 40 atau 20, jika tidak setiap kutu dihitung, tapi bagaimanapun, saya tidak punya cadangan waktu sama sekali, jadi saya bahkan tidak mempertimbangkan opsi ini. </p><br><p>  Inilah yang saya lakukan: </p><br><p>  Saya menjalankan beberapa permainan dengan bot yang dimodifikasi, di mana, ketika mencari lintasan, saya menyimpan data tentang diri saya dan bola, serta bendera, apakah lintasan ditemukan di mana saya mencegat bola. </p><br><p>  Saya menganggap semua koordinat relatif terhadap pemain sepak bola.  Yaitu  Saya selalu memilikinya di koordinat [0,0,0], jadi saya hanya menyimpan 10 bidang: posisi relatif bola, vektor kecepatan bola, vektor kecepatan pemain sepak bola, bendera intersepsi biner.  Saya menyimpan dataset hanya untuk bagian tengah bidang, karena  Saya menyadari bahwa algoritma sederhana belum akan menarik dan memperhitungkan papan. </p><br><p>  Kemudian saya memberi makan dataset DecisionTreeClassifier ini dengan max_depth = 7. Pohon yang terlatih memberikan akurasi, sejauh yang saya ingat, dari urutan 90%. </p><br><p>  Selanjutnya, saya mengekspor pohon ke satu set ifs (yang pada dasarnya DecisionTree). </p><br><p>  Itu terlihat seperti ini: </p><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dude_vel_x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dude_vel_y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dude_vel_z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_rel_pos_x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_rel_pos_y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_rel_pos_z, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_vel_x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_vel_y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ball_vel_z)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball_vel_z &lt;= <span class="hljs-number"><span class="hljs-number">6.4765448570251465</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dude_vel_y &lt;= -<span class="hljs-number"><span class="hljs-number">6.087389945983887</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball_vel_z &lt;= -<span class="hljs-number"><span class="hljs-number">20.188323974609375</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dude_vel_x &lt;= <span class="hljs-number"><span class="hljs-number">13.032730102539062</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ball_rel_pos_y &lt;= -<span class="hljs-number"><span class="hljs-number">1.1829500198364258</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ball_vel_y &lt;= <span class="hljs-number"><span class="hljs-number">18.906089782714844</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ............................</span></span></code> </pre> <br><p>  Pada tahap ini, saya menjalankan tes, tidak melihat peningkatan, dan menunda persidangan sampai nanti, yang, karena petualangan saya, tidak pernah tiba. </p><br><h3 id="shryodinbag">  Schroedinbag </h3><br><p>  Di suatu tempat setelah putaran pertama, saya menangkap hewan langka ini di rumah saya. </p><br><p>  Siapa yang tidak tahu, ini adalah bug yang mereka temukan hanya dengan membaca kode, dan setelah menemukannya, pengembang bertanya-tanya bagaimana program bisa bekerja sama sekali.  Dan dalam kasus saya, dia juga berada di 10 besar. </p><br><p>  Secara umum, bugnya adalah konstruktor dipanggil dalam fungsi salin gen, di mana argumen opsional dihilangkan yang mengandung nilai gen ini.  Dengan tidak adanya argumen ini, nilai dipilih secara acak.  Jadi, ketika mencoba menyalin gen, bukannya salinan, ia menciptakan contoh acak baru. </p><br><p>  Sebenarnya, alih-alih genetika, saya melakukan pencarian acak, karena setiap centang hanya menghasilkan beberapa ratus jalur acak dan memilih yang terbaik. </p><br><p>  Setelah koreksi (terdiri dari menambahkan 2 karakter ke kode), permainan menjadi sekitar 3 kali lebih baik. </p><br><h3 id="ritualnye-tancy">  Menari ritual </h3><br><p>  Pada titik waktu tertentu, saya perhatikan bahwa pemain terkadang bangkit tanpa alasan, karena jauh dari bola, terlepas dari penalti. </p><br><p>  Penjelasannya berubah sehingga saya menghitung momen lompatan dengan akurasi 100 mikrotik.  Dan kadang-kadang ternyata hanya pada saat lompatan ada tabrakan bola dengan barbel.  Dan tergantung pada keakuratan perhitungan tepat dalam centang ini, lintasan yang diusulkan dapat mengarah ke tujuan atau tidak. </p><br><p>  Secara kasar, bola terbang ke gawang lawan dan membentur tiang gawang.  pemain sepak bola saya, berlari di ujung lain lapangan, mensimulasikan lintasan tanpa melompat (dengan 1 mikrotik) dan melihat bahwa bola tidak mengenai sasaran. </p><br><p>  Kemudian lintasan lain datang, dengan lompatan tepat pada saat bola menyentuh mistar.  Dan karena saya menghitung tanda centang dengan lompatan 100 Mikrotik tidak hanya untuk pemain sepak bola, tetapi juga untuk bola, sudut pantulan bola yang dihitung berbeda dari sudut yang diperoleh di jalur dengan 1 mikrotik, dan mungkin terjadi bahwa bola dalam lintasan yang lebih akurat ini jatuh ke dalam gerbang. </p><br><p>  Dan karena itu, lintasan inilah yang akan dipilih dan bot akan melompat. </p><br><p>  Secara umum, dengan melakukan tarian ritual dengan memantul, para pemain menidurkan gol :) </p><br><h3 id="killer-ficha">  Fitur pembunuh </h3><br><p>  Bukan dia </p><br><h3 id="testirovanie">  Pengujian </h3><br><p>  Saya mengendarai game tanpa akhir dalam 8 utas (4 di setiap komputer dan laptop).  Saya memilih jumlah game sehingga signifikan secara statistik. </p><br><p>  Dengan peningkatan yang signifikan dalam strategi dapat dipenuhi dengan setengah ribu gol secara total, <br>  dengan koreksi yang lebih kecil, dibiarkan malam dan kemudian tagihan masuk ke ribuan. </p><br><h3 id="geneticheskiy-podbor-konstant">  Pemilihan konstanta genetik </h3><br><p>  Saya mencobanya sebelum babak pertama.  Itu tidak memberikan apa pun dengan alasan bahwa untuk genetika Anda perlu memainkan turnamen dari sejumlah besar permainan. </p><br><p>  Saya mencoba memainkan permainan 100.000 kutu, tetapi itu tidak cukup.  Dengan perbedaan kecil dalam kekuatan (dan biasanya ketika memilih konstanta inilah yang terjadi), pemenang per 100 k kutu tergantung terlalu banyak pada kasing.  Anda harus bermain lebih banyak untuk memastikan pemenangnya.  Dan saya tidak mampu meninggalkan seleksi selama sehari atau lebih, jadi saya menolak usaha ini. </p><br><h1 id="v-zaklyuchenie">  Kesimpulannya </h1><br><p>  Terima kasih tradisional kepada panitia.  Tugas itu menarik.  Sangat disayangkan bahwa saya terpaksa kehilangan hampir setengah dari kejuaraan dan benar-benar tidak melakukan apa pun untuk nitro atau tiga pemain. </p><br><p>  Akibatnya, sampai paling akhir saya menyaksikan di kotak pasir bagaimana strategi saya menang dalam mode 2x2 tanpa nitro dengan skor 13: 2 melawan Mr.Smile mana pun, yang mengambil tempat ke-3 di final, dan setelah beberapa pertandingan kalah baginya 12: 2 dalam mode 3x3 dengan nitro :) </p><br><p>  Dan tentu saja, video dari visualizer milik saya: </p><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/kh/hx/om/khhxombmg6eo4otune-_vdhdhbu.jpeg"></a> </p><br><p>  Hanya Anda yang mungkin harus mengucapkan selamat tinggal pada visualizer ini di kejuaraan mendatang. <br>  Untuk setiap kali saya semakin yakin bahwa jika Anda melamar tempat normal, satu-satunya pilihan adalah menulis di ... </p><br><p><img src="https://habrastorage.org/webt/gl/zj/1w/glzj1w_lztl_mhea9rqbs9rb5qq.jpeg"></p><br><p>  ... yah, Anda mengerti maksudnya. </p><br><p>  Capek setiap waktu untuk beristirahat di kelambatan Jawa dan mengurangi kekuatan strategi untuk memenuhi waktu yang ditentukan. </p><br><p>  Saya harap seseorang menemukan sendiri sesuatu yang menarik atau berguna dalam karya saya ini dengan catatan karakter otobiografi :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id440574/">https://habr.com/ru/post/id440574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id440562/index.html">Windows Phone - SEMUANYA, Ini Lagi atau Lagi</a></li>
<li><a href="../id440564/index.html">GPT-2 neural network dari OpenAI. Mulai cepat</a></li>
<li><a href="../id440566/index.html">Mempercepat tanpa hambatan atau mengenal SIMD</a></li>
<li><a href="../id440568/index.html">Kami sedang menulis aplikasi pembelajaran di Go dan Javascript untuk mengevaluasi pengembalian stok riil. Bagian 2 - Menguji backend</a></li>
<li><a href="../id440570/index.html">Peta Bayangan Reflektif: Bagian 2 - Implementasi</a></li>
<li><a href="../id440576/index.html">Perubahan penting pada CTE di PostgreSQL 12</a></li>
<li><a href="../id440582/index.html">Apakah mobil listrik ditarik ke bawah perusahaan mobil?</a></li>
<li><a href="../id440584/index.html">Apa yang salah dengan Raspberry Pi</a></li>
<li><a href="../id440586/index.html">Konsensus Eksonum: Cara Kerjanya</a></li>
<li><a href="../id440588/index.html">MIT belajar cara mentransmisikan suara dengan laser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>