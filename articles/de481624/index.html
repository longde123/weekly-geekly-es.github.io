<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏾 🚴🏽 📻 Schreiben einer Anwendung auf Flutter in Verbindung mit Redux 🔷 🔩 ▪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo an alle! In diesem Artikel möchte ich Ihnen zeigen, wie Sie mit Redux eine Flutter-Anwendung erstellen. Wenn Sie nicht wissen, was Flutter ist ,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Schreiben einer Anwendung auf Flutter in Verbindung mit Redux</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481624/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/xp/kq/1p/xpkq1phvyqjcztfqddbiedcjijw.jpeg" alt="Bild"></div><br><br>  Hallo an alle!  In diesem Artikel möchte ich Ihnen zeigen, wie Sie mit Redux eine Flutter-Anwendung erstellen.  Wenn Sie nicht wissen, was <a href="https://flutter.dev/">Flutter ist</a> , handelt es sich um ein Open-Source-SDK zum Erstellen mobiler Anwendungen von Google.  Es wird zum Entwickeln von Anwendungen für Android und iOS verwendet und ist auch die einzige Möglichkeit, Anwendungen für Google Fuchsia zu entwickeln. <br><br>  Wenn Sie mit Flutter vertraut sind und eine Anwendung erstellen möchten, die gut gestaltet, einfach zu testen und ein vorhersehbares Verhalten aufweist, lesen Sie diesen Artikel weiter und Sie werden es bald herausfinden! <br><br>  Aber bevor wir anfangen, die Anwendung selbst zu schreiben.  Machen wir uns ein wenig mit der Theorie vertraut und erklären wir zunächst, was Redux ist. <br><a name="habracut"></a><br><h3>  Was ist Redux? </h3><br>  <a href="https://redux.js.org/">Redux</a> ist eine Architektur, die ursprünglich für die JavaScript-Sprache erstellt wurde und in Anwendungen verwendet wird, die mit <i><b>reaktiven Frameworks</b></i> (z. B. React Native oder Flutter) erstellt wurden.  Redux ist eine vereinfachte Version der von Facebook erstellten Flux-Architektur.  Im Wesentlichen müssen Sie drei Dinge wissen: <br><br><ol><li>  Die einzige Quelle der Wahrheit - der gesamte <b>Status</b> Ihrer Anwendung wird an nur einem Ort gespeichert ( <b>Store genannt</b> ). </li><li>  state ist schreibgeschützt / state ist schreibgeschützt - um den Status der Anwendung zu ändern, müssen Sie Aktionen (action) senden, nach denen ein neuer Status erstellt wird </li><li>  Änderungen werden mit reinen Funktionen / reinen Funktionen vorgenommen - eine reine Funktion (der Einfachheit halber handelt es sich um eine Funktion ohne Nebenwirkungen) übernimmt den aktuellen Status der Anwendung und führt eine Aktion durch und gibt den neuen Status der Anwendung zurück </li></ol><br>  <b>Hinweis:</b> <i>Ein Nebeneffekt der Funktion ist die Fähigkeit, bei der Ausführung ihrer Berechnungen die Werte globaler Variablen zu lesen und zu ändern, E / A-Operationen auszuführen, auf Ausnahmesituationen zu reagieren und ihre Handler aufzurufen.</i>  <i>Wenn Sie eine Funktion mit einem Nebeneffekt zweimal mit demselben Satz von Eingabeargumentwerten aufrufen, kann es vorkommen, dass als Ergebnis unterschiedliche Werte zurückgegeben werden.</i>  <i>Solche Funktionen werden als nicht deterministische Funktionen mit Nebenwirkungen bezeichnet.</i> <br><br>  Klingt cool, aber was sind die Vorteile dieser Lösung? <br><br><ul><li>  Wir haben die Kontrolle über <b>Zustand / Zustand</b> - das bedeutet, wir wissen genau, was die Zustandsänderung verursacht hat, wir haben keinen doppelten Zustand und wir können den Datenfluss leicht überwachen </li><li>  <b>Reduzierer</b> sind reine Funktionen, die einfach zu testen sind - wir können den Status und die Aktion an den Eingang übergeben und prüfen, ob das Ergebnis wahr ist </li><li>  Die Anwendung ist klar strukturiert - wir haben verschiedene Ebenen für Aktionen, Modelle, Geschäftslogik usw. - damit Sie genau wissen, wo Sie eine weitere neue <i>Funktion</i> hinzufügen können </li><li>  Es ist eine großartige Architektur für komplexere Anwendungen. Sie müssen den Status nicht über den gesamten Strukturbaum Ihrer Ansicht von Eltern zu Kindern weitergeben </li><li>  und da ist noch einer ... </li></ul><br><h3>  Redux Zeitreise </h3><br>  Redux hat eine interessante Gelegenheit - Zeitreisen!  Mit Redux und verwandten Tools können Sie den Status Ihrer Anwendung über einen längeren Zeitraum verfolgen, den aktuellen Status überprüfen und jederzeit neu erstellen.  Sehen Sie diese Funktion in Aktion: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/d8e/168/e4cd8e16824e262401b8c2f7fae2a181.gif" alt="Bild"></div><br><h3>  Redux-Widgets mit einem einfachen Beispiel </h3><br>  Alle oben genannten Regeln bewirken, dass der Datenfluss in Redux unidirektional erfolgt.  Aber was heißt das?  In der Praxis geschieht dies alles mit <b>Aktionen</b> , <b>Reduzierungen</b> , <b>Speichern</b> und <b>Zuständen</b> .  Stellen wir uns eine Anwendung vor, die einen Zähler anzeigt: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/eb8/5e8/871eb85e8a5a12340a0b03d81ada4635.png" alt="Bild"></div><br><ol><li>  Ihre Anwendung hat beim Start einen bestimmten <b>Status</b> (die Anzahl der Klicks, die 0 ist) </li><li>  Basierend auf diesem Status wird die <b>Ansicht</b> gerendert. </li><li>  Wenn der Benutzer auf die Schaltfläche klickt, wird die <b>Aktion</b> gesendet (z. B. IncrementCounter). </li><li>  Danach erhält die <i>Aktion</i> einen <b>Reduzierer</b> , der den vorherigen <i>Status</i> kennt (Zähler 0), und erhält eine <i>Aktion</i> (IncrementCounter) und kann einen neuen <b>Status zurückgeben</b> (der Zähler ist jetzt 1). </li><li>  Unsere Anwendung hat einen neuen <b>Status</b> (Zähler ist 1) </li><li>  Basierend auf dem neuen <b>Status</b> wird die <b>Ansicht</b> neu gezeichnet, wodurch der aktuelle Status angezeigt wird </li></ol><br>  Wie Sie sehen, geht es in der Regel nur um den <b>Status</b> .  Sie haben einen Status der gesamten Anwendung, der <b>Status ist</b> <i>schreibgeschützt</i> , und um einen neuen <b>Status</b> zu erstellen, müssen Sie eine <b>Aktion</b> senden.  Durch das Senden von <i>Aktionen wird</i> ein <b>Reduzierer</b> gestartet, der einen neuen <b>Status</b> erstellt und an uns zurückgibt.  Und die Geschichte wiederholt sich. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/abd/064/a28/abd064a286704f7c441d19257ed8a390.png" alt="Bild"></div><br>  Lassen Sie uns eine kleine Anwendung erstellen und die Umsetzung des Redux-Ansatzes in Aktion kennenlernen. Die Anwendung wird als " <i>Einkaufsliste</i> " bezeichnet. <br><br>  Wir werden sehen, wie Redux in der Praxis funktioniert.  Wir erstellen eine einfache ShoppingCart-App.  Die Anwendung verfügt über Funktionen wie: <br><br><ul><li>  Käufe hinzufügen </li><li>  Der Kauf kann als abgeschlossen markiert werden </li><li>  und das ist im Grunde alles </li></ul><br>  Die Anwendung sieht folgendermaßen aus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85c/b09/372/85cb09372a6f1e4fa72817ab2f2f855a.png" alt="Bild"></div><br>  Beginnen wir mit dem Schreiben von Code! <br><br><h3>  Voraussetzung </h3><br>  In diesem Artikel werde ich die Erstellung der Benutzeroberfläche für diese Anwendung nicht zeigen.  <a href="https://github.com/pszklarska/flutter_shopping_cart">Sie können sich mit dem Code vertraut machen, den ich für Sie vorbereitet habe, bevor Sie mit dem Redux-Tauchgang fortfahren</a> .  Danach werden wir weiter Code schreiben und <i>Redux</i> zur aktuellen Anwendung hinzufügen. <br><br>  <b>Hinweis:</b> <i>Wenn Sie Flutter noch nie zuvor verwendet haben, empfehlen wir Ihnen, <a href="https://codelabs.developers.google.com/codelabs/flutter/">Flutter Codelabs von Google zu verwenden</a> .</i> <br><br><h3>  Vorbereitende Vorbereitung </h3><br>  Um <b>Redux</b> for Flutter verwenden zu können, müssen Abhängigkeiten zur Datei <i>pubspec.yaml hinzugefügt</i> werden: <br><br><pre><code class="swift hljs">flutter_redux: ^<span class="hljs-number"><span class="hljs-number">0.5</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br>  Sie können auch die aktuelle Version dieser Abhängigkeit überprüfen, indem Sie auf die Seite <a href="https://pub.dartlang.org/packages/flutter_redux">flutter_redux gehen</a> . <br><br>  <i>Zum Zeitpunkt des Schreibens war die Version flutter_redux 0.6.0</i> <br><br><h3>  Modell </h3><br>  Unsere Anwendung sollte in der Lage sein, das Hinzufügen und Ändern von Elementen zu steuern. <i>Daher verwenden</i> wir ein einfaches <i>CartItem-</i> Modell, um den Status eines Elements zu speichern.  Alle unsere Anwendungsstatus sind nur eine Liste von CartItems.  Wie Sie sehen, ist CartItem nur ein Objekt. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CartItem</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">String</span></span> name; bool checked; <span class="hljs-type"><span class="hljs-type">CartItem</span></span>(this.name, this.checked); }</code> </pre><br>  Zuerst müssen wir Aktionen deklarieren.  Aktion ist in der Tat jede Absicht, die aufgerufen werden kann, um den Status einer Anwendung zu ändern.  Im Wesentlichen gibt es zwei Aktionen zum Hinzufügen und Ändern eines Elements: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>(this.item); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToggleItemStateAction</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>(this.item); }</code> </pre><br>  Dann müssen wir unserer Anwendung mitteilen, was mit diesen <i>Aktionen geschehen soll</i> .  Aus diesem Grund werden <i>Reduzierungen</i> verwendet. Sie übernehmen nur den aktuellen Status der Anwendung und der Aktion (Anwendungsstatus und Aktion) und erstellen dann einen neuen Status und geben ihn zurück.  Wir werden zwei <i>Reduzierungsmethoden haben</i> : <br><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; appReducers(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addItem(items, action); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toggleItemState(items, action); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items; } <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; addItem(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-type"><span class="hljs-type">AddItemAction</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">List</span></span>.from(items)..add(action.item); } <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; toggleItemState(<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt; items, <span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span> action) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.name == action.item.name ? action.item : item).toList(); }</code> </pre><br>  Die <i>appReducers ()</i> -Methode delegiert die Aktion an die entsprechenden Methoden.  Die <i>Methoden</i> <i>addItem ()</i> und <i>toggleItemState ()</i> geben neue Listen zurück - dies ist unser neuer Zustand.  Wie Sie sehen, <b>sollten</b> Sie <b>die aktuelle Liste nicht ändern</b> .  Stattdessen erstellen wir jedes Mal eine neue Liste. <br><br><h3>  StoreProvider </h3><br>  Nachdem wir nun <i>Aktionen</i> und <i>Reduzierungen haben</i> , müssen wir einen Speicherort für den <i>Status der Anwendung bereitstellen</i> .  In Redux heißt es <b>store</b> und ist die einzige Quelle der Wahrheit für die Anwendung. <br><br><pre> <code class="swift hljs">void main() { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> store = new <span class="hljs-type"><span class="hljs-type">Store</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( appReducers, initialState: new <span class="hljs-type"><span class="hljs-type">List</span></span>()); runApp(new <span class="hljs-type"><span class="hljs-type">FlutterReduxApp</span></span>(store)); }</code> </pre><br>  Um ein <b>Geschäft</b> zu erstellen, müssen wir die <i>Reduktionsmethode</i> und den Anfangszustand übergeben.  Wenn wir ein <b>Geschäft erstellt haben</b> , müssen wir es an <i>StoreProvider übergeben</i> , um unserer Anwendung mitzuteilen, dass das <i>Geschäft</i> von jedem verwendet werden kann, der den aktuellen <b>Status der</b> Anwendung anfordern möchte. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlutterReduxApp</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">Store</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt; store; <span class="hljs-type"><span class="hljs-type">FlutterReduxApp</span></span>(this.store); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreProvider</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( store: store, child: new <span class="hljs-type"><span class="hljs-type">ShoppingCartApp</span></span>(), ); } }</code> </pre><br>  Im obigen Beispiel ist <i>ShoppingCartApp (</i> ) das Hauptwidget unserer Anwendung. <br><br><h3>  StoreConnector </h3><br>  Wir haben derzeit alles außer ... das Hinzufügen und Ändern von Artikeln zum Kauf.  Wie kann man das machen?  Um dies zu ermöglichen, müssen wir den <i>StoreConnector verwenden</i> .  Auf diese Weise können Sie den <b>Speicher abrufen</b> und ihm eine <i>Aktion</i> senden oder einfach den aktuellen <b>Status abrufen</b> . <br><br>  Zunächst möchten wir die aktuellen Daten abrufen und als Liste auf dem Bildschirm anzeigen: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingList</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;&gt;( converter: (store) =&gt; store.state, builder: (context, list) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">ListView</span></span>.builder( itemCount: list.length, itemBuilder: (context, position) =&gt; new <span class="hljs-type"><span class="hljs-type">ShoppingListItem</span></span>(list[position])); }, ); } }</code> </pre><br>  Der obige Code <i>umschließt ListView.builder</i> mit einem <i>StoreConnector</i> .  <b>StoreConnector</b> kann den aktuellen <b>Status</b> (eine Liste von Elementen <i>)</i> akzeptieren <i>und mithilfe von <i>Kartenfunktionen</i> in alles konvertieren.</i>  <i>In unserem Fall ist es jedoch derselbe <b>Status</b> (Liste), da wir hier eine Einkaufsliste benötigen.</i> <i><br><br></i>  <i>Als Nächstes erhalten wir in der <i>Builder-</i> Funktion eine Liste - im Grunde genommen eine Liste der <i>CartItems</i> aus dem <b>Store</b> , mit denen wir eine <b>ListView</b> erstellen <b>können</b> .</i> <i><br><br></i>  <i>Ok, cool - wir haben Daten.</i>  <i>Nun, wie man einige Daten einstellt?</i> <i><br><br></i>  <i>Dafür verwenden wir auch den <i>StoreConnector</i> , allerdings auf etwas andere Weise.</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialog</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span>&gt;( converter: (store) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (itemName) =&gt; store.dispatch(<span class="hljs-type"><span class="hljs-type">AddItemAction</span></span>(<span class="hljs-type"><span class="hljs-type">CartItem</span></span>(itemName, <span class="hljs-literal"><span class="hljs-literal">false</span></span>))); }, builder: (context, callback) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">AddItemDialogWidget</span></span>(callback); }); } }typedef <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span> = <span class="hljs-type"><span class="hljs-type">Function</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span> itemName);</code></i> </pre> <i><br></i>  <i>Schauen wir uns den Code an.</i>  <i>Wir haben den <i>StoreConnector</i> wie im vorherigen Beispiel verwendet, aber dieses Mal werden wir, anstatt die <i>CartItems-</i> Liste mit derselben Liste <i>abzugleichen</i> , eine <b>Zuordnungskonvertierung</b> in <i>OnItemAddedCallback durchführen</i> .</i>  <i>Daher können wir <a href="https://developer.mozilla.org/ru/docs/%25D0%25A1%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D1%258C/%25D1%2584%25D1%2583%25D0%25BD%25D0%25BA%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D1%258B%25D0%25B7%25D0%25BE%25D0%25B2%25D0%25B0">die Rückruffunktion</a> an <i>AddItemDialogWidget übergeben</i> und sie aufrufen, wenn der Benutzer <i>ein</i> neues Element <i>hinzufügt</i> :</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialogWidgetState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddItemDialogWidget</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-type"><span class="hljs-type">String</span></span> itemName; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">OnItemAddedCallback</span></span> callback; <span class="hljs-type"><span class="hljs-type">AddItemDialogWidgetState</span></span>(this.callback); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">AlertDialog</span></span>( ... actions: &lt;<span class="hljs-type"><span class="hljs-type">Widget</span></span>&gt;[ ... new <span class="hljs-type"><span class="hljs-type">FlatButton</span></span>( child: const <span class="hljs-type"><span class="hljs-type">Text</span></span>('<span class="hljs-type"><span class="hljs-type">ADD'</span></span>), onPressed: () { ... callback(itemName); }) ], ); } }</code></i> </pre> <i><br></i>  <i>Jedes Mal, wenn der Benutzer auf die Schaltfläche <i>HINZUFÜGEN</i> klickt, sendet die Rückruffunktion eine <b>Aktion</b> <i>AddItemAction ()</i> .</i> <i><br><br></i>  <i>Jetzt können wir eine sehr ähnliche Implementierung zum Ändern des Zustands eines Elements vornehmen.</i> <i><br><br></i> <pre> <i><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingListItem</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatelessWidget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">CartItem</span></span> item; <span class="hljs-type"><span class="hljs-type">ShoppingListItem</span></span>(this.item); @<span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-type"><span class="hljs-type">Widget</span></span> build(<span class="hljs-type"><span class="hljs-type">BuildContext</span></span> context) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">StoreConnector</span></span>&lt;<span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CartItem</span></span>&gt;, <span class="hljs-type"><span class="hljs-type">OnStateChanged</span></span>&gt;( converter: (store) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (item) =&gt; store.dispatch(<span class="hljs-type"><span class="hljs-type">ToggleItemStateAction</span></span>(item)); }, builder: (context, callback) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new <span class="hljs-type"><span class="hljs-type">ListTile</span></span>( title: new <span class="hljs-type"><span class="hljs-type">Text</span></span>(item.name), leading: new <span class="hljs-type"><span class="hljs-type">Checkbox</span></span>( value: item.checked, onChanged: (bool newValue) { callback(<span class="hljs-type"><span class="hljs-type">CartItem</span></span>(item.name, newValue)); }), ); }); } }</code></i> </pre> <i><br></i>  <i>Wie im vorherigen Beispiel verwenden wir den <b>StoreConnector</b> , um die <i>Liste für die <i>OnStateChanged-</i> Rückruffunktion <i>anzuzeigen</i> .</i></i>  <i><i>Jedes Mal, wenn sich das Flag ändert (in der onChanged-Methode), löst die Rückruffunktion das <i>ToggleItemStateAction-</i> Ereignis aus.</i></i> <i><i><br><br></i></i> <h3>  <i><i>Zusammenfassung</i></i> </h3> <i><i><br></i></i>  <i><i>Das ist alles!</i></i>  <i><i>In diesem Artikel haben wir eine einfache Anwendung erstellt, die eine Einkaufsliste anzeigt und ein wenig in die Verwendung der Redux-Architektur eintaucht.</i></i>  <i><i>In unserer Anwendung können wir Elemente hinzufügen und deren Status ändern.</i></i>  <i><i>Das Hinzufügen neuer Funktionen zu dieser Anwendung ist so einfach wie das Hinzufügen neuer <i>Aktionen</i> und <i>Reduzierungen</i> .</i></i> <i><i><br><br></i></i>  <i><i><a href="https://github.com/pszklarska/FlutterShoppingCart">Hier</a> finden Sie den Quellcode dieser Anwendung, einschließlich des <b>Zeitreise-</b> Widgets:</i></i> <i><i><br><br></i></i>  <i><i>Hoffe dir hat dieser Beitrag gefallen!</i></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de481624/">https://habr.com/ru/post/de481624/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de481610/index.html">PostgreSQL Antipatterns: Aktualisierung einer großen Tabelle unter Last</a></li>
<li><a href="../de481612/index.html">Unser kleiner Beitrag zum Kampf der Avalonia-Benutzeroberfläche für weniger Plattformen</a></li>
<li><a href="../de481616/index.html">Geodätische Kuppel. Über das Gerät und meine Erfahrungen mit Berechnungen</a></li>
<li><a href="../de481618/index.html">MVP in Unity oder wie man das Leben vereinfacht</a></li>
<li><a href="../de481620/index.html">Juniper SRX und Cisco ASA: Nächste Serie</a></li>
<li><a href="../de481626/index.html">Komplexe Anzeigesammlungen in iOS: Probleme und Lösungen am Beispiel des VKontakte-Feeds</a></li>
<li><a href="../de481628/index.html">Regeln für das Schreiben vorbereitender Schritte in Testfällen</a></li>
<li><a href="../de481630/index.html">Die besten nützlichen Tools und Ressourcen, um ein Startup im Jahr 2019 intelligenter zu machen</a></li>
<li><a href="../de481632/index.html">Cloud-Anbieter: Wer ist der Schönste auf dem Markt?</a></li>
<li><a href="../de481634/index.html">Food Design Digest, November 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>