<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ ğŸ’ƒğŸ½ ğŸ’Ÿ Internet Hal-Hal Saya: Kastil Tamu (Bagian 2) ğŸ¥” ğŸ† ğŸ˜´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai GT! Semua dengan kedatangan dan masa lalu! 
 Saya melanjutkan kisah tentang bagaimana saya menghubungkan kunci pintu ke Internet. Mulai di sini . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Internet Hal-Hal Saya: Kastil Tamu (Bagian 2)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/382677/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hai GT! Semua dengan kedatangan dan masa lalu! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya melanjutkan kisah tentang bagaimana saya menghubungkan kunci pintu ke Internet. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terima kasih banyak untuk semua komentarnya. Benar-benar ada solusi yang sudah jadi, tetapi ada juga sejumlah nuansa yang tidak memungkinkan saya untuk menggunakannya. Apartemen masih bukan hotel, jadi kami segera memberhentikan kastil hotel khusus. Kunci kunci, antena untuk NFC, agar tidak menakuti tetangga, kami juga tidak mempertimbangkan. Tidak ada kartu, token, atau media fisik lainnya yang dapat digunakan, dapat dipahami bahwa tidak ada cara untuk memindahkannya ke tamu sebelum ia membuka pintu.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kevo, August atau Lockitron tidak dapat digunakan, karena mereka didasarkan pada jenis kunci Amerika (deadbolt), yang tidak terpasang dengan baik pada pintu baja setebal 65-70 mm. Pilihan kami adalah CISA elektromekanis untuk pintu lapis baja, dengan harga sekitar 500 euro (belum dibeli, karena mahal). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan yang paling penting, saya ingin melakukan sesuatu dengan tangan saya sendiri, bukan untuk menjadi egois demi arus hobi.</font></font><br>
<img src="https://habrastorage.org/files/12f/2b5/6a3/12f2b56a3cae496d9f3717839e37cea1.JPG"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biarkan saya mengingatkan Anda bahwa pengontrol kunci terletak jauh di belakang NAT di jaringan rumah lokal, dan karena itu tidak masuk akal untuk meningkatkan server web di Arduin, tidak mungkin untuk mencapai itu dari Internet. Server ditulis dalam Python menggunakan kerangka Twisted, berjalan di Linux di tempat lain di mana ada alamat IP nyata, dan controller terhubung ke sana dan menunggu perintah. </font></font><br>
<img src="https://habrastorage.org/files/c3a/803/92b/c3a80392b83f4a0382e764ad8afa142e.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang saya ingin berbicara tentang logika kerja dan kriptografi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak menemukan sesuatu yang mengenkripsi lalu lintas untuk Arduina, karena komunikasi kastil dan server akan melalui saluran terbuka dengan lalu lintas yang tidak dienkripsi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam prototipe pertama, saya menggunakan MD5, sekarang saya mengubahnya menjadi SHA-1, di sini di perpustakaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cryptosuite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ini </font><font style="vertical-align: inherit;">. Ini mengkonsumsi lebih sedikit memori, dan sudah ada fungsi HMAC yang sudah jadi.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kuncinya adalah kata sandi hingga 30 karakter ASCII, disimpan dalam memori EEPROM controller. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam prototipe pertama, kata sandi yang sama disimpan secara eksplisit di server, yang tentu saja bukan keamanan. Prototipe kedua membutuhkan dua kata sandi. Yang pertama adalah untuk mengotentikasi kunci ketika terhubung ke server, Anda tidak dapat membuka kunci dengan kata sandi ini, diperlukan agar hanya kunci yang benar yang dapat terhubung ke server. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kunci terhubung ke server dan pertama-tama memberitahu pengenalnya. Server memeriksa dalam database jika ada kunci seperti itu, dan jika ada, ia mengirimkan urutan ASCII yang dihasilkan secara acak sebagai tanggapan. Kunci â€œmenandatanganinyaâ€ dengan kata sandi dan mengirim hash kembali. Server membandingkan hash yang diterima dengan apa yang dihitung sendiri, dan jika cocok, itu akan mengotorisasi pengontrol yang terhubung sebagai "kunci".</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kalau tidak, koneksi diatur ulang. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kata sandi kedua sudah menjadi kunci digital, tidak disimpan di server. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berfungsi sebagai berikut: aplikasi pengguna panggilan melalui fungsi SOAP di server, menunjukkan ID kunci dan perintah yang ingin ia kirim kepadanya. Akibatnya, fungsi mengembalikan ID permintaan. Server meneruskan perintah ini ke controller, controller mengirimkan urutan ASCII yang dihasilkan secara acak sebagai respons, dan menunggu respons "benar" selama beberapa detik. Selanjutnya, aplikasi pengguna perlu mendapatkannya dari server, melalui SOAP yang sama dengan ID permintaan, menandatanganinya dengan kunci digital dan mengirimkannya kembali. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kontroler membandingkan hash yang diterima dengan yang dihitung sendiri dan jika cocok, ia mengeksekusi perintah yang sebelumnya diterima, yang dilaporkan ke server.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Waktu untuk mengkonfirmasi perintah dibatasi hingga 2 detik, jika tidak ada respons yang diterima selama waktu ini, pengontrol mengabaikan perintah yang sebelumnya diterima. Jika hash tidak cocok, perintah ini juga diabaikan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, saya mencoba melindungi diri dari serangan â€œman in the middleâ€, yang sangat mudah untuk mengatur kabel penyedia saya. Koneksi ada sederhana, tidak ada kata sandi dan sertifikat, cukup untuk memotong twisted pair di perisai, memerasnya di kedua sisi, tancapkan ke jaringan dari sisi apartemen dengan alamat IP dari server perintah, meniru kunci di ujung lain (saya juga menulis skrip untuk emulasi pada python untuk debugging ), setelah mengatur "firewall" seperti itu dengan penyadapan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, menurut saya, kastil itu ternyata cukup terlindungi.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan meretas server perintah dan mencuri basis datanya dengan kata sandi untuk otorisasi oleh kunci tidak akan banyak masalah, karena mereka tidak dapat membuka kunci. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetap hanya berurusan dengan para tamu. Ini adalah persyaratan No. 6-8 dari artikel pertama. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keyboard, proksi, RFID, dan NFC bukan opsi, alasan di atas tulis. Tetapi hampir semua orang memiliki smartphone dan semua smartphone memiliki Bluetooth, pilihannya jelas! </font></font><br>
<img src="https://habrastorage.org/files/d2a/1bd/1b0/d2a1bd1b0a2a4f81a906fba3e2640b5e.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam prototipe pertama, seorang tamu dikaitkan dengan satu kode akses tunggal. Dalam database server untuk kode ini disimpan ID kunci, tanggal dan waktu awal dan akhir akses tamu, well, bidang teks untuk nama tamu yang dapat dibaca manusia.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamu datang ke kastil, meluncurkan aplikasi mobile di smartphone-nya, mengirimkan kode akses via Bluetooth ke controller, sebuah pesan datang dari controller ke server yang menyatakan bahwa seorang tamu telah mendekatinya dengan kode akses seperti itu. Server memeriksa terhadap database, dan jika tamu yang benar tiba pada waktu yang tepat di tempat yang tepat, mengirimkan perintah untuk membuka kunci. Bahkan, alih-alih kode akses yang jelas, tamu akan mengirim hash HMAC yang ditandatangani dengan "stempel sementara" (representasi string waktu Unix dibagi dengan 30 dengan bagian fraksional dibuang). Server untuk verifikasi membuat permintaan ke database dengan pilihan semua kode akses yang berlaku saat ini untuk kunci yang diberikan, kemudian beralih melalui itu dan menghitung HMAC yang sama untuk mereka, jika menemukan kecocokan, mengirimkan perintah untuk membuka,jika pencarian kode akses berakhir sebelum kecocokan dapat ditemukan, respons negatif dikirim ke kunci pada upaya untuk membukanya.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa kunci digital untuk otorisasi tersebut harus disimpan di server. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harus mempersulit otorisasi "tamu" untuk prototipe kedua. Kode akses tamu sekarang terdiri dari dua kunci, sebut saja "server" dan "pribadi". Server diperlukan untuk membuat akun tamu di server, dan pribadi untuk membuka kunci itu sendiri. Ruang server akan secara eksplisit disimpan di server, dan dari ruang privat hanya akan ada hash, tetapi bukan yang sederhana, tetapi HMAC dengan kunci digital untuk kunci. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang sesi otorisasi tamu terlihat seperti ini: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Aplikasi tamu meneruskan kunci "server" ke controller (seperti pada prototipe pertama hash-nya) dan </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Server memeriksa dengan cara yang sama, tetapi alih-alih perintah terbuka mengirim hash kunci pribadi</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3. Pengontrol membandingkan hash kunci pribadi yang diterima dari server dengan yang dihitung secara independen dan jika cocok, kunci terbuka. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, server tidak menyimpan apa pun yang bisa membuka kunci. Ini tidak akan berfungsi untuk menghasilkan hash yang diinginkan tanpa mengetahui kunci digital. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bluetooth yang sama juga digunakan untuk akses "master" tanpa Internet. Pengontrol menerima perintah melalui itu, merespons dengan kode satu kali, yang harus ditandatangani dengan kunci digital yang benar selama 2 detik.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Melalui itu, saya ingin membuat pengaturan dasar controller. </font><font style="vertical-align: inherit;">Pemilik menekan tombol khusus pada pengontrol, setelah itu ia mulai menerima serangkaian perintah yang diperluas, seperti pengaturan ID kunci, kunci rahasia, alamat port server, pengaturan jaringan, dll. </font><font style="vertical-align: inherit;">Tetapi di Adruin memori habis dan sketsa tidak cocok. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, demonstrasi singkat dari karya tersebut.</font></font><br>
<iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://www.youtube.com/embed/dfSnXt631KQ%3Ffeature%3Doembed&amp;usg=ALkJrhiLj9v44ptqfPy30S-UC7ZFA4qOxA" frameborder="0" allowfullscreen=""></iframe></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id382677/">https://habr.com/ru/post/id382677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id382665/index.html">Strategi dan taktik pemasaran email. Bagian 1</a></li>
<li><a href="../id382667/index.html">Intel Mengumumkan Prosesor Notebook Xeon Pertama</a></li>
<li><a href="../id382669/index.html">Sebuah pembersih. Memerangi perangkat lunak yang tidak bersih</a></li>
<li><a href="../id382673/index.html">Aibo Robot Dog Mortality</a></li>
<li><a href="../id382675/index.html">Sloth raksasa dari masa lalu bisa meletakkan garis kereta bawah tanah</a></li>
<li><a href="../id382679/index.html">Para astronom dapat mengambil gambar danau lava di permukaan Io, satelit Jupiter</a></li>
<li><a href="../id382681/index.html">5 jam pendekatan Soyuz ke ISS - dalam setengah menit video di YouTube</a></li>
<li><a href="../id382685/index.html">Lihatlah ke luar cakrawala</a></li>
<li><a href="../id382687/index.html">Para ilmuwan CERN sedang mempersiapkan "medan gaya" untuk melindungi astronot dari radiasi</a></li>
<li><a href="../id382689/index.html">Kami mengontrol pencahayaan di apartemen (NooLite, Raspberry Pi, dan WebIOPi)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>