<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÅ üå≤ üàöÔ∏è Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging √ºber ActiveMQ und Kafka. Kapitel 2. ActiveMQ üì¨ üë©üèæ‚ÄçüöÄ üî≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fortsetzung der √úbersetzung eines kleinen Buches: 
 "Message Brokers verstehen", 
 Autor: Jakub Korab, Herausgeber: O'Reilly Media, Inc., Erscheinungs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nachrichtenbroker verstehen. Erlernen der Mechanismen des Messaging √ºber ActiveMQ und Kafka. Kapitel 2. ActiveMQ</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471268/">  Fortsetzung der √úbersetzung eines kleinen Buches: <br>  "Message Brokers verstehen", <br>  Autor: Jakub Korab, Herausgeber: O'Reilly Media, Inc., Erscheinungsdatum: Juni 2017, ISBN: 9781492049296. <br><br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbersetzung abgeschlossen</a></b> <br><br>  Vorheriger Teil: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu Message Brokern.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erlernen der Mechanismen des Messaging √ºber ActiveMQ und Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 1. Einf√ºhrung</a> <br><a name="habracut"></a><br><h2>  KAPITEL 2 </h2><br><h2>  Activemq </h2><br>  ActiveMQ l√§sst sich am besten als klassisches Messagingsystem beschreiben.  Es wurde 2004 geschrieben, um den Bedarf an einem Open-Source-Nachrichtenbroker zu decken.  Zu dieser Zeit waren teure kommerzielle Produkte die einzige Wahl, wenn Sie Messaging in Ihren Anwendungen verwenden wollten. <br><br>  ActiveMQ wurde als Implementierung der Java Message Service (JMS) -Spezifikation entwickelt.  Diese Entscheidung wurde getroffen, um die Anforderungen f√ºr die Implementierung von JMS-kompatiblem Messaging im Apache Geronimo-Projekt, einem Open-Source-J2EE-Anwendungsserver, zu erf√ºllen. <br>  Ein Messaging-System (oder eine nachrichtenorientierte Middleware, wie sie manchmal genannt wird), die die JMS-Spezifikation implementiert, besteht aus den folgenden Komponenten: <br><br>  <b>Makler</b> <br><br>  Eine zentrale Middleware, die Nachrichten verteilt. <br><br>  <b>Kunde</b> <br><br>  Die Software, die Nachrichten √ºber einen Broker sendet.  Es besteht wiederum aus folgenden Artefakten: <br><br><ul><li>  Code mit der JMS-API. </li><li>  Die JMS-API besteht aus einer Reihe von Schnittstellen f√ºr die Interaktion mit einem Broker gem√§√ü den in der JMS-Spezifikation festgelegten Garantien. </li><li>  Die Clientbibliothek des Systems, die die Implementierung der API bereitstellt und mit dem Broker interagiert. </li></ul><br>  Der Client und der Broker kommunizieren √ºber das Anwendungsschichtprotokoll, das auch als <i>Interaktionsprotokoll bezeichnet wird, miteinander</i> <a href="">(Abbildung 2-1)</a> .  Die JMS-Spezifikation √ºberlie√ü die Details dieses Protokolls bestimmten Implementierungen. <br><br><img src="https://habrastorage.org/webt/u1/wi/za/u1wiza7rupveiqnyqktuqsa-mvs.png"><br>  <i>Abbildung 2-1.</i>  <i>JMS-√úberpr√ºfung</i> <br><br>  JMS verwendet den Begriff <i>Provider</i> , um die Implementierung des Messaging-Systems durch den <i>Anbieter</i> zu beschreiben, das der JMS-API zugrunde liegt, zu der der Broker sowie seine Client-Bibliotheken geh√∂ren. <br><br>  Die Entscheidung f√ºr die Implementierung von JMS hatte weitreichende Konsequenzen f√ºr die Implementierungsentscheidungen der ActiveMQ-Autoren.  Die Spezifikation selbst enth√§lt klare Richtlinien zu den Verantwortlichkeiten des Kunden des Nachrichtensystems und des Maklers, mit dem er kommuniziert, wobei die Verpflichtung des Maklers zur Verteilung und Zustellung von Nachrichten bevorzugt wird.  Die Hauptverantwortung des Kunden besteht darin, mit dem Adressaten (Warteschlange oder Thema) der von ihm gesendeten Nachrichten zu interagieren.  Die Spezifikation selbst zielt darauf ab, die Interaktion der API mit dem Broker relativ einfach zu machen. <br><br>  Dieser Bereich hatte, wie wir sp√§ter sehen werden, einen erheblichen Einfluss auf die ActiveMQ-Leistung.  Zus√§tzlich zu den Komplexit√§ten des Brokers hatte das Kompatibilit√§tspaket f√ºr die von Sun Microsystems bereitgestellte Spezifikation viele Nuancen, die sich auf die Leistung auswirkten.  Diese Nuancen sollten alle ber√ºcksichtigt worden sein, damit ActiveMQ als JMS-kompatibel angesehen werden kann. <br><br><h3>  Kommunikation </h3><br>  Obwohl die API und das erwartete Verhalten in der JMS-Spezifikation gut definiert waren, wurde das tats√§chliche Client-Broker-Kommunikationsprotokoll absichtlich von der Spezifikation ausgeschlossen, damit vorhandene Broker JMS-konform gemacht werden konnten.  Somit konnte ActiveMQ sein eigenes Interaktionsprotokoll, OpenWire, definieren.  OpenWire wird von der Implementierung der ActiveMQ JMS-Clientbibliothek sowie von ihren Gegenst√ºcken in .Net und C ++: NMS und CMS verwendet, bei denen es sich um ActiveMQ-Teilprojekte handelt, die von der Apache Software Foundation gehostet werden. <br><br>  Im Laufe der Zeit wurde ActiveMQ um die Unterst√ºtzung anderer Interaktionsprotokolle erweitert, wodurch die F√§higkeit zur Interaktion mit anderen Sprachen und Umgebungen verbessert wurde: <br><br>  <b>AMQP 1.0</b> <br><br>  Das Advanced Message Queuing-Protokoll (ISO / IEC 19464: 2014) darf nicht mit seinem Vorg√§nger 0.X verwechselt werden, der in anderen Messaging-Systemen, insbesondere RabbitMQ, unter Verwendung von 0.9.1 implementiert ist.  AMQP 1.0 ist ein universelles Bin√§rprotokoll zum Austausch von Nachrichten zwischen zwei Knoten.  Es hat kein Konzept f√ºr Kunden oder Makler und enth√§lt Funktionen wie Flusskontrolle, Transaktionen und verschiedene QoS (nicht mehr als einmal, mindestens einmal und genau einmal). <br><br>  <b>STOMP</b> <br><br>  Simple / Streaming Text Oriented Messaging Protocol, ein einfach zu implementierendes Protokoll mit Dutzenden von Client-Implementierungen in verschiedenen Sprachen. <br><br>  <b>Xmpp</b> <br><br>  Erweiterbares Messaging- und Anwesenheitsprotokoll.  (Extensible Messaging and Presence Protocol).  Fr√ºher als Jabber bezeichnet, wurde dieses XML-basierte Protokoll urspr√ºnglich f√ºr Chat-Systeme entwickelt, aber √ºber seine urspr√ºnglichen Anwendungsf√§lle hinaus um Publish-Subscribe-Messaging erweitert. <br><br>  <b>MQTT</b> <br><br>  Das einfache Publish-Subscribe-Protokoll (ISO / IEC 20922: 2016), das f√ºr Machine-to-Machine- (M2M) und Internet of Things- (IoT) Anwendungen verwendet wird. <br><br>  ActiveMQ unterst√ºtzt auch das Auferlegen der oben genannten Protokolle auf WebSockets, wodurch ein Vollduplex-Datenaustausch zwischen Anwendungen in einem Webbrowser und Zielen im Broker erm√∂glicht wird. <br><br>  Wenn wir jetzt √ºber ActiveMQ sprechen, beziehen wir uns nicht mehr ausschlie√ülich auf den Interaktionsstapel, der auf den JMS / NMS / CMS-Bibliotheken und dem OpenWire-Protokoll basiert.  Die Kombination und Auswahl von Sprachen, Plattformen und externen Bibliotheken, die f√ºr diese Anwendung am besten geeignet sind, wird immer beliebter.  Beispielsweise kann eine JavaScript-Anwendung in einem Browser mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eclipse Paho</a> MQTT-Bibliothek ausgef√ºhrt werden, um Nachrichten √ºber Web-Sockets an ActiveMQ zu senden. Diese Nachrichten werden von einem C ++ - Serverprozess gelesen, der AMQP √ºber die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Qpid Proton-</a> Bibliothek verwendet.  Aus dieser Perspektive wird die Messaging-Landschaft immer vielf√§ltiger. <br><br>  Mit Blick auf die Zukunft wird insbesondere AMQP viel mehr M√∂glichkeiten haben als jetzt, da Komponenten, die weder Kunden noch Makler sind, ein vertrauterer Bestandteil der Messaging-Landschaft werden.  Beispielsweise fungiert der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apache Qpid Dispatch Router</a> als Nachrichtenrouter, mit dem Clients eine direkte Verbindung herstellen, sodass verschiedene Ziele unterschiedliche Adressen verarbeiten k√∂nnen und die M√∂glichkeit des Sharding (Trennung) besteht. <br><br>  Beachten Sie bei der Arbeit mit Bibliotheken und externen Komponenten von Drittanbietern, dass diese eine variable Qualit√§t haben und m√∂glicherweise nicht mit den in ActiveMQ bereitgestellten Funktionen kompatibel sind.  Als sehr einfaches Beispiel: Es ist unm√∂glich, Nachrichten √ºber MQTT an die Warteschlange zu senden (ohne das Routing im Broker einzurichten).  Daher m√ºssen Sie einige Zeit mit Optionen arbeiten, um den Stapel des Messagingsystems zu bestimmen, der f√ºr die Anforderungen Ihrer Anwendung am besten geeignet ist. <br><br><h3>  Der Kompromiss zwischen Leistung und Zuverl√§ssigkeit </h3><br>  Bevor wir uns mit den Details der Funktionsweise von Punkt-zu-Punkt-Nachrichten in ActiveMQ befassen, m√ºssen wir ein wenig dar√ºber sprechen, was alle Systeme mit starker Datenverarbeitung zu bieten haben: einen Kompromiss zwischen Leistung und Zuverl√§ssigkeit. <br><br>  Jedes System, das Daten akzeptiert, sei es ein Nachrichtenbroker oder eine Datenbank, sollte angewiesen werden, wie diese Daten im Falle eines Fehlers verarbeitet werden.  Fehler k√∂nnen viele Formen annehmen, aber der Einfachheit halber werden wir sie auf eine Situation eingrenzen, in der das System die Stromversorgung verliert und sofort herunterf√§hrt.  In dieser Situation m√ºssen wir dar√ºber spekulieren, was mit den Daten im System geschehen wird.  Wenn sich die Daten (in diesem Fall Nachrichten) im Speicher oder im fl√ºchtigen Teil von Eisen befanden, z. B. im Cache, gehen diese Daten verloren.  Wenn die Daten jedoch an einen nichtfl√ºchtigen Speicher gesendet wurden, z. B. an eine Festplatte, sind sie wieder verf√ºgbar, wenn das System wieder funktioniert. <br><br>  Unter diesem Gesichtspunkt ist es sinnvoll, dass wir Nachrichten, die bei einem Brokerfehler nicht verloren gehen sollen, in den permanenten Speicher schreiben m√ºssen.  Die Kosten f√ºr diese spezielle L√∂sung sind leider ziemlich hoch. <br><br>  Beachten Sie, dass der Unterschied zwischen dem Schreiben eines Megabytes an Daten auf die Festplatte 100-1000-mal langsamer ist als das Schreiben in den Speicher.  Daher muss der Anwendungsentwickler entscheiden, ob die Zuverl√§ssigkeit der Nachricht den Leistungsverlust wert ist.  Entscheidungen wie diese sollten basierend auf einem Nutzungsszenario getroffen werden. <br><br>  Der Kompromiss zwischen Leistung und Zuverl√§ssigkeit basiert auf einer Reihe von Optionen.  Je h√∂her die Zuverl√§ssigkeit, desto geringer die Leistung.  Wenn Sie das System weniger zuverl√§ssig machen, z. B. Nachrichten nur im Speicher speichern, steigt Ihre Produktivit√§t erheblich.  Standardm√§√üig ist JMS so konfiguriert, dass ActiveMQ aus Gr√ºnden der Zuverl√§ssigkeit sofort einsatzbereit ist.  Es gibt viele Mechanismen, mit denen Sie den Broker konfigurieren und mit ihm an einer Position in diesem Spektrum interagieren k√∂nnen, die f√ºr bestimmte Szenarien der Verwendung des Messagingsystems am besten geeignet ist. <br><br>  Dieser Kompromiss wird auf der Ebene der einzelnen Makler angewendet.  Nach Abschluss der Einrichtung eines einzelnen Brokers ist es jedoch m√∂glich, das Nachrichtensystem √ºber diesen Punkt hinaus zu skalieren, indem die Nachrichtenfl√ºsse sorgf√§ltig untersucht und der Datenverkehr zwischen mehreren Brokern aufgeteilt wird.  Dies kann erreicht werden, indem bestimmten Empf√§ngern ihre eigenen Broker zur Verf√ºgung gestellt werden oder indem der gesamte Nachrichtenfluss entweder auf Anwendungsebene oder unter Verwendung einer Zwischenkomponente aufgeteilt wird.  Sp√§ter werden wir genauer untersuchen, wie die Topologien von Brokern ber√ºcksichtigt werden k√∂nnen. <br><br><h3>  Nachrichten speichern </h3><br>  ActiveMQ verf√ºgt √ºber eine Reihe steckbarer Strategien zur Aufbewahrung von Nachrichten.  Sie werden in Form von Persistenzadaptern (Persistenzadaptern) geliefert, die als Nachrichtenspeicher-Engines betrachtet werden k√∂nnen.  Dazu geh√∂ren festplattenbasierte L√∂sungen wie KahaDB und LevelDB sowie die M√∂glichkeit, die Datenbank √ºber JDBC zu verwenden.  Da erstere am h√§ufigsten verwendet werden, werden wir unsere Diskussion auf sie konzentrieren. <br><br>  Wenn ein Broker persistente Nachrichten empf√§ngt, werden diese zuerst in einem Journal auf die Festplatte geschrieben.  Ein Journal ist eine Datenstruktur auf der Festplatte, in der Sie nur Daten hinzuf√ºgen k√∂nnen und die aus mehreren Dateien besteht.  Eingehende Nachrichten werden vom Broker in eine protokollunabh√§ngige Darstellung des Objekts serialisiert und dann in bin√§rer Form gemarshallt, die dann an das Ende des Protokolls geschrieben wird.  Das Protokoll enth√§lt ein Protokoll aller eingehenden Nachrichten sowie Informationen zu den Nachrichten, die vom Client als gelesen best√§tigt wurden. <br><br>  Persistenz-Festplattenadapter unterst√ºtzen Indexdateien, die verfolgen, wo sich die folgenden weitergeleiteten Nachrichten im Protokoll befinden.  Wenn alle Nachrichten aus der Protokolldatei gelesen werden, werden sie vom ActiveMQ-Hintergrundworkflow entweder gel√∂scht oder archiviert.  Wenn dieses Protokoll w√§hrend des Ausfalls des Brokers besch√§digt wird, erstellt ActiveMQ es basierend auf den Informationen in den Protokolldateien neu. <br><br>  Nachrichten aus allen Warteschlangen werden in dieselben Protokolldateien geschrieben. Wenn also eine Nachricht nicht gelesen wird, kann die gesamte Datei (normalerweise 32 MB oder 100 MB, abh√§ngig vom Persistenzadapter) nicht gel√∂scht werden.  Dies kann im Laufe der Zeit zu Problemen mit geringem Speicherplatz f√ºhren. <br><blockquote>  Klassische Nachrichtenbroker sind nicht f√ºr die Langzeitspeicherung konzipiert - lesen Sie Ihre Nachrichten! </blockquote>  Protokolle sind ein √§u√üerst effizienter Mechanismus zum Speichern und anschlie√üenden Abrufen von Nachrichten, da der Datentr√§gerzugriff f√ºr beide Vorg√§nge sequentiell erfolgt.  Auf herk√∂mmlichen Festplatten wird dadurch die Anzahl der Festplattensuchen durch Zylinder minimiert, da die K√∂pfe auf der Festplatte einfach weiterhin Sektoren auf das rotierende Substrat der Festplatte lesen oder schreiben.  In √§hnlicher Weise ist bei SSDs der sequentielle Zugriff viel schneller als der wahlfreie Zugriff, da erstere die Speicherseiten des Laufwerks besser nutzen. <br><br><h3>  Festplattenleistungsfaktoren </h3><br>  Es gibt eine Reihe von Faktoren, die die Geschwindigkeit bestimmen, mit der eine Festplatte arbeiten kann.  Um dies zu verstehen, betrachten Sie die Methode zum Schreiben auf eine Disc anhand eines vereinfachten mentalen Modells einer Pipe ( <a href="">Abbildung 2-2</a> ). <br><br><img src="https://habrastorage.org/webt/kv/wx/j_/kvwxj_wqzdn772kf0lb5yttf4i8.png"><br>  <i>Abbildung 2-2.</i>  <i>Disk Performance Tube-Modell</i> <br><br>  Ein Rohr hat drei Dimensionen: <br><br>  <b>L√§nge</b> <br><br>  Entspricht der erwarteten <i>Latenz</i> , um einen Vorgang abzuschlie√üen.  F√ºr die meisten lokalen Laufwerke ist es ziemlich gut, aber es kann in Cloud-Umgebungen, in denen das lokale Laufwerk tats√§chlich online ist, zu einem wichtigen einschr√§nkenden Faktor werden.  Zum Zeitpunkt des Schreibens (April 2017) garantiert Amazon beispielsweise, dass das Schreiben in den EBS-Speicher "in weniger als 2 ms" erfolgt.  Wenn wir nacheinander aufnehmen, ergibt dies einen maximalen Durchsatz von 500 Datens√§tzen pro Sekunde. <br><br>  <b>Breite</b> <br><br>  Bestimmt die <i>Tragf√§higkeit oder Bandbreite einer</i> einzelnen Operation.  Dateisystem-Caches verwenden diese Eigenschaft, indem sie viele kleine Datens√§tze zu einem kleineren Satz gr√∂√üerer Schreibvorg√§nge kombinieren, die auf der Festplatte ausgef√ºhrt werden. <br><br>  <b>Bandbreite im Laufe der Zeit</b> <br><br>  Die Idee wird in Form einer Reihe von Ereignissen dargestellt, die sich gleichzeitig in der Pipe befinden k√∂nnen, ausgedr√ºckt durch eine Metrik namens <i>IOPS (die Anzahl der E / A-Operationen pro Sekunde)</i> .  IOPS wird h√§ufig von Speicherherstellern und Cloud-Anbietern verwendet, um die Leistung zu messen.  Die Festplatte hat in verschiedenen Kontexten unterschiedliche IOPS-Werte: ob die Arbeitslast haupts√§chlich aus Lesen, Schreiben oder einer Kombination davon besteht und ob diese Vorg√§nge sequentiell, willk√ºrlich oder gemischt sind.  Die aus Sicht des Brokers am interessantesten IOPS-Messungen sind sequentielle Lese- und Schreibvorg√§nge, da sie dem Lesen und Schreiben von Protokollen eines Protokolls entsprechen. <br><br>  Der maximale Durchsatz eines Nachrichtenbrokers wird durch das <i>Erreichen der ersten dieser Einschr√§nkungen bestimmt.</i> Die Brokerkonfiguration h√§ngt weitgehend von der Art und Weise ab, wie Sie mit Datentr√§gern interagieren.  Dies h√§ngt nicht nur davon ab, wie beispielsweise der Broker konfiguriert ist, sondern auch davon, wie Produzenten mit dem Broker interagieren.  Wie bei allem, was mit der Leistung zu tun hat, muss der Broker auf eine repr√§sentative Arbeitslast (d. H. So nah wie m√∂glich an realen Nachrichten) und auf die tats√§chliche Speicherkonfiguration getestet werden, die im PROM verwendet wird.  Dies geschieht, um zu verstehen, wie sich das System in der Realit√§t verh√§lt. <br><br><h3>  JMS-API </h3><br>  Bevor wir uns mit den Details der Kommunikation von ActiveMQ mit Clients befassen, m√ºssen wir zun√§chst die JMS-API kennenlernen.  Die API definiert eine Reihe von Programmierschnittstellen, die vom Clientcode verwendet werden: <br><br>  <b>ConnectionFactory</b> <br><br>  Dies ist die Schnittstelle der obersten Ebene, √ºber die Verbindungen zum Broker hergestellt werden.  In einer typischen Messaging-Anwendung gibt es nur eine Instanz dieser Schnittstelle.  In ActiveMQ ist dies eine ActiveMQConnectionFactory.  Auf der obersten Ebene gibt dieses Design den Standort des Nachrichtenbrokers sowie Details zur Interaktion mit ihm auf niedriger Ebene an.  Wie der Name schon sagt, ist ConnectionFactory der Mechanismus, mit dem Verbindungsobjekte erstellt werden. <br><br>  <b>Verbindung</b> <br><br>  Dies ist ein langlebiges Objekt, das in etwa einer TCP-Verbindung √§hnelt. Nach der Erstellung ist es normalerweise w√§hrend des gesamten Lebenszyklus der Anwendung vorhanden, bis es geschlossen wird.  Die Verbindung ist threadsicher und kann mit mehreren Threads gleichzeitig arbeiten.  Mit Verbindungsobjekten k√∂nnen Sie Sitzungsobjekte erstellen. <br><br>  <b>Sitzung</b> <br><br>  Dies ist ein Stream-Handle bei der Interaktion mit einem Broker.  Sitzungsobjekte sind nicht threadsicher, was bedeutet, dass nicht mehrere Threads gleichzeitig auf sie zugreifen k√∂nnen.  Sitzung ist der Haupttransaktionsdeskriptor, mit dem der Programmierer Rollback-Nachrichten festschreiben und zur√ºcksetzen kann, wenn er sich im Transaktionsmodus befindet.  Mit diesem Objekt erstellen Sie Message-, MessageConsumer- und MessageProducer-Objekte und erhalten Zeiger (Deskriptoren) auf Topic- und Queue-Objekte. <br><br>  <b>MessageProducer</b> <br><br>  √úber diese Schnittstelle k√∂nnen Sie eine Nachricht an den Empf√§nger senden. <br><br>  <b>Nachrichtenkonsument</b> <br><br>  √úber diese Schnittstelle kann der Entwickler Nachrichten empfangen.  Es gibt zwei Mechanismen zum Abrufen von Nachrichten: <br><br><ul><li>  Registrieren Sie MessageListener.  Dies ist die von Ihnen implementierte Nachrichtenhandler-Schnittstelle, die alle vom Broker ausgegebenen Nachrichten nacheinander mit einem Stream verarbeitet. </li><li>  Abfragen von Nachrichten mit der Methode receive (). </li></ul><br>  <b>Nachricht</b> <br><br>  Dies ist wahrscheinlich die wichtigste Struktur, da sie Ihre Daten √ºbertr√§gt.  Nachrichten in JMS bestehen aus zwei Aspekten: <br><br><ul><li>  Nachrichtenmetadaten.  Die Nachricht enth√§lt Header und Eigenschaften.  Sowohl das als auch das k√∂nnen als Elemente einer Karte betrachtet werden.  Header sind bekannte Elemente, die in der JMS-Spezifikation definiert sind und direkt √ºber die API verf√ºgbar sind, z. B. JMSDestination und JMSTimestamp.  Eigenschaften sind beliebige Nachrichteninformationen, die die Verarbeitung oder Weiterleitung von Nachrichten vereinfachen, ohne die Nachrichtennutzdaten selbst lesen zu m√ºssen.  Sie k√∂nnen beispielsweise den Header auf AccountID oder OrderType setzen. </li><li>  Nachrichtentext.  Abh√§ngig von der Art des Inhalts, der im Hauptteil gesendet wird, k√∂nnen aus der Sitzung verschiedene Arten von Nachrichten erstellt werden. Die h√§ufigsten sind TextMessage f√ºr Zeichenfolgen und BytesMessage f√ºr Bin√§rdaten. </li></ul><br><h3>  Wie Warteschlangen funktionieren: Eine Zwei-Hirn-Geschichte </h3><br>  Ein n√ºtzliches, wenn auch ungenaues ActiveMQ-Arbeitsmodell ist ein Modell aus zwei Gehirnh√§lften.  Ein Teil ist f√ºr den Empfang von Nachrichten vom Hersteller verantwortlich, der andere Teil sendet diese Nachrichten an die Verbraucher.  Beziehungen sind f√ºr Zwecke der Leistungsoptimierung tats√§chlich komplexer, aber das Modell reicht f√ºr ein grundlegendes Verst√§ndnis aus. <br><br><h4>  Senden von Nachrichten an die Warteschlange </h4><br>  Schauen wir uns die Interaktion an, die beim Senden einer Nachricht auftritt. <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2-3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zeigt ein vereinfachtes Modell des Prozesses, mit dem Nachrichten vom Broker empfangen werden. Es entspricht nicht vollst√§ndig dem jeweiligen Verhalten, ist aber durchaus geeignet, um ein grundlegendes Verst√§ndnis zu erlangen. </font></font><br><br><img src="https://habrastorage.org/webt/u9/tc/_p/u9tc_p1dznwdwdajfxt19fsoxva.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2-3. Senden von Nachrichten an JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In einer Clientanwendung erh√§lt ein Thread einen Zeiger auf einen MessageProducer. Es erstellt eine Nachricht mit einer gesch√§tzten Nachrichtennutzlast und ruft MessageProducer.send ("Bestellungen", Nachricht) auf, wobei die Warteschlange das endg√ºltige Ziel der Nachricht ist. Da der Programmierer die Nachricht nicht verlieren m√∂chte, wenn der Broker kaputt gegangen ist, wurde der Nachrichtenkopf JMSDeliveryMode auf PERSISTENT gesetzt (Standardverhalten).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu diesem Zeitpunkt (1) ruft der sendende Stream die Clientbibliothek auf und f√ºhrt die Nachricht im OpenWire-Format zusammen. Dann wird die Nachricht an den Broker gesendet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Broker entfernt der empfangende Stream die Nachricht aus der Leitung und stellt die Bereitstellung f√ºr das interne Objekt bereit. Anschlie√üend wird das Nachrichtenobjekt an den Persistenzadapter √ºbertragen, der die Nachricht im Format Google Protocol Buffers zusammenstellt und in den Speicher schreibt (2). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nach dem Aufzeichnen der Nachricht im Speicher sollte der Persistenzadapter eine Best√§tigung erhalten, dass die Nachricht tats√§chlich aufgezeichnet wurde (3). Dies ist normalerweise der langsamste Teil der gesamten Interaktion. dazu sp√§ter mehr.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald der Broker sicherstellt, dass die Nachricht gespeichert wurde, sendet er eine Best√§tigungsantwort (4) an den Kunden. Danach kann der Client-Thread, der urspr√ºnglich die send () -Operation aufgerufen hat, seine Arbeit fortsetzen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese ausstehende Best√§tigung persistenter Nachrichten ist die Grundlage f√ºr die Garantie der JMS-API. Wenn Sie m√∂chten, dass die Nachricht gespeichert wird, ist es wahrscheinlich auch wichtig f√ºr Sie, ob die Nachricht √ºberhaupt vom Broker empfangen wurde. Es gibt eine Reihe von Gr√ºnden, warum dies m√∂glicherweise nicht m√∂glich ist, z. B. wurde ein Speicher- oder Festplattenlimit erreicht. Anstelle eines Fehlers unterbricht der Broker entweder den Sendevorgang und zwingt den Produzenten, zu warten, bis gen√ºgend Systemressourcen zur Verarbeitung der Nachricht verf√ºgbar sind (ein Prozess namens Producer Flow Control), oder er sendet eine negative Best√§tigung an den Produzenten und l√∂st eine Ausnahme aus. Das genaue Verhalten kann f√ºr jeden Broker angepasst werden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei dieser einfachen Operation findet eine erhebliche Anzahl von E / A-Interaktionen statt: zwei Netzwerkoperationen zwischen dem Hersteller und dem Broker, eine Speicheroperation und ein Best√§tigungsschritt. Der Speichervorgang kann ein einfaches Schreiben auf die Festplatte oder ein anderer Netzwerk√ºbergang zum Speicherserver sein. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wirft eine wichtige Frage zu Nachrichtenbrokern auf: Ihre Arbeit ist mit einem √§u√üerst intensiven Strom von E / A-Vorg√§ngen verbunden und sie reagieren sehr empfindlich auf die verwendete Infrastruktur, insbesondere auf Festplatten.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns den Best√§tigungsschritt (3) in der obigen Interaktion genauer an. </font><font style="vertical-align: inherit;">Wenn der Persistenzadapter dateibasiert ist, m√ºssen Sie zum Speichern der Nachricht in das Dateisystem schreiben. </font><font style="vertical-align: inherit;">Wenn ja, warum muss ich dann best√§tigen, dass der Schreibvorgang abgeschlossen wurde? </font><font style="vertical-align: inherit;">Bedeutet das Abschlie√üen einer Aufnahme wirklich, dass eine Aufnahme stattgefunden hat?</font></font><br>  Nicht wirklich.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je tiefer Sie etwas studieren, desto komplexer wird es normalerweise. </font><font style="vertical-align: inherit;">In diesem speziellen Fall ist das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caching</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Schuldige </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caches, Caches √ºberall </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn ein Betriebssystemprozess, z. B. ein Broker, Daten auf die Festplatte schreibt, interagiert er mit dem Dateisystem. Ein Dateisystem ist ein Prozess, der die Details der Interaktion mit dem verwendeten Speichermedium abstrahiert und eine API f√ºr Dateivorg√§nge wie OPEN, CLOSE, READ und WRITE bereitstellt. Eine dieser Funktionen besteht darin </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Anzahl der Schreibvorg√§nge</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font><i><font style="vertical-align: inherit;">minimieren,</font></i><font style="vertical-align: inherit;"> indem die vom Betriebssystem geschriebenen Daten in Bl√∂cke gepuffert werden, die in einem Ansatz auf der Festplatte gespeichert werden k√∂nnen. Schreibvorg√§nge f√ºr Dateisysteme, die so aussehen, als w√ºrden sie mit Festplatten interagieren, werden tats√§chlich in diesen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puffercache geschrieben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbrigens, deshalb beschwert sich Ihr Computer, wenn Sie ein USB-Laufwerk unsicher auswerfen - die von Ihnen kopierten Dateien wurden m√∂glicherweise nicht geschrieben! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald die Daten den Puffercache √ºberschreiten, gelangen sie zur n√§chsten Caching-Ebene, diesmal auf Hardwareebene - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dem Festplattencontroller-Cache</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sie sind besonders wichtig f√ºr RAID-basierte Systeme und erf√ºllen dieselbe Funktion wie das Caching auf Betriebssystemebene: Minimieren Sie die Anzahl der Interaktionen, die f√ºr die Laufwerke selbst erforderlich sind. Diese Caches lassen sich in zwei Kategorien einteilen: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Durchschreiben</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schreibvorg√§nge werden sofort nach Erhalt auf die Festplatte √ºbertragen. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckschreiben</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Aufzeichnung wird nur dann auf Discs durchgef√ºhrt, wenn der Puffer voll ist und einen bestimmten Schwellenwert erreicht. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die in diesen Caches gespeicherten Daten k√∂nnen bei einem Stromausfall leicht verloren gehen, da der von ihnen verwendete Speicher normalerweise </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fl√ºchtig (fl√ºchtig) ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Teurere Karten verf√ºgen √ºber redundante Akkus (BBUs), die die Cache-Stromversorgung unterst√ºtzen, bis das gesamte System die Stromversorgung wiederherstellen kann. Anschlie√üend werden die Daten auf die Festplatte geschrieben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die letzte Cache-Ebene befindet sich auf den Festplatten selbst. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Festplatten-Caches</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich auf Festplatten (sowohl auf Standardfestplatten als auch auf Solid-State-Laufwerken) und kann entweder durchgeschrieben oder zur√ºckgeschrieben werden. Die meisten kommerziellen Laufwerke verwenden Write-Back-Caches und sind fl√ºchtig, was wiederum bedeutet, dass bei einem Stromausfall Daten verloren gehen k√∂nnen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie zum Nachrichtenbroker zur√ºckkehren, m√ºssen Sie den Best√§tigungsschritt ausf√ºhren, um sicherzustellen, dass die Daten tats√§chlich die Festplatte erreicht haben. Leider h√§ngt die Interaktion mit diesen Hardwarepuffern vom Dateisystem ab. Ein Prozess wie ActiveMQ kann also nur ein Signal an das Dateisystem senden, dass alle Systempuffer mit dem verwendeten Ger√§t synchronisiert werden sollen. Zu diesem Zweck ruft der Broker die Methode java.io.FileDescriptor.sync () auf, die wiederum die POSIX-Operation fsync () startet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses Synchronisationsverhalten ist eine Anforderung des JMS, um sicherzustellen, dass alle als persistent gekennzeichneten Nachrichten tats√§chlich auf der Festplatte gespeichert und daher ausgef√ºhrt werden, nachdem jede Nachricht oder jeder Satz verwandter Nachrichten in einer Transaktion empfangen wurde. </font><font style="vertical-align: inherit;">Daher ist die Geschwindigkeit, mit der eine Festplatte sync () ausf√ºhren kann, f√ºr die Leistung des Brokers von entscheidender Bedeutung.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interne Konflikte </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Verwendung eines Protokolls f√ºr alle Warteschlangen erh√∂ht die Komplexit√§t. Zu einem bestimmten Zeitpunkt k√∂nnen mehrere Hersteller gleichzeitig Nachrichten senden. Der Broker verf√ºgt √ºber mehrere Streams, die diese Nachrichten von eingehenden Sockets empfangen. Jeder Thread muss seine Nachricht im Protokoll speichern. Da k√∂nnen nicht mehrere Threads gleichzeitig in dieselbe Datei schreiben, weil Datens√§tze stehen in Konflikt miteinander, dann sollten die Datens√§tze mithilfe des gegenseitigen Ausschlussmechanismus in die Warteschlange gestellt werden. Wir nennen diesen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-Konflikt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Nachricht muss vollst√§ndig aufgezeichnet und synchronisiert werden, bevor die n√§chste Nachricht verarbeitet wird. Diese Einschr√§nkung betrifft alle Warteschlangen im Broker gleichzeitig. Die Geschwindigkeit, mit der eine Nachricht empfangen werden kann, ist somit die Zeit, die zum Schreiben auf die Festplatte ben√∂tigt wird, sowie die Wartezeit, bis andere Streams die Aufzeichnung beendet haben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ActiveMQ enth√§lt einen Schreibpuffer, in den die empfangenden Streams ihre Nachrichten schreiben und auf den Abschluss der vorherigen Aufzeichnung warten. Dann wird der Puffer in einer Aktion geschrieben, wenn die Nachricht verf√ºgbar wird. Nach Abschluss werden die Threads benachrichtigt. Somit maximiert der Broker die Nutzung der Speicherbandbreite.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Auswirkungen von Thread-Konflikten zu minimieren, k√∂nnen Warteschlangens√§tzen mithilfe des mKahaDB-Adapters eigene Protokolle zugewiesen werden. </font><font style="vertical-align: inherit;">Dieser Ansatz reduziert die Schreiblatenz, da Threads zu einem bestimmten Zeitpunkt h√∂chstwahrscheinlich in verschiedene Journale schreiben und nicht miteinander um den exklusiven Zugriff auf eine einzelne Protokolldatei konkurrieren m√ºssen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transaktionen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vorteil der Verwendung eines einzelnen Journals f√ºr alle Warteschlangen besteht darin, dass aus Sicht der Autoren des Brokers die Implementierung von Transaktionen viel einfacher ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schauen wir uns ein Beispiel an, in dem mehrere Nachrichten von einem Produzenten an mehrere Warteschlangen gesendet werden. Die Verwendung einer Transaktion bedeutet, dass der gesamte Satz der zu sendenden Nachrichten als eine atomare Operation betrachtet werden sollte. In dieser Interaktion kann die ActiveMQ-Clientbibliothek einige Optimierungen vornehmen, die die Sendegeschwindigkeit erheblich erh√∂hen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der in </font><a href=""><font style="vertical-align: inherit;">Abbildung 2-4</font></a><font style="vertical-align: inherit;"> gezeigten Operation</font></font><a href=""><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Produzent sendet drei Nachrichten, alle in unterschiedlichen Warteschlangen. </font><font style="vertical-align: inherit;">Anstelle der √ºblichen Interaktion mit dem Broker sendet der Client bei Best√§tigung jeder Nachricht alle drei Nachrichten asynchron, dh ohne auf eine Antwort zu warten. </font><font style="vertical-align: inherit;">Diese Nachrichten werden im Speicher des Brokers gespeichert. </font><font style="vertical-align: inherit;">Sobald der Vorgang abgeschlossen ist, informiert der Produzent seine Sitzungen √ºber die Notwendigkeit eines Commits, was wiederum den Broker zwingt, einen gro√üen Datensatz mit einem Synchronisationsvorgang auszuf√ºhren. </font></font><br><br><img src="https://habrastorage.org/webt/i0/gl/tu/i0gltuz_gqybny3uyjrtpiot5bg.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2-4. </font><font style="vertical-align: inherit;">Senden von Nachrichten in Transaktionen</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bei dieser Art von Operation verwendet ActiveMQ zwei Optimierungen, um die Geschwindigkeit zu erh√∂hen:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Entfernen der Wartezeit vor dem n√§chsten Versand durch den Hersteller wird m√∂glich </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kombinieren Sie viele kleine Festplattenvorg√§nge zu einem gro√üen - so k√∂nnen Sie die gesamte Bandbreite des Festplattenbusses nutzen </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir dies mit der Situation vergleichen, in der jede Warteschlange in einem eigenen Protokoll gespeichert ist, m√ºsste der Broker so etwas wie die Koordination von Transaktionen zwischen allen Datens√§tzen bereitstellen. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subtrahieren von Nachrichten aus der Warteschlange </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Prozess des Lesens von Nachrichten beginnt, wenn der Verbraucher seine Bereitschaft zum Akzeptieren zum Ausdruck bringt, indem er entweder einen MessageListener zum Verarbeiten von Nachrichten beim Eintreffen einrichtet oder die MessageConsumer.receive () -Methode aufruft ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2-5</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/webt/eh/p7/-2/ehp7-2hesg0xjd1h4ynnqr46gqo.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2-5. Lesen von Nachrichten √ºber JMS</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn ActiveMQ einen Verbraucher erkennt, liest es (ActiveMQ) (Seiten) Nachrichten Seite f√ºr Seite vom Speicher zum Verteilungsspeicher (1). Anschlie√üend werden diese Nachrichten an den Buchhalter (2) weitergeleitet (versandt), h√§ufig in mehreren Teilen, um den Umfang der Netzwerkinteraktion zu verringern. Der Broker verfolgt, welche Nachrichten an welchen Verbraucher umgeleitet wurden. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vom Verbraucher empfangene Nachrichten werden von der Anwendung nicht sofort verarbeitet, sondern in einem Speicherbereich abgelegt, der als bekannt ist</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorabrufpuffer (Prefetch - </font><font style="vertical-align: inherit;">Puffer)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Zweck dieses Puffers besteht darin, den Nachrichtenfluss zu optimieren, damit der Broker Nachrichten an den Supervisor senden kann, sobald diese zum Senden verf√ºgbar sind, w√§hrend der Verbraucher sie nacheinander ordnungsgem√§√ü empfangen kann. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Irgendwann nach dem Erreichen des Prefetch-Puffers werden Nachrichten von der Anwendungslogik (X) ausgelesen und eine Best√§tigung des Korrekturlesens an den Broker gesendet (3). Zeitordnung zwischen Nachrichtenverarbeitung und Best√§tigung ist so </font><font style="vertical-align: inherit;">konfiguriert , </font><font style="vertical-align: inherit;">indem JMS - </font><font style="vertical-align: inherit;">Session - </font><font style="vertical-align: inherit;">Parameter aufgerufen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quittierungsmodus</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die wir sp√§ter besprechen werden.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobald der Broker die Best√§tigung der Nachrichten√ºbermittlung akzeptiert, wird sie aus dem Speicher und aus dem Nachrichtenspeicher gel√∂scht (4). Der Begriff ‚ÄûL√∂schen‚Äú ist etwas irref√ºhrend, da in Wirklichkeit ein Best√§tigungsdatensatz in das Protokoll geschrieben wird und der Index im Index zunimmt. Das eigentliche L√∂schen der Protokolldatei mit der Nachricht wird vom Garbage Collector im Hintergrund-Thread basierend auf diesen Informationen durchgef√ºhrt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das oben beschriebene Verhalten ist eine Vereinfachung, um das Verst√§ndnis zu erleichtern. </font><font style="vertical-align: inherit;">Tats√§chlich liest ActiveMQ nicht nur Seite f√ºr Seite Daten von der Festplatte, sondern verwendet stattdessen den Cursormechanismus zwischen den empfangenden und umleitenden Teilen des Brokers, um die Interaktion mit dem Repository des Brokers nach M√∂glichkeit zu minimieren. </font><font style="vertical-align: inherit;">Die Paginierung ist, wie oben beschrieben, einer der in diesem Mechanismus verwendeten Modi. </font><font style="vertical-align: inherit;">Cursor k√∂nnen als Cache auf Anwendungsebene angesehen werden, der mit dem Repository des Brokers synchronisiert werden muss. </font><font style="vertical-align: inherit;">Das verwendete Koh√§renzprotokoll ist ein wesentlicher Bestandteil dessen, was den ActiveMQ-Versandmechanismus wesentlich komplexer macht als den im n√§chsten Kapitel beschriebenen Kafka-Mechanismus.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Best√§tigungs- und Transaktionsmodi </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschiedene Best√§tigungsmodi, die die Reihenfolge zwischen Korrekturlesen und Best√§tigung bestimmen, haben einen erheblichen Einfluss darauf, welche Logik im Client implementiert werden muss. Sie lauten wie folgt: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AUTO_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies ist der am h√§ufigsten verwendete Modus, m√∂glicherweise weil er das Wort AUTO enth√§lt. Dieser Modus zwingt die Clientbibliothek, die Nachricht gleichzeitig mit dem Lesen der Nachricht durch den Aufruf von receive () zu best√§tigen. Dies bedeutet, dass die Nachricht verloren geht, wenn die von der Nachricht initiierte Gesch√§ftslogik eine Ausnahme ausl√∂st, da sie bereits auf dem Broker gel√∂scht wurde. Wenn die Nachricht durch den Listener gelesen wird, wird die Nachricht erst best√§tigt, nachdem der Listener die Arbeit erfolgreich abgeschlossen hat. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLIENT_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Best√§tigung wird nur gesendet, wenn der Consumer-Code die Message.acknowledge () -Methode explizit aufruft. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DUPS_OK_ACKNOWLEDGE</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hier werden Best√§tigungen im Consumer gepuffert, bevor sie gleichzeitig gesendet werden, um den Netzwerkverkehr zu reduzieren. Wenn das Client-System jedoch heruntergefahren wird, gehen Best√§tigungen verloren und Nachrichten werden erneut gesendet und ein zweites Mal verarbeitet. Daher sollte der Code die Wahrscheinlichkeit doppelter Nachrichten ber√ºcksichtigen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Best√§tigungsmodi werden durch Transaktionslesewerkzeuge erg√§nzt. </font><font style="vertical-align: inherit;">Beim Erstellen einer Sitzung kann diese als transaktional markiert werden. </font><font style="vertical-align: inherit;">Dies bedeutet, dass der Programmierer Session.commit () oder Session.rollback () explizit aufrufen muss. </font><font style="vertical-align: inherit;">Auf der Verbraucherseite erweitern Transaktionen den Bereich der Interaktionen, die Code als eine atomare Operation ausf√ºhren kann. </font><font style="vertical-align: inherit;">Sie k√∂nnen beispielsweise mehrere Nachrichten als Ganzes lesen und verarbeiten oder eine Nachricht von einer Warteschlange subtrahieren und dann mit demselben Sitzungsobjekt an eine andere senden.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versand und mehrere Verbraucher </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bisher haben wir das Verhalten beim Lesen von Nachrichten mit einem einzelnen Verbraucher diskutiert. Schauen wir uns nun an, wie dieses Modell auf mehrere Verbraucher anwendbar ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn mehrere Konsumenten die Warteschlange abonnieren, sendet der Broker standardm√§√üig Round-Robin-Nachrichten an diejenigen Konsumenten, die einen Platz in den Prefetch-Puffern haben. Nachrichten werden in der Reihenfolge gesendet, in der sie in der Warteschlange angekommen sind - dies ist die einzige gew√§hrte FIFO-Garantie (first in, first out; first in, first out). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn der Verbraucher pl√∂tzlich herunterf√§hrt, werden alle an ihn gesendeten, aber noch nicht best√§tigten Nachrichten erneut an einen anderen verf√ºgbaren Kunden gesendet.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies wirft eine wichtige Frage auf: Selbst wenn Verbrauchertransaktionen verwendet werden, kann nicht garantiert werden, dass die Nachricht nicht mehrmals verarbeitet wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ber√ºcksichtigen Sie die folgende Verarbeitungslogik im Consumer:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Nachricht wird von der Warteschlange abgezogen. </font><font style="vertical-align: inherit;">Die Transaktion beginnt.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ein Webdienst wird mit dem Inhalt der Nachricht aufgerufen. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Transaktion wird festgeschrieben. </font><font style="vertical-align: inherit;">Eine Best√§tigung wird an den Broker gesendet.</font></font></li></ol><br>  Wenn der Client zwischen den Schritten 2 und 3 abgeschlossen ist, hat das Korrekturlesen der Nachricht bereits ein anderes System durch Aufrufen des Webdienstes beeinflusst.  Webdienstaufrufe sind HTTP-Anforderungen und daher keine Transaktionsanforderungen. <br><br>  Dieses Verhalten gilt f√ºr alle Warteschlangensysteme. Selbst wenn es sich um Transaktionssysteme handelt, k√∂nnen sie nicht garantieren, dass bei der Verarbeitung von Nachrichten in ihnen keine Nebenwirkungen auftreten.  Nachdem wir die Verarbeitung von Nachrichten im Detail untersucht haben, k√∂nnen wir zuversichtlich sagen, dass: <br><br>  <i>Es gibt keine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einmalige Nachrichten√ºbermittlung</a> .</i> <br><br>  Warteschlangen bieten eine Garantie f√ºr die Zustellung <i>mindestens einmal,</i> und vertrauliche Teile des Codes sollten immer die M√∂glichkeit in Betracht ziehen, wiederholte Nachrichten zu empfangen.  Wir werden sp√§ter diskutieren, wie ein Messaging-Client das idempotente Lesen verwenden kann, um bereits angezeigte Nachrichten zu verfolgen und Duplikate zu vermeiden. <br><br><h4>  Nachrichtensortierung </h4><br>  F√ºr eine Reihe von Nachrichten, die in der Reihenfolge [A, B, C, D] ankommen, und f√ºr zwei Verbraucher C1 und C2 ist die normale Verteilung der Nachrichten wie folgt: <br><br> <code>C1: [A, C] <br> C2: [B, D]</code> <br>  Da der Broker den Betrieb von Leseprozessen nicht steuert und die Verarbeitungsreihenfolge parallel ist, ist sie nicht deterministisch.  Wenn C1 langsamer als C2 ist, kann der anf√§ngliche Satz von Nachrichten als [B, D, A, C] verarbeitet werden. <br><br>  Dieses Verhalten kann Anf√§nger √ºberraschen, die erwarten, dass Nachrichten in der richtigen Reihenfolge verarbeitet werden, und auf dieser Grundlage ihre eigene Messaging-Anwendung entwickeln.  Die Anforderung, dass von demselben Absender gesendete Nachrichten in der Reihenfolge zueinander verarbeitet werden m√ºssen, was auch als <i>kausale Reihenfolge bezeichnet wird</i> , ist weit verbreitet. <br><br>  Nehmen Sie als Beispiel den folgenden Anwendungsfall aus Online-Wetten: <br><br><ol><li>  Das Benutzerkonto ist konfiguriert. </li><li>  Geld wird dem Konto gutgeschrieben. </li><li>  Es wird eine Wette abgeschlossen, die Geld vom Konto abhebt. </li></ol><br>  Hier ist es sinnvoll, dass die Nachrichten in der Reihenfolge verarbeitet werden, in der sie gesendet wurden, damit der allgemeine Status des Kontos ber√ºcksichtigt wird.  Seltsame Dinge k√∂nnen passieren, wenn das System versucht, Geld von einem Konto ohne Guthaben zu entfernen.  Es gibt nat√ºrlich M√∂glichkeiten, dies zu umgehen. <br><br>  Das <i>exklusive Kundenmodell</i> umfasst das Senden aller Nachrichten aus der Warteschlange an einen Kunden.  Wenn Sie bei diesem Ansatz mehrere Instanzen von Anwendungen oder Threads mit der Warteschlange verbinden, werden diese mit einem speziellen Empf√§ngerparameter signiert: <code>my.queue?consumer.exclusive=true</code> .  Wenn Sie einen Monopolverbraucher verbinden, erh√§lt er alle Nachrichten.  Wenn der zweite Verbraucher verbunden ist, erh√§lt er keine Nachrichten, bis der erste die Verbindung trennt.  Dieser zweite Verbraucher ist eigentlich eine hei√üe Reserve, w√§hrend der erste Verbraucher Nachrichten genau in der Reihenfolge empf√§ngt, in der sie im Journal aufgezeichnet wurden - in einer kausalen Reihenfolge. <br>  Der Nachteil dieses Ansatzes besteht darin, dass die Nachrichtenverarbeitung zwar konsistent ist, jedoch einen Leistungsengpass darstellt, da alle Nachrichten von einem einzelnen Verbraucher verarbeitet werden m√ºssen. <br><br>  Um diesen Anwendungsfall intelligenter zu verstehen, m√ºssen Sie das Problem √ºberdenken.  M√ºssen alle Nachrichten in der richtigen Reihenfolge verarbeitet werden?  Bei der oben beschriebenen Verarbeitung von Geboten m√ºssen nur Nachrichten, die sich auf ein Konto beziehen, nacheinander verarbeitet werden.  ActiveMQ bietet einen Mechanismus zur Bew√§ltigung dieser Situation, der als <i>JMS-Nachrichtengruppen bezeichnet wird</i> . <br><br>  Nachrichtengruppen sind eine Art Partitionierungsmechanismus, mit dem Produzenten Nachrichten in Gruppen verteilen k√∂nnen, die nacheinander nach einem Gesch√§ftsschl√ºssel verarbeitet werden.  Dieser Gesch√§ftsschl√ºssel wird in einer Nachrichteneigenschaft namens <code>JMSXGroupID</code> . <br><br>  Der nat√ºrliche Schl√ºssel bei der Bearbeitung von Geboten ist die Kontokennung. <br>  Um zu veranschaulichen, wie das Senden funktioniert, betrachten Sie eine Reihe von Nachrichten, die in der folgenden Reihenfolge ankommen: <br><br><pre> <code class="plaintext hljs">[(A, Group1), (B, Group1), (C, Group2), (D, Group3), (E, Group2)]</code> </pre> <br>  Wenn eine Nachricht vom Dispatching-Mechanismus in ActiveMQ verarbeitet wird und eine <code>JMSXGroupID</code> nicht vorhandene <code>JMSXGroupID</code> , wird dieser Schl√ºssel dem Verbraucher zyklisch zugewiesen.  Von nun an werden alle Nachrichten mit diesem Schl√ºssel an diesen Buchhalter gesendet. <br><br>  Hier werden die Gruppen wie folgt zwischen zwei Verbrauchern aufgeteilt: C1 und C2: <br><br><pre> <code class="plaintext hljs">C1: [Group1, Group3] C2: [Group2]</code> </pre> <br>  Nachrichten werden wie folgt umgeleitet und verarbeitet: <br><br><pre> <code class="plaintext hljs">C2: [B, D] C2: [(C, Group2), (E, Group2)]</code> </pre> <br>  Wenn der Verbraucher ausf√§llt, werden alle ihm zugewiesenen Gruppen auf den Rest der Verbraucher verteilt und alle nicht best√§tigten Nachrichten werden erneut umgeleitet.  Obwohl wir garantieren k√∂nnen, dass alle zugeh√∂rigen Nachrichten in der richtigen Reihenfolge verarbeitet werden, k√∂nnen wir daher nicht behaupten, dass sie von demselben Verbraucher verarbeitet werden. <br><br><h3>  Hochverf√ºgbarkeit </h3><br>  ActiveMQ bietet Hochverf√ºgbarkeit mit einem Master-Slave, der auf gemeinsam genutztem Speicher basiert.  In diesem Schema werden zwei oder mehr Broker (obwohl normalerweise zwei) auf separaten Servern konfiguriert und ihre Nachrichten werden in einem Nachrichtenspeicher an einem externen Speicherort gespeichert.  Ein Nachrichtenspeicher kann nicht von mehreren Instanzen eines Brokers gleichzeitig verwendet werden. Daher besteht seine (Speicher-) Sekund√§rfunktion darin, als Blockierungsmechanismus zu fungieren, um zu bestimmen, welcher Broker exklusiven Zugriff erh√§lt ( <a href="">Abbildung 2-6</a> ). <br><br><img src="https://habrastorage.org/webt/bn/yn/d5/bnynd5kctkhlomy5nb7-gmckrws.png"><br>  <i>Abbildung 2-6.</i>  <i>Broker A ist der Lead, Broker B ist als Slave in Bereitschaft</i> <br><br>  Um eine Verbindung zum Repository herzustellen, √ºbernimmt der erste Broker (Broker A) die Rolle des Leiters und √∂ffnet seine Ports f√ºr den Nachrichtenverkehr.  Wenn der zweite Broker (Broker B) eine Verbindung zum Repository herstellt, versucht er, eine Sperre zu erhalten, und stoppt kurz, da er keinen Erfolg hat, bevor er erneut versucht, eine Sperre zu erhalten.  Dies wird als getriebene Eind√§mmung bezeichnet. <br><br>  Gleichzeitig wechselt der Client die Adressen der beiden Broker, um eine Verbindung zum eingehenden Port herzustellen, der als Transportconnector bezeichnet wird.  Sobald der Hauptbroker verf√ºgbar ist, stellt der Client eine Verbindung zu seinem Port her und kann Nachrichten senden und lesen. <br>  Wenn Broker A als Leader aufgrund eines Prozessfehlers ausf√§llt ( <a href="">Abbildung 2-7</a> ), treten die folgenden Ereignisse auf: <br><br><ol><li>  Der Client trennt die Verbindung und versucht sofort, die Verbindung wiederherzustellen, wobei die Adressen zweier Broker abgewechselt werden. </li><li>  Die Sperre in der Nachricht wird aufgehoben.  Der Zeitpunkt hierf√ºr h√§ngt von der Speicherimplementierung ab. </li><li>  Broker B, der sich im Slave-Modus befand und regelm√§√üig versuchte, eine Sperre zu erhalten, ist schlie√ülich erfolgreich und √ºbernimmt die Rolle des Masters, indem er seine Ports √∂ffnet. </li><li>  Der Kunde stellt eine Verbindung zu Broker B her und setzt seine Arbeit fort. </li></ol><br><img src="https://habrastorage.org/webt/ks/wi/yd/kswiydyc5bffutft06ck-1sm4zq.png"><br>  <i>Abbildung 2-7.</i>  <i>Broker A wird beendet, indem die Verbindung zum Repository unterbrochen wird.</i>  <i>Broker B √ºbernimmt die F√ºhrung</i> <br><blockquote>  Es ist nicht garantiert, dass die Wechsellogik zwischen mehreren Brokeradressen in die Clientbibliothek integriert ist, wie dies bei JMS / NMS / CMS-Implementierungen der Fall ist.  Wenn die Bibliothek nur die Wiederverbindung mit einer einzelnen Adresse erm√∂glicht, m√ºssen Sie m√∂glicherweise einige Broker hinter einem Load Balancer platzieren, der ebenfalls hoch verf√ºgbar sein sollte. </blockquote>  Der Hauptnachteil dieses Ansatzes besteht darin, dass zur Vereinfachung der Arbeit eines logischen Brokers mehrere physische Server erforderlich sind.  In diesem Fall ist einer der beiden Server des Brokers inaktiv und wartet auf die Trennung seines Partners, bevor er seine Arbeit aufnehmen kann. <br><br>  Dieser Ansatz hat auch die zus√§tzliche Komplexit√§t, dass der verwendete Broker-Speicher, ob es sich um ein gemeinsam genutztes Netzwerkdateisystem oder eine Datenbank handelt, auch in hohem Ma√üe zug√§nglich sein muss.  Dies f√ºhrt zu zus√§tzlichen Kosten f√ºr die Ausr√ºstung und Verwaltung der Brokereinstellungen.  In diesem Szenario ist es verlockend, vorhandene Hochverf√ºgbarkeits-Repositorys, die von anderen Teilen der Infrastruktur verwendet werden, z. B. einer Datenbank, wiederzuverwenden. Dies ist jedoch ein Fehler. <br><br>  Es ist wichtig zu bedenken, dass die Festplatte der Hauptbegrenzer f√ºr die Gesamtleistung des Brokers ist.  Wenn die Festplatte selbst gleichzeitig von einem anderen Prozess als dem Nachrichtenbroker verwendet wird, verlangsamt die Interaktion dieses Prozesses mit der Festplatte wahrscheinlich die Aufzeichnung vom Broker und damit die Geschwindigkeit, mit der Nachrichten das System durchlaufen k√∂nnen.  Solche Verlangsamungen sind schwer zu diagnostizieren und k√∂nnen nur umgangen werden, indem die beiden Prozesse in unterschiedliche Speichervolumes aufgeteilt werden. <br><br>  Um den stabilen Betrieb des Brokers sicherzustellen, ist ein dedizierter und exklusiver Speicher erforderlich. <br><br><h3>  Vertikale und horizontale Skalierung </h3><br>  Zu einem bestimmten Zeitpunkt im Projektverlauf kann es zu einer Leistungsbeschr√§nkung des Nachrichtenbrokers kommen.  Diese Einschr√§nkungen beziehen sich normalerweise auf Ressourcen, insbesondere ActiveMQ-Interaktionen mit dem verwendeten Speicher.  Diese Probleme treten normalerweise aufgrund von Nachrichtenvolumen- oder Bandbreitenkonflikten zwischen Empf√§ngern auf, beispielsweise wenn in Spitzenzeiten eine Warteschlange den Broker √ºberl√§uft. <br><br>  Es gibt verschiedene M√∂glichkeiten, um mehr Leistung aus der Infrastruktur des Brokers zu ziehen: <br><br><ul><li>  Verwenden Sie keine Persistenz, wenn dies nicht erforderlich ist.  Einige Verwendungsszenarien erm√∂glichen den Verlust von Nachrichten w√§hrend eines Absturzes, insbesondere wenn ein System regelm√§√üig oder bei Bedarf einen anderen vollst√§ndigen Snapshot-Status √ºber die Warteschlange an das andere System sendet. </li><li>  F√ºhren Sie den Broker auf schnelleren Laufwerken aus.  Unter realen Bedingungen wurden signifikante Unterschiede in der Aufzeichnungsbandbreite zwischen Standard-Festplatte und speicherbasierten Alternativen festgestellt. </li><li>  Nutzen Sie die Festplattengr√∂√üen optimal.  Wie in dem oben beschriebenen Interaktionsmodell f√ºr die Plattenpipeline gezeigt, kann ein h√∂herer Durchsatz erzielt werden, indem Transaktionen zum Senden von Gruppen von Nachrichten verwendet werden, wodurch mehrere Schreibvorg√§nge zu einem gr√∂√üeren kombiniert werden. </li><li>  Verwenden Sie die Verkehrspartitionierung.  Sie k√∂nnen einen h√∂heren Durchsatz erzielen, indem Sie Ziele auf eine der folgenden Arten aufteilen: </li></ul><br><ol><li>  Mehrere Datentr√§ger innerhalb eines Brokers, z. B. mithilfe des mKahaDB-Persistenzadapters f√ºr mehrere Verzeichnisse, von denen jedes auf einem separaten Datentr√§ger bereitgestellt ist. </li><li>  Mehrere Broker, und die Partitionierung des Datenverkehrs wird manuell von der Client-Anwendung durchgef√ºhrt.  ActiveMQ bietet zu diesem Zweck keine nativen Funktionen. </li></ol><br>  Eine der h√§ufigsten Ursachen f√ºr Broker-Leistungsprobleme ist einfach der Versuch, mit einer Instanz zu viel zu tun.  Dies tritt in der Regel in Situationen auf, in denen der Broker naiv auf mehrere Anwendungen aufgeteilt ist, ohne die vorhandene Belastung des Brokers zu ber√ºcksichtigen oder die Volumes zu verstehen.  Im Laufe der Zeit wird ein Broker immer mehr geladen, bis er sich nicht mehr angemessen verh√§lt. <br><br>  Das Problem tritt h√§ufig w√§hrend der Systementwurfsphase auf, wenn der Systemarchitekt ein solches Schema wie in <a href="">Abbildung 2-8</a> vorschlagen kann. <br><br><img src="https://habrastorage.org/webt/86/2g/9m/862g9malnlxd6k8ryettpya_dwu.png"><br>  <i>Abbildung 2-8.</i>  <i>Konzeptionelle Ansicht der Messaging-Infrastruktur</i> <br><br>  Ziel ist es, dass mehrere Anwendungen √ºber ActiveMQ asynchron miteinander kommunizieren.  Das Ziel wird nicht mehr angegeben und dann bestimmt das Schema die Basis der realen Brokerkonfiguration.  Dieser Ansatz wird als Universal Data Pipeline bezeichnet. <br><br>  Der grundlegende Schritt der Analyse zwischen dem oben genannten Konzeptentwurf und der physischen Umsetzung wird nicht ber√ºcksichtigt.  Bevor Sie mit der Erstellung einer bestimmten Konfiguration fortfahren, m√ºssen Sie eine Analyse durchf√ºhren, die dann zur Begr√ºndung des physischen Projekts verwendet wird.  Der erste Schritt in diesem Prozess besteht darin, zu bestimmen, welche Systeme miteinander interagieren - ein ziemlich einfaches Diagramm mit Rechtecken und Pfeilen ( <a href="">Abbildung 2-9</a> ). <br><br><img src="https://habrastorage.org/webt/v_/wz/cz/v_wzczik2oi-menqrxjenakhs1e.png"><br>  <i>Abbildung 2-9.</i>  <i>Skizzieren Sie Nachrichtenfl√ºsse zwischen Systemen</i> <br><br>  Nach der Genehmigung k√∂nnen Sie die Details aufrufen, um die folgenden Fragen zu beantworten: <br><br><ul><li>  Wie viele Warteschlangen und Themen werden verwendet? </li><li>  Welche Nachrichtenmengen werden f√ºr jede von ihnen erwartet? </li><li>  Wie gro√ü sind die Nachrichten in jedem Empf√§nger?  Gro√üe Nachrichten k√∂nnen Probleme im Paging-Prozess verursachen, die dazu f√ºhren, dass Speichergrenzen √ºberschritten werden und der Broker blockiert wird. </li><li>  Werden die Nachrichtenfl√ºsse den ganzen Tag √ºber gleichm√§√üig sein oder wird es aufgrund von Stapeljobs Spitzen geben?  Gro√üe Stapel in einer weniger genutzten Warteschlange k√∂nnen zeitnahe Schreibvorg√§nge f√ºr Hochleistungsziele beeintr√§chtigen. </li><li>  Befinden sich die Systeme im selben Rechenzentrum oder in unterschiedlichen?  An der Fernkommunikation sind Netzwerkbroker beteiligt. </li></ul><br>  Die Idee ist, separate Messaging-Szenarien zu definieren, die von einzelnen Brokern kombiniert oder aufgeteilt werden k√∂nnen ( <a href="">Abbildung 2-10</a> ). <br>  Nach einer solchen Aufschl√ºsselung k√∂nnen Nutzungsszenarien simuliert werden, indem sie mithilfe des ActiveMQ-Leistungsmoduls miteinander kombiniert werden, um Probleme zu identifizieren. <br><br><img src="https://habrastorage.org/webt/nj/im/ry/njimryyhatcjfwhprygsdrrzqwc.png"><br>  <i>Abbildung 2-10.</i>  <i>Identifizierung einzelner Makler</i> <br><br>  Nachdem Sie die entsprechende Anzahl logischer Broker ermittelt haben, k√∂nnen Sie mithilfe hochzug√§nglicher Konfigurationen und Brokernetzwerke festlegen, wie diese auf physischer Ebene implementiert werden sollen. <br><br><h3>  Zusammenfassung </h3><br>  In diesem Kapitel haben wir den Mechanismus untersucht, mit dem ActiveMQ Nachrichten empf√§ngt und verteilt.  Wir haben Funktionen besprochen, die von dieser Architektur unterst√ºtzt werden, einschlie√ülich des Sticky-Load-Balancing verwandter Nachrichten und Transaktionen.  Gleichzeitig haben wir eine Reihe von Konzepten eingef√ºhrt, die allen Nachrichtensystemen gemeinsam sind, einschlie√ülich Kommunikationsprotokollen und Magazinen.  Wir haben auch detailliert untersucht, welche Schwierigkeiten beim Schreiben auf die Festplatte auftreten und wie Broker Techniken wie das Schreiben von Paketen verwenden k√∂nnen, um die Leistung zu verbessern.  Schlie√ülich haben wir untersucht, wie ActiveMQ hoch verf√ºgbar gemacht werden kann und wie es √ºber die F√§higkeiten eines einzelnen Brokers hinaus skaliert werden kann. <br><br>  Im n√§chsten Kapitel werden wir uns mit Apache Kafka befassen und wie seine Architektur die Beziehung zwischen Clients und Brokern neu definiert, um eine unglaublich robuste Nachrichtenpipeline mit einer Bandbreite bereitzustellen, die um ein Vielfaches gr√∂√üer ist als die eines normalen Nachrichtenbrokers.  Wir werden die Funktionalit√§t diskutieren, die zur Erreichung dieses Ziels verwendet wird, und kurz die Architektur von Anwendungen betrachten, die diese Funktionalit√§t bereitstellen. <br><br>  N√§chster Teil: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Grundlegendes zu Message Brokers.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erlernen der Mechanismen des Messaging √ºber ActiveMQ und Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kapitel 3. Kafka</a> <br><br>  <b>√úbersetzung abgeschlossen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tele.gg/middle_java</a></b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471268/">https://habr.com/ru/post/de471268/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471258/index.html">Datenspeicher- / Ladesystem</a></li>
<li><a href="../de471260/index.html">Kali Linux NetHunter unter Android Teil 2: Angriffe auf drahtlose Netzwerke</a></li>
<li><a href="../de471262/index.html">Holivar. Geschichte von Runet. Teil 5. Trolle: Lernen, hektischer Drucker, Kupfer</a></li>
<li><a href="../de471264/index.html">Eine Alternative zu Mailchimp w√§hlen: Warum wechseln und welches Produkt w√§hlen?</a></li>
<li><a href="../de471266/index.html">Die Zukunft ist hier oder direkt im Browser verschl√ºsselt</a></li>
<li><a href="../de471270/index.html">Automatisieren Sie den Empfang von Daten √ºber die Geschwindigkeit des Ladens einer Website aus Google PageSpeed ‚Äã‚ÄãInsights [Vorlage]</a></li>
<li><a href="../de471272/index.html">Die Vorteile einer starken Eingabe in C ++: praktische Erfahrung</a></li>
<li><a href="../de471278/index.html">Texterzeugung in russischer Sprache durch Vorlagen</a></li>
<li><a href="../de471282/index.html">Auf der Suche nach Lungenentz√ºndung bei R√∂ntgenaufnahmen mit Fast.ai</a></li>
<li><a href="../de471288/index.html">Das Gesicht eines Charakters f√ºr das Spiel "OnAir" erstellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>