<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌆 😻 👩🏽‍⚕️ Comment rendre SFINAE élégant et fiable 🆚 👼🏾 🛷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour encore. Nous partageons avec vous un article intéressant, dont la traduction a été préparée spécialement pour les étudiants du cours "Développ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rendre SFINAE élégant et fiable</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/466915/">  <i>Bonjour encore.</i>  <i>Nous partageons avec vous un article intéressant, dont la traduction a été préparée spécialement pour les étudiants du cours <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Développeur C ++"</a> .</i> <br><br><img src="https://habrastorage.org/webt/i1/cn/mm/i1cnmmt1eyhcbyi9exnawbo2vgq.png"><br><br><hr><br>  Aujourd'hui, nous avons un message d'invité de dám Balázs.  Adam est ingénieur logiciel chez Verizon Smart Communities Hungary et développe des analyses vidéo pour les systèmes embarqués.  L'une de ses passions est l'optimisation du temps de compilation, il a donc immédiatement accepté d'écrire un article invité sur ce sujet.  Vous pouvez trouver Adam en ligne sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">LinkedIn</a> . <a name="habracut"></a><br><br>  Dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">série d'articles sur la façon de rendre SFINAE élégant</a> , nous avons vu comment rendre notre modèle SFINAE assez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">concis et expressif</a> . <br><br>  Jetez un œil à sa forme originale: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; x)</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_ = T&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f(T&amp;&amp; x, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_reference&lt;T_&gt;::value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>&gt;::type = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){} };</code> </pre> <br><br>  Et comparez-le avec cette forme plus expressive: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsNotReference = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_reference_v&lt;T&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; x)</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_ = T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsNotReference &lt;T_&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f(T&amp;&amp; x){} };</code> </pre> <br>  Nous pouvons raisonnablement croire qu'il est déjà possible de se détendre et de commencer à l'utiliser en production.  Nous pourrions, cela fonctionne dans la plupart des cas, mais - comme nous parlons d'interfaces - notre code devrait être sûr et fiable.  En est-il ainsi?  Essayons de le pirater! <br><br><h2>  Défaut n ° 1: SFINAE peut être contourné </h2><br>  En règle générale, SFINAE est utilisé pour désactiver une partie du code en fonction de la condition.  Cela peut être très utile si nous devons implémenter, par exemple, la fonction définie par l'utilisateur abs pour une raison quelconque (classe arithmétique définie par l'utilisateur, optimisation pour un équipement spécifique, à des fins de formation, etc.): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"a: "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">" myAbs( a ): "</span></span> &lt;&lt; myAbs( a ) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Ce programme affiche les éléments suivants, ce qui semble tout à fait normal: <br><br><pre> <code class="cpp hljs">a: <span class="hljs-number"><span class="hljs-number">2147483647</span></span> myAbs( a ): <span class="hljs-number"><span class="hljs-number">2147483647</span></span></code> </pre> <br>  Mais nous pouvons appeler notre fonction <code>abs</code> avec des arguments non signés <code>T</code> , et l'effet sera catastrophique: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"a: "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">" myAbs( a ): "</span></span> &lt;&lt; myAbs( a ) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  En effet, maintenant le programme affiche: <br><br> <code>a: 4294967295 myAbs( a ): 1</code> <br> <br>  Notre fonction n'a pas été conçue pour fonctionner avec des arguments non signés, nous devons donc limiter l'ensemble possible de <code>T</code> avec SFINAE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  Le code fonctionne comme prévu: un appel à myAbs avec un type non signé provoque une erreur de compilation: <br><br> <code><code>candidate template ignored: requirement 'std::is_signed_v&lt;</code> unsigned int&gt;' was not satisfied [with T = unsigned int]</code> <br> <br><h3>  Hacking SFINAE State </h3><br>  Alors qu'est-ce qui ne va pas avec cette fonction?  Pour répondre à cette question, nous devons vérifier comment myAbs implémente SFINAE. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt;T&gt; &gt; T myAbs( T val );</code> </pre> <br>  <code>myAbs</code> est un modèle de fonction avec deux types de paramètres de modèle d'entrée.  Le premier est le type réel de l'argument de la fonction, le second est le type anonyme par défaut <code><code>IsSigned &lt;</code> T <code>&gt;</code></code> (sinon <code><code>std::enable_if_t &lt;</code> std::is_signed_v <code>&lt;</code> T <code>&gt;</code> &gt;</code> ou bien <code><code>std::enable_if &lt;</code> std::is_signed_v <code>&lt;</code> T&gt;, void&gt;::type</code> , qui est une substitution <code>void</code> ou ayant échoué). <br><br>  Comment pouvons-nous appeler <code>myAbs</code> ?  Il y a 3 façons: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) };</code> </pre> <br>  Les premier et deuxième appels sont simples, mais le troisième est intéressant: quel est l'argument du modèle <code>void</code> ? <br><br>  Le deuxième paramètre de modèle est anonyme, a un type par défaut, mais il s'agit toujours d'un paramètre de modèle, vous pouvez donc le spécifier explicitement.  Est-ce un problème?  Dans ce cas, c'est vraiment un énorme problème.  Nous pouvons utiliser le troisième formulaire pour contourner notre chèque SFINAE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() ) };</code> </pre> <br>  Ce code compile bien, mais conduit à des résultats désastreux, pour éviter que nous ayons utilisé SFINAE: <br><br><pre> <code class="cpp hljs">a: <span class="hljs-number"><span class="hljs-number">4294967295</span></span> myAbs( a ): <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Nous allons résoudre ce problème - mais d'abord: y a-t-il d'autres inconvénients?  Et bien ... <br><br><h2>  Défaut n ° 2: nous ne pouvons pas avoir d'implémentations spécifiques </h2><br>  Une autre utilisation courante de SFINAE est de fournir des implémentations spécifiques pour des conditions de compilation spécifiques.  Et si nous ne voulons pas interdire complètement l'appel de <code>myAbs</code> avec <code>myAbs</code> valeurs <code>myAbs</code> et fournir une implémentation triviale pour ces cas?  Nous pouvons utiliser if constexpr en C ++ 17 (nous en discuterons plus tard), ou nous pouvons: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsUnsigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }</code> </pre> <br>  Mais c'est quoi? <br><br><pre> <code class="cpp hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> parameter redefines <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; note: previous <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> argument defined here <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt;</code> </pre> <br>  <i><b>Oh, la norme C ++ (C ++ 17; §17.1.16) stipule ce qui suit</b> :</i> <br><br><blockquote>  "Les arguments par défaut ne doivent pas être fournis au paramètre de modèle par deux déclarations différentes dans la même portée." </blockquote><br>  Oups, c'est exactement ce que nous avons fait ... <br><br><h3>  Pourquoi ne pas utiliser régulièrement si? </h3><br>  Nous pourrions simplement utiliser if lors de l'exécution à la place: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } }</code> </pre> <br>  Le compilateur optimiserait la condition car <code><code>if (std::is_signed_v &lt;</code> T&gt;)</code> devient <code>if (true)</code> ou <code>if (false)</code> après avoir créé le modèle.  Oui, avec notre implémentation actuelle de <code>myAbs</code> cela fonctionnera.  Mais dans l'ensemble, cela impose une énorme limitation: les <code>else</code> <code>if</code> et <code>else</code> doivent être valides pour chaque <code>T</code>  Et si nous modifions un peu notre implémentation: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; }</code> </pre> <br>  Notre code plantera immédiatement: <br><br><pre> <code class="cpp hljs">error: call of overloaded <span class="hljs-string"><span class="hljs-string">'abs(unsigned int&amp;)'</span></span> is ambiguous</code> </pre> <br>  Cette restriction est ce que SFINAE élimine: nous pouvons écrire du code qui n'est valide que pour un sous-ensemble de T (dans myAbs, il n'est valide que pour les types non signés ou valide uniquement pour les types signés). <br><br><h3>  Solution: un autre formulaire pour SFINAE </h3><br>  Que pouvons-nous faire pour surmonter ces lacunes?  Pour le premier problème, nous devons forcer notre vérification SFINAE quelle que soit la façon dont les utilisateurs invoquent notre fonction.  Actuellement, notre test peut être contourné lorsque le compilateur n'a pas besoin du type par défaut pour le deuxième paramètre de modèle. <br><br>  Que faire si nous utilisons notre code SFINAE pour déclarer un type de paramètre de modèle au lieu de fournir un type par défaut?  Essayons: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//int a{ myAbs( 5u ) }; int b{ myAbs&lt; int &gt;( 5u ) }; //int c{ myAbs&lt; unsigned int, true &gt;( 5u ) }; }</span></span></code> </pre> <br>  Nous avons besoin que IsSigned soit un type autre que void dans les cas valides, car nous voulons fournir une valeur par défaut pour ce type.  Il n'y a pas de valeur pour le type void, nous devons donc utiliser autre chose: bool, int, enum, nullptr_t, etc. Habituellement, j'utilise bool - dans ce cas, les expressions ont un sens: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt;</code> </pre> <br>  Ça marche!  Pour <code>myAbs (5u)</code> compilateur renvoie une erreur, comme précédemment: <br><br><pre> <code class="cpp hljs">candidate <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> ignored: requirement <span class="hljs-string"><span class="hljs-string">'std::is_signed_v&lt;unsigned int&gt;'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied [with T = <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  Le deuxième appel, <code><code>myAbs &lt;</code> int&gt; (5u)</code> est toujours valide, nous indiquons explicitement le type de compilateur <code>T</code> , donc il convertit <code>5u</code> en <code>int</code> . <br><br>  Enfin, nous ne pouvons plus tracer <code>myAbs</code> autour du doigt: <code><code>myAbs &lt;</code> unsigned int, true&gt; (5u)</code> renvoie une erreur.  Peu importe que nous fournissions une valeur par défaut dans l'appel ou non, une partie de l'expression SFINAE est quand même évaluée, car le compilateur a besoin d'un type d'argument d'une valeur de modèle anonyme. <br><br>  Nous pouvons passer au problème suivant - mais attendez une minute!  Je pense que nous ne remplaçons plus l'argument par défaut pour le même paramètre de modèle. Quelle était la situation d'origine? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; T myAbs( T val ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val );</code> </pre> <br>  Mais maintenant avec le code actuel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsUnsigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val );</code> </pre> <br>  Il ressemble beaucoup au code précédent, nous pouvons donc penser que cela ne fonctionnera pas non plus, mais en fait ce code n'a pas le même problème.  Qu'est-ce que <code><code>IsUnsigned &lt;</code> T&gt;</code> ?  Recherche booléenne ou échouée.  Et qu'est-ce que <code><code>IsSigned &lt;</code> T&gt;</code> ?  Même chose, mais si l'un d'eux est Bool, l'autre est une recherche échouée. <br><br>  Cela signifie que nous ne remplaçons pas les arguments par défaut, car il n'y a qu'une fonction avec l'argument de modèle bool, l'autre est une substitution ayant échoué, elle n'existe donc pas. <br><br><h3>  Sucre syntaxique </h3><br>  <i><b>UPD</b></i>  <i>Ce paragraphe a été supprimé par l'auteur en raison d'erreurs qui s'y trouvaient.</i> <br><br><h3>  Anciennes versions de C ++ </h3><br>  Tout ce qui précède fonctionne avec C ++ 11, la seule différence est la verbosité des définitions des restrictions entre les versions standard: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//C++11 template&lt; typename T &gt; using IsSigned = typename std::enable_if&lt; std::is_signed&lt; T &gt;::value, bool &gt;::type; //C++14 - std::enable_if_t template&lt; typename T &gt; using IsSigned = std::enable_if_t&lt; std::is_signed&lt; T &gt;::value, bool &gt;; //C++17 - std::is_signed_v template&lt; typename T &gt; using IsSigned = std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, bool &gt;;</span></span></code> </pre> <br>  Mais le modèle reste le même: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt;</code> </pre> <br>  Dans le bon vieux C ++ 98, il n'y a pas d'alias de modèle, en outre, les modèles de fonction ne peuvent pas avoir de types ou de valeurs par défaut.  Nous pouvons insérer notre code SFINAE dans le type de résultat ou uniquement dans la liste des paramètres de fonction.  La deuxième option est recommandée car les constructeurs n'ont pas de type de résultat.  Le mieux que nous puissions faire est quelque chose comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> my_enable_if&lt; my_is_signed&lt; T &gt;::value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt;::type = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  Juste pour comparaison - la version moderne de C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  La version C ++ 98 est laide, introduit un paramètre vide de sens, mais cela fonctionne - vous pouvez l'utiliser si c'est absolument nécessaire.  Et oui: <code>my_enable_if</code> et <code>my_is_signed</code> doivent être implémentés ( <code>std :: enable_if  std :: is_signed</code> étaient nouveaux en C ++ 11). <br><br><h3>  État actuel </h3><br>  C ++ 17 a introduit <code>if constexpr</code> , une méthode pour éliminer le code basé sur les conditions au moment de la compilation.  Les instructions if et else doivent être syntaxiquement correctes, mais la condition sera évaluée au moment de la compilation. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; T &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-comment"><span class="hljs-comment">/*else { static_assert( false, "T must be signed or unsigned arithmetic type." ); }*/</span></span> } }</code> </pre> <br>  Comme nous pouvons le voir, notre fonction abs est devenue plus compacte et plus facile à lire.  Cependant, la gestion des types non conformes n'est pas simple.  L' <code>static_assert</code> inconditionnelle <code>static_assert</code> rend cette instruction peu cohérente, ce qui est interdit par la norme, qu'elle soit ignorée ou non. <br><br>  Heureusement, il existe une faille: dans les objets de modèle, les opérateurs supprimés ne sont pas créés si la condition est indépendante de la valeur.  Super! <br><br>  Donc, le seul problème avec notre code est qu'il se bloque lors de la définition du modèle.  Si nous pouvions différer l'évaluation de <code>static_assert</code> jusqu'à la création du modèle, le problème serait résolu: il serait créé si et seulement si toutes nos conditions étaient fausses.  Mais comment pouvons-nous différer <code>static_assert</code> jusqu'à ce que le modèle soit créé?  Faites dépendre son état du type! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dependent_false_v{ <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; T &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( dependent_false_v&lt; T &gt;, <span class="hljs-string"><span class="hljs-string">"Unsupported type"</span></span> ); } } }</code> </pre> <br><h3>  À propos de l'avenir </h3><br>  Nous sommes déjà très proches, mais nous devons attendre un peu jusqu'à ce que C ++ 20 apporte la solution finale: les concepts!  Cela changera complètement la façon dont les modèles (et SFINAE) sont utilisés. <br><br>  En résumé: les concepts peuvent être utilisés pour limiter l'ensemble d'arguments acceptés pour les paramètres de modèle.  Pour notre fonction abs, nous pourrions utiliser le concept suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt; T &gt;; }</code> </pre> <br>  Et comment utiliser les concepts?  Il existe trois façons: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   template&lt; typename T &gt; requires Arithmetic&lt; T &gt;() T myAbs( T val ); //   template&lt; Arithmetic T &gt; T myAbs( T val ); //  Arithmetic myAbs( Arithmetic val );</span></span></code> </pre> <br>  Notez que le troisième formulaire déclare toujours une fonction de modèle!  Voici l'implémentation complète de myAbs en C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt; T &gt;; } <span class="hljs-function"><span class="hljs-function">Arithmetic </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Arithmetic val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( val ) &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-comment"><span class="hljs-comment">//std::string c{ myAbs( "d" ) }; }</span></span></code> </pre> <br>  Un appel commenté donne l'erreur suivante: <br><br><pre> <code class="cpp hljs">error: cannot call function <span class="hljs-string"><span class="hljs-string">'auto myAbs(auto:1) [with auto:1 = const char*]'</span></span> constraints <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied within <span class="hljs-string"><span class="hljs-string">'template&lt;class T&gt; concept bool Arithmetic() [with T = const char*]'</span></span> <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ ^~~~~~~~~~ <span class="hljs-string"><span class="hljs-string">'std::is_arithmetic_v'</span></span> evaluated to <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  J'exhorte tout le monde à utiliser hardiment ces méthodes dans le code de production; le temps de compilation est moins cher que le runtime.  Bonne SFINAEing! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466915/">https://habr.com/ru/post/fr466915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466899/index.html">Pourquoi tout abandonner et apprendre Swift et Kotlin dès maintenant</a></li>
<li><a href="../fr466903/index.html">Présentez toujours votre travail</a></li>
<li><a href="../fr466905/index.html">À la question de U-Boot</a></li>
<li><a href="../fr466907/index.html">5G et WiFi 6: quand deux technologies réseau valent mieux qu'une</a></li>
<li><a href="../fr466911/index.html">Un tribunal américain a légalisé le grattage d'un site Web et lui a interdit de faire obstacle techniquement</a></li>
<li><a href="../fr466917/index.html">Lorsque la norme HTTP ne suffit pas. Micronaut s'engage</a></li>
<li><a href="../fr466921/index.html">5 problèmes de toute entreprise de services et leur solution en utilisant la plate-forme d'automatisation</a></li>
<li><a href="../fr466923/index.html">Comment les professionnels de l'informatique dans une banque étrangère pour prouver l'origine des fonds</a></li>
<li><a href="../fr466925/index.html">Comment exécuter Hi-CPU VDS pour Bitrix, disperser les perroquets et ne pas faire faillite</a></li>
<li><a href="../fr466929/index.html">Ajouter un jeton d'actualisation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>