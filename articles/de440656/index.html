<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÖ ‚òïÔ∏è ü¶É Professionelle Containerisierung von Node.js-Anwendungen mit Docker ü•Ä üïö üë≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, ist ein DevOps-Ingenieur. Er sagt, er muss Docker benutzen. Insbesondere wird d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Professionelle Containerisierung von Node.js-Anwendungen mit Docker</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/440656/">  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, ist ein DevOps-Ingenieur.  Er sagt, er muss <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker</a> benutzen.  Insbesondere wird diese Containerverwaltungsplattform in verschiedenen Phasen des Lebenszyklus von Node.js-Anwendungen verwendet.  Mit Docker, einer Technologie, die in letzter Zeit sehr beliebt war, k√∂nnen Sie den Entwicklungs- und Ausgabeprozess von Node.js Projekten in der Produktion optimieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/0c1/c88/f14/0c1c88f14934b3bb68342f9c5a18eee6.png" alt="Bild"></a> <br><br>  Wir ver√∂ffentlichen jetzt eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Reihe von Artikeln</a> √ºber Docker, die f√ºr diejenigen gedacht sind, die diese Plattform f√ºr den Einsatz in verschiedenen Situationen erlernen m√∂chten.  Das gleiche Material konzentriert sich haupts√§chlich auf den professionellen Einsatz von Docker in der Entwicklung von Node.j. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Was ist ein Docker?</font> </h2><br>  Docker ist ein Programm zur Organisation der Virtualisierung auf Betriebssystemebene (Containerisierung).  Das Herzst√ºck von Containern sind geschichtete Bilder.  Einfach ausgedr√ºckt ist Docker ein Tool, mit dem Sie Anwendungen mithilfe von Containern erstellen, bereitstellen und ausf√ºhren k√∂nnen, unabh√§ngig vom Betriebssystem, auf dem sie ausgef√ºhrt werden.  Der Container enth√§lt ein Image des Basisbetriebssystems, das f√ºr das Funktionieren der Anwendung erforderlich ist, die Bibliothek, von der diese Anwendung abh√§ngt, und diese Anwendung selbst.  Wenn mehrere Container auf demselben Computer ausgef√ºhrt werden, verwenden sie die Ressourcen dieses Computers zusammen.  Docker-Container k√∂nnen Projekte packen, die mit einer Vielzahl von Technologien erstellt wurden.  Wir sind an Projekten interessiert, die auf Node.js basieren. <br><br><h2>  <font color="#3AC1EF">Erstellen eines Node.js-Projekts</font> </h2><br>  Bevor wir ein Node.js-Projekt in einen Docker-Container packen, m√ºssen wir dieses Projekt erstellen.  Lass es uns tun.  Hier ist die Datei <code>package.json</code> dieses Projekts: <br><br><pre> <code class="bash hljs">{ <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"node-app"</span></span>, <span class="hljs-string"><span class="hljs-string">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-string"><span class="hljs-string">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"The best way to manage your Node app using Docker"</span></span>, <span class="hljs-string"><span class="hljs-string">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"index.js"</span></span>, <span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node index.js"</span></span> }, <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"Ankit Jain &lt;ankitjain28may77@gmail.com&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-string"><span class="hljs-string">"dependencies"</span></span>: {   <span class="hljs-string"><span class="hljs-string">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.16.4"</span></span> } }</code> </pre> <br>  F√ºhren Sie den Befehl <code>npm install</code> um die Projektabh√§ngigkeiten zu <code>npm install</code> .  Im Verlauf dieses Befehls wird unter anderem die Datei <code>package-lock.json</code> erstellt.  Erstellen Sie nun die Datei <code>index.js</code> , die den Projektcode enth√§lt: <br><br><pre> <code class="bash hljs">const express = require(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); const app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, (req, res) =&gt; { res.send(<span class="hljs-string"><span class="hljs-string">'The best way to manage your Node app using Docker\n'</span></span>); }); app.listen(3000); console.log(<span class="hljs-string"><span class="hljs-string">'Running on http://localhost:3000'</span></span>);</code> </pre> <br>  Wie Sie sehen k√∂nnen, haben wir hier einen einfachen Server beschrieben, der als Antwort auf Anforderungen Text zur√ºckgibt. <br><br><h2>  <font color="#3AC1EF">Erstellen Sie eine Docker-Datei</font> </h2><br>  Nachdem die Anwendung fertig ist, sprechen wir dar√ºber, wie Sie sie in einen Docker-Container packen.  Es geht n√§mlich darum, was der wichtigste Teil eines Docker-basierten Projekts ist, n√§mlich die Docker-Datei. <br><br>  Eine Docker-Datei ist eine Textdatei, die Anweisungen zum Erstellen eines Docker-Images f√ºr eine Anwendung enth√§lt.  Die Anweisungen in dieser Datei beschreiben, wenn sie nicht auf Details eingehen, die Erstellung von Ebenen eines mehrstufigen Dateisystems, das alles enth√§lt, was eine Anwendung zum Arbeiten ben√∂tigt.  Die Docker-Plattform kann Bildebenen zwischenspeichern, was bei der Wiederverwendung von Ebenen, die sich bereits im Cache befinden, das Erstellen von Bildern beschleunigt. <br><br>  In der objektorientierten Programmierung gibt es so etwas wie eine Klasse.  Klassen werden zum Erstellen von Objekten verwendet.  In Docker k√∂nnen Bilder mit Klassen verglichen werden, und Container k√∂nnen mit Instanzen von Bildern verglichen werden, dh mit Objekten.  Betrachten Sie den Prozess des Generierens einer Docker-Datei, um dies herauszufinden. <br><br>  Erstellen Sie eine leere Docker-Datei: <br><br><pre> <code class="bash hljs">touch Dockerfile</code> </pre> <br>  Da wir einen Container f√ºr die Anwendung Node.js erstellen, m√ºssen wir zun√§chst das Basisknoten-Image in den Container einf√ºgen, das sich auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Docker Hub befindet</a> .  Wir werden die LTS-Version von Node.js verwenden.  Infolgedessen lautet die erste Anweisung unserer Docker-Datei wie folgt: <br><br><pre> <code class="bash hljs">FROM node:8</code> </pre> <br>  Erstellen Sie danach ein Verzeichnis f√ºr unseren Code.  Gleichzeitig k√∂nnen wir dank der hier verwendeten <code>ARG</code> Anweisung bei Bedarf den Namen des anderen Anwendungsverzeichnisses als <code>/app</code> w√§hrend der Montage des Containers angeben.  Details zu diesem Handbuch finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR}</span></span></code> </pre> <br>  Da wir das Node-Image verwenden, sind die Plattformen Node.js und npm bereits darin installiert.  Mit dem, was bereits im Image enthalten ist, k√∂nnen Sie die Installation von Projektabh√§ngigkeiten organisieren.  Wenn Sie das Flag <code>--production</code> verwenden (oder wenn die Umgebungsvariable <code>NODE_ENV</code> auf <code>production</code> ), installiert npm die im Abschnitt <code>devDependencies</code> Datei <code>devDependencies</code> aufgef√ºhrten Module nicht. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install #     # RUN npm install --production</span></span></code> </pre> <br>  Hier kopieren wir die <code>package*.json</code> Datei in das Image, anstatt beispielsweise alle Projektdateien zu kopieren.  Wir tun genau das, weil die Dockerfile-Anweisungen <code>RUN</code> , <code>COPY</code> und <code>ADD</code> zus√§tzliche Bildebenen erstellen, sodass Sie die Caching-Funktionen der Docker-Plattformebenen verwenden k√∂nnen.  Mit diesem Ansatz wird Docker beim n√§chsten Sammeln eines √§hnlichen Bilds herausfinden, ob es m√∂glich ist, Bildebenen, die sich bereits im Cache befinden, wiederzuverwenden. In diesem Fall wird das bereits vorhandene Bild ausgenutzt, anstatt neue zu erstellen Schichten.  Auf diese Weise k√∂nnen Sie beim Zusammenstellen von Ebenen bei der Arbeit an gro√üen Projekten, die viele npm-Module enthalten, erheblich Zeit sparen. <br><br>  Kopieren Sie nun die Projektdateien in das aktuelle Arbeitsverzeichnis.  Hier verwenden wir nicht die Anweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ADD</a> , sondern die Anweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">COPY</a> .  In den meisten F√§llen wird empfohlen, die <code>COPY</code> Anweisung zu bevorzugen. <br><br>  Der <code>ADD</code> Befehl weist im Vergleich zu <code>COPY</code> einige Funktionen auf, die jedoch nicht immer ben√∂tigt werden.  Zum Beispiel sprechen wir √ºber Optionen zum Entpacken von .tar-Archiven und zum Herunterladen von Dateien per URL. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#    COPY . .</span></span></code> </pre> <br>  Docker-Container sind isolierte Umgebungen.  Dies bedeutet, dass wir beim Starten der Anwendung im Container nicht direkt mit ihr interagieren k√∂nnen, ohne den Port zu √∂ffnen, den diese Anwendung √ºberwacht.  Um Docker dar√ºber zu informieren, dass sich in einem bestimmten Container eine Anwendung befindet, die einen bestimmten Port <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberwacht</a> , k√∂nnen Sie die Anweisung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">EXPOSE verwenden</a> . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,      EXPOSE 3000</span></span></code> </pre> <br>  Bisher haben wir mithilfe der Docker-Datei das Image beschrieben, das die Anwendung enthalten wird, sowie alles, was zum erfolgreichen Start erforderlich ist.  F√ºgen Sie nun der Datei die Anweisung hinzu, mit der Sie die Anwendung starten k√∂nnen.  Dies ist eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CMD-</a> Anweisung.  Hier k√∂nnen Sie einen bestimmten Befehl mit Parametern angeben, die beim Start des Containers ausgef√ºhrt werden und bei Bedarf von der Befehlszeile √ºberschrieben werden k√∂nnen. <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   CMD ["npm", "start"]</span></span></code> </pre> <br>  So sieht das fertige Dockerfile aus: <br><br><pre> <code class="bash hljs">FROM node:8 <span class="hljs-comment"><span class="hljs-comment">#   ARG APP_DIR=app RUN mkdir -p ${APP_DIR} WORKDIR ${APP_DIR} #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #    COPY . . #   ,      EXPOSE 3000 #   CMD ["npm", "start"]</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Bildassemblierung</font> </h2><br>  Wir haben eine Dockerfile-Datei vorbereitet, die Anweisungen zum Erstellen des Images enth√§lt, auf deren Grundlage ein Container mit einer laufenden Anwendung erstellt wird.  Stellen Sie das Bild zusammen, indem Sie einen Befehl der folgenden Form ausf√ºhren: <br><br><pre> <code class="bash hljs">docker build --build-arg &lt;build arguments&gt; -t &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt; /path/to/Dockerfile</code> </pre> <br>  In unserem Fall sieht es so aus: <br><br><pre> <code class="bash hljs">docker build --build-arg APP_DIR=var/app -t ankitjain28may/node-app:V1 .</code> </pre> <br>  Dockerfile verf√ºgt √ºber eine <code>ARG</code> Anweisung, die das Argument <code>APP_DIR</code> .  Hier setzen wir seine Bedeutung.  Wenn dies nicht getan wird, nimmt es den Wert an, der ihm in der Datei zugewiesen ist, <code>app</code> - <code>app</code> . <br><br>  √úberpr√ºfen Sie nach dem Zusammenstellen des Bildes, ob Docker es sieht.  F√ºhren Sie dazu den folgenden Befehl aus: <br><br><pre> <code class="bash hljs">docker images</code> </pre> <br>  Als Antwort auf diesen Befehl sollte ungef√§hr Folgendes ausgegeben werden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51d/c22/3e0/51dc223e0030bb0275c3d61fa01562e5.png"></div><br>  <i><font color="#999999">Docker-Bilder</font></i> <br><br><h2>  <font color="#3AC1EF">Bildstart</font> </h2><br>  Nachdem wir das Docker-Image zusammengestellt haben, k√∂nnen wir es ausf√ºhren, dh eine Instanz davon erstellen, die durch einen Arbeitscontainer dargestellt wird.  Verwenden Sie dazu einen Befehl dieser Art: <br><br><pre> <code class="bash hljs">docker run -p &lt;External-port:exposed-port&gt; -d --name &lt;name of the container&gt; &lt;user-name&gt;/&lt;image-name&gt;:&lt;tag-name&gt;</code> </pre> <br>  In unserem Fall sieht es so aus: <br><br><pre> <code class="bash hljs">docker run -p 8000:3000 -d --name node-app ankitjain28may/node-app:V1</code> </pre> <br>  Mit diesem Befehl werden wir das System um Informationen zu Arbeitscontainern bitten: <br><br><pre> <code class="bash hljs">docker ps</code> </pre> <br>  Als Reaktion darauf sollte das System Folgendes ausgeben: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87f/bc0/fcf/87fbc0fcf1bdeecef051e2874d48d91e.png"></div><br>  <i><font color="#999999">Docker-Container</font></i> <br><br>  Bisher l√§uft alles wie erwartet, obwohl wir noch nicht versucht haben, auf die im Container ausgef√ºhrte Anwendung zuzugreifen.  Unser Container mit dem Namen <code>node-app</code> √ºberwacht n√§mlich Port <code>8000</code> .  Um zu versuchen, darauf zuzugreifen, k√∂nnen Sie einen Browser √∂ffnen und unter <code>localhost:8000</code> darauf zugreifen.  Um den Zustand des Containers zu √ºberpr√ºfen, k√∂nnen Sie au√üerdem den folgenden Befehl verwenden: <br><br><pre> <code class="bash hljs">curl -i localhost:8000</code> </pre> <br>  Wenn der Container wirklich funktioniert, wird als Antwort auf diesen Befehl etwas wie das in der folgenden Abbildung gezeigte zur√ºckgegeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea4/407/9ba/ea44079bab09d56c402af3c58eb6a638.png"></div><br>  <i><font color="#999999">Ergebnis der Container-Integrit√§tspr√ºfung</font></i> <br><br>  Auf der Grundlage des gleichen Bildes, beispielsweise auf der Grundlage der gerade erstellten, k√∂nnen viele Container erstellt werden.  Dar√ºber hinaus k√∂nnen Sie unser Image an die Docker Hub-Registrierung senden, damit andere Entwickler unser Image hochladen und die entsprechenden Container zu Hause starten k√∂nnen.  Dieser Ansatz vereinfacht die Arbeit mit Projekten. <br><br><h2>  <font color="#3AC1EF">Empfehlungen</font> </h2><br>  Hier sind einige Vorschl√§ge, die Sie ber√ºcksichtigen sollten, um die Leistung von Docker zu nutzen und so kompakte Bilder wie m√∂glich zu erstellen. <br><br><h3>  <font color="#3AC1EF">‚ñç1.</font>  <font color="#3AC1EF">Erstellen Sie immer eine .dockerignore-Datei</font> </h3><br>  In dem Projektordner, den Sie in den Container <code>.dockerignore</code> , m√ºssen Sie immer eine <code>.dockerignore</code> Datei erstellen.  Sie k√∂nnen Dateien und Ordner ignorieren, die beim Erstellen des Bildes nicht ben√∂tigt werden.  Mit diesem Ansatz k√∂nnen wir den sogenannten Build-Kontext reduzieren, wodurch wir das Image schnell zusammenstellen und seine Gr√∂√üe reduzieren k√∂nnen.  Diese Datei unterst√ºtzt Dateinamenvorlagen. In dieser Datei √§hnelt sie einer <code>.gitignore</code> Datei.  Es wird empfohlen, einen Befehl zu <code>.dockerignore</code> hinzuzuf√ºgen, aufgrund dessen Docker den Ordner <code>/.git</code> ignoriert, da dieser Ordner normalerweise gro√üe Materialien enth√§lt (insbesondere w√§hrend der Entwicklung eines Projekts) und das Hinzuf√ºgen zum Bild zu einer Vergr√∂√üerung f√ºhrt.  Dar√ºber hinaus ist das Kopieren dieses Ordners in ein Bild wenig sinnvoll. <br><br><h3>  <font color="#3AC1EF">‚ñç2.</font>  <font color="#3AC1EF">Verwenden Sie den mehrstufigen Bildassemblierungsprozess</font> </h3><br>  Betrachten Sie das Beispiel, wenn wir ein Projekt f√ºr eine bestimmte Organisation sammeln.  Dieses Projekt verwendet viele npm-Pakete, und jedes dieser Pakete kann zus√§tzliche Pakete installieren, von denen es abh√§ngt.  Das Ausf√ºhren all dieser Vorg√§nge f√ºhrt zu zus√§tzlichem Zeitaufwand f√ºr das Zusammenstellen des Images (obwohl dies dank der Caching-Funktionen von Docker keine so gro√üe Sache ist).  Schlimmer noch, das resultierende Bild, das die Abh√§ngigkeiten eines bestimmten Projekts enth√§lt, ist ziemlich gro√ü.  Wenn wir hier √ºber Front-End-Projekte sprechen, k√∂nnen wir uns daran erinnern, dass solche Projekte normalerweise mit Bundlern wie Webpack verarbeitet werden, die es erm√∂glichen, alles, was eine Anwendung ben√∂tigt, bequem in ein Verkaufspaket zu packen.  Daher sind npm-Paketdateien f√ºr ein solches Projekt nicht erforderlich.  Dies bedeutet, dass wir solche Dateien entfernen k√∂nnen, nachdem wir das Projekt mit demselben Webpack erstellt haben. <br><br>  Versuchen Sie mit dieser Idee Folgendes zu tun: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   COPY package*.json ./ RUN npm install --production # - COPY . . RUN npm run build:production #    npm- RUN rm -rf node_modules</span></span></code> </pre> <br>  Ein solcher Ansatz wird uns jedoch nicht passen.  Wie bereits erw√§hnt, erstellen die Anweisungen <code>RUN</code> , <code>ADD</code> und <code>COPY</code> von Docker zwischengespeicherte Ebenen. Daher m√ºssen wir einen Weg finden, um die Installation von Abh√§ngigkeiten zu handhaben, das Projekt zu erstellen und dann unn√∂tige Dateien mit einem einzigen Befehl zu l√∂schen.  Zum Beispiel k√∂nnte es so aussehen: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      COPY . . #  ,      RUN npm install --production &amp;&amp; npm run build:production &amp;&amp; rm -rf node_module</span></span></code> </pre> <br>  In diesem Beispiel gibt es nur eine <code>RUN</code> Anweisung, die die Abh√§ngigkeiten installiert, <code>node_modules</code> Projekt erstellt und den Ordner <code>node_modules</code> l√∂scht.  Dies f√ºhrt dazu, dass die Gr√∂√üe des Bildes nicht so gro√ü ist wie die Gr√∂√üe des Bildes, das den Ordner <code>node_modules</code> .  Wir verwenden die Dateien aus diesem Ordner nur w√§hrend des Erstellungsprozesses des Projekts und l√∂schen sie dann.  Dieser Ansatz ist insofern schlecht, als die Installation von npm-Abh√§ngigkeiten viel Zeit in Anspruch nimmt.  Sie k√∂nnen diesen Nachteil mithilfe der Technologie der mehrstufigen Montage von Bildern beseitigen. <br><br>  Stellen Sie sich vor, wir arbeiten an einem Frontend-Projekt mit vielen Abh√§ngigkeiten und verwenden Webpack, um dieses Projekt zu erstellen.  Mit diesem Ansatz k√∂nnen wir zur Reduzierung der Bildgr√∂√üe die Funktionen von Docker f√ºr die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mehrstufige Montage von Bildern nutzen</a> . <br><br><pre> <code class="bash hljs">FROM node:8 As build <span class="hljs-comment"><span class="hljs-comment">#  RUN mkdir /app &amp;&amp; mkdir /src WORKDIR /src #   COPY package*.json ./ RUN npm install #     # RUN npm install --production #       COPY . . RUN npm run build:production #    ,     FROM node:alpine #      build   app COPY --from=build ./src/build/* /app/ ENTRYPOINT ["/app"] CMD ["--help"]</span></span></code> </pre> <br>  Bei diesem Ansatz ist das resultierende Bild viel kleiner als das vorherige Bild, und wir verwenden auch das <code>node:alpine</code> Bild, das selbst sehr klein ist.  Und hier ist ein Vergleich eines Bildpaares, bei dem zu sehen ist, dass das Bild von <code>node:alpine</code> viel kleiner ist als das Bild von <code>node:8</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/565/c80/c3b/565c80c3bb0498e0ebcdf53022bdab6e.png"></div><br>  <i><font color="#999999">Vergleichen von Bildern aus dem Node-Repository</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç3.</font>  <font color="#3AC1EF">Verwenden Sie den Docker-Cache</font> </h3><br>  Versuchen Sie, die Caching-Funktionen von Docker zum Erstellen Ihrer Bilder zu verwenden.  Wir haben diese Funktion bereits bei der Arbeit mit einer Datei beachtet, auf die √ºber das Namenspaket <code>package*.json</code> .  Dies reduziert die Erstellungszeit des Bildes.  Diese Gelegenheit sollte jedoch nicht vorschnell genutzt werden. <br><br>  Angenommen, wir beschreiben in Dockerfile die Installation von Paketen in einem Image, das aus dem Basis- <code>Ubuntu:16.04</code> Image erstellt wurde <code>Ubuntu:16.04</code> : <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update &amp;&amp; apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Wenn das System diese Datei verarbeitet und viele Pakete installiert sind, nehmen die Aktualisierungs- und Installationsvorg√§nge viel Zeit in Anspruch.  Um die Situation zu verbessern, haben wir uns entschlossen, die Layer-Caching-Funktionen von Docker zu nutzen und die Docker-Datei wie folgt neu zu schreiben: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   .   .</code> </pre> <br>  Wenn Sie das Bild jetzt zum ersten Mal zusammenstellen, l√§uft alles so, wie es sollte, da der Cache noch nicht gebildet wurde.  Stellen Sie sich jetzt vor, wir m√ºssen ein anderes Paket installieren, <code>package-2</code> .  Dazu schreiben wir die Datei neu: <br><br><pre> <code class="bash hljs">FROM ubuntu:16.04 RUN apt-get update RUN apt-get install -y \   curl \   package-1 \   package-2 \   .   .</code> </pre> <br>  Aufgrund eines solchen Befehls wird <code>package-2</code> nicht installiert oder aktualisiert.  Warum?  Tatsache ist, dass Docker beim Ausf√ºhren der <code>RUN apt-get update</code> Anweisung <code>RUN apt-get update</code> keinen Unterschied zwischen dieser Anweisung und der zuvor ausgef√ºhrten Anweisung sieht, sodass Daten aus dem Cache entnommen werden.  Und diese Daten sind bereits veraltet.  Bei der Verarbeitung der <code>RUN apt-get install</code> Anweisung <code>RUN apt-get install</code> System sie aus, da sie nicht wie eine √§hnliche Anweisung in der vorherigen Docker-Datei aussieht. W√§hrend der Installation k√∂nnen jedoch Fehler auftreten oder die alte Version von Paketen wird installiert.  Infolgedessen stellt sich heraus, dass die <code>update</code> und <code>install</code> innerhalb derselben <code>RUN</code> Anweisung ausgef√ºhrt werden m√ºssen, wie dies im ersten Beispiel der Fall ist.  Caching ist eine gro√üartige Funktion, aber die r√ºcksichtslose Verwendung dieser Funktion kann zu Problemen f√ºhren. <br><br><h3>  <font color="#3AC1EF">‚ñç4.</font>  <font color="#3AC1EF">Minimieren Sie die Anzahl der Bildebenen</font> </h3><br>  Es wird empfohlen, nach M√∂glichkeit zu versuchen, die Anzahl der Bildebenen zu minimieren, da jede Ebene das Dateisystem des Docker-Bildes ist. Je kleiner das Ebenenbild, desto kompakter wird es.  Bei Verwendung des mehrstufigen Prozesses zum Zusammensetzen von Bildern wird eine Verringerung der Anzahl von Schichten im Bild und eine Verringerung der Gr√∂√üe des Bildes erreicht. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir uns mit dem Verpacken von Node.js-Anwendungen in Docker-Containern und dem Arbeiten mit solchen Containern befasst.  Dar√ºber hinaus haben wir einige Empfehlungen abgegeben, die √ºbrigens nicht nur beim Erstellen von Containern f√ºr Node.js-Projekte verwendet werden k√∂nnen. <br><br>  <b>Liebe Leser!</b>  Wenn Sie Docker bei der Arbeit mit Node.js-Projekten professionell verwenden, teilen Sie Anf√§ngern Empfehlungen zur effektiven Verwendung dieses Systems mit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440656/">https://habr.com/ru/post/de440656/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440646/index.html">Frontend Weekly Digest (11. - 17. Februar 2019)</a></li>
<li><a href="../de440648/index.html">√úberblick √ºber die russische Gesetzgebung im Bereich der Barrierefreiheit im Internet</a></li>
<li><a href="../de440650/index.html">Wie Bewusstsein funktioniert: Schlussfolgerungen aus dem Buch von Alexander Nevzorov</a></li>
<li><a href="../de440652/index.html">Computervideo in 755 Megapixeln: Plenoptik gestern, heute und morgen</a></li>
<li><a href="../de440654/index.html">Python lernen: Argparse-Modul</a></li>
<li><a href="../de440658/index.html">Exploring Docker, Teil 4: Reduzieren der Gr√∂√üe von Bildern und Beschleunigen ihrer Montage</a></li>
<li><a href="../de440660/index.html">Docker lernen, Teil 5: Befehle</a></li>
<li><a href="../de440662/index.html">React Tutorial Teil 18: Die sechste Phase der Arbeit an einer TODO-Anwendung</a></li>
<li><a href="../de440666/index.html">Klassifizierung handschriftlicher Zeichnungen. Bericht in Yandex</a></li>
<li><a href="../de440670/index.html">Die Zentralbank ver√∂ffentlichte Empfehlungen zum kryptografischen Schutz von EBS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>