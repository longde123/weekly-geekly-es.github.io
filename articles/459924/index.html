<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêë üßñüèø üìÜ Ciclo completo de prueba de reacci√≥n. Auto.ru Report üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© üë®üèª‚Äç‚öñÔ∏è üëÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El deseo de alejarse de las pruebas de regresi√≥n manual es una buena raz√≥n para introducir pruebas autom√°ticas. La pregunta es cu√°les. Los desarrollad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ciclo completo de prueba de reacci√≥n. Auto.ru Report</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459924/"> El deseo de alejarse de las pruebas de regresi√≥n manual es una buena raz√≥n para introducir pruebas autom√°ticas.  La pregunta es cu√°les.  Los desarrolladores de interfaces Natalya Stus y Alexei Androsov recordaron c√≥mo su equipo pas√≥ por varias iteraciones y construyeron pruebas frontend en Auto.ru basadas en Jest y Puppeteer: pruebas unitarias, pruebas para componentes React individuales, pruebas de integraci√≥n.  Lo m√°s interesante de esta experiencia es la prueba aislada de componentes React en un navegador sin Selenium Grid, Java y otras cosas. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/yr/np/zo/yrnpzon4-5momllzoy0bg1zz-ie.jpeg"></a> <br><br>  Alexey: <br>  - Primero debes contar un poco qu√© es Automotive News.  Este es un sitio que vende autos.  Hay una b√∫squeda, cuenta personal, servicios de autom√≥viles, repuestos, revisiones, concesionarios y mucho m√°s.  Auto.ru es un proyecto muy grande, con mucho c√≥digo.  Escribimos todo el c√≥digo en un gran monorepe, porque todo est√° mezclado.  Las mismas personas realizan tareas similares, por ejemplo, para dispositivos m√≥viles y de escritorio.  Resulta mucho c√≥digo, y monorepa es vital para nosotros.  La pregunta es c√≥mo probarlo. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/vn/qv/qf/vnqvqfbci0v-wlfceczgd5snhgi.jpeg"><br><br>  Tenemos React y Node.js, que realiza la representaci√≥n del lado del servidor y solicita datos del backend.  Piezas restantes y peque√±as en el BEM. <br><br><img src="https://habrastorage.org/webt/xb/1p/_b/xb1p_b-9j8huy-rle317mtp5sjc.jpeg"><br><br>  Natalya <br>  - Comenzamos a pensar en la automatizaci√≥n.  El ciclo de lanzamiento de nuestras aplicaciones individuales incluy√≥ varios pasos.  Primero, el programador desarrolla la caracter√≠stica en una rama separada.  Despu√©s de eso, en la misma rama separada, la caracter√≠stica es probada por probadores manuales.  Si todo est√° bien, la tarea recae en el candidato de liberaci√≥n.  De lo contrario, vuelva a la iteraci√≥n de desarrollo nuevamente, pruebe nuevamente.  Hasta que el probador diga que todo est√° bien en esta funci√≥n, no entrar√° en el candidato de lanzamiento. <br><br>  Despu√©s de ensamblar el candidato de lanzamiento, hay una regresi√≥n manual, no solo Auto.ru, sino solo el paquete que vamos a lanzar.  Por ejemplo, si vamos a rodar la web de escritorio, entonces hay una regresi√≥n manual de la web de escritorio.  Estos son muchos casos de prueba manual.  Tal regresi√≥n tom√≥ aproximadamente un d√≠a h√°bil de un probador manual. <br><br>  Cuando se completa la regresi√≥n, se produce una liberaci√≥n.  Despu√©s de eso, la rama de lanzamiento se fusiona con el maestro.  En este punto, solo podemos inyectar el c√≥digo maestro, que probamos solo para la web de escritorio, y este c√≥digo puede romper la web m√≥vil, por ejemplo.  Esto no se verifica de inmediato, sino solo en la pr√≥xima regresi√≥n manual: la web m√≥vil. <br><br><img src="https://habrastorage.org/webt/uc/pp/f6/ucppf6mqcfn6rcjayzc7mzgzzwe.jpeg"><br><br>  Naturalmente, el lugar m√°s doloroso en este proceso fue la regresi√≥n manual, que tom√≥ mucho tiempo.  Todos los probadores manuales, naturalmente, est√°n cansados ‚Äã‚Äãde hacer lo mismo todos los d√≠as.  Por lo tanto, decidimos automatizar todo.  La primera soluci√≥n que se ejecut√≥ fueron las autocomprobaciones de Selenium y Java, escritas por un equipo separado.  Estas fueron pruebas de extremo a extremo, e2e, que probaron toda la aplicaci√≥n.  Escribieron alrededor de 5 mil de tales pruebas.  ¬øCon qu√© terminamos? <br><br>  Naturalmente, aceleramos la regresi√≥n.  Las pruebas autom√°ticas pasan mucho m√°s r√°pido que un probador manual, aproximadamente 10 veces m√°s r√°pido result√≥.  En consecuencia, las acciones de rutina que realizaban todos los d√≠as se eliminaron de los probadores manuales.  Los errores encontrados de las pruebas autom√°ticas son m√°s f√°ciles de reproducir.  Simplemente reinicie esta prueba o observe los pasos que sigue, a diferencia del probador manual, que dir√°: "Hice clic en algo y todo se rompi√≥". <br><br>  Proporcion√≥ estabilidad del recubrimiento.  Siempre realizamos las mismas pruebas de ejecuci√≥n, en contraste, de nuevo, de las pruebas manuales, cuando el evaluador puede considerar que no tocamos este lugar, y no lo comprobar√© esta vez.  Agregamos pruebas para comparar capturas de pantalla, mejoramos la precisi√≥n de las pruebas de IU; ahora verificamos la diferencia en un par de p√≠xeles que el probador no ver√° con sus ojos.  Todo gracias a las pruebas de captura de pantalla. <br><br>  Pero hab√≠a contras.  El m√°s grande: para las pruebas e2e, necesitamos un entorno de prueba que sea totalmente coherente con el producto.  Siempre debe mantenerse actualizado y operativo.  Esto requiere casi tanta fuerza como vender soporte de estabilidad.  Naturalmente, no siempre podemos pagarlo.  Por lo tanto, a menudo tuvimos situaciones en las que el entorno de prueba no funciona o en alg√∫n lugar se rompe algo, y las pruebas fallan, aunque no hubo problemas en el paquete principal. <br><br>  Estas pruebas tambi√©n est√°n siendo desarrolladas por un equipo separado, que tiene sus propias tareas, su propio turno en el rastreador de tareas y las nuevas funciones est√°n cubiertas con cierto retraso.  No pueden venir inmediatamente despu√©s del lanzamiento de una nueva funci√≥n e inmediatamente escribir autotests en ella.  Como las pruebas son caras y dif√≠ciles de escribir y mantener, no cubrimos todos los escenarios con ellos, sino solo los m√°s cr√≠ticos.  Al mismo tiempo, se necesita un equipo separado, y tendr√° herramientas separadas, una infraestructura separada, propia.  Y el an√°lisis de las pruebas ca√≠das tambi√©n es una tarea no trivial para los probadores manuales o para los desarrolladores.  Mostrar√© un par de ejemplos. <br><br><img src="https://habrastorage.org/webt/gn/ix/c6/gnixc6p8h1phrdhcjlosttb0ai8.jpeg"><br><br>  Hemos realizado pruebas.  Pasaron 500 pruebas, de las cuales algunas cayeron.  Podemos ver tal cosa en el informe.  Aqu√≠ la prueba simplemente no comenz√≥, y no est√° claro si todo est√° bien all√≠ o no. <br><br><img src="https://habrastorage.org/webt/40/70/6p/40706pwn5i1vfzfpl4ekmfhpeom.jpeg"><br><br>  Otro ejemplo: la prueba comenz√≥, pero se bloque√≥ con dicho error.  No pudo encontrar ning√∫n elemento en la p√°gina, pero no sabemos por qu√©.  O este elemento simplemente no apareci√≥, o result√≥ estar en la p√°gina incorrecta, o el localizador cambi√≥.  Todo lo que necesitas para ir y debatir las manos. <br><br><img src="https://habrastorage.org/webt/vh/_f/xd/vh_fxdrktlr3llkbrcloced22ks.jpeg"><br><br>  Las pruebas de captura de pantalla tampoco siempre nos dan una buena precisi√≥n.  Aqu√≠ cargamos alg√∫n tipo de tarjeta, se ha movido ligeramente, nuestra prueba ha ca√≠do. <br><br><img src="https://habrastorage.org/webt/_r/1y/dm/_r1ydm4pdscdlxgdse5focstyje.jpeg"><br><br>  Intentamos resolver varios de estos problemas.  Comenzamos a ejecutar parte de las pruebas en el producto; las que no afectan los datos del usuario no cambian nada en la base de datos.  Es decir, en prod hicimos una m√°quina separada que examina el entorno prod.  Simplemente instalamos un nuevo paquete frontend y ejecutamos pruebas all√≠.  El producto es al menos estable. <br><br>  Transferimos algunas de las pruebas a mokeys, pero tenemos muchos backends diferentes, diferentes API, y bloquearlo todo es una tarea muy dif√≠cil, especialmente para 5 mil pruebas.  Para esto, se escribi√≥ un servicio especial llamado mockritsa, que ayuda a hacer los mokas necesarios para el frontend con bastante facilidad y es bastante f√°cil representarlos. <br><br>  Tambi√©n tuvimos que comprar un mont√≥n de hierro para que nuestra red de dispositivos Selenium desde la que se inician estas pruebas fuera m√°s grande para que no se cayeran, ya que no podr√≠an elevar el navegador y, en consecuencia, ir√≠an m√°s r√°pido.  Incluso despu√©s de que intentamos resolver estos problemas, llegamos a la conclusi√≥n de que tales pruebas no son adecuadas para CI, toman mucho tiempo.  No podemos ejecutarlos en cada solicitud de grupo.  Simplemente nunca en nuestra vida analizaremos m√°s adelante estos informes, que se generar√°n para cada solicitud de grupo. <br><br><img src="https://habrastorage.org/webt/od/0z/rl/od0zrladzvsshl04e52vipgtcvo.jpeg"><br><br>  En consecuencia, para CI, necesitamos pruebas r√°pidas y estables que no fallen por algunas razones aleatorias.  Queremos ejecutar pruebas para la solicitud de grupo sin ning√∫n banco de pruebas, backends, bases de datos, sin ning√∫n caso de usuario complicado. <br><br>  Queremos que estas pruebas se escriban simult√°neamente con el c√≥digo, y que los resultados de las pruebas dejen en claro de inmediato en qu√© archivo sali√≥ algo mal. <br><br>  Alexey: <br>  - S√≠, y decidimos probar todo lo que queramos, enderezar todo desde el principio hasta el final en la misma infraestructura de Jest.  ¬øPor qu√© elegimos Jest?  Ya escribimos pruebas unitarias en Jest, nos gust√≥.  Esta es una herramienta popular y compatible, ya tiene un mont√≥n de integraciones listas para usar: React test render, Enzyme.  Todo funciona de f√°brica, no es necesario construir nada, todo es simple. <br><br><img src="https://habrastorage.org/webt/js/bo/sa/jsbosapwtytq_x6a8zkvxl6gdv0.jpeg"><br><br>  Y Jest personalmente gan√≥ para m√≠ en eso, a diferencia de cualquier moka, es dif√≠cil disparar el efecto secundario de alg√∫n tipo de prueba de terceros en su pierna si olvid√© limpiarlo u otra cosa.  En moka, esto se hace una o dos veces, pero en Jest es dif√≠cil hacerlo: se lanza constantemente en hilos separados.  Es posible, pero dif√≠cil.  Y para e2e lanz√≥ Puppeteer, tambi√©n decidimos probarlo.  Eso es lo que tenemos. <br><br><img src="https://habrastorage.org/webt/ab/ph/oa/abphoap_rzksxw_spwh4t_0nfra.jpeg"><br><br>  Natalya <br>  "Tambi√©n comenzar√© con un ejemplo de pruebas unitarias".  Cuando escribimos pruebas simplemente para alguna funci√≥n, no hay problemas especiales.  Llamamos a esta funci√≥n, pasamos algunos argumentos, comparamos lo que sucedi√≥ con lo que deber√≠a haber sucedido. <br><br>  Si hablamos de componentes React, entonces todo se vuelve un poco m√°s complicado.  Necesitamos representarlos de alguna manera.  Existe un procesador de prueba React, pero no es muy conveniente para las pruebas unitarias, ya que no nos permitir√° probar componentes de forma aislada.  Representar√° el componente completamente hasta el final, para su dise√±o. <br><br>  Y quiero mostrar c√≥mo con Enzyme es posible escribir pruebas unitarias para componentes React utilizando un ejemplo de dicho componente donde tenemos un cierto MyComponent.  Obtiene alg√∫n tipo de apoyo, tiene alg√∫n tipo de l√≥gica.  Luego devuelve el componente Foo, que, a su vez, devolver√° el componente de barra, que ya en el componente de barra nos devuelve, de hecho, el dise√±o. <br><br><img src="https://habrastorage.org/webt/h2/1e/e6/h21ee6qkeeucwkgnvye6ewsgxog.jpeg"><br><br>  Podemos usar una herramienta de enzimas como el renderizado superficial.  Esto es justo lo que necesitamos para probar el componente MyComponent de forma aislada.  Y estas pruebas no depender√°n de lo que los componentes foo y bar contendr√°n dentro de s√≠ mismos.  Simplemente probaremos la l√≥gica del componente MyComponent. <br><br>  Jest tiene algo as√≠ como Instant√°nea, y tambi√©n pueden ayudarnos aqu√≠.  "Esperar algo para hacer una captura de pantalla" crear√° una estructura para nosotros, solo un archivo de texto que almacena, de hecho, lo que pasamos a esperar, lo que sucede, y cuando se ejecuta esta prueba por primera vez, este archivo se escribe.  Con m√°s ejecuciones de las pruebas, lo que se obtenga se comparar√° con el est√°ndar contenido en el archivo MyComponent.test.js.snap. <br><br>  Aqu√≠ vemos que todo el renderizado nos devuelve exactamente lo que el m√©todo de renderizado de MyComponent devuelve, y lo que es, en general, no importa.  Podemos escribir esas dos pruebas para nuestros dos casos, para nuestros dos casos para el componente MyComponent. <br><br><img src="https://habrastorage.org/webt/wu/b3/iw/wub3iwlwsatz7ytgzpeim8vsbqs.jpeg"><br><br>  En principio, podemos probar lo mismo sin una instant√°nea, simplemente comprobando los scripts que necesitamos, por ejemplo, comprobando qu√© accesorio se pasa al componente foo.  Pero este enfoque tiene un menos.  Si agregamos alg√∫n otro elemento a MyComponent, nuestra nueva prueba, esto no se muestra de ninguna manera. <br><br><img src="https://habrastorage.org/webt/pd/9e/vy/pd9evyrhuh7kfzrqcukvwpbudaq.jpeg"><br><br>  Por lo tanto, despu√©s de todo, las pruebas de Instant√°neas son aquellas que nos mostrar√°n casi cualquier cambio dentro del componente.  Pero si escribimos ambas pruebas en Snapshot, y luego hacemos los mismos cambios en el componente, entonces veremos que ambas pruebas caer√°n.  En principio, los resultados de estas pruebas fallidas nos dir√°n sobre lo mismo, que agregamos alg√∫n tipo de "hola" all√≠. <br><br><img src="https://habrastorage.org/webt/gv/c1/dc/gvc1dcwq9aw2m3owq6c-esulpsg.jpeg"><br><br>  Y esto tambi√©n es redundante, por lo tanto, creo que es mejor usar una prueba de Instant√°nea para la misma estructura.  Verifique el resto de la l√≥gica de alguna manera diferente, sin Snapshot, porque Snapshot, no son muy indicativos.  Cuando ve Instant√°nea, solo ve que se ha procesado algo, pero no est√° claro qu√© l√≥gica prob√≥ aqu√≠.  Esto es completamente inadecuado para TDD si desea usarlo.  Y no funcionar√° como documentaci√≥n.  Es decir, cuando veas este componente, ver√°s que s√≠, Snapshot corresponde a algo, pero qu√© tipo de l√≥gica hab√≠a all√≠ no est√° muy claro. <br><br><img src="https://habrastorage.org/webt/wa/yc/ia/wayciagk2zoa51amkq8bb9xcqic.jpeg"><br><br><img src="https://habrastorage.org/webt/zk/mj/sa/zkmjsaoqa-34pqk2flku7_n7nsy.jpeg"><br><br>  Del mismo modo, escribiremos pruebas unitarias en el componente foo, en el componente de barra, por ejemplo, Instant√°nea. <br><br><img src="https://habrastorage.org/webt/bg/eu/lk/bgeulklgkyqg-woog9tkqhkkpco.jpeg"><br><br>  Obtenemos 100% de cobertura para estos tres componentes.  Creemos que hemos comprobado todo, estamos bien hechos. <br><br>  Pero digamos que cambiamos algo en el componente de la barra, le agregamos un nuevo accesorio, y obviamente tuvimos una prueba para el componente de la barra.  Corregimos la prueba, y las tres pruebas pasan con nosotros. <br><br><img src="https://habrastorage.org/webt/4i/pe/xc/4ipexciijx7ss998ugl84hr6smi.jpeg"><br><br>  Pero, de hecho, si recopilamos toda esta historia, entonces nada funcionar√°, porque MyComponent no se juntar√° con tal error.  En realidad, no pasamos el accesorio que espera al componente de la barra.  Por lo tanto, estamos hablando del hecho de que en este caso tambi√©n necesitamos pruebas de integraci√≥n que verifiquen, incluso si llamamos correctamente a su componente hijo desde nuestro componente. <br><br><img src="https://habrastorage.org/webt/8e/aa/zk/8eaazkltwuurjeh7fhef39ovblq.jpeg"><br><br>  Teniendo tales componentes y cambiando uno de ellos, inmediatamente ver√° qu√© cambios en este componente han afectado. <br><br>  ¬øQu√© oportunidades tenemos en Enzyme para realizar pruebas de integraci√≥n?  El renderizado en s√≠ mismo devuelve dicha estructura.  Tiene un m√©todo de inmersi√≥n, si se llama en alg√∫n componente React, fallar√°.  En consecuencia, al llamarlo al componente foo, obtenemos lo que el componente foo representa, esto es una barra, si hacemos la inmersi√≥n nuevamente, obtendremos, de hecho, el dise√±o que el componente de la barra nos devuelve.  Esto solo ser√° una prueba de integraci√≥n. <br><br><img src="https://habrastorage.org/webt/oo/jm/af/oojmafj91rsbbpprnhyqf868qoy.jpeg"><br><br>  O puede renderizar todo a la vez utilizando el m√©todo de montaje, que implementa la representaci√≥n DOM completa.  Pero no aconsejo hacer esto, porque ser√° una instant√°nea muy dif√≠cil.  Y, como regla, no es necesario que verifique toda la estructura por completo.  Solo necesita verificar la integraci√≥n entre el componente primario y secundario en cada caso. <br><br><img src="https://habrastorage.org/webt/q9/ud/i-/q9udi-03qar0hjqhxe6th8an6zc.jpeg"><br><br>  Y para MyComponent agregamos una prueba de integraci√≥n, por lo que en la primera prueba agrego solo dive, y resulta que probamos no solo la l√≥gica del componente en s√≠, sino tambi√©n su integraci√≥n con el componente foo.  Lo mismo, agregamos la prueba de integraci√≥n para el componente foo que llama correctamente el componente de barra, y luego verificamos toda esta cadena, y estamos seguros de que ning√∫n cambio nos interrumpir√°, de hecho, la representaci√≥n de MyComponent <br><br><img src="https://habrastorage.org/webt/ff/zu/fq/ffzufq_vcw5lmuygnztd0lycvao.jpeg"><br><br>  Otro ejemplo, ya de un proyecto real.  Solo brevemente sobre qu√© m√°s pueden hacer Jest y Enzyme.  Jest puede hacer moki.  Puede, si usa alguna funci√≥n externa en su componente, puede bloquearla.  Por ejemplo, en este ejemplo, llamamos a alg√∫n tipo de API, por supuesto, no queremos ir a ninguna API en la prueba unitaria, por lo que simplemente borramos la funci√≥n getResource con alg√∫n objeto jest.fn.  De hecho, la funci√≥n simulada.  Luego podemos verificar si se llam√≥ o no, cu√°ntas veces se llam√≥ y con qu√© argumentos.  Todo esto te permite hacer bromas. <br><br><img src="https://habrastorage.org/webt/z8/lb/ap/z8lbapgq_qzer-1vz3yazx9wo-o.jpeg"><br><br>  En el renderizado superficial, puede pasar la tienda a un componente.  Si necesita una tienda, simplemente puede transferirla all√≠ y funcionar√°. <br><br><img src="https://habrastorage.org/webt/y2/tl/ih/y2tlihjjqqwogsbftvcirxe_njc.jpeg"><br><br>  Tambi√©n puede cambiar el estado y el accesorio en un componente ya renderizado. <br><br><img src="https://habrastorage.org/webt/ew/8g/hc/ew8ghcc6gtv3347yt8ik6o9v6s4.jpeg"><br><br>  Puede llamar al m√©todo de simulaci√≥n en alg√∫n componente.  Simplemente llama al manejador.  Por ejemplo, si simula hacer clic, llamar√° a onClick para el componente del bot√≥n aqu√≠.  Todo esto se puede leer, por supuesto, en la documentaci√≥n sobre Enzyme, muchas piezas √∫tiles.  Estos son solo algunos ejemplos de un proyecto real. <br><br><img src="https://habrastorage.org/webt/tw/kn/9t/twkn9txihstmq5pdpc9yqgc1nnw.jpeg"><br><br>  Alexey: <br>  - Llegamos a la pregunta m√°s interesante.  Podemos probar Jest, podemos escribir pruebas unitarias, verificar componentes, verificar qu√© elementos responden incorrectamente a un clic.  Podemos verificar su html.  Ahora necesitamos verificar el dise√±o del componente, css. <br><br><img src="https://habrastorage.org/webt/fw/dj/8p/fwdj8pbfn6ywa4he7ejwjnq6hs4.jpeg"><br><br>  Y es aconsejable hacer esto para que el principio de prueba no difiera de ninguna manera del que describ√≠ anteriormente.  Si reviso html, llam√© renderizado superficial, me tom√≥ y me mostr√≥ html.  Quiero verificar css, solo llamar a alg√∫n tipo de render y simplemente verificar, sin subir nada, sin configurar ninguna herramienta. <br><br><img src="https://habrastorage.org/webt/mz/u-/p2/mzu-p2y3eiblryntol0eelzghtc.jpeg"><br><br>  Comenc√© a buscarlo, y en casi todas partes se dio la misma respuesta a todo esto llamado Titiritero, o grilla de selenio.  Abre alguna pesta√±a, va a una p√°gina html, toma una captura de pantalla y la compara con la opci√≥n anterior.  Si no ha cambiado, entonces todo est√° bien. <br><br>  La pregunta es, ¬øqu√© es la p√°gina html si solo quiero verificar un componente de forma aislada?  Es deseable, en diferentes condiciones. <br><br><img src="https://habrastorage.org/webt/w2/t0/vn/w2t0vni_fdskrtopftgiigmxows.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace desde la diapositiva</a></sub></sup> </h5><br>  No quiero escribir un mont√≥n de estas p√°ginas html para cada componente, para cada estado.  Avito tiene una buena racha.  Roma Dvornov public√≥ un art√≠culo sobre Habr√©, y √©l, por cierto, tuvo un discurso.  ¬øQu√© hicieron ellos?  Toman componentes, ensamblan html a trav√©s de un render est√°ndar.  Luego, con la ayuda de complementos y todo tipo de trucos, recopilan todos los activos que tienen: im√°genes, css.  Ins√©rtelo todo en html y obtendr√°n el html correcto. <br><br><img src="https://habrastorage.org/webt/0j/yr/zk/0jyrzkzvwzebsx36hos2vvi1uvs.jpeg"><br><h5>  <sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Enlace desde la diapositiva</a></sub></sup> </h5><br>  Y luego levantaron un servidor especial, enviaron html all√≠, lo renderiza y devuelve alg√∫n resultado.  Un art√≠culo muy interesante, lea, sin embargo, puede extraer muchas ideas interesantes a partir de ah√≠. <br><br><img src="https://habrastorage.org/webt/z5/xp/gb/z5xpgbasgyr6gooqi_dt-p4_mxw.jpeg"><br><br>  Lo que no me gusta all√≠.  Ensamblar un componente es diferente de c√≥mo va a la producci√≥n.  Por ejemplo, tenemos webpack, y all√≠ ser√° recolectado por alg√∫n tipo de activos de babel, all√≠ se extrae de manera diferente.  No puedo garantizar que prob√© lo que voy a descargar ahora. <br><br>  Y de nuevo, un servicio separado para capturas de pantalla.  Quiero hacerlo de alguna manera m√°s f√°cil.  Y, de hecho, exist√≠a la idea de que, vamos a recogerlo exactamente igual que lo haremos.  Y trate de usar algo como Docker, porque es tal cosa, se puede poner en una computadora, localmente, ser√° simple, aislado, no tocar√° nada, todo est√° bien. <br><br><img src="https://habrastorage.org/webt/9k/nz/hm/9knzhmk3-qivjt6peujxtmjnovw.jpeg"><br><br>  Pero este problema es con la p√°gina html, sigue siendo lo que realmente es.  Y naci√≥ una idea.  Tiene un webpack.conf simplificado, y de √©l hay algo de EntryPoint para el cliente js.  Se describen los m√≥dulos, c√≥mo ensamblarlos, el archivo de salida, todos los complementos que ha descrito, todo est√° configurado, todo est√° bien. <br><br><img src="https://habrastorage.org/webt/3f/km/ha/3fkmhal86lf6s38oq8rnnhchsdg.jpeg"><br><br>  ¬øQu√© pasa si me gusta esto?  √âl entrar√° en mi componente y lo recoger√° de forma aislada.  Y habr√° exactamente un componente.  Si agrego html webpack all√≠, tambi√©n me dar√° html, y estos activos se recopilar√°n all√≠, y esto, sin embargo, ya puede probarse autom√°ticamente. <br><br>  Y estaba a punto de escribir todo esto, pero luego encontr√© esto. <br><br><img src="https://habrastorage.org/webt/hq/ju/0s/hqju0sbemjp1z3ryufas0pk0tfu.jpeg"><br><br>  Jest-titiritero-React, un complemento joven.  Y comenc√© a contribuir activamente a ello.  Si de repente quieres probarlo, puedes, por ejemplo, venir a m√≠, de alguna manera puedo ayudarte.  El proyecto, de hecho, no es m√≠o. <br><br>  Escribe un archivo normal como test.js, y estos archivos deben escribirse un poco por separado para ayudar a encontrarlos, a fin de no compilar todo el proyecto por usted, sino compilar solo los componentes necesarios.  De hecho, tomas la configuraci√≥n del paquete web.  Y los puntos de entrada cambian a estos archivos browser.js, es decir, exactamente lo que queremos probar se empaquetar√° en html, y con la ayuda de Puppeteer le tomar√° capturas de pantalla. <br><br><img src="https://habrastorage.org/webt/3e/jh/fr/3ejhfrfte3ucybs-vvl6ncw28vo.jpeg"><br><br>  Que puede hacer el?    ,         jest-image-snapshot.    .     ,     ,  js,   media-query, ,  . <br><br>    headless-,  ,    ,  ,   ,  headless-,     Chrome   .  web-,    , , ,   . <br><br>       Docker.          .  .  ,  Docker,  .   .  Docker     ,         , ,     Linux,   -   ,      -  .  Docker   ,            . <br><br><img src="https://habrastorage.org/webt/gt/26/zc/gt26zcwy-madcquchbm37l89lwo.jpeg"><br><br>      ?   ,       . ,  .    before-after,     ,  .   ,    .   ,         Chrome,       Firefox.    . <br><br>       .    pixelmatch.  ,   looksame,    ¬´¬ª,    .   ,         . <br><br><img src="https://habrastorage.org/webt/ep/zg/ov/epzgovfoqseh2bj5r7jcr8z0lr0.jpeg"><br><br>  ‚Äî   .   ,  ,     .  ,    :    - ,             ‚Äî    Enzyme.      Redux   store .  .    viewport,  ,      .   , ,     . <br><br><img src="https://habrastorage.org/webt/ln/wh/qu/lnwhqusfy-4mqef59zw0lmnoaus.jpeg"><br><br>      .  ,   .  ?     ,     . <br><br><img src="https://habrastorage.org/webt/ut/l6/xb/utl6xb7objmhjnhozdlamgwzjyk.jpeg"><br><br>   :       5-10        . Selenium    .    ,  , ,           .        . <br><br><img src="https://habrastorage.org/webt/md/qr/rf/mdqrrf6ueg73uu25m6wqfihyo3q.jpeg"><br><br>      Puppeteer,    e2e-.      ,          e2e- ‚Äî   ,    Selenium. <br><br> : <br> ‚Äî ,         Selenium Java ,    .     - JS   Puppeteer,    ,         . <br><br>     ,       .     ,           ,    . <br><br><img src="https://habrastorage.org/webt/0s/7u/ns/0s7uns7oaxi3dcwuejuhk5kwuoy.jpeg"><br><br>   ‚Äî  Selenium  Java,   ‚Äî  JS Puppeteer.   .   18  .          ,   ,    Java.  ,           ,       Java  Selenium. <br><br><img src="https://habrastorage.org/webt/kk/us/pj/kkuspjg5dwwz6h2tuhkwfkssth0.jpeg"><br><br> : <br> ‚Äî     ?       .    , html-,    css   .   e2e.  Genial  ,       . <br><br><img src="https://habrastorage.org/webt/sj/wg/58/sjwg58se3lov3vvrskvjjh2pw90.jpeg"><br><br>     ,    ,  .        . ,   , ‚Äî  , .        ,     . -    , ,      :     ,     . <br><br>   ,         ,     .     git hook,  -,      .    green master ‚Äî   ,   ,  ,      .  Gracias </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459924/">https://habr.com/ru/post/459924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459906/index.html">Tic Tac Toe, parte 3: Deshacer / Rehacer con almacenamiento de comandos</a></li>
<li><a href="../459910/index.html">Situaci√≥n: las empresas no tienen prisa por desarrollar servicios para asistentes de voz: ¬øcu√°les son los riesgos?</a></li>
<li><a href="../459914/index.html">SQL Index Manager: una herramienta gratuita para desfragmentar y mantener √≠ndices</a></li>
<li><a href="../459918/index.html">Resoluci√≥n de problemas con pwnable.kr 03 - bof. Desbordamiento de b√∫fer en la pila</a></li>
<li><a href="../459922/index.html">Eliminar el ruido de alta frecuencia de las se√±ales de los sensores de vibraci√≥n durante el diagn√≥stico de vibraci√≥n de los rodamientos</a></li>
<li><a href="../459928/index.html">El camino del estudiante hacia el desarrollo de aplicaciones m√≥viles</a></li>
<li><a href="../459930/index.html">Automatizaci√≥n de importaci√≥n de Python</a></li>
<li><a href="../459934/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 306 (del 8 al 14 de julio)</a></li>
<li><a href="../459936/index.html">9 trucos m√°s para trabajar con Visual Studio</a></li>
<li><a href="../459948/index.html">Implementaci√≥n de nubes volum√©tricas f√≠sicamente correctas como en Horizon Zero Dawn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>