<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚃 🦇 🎧 Container-to-pipeline: CRI-O sekarang menjadi default di OpenShift Container Platform 4 ✴️ 👨🏽‍🚒 👨🏿‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Platform Red Hat OpenShift Container Platform 4 memungkinkan Anda untuk mengalirkan pembuatan host untuk penyebaran kontainer , termasuk dalam infrast...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Container-to-pipeline: CRI-O sekarang menjadi default di OpenShift Container Platform 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/460495/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Platform Red Hat OpenShift Container Platform 4</a> memungkinkan Anda untuk mengalirkan pembuatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">host untuk penyebaran kontainer</a> , termasuk dalam infrastruktur penyedia layanan cloud, pada platform virtualisasi atau dalam sistem bare-metal.  Untuk membuat platform cloud dalam arti penuh, kami harus mengambil kendali ketat dari semua elemen yang digunakan dan dengan demikian meningkatkan keandalan proses otomasi yang kompleks. <br><br><img src="https://habrastorage.org/webt/h5/hn/x9/h5hnx9ulnrjawbfhd2dncjqmxvm.png" width="100%"><br><br>  Solusi yang jelas adalah menggunakan Red Hat Enterprise Linux CoreOS (variasi dari Red Hat Enterprise Linux) dan CRI-O sebagai standar, dan inilah sebabnya ... <br><a name="habracut"></a><br>  Karena topik navigasi sangat berhasil untuk menemukan analogi dalam menjelaskan operasi Kubernet dan wadah, mari kita coba untuk membicarakan masalah-masalah bisnis yang dipecahkan oleh CoreOS dan CRI-O, dengan menggunakan contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penemuan Brunel untuk produksi blok-blok rigging</a> .  Pada tahun 1803, Mark Brunel ditugaskan untuk membuat 100.000 blok rigging untuk kebutuhan angkatan laut Inggris yang sedang tumbuh.  Blok pengangkat adalah jenis rig yang digunakan untuk memasang tali pada layar.  Hingga awal abad ke-19, balok-balok ini dibuat dengan tangan, tetapi Brunel mampu mengotomatisasi produksi dan mulai memproduksi balok standar dengan menggunakan mesin.  Otomatisasi proses ini berarti bahwa, semua blok hampir sama, dapat dengan mudah diganti jika terjadi kerusakan, dan dapat dibuat dalam jumlah besar. <br><br>  Sekarang bayangkan Brunel harus melakukan pekerjaan ini untuk 20 model kapal yang berbeda (versi Kubernetes) dan untuk lima planet berbeda dengan arus dan angin laut yang sangat berbeda (penyedia cloud).  Selain itu, semua kapal (klaster OpenShift) diharuskan, terlepas dari planet mana pun yang dinavigasi, dari sudut pandang kapten (operator yang mengendalikan operasi kluster) berperilaku identik.  Melanjutkan analogi kelautan, kapten kapal benar-benar tidak peduli blok rigging (CRI-O) apa yang digunakan pada kapal mereka - hal utama bagi mereka adalah bahwa blok ini kuat dan dapat diandalkan. <br><br>  OpenShift 4, sebagai platform cloud, menghadapi tantangan bisnis yang sangat mirip.  Node baru harus dibuat pada saat pembuatan cluster, dalam hal terjadi kegagalan di salah satu node, atau ketika scaling cluster.  Saat membuat dan menginisialisasi node baru, komponen host kritis, termasuk CRI-O, harus dikonfigurasi dengan tepat.  Seperti dalam produksi lain, "bahan baku" harus dipasok di awal.  Dalam kasus kapal, logam dan kayu bertindak sebagai bahan baku.  Namun, jika Anda membuat host untuk menggunakan kontainer di cluster OpenShift 4, Anda harus memiliki file konfigurasi dan server API yang disediakan di input.  Setelah itu, OpenShift akan memberikan tingkat otomatisasi yang diperlukan sepanjang siklus hidup, menawarkan dukungan produk yang diperlukan untuk pengguna akhir dan dengan demikian membayar investasi dalam platform. <br><br>  OpenShift 4 dibuat sedemikian rupa untuk memberikan kemampuan untuk memperbarui sistem dengan nyaman sepanjang siklus hidup platform (untuk versi 4.X) untuk semua pemasok utama komputasi awan, platform virtualisasi, dan bahkan sistem logam telanjang.  Untuk ini, node harus dibuat berdasarkan elemen yang dapat dipertukarkan.  Ketika sebuah cluster membutuhkan versi baru Kubernetes, itu juga menerima versi CRI-O yang sesuai pada CoreOS.  Karena versi CRI-O terkait langsung dengan Kubernetes, semua ini sangat menyederhanakan permutasi untuk pengujian, pemecahan masalah atau dukungan.  Selain itu, pendekatan ini mengurangi biaya untuk pengguna akhir dan Red Hat. <br><br>  Ini adalah tampilan fundamental baru pada kluster Kubernetes, yang meletakkan dasar untuk perencanaan fitur baru yang sangat berguna dan menarik.  CRI-O (proyek kontainer terbuka Interface Runtime Interface - Open Container Initiative, disingkat CRI-OCI) adalah pilihan paling sukses untuk pembuatan massal node, yang diperlukan untuk bekerja dengan OpenShift.  CRI-O akan menggantikan mesin Docker yang sebelumnya digunakan, menawarkan pengguna OpenShift yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ekonomis, stabil, sederhana, dan membosankan</a> - ya, Anda mendengarnya dengan benar - mesin kontainer membosankan yang dirancang khusus untuk bekerja dengan Kubernetes. <br><br><h3>  Dunia wadah terbuka </h3><br>  Dunia telah lama bergerak menuju wadah terbuka.  Baik di Kubernetes, atau di tingkat yang lebih rendah, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengembangan standar wadah</a> mengarah pada ekosistem inovasi di setiap tingkat. <br><br>  Semuanya dimulai dengan penciptaan Open Containers Initiative <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pada Juni 2015</a> .  Pada tahap awal pekerjaan ini, spesifikasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar</a> kontainer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(gambar)</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">runtime</a> terbentuk.  Ini memungkinkan jaminan bahwa alat dapat menggunakan standar tunggal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar wadah</a> dan format tunggal untuk bekerja dengannya.  Spesifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">distribusi</a> kemudian ditambahkan, yang memungkinkan pengguna untuk dengan mudah bertukar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar kontainer</a> . <br><br>  Komunitas Kubernetes kemudian mengembangkan standar antarmuka tunggal pluggable yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Container Runtime Interface (CRI)</a> .  Berkat ini, pengguna Kubernetes dapat menghubungkan berbagai mesin untuk bekerja dengan kontainer selain Docker. <br><br>  Insinyur Red Hat dan Google melihat permintaan pasar untuk mesin kontainer yang dapat menerima permintaan dari Kubelet menggunakan protokol CRI dan memperkenalkan kontainer yang kompatibel dengan spesifikasi OCI yang disebutkan di atas.  Jadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada OCID</a> .  Tetapi permisi, karena kami mengatakan bahwa materi ini akan dikhususkan untuk CRI-O?  Faktanya, hanya dengan merilis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi 1.0,</a> proyek ini berganti nama menjadi CRI-O. <br><br>  <b><i>Fig.</i></b>  <b><i>1.</i></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7-/-n/qb/7--nqbszwtnoy38f-tnbuzdmucm.png"></div><br><br><h3>  Inovasi dengan CRI-O dan CoreOS </h3><br>  Dengan peluncuran platform OpenShift 4, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin kontainer yang</a> digunakan di platform default diubah, dan Docker digantikan oleh CRI-O, yang menawarkan lingkungan peluncuran kontainer yang ekonomis, stabil, sederhana dan membosankan, yang berkembang secara paralel dengan Kubernetes.  Ini sangat menyederhanakan dukungan dan konfigurasi cluster.  Mengkonfigurasi mesin wadah dan host, serta mengelolanya, menjadi otomatis dalam OpenShift 4. <br><br>  Berhenti, bagaimana? <br><br>  Itu benar, dengan munculnya OpenShift 4, sekarang tidak ada lagi kebutuhan untuk terhubung ke host individu dan menginstal mesin kontainer, mengkonfigurasi penyimpanan, mengkonfigurasi server untuk pencarian, atau mengkonfigurasi jaringan.  Platform OpenShift 4 telah sepenuhnya dirancang ulang untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kerangka Operator</a> tidak hanya dalam hal aplikasi pengguna akhir, tetapi juga dalam hal operasi tingkat platform dasar, seperti menyebarkan gambar, mengkonfigurasi sistem, atau menginstal pembaruan. <br><br>  Kubernetes selalu memungkinkan pengguna untuk mengelola aplikasi dengan menentukan status yang diinginkan dan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengontrol</a> untuk memastikan bahwa kondisi aktual sedekat mungkin dengan keadaan yang diberikan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendekatan</a> ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan keadaan tertentu dan keadaan aktual</a> membuka peluang besar baik dari sudut pandang pengembangan maupun dari sudut pandang operasi.  Pengembang dapat menentukan status yang diperlukan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mentransfernya ke</a> operator dalam bentuk file YAML atau JSON, dan kemudian operator dapat membuat instance aplikasi yang diperlukan dalam lingkungan operasi, sedangkan status operasional instance ini sepenuhnya sesuai dengan yang ditentukan. <br><br>  Menggunakan Operator di platform, OpenShift 4 membawa paradigma baru ini (menggunakan konsep set dan state aktual) ke manajemen RHEL CoreOS dan CRI-O.  Tugas-tugas untuk mengkonfigurasi dan membuat versi sistem operasi dan mesin kontainer diotomatisasi menggunakan apa yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Machine Config Operator (MCO)</a> .  MCO sangat menyederhanakan pekerjaan administrator cluster, pada dasarnya mengotomatiskan tahap terakhir instalasi, serta operasi selanjutnya setelah instalasi (hari kedua operasi).  Semua ini menjadikan OpenShift 4 platform cloud sejati.  Kita akan membahasnya nanti. <br><br><h3>  Peluncuran kontainer </h3><br>  Pengguna memiliki kesempatan untuk menggunakan mesin CRI-O di platform OpenShift mulai dari versi 3.7 dalam status Tech Preview dan dari versi 3.9 dalam status Tersedia Secara Umum (saat ini didukung).  Selain itu, Red Hat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRI-O secara ekstensif untuk meluncurkan beban kerja produksi</a> di OpenShift Online sejak versi 3.10.  Semua ini memungkinkan tim yang bekerja pada CRI-O untuk mendapatkan pengalaman luas dalam peluncuran massal kontainer pada kelompok Kubernet besar.  Untuk mendapatkan pemahaman dasar tentang bagaimana Kubernet menggunakan CRI-O, mari kita lihat ilustrasi berikut, yang menunjukkan cara kerja arsitektur. <br><br>  <b><i>Fig.</i></b>  <b><i>2. Bagaimana wadah bekerja di kluster Kubernetes</i></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/zr/kz/1azrkzz-ey6euphpkgqpazncwci.png"></div><br><br>  CRI-O menyederhanakan pembuatan host kontainer baru dengan menyinkronkan seluruh level teratas ketika menginisialisasi node baru, dan ketika merilis versi baru platform OpenShift.  Seluruh audit platform memungkinkan pembaruan / rollback transaksional, dan juga mencegah kebuntuan dalam dependensi antara kernel ekor kontainer, mesin kontainer, Kubelets, dan Kubernetes Master.  Dengan manajemen terpusat dari semua komponen platform, dengan kontrol dan manajemen versi, Anda selalu dapat melacak jalur yang jelas dari negara A ke negara B. Ini menyederhanakan proses pembaruan, meningkatkan keamanan, meningkatkan pelaporan kinerja dan membantu mengurangi biaya memperbarui dan menginstal versi baru. <br><br><h3>  Demonstrasi kekuatan elemen yang dapat dipertukarkan </h3><br>  Seperti yang disebutkan sebelumnya, menggunakan Operator Konfigurasi Mesin untuk mengelola host kontainer dan mesin kontainer di OpenShift 4 memberikan tingkat otomatisasi baru yang sebelumnya tidak mungkin terjadi pada platform Kubernetes.  Untuk mendemonstrasikan fitur-fitur baru, kami menunjukkan bagaimana Anda dapat membuat perubahan pada file crio.conf.  Agar tidak bingung dalam terminologi, cobalah untuk fokus pada hasilnya. <br><br>  Pertama, mari kita buat apa yang disebut konfigurasi runtime kontainer - Container Runtime Config.  Pertimbangkan ini sumber daya Kubernetes yang mewakili konfigurasi untuk CRI-O.  Pada kenyataannya, ini adalah versi khusus dari apa yang disebut MachineConfig, yang merupakan konfigurasi apa pun yang digunakan pada mesin RHEL CoreOS di dalam cluster OpenShift. <br><br>  Sumber daya kustom ini, disebut ContainerRuntimeConfig, diciptakan untuk memudahkan administrator klaster untuk mengkonfigurasi CRI-O.  Ini adalah alat yang cukup kuat yang hanya bisa diterapkan ke node tertentu tergantung pada pengaturan MachineConfigPool.  Pertimbangkan ini sekelompok mesin yang memiliki tujuan yang sama. <br><br>  Perhatikan dua baris terakhir yang akan kita ubah di file /etc/crio/crio.conf.  Dua baris ini sangat mirip dengan baris dalam file crio.conf, ini adalah: <br><br><pre><code class="plaintext hljs">vi ContainerRuntimeConfig.yaml</code> </pre> <br>  Kesimpulan: <br><br><pre> <code class="plaintext hljs">apiVersion: machineconfiguration.openshift.io/v1 kind: ContainerRuntimeConfig metadata: name: set-log-and-pid spec: machineConfigPoolSelector: matchLabels: debug-crio: config-log-and-pid containerRuntimeConfig: pidsLimit: 2048 logLevel: debug</code> </pre><br>  Sekarang kirim file ini ke kluster Kubernetes dan verifikasi bahwa itu sebenarnya dibuat.  Harap dicatat bahwa operasi dilakukan dengan cara yang sama dengan sumber daya Kubernet lainnya: <br><br><pre> <code class="plaintext hljs">oc create -f ContainerRuntimeConfig.yaml oc get ContainerRuntimeConfig</code> </pre><br>  Kesimpulan: <br><br><pre> <code class="plaintext hljs">NAME AGE set-log-and-pid 22h</code> </pre><br>  Setelah kami membuat ContainerRuntimeConfig, kami perlu memodifikasi salah satu dari MachineConfigPools untuk membuat Kubernet memahami bahwa kami ingin menerapkan konfigurasi ini ke grup mesin tertentu di cluster.  Dalam hal ini, kami akan mengubah MachineConfigPool untuk node master: <br><br><pre> <code class="plaintext hljs">oc edit MachineConfigPool/master</code> </pre><br>  Kesimpulan (untuk kejelasan, poin utama tersisa): <br><br><pre> <code class="plaintext hljs">... metadata: creationTimestamp: 2019-04-10T23:42:28Z generation: 1 labels: debug-crio: config-log-and-pid operator.machineconfiguration.openshift.io/required-for-upgrade: "" ...</code> </pre><br>  Pada titik ini, MCO mulai membuat file crio.conf baru untuk cluster.  Dalam hal ini, file konfigurasi yang sudah selesai dapat dilihat menggunakan Kubernetes API.  Ingat, ContainerRuntimeConfig hanyalah versi khusus dari MachineConfig, jadi kita bisa melihat hasilnya dengan melihat baris-baris di MachineConfigs: <br><br><pre> <code class="plaintext hljs">oc get MachineConfigs | grep rendered</code> </pre><br>  Kesimpulan: <br><br><pre> <code class="plaintext hljs">rendered-master-c923f24f01a0e38c77a05acfd631910b 4.0.22-201904011459-dirty 2.2.0 16h rendered-master-f722b027a98ac5b8e0b41d71e992f626 4.0.22-201904011459-dirty 2.2.0 4m rendered-worker-9777325797fe7e74c3f2dd11d359bc62 4.0.22-201904011459-dirty 2.2.0 16h</code> </pre><br>  Harap perhatikan bahwa file konfigurasi yang dihasilkan untuk node master ternyata merupakan versi yang lebih baru daripada konfigurasi asli.  Untuk melihatnya, jalankan perintah berikut.  Secara sepintas, kami mencatat bahwa ini mungkin salah satu skrip baris tunggal terbaik dalam sejarah Kubernetes: <br><br><pre> <code class="plaintext hljs">python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.argv[1]))" $(oc get MachineConfig/rendered-master-f722b027a98ac5b8e0b41d71e992f626 -o YAML | grep -B4 crio.conf | grep source | tail -n 1 | cut -d, -f2) | grep pid</code> </pre><br>  Kesimpulan: <br><br><pre> <code class="plaintext hljs">pids_limit = 2048</code> </pre><br>  Sekarang pastikan bahwa konfigurasi telah diterapkan ke semua node master.  Pertama kita mendapatkan daftar node di cluster: <br><br><pre> <code class="plaintext hljs">oc get node | grep master Output: ip-10-0-135-153.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1 ip-10-0-154-0.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1 ip-10-0-166-79.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1</code> </pre><br>  Sekarang lihat file yang diinstal.  Anda akan melihat bahwa file telah diperbarui dengan arahan pid dan debug baru yang kami tentukan dalam sumber daya ContainerRuntimeConfig.  Keanggunan itu sendiri: <br><br><pre> <code class="plaintext hljs">oc debug node/ip-10-0-135-153.us-east-2.compute.internal — cat /host/etc/crio/crio.conf | egrep 'debug||pid'</code> </pre><br>  Kesimpulan: <br><br><pre> <code class="plaintext hljs">... pids_limit = 2048 ... log_level = "debug" ...</code> </pre><br>  Semua perubahan ini di cluster dibuat bahkan tanpa memulai SSH.  Semua pekerjaan dilakukan dengan menghubungi simpul utama Kuberentes.  Artinya, parameter baru ini hanya dikonfigurasikan pada node master.  Pada saat yang sama, node yang bekerja tidak berubah, yang menunjukkan kelebihan metodologi Kubernetes menggunakan set dan kondisi saat ini sebagaimana diterapkan pada host kontainer dan mesin kontainer dengan elemen yang dapat dipertukarkan. <br><br>  Contoh di atas menunjukkan kemampuan untuk membuat perubahan pada klaster OpenShift Platform Platform 4 kecil dengan tiga simpul kerja atau ke kluster produksi besar dengan 3000 simpul.  Bagaimanapun, jumlah pekerjaan akan sama - dan sangat kecil - cukup konfigurasikan file ContainerRuntimeConfig, dan ubah satu label di MachineConfigPool.  Dan Anda dapat melakukan ini dengan versi apa pun dari platform OpenShift Container Platform 4.X yang digunakan oleh Kubernetes sepanjang siklus hidupnya. <br><br>  Seringkali, perusahaan teknologi berkembang sangat cepat sehingga kami tidak dapat menjelaskan mengapa kami memilih teknologi tertentu untuk komponen dasar.  Mesin kontainer secara historis merupakan komponen yang digunakan pengguna untuk berinteraksi secara langsung.  Karena popularitas kontainer secara alami dimulai dengan munculnya mesin kontainer, pengguna sering menunjukkan minat terhadapnya.  Ini adalah alasan lain mengapa Red Hat memilih untuk CRI-O.  Kontainer sedang berkembang, dengan fokus pada orkestrasi hari ini, dan kami sampai pada kesimpulan bahwa CRI-O memberikan pengalaman terbaik ketika bekerja dengan OpenShift 4. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460495/">https://habr.com/ru/post/id460495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460483/index.html">5 Metode untuk Menjalankan Brainstorm yang Efektif</a></li>
<li><a href="../id460485/index.html">Bagaimana turnamen online dapat mencegah "selesai minggu depan"</a></li>
<li><a href="../id460489/index.html">TOP 11 kesalahan dalam pengembangan BCP</a></li>
<li><a href="../id460491/index.html">Sensor suhu dan kelembaban Arduino dengan pengiriman dan perencanaan (Bagian 1)</a></li>
<li><a href="../id460493/index.html">“Killer apps” untuk PC dari tahun 80-an: VisiCalc dan WordStar</a></li>
<li><a href="../id460497/index.html">Penggunaan intuitif metode Monte Carlo dengan rantai Markov</a></li>
<li><a href="../id460499/index.html">Tiga pemenang Dijkstra Prize: bagaimana Hydra 2019 dan SPTDC 2019 pergi</a></li>
<li><a href="../id460501/index.html">Contoh Implementasi Integrasi Berkelanjutan Menggunakan BuildBot</a></li>
<li><a href="../id460503/index.html">Konfigurasi nirkabel Raspberry PI 3 B +</a></li>
<li><a href="../id460505/index.html">Pikat tiga persilangan, atau Mengapa proyek sangat sulit diselesaikan tepat waktu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>