<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌅 🙋🏾 🤚🏻 Malas memuat gambar menggunakan IntersectionObserver 🛵 🔷 👎🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, batu sandungan utama di jalan menuju situs pemuatan kecepatan tinggi adalah gambar. Ini terutama berlaku untuk proyek-proyek e-commerce. Gam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Malas memuat gambar menggunakan IntersectionObserver</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/423485/">  Saat ini, batu sandungan utama di jalan menuju situs pemuatan kecepatan tinggi adalah gambar.  Ini terutama berlaku untuk proyek-proyek e-commerce.  Gambar di atasnya, biasanya cukup "berat", membuat sebagian besar konten halaman.  Ini, sebagai suatu peraturan, mengarah pada fakta bahwa untuk menunjukkan kepada pengguna suatu halaman, browser-nya perlu mengunduh beberapa megabita data grafik.  Bagaimana mempercepat pemuatan halaman dalam situasi ini?  Jawaban untuk pertanyaan ini dikhususkan untuk materi, terjemahan yang kami terbitkan hari ini. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/943/040/c54/943040c5465e609d529aaa40f4f81f67.jpg" alt="gambar"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ketentuan Umum</font> </h2><br>  Pertimbangkan, misalnya, halaman awal Departemen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dalam</a> Negeri di Walmart. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/717/79a/e0971779a66d1ee7c507d8db410dbb2b.gif"></div><br>  <i><font color="#999999">Halaman dengan banyak gambar</font></i> <br><br>  Berikut adalah informasi tentang berapa banyak gambar yang dimuat untuk membentuk halaman ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/5d9/139/5845d91397a03e5e6763a0b953d72f93.png"></div><br>  <i><font color="#999999">Gambar dimuat selama pembentukan halaman</font></i> <br><br>  Seperti yang Anda lihat, ada 137 gambar!  Ini berarti bahwa lebih dari 80% data yang diperlukan untuk menampilkan halaman dan dikirim melalui jaringan disajikan sebagai file grafik. <br><br>  Sekarang kami menganalisis permintaan jaringan yang dieksekusi ketika halaman dimuat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f42/618/dae/f42618daedd718f3766010a6a8a8cde3.png"></div><br>  <i><font color="#999999">Permintaan jaringan dieksekusi selama pembentukan halaman</font></i> <br><br>  Dalam hal ini, file yang dihasilkan dari pemisahan kode proyek diunduh lebih lambat dari yang semestinya.  Ini karena Anda harus memuat bundel utama <code>cp_ny.bundle</code> .  Bundel ini dapat diunduh lebih cepat jika tidak terganggu oleh 18 gambar yang saling bersaing untuk mendapatkan bandwidth. <br><br>  Bagaimana cara memperbaikinya?  Bahkan, untuk benar-benar "memperbaiki" ini tidak akan berhasil, tetapi Anda dapat melakukan banyak hal untuk mengoptimalkan pemuatan gambar.  Ada banyak pendekatan untuk mengoptimalkan gambar yang digunakan pada halaman web.  Diantaranya adalah penggunaan berbagai format file grafik, kompresi data, penggunaan teknik animasi blur, penggunaan CDN.  Saya ingin membahas apa yang disebut "pemuatan malas" gambar (lazy loading).  Secara khusus, kita akan berbicara tentang bagaimana menerapkan teknik ini di situs Bereaksi, tetapi karena didasarkan pada mekanisme JavaScript, itu dapat diintegrasikan ke dalam proyek web apa pun. <br><br><h2>  <font color="#3AC1EF">Proyek percontohan</font> </h2><br>  Mari kita mulai dengan komponen <code>Image</code> React yang sangat sederhana: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Image</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   const { src } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img align=<span class="hljs-string"><span class="hljs-string">"center"</span></span> src={src} /&gt;; } }</code> </pre> <br>  Dibutuhkan, sebagai properti, URL, dan menggunakannya untuk merender elemen <code>img</code> HTML.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> kode JSFiddle yang relevan.  Gambar berikut menunjukkan halaman yang mengandung komponen ini.  Harap dicatat bahwa untuk melihat gambar yang ditampilkan olehnya, Anda perlu menggulir konten halaman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/978/b57/754978b574f4cc42960bda55487491a0.gif"></div><br>  <i><font color="#999999">Halaman dengan komponen yang menampilkan gambar</font></i> <br><br>  Untuk menerapkan teknik pemuatan gambar yang malas di komponen ini, Anda perlu melakukan tiga langkah berikut: <br><br><ol><li>  Jangan membuat gambar segera setelah mengunduh. </li><li>  Siapkan alat untuk mendeteksi tampilan gambar di area tampilan konten halaman. </li><li>  Tampilkan gambar setelah terdeteksi bahwa itu jatuh ke area tampilan. </li></ol><br>  Mari kita lihat langkah-langkah ini. <br><br><h2>  <font color="#3AC1EF">Langkah 1</font> </h2><br>  Pada langkah ini, gambar segera setelah pemuatan tidak ditampilkan. <br><br><pre> <code class="hljs kotlin">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img /&gt;; }</code> </pre> <br><h2>  <font color="#3AC1EF">Langkah 2</font> </h2><br>  Di sini kita mengkonfigurasi mekanisme yang memungkinkan kita mendeteksi saat gambar memasuki area tampilan. <br><br><pre> <code class="hljs coffeescript">componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntersectionObserver(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        }, {   root: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } .... render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img ref={el =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = el} /&gt;; }</code> </pre> <br>  Mari kita menganalisis kode ini.  Inilah yang telah dilakukan di sini: <br><br><ul><li>  Atribut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ref</a> telah ditambahkan ke elemen <code>img</code> .  Ini memungkinkan Anda untuk memperbarui tautan gambar di <code>src</code> tanpa harus merender ulang komponen tersebut. </li><li>  Sebuah instance baru dari <code>IntersectionObserver</code> (kita akan membicarakan ini di bawah). </li><li>  Objek <code>IntersectionObserver</code> diminta untuk mengamati gambar menggunakan konstruksi <code>observe(this.element)</code> . </li></ul><br>  Apa itu <code>IntersectionObserver</code> ?  Menimbang bahwa kata "persimpangan" diterjemahkan sebagai "persimpangan" dan "pengamat" adalah "pengamat", orang sudah bisa menebak peran objek ini.  Jika Anda mencari informasi tentang hal itu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN</a> , Anda dapat mengetahui bahwa Intersection Observer API memungkinkan aplikasi web untuk secara asinkron memantau perubahan di persimpangan elemen dengan induknya atau ruang lingkup dokumen viewport. <br><br>  Pada pandangan pertama, karakteristik API ini mungkin tampak tidak terlalu dapat dimengerti, tetapi pada kenyataannya, strukturnya sangat sederhana.  Contoh <code>IntersectionObserver</code> melewati beberapa parameter.  Secara khusus, kami menggunakan parameter <code>root</code> , yang memungkinkan kami untuk mengatur elemen DOM root, yang kami anggap sebagai wadah, tentang persimpangan elemen dengan perbatasan yang perlu kami ketahui.  Secara default, ini adalah area di mana fragmen yang terlihat dari halaman (viewport) berada, tetapi saya secara eksplisit mengaturnya untuk menggunakan wadah yang terletak di elemen <code>iframe</code> dari JSFiddle.  Ini dilakukan untuk, kemudian, mempertimbangkan satu kemungkinan yang tidak dirancang untuk menggunakan elemen <code>iframe</code> . <br><br>  Alasan yang menggunakan <code>IntersectionObserver</code> untuk menentukan kapan suatu item menjadi terlihat lebih populer daripada metode yang lebih tradisional, seperti menggunakan <code>onScroll</code> dan <code>getBoundingClientRect()</code> bersamaan, karena mekanisme <code>IntersectionObserver</code> berjalan di luar utas utama.  Namun, panggilan balik yang dipanggil setelah <code>IntersectionObserver</code> mendeteksi persimpangan elemen dengan wadah dijalankan secara alami di utas utama, sehingga kodenya tidak boleh terlalu berat. <br><br><h2>  <font color="#3AC1EF">Langkah 3</font> </h2><br>  Sekarang kita perlu mengkonfigurasi callback yang dipanggil ketika mendeteksi persimpangan elemen <code>target</code> (elemen ini dalam kasus kami) dengan wadah <code>root</code> (dalam kasus kami, ini adalah elemen <code>div</code> <code>.container</code> ). <br><br><pre> <code class="hljs kotlin">.... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = new IntersectionObserver( entries =&gt; {   entries.forEach(entry =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { isIntersecting } = entry;     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIntersecting) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.src = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.src;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.disconnect();     }   }); }, {   root: document.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) } ); ....</code> </pre> <br>  Ketika persimpangan terdeteksi, array <code>entries</code> ditransfer ke <code>entries</code> , yang menyerupai sekumpulan snapshot status semua elemen target yang terdeteksi persimpangan perbatasan yang ditentukan.  Properti <code>isIntersecting</code> menunjukkan arah persimpangan.  Jika item yang dipantau berada di luar elemen root, itu <code>true</code> .  Jika suatu elemen meninggalkan elemen root, maka itu <code>false</code> . <br><br>  Jadi, ketika ternyata elemen telah menyeberang dengan batas bawah wadah, saya secara manual mengatur properti <code>src</code> dan mematikan pemantauan untuknya, yang tidak lagi diperlukan. <br><br><h2>  <font color="#3AC1EF">Langkah 4 (rahasia)</font> </h2><br>  Sekarang, pada langkah rahasia keempat dari pekerjaan kami, Anda dapat mengagumi hasilnya dan menikmati kesuksesan.  Berikut adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode</a> yang mengumpulkan apa yang baru saja kita bicarakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/b5c/4e3/edfb5c4e3ab3bd515f11e96fe0e8d8ac.gif"></div><br>  <i><font color="#999999">Hasil penerapan teknik pemuatan gambar malas</font></i> <br><br>  Namun, jika Anda melihat lebih dekat apa yang kita miliki, ternyata di sini Anda dapat menemukan sesuatu yang tidak terlalu baik.  Untuk melihat ini, saya dengan cepat menggulir halaman, sambil memperlambat kecepatan koneksi jaringan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/c00/2ce/400c002ce3f46f27875c40288bf39f4f.gif"></div><br>  <i><font color="#999999">Perilaku halaman saat bergulir dengan cepat dan memperlambat kecepatan koneksi jaringan</font></i> <br><br>  Karena kita memuat gambar hanya setelah telah mencapai area di mana seharusnya sudah terlihat, pengguna tidak memiliki kesempatan untuk menelusuri halaman dan melihat area yang ditempati oleh gambar, dan, tentu saja, gambar itu sendiri, sebelum memuatnya.  Ketika situs melihat dari komputer biasa yang terhubung ke Internet cepat, ini tidak menimbulkan masalah.  Tetapi banyak pengguna modern mengunjungi situs dari ponsel mereka, kadang-kadang mereka menggunakan jaringan 3G atau, lebih buruk lagi, koneksi EDGE. <br><br>  Benar, menangani masalah ini tidak begitu sulit.  Ini dapat dilakukan karena fakta bahwa Intersection Observer API memberi pengembang kemampuan untuk memperluas atau mempersempit batasan elemen root (dalam kasus kami, ini adalah elemen <code>.container</code> ).  Untuk menggunakan kesempatan ini, cukup tambahkan satu baris kode ke tempat wadah root dikonfigurasi: <br><br><pre> <code class="hljs objectivec">rootMargin: <span class="hljs-string"><span class="hljs-string">"0px 0px 200px 0px"</span></span></code> </pre> <br>  Di properti <code>rootMargin</code> , tulis baris yang strukturnya sesuai dengan aturan CSS yang digunakan untuk mengonfigurasi lekukan elemen.  Dalam kasus kami, kami memberi tahu sistem bahwa batas bawah yang digunakan untuk mendeteksi persimpangan elemen dengan wadah perlu ditingkatkan 200 piksel.  Ini berarti bahwa panggilan balik yang sesuai akan dipanggil ketika elemen jatuh ke area yang 200 piksel di bawah batas bawah elemen root (nilai defaultnya adalah 0). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> kode yang mengimplementasikan teknik ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/e52/257/ae8e52257adaf3205addb04ac82dc10a.gif"></div><br>  <i><font color="#999999">Memperbaiki teknik pemuatan gambar yang malas</font></i> <br><br>  Hasilnya, ternyata ketika kita menggulir halaman hanya ke elemen ke-4 dari daftar, gambar dimuat di area yang 200 piksel di bawah area yang terlihat dari halaman. <br>  Sekarang, tampaknya, semua yang dibutuhkan sudah selesai.  Tapi ini tidak benar. <br><br><h2>  <font color="#3AC1EF">Masalah ketinggian gambar</font> </h2><br>  Jika Anda dengan cermat mempelajari ilustrasi GIF di atas, maka Anda mungkin memperhatikan bahwa bilah gulir “melompat” setelah memuat gambar.  Untungnya, masalah ini mudah ditangani.  Alasannya adalah bahwa elemen yang menampilkan gambar pada awalnya memiliki ketinggian 0, yang, setelah memuat gambar, ternyata 300 piksel.  Oleh karena itu, untuk memperbaiki masalah, cukup untuk mengatur elemen ke ketinggian tetap dengan menambahkan atribut <code>height={300}</code> ke gambar. <br><br><h2>  <font color="#3AC1EF">Tentang hasil pengoptimalan</font> </h2><br>  Apa hasil yang kami dapatkan di Walmart setelah menerapkan pemuatan gambar yang malas di halaman <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> ?  Bahkan, hasil spesifik sangat bervariasi tergantung pada banyak keadaan, di antaranya kita dapat mencatat kecepatan koneksi jaringan klien, ketersediaan CDN, jumlah gambar pada halaman dan aturan untuk mendeteksi persimpangan dengan elemen root yang diterapkan padanya.  Dengan kata lain, bagi Anda, untuk menilai dampak pemuatan gambar yang malas pada proyek Anda sendiri, yang terbaik adalah menerapkan dan memverifikasi sendiri.  Tetapi jika Anda masih tertarik untuk melihat apa yang diberikan pemuatan gambar secara malas kepada kami, berikut adalah beberapa laporan Lighthouse.  Yang pertama dibentuk sebelum optimasi, yang kedua - setelah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/4c8/698/5474c8698697e0489dd1ba213970b244.png"></div><br>  <i><font color="#999999">Laporan mercusuar dihasilkan sebelum pengoptimalan</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c82/7ec/203c827ec729a55597ac33568672365e.png"></div><br>  <i><font color="#999999">Laporan mercusuar dihasilkan setelah optimasi</font></i> <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hari ini kami melihat teknik untuk mengoptimalkan halaman web menggunakan pemuatan gambar yang malas.  Jika halaman situs Anda penuh dengan gambar, maka, sangat mungkin, teknik ini akan berguna bagi Anda. <br><br>  <b>Pembaca yang budiman!</b>  Bagaimana Anda mengoptimalkan gambar dan pemuatannya? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423485/">https://habr.com/ru/post/id423485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423475/index.html">Meretas kode penuaan: ilmu baru tentang penuaan dan apa artinya tetap muda</a></li>
<li><a href="../id423477/index.html">Jadilah seorang ninja keamanan: mulai jalan Anda ke ketinggian IB</a></li>
<li><a href="../id423479/index.html">"Pertama": apakah akan terbang ke Mars</a></li>
<li><a href="../id423481/index.html">Saya perlu meningkatkan cluster Kubernetes, tapi saya hanya seorang programmer kode. Ada jalan keluar</a></li>
<li><a href="../id423483/index.html">Menemukan Cara yang Tepat untuk Memisahkan Konten Situs Web Menggunakan Webpack</a></li>
<li><a href="../id423487/index.html">Node.js tanpa node_modules</a></li>
<li><a href="../id423489/index.html">Saya seorang dokter darurat dan saya ingin berbicara tentang elektrokardiogram Apple Watch yang baru</a></li>
<li><a href="../id423491/index.html">PHP Digest No. 139 (3 - 17 September 2018)</a></li>
<li><a href="../id423493/index.html">Android Go adalah miliar perangkat masa depan dan batas 50 MB. Kuliah Yandex</a></li>
<li><a href="../id423495/index.html">Apa yang ada di dalam XGBoost, dan apa yang harus dilakukan Go dengan itu?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>