<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ ü§≠ üöÉ S√©curit√© Mobile OAuth 2.0 üõèÔ∏è üê± ü§òüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous! Je suis Nikita Stupin, sp√©cialiste de la s√©curit√© de l'information, Mail.Ru Mail. Il n'y a pas si longtemps, j'ai men√© une recherche d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>S√©curit√© Mobile OAuth 2.0</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/417031/"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Bonjour √† tous!  Je suis Nikita Stupin, sp√©cialiste de la s√©curit√© de l'information, Mail.Ru Mail.  Il n'y a pas si longtemps, j'ai men√© une recherche de vuln√©rabilit√© sur OAuth 2.0 mobile.  Pour cr√©er un sch√©ma OAuth 2.0 mobile s√©curis√©, il ne suffit pas d'impl√©menter la norme dans sa forme pure et de v√©rifier redirect_uri.  Il est n√©cessaire de prendre en compte les sp√©cificit√©s des applications mobiles et d'appliquer des m√©canismes de protection suppl√©mentaires. <br><br>  Dans cet article, je veux partager avec vous des connaissances sur les attaques contre OAuth 2.0 mobile, sur les m√©thodes de protection et la mise en ≈ìuvre s√ªre de ce protocole.  Tous les composants de protection n√©cessaires, dont je parlerai ci-dessous, sont impl√©ment√©s dans le dernier SDK pour les clients mobiles Mail.Ru Mail. <br><a name="habracut"></a><br><h1>  La nature et la fonction d'OAuth 2.0 </h1><br>  OAuth 2.0 est un protocole d'autorisation qui d√©crit comment un service client peut acc√©der en toute s√©curit√© aux ressources utilisateur sur un fournisseur de services.  Dans le m√™me temps, OAuth 2.0 √©vite √† l'utilisateur d'avoir √† saisir un mot de passe en dehors du prestataire de services: l'ensemble du processus se r√©duit √† cliquer sur le bouton ¬´J'accepte d'accorder l'acc√®s √† ...¬ª. <br><br>  Un fournisseur en termes d'OAuth 2.0 est un service qui poss√®de des donn√©es utilisateur et, avec la permission de l'utilisateur, fournit des services tiers (clients) avec un acc√®s s√©curis√© √† ces donn√©es.  Un client est une application qui souhaite recevoir des donn√©es utilisateur d'un fournisseur. <br><br>  Quelque temps apr√®s la sortie du protocole OAuth 2.0, les d√©veloppeurs ordinaires l'ont adapt√© pour l'authentification, bien qu'il n'√©tait pas initialement pr√©vu pour cela.  L'authentification d√©place le vecteur d'attaque des donn√©es utilisateur stock√©es chez le fournisseur de services vers les comptes d'utilisateurs de service utilisateur. <br><br>  Elle ne se limitait pas √† l'authentification seule.  √Ä l'√®re des applications mobiles et de l'exaltation de la conversion, entrer dans l'application avec un seul bouton est devenu tr√®s tentant.  Les d√©veloppeurs ont mis OAuth 2.0 sur des rails mobiles.  Naturellement, peu de gens ont pens√© √† la s√©curit√© et aux sp√©cificit√©s des applications mobiles: encore et encore, et en production.  Cependant, OAuth 2.0 ne fonctionne g√©n√©ralement pas bien en dehors des applications Web: les m√™mes probl√®mes sont observ√©s dans les applications mobiles et de bureau. <br><br>  Voyons comment cr√©er un OAuth 2.0 mobile s√©curis√©. <br><br><h1>  Comment √ßa marche? </h1><br>  N'oubliez pas que sur les appareils mobiles, le client peut ne pas √™tre un navigateur, mais une application mobile sans backend.  Par cons√©quent, nous sommes confront√©s √† deux probl√®mes de s√©curit√© majeurs pour OAuth 2.0 mobile: <br><br><ol><li>  Le client n'est pas fiable. </li><li>  Le comportement d'une redirection d'un navigateur vers une application mobile d√©pend des param√®tres et des applications que l'utilisateur a install√©s. </li></ol><br><h4>  L'application mobile est un client public </h4><br>  Pour comprendre la racine du premier probl√®me, voyons comment OAuth 2.0 fonctionne en cas d'interaction de serveur √† serveur, puis comparons-le avec OAuth 2.0 en cas d'interaction client-serveur. <br><br>  Dans les deux cas, tout commence par le fait que le client de service s'inscrit aupr√®s du fournisseur de services et re√ßoit <code>client_id</code> et, dans certains cas, <code>client_secret</code> .  La valeur <code>client_id</code> est publique et est n√©cessaire pour identifier le service client, contrairement √† <code>client_secret</code> , dont la valeur est priv√©e.  Le processus d'enregistrement est d√©crit plus en d√©tail dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC 7591</a> . <br><br>  Le diagramme ci-dessous montre le fonctionnement d'OAuth 2.0 dans la communication de serveur √† serveur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Image prise √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  Il existe 3 √©tapes principales du protocole OAuth 2.0: <br><br><ol><li>  [√âtapes AC] Obtenez le code d'autorisation (ci-apr√®s simplement <code>code</code> ). </li><li>  [√âtapes DE] √âchangez le <code>code</code> pour <code>access_token</code> . </li><li>  Acc√©dez √† la ressource en utilisant <code>access_token</code> . </li></ol><br>  Examinons plus en d√©tail la r√©ception du code: <br><br><ol><li>  [√âtape A] Le client de service redirige l'utilisateur vers le fournisseur de services. </li><li>  [√âtape B] Le fournisseur de services demande l'autorisation √† l'utilisateur de fournir des donn√©es au service client (fl√®che B vers le haut).  L'utilisateur donne acc√®s aux donn√©es (fl√®che B √† droite). </li><li>  [√âtape C] Le fournisseur de services renvoie le <code>code</code> au navigateur de l'utilisateur, qui redirige le <code>code</code> le service client. </li></ol><br>  Voyons <code>access_token</code> obtenir <code>access_token</code> plus en d√©tail: <br><br><ol><li>  [√âtape D] Le serveur client envoie une demande d' <code>access_token</code> .  La demande comprend: <code>code</code> , <code>client_secret</code> et <code>redirect_uri</code> . </li><li>  [√âtape E] Dans le cas d'un <code>code</code> valide, <code>client_secret</code> et <code>redirect_uri</code> , <code>client_secret</code> fourni. </li></ol><br>  La demande d' <code>access_token</code> est effectu√©e selon le sch√©ma de serveur √† serveur, par cons√©quent, en g√©n√©ral, pour voler <code>client_secret</code> attaquant doit pirater le serveur client-serveur ou le serveur du fournisseur de services. <br><br>  Voyons maintenant √† quoi ressemble le sch√©ma OAuth 2.0 sur un appareil mobile sans backend (interaction client-serveur). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Image prise √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  Le sch√©ma g√©n√©ral est divis√© en 3 m√™mes √©tapes principales: <br><br><ol><li>  [√©tapes 1 √† 4 de l'image] Obtenez le <code>code</code> . </li><li>  [√©tapes 5-6 dans l'image] <code>code</code> √©change pour <code>access_token</code> . </li><li>  Acc√©dez √† la ressource en utilisant <code>access_token</code> . </li></ol><br>  Cependant, dans ce cas, l'application mobile agit √©galement comme un serveur, ce qui signifie que <code>client_secret</code> sera <code>client_secret</code> √† l'int√©rieur de l'application.  Cela conduit au fait que sur les appareils mobiles, il est impossible de garder <code>lient_secret</code> d'un attaquant.  <code>client_secret</code> existe deux fa√ßons de <code>client_secret</code> dans l'application: pour filtrer le trafic de l'application vers le serveur ou effectuer une r√©tro-ing√©nierie de l'application.  Les deux m√©thodes sont faciles √† impl√©menter, donc <code>client_secret</code> inutile sur les appareils mobiles. <br><br>  Concernant le sch√©ma client-serveur, vous pourriez avoir une question: ¬´pourquoi ne pas obtenir imm√©diatement <code>access_token</code> ?¬ª.  Il semblerait, pourquoi avons-nous besoin d'une √©tape suppl√©mentaire?  De plus, il existe un sch√©ma de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">subvention implicite</a> dans lequel le client re√ßoit imm√©diatement un <code>access_token</code> .  Bien qu'il puisse √™tre utilis√© dans certains cas, nous verrons ci-dessous que la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">subvention implicite</a> ne convient pas pour OAuth 2.0 mobile s√©curis√©. <br><br><h4>  Rediriger sur les appareils mobiles </h4><br>  En g√©n√©ral, pour une redirection d'un navigateur vers une application sur des appareils mobiles, les m√©canismes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sch√©ma URI personnalis√©</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppLink</a> sont utilis√©s.  Aucun de ces m√©canismes dans sa forme pure n'est aussi fiable qu'une redirection de navigateur. <br><br>  Le sch√©ma d'URI personnalis√© (ou lien profond) est utilis√© comme suit: le d√©veloppeur d√©finit le sch√©ma d'application avant l'assemblage.  Le sch√©ma peut √™tre arbitraire, tandis que sur le m√™me appareil, plusieurs applications avec le m√™me sch√©ma peuvent √™tre install√©es.  Tout est assez simple lorsque chaque application sur l'appareil correspond √† une application.  Mais que se passe-t-il si deux applications enregistrent le m√™me circuit sur le m√™me appareil?  Comment le syst√®me d'exploitation peut-il d√©terminer laquelle des deux applications ouvrir lors de l'acc√®s au sch√©ma d'URI personnalis√©?  Android affichera une fen√™tre avec le choix de l'application dans laquelle vous souhaitez ouvrir un lien.  Dans iOS, le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comportement n'est pas d√©fini</a> , ce qui signifie que l'une des deux applications peut √™tre ouverte.  Dans les deux cas, un attaquant <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">peut intercepter du code ou access_token</a> . <br><br>  AppLink, contrairement au sch√©ma d'URI personnalis√©, garantit l'ouverture de la bonne application, mais ce m√©canisme pr√©sente plusieurs inconv√©nients: <br><br><ol><li>  Chaque client de service doit passer ind√©pendamment <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la proc√©dure de v√©rification</a> . </li><li>  Les utilisateurs d'Android peuvent d√©sactiver AppLink pour une application sp√©cifique dans les param√®tres. </li><li>  Android sous 6.0 et iOS sous 9.0 ne prennent pas en charge AppLink. </li></ol><br>  Les inconv√©nients ci-dessus d'AppLink, d'une part, augmentent le seuil d'entr√©e pour les services clients potentiels, et d'autre part, peuvent conduire au fait que dans certaines circonstances, l'utilisateur ne fonctionnera pas OAuth 2.0.  Cela rend AppLink inadapt√© au remplacement des redirections de navigateur dans le protocole OAuth 2.0. <br><br><h1>  D'accord, quoi attaquer? </h1><br>  Les probl√®mes du mobile OAuth 2.0 ont √©galement donn√© lieu √† des attaques sp√©cifiques.  Voyons ce qu'ils sont et comment ils fonctionnent. <br><br><a name="1"></a><h4>  Attaque d'interception de code d'autorisation </h4><br>  Donn√©es initiales: une application l√©gitime (client OAuth 2.0) et une application malveillante ayant enregistr√© le m√™me sch√©ma que celui l√©gitime sont install√©es sur l'appareil de l'utilisateur.  La figure ci-dessous montre le sch√©ma d'attaque. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Image prise √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  Voici le probl√®me: √† l'√©tape 4, le navigateur renvoie le <code>code</code> √† l'application via le sch√©ma d'URI personnalis√©, afin que le <code>code</code> puisse √™tre intercept√© par le malware (car il a enregistr√© le m√™me sch√©ma que l'application l√©gitime).  Apr√®s cela, le malware modifie le <code>code</code> en <code>access_token</code> et acc√®de aux donn√©es utilisateur. <br><br>  Comment se prot√©ger?  Dans certains cas, des m√©canismes de communication interprocessus peuvent √™tre utilis√©s, nous en parlerons ci-dessous.  Dans le cas g√©n√©ral, vous devez appliquer un sch√©ma appel√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cl√© de preuve pour l'√©change de code</a> .  Son essence se refl√®te dans le sch√©ma ci-dessous. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Image prise √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  Dans les requ√™tes du client, il existe plusieurs param√®tres suppl√©mentaires: <code>code_verifier</code> , <code>code_challenge</code> (sur le <code>t(code_verifier)</code> ) et <code>code_challenge_method</code> (sur le diagramme <code>t_m</code> ). <br><br>  <code>Code_verifier</code> est un nombre al√©atoire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'au moins 256 bits</a> qui n'est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">utilis√© qu'une seule fois</a> .  Autrement dit, pour <b>chaque</b> demande de <code>code</code> client doit g√©n√©rer un nouveau <code>code_verifier</code> . <br><br>  <code>Code_challenge_method</code> est le nom d'une fonction de conversion, le plus souvent SHA-256. <br><br>  <code>Code_challenge</code> est un <code>code_verifier</code> auquel la conversion <code>code_challenge_method</code> a √©t√© <code>code_challenge_method</code> et encod√©e dans l'URL Safe Base64. <br><br>  La conversion de <code>code_verifier</code> en <code>code_challenge</code> n√©cessaire pour se prot√©ger contre les vecteurs d'attaque bas√©s sur l'interception de <code>code_verifier</code> (par exemple, √† partir des journaux syst√®me de l'appareil) lors de la demande de <code>code</code> . <br><br>  Si l'appareil de l'utilisateur <b>ne prend pas en charge</b> SHA-256, une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©trogradation est autoris√©e jusqu'√† ce que la conversion code_verifier soit manquante</a> .  Dans tous les autres cas, vous devez utiliser SHA-256. <br><br>  Le sch√©ma fonctionne comme suit: <br><br><ol><li>  Le client g√©n√®re un <code>code_verifier</code> et s'en souvient. </li><li>  Le client s√©lectionne <code>code_challenge_method</code> et obtient <code>code_challenge</code> de <code>code_verifier</code> . </li><li>  [√âtape A] Le client demande du <code>code</code> , avec <code>code_challenge</code> et <code>code_challenge_method</code> ajout√©s √† la demande. </li><li>  [√âtape B] Le fournisseur se souvient du <code>code_challenge</code> et du <code>code_challenge_method</code> sur le serveur et renvoie le <code>code</code> client. </li><li>  [√âtape C] Le client demande <code>access_token</code> , avec <code>access_token</code> √©tant ajout√© √† la <code>code_verifier</code> . </li><li>  Le fournisseur re√ßoit le <code>code_challenge</code> du <code>code_challenge</code> entrant, puis le <code>code_challenge</code> au <code>code_challenge</code> dont il s'est souvenu. </li><li>  [√âtape D] Si les valeurs correspondent, le fournisseur √©met un <code>access_token</code> client. </li></ol><br>  Voyons pourquoi <code>code_challenge</code> permet de <code>code_challenge</code> prot√©ger contre une attaque d'interception de code.  Pour ce faire, nous allons passer par les √©tapes d'obtention de <code>access_token</code> . <br><br><ol><li>  Tout d'abord, une application l√©gitime demande du <code>code</code> ( <code>code_challenge</code> et <code>code_challenge_method</code> envoy√©s avec la <b>demande</b> ). </li><li>  Le malware intercepte le <code>code</code> (mais pas <code>code_challenge</code> , car il <b>n'y a</b> pas de <code>code_challenge</code> <b>dans la r√©ponse</b> ). </li><li>  Le malware demande <code>access_token</code> (avec un <code>code</code> valide, mais <b>sans</b> <code>code_verifier</code> valide). </li><li>  Le serveur remarque l'incompatibilit√© de <code>code_challenge</code> et renvoie une erreur. </li></ol><br>  Notez que l'attaquant n'a pas la capacit√© de deviner le <code>code_verifier</code> (256 bits al√©atoires!) Ou de le trouver quelque part dans les journaux ( <code>code_verifier</code> est transmis une fois). <br><br>  Si tout cela est r√©duit √† une phrase, alors <code>code_challenge</code> permet au fournisseur de services de r√©pondre √† la question: " <code>access_token</code> demand√© par la m√™me application cliente qui a demand√© le <code>code</code> , ou par une autre?" <br><br><h4>  OAuth 2.0 CSRF </h4><br>  Sur les appareils mobiles, OAuth 2.0 est souvent utilis√© comme m√©canisme d'authentification.  Comme nous nous en souvenons, l'authentification via OAuth 2.0 diff√®re de l'autorisation en ce que les vuln√©rabilit√©s OAuth 2.0 affectent les donn√©es utilisateur du c√¥t√© du client de service et non du fournisseur de services.  Par cons√©quent, l'attaque CSRF sur OAuth 2.0 vous permet de voler le compte de quelqu'un d'autre. <br><br>  Consid√©rez une attaque CSRF contre OAuth 2.0 en utilisant l'exemple de l'application client taxi et du fournisseur provider.com.  Tout d'abord, un attaquant se connecte √† attacker@provider.com sur son appareil et re√ßoit un <code>code</code> de taxi.  Apr√®s cela, l'attaquant interrompt le processus OAuth 2.0 et g√©n√®re un lien: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Ensuite, l'agresseur envoie un lien √† la victime, par exemple, sous le couvert d'une lettre ou d'un SMS de l'administration des taxis.  La victime <code>access_token</code> lien, une application de taxi s'ouvre sur son t√©l√©phone, qui re√ßoit <code>access_token</code> , et en cons√©quence la victime se retrouve sur le compte de taxi de l' <b>attaquant</b> .  Ignorant la capture, la victime utilise ce compte: fait des voyages, saisit ses donn√©es, etc. <br><br>  D√©sormais, un attaquant peut se connecter √† tout moment au compte de taxi de la victime car il est li√© √† <code>attacker@provider.com</code> .  Attaque CSRF sur la connexion autoris√©e √† voler un compte. <br><br>  Les attaques CSRF sont g√©n√©ralement prot√©g√©es par un jeton CSRF (√©galement appel√© <code>state</code> ), et OAuth 2.0 ne fait pas exception.  Comment utiliser le jeton CSRF: <br><br><ol><li>  L'application cliente g√©n√®re et stocke le jeton CSRF sur l'appareil mobile de l'utilisateur. </li><li>  L'application cliente inclut le jeton CSRF dans la demande de <code>code</code> . </li><li>  Le serveur renvoie le m√™me jeton CSRF dans la r√©ponse avec le code. </li><li>  L'application client compare le jeton CSRF entrant et stock√©.  Si les valeurs correspondent, le processus se poursuit. </li></ol><br>  Exigences de jeton CSRF: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nonce d'</a> au moins 256 bits de long, obtenues √† partir d'une bonne source de s√©quences pseudo-al√©atoires. <br><br>  En bref, le jeton CSRF permet √† l'application cliente de r√©pondre √† la question: "est-ce que je commen√ßais √† obtenir <code>access_token</code> , ou est-ce que quelqu'un essaie de me <code>access_token</code> ?" <br><br><h4>  Malware se faisant passer pour un client l√©gitime </h4><br>  Certains logiciels malveillants peuvent imiter des applications l√©gitimes et afficher un √©cran de consentement en leur nom (l'√©cran de consentement est un √©cran sur lequel l'utilisateur voit: ¬´J'accepte d'accorder l'acc√®s √† ...¬ª).  Un utilisateur inattentif peut cliquer sur ¬´autoriser¬ª et, par cons√©quent, le logiciel malveillant acc√®de aux donn√©es de l'utilisateur. <br><br>  Android et iOS fournissent des m√©canismes de v√©rification mutuelle des applications.  L'application fournisseur peut v√©rifier la l√©gitimit√© de l'application cliente et vice versa. <br><br>  Malheureusement, si le m√©canisme OAuth 2.0 utilise un flux via un navigateur, vous ne pouvez pas vous d√©fendre contre cette attaque. <br><br><h4>  Autres attaques </h4><br>  Nous avons examin√© les attaques sp√©cifiques au mobile OAuth 2.0.  Cependant, n'oubliez pas les attaques sur OAuth 2.0 normal: usurpation d'identit√© <code>redirect_uri</code> , interception du trafic sur une connexion non s√©curis√©e, etc.  Vous pouvez en savoir plus √† leur sujet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br><h1>  Que faire? </h1><br>  Nous avons appris le fonctionnement du protocole OAuth 2.0 et d√©termin√© quelles vuln√©rabilit√©s existent dans les impl√©mentations de ce protocole sur les appareils mobiles.  Maintenant, assemblons un sch√©ma OAuth 2.0 mobile s√©curis√© √† partir de pi√®ces individuelles. <br><br><h4>  Bon, mauvais OAuth 2.0 </h4><br>  Commen√ßons par savoir comment lever correctement l'√©cran de consentement.  Sur les appareils mobiles, il existe deux fa√ßons d'ouvrir une page Web √† partir d'une application native (exemples d'applications natives: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  La premi√®re m√©thode est appel√©e l'onglet personnalis√© du navigateur (dans l'image de gauche).  <b>Remarque</b> : l'onglet personnalis√© du navigateur sur Android est appel√© onglet personnalis√© Chrome et sur iOS SafariViewController.  En fait, il s'agit d'un onglet de navigateur normal, qui s'affiche directement dans l'application, c'est-√†-dire  Il n'y a pas de commutation visuelle entre les applications. <br><br>  La deuxi√®me m√©thode est appel√©e ¬´augmenter WebView¬ª (dans l'image de droite), par rapport au mobile OAuth 2.0, je la consid√®re comme mauvaise. <br><br>  WebView est un navigateur autonome pour une application native. <br><br>  <i>Un</i> ¬´ <i>navigateur</i> autonome¬ª signifie que WebView ne permet pas d'acc√©der aux cookies, au stockage, au cache, √† l'historique et aux autres donn√©es des navigateurs Safari et Chrome.  L'inverse est √©galement vrai: Safari et Chrome ne peuvent pas acc√©der aux donn√©es WebView. <br><br>  ¬´ <i>Navigateur pour une application native</i> ¬ª signifie que l'application native qui a g√©n√©r√© WebView a <b>un</b> acc√®s <b>complet</b> aux cookies, stockage, cache, historique et autres donn√©es WebView. <br><br>  Imaginez maintenant: l'utilisateur appuie sur le bouton "se connecter en utilisant ..." et le WebView de l'application malveillante demande son nom d'utilisateur et son mot de passe au fournisseur de services. <br><br>  √âchec √† la fois sur tous les fronts: <br><br><ol><li>  L'utilisateur entre le nom d'utilisateur et le mot de passe √† partir du compte du fournisseur de services dans l'application, qui peut facilement voler ces donn√©es. </li><li>  OAuth 2.0 a √©t√© initialement d√©velopp√© pour <i>ne pas saisir de nom d'utilisateur et de mot</i> de <i>passe</i> d'un fournisseur de services. </li><li>  L'utilisateur s'habitue √† entrer le login et le mot de passe n'importe o√π, la probabilit√© de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">phishing</a> augmente. <br></li></ol><br>  √âtant donn√© que tous les arguments sont contre WebView, la conclusion se sugg√®re: soulevez l'onglet personnalis√© du navigateur pour l'√©cran de consentement. <br><br>  Si l'un d'entre vous a des arguments en faveur de WebView au lieu de l'onglet personnalis√© du navigateur, √©crivez-le dans les commentaires, je vous en serai tr√®s reconnaissant. <br><br><h4>  Sch√©ma Secure Mobile OAuth 2.0 </h4><br>  Nous utiliserons le sch√©ma d'autorisation de code d'autorisation car il nous permet d'ajouter un <code>code_challenge</code> et de <code>code_challenge</code> prot√©ger contre une attaque d'interception de code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Image prise √† partir de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  La demande de code (√©tapes 1-2) ressemblera √† ceci: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  √Ä l'√©tape 3, le navigateur re√ßoit une r√©ponse redirig√©e: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  √Ä l'√©tape 4, le navigateur ouvre le sch√©ma d'URI personnalis√© et transmet le <code>code</code> et le jeton CSRF √† l'application cliente. <br><br>  Demande d' <code>access_token</code> (√©tape 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  La derni√®re √©tape renvoie une r√©ponse avec <code>access_token</code> . <br><br>  En g√©n√©ral, le sch√©ma ci-dessus est s√ªr, mais il existe √©galement des cas particuliers dans lesquels OAuth 2.0 peut √™tre rendu plus simple et un peu plus s√ªr. <br><br><h4>  IPC Android </h4><br>  Android dispose d'un m√©canisme d'√©change de donn√©es bidirectionnel entre les processus: IPC (communication inter-processus).  IPC est pr√©f√©r√© au sch√©ma d'URI personnalis√© pour deux raisons: <br><br><ol><li>  Une application qui ouvre un canal IPC peut v√©rifier l'authenticit√© d'une application ouverte par son certificat.  L'inverse est √©galement vrai: une application ouverte peut v√©rifier l'authenticit√© de l'application qui l'a ouverte. </li><li>  En envoyant une demande via un canal IPC, l'exp√©diteur peut recevoir une r√©ponse via le m√™me canal.  Avec la v√©rification mutuelle (√©l√©ment 1), cela signifie qu'aucun processus tiers ne peut intercepter <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Ainsi, nous pouvons utiliser la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">subvention implicite</a> et simplifier consid√©rablement le sch√©ma OAuth 2.0 mobile.  Aucun <code>code_challenge</code> et jetons CSRF.  De plus, nous serons en mesure de nous prot√©ger contre les logiciels malveillants qui imitent les clients l√©gitimes afin de voler des comptes d'utilisateurs. <br><br><h4>  SDK client </h4><br>  En plus d'impl√©menter le sch√©ma OAuth 2.0 mobile s√©curis√© d√©crit ci-dessus, le fournisseur doit d√©velopper un SDK pour ses clients.  Cela facilitera la mise en ≈ìuvre d'OAuth 2.0 c√¥t√© client et r√©duira en m√™me temps le nombre d'erreurs et de vuln√©rabilit√©s. <br><br><h1>  Tirer des conclusions </h1><br>  Pour les fournisseurs OAuth 2.0, j'ai compil√© la ¬´Liste de contr√¥le Secure Mobile OAuth 2.0¬ª: <br><br><ol><li>  Une base solide est vitale.  Dans le cas d'OAuth 2.0 mobile, la base est le sch√©ma ou le protocole que nous choisissons de mettre en ≈ìuvre.  Lorsque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous impl√©mentez votre propre sch√©ma OAuth 2.0,</a> il est facile de faire une erreur.  D'autres ont d√©j√† rempli les bosses et tir√© des conclusions, il n'y a rien de mal √† apprendre de leurs erreurs et √† faire imm√©diatement une mise en ≈ìuvre s√ªre.  En g√©n√©ral, le sch√©ma OAuth 2.0 mobile le plus s√©curis√© est celui de la section Que faire? </li><li>  <code>Access_token</code> et d'autres donn√©es sensibles: sous iOS - dans le trousseau, sous Android - dans le stockage interne.  Ces r√©f√©rentiels sont sp√©cifiquement con√ßus √† ces fins.  Si n√©cessaire, vous pouvez utiliser le fournisseur de contenu dans Android, mais il doit √™tre configur√© en toute s√©curit√©. </li><li>  <code>Code</code> doit √™tre unique, avec une courte dur√©e de vie. </li><li>  Pour vous prot√©ger contre l'interception de code, utilisez <code>code_challenge</code> . </li><li>  Pour vous prot√©ger contre une attaque CSRF sur la connexion, utilisez des jetons CSRF. </li><li>  N'utilisez pas WebView pour l'√©cran de consentement, utilisez l'onglet personnalis√© du navigateur. </li><li>  <code>Client_secret</code> <b>inutile</b> s'il n'est pas stock√© sur le backend.  Ne le donnez pas aux clients publics. </li><li>  Utilisez HTTPS <b>partout</b> , avec l'interdiction de r√©trograder vers HTTP. </li><li>  Suivez les recommandations de cryptographie (s√©lection de chiffre, longueur de jeton, etc.) <b>des normes</b> .  Vous pouvez copier les donn√©es et d√©couvrir pourquoi cela a √©t√© fait de cette fa√ßon, mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous ne pouvez pas faire votre cryptographie</a> . </li><li>  Dans l'application client, v√©rifiez qui vous ouvrez pour OAuth 2.0 et dans l'application fournisseur, v√©rifiez qui vous ouvre pour OAuth 2.0. </li><li>  Soyez conscient des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vuln√©rabilit√©s habituelles d'OAuth 2.0</a> .  Mobile OAuth 2.0 √©tend et compl√®te la version standard, donc personne n'a annul√© la v√©rification de <code>redirect_uri</code> pour les correspondances exactes et autres recommandations pour OAuth 2.0 standard. </li><li>  Assurez-vous de fournir des SDK aux clients.  Le client aura moins de bogues et de vuln√©rabilit√©s dans le code, et il lui sera plus facile d'impl√©menter votre OAuth 2.0. </li></ol><br><h1>  Que lire </h1><br><ol><li>  [RFC] OAuth 2.0 pour les applications natives <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 pour applications mobiles et de bureau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Cl√© de preuve pour l'√©change de code par les clients publics OAuth <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7636</a> </li><li>  Condition de course OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://hackerone.com/reports/55140</a> </li><li>  [RFC] Mod√®le de menace OAuth 2.0 et consid√©rations de s√©curit√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc6819</a> </li><li>  Attaques sur OAuth 2.0 r√©gulier <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://sakurity.com/oauth</a> </li><li>  [RFC] Protocole d'enregistrement de client dynamique OAuth 2.0 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Remerciements </h1><br>  Merci √† tous ceux qui ont contribu√© √† la r√©daction de cet article, en particulier Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">@isciurus</a> ) et Daria Yakovleva. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417031/">https://habr.com/ru/post/fr417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417015/index.html">Nous comprenons ce qui enregistre et ce qui n'enregistre pas l'application Burger King</a></li>
<li><a href="../fr417017/index.html">Comment une exp√©rience nucl√©aire rat√©e a g√©n√©r√© accidentellement l'astronomie des neutrinos</a></li>
<li><a href="../fr417023/index.html">Exp√©rience du Groupe Rambler: comment nous avons commenc√© √† contr√¥ler compl√®tement la formation et le comportement des composants frontaux React</a></li>
<li><a href="../fr417027/index.html">Comment ai-je √©crit la biblioth√®que C ++ 11 standard ou pourquoi boost est si effrayant. Pr√©sentation</a></li>
<li><a href="../fr417029/index.html">Profilage de code avec LLVM</a></li>
<li><a href="../fr417033/index.html">QIWI Kitchen le 7 juin - vid√©o des discours de nos intervenants</a></li>
<li><a href="../fr417035/index.html">UnnyWorld: post-mortem</a></li>
<li><a href="../fr417037/index.html">BEERBRAZZERS. Contr√¥le de la lumi√®re. Vixen Lights 3. D√©marrage rapide (1/4)</a></li>
<li><a href="../fr417039/index.html">Apprenez wordpress (et plus) pour rendre les joueurs Youtube rapidement</a></li>
<li><a href="../fr417041/index.html">eslint-scope v3.7.2 vole des jetons NPM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>