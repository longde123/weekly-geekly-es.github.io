<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïñ üôåüèª üë®‚Äç‚öñÔ∏è Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 7: Sandbox do Cliente Nativo Parte 2 üéöÔ∏è üßëüèæ‚Äçü§ù‚Äçüßëüèª ü§≥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula n¬∫ 6.858. "Seguran√ßa de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 7: Sandbox do Cliente Nativo Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418225/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula n¬∫ 6.858.  "Seguran√ßa de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security √© um curso sobre o desenvolvimento e implementa√ß√£o de sistemas de computador seguros.  As palestras abrangem modelos de amea√ßas, ataques que comprometem a seguran√ßa e t√©cnicas de seguran√ßa baseadas em trabalhos cient√≠ficos recentes.  Os t√≥picos incluem seguran√ßa do sistema operacional (SO), recursos, gerenciamento de fluxo de informa√ß√µes, seguran√ßa de idiomas, protocolos de rede, seguran√ßa de hardware e seguran√ßa de aplicativos da web. <br><br>  Palestra 1: ‚ÄúIntrodu√ß√£o: modelos de amea√ßas‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: ‚ÄúControle de ataques de hackers‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: ‚ÄúEstouros de Buffer: Explora√ß√µes e Prote√ß√£o‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: ‚ÄúSepara√ß√£o de Privil√©gios‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: ‚ÄúDe onde v√™m os sistemas de seguran√ßa?‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: ‚ÄúOportunidades‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: ‚ÄúSandbox do Cliente Nativo‚Äù <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  <b>P√∫blico:</b> por que o intervalo de capacidade da mem√≥ria do intervalo de endere√ßos deve come√ßar do zero? <br><br>  <b>Professor:</b> porque em termos de desempenho, √© mais eficiente usar o salto de destino se voc√™ souber que um endere√ßo v√°lido √© um conjunto cont√≠nuo de endere√ßos come√ßando do zero.  Porque ent√£o voc√™ pode fazer isso com uma √∫nica m√°scara <b>AND</b> , onde todos os bits altos s√£o um e apenas um par de bits baixos √© zero. <br><br>  <b>P√∫blico:</b> Eu pensei que a m√°scara <b>AND</b> deveria fornecer alinhamento. <br><br>  <b>Professor:</b> certo, a m√°scara fornece alinhamento, mas por que come√ßa do zero?  Eu acho que eles confiam no <b>hardware</b> segmentado por hardware de segmenta√ß√£o.  Ent√£o, basicamente, eles poderiam us√°-lo para mover a √°rea para cima, em termos de espa√ßo linear.  Ou talvez esteja relacionado apenas ao modo como o aplicativo "v√™" esse intervalo.  De fato, voc√™ pode coloc√°-lo com diferentes compensa√ß√µes no seu espa√ßo de endere√ßo virtual.  Isso permitir√° que voc√™ execute certos truques com hardware segmentado para executar v√°rios m√≥dulos no mesmo espa√ßo de endere√ßo. <br><br><img src="https://habrastorage.org/webt/_r/ef/sc/_refscc89wngsofm0ajoa0eflym.jpeg"><br><br>  <b>P√∫blico:</b> Talvez seja porque eles querem "capturar" o ponto de recebimento do ponteiro nulo? <br><br>  <b>Professor:</b> sim, porque eles querem pegar todos os pontos de recep√ß√£o.  Mas voc√™ tem uma maneira de fazer isso.  Porque o ponteiro nulo se refere ao segmento que est√° sendo acessado.  E se voc√™ mover o segmento, poder√° exibir uma p√°gina zero n√£o utilizada no in√≠cio de cada segmento.  Portanto, isso ajudar√° a criar alguns m√≥dulos. <br><br>  Eu acho que uma das raz√µes para essa decis√£o - iniciar o intervalo de 0 - se deve ao desejo de portar seu programa para a plataforma <b>x64</b> , que tem um design um pouco diferente.  Mas o artigo deles n√£o diz isso.  No design de 64 bits, o pr√≥prio equipamento se livrou de algum hardware de segmenta√ß√£o, no qual eles contavam por raz√µes de efici√™ncia, ent√£o eles tiveram que fornecer uma abordagem orientada a software.  No entanto, para <b>x32,</b> esse ainda n√£o √© um bom motivo para o espa√ßo come√ßar do zero. <br><br>  Portanto, continuamos a quest√£o principal - o que queremos garantir do ponto de vista da seguran√ßa.  Vamos abordar esse assunto de forma um tanto "ing√™nua" e ver como podemos arruinar tudo e depois tentar consert√°-lo. <br><br>  Acredito que um plano ing√™nuo √© procurar instru√ß√µes proibidas simplesmente digitalizando o execut√°vel do come√ßo ao fim.  Ent√£o, como voc√™ pode identificar essas instru√ß√µes?  Voc√™ pode simplesmente pegar o c√≥digo do programa e coloc√°-lo em uma linha gigante que varia de zero a 256 megabytes, dependendo do tamanho do seu c√≥digo, e ent√£o iniciar a busca. <br><br><img src="https://habrastorage.org/webt/nl/vt/rv/nlvtrvk-s3z8c_yhuugx0zqaxyc.jpeg"><br><br>  Essa linha pode primeiro conter o m√≥dulo de instru√ß√µes <b>NOP</b> , depois o m√≥dulo de instru√ß√µes <b>ADD</b> , <b>NOT</b> , <b>JUMP</b> e assim por diante.  Voc√™ apenas procura e, se encontrar uma instru√ß√£o incorreta, diga que √© um m√≥dulo inv√°lido e descarte-o.  E se voc√™ n√£o vir nenhuma chamada do sistema para esta instru√ß√£o, poder√° ativar o lan√ßamento deste m√≥dulo e fazer tudo dentro do intervalo de 0 a 256.  Voc√™ acha que isso vai funcionar ou n√£o?  Com o que eles est√£o preocupados?  Por que isso √© t√£o dif√≠cil? <br><br>  <b>P√∫blico:</b> Eles est√£o preocupados com o tamanho das instru√ß√µes? <br><br>  <b>Professor:</b> sim, o fato √© que a plataforma <b>x86</b> possui instru√ß√µes de tamanho vari√°vel.  Isso significa que o tamanho exato da instru√ß√£o depende dos primeiros bytes desta instru√ß√£o.  De fato, voc√™ pode observar o primeiro byte para dizer que a instru√ß√£o ser√° muito maior e, em seguida, talvez seja necess√°rio observar mais alguns bytes e decidir qual tamanho ser√° necess√°rio.  Algumas arquiteturas como <b>Spark</b> , <b>ARM</b> , <b>MIPS</b> t√™m instru√ß√µes de comprimento mais fixo.  <b>O ARM</b> possui dois comprimentos de instru√ß√£o - 2 ou 4 bytes.  Mas na plataforma <b>x86, o</b> comprimento das instru√ß√µes pode ser de 1, 5 e 10 bytes e, se voc√™ tentar, poder√° obter uma instru√ß√£o bastante longa de 15 bytes.  No entanto, estas s√£o instru√ß√µes complexas. <br><br>  Como resultado, um problema pode aparecer.  Se voc√™ digitalizar esta linha de c√≥digo linearmente, tudo ficar√° bem.  Mas talvez em tempo de execu√ß√£o voc√™ v√° para o meio de algum tipo de instru√ß√£o, por exemplo, <b>N√ÉO</b> . <br><br><img src="https://habrastorage.org/webt/ob/rv/lj/obrvlj58uew5ji8-9mev7cxwb04.jpeg"><br><br>  √â poss√≠vel que seja uma instru√ß√£o multibyte e, se voc√™ a interpretar a partir do segundo byte, ela parecer√° completamente diferente. <br><br>  Outro exemplo no qual vamos "brincar" com o assembler.  Suponha que tenhamos a instru√ß√£o <b>25 CD 80 00 00</b> .  Tendo examinado o segundo byte, voc√™ o interpretar√° como uma instru√ß√£o de cinco bytes, ou seja, ter√° que olhar 5 bytes para frente e ver que √© seguido pela instru√ß√£o <b>AND% EAX, CD 0x00 00 80</b> , come√ßando com o operador <b>AND</b> para o registro <b>EAX</b> com alguns constantes definidas, por exemplo, <b>00 00 80 CD</b> .  Esta √© uma das instru√ß√µes seguras que o <b>Native Client</b> deve simplesmente permitir pela primeira regra de verifica√ß√£o de instru√ß√µes bin√°rias.  Mas se, durante a execu√ß√£o do programa, a <b>CPU</b> decidir que deve come√ßar a executar o c√≥digo do <b>CD</b> , marcarei este local da instru√ß√£o com uma seta, ent√£o a instru√ß√£o <b>% EAX, 0x00 00 80 CD</b> , que na verdade √© uma instru√ß√£o de 4 bytes, significar√° a execu√ß√£o do <b>INT $ 0x80</b> , que √© uma maneira de fazer uma chamada de sistema no <b>Linux</b> . <br><br><img src="https://habrastorage.org/webt/ib/3a/zp/ib3azp3oe9zmfedweosbecx9fto.jpeg"><br><br>  Portanto, se voc√™ perder esse fato, deixe o m√≥dulo n√£o confi√°vel "pular" no kernel e fazer chamadas ao sistema, ou seja, fa√ßa o que voc√™ deseja impedir.  Como podemos evitar isso? <br><br>  Talvez dev√™ssemos tentar observar o deslocamento de cada byte.  Como o x86 pode come√ßar a interpretar apenas uma instru√ß√£o nos limites de bytes, n√£o de bits.  Portanto, voc√™ deve observar o deslocamento de cada byte para ver onde a instru√ß√£o come√ßa.  Voc√™ acha que esse √© um plano vi√°vel? <br><br>  <b>P√∫blico:</b> Eu acho que se algu√©m realmente usa <b>AND</b> , o processador n√£o salta para este local, mas simplesmente permite que o programa seja executado. <br><br>  <b>Professor:</b> sim, porque basicamente ele n√£o √© propenso a falsos positivos.  Agora, se voc√™ realmente quiser, pode alterar um pouco o c√≥digo para evit√°-lo.  Se voc√™ souber exatamente o que o dispositivo de teste est√° procurando, poder√° alterar essas instru√ß√µes.  Talvez configurando <b>AND</b> primeiro para uma instru√ß√£o e depois use a m√°scara em outra.  Mas √© muito mais f√°cil evitar esses arranjos de bytes suspeitos, embora isso pare√ßa bastante inconveniente. <br><br>  √â poss√≠vel que a arquitetura inclua uma altera√ß√£o no compilador.  Basicamente, eles t√™m algum tipo de componente que realmente precisa compilar o c√≥digo corretamente.  Voc√™ n√£o pode simplesmente "decolar" o <b>GCC</b> e compilar o c√≥digo para o <b>Native Client</b> .  Ent√£o, basicamente, isso √© fact√≠vel.  Mas, provavelmente, eles acham que isso causa muitos problemas, n√£o ser√° uma solu√ß√£o confi√°vel ou de alto desempenho e assim por diante.  Al√©m disso, existem v√°rias instru√ß√µes <b>x86</b> que s√£o proibidas ou devem ser consideradas inseguras e, portanto, devem ser proibidas.  Mas, na maioria das vezes, eles t√™m um byte de tamanho, por isso √© muito dif√≠cil encontr√°-los ou filtr√°-los. <br><br>  Portanto, se eles n√£o podem simplesmente coletar e classificar instru√ß√µes inseguras e esperar o melhor, precisam usar um plano diferente para desmont√°-lo de maneira confi√°vel.  Ent√£o, o que o <b>Native Client faz</b> para garantir que n√£o "trope√ßa" nessa codifica√ß√£o de tamanho vari√°vel? <br><br>  De certa forma, se realmente varrermos o arquivo execut√°vel da esquerda para a direita e procurarmos todos os c√≥digos incorretos poss√≠veis, e se for assim que o c√≥digo for executado, estaremos em boa forma.  Mesmo que haja algumas instru√ß√µes estranhas e algum vi√©s, o processador ainda n√£o vai ‚Äúpular‚Äù para l√°, ele executar√° o programa na mesma ordem em que as instru√ß√µes s√£o digitalizadas, ou seja, da esquerda para a direita. <br><br><img src="https://habrastorage.org/webt/kh/v0/ea/khv0ea7apzgmwqnx1pbaj8k1fgy.jpeg"><br><br>  Assim, o problema com a desmontagem confi√°vel surge devido ao fato de que em algum lugar da aplica√ß√£o pode haver "saltos".  O processador pode falhar se der um ‚Äúsalto‚Äù para alguma instru√ß√£o de c√≥digo que n√£o percebeu ao digitalizar da esquerda para a direita.  Portanto, este √© um problema de desmontagem confi√°vel at√© agora em desenvolvimento.  E o plano principal √© verificar para onde todos os "saltos" levam.  De fato, √© bastante simples em algum n√≠vel.  Existem v√°rias regras que consideraremos em um segundo, mas o plano aproximado √© que, se voc√™ vir uma instru√ß√£o de "salto", precisar√° garantir que o objetivo do "salto" tenha sido observado anteriormente.  Para fazer isso, de fato, basta escanear da esquerda para a direita, ou seja, o procedimento que descrevemos em nossa abordagem ing√™nua do problema. <br><br>  Nesse caso, se voc√™ vir alguma instru√ß√£o de ‚Äúsalto‚Äù e o endere√ßo para o qual esta instru√ß√£o aponta, verifique se esse √© o mesmo endere√ßo que voc√™ j√° viu durante a desmontagem da esquerda para a direita. <br><br>  Se uma instru√ß√£o de salto para este byte de CD for encontrada, devemos marc√°-lo como inv√°lido, porque nunca vimos a instru√ß√£o iniciando no byte de CD, mas vimos outra instru√ß√£o come√ßando com o n√∫mero 25. Mas se todas as instru√ß√µes de salto ordenado a ir para o in√≠cio da instru√ß√£o, neste caso para 25, ent√£o estamos bem.  Isso est√° claro? <br><br>  O √∫nico problema √© que voc√™ n√£o pode verificar os objetivos de cada salto no programa, pois pode haver saltos indiretos.  Por exemplo, em <b>x86,</b> voc√™ pode ter algo como um salto no valor desse registro <b>EAX</b> .  Isso √© √≥timo para implementar ponteiros de fun√ß√£o. <br><br><img src="https://habrastorage.org/webt/uf/gh/bl/ufghbl_dd-pofxnrp7fy-ne3ee0.jpeg"><br><br>  Ou seja, o ponteiro de fun√ß√£o est√° em algum lugar da mem√≥ria, voc√™ o mant√©m em algum registro e depois vai para qualquer endere√ßo no registro de movimento. <br><br>  Ent√£o, como esses caras lidam com saltos indiretos?  Porque, de fato, n√£o tenho id√©ia se isso ser√° um ‚Äúsalto‚Äù para o byte <b>CD</b> ou o byte 25. O que eles fazem nesse caso? <br><br>  <b>P√∫blico:</b> usando ferramentas? <br><br>  <b>Professor:</b> sim, a instrumenta√ß√£o √© o principal truque.  Portanto, sempre que virem que o compilador est√° pronto para executar a gera√ß√£o, isso prova que esse salto n√£o causar√° problemas.  Para fazer isso, eles precisam garantir que todos os saltos sejam executados com uma multiplicidade de 32 bytes.  Como eles fazem isso?  Eles mudam todas as instru√ß√µes de salto para o que chamam de "pseudo instru√ß√µes".  Estas s√£o as mesmas instru√ß√µes, mas prefixadas, que limpam os 5 bits baixos no registro <b>EAX</b> .  O fato de a instru√ß√£o limpar 5 bits baixos significa que faz com que o valor fornecido seja um m√∫ltiplo de 32, de dois a cinco, e ent√£o um salto para esse valor j√° √© realizado. <br><br><img src="https://habrastorage.org/webt/r3/sf/nq/r3sfnqlxz3egqe8q-0ret79kwzu.jpeg"><br><br>  Se voc√™ observar isso durante a verifica√ß√£o, certifique-se de que esse "par" instrucional "salte" apenas com uma multiplicidade de 32 bytes.  E ent√£o, para garantir que n√£o haja possibilidade de "pular" em algumas instru√ß√µes estranhas, voc√™ aplica uma regra adicional.  Consiste no fato de que, durante a desmontagem, quando voc√™ olha suas instru√ß√µes da esquerda para a direita, assegura que o in√≠cio de cada instru√ß√£o v√°lida tamb√©m seja um m√∫ltiplo de 32 bytes. <br><br>  Assim, al√©m deste kit de ferramentas, voc√™ verifica se cada c√≥digo m√∫ltiplo de 32 √© a instru√ß√£o correta.  Por uma instru√ß√£o v√°lida e v√°lida, quero dizer uma instru√ß√£o desmontada da esquerda para a direita. <br><br>  <b>P√∫blico:</b> Por que o n√∫mero 32 foi escolhido? <br><br>  <b>Professor:</b> sim, por que eles escolheram 32 em vez de 1000 ou 5?  Por que 5 √© ruim? <br><br>  <b>P√∫blico:</b> porque o n√∫mero deve ser uma pot√™ncia de 2. <br><br>  <b>Professor:</b> sim, bem, √© por isso.  Porque, caso contr√°rio, garantir o uso de algo m√∫ltiplo de 5 exigir√° instru√ß√µes adicionais que levem √† sobrecarga.  E oito?  O n√∫mero √© oito o suficiente? <br><br>  <b>P√∫blico-alvo:</b> voc√™ pode ter instru√ß√µes com mais de oito bits. <br><br>  <b>Professor:</b> sim, isso pode ser para a instru√ß√£o mais longa permitida na plataforma x86.  Se temos uma instru√ß√£o de 10 bytes e tudo deve ter um m√∫ltiplo de 8, n√£o podemos inseri-la em nenhum lugar.  Portanto, o comprimento deve ser suficiente para todos os casos, porque a maior instru√ß√£o que vi foi de 15 bytes.  Ent√£o 32 bytes √© suficiente. <br><br>  Se voc√™ deseja adaptar as instru√ß√µes para entrar ou sair do ambiente de servi√ßo de processo, pode precisar de uma quantidade n√£o trivial de c√≥digo em um slot de 32 bytes.  Por exemplo, 31 bytes, porque 1 byte cont√©m uma instru√ß√£o.  Deveria ser muito maior?  Devemos fazer isso igual a, digamos, 1024 bytes?  Se voc√™ tiver muitos ponteiros de fun√ß√£o ou muitos saltos indiretos, toda vez que quiser criar um local para pular, dever√° continuar na pr√≥xima borda, independentemente do seu valor.  Portanto, com 32 bits, √© um tamanho bastante normal.  Na pior das hip√≥teses, voc√™ perder√° apenas 31 bytes se precisar chegar rapidamente √† pr√≥xima borda.  Mas se voc√™ tem um tamanho m√∫ltiplo de 1024 bytes, existe a possibilidade de desperdi√ßar um kilobyte inteiro de mem√≥ria em v√£o para um salto indireto.  Se voc√™ tiver fun√ß√µes curtas ou muitos ponteiros de fun√ß√£o, um tamanho t√£o grande da multiplicidade do comprimento do "salto" causar√° um desperd√≠cio significativo de mem√≥ria. <br><br>  Eu n√£o acho que o n√∫mero 32 seja uma pedra de trope√ßo para o <b>Native Client</b> .  Alguns blocos podem funcionar com uma multiplicidade de 16 bits, alguns de 64 ou 128 bits, isso n√£o importa.  Apenas 32 bits pareciam o valor ideal mais aceit√°vel. <br><br>  Ent√£o, vamos fazer um plano para uma desmontagem confi√°vel.  Como resultado, o compilador deve ter um pouco de cuidado ao compilar o <b>c√≥digo</b> <b>C</b> ou <b>C ++</b> em um bin√°rio do <b>Native Client</b> e observar as seguintes regras. <br><br><img src="https://habrastorage.org/webt/c0/nh/kc/c0nhkc4izpqqyrj_rtr2gg-eytu.jpeg"><br><br>  Portanto, sempre que ele pular, como mostrado na linha superior, ele deve adicionar essas instru√ß√µes adicionais fornecidas nas 2 linhas inferiores.  E, independentemente do fato de ele criar uma fun√ß√£o para a qual ele "saltar√°", nossa instru√ß√£o saltar√° como a adi√ß√£o <b>AND $ 0xffffffe0,% eax</b> indica.  E n√£o pode apenas complement√°-lo com zeros, porque tudo isso deve ter os c√≥digos corretos.  Portanto, a adi√ß√£o √© necess√°ria para garantir que todas as instru√ß√µes poss√≠veis sejam v√°lidas.  E, felizmente, na plataforma <b>x86</b> , nem uma √∫nica fun√ß√£o <b>noop</b> √© descrita por um √∫nico byte, ou pelo menos n√£o h√° um √∫nico <b>noop com</b> 1 byte de tamanho.  Assim, voc√™ sempre pode adicionar coisas ao valor de uma constante. <br><br>  Ent√£o, o que isso nos garante?  Vamos garantir que sempre vejamos o que acontece na terminologia das instru√ß√µes que ser√£o seguidas.  Aqui est√° o que essa regra nos fornece - a garantia de que uma chamada do sistema n√£o ser√° feita por acidente.  Isso se aplica aos saltos, mas e os retornos?  Como eles lidam com retornos?  Podemos <b>retornar</b> a uma fun√ß√£o no <b>Native Client</b> ?  O que acontece se voc√™ executar o c√≥digo em brasa? <br><br>  <b>P√∫blico:</b> Pode estourar a pilha. <br><br>  <b>Professor:</b> √© verdade que aparece inesperadamente na pilha.  Mas o fato √© que a pilha usada pelos m√≥dulos do <b>Native Client</b> realmente cont√©m alguns dados.  Portanto, ao lidar com o <b>Native Client,</b> voc√™ n√£o deve se preocupar com o estouro de pilha. <br><br>  <b>P√∫blico:</b> espere, mas voc√™ pode colocar qualquer coisa na pilha.  E quando voc√™ d√° um salto indireto. <br><br>  <b>Professor:</b> √© verdade.  O retorno parece quase um salto indireto de algum lugar da mem√≥ria, localizado no topo da pilha.  Portanto, acho que uma coisa que eles poderiam fazer para a fun√ß√£o de <b>retorno</b> √© definir o prefixo da mesma maneira que na verifica√ß√£o anterior.  E esse prefixo verifica o que aparece no topo da pilha.  Voc√™ verifica se isso √© v√°lido e, ao escrever ou usar o operador <b>AND</b> , verifica o que est√° no topo da pilha.  Isso parece um pouco confi√°vel devido √† constante mudan√ßa de dados.  Como, por exemplo, se voc√™ olhar para o topo da pilha e verificar se est√° tudo bem, e depois escrever alguma coisa, o fluxo de dados no mesmo m√≥dulo poder√° modificar algo no topo da pilha, ap√≥s o qual voc√™ se referir√° ao errado endere√ßo <br><br>  <b>P√∫blico:</b> Isso n√£o se aplica ao salto na mesma extens√£o? <br><br>  <b>Professor:</b> sim, ent√£o o que acontece l√° com um salto?  Nossas condi√ß√µes de corrida podem de alguma forma invalidar este teste? <br><br>  <b>P√∫blico:</b> Mas o c√≥digo n√£o √© grav√°vel? <br><br>  <b>Professor:</b> sim, o c√≥digo n√£o pode ser escrito, isso √© verdade.  Portanto, voc√™ n√£o pode modificar AND.  Mas n√£o poderia outro fluxo alterar o objetivo do salto entre essas duas instru√ß√µes? <br><br>  <b>P√∫blico:</b> isso est√° no registro, ent√£o ... <br><br>  <b>Professor:</b> Sim, isso √© uma coisa legal.  Como se um fluxo modificar algo na mem√≥ria ou no <b>conte√∫do</b> carregado do <b>EAX</b> (por si s√≥, voc√™ o faz antes do download), nesse caso, o <b>EAX</b> estar√° em um estado ruim, mas eliminar√° os bits ruins.  Ou ele pode alterar a mem√≥ria depois, quando o ponteiro j√° estiver no <b>EAX</b> , portanto, n√£o importa que ele altere o local da mem√≥ria da qual o registro <b>EAX</b> foi carregado. <br><br>  De fato, os threads n√£o compartilham conjuntos de registros.  Portanto, se outro segmento alterar o registro <b>EAX</b> , isso n√£o afetar√° o registro <b>EAX</b> desse segmento.  Portanto, outros segmentos n√£o podem invalidar esta sequ√™ncia de instru√ß√µes. <br><br>  H√° outra quest√£o interessante.  Podemos contornar isso <b>E</b> ?  Eu posso pular para onde quiser em qualquer lugar deste espa√ßo de endere√ßo.      ,       <b>AND</b>  . <br><br><img src="https://habrastorage.org/webt/4p/vf/nk/4pvfnkoa0kmui9vdd5wn2o-jbk0.jpeg"><br><br>       ,      ,   ,    ,  ,        <b>AND</b> .    .     <b>jmp</b> ,      . <br><br><img src="https://habrastorage.org/webt/kg/mf/cu/kgmfcuyc42v0rtkdtzt1ptm1ty4.jpeg"><br><br> ,      ,    -  ,    1237.     ,     32.  <b>Native Client</b>       ,     ,      ,     .          ,   ,      1237      ? <br><br><img src="https://habrastorage.org/webt/dn/_-/_r/dn_-_r-vi7p_qx7nxwwkqmroh-w.jpeg"><br><br>    -  <b>EAX</b> ,   , ,        ,      .  ,    ?     ? <br><br> <b>:</b> <b>NaCl</b>   ,      . <br><br> <b>:</b> ,       .      <b>x86</b>    ,    ,   <b>NaCl</b>   ,  2          .       ,    ,  : ¬´,    ,    !¬ª,              <b>25 CD 80 00 00</b> .     .         ,     <b>x86</b> . <br><br>   ,   <b>Native Client</b>      . ,       ,   ,    ,          <b>NaCl</b> . ,     . <br><br> <b>:</b> ,        ,     .     ,         .  ,      ,     ,       ,     . <br><br><img src="https://habrastorage.org/webt/sq/hd/pl/sqhdplwnbsfj55r8qmp6trwxk5y.jpeg"><br><br> <b>:</b> ,  .     ,   . ,       ,      ,   <b>EAX</b> .           ,   -  .        <b>EAX</b> ,  <b>EBX</b>   .           ,       .          <b>EAX</b>  <b>EBX</b>  <b>AND</b>   .     ,  ,      <b>EAX</b> ,         .         ,   -   <b>64</b>  .    <b>Jmp *% eax</b>   <b>AND</b>   . <br><br><img src="https://habrastorage.org/webt/qz/nf/zt/qznfzt9lqpfreshgcc76zygs8cq.jpeg"><br><br> ,   , ,   ,   .   <b>Intel</b> ,        ,  ,   ,      .       ,   ,             .       <b>AND</b>    ,   <b>EAX</b>  ,    ¬´¬ª . <br><br> ,       ,           .     ,       .     ,    ,   ,   .      ,  ,   ,    . <br> ,     ,  <b>C1</b>  <b>C7</b> . <br><br> <b>C1</b>   ,       ,            .     ,     ¬´¬ª     .   ,       ,      .   ,       ,     - .  ,    . <br> <b>2</b> ,     0   <b>64</b> .     ,     ,        .        ,      ,      . <br><br>  <b>3</b> ,  ,  ,   .        ,  ,         . <br><br> <b>4</b>   ,         <b>hlt</b> .             <b>halt</b> ?     ,  <b>C4</b> .   ,   ,      -  ,      . <br><br>     ,  ,          ? ,          ,      -  . <br>     ,     ,  ,       ,       .    ,       ,     ,  ,           .         . <br><br><img src="https://habrastorage.org/webt/9i/1f/yj/9i1fyjdue4tun6jsa8gnnzkue9c.jpeg"><br><br> 55:20  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Curso MIT "Seguran√ßa de sistemas de computadores".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> 7: ¬´ Native Client¬ª,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br> ,    .  Voc√™ gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usu√°rios da Habr em um an√°logo exclusivo de servidores b√°sicos que inventamos para voc√™:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 n√∫cleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as op√ß√µes est√£o dispon√≠veis com RAID1 e RAID10, at√© 24 n√∫cleos e at√© 40GB DDR4). <br><br> <b>3  </b>    Dell R630     ‚Äî <b>2  Intel Deca-Core Xeon E5-2630 v4 / 128GB DDR4 / 41TB HDD  2240GB SSD / 1Gbps 10 TB ‚Äî  $99,33 </b> ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente n√≥s temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um pr√©dio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418225/">https://habr.com/ru/post/pt418225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418215/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 5: ‚ÄúDe onde v√™m os erros do sistema de seguran√ßa‚Äù, Parte 2</a></li>
<li><a href="../pt418217/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 6: ‚ÄúOportunidades‚Äù, parte 1</a></li>
<li><a href="../pt418219/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 6: Oportunidades, Parte 2</a></li>
<li><a href="../pt418221/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 6: ‚ÄúOportunidades‚Äù, parte 3</a></li>
<li><a href="../pt418223/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 1</a></li>
<li><a href="../pt418227/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 3</a></li>
<li><a href="../pt418229/index.html">Curso MIT "Seguran√ßa de sistemas de computadores". Aula 8: Modelo de Seguran√ßa de Rede, Parte 1</a></li>
<li><a href="../pt418233/index.html">Mnem√¥nicos da BMW para encontrar valores-limite</a></li>
<li><a href="../pt418235/index.html">Saga orquestrada ou como criar transa√ß√µes comerciais em servi√ßos com o banco de dados por padr√£o de servi√ßo</a></li>
<li><a href="../pt418237/index.html">Desenvolvimento de aplicativos multilocat√°rios na plataforma em nuvem SAP na Neo, parte 2: autoriza√ß√£o e autentica√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>