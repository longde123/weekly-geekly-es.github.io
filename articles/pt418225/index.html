<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕖 🙌🏻 👨‍⚖️ Curso MIT "Segurança de sistemas de computadores". Palestra 7: Sandbox do Cliente Nativo Parte 2 🎚️ 🧑🏾‍🤝‍🧑🏻 🤳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instituto de Tecnologia de Massachusetts. Curso de Aula nº 6.858. "Segurança de sistemas de computador". Nikolai Zeldovich, James Mickens. 2014 ano 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Curso MIT "Segurança de sistemas de computadores". Palestra 7: Sandbox do Cliente Nativo Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418225/"><h3>  Instituto de Tecnologia de Massachusetts.  Curso de Aula nº 6.858.  "Segurança de sistemas de computador".  Nikolai Zeldovich, James Mickens.  2014 ano </h3><br>  Computer Systems Security é um curso sobre o desenvolvimento e implementação de sistemas de computador seguros.  As palestras abrangem modelos de ameaças, ataques que comprometem a segurança e técnicas de segurança baseadas em trabalhos científicos recentes.  Os tópicos incluem segurança do sistema operacional (SO), recursos, gerenciamento de fluxo de informações, segurança de idiomas, protocolos de rede, segurança de hardware e segurança de aplicativos da web. <br><br>  Palestra 1: “Introdução: modelos de ameaças” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 2: “Controle de ataques de hackers” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Aula 3: “Estouros de Buffer: Explorações e Proteção” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 4: “Separação de Privilégios” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 5: “De onde vêm os sistemas de segurança?” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  Palestra 6: “Oportunidades” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br>  Palestra 7: “Sandbox do Cliente Nativo” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <a name="habracut"></a><br><br>  <b>Público:</b> por que o intervalo de capacidade da memória do intervalo de endereços deve começar do zero? <br><br>  <b>Professor:</b> porque em termos de desempenho, é mais eficiente usar o salto de destino se você souber que um endereço válido é um conjunto contínuo de endereços começando do zero.  Porque então você pode fazer isso com uma única máscara <b>AND</b> , onde todos os bits altos são um e apenas um par de bits baixos é zero. <br><br>  <b>Público:</b> Eu pensei que a máscara <b>AND</b> deveria fornecer alinhamento. <br><br>  <b>Professor:</b> certo, a máscara fornece alinhamento, mas por que começa do zero?  Eu acho que eles confiam no <b>hardware</b> segmentado por hardware de segmentação.  Então, basicamente, eles poderiam usá-lo para mover a área para cima, em termos de espaço linear.  Ou talvez esteja relacionado apenas ao modo como o aplicativo "vê" esse intervalo.  De fato, você pode colocá-lo com diferentes compensações no seu espaço de endereço virtual.  Isso permitirá que você execute certos truques com hardware segmentado para executar vários módulos no mesmo espaço de endereço. <br><br><img src="https://habrastorage.org/webt/_r/ef/sc/_refscc89wngsofm0ajoa0eflym.jpeg"><br><br>  <b>Público:</b> Talvez seja porque eles querem "capturar" o ponto de recebimento do ponteiro nulo? <br><br>  <b>Professor:</b> sim, porque eles querem pegar todos os pontos de recepção.  Mas você tem uma maneira de fazer isso.  Porque o ponteiro nulo se refere ao segmento que está sendo acessado.  E se você mover o segmento, poderá exibir uma página zero não utilizada no início de cada segmento.  Portanto, isso ajudará a criar alguns módulos. <br><br>  Eu acho que uma das razões para essa decisão - iniciar o intervalo de 0 - se deve ao desejo de portar seu programa para a plataforma <b>x64</b> , que tem um design um pouco diferente.  Mas o artigo deles não diz isso.  No design de 64 bits, o próprio equipamento se livrou de algum hardware de segmentação, no qual eles contavam por razões de eficiência, então eles tiveram que fornecer uma abordagem orientada a software.  No entanto, para <b>x32,</b> esse ainda não é um bom motivo para o espaço começar do zero. <br><br>  Portanto, continuamos a questão principal - o que queremos garantir do ponto de vista da segurança.  Vamos abordar esse assunto de forma um tanto "ingênua" e ver como podemos arruinar tudo e depois tentar consertá-lo. <br><br>  Acredito que um plano ingênuo é procurar instruções proibidas simplesmente digitalizando o executável do começo ao fim.  Então, como você pode identificar essas instruções?  Você pode simplesmente pegar o código do programa e colocá-lo em uma linha gigante que varia de zero a 256 megabytes, dependendo do tamanho do seu código, e então iniciar a busca. <br><br><img src="https://habrastorage.org/webt/nl/vt/rv/nlvtrvk-s3z8c_yhuugx0zqaxyc.jpeg"><br><br>  Essa linha pode primeiro conter o módulo de instruções <b>NOP</b> , depois o módulo de instruções <b>ADD</b> , <b>NOT</b> , <b>JUMP</b> e assim por diante.  Você apenas procura e, se encontrar uma instrução incorreta, diga que é um módulo inválido e descarte-o.  E se você não vir nenhuma chamada do sistema para esta instrução, poderá ativar o lançamento deste módulo e fazer tudo dentro do intervalo de 0 a 256.  Você acha que isso vai funcionar ou não?  Com o que eles estão preocupados?  Por que isso é tão difícil? <br><br>  <b>Público:</b> Eles estão preocupados com o tamanho das instruções? <br><br>  <b>Professor:</b> sim, o fato é que a plataforma <b>x86</b> possui instruções de tamanho variável.  Isso significa que o tamanho exato da instrução depende dos primeiros bytes desta instrução.  De fato, você pode observar o primeiro byte para dizer que a instrução será muito maior e, em seguida, talvez seja necessário observar mais alguns bytes e decidir qual tamanho será necessário.  Algumas arquiteturas como <b>Spark</b> , <b>ARM</b> , <b>MIPS</b> têm instruções de comprimento mais fixo.  <b>O ARM</b> possui dois comprimentos de instrução - 2 ou 4 bytes.  Mas na plataforma <b>x86, o</b> comprimento das instruções pode ser de 1, 5 e 10 bytes e, se você tentar, poderá obter uma instrução bastante longa de 15 bytes.  No entanto, estas são instruções complexas. <br><br>  Como resultado, um problema pode aparecer.  Se você digitalizar esta linha de código linearmente, tudo ficará bem.  Mas talvez em tempo de execução você vá para o meio de algum tipo de instrução, por exemplo, <b>NÃO</b> . <br><br><img src="https://habrastorage.org/webt/ob/rv/lj/obrvlj58uew5ji8-9mev7cxwb04.jpeg"><br><br>  É possível que seja uma instrução multibyte e, se você a interpretar a partir do segundo byte, ela parecerá completamente diferente. <br><br>  Outro exemplo no qual vamos "brincar" com o assembler.  Suponha que tenhamos a instrução <b>25 CD 80 00 00</b> .  Tendo examinado o segundo byte, você o interpretará como uma instrução de cinco bytes, ou seja, terá que olhar 5 bytes para frente e ver que é seguido pela instrução <b>AND% EAX, CD 0x00 00 80</b> , começando com o operador <b>AND</b> para o registro <b>EAX</b> com alguns constantes definidas, por exemplo, <b>00 00 80 CD</b> .  Esta é uma das instruções seguras que o <b>Native Client</b> deve simplesmente permitir pela primeira regra de verificação de instruções binárias.  Mas se, durante a execução do programa, a <b>CPU</b> decidir que deve começar a executar o código do <b>CD</b> , marcarei este local da instrução com uma seta, então a instrução <b>% EAX, 0x00 00 80 CD</b> , que na verdade é uma instrução de 4 bytes, significará a execução do <b>INT $ 0x80</b> , que é uma maneira de fazer uma chamada de sistema no <b>Linux</b> . <br><br><img src="https://habrastorage.org/webt/ib/3a/zp/ib3azp3oe9zmfedweosbecx9fto.jpeg"><br><br>  Portanto, se você perder esse fato, deixe o módulo não confiável "pular" no kernel e fazer chamadas ao sistema, ou seja, faça o que você deseja impedir.  Como podemos evitar isso? <br><br>  Talvez devêssemos tentar observar o deslocamento de cada byte.  Como o x86 pode começar a interpretar apenas uma instrução nos limites de bytes, não de bits.  Portanto, você deve observar o deslocamento de cada byte para ver onde a instrução começa.  Você acha que esse é um plano viável? <br><br>  <b>Público:</b> Eu acho que se alguém realmente usa <b>AND</b> , o processador não salta para este local, mas simplesmente permite que o programa seja executado. <br><br>  <b>Professor:</b> sim, porque basicamente ele não é propenso a falsos positivos.  Agora, se você realmente quiser, pode alterar um pouco o código para evitá-lo.  Se você souber exatamente o que o dispositivo de teste está procurando, poderá alterar essas instruções.  Talvez configurando <b>AND</b> primeiro para uma instrução e depois use a máscara em outra.  Mas é muito mais fácil evitar esses arranjos de bytes suspeitos, embora isso pareça bastante inconveniente. <br><br>  É possível que a arquitetura inclua uma alteração no compilador.  Basicamente, eles têm algum tipo de componente que realmente precisa compilar o código corretamente.  Você não pode simplesmente "decolar" o <b>GCC</b> e compilar o código para o <b>Native Client</b> .  Então, basicamente, isso é factível.  Mas, provavelmente, eles acham que isso causa muitos problemas, não será uma solução confiável ou de alto desempenho e assim por diante.  Além disso, existem várias instruções <b>x86</b> que são proibidas ou devem ser consideradas inseguras e, portanto, devem ser proibidas.  Mas, na maioria das vezes, eles têm um byte de tamanho, por isso é muito difícil encontrá-los ou filtrá-los. <br><br>  Portanto, se eles não podem simplesmente coletar e classificar instruções inseguras e esperar o melhor, precisam usar um plano diferente para desmontá-lo de maneira confiável.  Então, o que o <b>Native Client faz</b> para garantir que não "tropeça" nessa codificação de tamanho variável? <br><br>  De certa forma, se realmente varrermos o arquivo executável da esquerda para a direita e procurarmos todos os códigos incorretos possíveis, e se for assim que o código for executado, estaremos em boa forma.  Mesmo que haja algumas instruções estranhas e algum viés, o processador ainda não vai “pular” para lá, ele executará o programa na mesma ordem em que as instruções são digitalizadas, ou seja, da esquerda para a direita. <br><br><img src="https://habrastorage.org/webt/kh/v0/ea/khv0ea7apzgmwqnx1pbaj8k1fgy.jpeg"><br><br>  Assim, o problema com a desmontagem confiável surge devido ao fato de que em algum lugar da aplicação pode haver "saltos".  O processador pode falhar se der um “salto” para alguma instrução de código que não percebeu ao digitalizar da esquerda para a direita.  Portanto, este é um problema de desmontagem confiável até agora em desenvolvimento.  E o plano principal é verificar para onde todos os "saltos" levam.  De fato, é bastante simples em algum nível.  Existem várias regras que consideraremos em um segundo, mas o plano aproximado é que, se você vir uma instrução de "salto", precisará garantir que o objetivo do "salto" tenha sido observado anteriormente.  Para fazer isso, de fato, basta escanear da esquerda para a direita, ou seja, o procedimento que descrevemos em nossa abordagem ingênua do problema. <br><br>  Nesse caso, se você vir alguma instrução de “salto” e o endereço para o qual esta instrução aponta, verifique se esse é o mesmo endereço que você já viu durante a desmontagem da esquerda para a direita. <br><br>  Se uma instrução de salto para este byte de CD for encontrada, devemos marcá-lo como inválido, porque nunca vimos a instrução iniciando no byte de CD, mas vimos outra instrução começando com o número 25. Mas se todas as instruções de salto ordenado a ir para o início da instrução, neste caso para 25, então estamos bem.  Isso está claro? <br><br>  O único problema é que você não pode verificar os objetivos de cada salto no programa, pois pode haver saltos indiretos.  Por exemplo, em <b>x86,</b> você pode ter algo como um salto no valor desse registro <b>EAX</b> .  Isso é ótimo para implementar ponteiros de função. <br><br><img src="https://habrastorage.org/webt/uf/gh/bl/ufghbl_dd-pofxnrp7fy-ne3ee0.jpeg"><br><br>  Ou seja, o ponteiro de função está em algum lugar da memória, você o mantém em algum registro e depois vai para qualquer endereço no registro de movimento. <br><br>  Então, como esses caras lidam com saltos indiretos?  Porque, de fato, não tenho idéia se isso será um “salto” para o byte <b>CD</b> ou o byte 25. O que eles fazem nesse caso? <br><br>  <b>Público:</b> usando ferramentas? <br><br>  <b>Professor:</b> sim, a instrumentação é o principal truque.  Portanto, sempre que virem que o compilador está pronto para executar a geração, isso prova que esse salto não causará problemas.  Para fazer isso, eles precisam garantir que todos os saltos sejam executados com uma multiplicidade de 32 bytes.  Como eles fazem isso?  Eles mudam todas as instruções de salto para o que chamam de "pseudo instruções".  Estas são as mesmas instruções, mas prefixadas, que limpam os 5 bits baixos no registro <b>EAX</b> .  O fato de a instrução limpar 5 bits baixos significa que faz com que o valor fornecido seja um múltiplo de 32, de dois a cinco, e então um salto para esse valor já é realizado. <br><br><img src="https://habrastorage.org/webt/r3/sf/nq/r3sfnqlxz3egqe8q-0ret79kwzu.jpeg"><br><br>  Se você observar isso durante a verificação, certifique-se de que esse "par" instrucional "salte" apenas com uma multiplicidade de 32 bytes.  E então, para garantir que não haja possibilidade de "pular" em algumas instruções estranhas, você aplica uma regra adicional.  Consiste no fato de que, durante a desmontagem, quando você olha suas instruções da esquerda para a direita, assegura que o início de cada instrução válida também seja um múltiplo de 32 bytes. <br><br>  Assim, além deste kit de ferramentas, você verifica se cada código múltiplo de 32 é a instrução correta.  Por uma instrução válida e válida, quero dizer uma instrução desmontada da esquerda para a direita. <br><br>  <b>Público:</b> Por que o número 32 foi escolhido? <br><br>  <b>Professor:</b> sim, por que eles escolheram 32 em vez de 1000 ou 5?  Por que 5 é ruim? <br><br>  <b>Público:</b> porque o número deve ser uma potência de 2. <br><br>  <b>Professor:</b> sim, bem, é por isso.  Porque, caso contrário, garantir o uso de algo múltiplo de 5 exigirá instruções adicionais que levem à sobrecarga.  E oito?  O número é oito o suficiente? <br><br>  <b>Público-alvo:</b> você pode ter instruções com mais de oito bits. <br><br>  <b>Professor:</b> sim, isso pode ser para a instrução mais longa permitida na plataforma x86.  Se temos uma instrução de 10 bytes e tudo deve ter um múltiplo de 8, não podemos inseri-la em nenhum lugar.  Portanto, o comprimento deve ser suficiente para todos os casos, porque a maior instrução que vi foi de 15 bytes.  Então 32 bytes é suficiente. <br><br>  Se você deseja adaptar as instruções para entrar ou sair do ambiente de serviço de processo, pode precisar de uma quantidade não trivial de código em um slot de 32 bytes.  Por exemplo, 31 bytes, porque 1 byte contém uma instrução.  Deveria ser muito maior?  Devemos fazer isso igual a, digamos, 1024 bytes?  Se você tiver muitos ponteiros de função ou muitos saltos indiretos, toda vez que quiser criar um local para pular, deverá continuar na próxima borda, independentemente do seu valor.  Portanto, com 32 bits, é um tamanho bastante normal.  Na pior das hipóteses, você perderá apenas 31 bytes se precisar chegar rapidamente à próxima borda.  Mas se você tem um tamanho múltiplo de 1024 bytes, existe a possibilidade de desperdiçar um kilobyte inteiro de memória em vão para um salto indireto.  Se você tiver funções curtas ou muitos ponteiros de função, um tamanho tão grande da multiplicidade do comprimento do "salto" causará um desperdício significativo de memória. <br><br>  Eu não acho que o número 32 seja uma pedra de tropeço para o <b>Native Client</b> .  Alguns blocos podem funcionar com uma multiplicidade de 16 bits, alguns de 64 ou 128 bits, isso não importa.  Apenas 32 bits pareciam o valor ideal mais aceitável. <br><br>  Então, vamos fazer um plano para uma desmontagem confiável.  Como resultado, o compilador deve ter um pouco de cuidado ao compilar o <b>código</b> <b>C</b> ou <b>C ++</b> em um binário do <b>Native Client</b> e observar as seguintes regras. <br><br><img src="https://habrastorage.org/webt/c0/nh/kc/c0nhkc4izpqqyrj_rtr2gg-eytu.jpeg"><br><br>  Portanto, sempre que ele pular, como mostrado na linha superior, ele deve adicionar essas instruções adicionais fornecidas nas 2 linhas inferiores.  E, independentemente do fato de ele criar uma função para a qual ele "saltará", nossa instrução saltará como a adição <b>AND $ 0xffffffe0,% eax</b> indica.  E não pode apenas complementá-lo com zeros, porque tudo isso deve ter os códigos corretos.  Portanto, a adição é necessária para garantir que todas as instruções possíveis sejam válidas.  E, felizmente, na plataforma <b>x86</b> , nem uma única função <b>noop</b> é descrita por um único byte, ou pelo menos não há um único <b>noop com</b> 1 byte de tamanho.  Assim, você sempre pode adicionar coisas ao valor de uma constante. <br><br>  Então, o que isso nos garante?  Vamos garantir que sempre vejamos o que acontece na terminologia das instruções que serão seguidas.  Aqui está o que essa regra nos fornece - a garantia de que uma chamada do sistema não será feita por acidente.  Isso se aplica aos saltos, mas e os retornos?  Como eles lidam com retornos?  Podemos <b>retornar</b> a uma função no <b>Native Client</b> ?  O que acontece se você executar o código em brasa? <br><br>  <b>Público:</b> Pode estourar a pilha. <br><br>  <b>Professor:</b> é verdade que aparece inesperadamente na pilha.  Mas o fato é que a pilha usada pelos módulos do <b>Native Client</b> realmente contém alguns dados.  Portanto, ao lidar com o <b>Native Client,</b> você não deve se preocupar com o estouro de pilha. <br><br>  <b>Público:</b> espere, mas você pode colocar qualquer coisa na pilha.  E quando você dá um salto indireto. <br><br>  <b>Professor:</b> é verdade.  O retorno parece quase um salto indireto de algum lugar da memória, localizado no topo da pilha.  Portanto, acho que uma coisa que eles poderiam fazer para a função de <b>retorno</b> é definir o prefixo da mesma maneira que na verificação anterior.  E esse prefixo verifica o que aparece no topo da pilha.  Você verifica se isso é válido e, ao escrever ou usar o operador <b>AND</b> , verifica o que está no topo da pilha.  Isso parece um pouco confiável devido à constante mudança de dados.  Como, por exemplo, se você olhar para o topo da pilha e verificar se está tudo bem, e depois escrever alguma coisa, o fluxo de dados no mesmo módulo poderá modificar algo no topo da pilha, após o qual você se referirá ao errado endereço <br><br>  <b>Público:</b> Isso não se aplica ao salto na mesma extensão? <br><br>  <b>Professor:</b> sim, então o que acontece lá com um salto?  Nossas condições de corrida podem de alguma forma invalidar este teste? <br><br>  <b>Público:</b> Mas o código não é gravável? <br><br>  <b>Professor:</b> sim, o código não pode ser escrito, isso é verdade.  Portanto, você não pode modificar AND.  Mas não poderia outro fluxo alterar o objetivo do salto entre essas duas instruções? <br><br>  <b>Público:</b> isso está no registro, então ... <br><br>  <b>Professor:</b> Sim, isso é uma coisa legal.  Como se um fluxo modificar algo na memória ou no <b>conteúdo</b> carregado do <b>EAX</b> (por si só, você o faz antes do download), nesse caso, o <b>EAX</b> estará em um estado ruim, mas eliminará os bits ruins.  Ou ele pode alterar a memória depois, quando o ponteiro já estiver no <b>EAX</b> , portanto, não importa que ele altere o local da memória da qual o registro <b>EAX</b> foi carregado. <br><br>  De fato, os threads não compartilham conjuntos de registros.  Portanto, se outro segmento alterar o registro <b>EAX</b> , isso não afetará o registro <b>EAX</b> desse segmento.  Portanto, outros segmentos não podem invalidar esta sequência de instruções. <br><br>  Há outra questão interessante.  Podemos contornar isso <b>E</b> ?  Eu posso pular para onde quiser em qualquer lugar deste espaço de endereço.      ,       <b>AND</b>  . <br><br><img src="https://habrastorage.org/webt/4p/vf/nk/4pvfnkoa0kmui9vdd5wn2o-jbk0.jpeg"><br><br>       ,      ,   ,    ,  ,        <b>AND</b> .    .     <b>jmp</b> ,      . <br><br><img src="https://habrastorage.org/webt/kg/mf/cu/kgmfcuyc42v0rtkdtzt1ptm1ty4.jpeg"><br><br> ,      ,    -  ,    1237.     ,     32.  <b>Native Client</b>       ,     ,      ,     .          ,   ,      1237      ? <br><br><img src="https://habrastorage.org/webt/dn/_-/_r/dn_-_r-vi7p_qx7nxwwkqmroh-w.jpeg"><br><br>    -  <b>EAX</b> ,   , ,        ,      .  ,    ?     ? <br><br> <b>:</b> <b>NaCl</b>   ,      . <br><br> <b>:</b> ,       .      <b>x86</b>    ,    ,   <b>NaCl</b>   ,  2          .       ,    ,  : «,    ,    !»,              <b>25 CD 80 00 00</b> .     .         ,     <b>x86</b> . <br><br>   ,   <b>Native Client</b>      . ,       ,   ,    ,          <b>NaCl</b> . ,     . <br><br> <b>:</b> ,        ,     .     ,         .  ,      ,     ,       ,     . <br><br><img src="https://habrastorage.org/webt/sq/hd/pl/sqhdplwnbsfj55r8qmp6trwxk5y.jpeg"><br><br> <b>:</b> ,  .     ,   . ,       ,      ,   <b>EAX</b> .           ,   -  .        <b>EAX</b> ,  <b>EBX</b>   .           ,       .          <b>EAX</b>  <b>EBX</b>  <b>AND</b>   .     ,  ,      <b>EAX</b> ,         .         ,   -   <b>64</b>  .    <b>Jmp *% eax</b>   <b>AND</b>   . <br><br><img src="https://habrastorage.org/webt/qz/nf/zt/qznfzt9lqpfreshgcc76zygs8cq.jpeg"><br><br> ,   , ,   ,   .   <b>Intel</b> ,        ,  ,   ,      .       ,   ,             .       <b>AND</b>    ,   <b>EAX</b>  ,    «» . <br><br> ,       ,           .     ,       .     ,    ,   ,   .      ,  ,   ,    . <br> ,     ,  <b>C1</b>  <b>C7</b> . <br><br> <b>C1</b>   ,       ,            .     ,     «»     .   ,       ,      .   ,       ,     - .  ,    . <br> <b>2</b> ,     0   <b>64</b> .     ,     ,        .        ,      ,      . <br><br>  <b>3</b> ,  ,  ,   .        ,  ,         . <br><br> <b>4</b>   ,         <b>hlt</b> .             <b>halt</b> ?     ,  <b>C4</b> .   ,   ,      -  ,      . <br><br>     ,  ,          ? ,          ,      -  . <br>     ,     ,  ,       ,       .    ,       ,     ,  ,           .         . <br><br><img src="https://habrastorage.org/webt/9i/1f/yj/9i1fyjdue4tun6jsa8gnnzkue9c.jpeg"><br><br> 55:20  <br><br> : <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Curso MIT "Segurança de sistemas de computadores".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> 7: « Native Client»,  3</a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br> ,    .  Você gosta dos nossos artigos?  Deseja ver materiais mais interessantes?  Ajude-nos fazendo um pedido ou recomendando a seus amigos, um <b>desconto de 30% para os usuários da Habr em um análogo exclusivo de servidores básicos que inventamos para você:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Toda a verdade sobre o VPS (KVM) E5-2650 v4 (6 núcleos) 10GB DDR4 240GB SSD 1Gbps de US $ 20 ou como dividir o servidor?</a>  (as opções estão disponíveis com RAID1 e RAID10, até 24 núcleos e até 40GB DDR4). <br><br> <b>3  </b>    Dell R630     — <b>2  Intel Deca-Core Xeon E5-2630 v4 / 128GB DDR4 / 41TB HDD  2240GB SSD / 1Gbps 10 TB —  $99,33 </b> ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> . <br><br>  <b>Dell R730xd 2 vezes mais barato?</b>  Somente nós temos <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2 TVs Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 a partir de US $ 249</a> na Holanda e nos EUA!</b>  Leia sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como criar um prédio de infraestrutura.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">classe usando servidores Dell R730xd E5-2650 v4 custando 9.000 euros por um centavo?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418225/">https://habr.com/ru/post/pt418225/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418215/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 5: “De onde vêm os erros do sistema de segurança”, Parte 2</a></li>
<li><a href="../pt418217/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: “Oportunidades”, parte 1</a></li>
<li><a href="../pt418219/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: Oportunidades, Parte 2</a></li>
<li><a href="../pt418221/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 6: “Oportunidades”, parte 3</a></li>
<li><a href="../pt418223/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 1</a></li>
<li><a href="../pt418227/index.html">Curso MIT "Segurança de sistemas de computadores". Palestra 7: A Sandbox do Cliente Nativo, Parte 3</a></li>
<li><a href="../pt418229/index.html">Curso MIT "Segurança de sistemas de computadores". Aula 8: Modelo de Segurança de Rede, Parte 1</a></li>
<li><a href="../pt418233/index.html">Mnemônicos da BMW para encontrar valores-limite</a></li>
<li><a href="../pt418235/index.html">Saga orquestrada ou como criar transações comerciais em serviços com o banco de dados por padrão de serviço</a></li>
<li><a href="../pt418237/index.html">Desenvolvimento de aplicativos multilocatários na plataforma em nuvem SAP na Neo, parte 2: autorização e autenticação</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>