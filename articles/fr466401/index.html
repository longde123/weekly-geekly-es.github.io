<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéÜ üë©üèæ‚Äçü§ù‚Äçüë©üèº üßöüèø Un peu de math√©matiques financi√®res: calculer l'inflation et les int√©r√™ts ‚ôâÔ∏è üé¶ üë¶üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R√©cemment, j'ai d√ª v√©rifier les calculs effectu√©s par les services publics de ma ville. Il y avait un probl√®me controvers√©, qui ne peut √™tre r√©solu qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un peu de math√©matiques financi√®res: calculer l'inflation et les int√©r√™ts</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466401/"> R√©cemment, j'ai d√ª v√©rifier les calculs effectu√©s par les services publics de ma ville.  Il y avait un probl√®me controvers√©, qui ne peut √™tre r√©solu qu'en effectuant des calculs corrects.  Pour l'avenir, je dirai que les services publics pensent mal.  Par cons√©quent, nous examinerons ici comment calculer correctement les co√ªts d'inflation et 3% par an sur la dette pour les obligations, selon le Code civil de l'Ukraine. <br><br>  La premi√®re partie d√©crit le calcul des co√ªts d'inflation, ceci est sp√©cifique √† l'Ukraine. <br>  La deuxi√®me partie (plus importante) sera consacr√©e √† la question du calcul de 3% par an.  Il s'applique √©galement √† la F√©d√©ration de Russie, √† la Bi√©lorussie et au Kazakhstan, mais dans ces pays, le taux n'est pas fixe, mais d√©pend du taux de refinancement de la Banque centrale.  Le reste du pays n'a pas regard√©. <br><br>  La deuxi√®me partie est tr√®s proche du calcul des int√©r√™ts sur les op√©rations de cr√©dit ordinaires (pr√™ts, pr√™ts, emprunts, etc.). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/di/2q/9l/di2q9lbdqyzqzcywadgdnny0bgo.png" alt="image alt"></div><br>  D'abord une th√©orie, √† la fin un peu de code. <br><br>  Tout cela sous la coupe. <br><a name="habracut"></a><br>  Je suis donc tomb√© entre les mains d'un document des services publics "D√©claration de cumul des co√ªts d'inflation et de 3% par an".  Il a √©t√© v√©rifi√© par moi, et j'ai d√©couvert qu'il a √©t√© calcul√© en utilisant le mauvais algorithme et qu'il pr√©sente un int√©r√™t, car il doit mettre en ≈ìuvre les exigences de l'article du Code civil de l'Ukraine. <br><br>  Ce qui doit √™tre pris en compte est √©crit dans le Code civil de l'Ukraine: <br><blockquote>  Article 625 du Code civil de l'Ukraine.  ¬´Responsabilit√© pour violation d'une obligation mon√©taire¬ª <br>  2. Le d√©biteur qui a retard√© l'ex√©cution d'une obligation mon√©taire est, √† la demande du cr√©ancier, tenu de payer le montant de la dette en tenant compte de l'indice d'inflation √©tabli pour toute la p√©riode de retard, ainsi que de 3% par an du montant en souffrance ... </blockquote>  Sur la base des chiffres de la dette, les services publics ont calcul√© les co√ªts d'inflation et 3% par an. <br><br><h2>  Co√ªts d'inflation </h2><br>  Plus loin, je parlerai de l'algorithme de calcul, et non de nombres sp√©cifiques. <br><br>  L'inflation est un processus caract√©ris√© par une d√©pr√©ciation de la monnaie, c'est-√†-dire une diminution de son pouvoir d'achat et une augmentation g√©n√©rale des prix.  Hors inflation, les r√©sultats finaux des calculs de flux de tr√©sorerie sont tr√®s arbitraires. <br><br>  L'indice d'inflation (II) ou l'indice des prix √† la consommation (IPC), l'indice des prix √† la consommation (IPC) est l'un des types d'indices des prix cr√©√©s pour mesurer le niveau moyen des prix des biens et services (panier de consommation) pendant une certaine p√©riode de l'√©conomie. <br><br>  L'IA est un indicateur caract√©risant la dynamique du niveau g√©n√©ral des prix des biens et services que la population acquiert pour une consommation non productive.  Il s'agit de l'indice de croissance, qui indique le pourcentage de l'augmentation moyenne des prix pour la p√©riode consid√©r√©e. <br><br>  En Ukraine, AI et CPI sont synonymes <br><br>  L'indice des prix √©tant un indice en cha√Æne, pour les p√©riodes qui se succ√®dent, il est calcul√© en multipliant les indicateurs, par exemple, 101% * 102% = (1,01 * 1,02) * 100% = 103,02%. <br><br>  L'IA est calcul√©e par le Comit√© national des statistiques de l'Ukraine et publi√©e dans des p√©riodiques officiels.  Ces chiffres cl√©s peuvent √™tre utilis√©s pour recalculer les montants en esp√®ces. <br>  Que pensent les travailleurs communaux? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/5p/hv/ge5phvi9cjhbbz7kkx0jndzuyli.png" alt="Partie du document de facturation des services publics"></div><br>  La derni√®re date de r√®glement est le 7 d√©cembre 2016. <br><br>  Voyons comment les travailleurs communaux ont obtenu des ratios de co√ªt d'inflation? <br><br>  On peut voir √† l'≈ìil nu que dans la troisi√®me (et cinqui√®me colonne), au lieu de la partie enti√®re 1, il devrait y avoir la partie enti√®re 0. Comment ont-ils obtenu la partie fractionnaire? <br><br>  <strong>Septembre 2016.</strong> Partie fractionnaire 0,028.  Le d√©lai de paiement pour septembre est le 20 octobre 2016. La partie fractionnaire correspond √† l'indice d'inflation publi√© par le Comit√© national des statistiques, pour octobre 2016 - 102,8% <br><br>  <strong>Ao√ªt 2016.</strong> Partie fractionnaire 0,0465.  Le d√©lai de paiement pour ao√ªt est le 20 septembre 2016. La fraction correspond √† l'indice d'inflation de septembre multipli√© par II pour octobre: ‚Äã‚Äã101,8% * 102,8% = 104,65%, ou en actions, 1,018 * 1,028 = 1,046504.  Les services publics sont arrondis √† 1,0465 et impriment ce nombre, bien que l'unit√© doive √™tre supprim√©e, car dans la colonne suivante, ils n'impriment que le montant des co√ªts d'inflation, et non le montant accumul√©. <br><br>  <strong>Juillet 2016 et versions ant√©rieures.</strong>  J'ai effectu√© ces calculs et restaur√© l'algorithme.  Les services publics multiplient les indices d'inflation √† partir du mois suivant le mois de la prestation de services (mois de la date d'√©ch√©ance) et se terminant en octobre 2016. <br><br>  <strong>Le point de d√©part n'est</strong> que partiellement vrai.  Comme je le montrerai plus tard, dans le cas g√©n√©ral, le calcul doit vraiment commencer √† partir de ce mois, mais dans notre cas particulier, le premier mois doit √™tre ignor√© (assimiler AI √† 100%). <br><br>  <strong>Le point final de la</strong> multiplication.  √âtant donn√© que le dernier jour de calcul est en d√©cembre et que vous devez terminer d√©cembre, c'est g√©n√©ralement le cas.  Comme je le montrerai plus tard, dans ce cas particulier, d√©cembre doit √©galement √™tre ignor√© (√©quivaut √©galement √† 100% pour l'IA).  Et le 7 d√©cembre, les IA de d√©cembre n'ont pas eu le temps de publier. <br><br>  Pourquoi novembre n'est-il pris en compte nulle part?  Je pense qu'ils ont juste oubli√© de l'introduire dans le syst√®me. <br><br>  Voyons maintenant comment calculer l'indice d'inflation.  Au <strong>besoin</strong> - d√©crit dans la lettre d'information de la Cour √©conomique supr√™me d'Ukraine n ¬∞ 01-06 / 928/2012 du 17 juillet 2012 [6]. <br><br>  Je vais donner une partie du paragraphe: <br><blockquote>  Le montant de la dette √† payer du 1er au 15e jour du mois est index√© en tenant compte de ce mois, et si la dette est √† payer du 16e au 31e jour du mois, le calcul commence √† partir du mois suivant. <br><br>  De m√™me, si une dette a √©t√© rembours√©e de 1 √† 15 jours par mois, les co√ªts d'inflation sont calcul√©s sans tenir compte de ce mois, et si de 16 √† 31 jours par mois, les co√ªts d'inflation sont calcul√©s en tenant compte de ce mois. </blockquote>  Dans notre cas, le d√©lai de paiement est le 20e jour du mois suivant le mois de la prestation de services, c'est-√†-dire  pour la prestation de services en septembre, la date de d√©but des r√®glements est le 21 octobre 2016 et la date limite est le 7 d√©cembre 2016. <br><br>  C'est-√†-dire  il est juste d'en tenir compte: pour la prestation de services en septembre 2016, pensez √† l'inflation pendant trois mois (passez le curseur ou le cycle), d'octobre √† d√©cembre, mais au premier et au dernier mois, prenez AI √©gal √† 1 (100%), et ne prenez en compte que novembre. <br><br>  En novembre 2016, l'IA s'√©levait √† 101,8%, soit  le coefficient doit √™tre de 0,0180 et non de 0,0280.  J'ai d√©j√† √©crit sur l'unit√© principale. <br><br><h2>  3% par an </h2><br>  Voyons comment les services communaux ont re√ßu des coefficients et des montants cumul√©s de 3% par an?  Il s'agit de la cinqui√®me colonne du tableau ci-dessus. <br><br>  Comme je l'ai √©crit plus t√¥t, il ne devrait pas y avoir d'unit√© principale, il devrait y avoir 0. Nous regardons la partie fractionnaire, et notons qu'elle est en quelque sorte √©trangement arrondie - chaque mois pr√©c√©dent est 0,0025 de plus que le mois en cours. <br><br>  √Ä l'aide de calculs simples, il peut √™tre d√©termin√© que les services publics, sans plus tarder, ont divis√© 3% en 12 mois, re√ßu 0,0025, ou 0,25% par mois, et cumul√© ce pourcentage pour chaque mois de retard complet et incomplet.  Oui, si vous regardez octobre 2016, dont le d√©lai de paiement est venu le 21 novembre et les calculs ont √©t√© effectu√©s le 7 d√©cembre, alors pour un mois incomplet, ils ont compt√© le m√™me 0,25%. <br><br>  L'approche admire la simplicit√© brutale, mais, comme je le montrerai plus loin, les math√©matiques financi√®res ne connaissent pas un tel algorithme. <br><br>  La l√©gislation ukrainienne et les math√©matiques financi√®res ne donnent pas de r√©ponse claire √† la question de savoir comment facturer 3% par an?  J'ai cherch√© plusieurs livres sur ce sujet, mais les livres sont anciens et remontent √† 2002.  Par cons√©quent, les algorithmes des livres seront compl√©t√©s par le fait qu'il √©tait possible de google √† partir d'articles plus modernes et occidentaux.  [1] a √©t√© r√©imprim√© en 2007 et aucun livre en russe plus r√©cent n'a pu √™tre trouv√©.  Peut-√™tre parce que les math√©matiques financi√®res, en tant que science, sont n√©es il y a tr√®s longtemps, bien avant l'av√®nement des ordinateurs, des concepts tels que ¬´cr√©dit¬ª et ¬´int√©r√™t sur cr√©dit¬ª sont apparus il y a plusieurs centaines d'ann√©es.  Et les algorithmes n'ont pas beaucoup chang√© depuis 2002. <br><br>  Mais la vision occidentale du probl√®me est diff√©rente de celle d√©crite dans les livres en russe.  Je citerai d'abord des informations tir√©es de livres en russe, puis d'articles occidentaux, indiquant o√π elles co√Øncident. <br><br>  Ce qui est √©crit ci-dessous concerne le cas sp√©cifique de l'accumulation de 3% par an sur les arri√©r√©s, mais peut √©galement √™tre g√©n√©ralis√© au calcul des int√©r√™ts sur d'autres relations de cr√©dit si les int√©r√™ts sont accumul√©s en fonction des int√©r√™ts simples plut√¥t que des int√©r√™ts compos√©s. <br><br>  Selon l'art.  625 Le Code civil de l'Ukraine doit accumuler 3% par an selon le r√©gime des int√©r√™ts simples.  Pour calculer le montant des int√©r√™ts, le montant de la dette (ou le corps du pr√™t, dans le cas g√©n√©ral) doit √™tre multipli√© par le taux d'int√©r√™t annuel normalis√© de 3% et multipli√© par la fraction de l'ann√©e (dur√©e en ann√©es) que repr√©sentait le retard.  Cette part peut √™tre sup√©rieure √† 1 si le retard est sup√©rieur √† un an. <br><br>  La dur√©e du retard est exprim√©e en jours.  Dans un cas plus g√©n√©ral, la dur√©e du pr√™t <strong>peut √™tre</strong> exprim√©e en jours (la situation o√π la dur√©e du pr√™t est exprim√©e en mois et en ann√©es n'est pas prise en compte ici).  Et le taux annuel de 3% est le taux normalis√© d'int√©r√™t simple pour l'ann√©e.  <strong>Par cons√©quent, vous devez √™tre en mesure de ramener la dur√©e du retard (cr√©dit) en jours √† la dur√©e en ann√©es.</strong>  <strong>Ce n'est pas une t√¢che triviale, car la dur√©e de l'ann√©e d√©pend de son nombre.</strong> <br><br>  La dur√©e en jours est une mesure d√©finie de mani√®re unique de la dur√©e des √©carts de calendrier, par opposition √† la dur√©e en ann√©es.  La d√©finition de cette derni√®re n√©cessite une clarification sous la forme d'une r√®gle de conversion de la dur√©e en jours en dur√©e en ann√©es.  Un certain nombre de m√©thodes standard pour convertir la dur√©e en jours en dur√©e en ann√©es est bas√©e sur la division du nombre de jours par le soi-disant <strong>¬´diviseur annuel¬ª</strong> .  Les valeurs les plus courantes du diviseur annuel sont 360 et 365 jours.  Dans les cas les plus simples, le diviseur est un nombre constant et ind√©pendant de l'intervalle.  Le nombre de jours dans une p√©riode agit toujours comme un dividende (num√©rateur d'une fraction). <br>  Et vous devez d√©cider de la proc√©dure de calcul des termes en jours.  Prenons deux exemples farfelus: <br><br><ol><li>  Le client re√ßoit un pr√™t √† court terme de la banque du 6 d√©cembre 2018 au 7 d√©cembre 2018.  Quelle est la dur√©e du contrat et combien de jours ai-je besoin pour accumuler des int√©r√™ts?  De toute √©vidence - 1 jour. </li><li>  L'abonn√© pr√©commande le service aupr√®s de l'op√©rateur t√©l√©com, avec une dur√©e de validit√© future du 6 d√©cembre 2018 au 7 d√©cembre 2018.  Quelles sont les lignes de prestation de service et pendant combien de jours dois-je prendre un abonnement pour le service?  Evidemment 2 jours. </li></ol><br>  Quelle est la diff√©rence? <br><br>  Le fait est que le jour n'est pas un point sur la chronologie, mais un intervalle qui peut √™tre √©crit de deux mani√®res (rappel, le crochet entre les bords de l'intervalle signifie que le point est dans l'intervalle, la parenth√®se est le point pas dans l'intervalle): <br><br><ul><li>  [06.12.2018 00.00.00, 12/07/2018 00.00.00) - ici la bordure droite de l'intervalle n'est pas incluse dans l'intervalle, </li><li>  [06/12/2018 00.00.00, 12/06/2018 23.59.59] - ici la bordure droite de l'intervalle est incluse dans l'intervalle. </li></ul><br>  Dans le premier cas (1), lorsque l'intervalle de temps n'est pas indiqu√© explicitement, mais sous la forme d'un intervalle entre les dates, le nombre exact de jours est g√©n√©ralement calcul√©, y compris le premier ou le dernier jour, mais pas les deux.  [4] dit la m√™me chose en d'autres termes: "Le jour o√π le pr√™t est √©mis et le jour de remboursement est consid√©r√© comme un jour". <br><br>  Cette m√©thode d√©termine l'heure dite exacte.  Il peut √©galement √™tre facilement d√©termin√© si les deux dates se r√©f√®rent √† la m√™me ann√©e et un calendrier est disponible indiquant le num√©ro de s√©rie de chaque jour de l'ann√©e.  Il suffit ensuite de soustraire le num√©ro de s√©rie de la date pr√©coce du num√©ro de s√©rie de la date tardive et le r√©sultat donnera la dur√©e de la p√©riode.  Dans Oracle Database, vous pouvez simplement soustraire des dates (type DATE) tronqu√©es √† un jour (avec heure supprim√©e), l'une de l'autre, la diff√©rence est un nombre entier de jours. <br><br>  Dans le second cas (2) nous parlons de jours, donc nous comptons deux jours. <br><br>  De plus, je pars du fait que le nombre de jours que vous avez d√©j√† √©t√© d√©termin√©, par exemple, dans le cas des services communaux, lorsque le d√©lai de paiement est le 20 septembre (c'est-√†-dire le dernier jour de paiement acceptable), et qu'il a √©t√© pay√© le 21 septembre, c'est-√†-dire il est √©vident que le d√©lai doit √™tre pris √©gal √† 1 jour.  Dans le cas o√π vous √™tes confront√© √† une indication de l'intervalle n'incluant pas la bordure gauche - d√©placez simplement la bordure gauche un jour vers la droite. <br><br>  Comment comptons-nous le nombre de jours et le num√©rateur d'une fraction?  Il y a un calcul exact et un calcul approximatif. <br><br><h3>  Comptage pr√©cis des jours </h3><br><h4>  Pratique russophone </h4><br>  Le texte est en outre bas√© sur [1]. <br><br>  Le choix du nombre exact de jours dans une p√©riode comme diviseur, et les deux r√®gles les plus courantes donnent les r√®gles les plus courantes comme d√©nominateur - un diviseur annuel de 360 ‚Äã‚Äãou 365: <br><br>  <strong>R√®gle (R1) ACT / 365.</strong>  Pour cette r√®gle, la dur√©e en jours est divis√©e par le nombre 365. Je note que la dur√©e d'une ann√©e bissextile sera de 366/365 = 1,00274, ce qui est sup√©rieur √† un.  L'erreur de r√®gle ACT / 365 sera la plus grande, le plus d'ann√©es bissextiles dans une p√©riode.  Par cons√©quent, la valeur de 3% par an accumul√©e par cette r√®gle sera sup√©rieure √† 3%. <br><br>  <strong>R√®gle (R2) ACT / 360.</strong>  Il s'agit de la ¬´r√®gle bancaire¬ª, selon laquelle la dur√©e en jours est divis√©e par 360. Cette r√®gle augmente encore la dur√©e annuelle des √©carts.  Pour une ann√©e non bissextile, sa longueur sera de 365/360 = 1.01389, et pour une ann√©e bissextile 366/360 = 1.01667.  Naturellement, plus la p√©riode est longue, plus le degr√© ¬´d'allongement¬ª des ann√©es est √©lev√©.  Cette r√®gle est le plus souvent utilis√©e dans les calculs li√©s au march√© mon√©taire, c'est-√†-dire  l'endettement √† court terme du march√©, comme les d√©p√¥ts aupr√®s des banques, les effets, les papiers commerciaux, les certificats de d√©p√¥t, etc. La valeur de 3% par an pour l'ann√©e sera encore plus √©lev√©e que lors de l'utilisation de la r√®gle pr√©c√©dente. <br><br>  Dans le cas o√π le diviseur annuel est accept√© √©gal √† 360 jours, l'int√©r√™t gagn√© en utilisant un tel diviseur est appel√© <strong>ordinaire</strong> ou <strong>commercial</strong> .  Si le diviseur est pris √©gal √† 365 ou, comme je le montrerai plus tard, √† 366 jours, l'int√©r√™t est appel√© exact. <br><br>  De toute √©vidence, les pourcentages ordinaires sont plus qu'exactes. <br><br>  Bien que la premi√®re r√®gle soit plus pr√©cise que la seconde, les deux ne sont pas assez pr√©cises. <br><br>  Pour √©liminer l'effet des ann√©es bissextiles sur les r√©sultats, il existe deux autres r√®gles. <br><br>  <strong>R√®gle (R3) ACT / 365, Japon.</strong>  Le calcul est effectu√© de la m√™me mani√®re que pour la r√®gle ACT / 365, mais lors du calcul de la dur√©e d'intervalle (num√©rateur de fraction), les dates de saut sont exclues.  Le diviseur annuel reste inchang√©. <br><br>  Selon Wiki: <br><blockquote>  Dans de nombreux pays europ√©ens, jusqu'au 18e si√®cle, le 29 f√©vrier √©tait consid√©r√© comme un jour inexistant, une date sans statut juridique.  Souvent, les transactions n'ont pas √©t√© effectu√©es ce jour-l√†, les paiements n'ont pas √©t√© effectu√©s, ils n'ont pas √©t√© vers√©s en dette, etc., en raison des difficult√©s li√©es √† l'aspect formel de la question et au r√®glement des affaires devant les tribunaux. </blockquote><br><br>  Une autre fa√ßon est li√©e au changement effectif du diviseur. <br><br>  <strong>R√®gle (R4) ACT / ACT basic.</strong>  Nous divisons la p√©riode souhait√©e en trois parties: <br><br><ul><li>  la premi√®re partie, de la date de d√©but √† la fin de l'ann√©e o√π se situe la date de d√©but, </li><li>  la troisi√®me partie - du d√©but de l'ann√©e o√π se situe la date de fin √† la date de fin, </li><li>  la deuxi√®me partie - 0 ou plusieurs ann√©es civiles compl√®tes entre la premi√®re et la troisi√®me partie. </li></ul><br>  Les dur√©es des premi√®re et troisi√®me parties sont obtenues en divisant le nombre de jours par le diviseur annuel 365 ou 366, selon qu'il s'agit d'une ann√©e bissextile?  La dur√©e de la deuxi√®me p√©riode se compose d'un nombre entier d'ann√©es civiles compl√®tes, par d√©finition, qu'elles soient bissextiles ou non.  La dur√©e en ann√©es de la p√©riode enti√®re est obtenue en additionnant les dur√©es de trois parties, repr√©sent√©es par trois nombres, dont la seconde est un tout, et la premi√®re et la troisi√®me sont fractionnaires. <br><br>  <strong>R√®gle (R5) ACT / ACT modification "courte", pour des p√©riodes inf√©rieures √† un an.</strong>  Dans ce cas, la dur√©e en jours est divis√©e par le diviseur annuel 365 ou 366, selon qu'il existe une date au 29 f√©vrier dans la p√©riode de recherche?  Une caract√©ristique de la r√®gle ACT / ACT courte est que si l'intervalle ne correspond pas √† l'ann√©e civile (ses extr√©mit√©s appartiennent aux ann√©es voisines), l'application des r√®gles de base et des r√®gles courtes entra√Ænera des r√©sultats diff√©rents. <br><br><h4>  Pratique occidentale </h4><br>  Dans la pratique occidentale, les r√®gles sont d√©crites diff√©remment.  Souvent, les m√™mes r√®gles en russe ont des noms diff√©rents et, en plus, pas un √† la fois. <br><br>  Les informations sont en outre bas√©es sur [2].  C'est Vicki, j'ai v√©rifi√© toutes les sources et utilis√© d'autres informations Google: dans les r√®gles avec un nombre exact de jours, tout est correct, mais dans les r√®gles avec un nombre approximatif de jours, il y a d'autres interpr√©tations des r√®gles, et souvent elles changent au fil du temps, donc, pour mettre les r√®gles en pratique, le nombre approximatif de jours o√π cet article ne suffit pas. <br><br>  <strong>R√®gle (W1) ISDA r√©el / r√©el.</strong>  Cette r√®gle donne le m√™me r√©sultat que (R4) ¬´ACT / ACT main¬ª, mais est formul√©e diff√©remment: l'intervalle est divis√© en ann√©es bissextiles et non bissextiles, qu'elles soient compl√®tes ou incompl√®tes, en outre, la somme des jours tombant dans ann√©es bissextiles, divis√© par 365, et la somme des jours des ann√©es non bissextiles est divis√©e par 366, les deux nombres sont additionn√©s. <br><br>  Autres noms de la r√®gle dans la pratique occidentale: Actual / Actual, Act / Act, Actual / 365, Act / 365.  Oui, le nom de famille est le m√™me que la r√®gle (R1), bien que l'essence de la r√®gle soit diff√©rente. <br><br>  <strong>R√®gle (W2) R√©el / 365 fixe.</strong>  Cette r√®gle r√©p√®te exactement la r√®gle (R1) ACT / 365 - le nombre de jours est divis√© par 365. <br><br>  Autres noms de la r√®gle dans la pratique occidentale: Act / 365 Fixed, A / 365 Fixed, A / 365F, anglais. <br><br>  <strong>R√®gle (W3) R√©el / 360.</strong>  Cette r√®gle r√©p√®te (R2) ACT / 360 - le nombre exact de jours est divis√© par 360. <br><br>  <strong>R√®gle (W4) R√©el / 364.</strong>  Le nombre de jours est divis√© par 364. Il n'a pas d'analogue dans la pratique russophone. <br><br>  <strong>R√®gle (W5) R√©el / 365L.</strong>  Il se compose de deux r√©glages: <br><ol><li>  Pour les paiements annuels.  Si la date est le 29 f√©vrier dans la p√©riode, alors le nombre de jours de la p√©riode est divis√© par le diviseur annuel 366, sinon 365, en ce sens, il co√Øncide avec la r√®gle (R5) ACT / ACT "modification courte". </li><li>  Si la fr√©quence des paiements diff√®re de celle annuelle.  Si la date de fin est dans une ann√©e bissextile (et n'est pas n√©cessairement √©gale au 29 f√©vrier), alors le diviseur annuel est 366, sinon 365. Dans la pratique russophone, il n'a pas d'analogue. </li></ol><br>  Un autre nom est ISMA-Year. <br><br>  <strong>R√®gle (W6) AFB r√©el / r√©el.</strong>  Il se compose de deux r√©glages: <br><ol><li>  Le principal pour les p√©riodes inf√©rieures √† un an: si la date est le 29 f√©vrier dans la p√©riode, alors le nombre de jours de la p√©riode est divis√© par le diviseur annuel 366, sinon 365, en ce sens, il co√Øncide √©galement avec la r√®gle R / ACT ACT / ACT ¬´modification courte¬ª . </li><li>  Prolong√©, pour des p√©riodes de plus d'un an: une ann√©e enti√®re enti√®re est d√©compt√©e de la date de fin √† la date de d√©but.  Pour un solde inf√©rieur √† un an, la r√®gle principale s'applique.  Le nombre d'ann√©es compl√®tes et la part de l'ann√©e selon la r√®gle de base sont r√©sum√©s. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a des nuances associ√©es au compte √† rebours il y a des ann√©es, si le compte √† rebours a eu lieu le 28 f√©vrier, et apr√®s un certain nombre d'ann√©es compl√®tes, l'ann√©e a √©t√© une ann√©e bissextile. </font><font style="vertical-align: inherit;">Dans ce cas, la date d'il y a n ans devrait √™tre adopt√©e le 29 f√©vrier. </font><font style="vertical-align: inherit;">J'ajoute que la question se pose √©galement si le compte √† rebours a √©t√© effectu√© √† partir du 29 f√©vrier et que le nombre d'ann√©es compl√®tes n'est pas un multiple de quatre et que l'ann√©e pr√©c√©dente n'√©tait donc pas une ann√©e bissextile. </font><font style="vertical-align: inherit;">Je ne suis pas entr√© dans les d√©tails ici. </font><font style="vertical-align: inherit;">Mais vous pouvez vous r√©f√©rer aux liens de [2]. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et ¬´cerise sur le g√¢teau¬ª, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√®gle (W7) 1/1. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre de jours est divis√© par le diviseur annuel 365,25. </font><font style="vertical-align: inherit;">Utilis√© pour les calculs li√©s √† l'inflation.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nombre de jours estim√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les r√®gles √©num√©r√©es ci-dessus √©taient bas√©es sur la dur√©e exacte en jours des p√©riodes civiles. Cependant, il existe parfois des sch√©mas bas√©s sur le d√©nombrement dit simplifi√© ou approximatif des jours. L'id√©e de ces r√©gimes est ¬´d'√©galiser¬ª la dur√©e de tous les mois √† 30 jours. Ainsi, l'ann√©e comprendra 12 mois de 30 jours, soit sur 360 jours. Par cons√©quent, le diviseur annuel (d√©nominateur de la fraction) pour ces r√®gles sera toujours 360, et le num√©rateur est calcul√© de mani√®re sp√©ciale. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âtant donn√© que le nombre exact de jours d'un pr√™t dans la plupart des cas, mais bien s√ªr, pas toujours, est plus qu'approximatif (comme on peut facilement le voir en d√©terminant le nombre moyen de jours dans un mois pour un an, qui est de 30,44), la m√©thode de calcul des int√©r√™ts avec le nombre exact de jours d'un pr√™t donne g√©n√©ralement croissance sup√©rieure √† celle approximative. [4]</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La version la plus simple de cette r√®gle, dite </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√®gle de base 30/360</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , est d√©crite comme suit (ci-apr√®s les informations sur le livre [1] - Pratique en langue russe): </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle de base 30/360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre approximatif de jours entre les dates est</font></font><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360 * (y2 - y1) + 30 * (m2 - m1) + (d2 - d1), </font></font></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o√π y, m, d - ann√©e, mois et jour aux deuxi√®me et premi√®re dates. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette r√®gle est apparue avant la cr√©ation des premiers appareils informatiques et a consid√©rablement r√©duit le co√ªt des op√©rations informatiques dans la pratique financi√®re. </font><font style="vertical-align: inherit;">Bien que le besoin de m√©thodes simplifi√©es ait maintenant disparu, n√©anmoins, ayant pris pied dans la pratique, par tradition, elles sont parfois utilis√©es √† l'heure actuelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La r√®gle s'applique avec une indication obligatoire d'une modification qui indique comment g√©rer les derniers jours des mois:</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pratique russophone </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donn√© par [1]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle (R6) 30/360 ISDA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si d1 = 31, alors d1 '= 30, sinon d1' = d1. </font><font style="vertical-align: inherit;">Si d2 = 31 et d1 '= 30, alors d2' = 30, sinon d2 '= d2. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle (R7) 30E / 360. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si d1 = 31, alors d1 '= 30, sinon d1' = d1. </font><font style="vertical-align: inherit;">Si d2 = 31, alors d2 '= 30, sinon d2' = d2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette r√®gle est une variante de la r√®gle ISDA 30/360, utilis√©e principalement en Europe, d'o√π l'√©tiquette ¬´E¬ª au nom de la r√®gle. </font><font style="vertical-align: inherit;">Elle ne diff√®re de la r√®gle ISDA 30/360 que lorsque la deuxi√®me date est √©galement la 31e. </font><font style="vertical-align: inherit;">La version europ√©enne le convertit toujours au 30√®me nombre, quelle que soit la premi√®re date. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle (R8) 30/360 PSA. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si d1 = 31 ou d1 est le dernier jour de f√©vrier, alors d1 '= 30, sinon d1' = d1. </font><font style="vertical-align: inherit;">Si d2 = 31 et d1 '= 30, alors d2' = 30, sinon d2 '= d2.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La description de la r√®gle SIA 30/360 dans [1] est tr√®s probablement une erreur, donc je ne la donnerai pas ici. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pratique occidentale </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donn√© selon [2]. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle (W8) 30/360 Base des obligations.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Identique √† (R6) 30/360 ISDA. Autre nom: 30A / 360. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle (W9) 30E / 360.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Identique √† (R7) 30E / 360. Autres noms: 30/360 ICMA, 30S / 360, base Eurobond (ISDA 2006), allemand sp√©cial. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle (W10) 30E / 360 ISDA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si d1 est le dernier jour du mois, alors d1 '= 30. Si d2 est le dernier jour PAS de f√©vrier, alors d2 '= 30. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autres noms: 30E / 360 ISDA, base Eurobond (ISDA 2000), allemand. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√®gle (W11) 30/360 SIA.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si d1 est le dernier jour de f√©vrier et d2 est le dernier jour de f√©vrier, alors d2 '= 30. Si d1 = 31 ou le dernier jour de f√©vrier, alors d1 '= 30, sinon d1' = d1. Si d1 '= 30 et d2 = 31, alors d2' = 30, sinon d2 '= d1.</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les r√®gles (R4) ACT / ACT, (W1) R√©el / R√©el ISDA, (W2) R√©el / 365 Fixe sont √©galement appel√©es ¬´pratique anglaise¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les r√®gles (R2) ACT / 360 et (W3) Actual / 360 sont √©galement appel√©es ¬´pratiques fran√ßaises¬ª. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les r√®gles (R7) 30E / 360, (W9) 30E / 360 et (W10) 30E / 360 ISDA sont √©galement appel√©es ¬´pratique allemande¬ª ou ¬´pratique allemande¬ª. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, en tenant compte de l'int√©r√™t exact et ordinaire, ainsi que du nombre exact et approximatif de jours pour le calcul de l'int√©r√™t, nous obtenons quatre m√©thodes pour calculer l'int√©r√™t simple (les noms des r√®gles sont indiqu√©s dans la pratique russophone):</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Int√©r√™t normal avec le nombre exact de jours (ACT / 360 - r√®gle bancaire), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pourcentages exacts avec le nombre exact de jours (ACT / 365, ACT / ACT), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Int√©r√™t normal avec un nombre approximatif de jours (30/360), </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pourcentages exacts avec un nombre approximatif de jours. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re m√©thode la plus utilis√©e est la r√®gle bancaire, moins souvent la deuxi√®me et la troisi√®me, et presque jamais la quatri√®me [1]. Et [4] dit: "... une option de calcul avec un int√©r√™t exact et un nombre approximatif de jours de pr√™t n'a aucun sens et ne s'applique pas." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les calculs ci-dessus de la dur√©e approximative des p√©riodes en fractions d'ann√©e montrent la non-banalit√© et la vari√©t√© des r√®gles appliqu√©es. Leur application (ainsi que leur origine) d√©pend du pays, de la devise, du type d'instrument financier, de l'association professionnelle, des accords.</font></font> [1] <br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONCLUSION:</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comment compter 3% dans mon cas avec les services publics en Ukraine? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse de la pratique judiciaire d'application de l'art. 625 du Code civil de l'Ukraine indique que la m√©thode (R1) ACT / 365 [3] est g√©n√©ralement utilis√©e, mais qu'elle n'est pas clairement formul√©e. Je pense que vous devez toujours appliquer (R4) ACT / ACT, et voici pourquoi: si vous accumulez 3% pour une ann√©e bissextile compl√®te en utilisant la m√©thode ACT / 365, le montant des int√©r√™ts sera √©gal √† 3,008219%, ce qui correspond √† la dette (ou √† la taille de l'organisme de pr√™t) de 1 million d'unit√©s mon√©taires donnera un exc√©dent de 82,19 UM plus de 3%, qui sont stipul√©s par le taux d'int√©r√™t annuel standardis√© en vertu de la loi. Cela deviendra particuli√®rement important avec l'accumulation progressive des int√©r√™ts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'appr√©cierais les commentaires, en particulier des employ√©s de banque. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources utilis√©es</font></font></strong> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) Bocharov, P.P., Kasimov, Yu.F. Math√©matiques financi√®res. Moscou: Gardariki, 2002 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2) Convention de comptage des jours, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.wikipedia.org/wiki/Day_count_convention</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3) Analyse de l'application de l'art. 625 du Code civil de l'Ukraine dans les proc√©dures civiles, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zib.com.ua/ua/74602-analiz_praktiki_zastosuvannya_st_625_civilnogo_kodeksu_ukrai.html</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4) Chetyrkin E.M. Math√©matiques financi√®res. Moscou: cas, 2005 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5) Conventions de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcul du nombre de</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jours et facteurs de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">cumul</font></a><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">docs.fincad.com/support/developerfunc/mathref/Daycount.htm</font></a></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6) Lettre d'information de la Cour supr√™me √©conomique d'Ukraine n ¬∞ 01-06 / 928/2012 du 17.07.2012, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zakon.rada.gov.ua/laws/show/v_928600-12</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et maintenant un petit code sur Oracle Database:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici le paquet que j'ai fait pour mon cas particulier - il calcule les co√ªts d'inflation et 3% par an pour l'Ukraine. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il n'y a pas de fonction d'agr√©gation dans Oracle Database qui multiplie les valeurs d'inflation. </font><font style="vertical-align: inherit;">Par cons√©quent, j'utilise la somme des logarithmes.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">Texte masqu√©</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, OVERHEAD_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>), INF_RATE_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> , INF_COEF_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_ACCUMULATED <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, INF_AMOUNT_MONTH <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_MONTH <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, INF_RATE <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, SKIP_INFLATION <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, DEBT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, DEBT_AMOUNT <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PAYMENT_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_DAYS <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_DAY <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_BEGIN_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span> , PCT_YEAR_END_DATE <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, PCT_YEAR_DAYS_CALC <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_YEAR_PCT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>, PCT_AMOUNT_PER_YEAR <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_OVERHEAD_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_OVERHEAD_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_INF_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> DEBT_WITH_PCT_AMOUNT_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> DEBT_WITH_PCT_AMOUNT_T; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> CALC_OVERHEADS_P <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> GET_DEBT_WITH_INF (p_debt_date_begin <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_debt_date_end <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>, p_last_collection_date <span class="hljs-built_in"><span class="hljs-built_in">date</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DEBT_WITH_INF_LIST_T <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ret_value DEBT_WITH_INF_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.ID, a.DEBT_DATE, a.DEBT_AMOUNT, a.PAYMENT_DATE, b.INF_MONTH, c.AVAL <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> add_months (trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= months_between (trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>), trunc (a.PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>) b <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> INFLATION c <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> c.ADATE = b.INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> c.TYP = <span class="hljs-string"><span class="hljs-string">'M'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a.DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE , <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (PAYMENT_DATE, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> trunc (p_last_collection_date, <span class="hljs-string"><span class="hljs-string">'month'</span></span>) = INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> SKIP_INFLATION <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_INF_AMOUNT_LIST_T is ret_value DEBT_WITH_INF_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION , <span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> INF_RATE <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span> <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unbounded</span></span> <span class="hljs-keyword"><span class="hljs-keyword">preceding</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>)) * <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_RATE_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date))) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED , (INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_COEF_ACCUMULATED , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> (((INF_RATE_ACCUMULATED - <span class="hljs-number"><span class="hljs-number">100</span></span>) / <span class="hljs-number"><span class="hljs-number">100</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT_ACCUMULATED <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_INF_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, INF_MONTH, INF_RATE, SKIP_INFLATION, INF_RATE_ACCUMULATED, INF_COEF_ACCUMULATED, INF_AMOUNT_ACCUMULATED , INF_AMOUNT_ACCUMULATED - lag (INF_AMOUNT_ACCUMULATED, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> INF_MONTH)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_INF_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> , DEBT_DATE , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">exp</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ln</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> SKIP_INFLATION = <span class="hljs-string"><span class="hljs-string">'Y'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> INF_RATE / <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>))) - <span class="hljs-number"><span class="hljs-number">1</span></span>) * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> INF_AMOUNT <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_INF (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, INF_AMOUNT) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_WITH_PCT_AMOUNT_LIST_T is ret_value DEBT_WITH_PCT_AMOUNT_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> T1 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> DEBTS a <span class="hljs-keyword"><span class="hljs-keyword">cross</span></span> <span class="hljs-keyword"><span class="hljs-keyword">apply</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p_last_collection_date) - <span class="hljs-keyword"><span class="hljs-keyword">extract</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">year</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PAYMENT_DATE) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> DEBT_DATE <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> p_debt_date_begin <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> p_debt_date_end ) , T2 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) - <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T1) , T3 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS , <span class="hljs-number"><span class="hljs-number">0.03</span></span> / PCT_YEAR_DAYS <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T2) , T4 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY , <span class="hljs-keyword"><span class="hljs-keyword">greatest</span></span> (PAYMENT_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'01.01.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_BEGIN_DATE , <span class="hljs-keyword"><span class="hljs-keyword">least</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">to_date</span></span> (<span class="hljs-string"><span class="hljs-string">'31.12.'</span></span>||PCT_YEAR, <span class="hljs-string"><span class="hljs-string">'DD-MM-YYYY'</span></span>), p_last_collection_date) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_END_DATE <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T3) , T5 <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE , PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_DAYS_CALC , (PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_YEAR_PCT_PER_YEAR , <span class="hljs-keyword"><span class="hljs-keyword">round</span></span> ((PCT_YEAR_END_DATE - PCT_YEAR_BEGIN_DATE + <span class="hljs-number"><span class="hljs-number">1</span></span>) * PCT_YEAR_PCT_PER_DAY * DEBT_AMOUNT, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> PCT_AMOUNT_PER_YEAR <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T4) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_WITH_PCT_AMOUNT_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, DEBT_AMOUNT, PAYMENT_DATE, PCT_YEAR, PCT_YEAR_DAYS, PCT_YEAR_PCT_PER_DAY, PCT_YEAR_BEGIN_DATE, PCT_YEAR_END_DATE, PCT_YEAR_DAYS_CALC, PCT_YEAR_PCT_PER_YEAR, PCT_AMOUNT_PER_YEAR) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> T5; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; function GET_DEBT_WITH_PCT_AMOUNT_TOTAL (p_debt_date_begin date, p_debt_date_end date, p_last_collection_date date) return DEBT_OVERHEAD_LIST_T is ret_value DEBT_OVERHEAD_LIST_T; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> DEBT_OVERHEAD_T (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE, <span class="hljs-keyword"><span class="hljs-keyword">sum</span></span> (PCT_AMOUNT_PER_YEAR)) <span class="hljs-keyword"><span class="hljs-keyword">bulk</span></span> <span class="hljs-keyword"><span class="hljs-keyword">collect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ret_value <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> (CALC_OVERHEADS_P.GET_DEBT_WITH_PCT_AMOUNT (p_debt_date_begin, p_debt_date_end, p_last_collection_date)) <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, DEBT_DATE; return ret_value; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466401/">https://habr.com/ru/post/fr466401/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466379/index.html">Ex√©cutez le logiciel ¬´desktop¬ª sur le microcontr√¥leur</a></li>
<li><a href="../fr466381/index.html">Comment les ampoules LED Era ont chang√© en 2019</a></li>
<li><a href="../fr466383/index.html">Cryptocurrency Ocean: examen des 50 meilleurs projets avec CoinMarketCap</a></li>
<li><a href="../fr466385/index.html">Comprendre les courtiers de messages. Apprentissage de la m√©canique de la messagerie via ActiveMQ et Kafka. Chapitre 1</a></li>
<li><a href="../fr466397/index.html">Nous reprogrammons le caissier et imprimons dessus Keanu Reeves. Partie 2. Logiciel PC</a></li>
<li><a href="../fr466403/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 35. Protocole de jonction DTP dynamique</a></li>
<li><a href="../fr466405/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 36. Channel Protocol STP</a></li>
<li><a href="../fr466407/index.html">Culture de recrutement dans les grandes soci√©t√©s de statistiques de Glassdoor</a></li>
<li><a href="../fr466409/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 37. STP: S√©lection du pont racine, fonctions de protection PortFast et BPDU. Partie 1</a></li>
<li><a href="../fr466413/index.html">√âchange de sites pour Bitrix et 1C: r√©soudre les principaux probl√®mes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>