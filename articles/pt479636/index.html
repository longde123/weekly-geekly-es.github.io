<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ü™Ô∏è ‚òÆÔ∏è üßëüèø‚Äçü§ù‚Äçüßëüèª Pilha de navega√ß√£o pr√≥pria. Melhor que ROS? üòº üóø ü§∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este √© o segundo artigo da equipe setUP sobre nossa experi√™ncia na cria√ß√£o de rob√¥s aut√¥nomos para competi√ß√µes Eurobot Open e no uso de ROS para isso....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pilha de navega√ß√£o pr√≥pria. Melhor que ROS?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479636/"> Este √© o segundo artigo da equipe setUP sobre nossa experi√™ncia na cria√ß√£o de rob√¥s aut√¥nomos para competi√ß√µes Eurobot Open e no uso de ROS para isso. <br><br>  <a href="https://habr.com/ru/post/478836/">O primeiro artigo √© sobre a mec√¢nica e a arquitetura geral dos rob√¥s.</a> <br><br>  Os rob√¥s viajam em um campo plano e a maioria dos obst√°culos √© conhecida com anteced√™ncia, no entanto, oponentes insidiosos podem tentar roubar nossos recursos (e √†s vezes queremos comer algumas d√∫zias de pontos extras), enquanto queremos chegar ao ponto desejado o mais r√°pido poss√≠vel e n√£o tocar nos obst√°culos.  De uma c√¢mera externa em campo, obtemos dados sobre a posi√ß√£o do inimigo e sabemos onde ele est√° agora.  No entanto, n√£o basta conhecer sua posi√ß√£o - voc√™ precisa poder usar essas informa√ß√µes. <br><br>  Hoje vamos tentar dirigir do ponto A ao ponto B sem ter viajado ao longo da cauda de um gato que adormeceu no campo.  Em particular, explicaremos como constru√≠mos uma rota e controlamos a velocidade do rob√¥, al√©m de como iniciar tudo em nosso computador. <br><br><img src="https://habrastorage.org/webt/om/x0/a6/omx0a6wfefbht9c1pialld-9vqy.png"><br><a name="habracut"></a><br><h3>  Tentando sobreviver com um pouco de sangue </h3><br>  Ao resolver esse problema, voc√™ pode pegar material pronto, elaborado por profissionais, para que n√£o haja tormento e inven√ß√£o da pr√≥xima ‚Äúbicicleta‚Äù.  Usamos uma plataforma omni-wheeled, portanto, embora tenha havido uma tentativa de usar uma plaina local pronta da ROS, por v√°rias raz√µes, eles acharam isso pouco promissor.  Abaixo, voc√™ pode ver quantas coisas o designer de um planador padr√£o precisa: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @class TrajectoryPlanner * @brief Computes control velocities for a robot given a costmap, a plan, and the robot's position in the world. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlanner</span></span></span><span class="hljs-class">{</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrajectoryPlannerTest</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//Need this for gtest to work public: /** * @brief Constructs a trajectory controller * @param world_model The WorldModel the trajectory controller uses to check for collisions * @param costmap A reference to the Costmap the controller should use * @param footprint_spec A polygon representing the footprint of the robot. (Must be convex) * @param inscribed_radius The radius of the inscribed circle of the robot * @param circumscribed_radius The radius of the circumscribed circle of the robot * @param acc_lim_x The acceleration limit of the robot in the x direction * @param acc_lim_y The acceleration limit of the robot in the y direction * @param acc_lim_theta The acceleration limit of the robot in the theta direction * @param sim_time The number of seconds to "roll-out" each trajectory * @param sim_granularity The distance between simulation points should be small enough that the robot doesn't hit things * @param vx_samples The number of trajectories to sample in the x dimension * @param vtheta_samples The number of trajectories to sample in the theta dimension * @param pdist_scale A scaling factor for how close the robot should stay to the path * @param gdist_scale A scaling factor for how aggresively the robot should pursue a local goal * @param occdist_scale A scaling factor for how much the robot should prefer to stay away from obstacles * @param heading_lookahead How far the robot should look ahead of itself when differentiating between different rotational velocities * @param oscillation_reset_dist The distance the robot must travel before it can explore rotational velocities that were unsuccessful in the past * @param escape_reset_dist The distance the robot must travel before it can exit escape mode * @param escape_reset_theta The distance the robot must rotate before it can exit escape mode * @param holonomic_robot Set this to true if the robot being controlled can take y velocities and false otherwise * @param max_vel_x The maximum x velocity the controller will explore * @param min_vel_x The minimum x velocity the controller will explore * @param max_vel_th The maximum rotational velocity the controller will explore * @param min_vel_th The minimum rotational velocity the controller will explore * @param min_in_place_vel_th The absolute value of the minimum in-place rotational velocity the controller will explore * @param backup_vel The velocity to use while backing up * @param dwa Set this to true to use the Dynamic Window Approach, false to use acceleration limits * @param heading_scoring Set this to true to score trajectories based on the robot's heading after 1 timestep * @param heading_scoring_timestep How far to look ahead in time when we score heading based trajectories * @param meter_scoring adapt parameters to costmap resolution * @param simple_attractor Set this to true to allow simple attraction to a goal point instead of intelligent cost propagation * @param y_vels A vector of the y velocities the controller will explore * @param angular_sim_granularity The distance between simulation points for angular velocity should be small enough that the robot doesn't hit things */ TrajectoryPlanner(WorldModel&amp; world_model, const costmap_2d::Costmap2D&amp; costmap, std::vector&lt;geometry_msgs::Point&gt; footprint_spec, double acc_lim_x = 1.0, double acc_lim_y = 1.0, double acc_lim_theta = 1.0, double sim_time = 1.0, double sim_granularity = 0.025, int vx_samples = 20, int vtheta_samples = 20, double pdist_scale = 0.6, double gdist_scale = 0.8, double occdist_scale = 0.2, double heading_lookahead = 0.325, double oscillation_reset_dist = 0.05, double escape_reset_dist = 0.10, double escape_reset_theta = M_PI_2, bool holonomic_robot = true, double max_vel_x = 0.5, double min_vel_x = 0.1, double max_vel_th = 1.0, double min_vel_th = -1.0, double min_in_place_vel_th = 0.4, double backup_vel = -0.1, bool dwa = false, bool heading_scoring = false, double heading_scoring_timestep = 0.1, bool meter_scoring = true, bool simple_attractor = false, std::vector&lt;double&gt; y_vels = std::vector&lt;double&gt;(0), double stop_time_buffer = 0.2, double sim_period = 0.1, double angular_sim_granularity = 0.025);</span></span></code> </pre> <br>  <i>Este √© um exemplo de inicializa√ß√£o de par√¢metros para regula√ß√£o de velocidades e trajet√≥ria como um todo.</i> <br><br>  Par√¢metros importantes para um c√°lculo completo: <br><br><ol><li>  Par√¢metro world_model. </li><li>  Par√¢metro do mapa de custo: um link para um mapa contendo obst√°culos, bem como sua "extens√£o virtual", levando em considera√ß√£o a poss√≠vel colis√£o. </li></ol><br>  Das vantagens da pilha padr√£o, √© poss√≠vel destacar a disponibilidade da documenta√ß√£o e a capacidade de encontrar informa√ß√µes nos f√≥runs.  <a href="https://github.com/ros-planning/navigation" rel="nofollow">Voc√™ pode ler mais no site oficial com documenta√ß√£o</a> <br><br>  √â importante mencionar que os pacotes ROS foram escritos para plataformas de duas rodas e, no Omni, eles foram otimizados aumentando o √¢ngulo de rota√ß√£o dispon√≠vel ao subir at√© 360 graus, o que certamente √© uma muleta. <br><br>  Depois de analisar o projeto, percebemos que haveria uma dificuldade em estudar e suplementar, al√©m de haver muitos chips pesados ‚Äã‚Äãdos quais n√£o precisamos.  Parece, deixe-os estar, mas usamos o Odroid xu4 (o processador do qual ainda estava na Samsung s5), e os resultados de desempenho foram deprimentes e o espa√ßo para algo mais poderoso (e o processador raspberry 4 e o jetson nano fumam nervosamente √† parte, em compara√ß√£o com com ele) n√£o.  Eu tive que abandonar a pilha padr√£o e tentar criar o planejador global, planejador local e regulador de trajet√≥ria <br><br><img src="https://habrastorage.org/webt/ij/qe/es/ijqeesrak1vuhjqfr1ij6exr4_a.jpeg"><br><br><h3>  Plaina global, planejador local, regulador de trajet√≥ria e tudo </h3><br>  Planadores globais e locais s√£o necess√°rios para obter dire√ß√µes para o destino.  Por que a separa√ß√£o √© necess√°ria?  Por que voc√™ n√£o pode simplesmente pegar o <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> e mont√°-lo?  Como regra, o planejador global, ao construir uma rota, pode usar o mapa inteiro em seu trabalho, de modo que o algoritmo deve ser o mais r√°pido poss√≠vel, talvez com algumas simplifica√ß√µes.  Para suavizar essas simplifica√ß√µes, eles tamb√©m usam o planejador local, que, com base no resultado do planejador global (ou apenas em uma √°rea limitada ao redor do rob√¥), tenta levar em considera√ß√£o todas as nuances. <br><br>  Depois que constru√≠mos a rota, sabemos para onde o rob√¥ deve ir, mas como ele pode ser informado sobre isso?  Para isso, existe um regulador de trajet√≥ria.  Ele calcula em que velocidade e em que dire√ß√£o o rob√¥ deve se mover no momento para n√£o se desviar da trajet√≥ria.  De v√°rias maneiras, este pacote √© respons√°vel pela rapidez e beleza do rob√¥. <br><br>  Al√©m dessas tr√™s entidades, h√° um quarto - um servidor de mapas, que permite processar convenientemente o estado do mundo.  Ele define como descrevemos o mapa, que possibilidades temos ao trabalhar com o mapa e, de v√°rias maneiras, determinamos a velocidade dos planadores. <br><br>  Antes de prosseguir com a descri√ß√£o da pilha de navega√ß√£o, seria bom descrever as raz√µes pelas quais cost_map foi escolhido como servidor de mapas.  Em geral, tentamos op√ß√µes diferentes para o manipulador de mapas: <a href="https://github.com/IntelRealSense/realsense-ros/tree/occupancy-mapping" rel="nofollow">Occupancy_grid</a> , <a href="http://wiki.ros.org/grid_map" rel="nofollow">Grid_map</a> , <a href="https://github.com/stonier/cost_map" rel="nofollow">Cost_map</a> , mas resolvemos o √∫ltimo. <br><br>  Raz√µes: <br><br><ol><li>  Interaja convenientemente com o mapa. </li><li>  Existem v√°rios iteradores que precisamos de v√°rias formas (circular, linear, retangular etc.). </li><li>  Voc√™ pode armazenar v√°rias camadas de mapa com diferentes par√¢metros. </li><li>  Bom gerenciamento de mem√≥ria. </li><li>  E o mais importante, velocidade.  O mapa de grade funciona com tipo duplo e, por isso, √© v√°rias vezes mais lento que os servidores de mapa que usam o int8 para funcionar. </li></ol><br>  Apesar do fato de a grade de ocupa√ß√£o tamb√©m funcionar com int8, ela n√£o pode se gabar da mesma usabilidade, ent√£o tive que abandon√°-la. <br><br>  No mapa, precisamos saber onde est√£o as zonas livres, perigosas e irresist√≠veis.  Para cada objeto que est√° no campo, podemos ajustar o campo de infla√ß√£o - um valor que, dependendo da dist√¢ncia do objeto, caracteriza a permeabilidade da c√©lula.  A infla√ß√£o √© a cauda do gato, √© f√°cil n√£o notar, mas voc√™ vai se arrepender por muito tempo.  Mapeamos rob√¥s inimigos e adicionamos uma zona de perigo que somente o planejador local leva em considera√ß√£o.  Planejador global ignora todos os pontos, se eles n√£o s√£o um obst√°culo. <br><br><h4>  Planejador global </h4><br>  A primeira coisa que escreveram na navega√ß√£o √© o planejador global.  √â baseado no algoritmo theta *.  Em resumo, este √© um <a href="https://ru.wikipedia.org/wiki/A*" rel="nofollow">A *</a> modificado, onde a √™nfase est√° em encontrar o n√≥ pai, que pode ser alcan√ßado diretamente, ou seja,  n√£o h√° obst√°culos para ela.  Isso nos permite criar caminhos convenientes e suaves que s√£o usados ‚Äã‚Äãno planejador local. <br><br><img src="https://habrastorage.org/webt/it/qs/e4/itqse4uuumbbzu8rxws07gapbn8.png"><br>  <i>Compara√ß√£o de A * e teta *</i> <br><br>  Para o planejador global, temos um arquivo com par√¢metros (params / path_planner.yaml) que descreve t√≥picos e t√≥picos do mapa com a localiza√ß√£o de todos os rob√¥s (para todos os quatro rob√¥s em campo, onde "nulo" √© o t√≥pico com dados sobre o rob√¥ atual). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># small robot debug param list robot_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"small"</span></span></span><span class="hljs-meta"> ########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: 0.45 cost_map_server/little_robot_size: 0.45 cost_map_server/cube_size: 0.11 cost_map_server/inscribed_radius: 0.3 cost_map_server/inflation_radius: 0.3 cost_map_server/inflation_exponential_rate: 0.6 cost_map_server/big_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/big_robot"</span></span></span><span class="hljs-meta"> cost_map_server/big_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot1"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot1: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"null"</span></span></span><span class="hljs-meta"> cost_map_server/small_robot2: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/aruco/enemy_robot2"</span></span></span><span class="hljs-meta"> cost_map_server/collision: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"collision"</span></span></span><span class="hljs-meta"> cost_map_server/image_resource_name: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span></span><span class="hljs-meta"> cost_map_server/min_diff_points: 0.01 ########################### ### path_planner params ### ########################### global_planner/path_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/path_force_layer: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"obstacle_inflation_layer"</span></span></span><span class="hljs-meta"> global_planner/frame_id: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"map"</span></span></span><span class="hljs-meta"> global_planner/current_position: </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"real_corr"</span></span></span><span class="hljs-meta"> global_planner/path_filter_epsilon: 0</span></span></code> </pre> <br>  Tamb√©m indica: <br><br><ol><li>  um dos algoritmos que voc√™ pode escolher para construir uma rota, </li><li>  nomes de camadas nas quais vamos construir a pr√≥pria rota, </li><li>  um t√≥pico sobre a nossa posi√ß√£o, onde os dados filtrados s√£o emitidos (no nosso caso, √© uma combina√ß√£o de dados de localiza√ß√£o da c√¢mera e odometria). </li></ol><br>  O pr√≥prio algoritmo de busca de caminho - Theta Star - √© destacado em um arquivo separado (src / global_planner.cpp) para a conveni√™ncia de adicionar novos algoritmos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cost_so_far[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>]; PriorityPoint neighbors[<span class="hljs-number"><span class="hljs-number">8</span></span>]; PriorityPoint current; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> come_from[<span class="hljs-number"><span class="hljs-number">300</span></span>][<span class="hljs-number"><span class="hljs-number">200</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makePath_ThetaStar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;cost_map::Index&gt; &amp;path, PriorityPoint start, PriorityPoint goal, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> layer, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> grid_cost, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> only_cost)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::priority_queue&lt;PriorityPoint, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;PriorityPoint&gt;, myCompare&gt; openSet; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_x = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_y = cost_map.getSize()[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fill_n(*cost_so_far, max_x * max_y, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;::max()); cost_so_far[start.x][start.y] = <span class="hljs-number"><span class="hljs-number">0</span></span>; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = start.x; come_from[start.x][start.y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = start.y; openSet.push(start); grid_cost=<span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!openSet.empty()) { current = openSet.top(); openSet.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == goal) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current.GetNeighbors(neighbors); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> current_cost = cost_so_far[current.x][current.y]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> parent_carent[<span class="hljs-number"><span class="hljs-number">2</span></span>] ={come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>], come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!neighbors[i].OnMap(max_x, max_y)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> onLine = lineOfSight(parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>], parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>], neighbors[i].x, neighbors[i].y, cost_map, layer, grid_cost + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onLine) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = cost_so_far[parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]][parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + HeuristicEvclid(parent_carent, neighbors[i], grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority = HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">0</span></span>]; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = parent_carent[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> neighbor_price = cost_map.at(layer, cost_map::Index({neighbors[i].x, neighbors[i].y})) + neighbors[i].priority; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> new_cost = current_cost + neighbor_price; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (new_cost &lt; cost_so_far[neighbors[i].x][neighbors[i].y]) { cost_so_far[neighbors[i].x][neighbors[i].y] = new_cost; neighbors[i].priority =HeuristicEvclid(neighbors[i], goal, grid_cost*<span class="hljs-number"><span class="hljs-number">10</span></span>) + new_cost; openSet.push(neighbors[i]); come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">0</span></span>] = current.x; come_from[neighbors[i].x][neighbors[i].y][<span class="hljs-number"><span class="hljs-number">1</span></span>] = current.y; } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (only_cost) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cost_so_far[current.x][current.y]; } path.clear(); PriorityPoint temp_point; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (current != start) { path.push_back({current.x, current.y}); temp_point.x = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">0</span></span>]; temp_point.y = come_from[current.x][current.y][<span class="hljs-number"><span class="hljs-number">1</span></span>]; current = temp_point; } path.push_back({current.x, current.y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Um algoritmo para remover pontos extras no caminho RamerDouglasPeucker tamb√©m √© alocado para um arquivo separado. <br>  Ele remove pontos do caminho se estiver al√©m de uma determinada dist√¢ncia da linha que conecta dois pontos vizinhos. <br><br><img src="https://habrastorage.org/webt/en/_9/dw/en_9dw6khdarxbyf7gvrhpqg7b4.jpeg"><br><br><h4>  Planejador local </h4><br>  Ele trabalha para n√≥s com base na descida do gradiente em um campo potencial.  Como entrada, o caminho do planejador global.  No entanto, isso n√£o √© tudo o que ele √© capaz.  No local_planner, existem servi√ßos internos para escolher o modo de constru√ß√£o do caminho.  Existem dois modos de opera√ß√£o no total: o modo de pontos de deslocamento ao longo do gradiente, usando v√°rias passagens no mapa, bem como o modo de deslocamento, no qual calculamos imediatamente o incremento em duas coordenadas e movemos o ponto para a borda da zona segura.  Se o ponto cair em v√°rias dessas zonas, passamos para os locais de seu cruzamento, porque √© mais seguro. <br><br>  O modo de opera√ß√£o √© o seguinte: se n√£o houver obst√°culo no caminho da itera√ß√£o anterior, quebramos o caminho a cada 2 cm e o deslocamos ao longo do gradiente, caso contr√°rio, usamos o segundo modo de opera√ß√£o do planejador local. <br><br>  A segunda op√ß√£o √© bastante leve e, como o planejador global, n√£o carrega muito o processador.  Usamos v√°rias vers√µes desse algoritmo e v√°rias manipula√ß√µes com o mapa.  Por exemplo, tentamos escrever um gr√°fico no qual os v√©rtices s√£o encontrados a cada 10 cm e s√£o deslocados no m√°ximo em 4 cm, ap√≥s o qual o algoritmo de Dijkstra foi usado no gr√°fico obtido para encontrar a menor dist√¢ncia.  O terminal neste caso usa o ponto de deslocamento mais pr√≥ximo.  Mas esse algoritmo era mais adequado para o planejador global e decidimos abandonar essa implementa√ß√£o. <br><br>  Tamb√©m tentamos usar a constru√ß√£o de caminhos do zero usando o m√©todo de descida de gradiente.  Este m√©todo foi o primeiro que decidimos escrever.  Acabou n√£o sendo eficiente em mem√≥ria (ocupava mais de 400 mb de RAM pura, pois usava um mapa de custos a cada passagem) e lento.  O controle de frequ√™ncia foi desativado devido √† baixa otimiza√ß√£o e a velocidade foi inferior a 30 vezes por segundo, o que n√£o nos convinha. <br><br>  Como resultado, decidimos usar a descida do gradiente em um campo potencial com base no caminho da plaina global.  Acabou sendo um algoritmo leve e relativamente simples, que nos conv√©m completamente em termos de qualidade do caminho, tempo de trabalho e quantidade de RAM usada na regi√£o de 100-150 mb, o que √© v√°rias vezes menor do que nas primeiras itera√ß√µes de desenvolvimento. <br><br><img src="https://habrastorage.org/webt/sg/oq/mo/sgoqmogivjs8elhylt74oqjqrdw.png"><br>  <i>Um exemplo de deslocamento de caminho por uma plaina local</i> <br><br>  Diferentemente do global_planner, os par√¢metros no local_planner s√£o extremamente pequenos, devido √† sua simplicidade, porque todas as tarefas mais importantes est√£o no global_planner: <br><br><pre> <code class="cpp hljs">grid_map_server/big_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/big_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot1 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> grid_map_server/small_robot2 : <span class="hljs-number"><span class="hljs-number">0.4</span></span> local_planner/radius : <span class="hljs-number"><span class="hljs-number">0.15</span></span> global_planner/frame_id : <span class="hljs-string"><span class="hljs-string">"map"</span></span></code> </pre> <br>  Nesse caso, configuramos: <br><br><ul><li>  Raios de zonas seguras para cada um dos rob√¥s. </li><li>  Deslocamento m√°ximo do caminho pela plaina local. </li><li>  O nome da camada de mapa com a qual estamos trabalhando. </li></ul><br>  Em uma classe separada, todas as fun√ß√µes mais importantes foram alocadas.  Nesse caso, √© uma reparti√ß√£o recursiva do caminho, a cria√ß√£o de um planador e construtores e destruidores virtuais. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Planner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Planner(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> inflation_radius_, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> frame_id_) { inflation_radius = inflation_radius_; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">200</span></span>; j++) our_map[i][j] = <span class="hljs-number"><span class="hljs-number">3000.0</span></span>; } OurPath-&gt;poses.resize(<span class="hljs-number"><span class="hljs-number">50</span></span>); geometry_msgs::Pose pose; pose.position.x = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; pose.position.y = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">50</span></span>; i++) { OurPath-&gt;poses[i].pose = pose; } frame_id = frame_id_; } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Planner() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdatePath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ros::Publisher move_pub; ros::Publisher BigEnemyPub; ros::Publisher LittleEnemyPub; ros::Publisher local_path_publisher; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-comment"><span class="hljs-comment">// virtual double Calculate_Path_Len(); nav_msgs::Path* recursive_path(nav_msgs::Path *path, std::pair&lt;double, double&gt; start, std::pair&lt;double, double&gt; end, double epsilon, int &amp;index) { if (CalcDistance(start, end) &lt; (epsilon) || path-&gt;poses.size() &gt; 200) return path; double start_x = (start.first + end.first) / 2.0; double start_y = (start.second + end.second) / 2.0; index = find_out(path, start); geometry_msgs::PoseStamped pose; pose.pose.position.x = start_x; pose.pose.position.y = start_y; path-&gt;poses.insert(path-&gt;poses.begin() + index, pose); recursive_path(path, start, std::pair&lt;double, double&gt;{start_x, start_y}, epsilon, index); recursive_path(path, std::pair&lt;double, double&gt;{start_x, start_y}, end, epsilon, index); } int find_out(nav_msgs::Path *path, pair_double point) { int index = 0; for (int i = 0; i &lt; path-&gt;poses.size(); i++) if (path-&gt;poses[i].pose.position.x == point.first &amp;&amp; path-&gt;poses[i].pose.position.y == point.second) return ++i; return index; } void add_in_path(nav_msgs::Path* Path, geometry_msgs::PoseStamped pose, int&amp; Index) { Path-&gt;poses[Index % max_size] = pose; Index++; } double inflation_radius; double our_map[300][200]; int max_size = 49; std::string frame_id; nav_msgs::Path *path = new nav_msgs::Path; nav_msgs::Path *OurPath = new nav_msgs::Path; };</span></span></code> </pre> <br>  A classe LocalPlanning foi herdada dela, onde est√° localizado todo o n√∫cleo do planador, ou seja, deslocando pontos para a borda da zona segura e decidindo o que fazer com o caminho especificamente. <br><br>  Todas as outras fun√ß√µes s√£o destacadas em um arquivo separado fichi.hpp e a descida gradiente em potencial_field.hpp.  Abaixo est√° uma captura instant√¢nea deste arquivo, que mostra as fun√ß√µes para criar um campo potencial no mapa cost_map: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcAttractivePotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(grid_map::Index index, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">0</span></span>] - goalx, <span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(index[<span class="hljs-number"><span class="hljs-number">1</span></span>] - goaly, <span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalcPotential</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> startx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> starty, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goalx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> goaly, cost_map::CostMap &amp;cost_map, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (&amp;our_map)[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">300</span></span></span></span><span class="hljs-function"><span class="hljs-params">][</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">200</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Use some magic for normalisation of Field double max_distance = (CalcAttractivePotential(grid_map::Index(startx, starty), goalx, goaly) + 15); if (max_distance == 0.0) { max_distance = 0.01; } for (cost_map::CircleIterator iterator(cost_map, grid_map::Position(startx / 100.0, starty / 100.0), max_distance / 100.); !iterator.isPastEnd(); ++iterator) { try { grid_map::Index index(*iterator); double uf; uf = cost_map.at("obstacle_inflation_layer", *iterator); // if we on free podouble - field is more less then if it not free podouble if ( uf &gt;= 10) { uf = 3000.0; // CP - is const variable } else uf += CalcAttractivePotential(index, goalx, goaly)/max_distance * 256; our_map[299-index(0)][199-index(1)] = uf; } catch(std::exception&amp; e) { ROS_INFO("Exception! %s", e.what() ); } } }</span></span></code> </pre> <br><h4>  Regulador de traject√≥ria </h4><br>  Por √∫ltimo, mas n√£o menos importante, √© o regulador de trajet√≥ria.  Ele √© respons√°vel por converter o caminho do planejador local em um caminho e fornece a velocidade da etapa atual. <br><br>  Sua primeira vers√£o, que usamos na final do Eurobot 2018, √© uma mistura do controlador pid de acelera√ß√£o e frenagem, onde o vetor √© normalizado para o pr√≥ximo ponto no caminho, em rela√ß√£o √† dist√¢ncia at√© o ponto final. <br><br>  O controlador PID, em resumo, √© a soma dos tr√™s estados do sistema que ajudam a corrigir erros aleat√≥rios e do sistema que √†s vezes ocorrem. <br><br>  Essas fun√ß√µes foram selecionadas empiricamente e dependem da dist√¢ncia at√© o ponto final no caminho (pode ser quadr√°tica, c√∫bica, inversa, mas depois estabelecemos a quadr√°tica).  Isso funcionou, mas a √∫nica coisa que n√£o nos convinha era que o rob√¥ n√£o podia travar no tempo a velocidades acima de 0,7 metros por segundo.  Portanto, quando chegou a hora, decidimos reconstruir todo o algoritmo. <br><br>  A primeira itera√ß√£o no caminho para a nova trajet√≥ria foi a substitui√ß√£o do vetor para o qual est√°vamos indo.  Agora era a soma dos vetores para os pr√≥ximos tr√™s com diferentes coeficientes.  A segunda itera√ß√£o estava escrevendo Minimum Jerk.  Em resumo, trata-se de uma constru√ß√£o de um polin√¥mio do 5¬∫ grau, em que as coordenadas x e y dependem da hora de chegada a cada ponto. <br><br><img src="https://habrastorage.org/webt/ho/mw/hd/homwhdagbnkgdlrigettcc6yook.png"><br>  <i>A figura mostra um gr√°fico de uma das coordenadas versus o tempo, bem como a velocidade ao longo dessa coordenada</i> <br><br>  Esse tipo de regulador de trajet√≥ria nos convinha mais, pois exigia menos manipula√ß√£o com a sele√ß√£o de diferentes coeficientes, porque todos os coeficientes s√£o os valores no polin√¥mio, que foram calculados com base no tempo de chegada, velocidade e acelera√ß√£o atuais, velocidade de sa√≠da e acelera√ß√£o. <br><br>  O resultado da reescrita da trajet√≥ria foi que conseguimos dobrar a velocidade m√©dia do rob√¥. <br><br>  Como nos dois casos anteriores, todas as principais fun√ß√µes s√£o destacadas em um arquivo separado para facilitar a intera√ß√£o.  Desta vez, a classe PlannerTrajectory √© respons√°vel por construir uma trajet√≥ria baseada no MinimumJerk <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> velocity; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> acceleration; State(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> v_, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a_) : velocity(v_), acceleration(a_) {} State() { velocity = <span class="hljs-number"><span class="hljs-number">0</span></span>; acceleration = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlannerTrajectory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: nav_msgs::Path global_path; cost_map::CostMap *costmap_ptr; geometry_msgs::PoseStamped Goal_pred; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_x; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; trajectory_y; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> average_velocity = <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Defualt or get from param // double max_velocity = 100; double coef_x[6]; double coef_y[6]; int frequency = 30; // Defualt or get from param // int index; public: PlannerTrajectory(cost_map::CostMap *costmap_, const int &amp;frequency_, const double &amp;max_velocity_, const double &amp;average_velocity_) { average_velocity = average_velocity;; max_velocity = max_velocity_; costmap_ptr = costmap_; frequency = frequency_; Goal_pred.pose.position.x = 0.0; Goal_pred.pose.position.y = 0.0; }</span></span></code> </pre> <br>  <i>A foto mostra todas as vari√°veis ‚Äã‚Äãdeclaradas que usamos.</i> <br><br>  Todo o resto √© destacado em outro arquivo (include / trajectory_regulator.h): recebendo pontos de t√≥picos, decidindo se deve ir para o pr√≥ximo ponto (se estiver em um obst√°culo, n√£o estamos indo) e muito mais. <br><br><h3>  Migrando para o ROS Melodic </h3><br>  At√© o ano passado, usamos o lan√ßamento do ROS - ROS Kinetic.  Ele geralmente nos convinha, mas seu apoio est√° chegando ao fim no pr√≥ximo ano, e muitos dos pacotes que precisamos come√ßaram a sair exclusivamente para o ROS Melodic.  E ent√£o descobriu-se que o costmap_server que usamos n√£o est√° sob Melodic. <br><br>  Ocorreu um problema ao processar os dados dos cart√µes. <br><br>  Escolhemos o mapa da grade, pois a pilha √© semelhante, mas o in√≠cio do mapa est√° em um local diferente e os valores do pr√≥prio mapa variam de 0 a 1. Isso se tornou um grande problema em toda a pilha de navega√ß√£o.  Se anteriormente, o planejador global era lan√ßado 50 vezes por segundo (havia limita√ß√µes de frequ√™ncia e, portanto, o processador n√£o era muito usado, mesmo na metade de um segmento), agora ele preparava o caminho a cada dois segundos e o considerava ruim: carregava completamente um n√∫cleo.  Em 2 segundos, o rob√¥ poderia atravessar o mapa inteiro.  Isso n√£o nos convinha, e as tentativas de paralelizar esse processo terminaram em falha, porque n√£o havia desempenho para outros projetos (levando em considera√ß√£o os custos da paraleliza√ß√£o). <br><br>  Decidimos mudar a pilha novamente, abandonar o mapa da grade em favor da grade de ocupa√ß√£o.  Um novo problema apareceu - a incapacidade de armazenar v√°rias vers√µes de mapas ao mesmo tempo (por exemplo, um mapa completo, com todos os obst√°culos e um mapa est√°tico, com apenas obst√°culos din√¢micos).  Eu teria que mudar metade do c√≥digo, o que n√£o era particularmente confi√°vel.  Portanto, decidimos procurar solu√ß√µes alternativas para esse problema. <br><br><h4>  Servidor de Mapa de Custo </h4><br>  Ap√≥s uma longa pesquisa, encontramos os mapas de garfos costmap_serverr: <a href="" rel="nofollow">https://github.com/lelongg/cost_map.git</a> - extremamente √∫teis para o nosso sistema de garfos. <br><br><img src="https://habrastorage.org/webt/27/rb/oh/27rbohj3kefxprwtjqrg4mwtqjc.png"><br><br>  E agora, em vez de atender apenas o mapa da grade, para entrega, conseguimos calcular a prov√°vel localiza√ß√£o do inimigo com base na previs√£o do filtro Kalman. <br><br><img src="https://habrastorage.org/webt/ni/pm/nz/nipmnzvhcrqdje1cu8glf9quude.png"><br><br>  Uma das coisas mais importantes para um servidor de mapa √© um arquivo de mapa, usado para a cria√ß√£o inicial de todas as camadas, que s√£o atualizadas apenas posteriormente.  √â uma imagem png bin√°ria, onde o preto √© um obst√°culo e o branco √© uma zona livre. <br><br><img src="https://habrastorage.org/webt/2b/l5/rg/2bl5rgpuecb7he51heslqpvcazm.png"><br><br>  H√° tamb√©m um arquivo de configura√ß√µes para a configura√ß√£o cost_map_server.  Ele cont√©m t√≥picos com pontos inimigos, uma zona de infla√ß√£o e o tamanho do quadrado, que tamb√©m pode ser usado para colocar a zona perigosa do inimigo no mapa. <br><br><pre> <code class="cpp hljs">########################### # cost_map_server params ## ########################### cost_map_server/big_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/little_robot_size: <span class="hljs-number"><span class="hljs-number">0.4</span></span> cost_map_server/cube_size: <span class="hljs-number"><span class="hljs-number">0.11</span></span> cost_map_server/inscribed_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_radius: <span class="hljs-number"><span class="hljs-number">0.25</span></span> cost_map_server/inflation_exponential_rate: <span class="hljs-number"><span class="hljs-number">0.6</span></span> cost_map_server/big_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot1"</span></span> cost_map_server/big_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot2"</span></span> cost_map_server/small_robot1: <span class="hljs-string"><span class="hljs-string">"/aruco/robot3"</span></span> cost_map_server/small_robot2: <span class="hljs-string"><span class="hljs-string">"/aruco/robot4"</span></span> cost_map_server/collision: <span class="hljs-string"><span class="hljs-string">"collision"</span></span> cost_map_server/image_resource_name: <span class="hljs-string"><span class="hljs-string">"$(find cost_map_server)/param/image_resource.yaml"</span></span> cost_map_server/min_diff_points: <span class="hljs-number"><span class="hljs-number">0.01</span></span></code> </pre> <br>  Todas as camadas s√£o publicadas apenas se algu√©m as assinar: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PublishChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ nav_msgs::OccupancyGrid msg; cost_map_msgs::CostMap cost_map_msg; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obstacle_inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"obstacle_layer"</span></span>, msg); obstacle_inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inflation_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toOccupancyGrid(costmap, <span class="hljs-string"><span class="hljs-string">"inflation_layer"</span></span>, msg); inflation_publisher.publish(msg); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cost_map_publisher.getNumSubscribers() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { cost_map::toMessage(costmap, cost_map_msg); cost_map_publisher.publish(cost_map_msg); } }</code> </pre> <br><h3>  Execute no seu computador </h3><br>  Para iniciar a pilha inteira, voc√™ deve: <br><br><ul><li>  Coloque ROS </li><li>  roslaunch cost_map_server cost_map_server_alone.launch - para iniciar o mapa </li><li>  roslaunch global_planner global_planner.launch - inicia a plaina global com par√¢metros </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosparam load $ (encontre local_planner) /param/param.yaml </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun local_planner local_planning </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trajet√≥ria_regulador rosrun trajet√≥ria_regulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun global_planner mover </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rosrun rviz </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adicionar infla√ß√£o_ camada </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, enviando uma mensagem para o t√≥pico / gp / goal, enviamos o rob√¥ para o ponto desejado </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado do lan√ßamento de todos os itens, voc√™ ter√° uma simula√ß√£o pronta para iniciar nossa pilha no seu computador. </font></font><a href="https://github.com/lelongg/cost_map" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Garfo necess√°rio</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iRY5WHgAFns" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialmente, precis√°vamos de navega√ß√£o que ajudasse o nosso rob√¥ a dirigir de maneira bonita, r√°pida e precisa em rodas omni. </font><font style="vertical-align: inherit;">Durante a prepara√ß√£o para a competi√ß√£o, nenhum gato foi ferido e o rob√¥ √© bonito. </font><font style="vertical-align: inherit;">Como resultado, temos uma pilha de navega√ß√£o leve para concursos semelhantes ao eurobot, com os quais estamos bastante satisfeitos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para n√≥s, essa pilha √© melhor que a padr√£o, mas ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nosso Telegrama: t.me/SetUpSber </font></font><br> <a href="https://github.com/ristle/EUrobotNavigation" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O reposit√≥rio de toda a nossa criatividade</font></font></a> <br><br><img src="https://habrastorage.org/webt/98/gl/4m/98gl4mdibk20qgavmhzkbdppu4w.jpeg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt479636/">https://habr.com/ru/post/pt479636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt479620/index.html">L√≥gica reversa</a></li>
<li><a href="../pt479622/index.html">Como o prot√≥tipo de transa√ß√µes an√¥nimas na blockchain Waves funciona</a></li>
<li><a href="../pt479624/index.html">O profissional do Postgres, Oleg Bartunov, fala a Faride Roslovets sobre o PostgreSQL e neg√≥cios na R√∫ssia</a></li>
<li><a href="../pt479626/index.html">Ressonador com um toque que os f√≠sicos n√£o conhecem</a></li>
<li><a href="../pt479630/index.html">Lute por aten√ß√£o</a></li>
<li><a href="../pt479642/index.html">Como decis√µes est√∫pidas ao projetar uma aeronave da Segunda Guerra Mundial levaram √† cria√ß√£o do Macintosh</a></li>
<li><a href="../pt479646/index.html">Maus conselhos ou raz√µes para continuar a aprender ingl√™s ap√≥s o Intermedi√°rio</a></li>
<li><a href="../pt479650/index.html">Os 12 principais infogr√°ficos din√¢micos de TI mais interessantes</a></li>
<li><a href="../pt479654/index.html">Django vue generator</a></li>
<li><a href="../pt479656/index.html">Antipatterns PostgreSQL: estat√≠sticas em torno da cabe√ßa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>