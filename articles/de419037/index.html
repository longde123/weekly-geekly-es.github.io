<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óæÔ∏è üßñüèø üåñ PPPOS-Implementierung bei stm32f4-Discovery üë©üèæ‚Äçüè´ ‚úàÔ∏è üë®‚Äçüë®‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor mir gab es einmal die Aufgabe, auf dem STM32 den Zugang zum Internet mit nur einem COM-Port zu erm√∂glichen. Um dieses Problem zu l√∂sen, ben√∂tigte ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PPPOS-Implementierung bei stm32f4-Discovery</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419037/">  Vor mir gab es einmal die Aufgabe, auf dem STM32 den Zugang zum Internet mit nur einem COM-Port zu erm√∂glichen.  Um dieses Problem zu l√∂sen, ben√∂tigte ich PPP oder genauer gesagt PPPoS (Point-to-Point-Protokoll √ºber seriell - eine der M√∂glichkeiten zur Implementierung von PPP, die bei der Verbindung √ºber den COM-Port verwendet wird). <br><br>  Bei der L√∂sung der vor mir liegenden Aufgabe stie√ü ich auf einige Schwierigkeiten, von denen eine meiner Meinung nach darin bestand, dass Probleme im Zusammenhang mit PPPoS im Internet nicht ausreichend behandelt wurden.  Mit diesem Beitrag werde ich versuchen, die vorgesehene L√ºcke zu schlie√üen, soweit mein bescheidenes Wissen dies zul√§sst. <br><br>  Dieser Artikel beschreibt, wie Sie ein Projekt f√ºr System Workbench f√ºr STM32 von Grund auf neu erstellen.  Zeigt ein Beispiel f√ºr die Arbeit mit UART.  Es gibt Codebeispiele f√ºr die Implementierung von PPP.  Und nat√ºrlich ein Beispiel f√ºr das Senden einer Nachricht an einen benachbarten Computer. <br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  PPP (Point-to-Point-Protokoll) ist ein Zweipunkt-Datenverbindungsprotokoll des OSI-Netzwerkmodells.  Es wird normalerweise verwendet, um eine direkte Kommunikation zwischen zwei Netzwerkknoten herzustellen, und es kann Verbindungsauthentifizierung, -verschl√ºsselung und Datenkomprimierung bereitstellen.  Wird in vielen Arten von physischen Netzwerken verwendet: Nullmodemkabel, Telefonleitung, Mobilfunk usw. <br><br>  H√§ufig gibt es Unterarten des PPP-Protokolls, z. B. das Punkt-zu-Punkt-Protokoll √ºber Ethernet (PPPoE), das f√ºr die Verbindung √ºber Ethernet und manchmal √ºber DSL verwendet wird.  und Punkt-zu-Punkt-Protokoll √ºber ATM (PPPoA), das f√ºr die Verbindung √ºber ATM Adaptation Layer 5 (AAL5) verwendet wird, die die wichtigste PPPoE-Alternative f√ºr DSL darstellt. <br><br>  PPP ist eine Protokollfamilie: Link Control Protocol (LCP), Network Control Protocol (NCP), Authentifizierungsprotokolle (PAP, CHAP), Multichannel PPP (MLPPP). <br><br>  <i>Aus Wikipedia</i> . <br><br><h3>  Vorbereitung </h3><br>  Um das Problem zu l√∂sen, brauchen wir: <br><br><h4>  Eisen: </h4><br><ol><li>  Debugboard stm32f4_discovery: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/u1/0k/6-/u10k6-una1bkmaphl4wlazibaca.jpeg"></div></li><li>  USB-zu-Mini-USB-Adapter zum Anschlie√üen der Karte an einen Computer. </li><li>  Zwei USBtoUART FT232-Adapter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/uk/mo/uhukmolq4_t-pckn8h2rjofspnu.png"></div></li><li>  Zwei USB-Verl√§ngerungskabel sind ebenfalls n√ºtzlich, nicht unbedingt, aber nur praktisch. </li></ol><br><h4>  Weich: </h4><br><ol><li>  Virtuelle Maschine VirtualBox.  Sie k√∂nnen es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunterladen.  Wir laden auch das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Extension Pack</a> f√ºr VirtualBox herunter und installieren es. </li><li>  Zwei Installationsdisketten mit den Betriebssystemen Windows und Linux.  Wir nehmen Windows <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> , Linux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br>  Nach der Installation des Betriebssystems m√ºssen Sie Add-Ons f√ºr das Gastbetriebssystem installieren.  F√ºr die Aufgabe haben wir genug 32x-Systeme, die Sie mit der Einbeziehung der Virtualisierung nicht t√§uschen k√∂nnen. </li><li>  F√ºr Windows ben√∂tigen wir ein Programm, das Anforderungen annehmen und √ºber TCP / IP beantworten kann, sowie ein Terminalprogramm f√ºr die Arbeit mit einem COM-Port.  Laden Sie PacketSender <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> herunter (klicken Sie auf "Nein, danke, lassen Sie mich einfach herunterladen."). Das Terminal ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> .  Zus√§tzlich ben√∂tigen wir STM32CubeMX f√ºr die Ersteinrichtung des Projekts.  Download von st.com (nach der Registrierung erfolgt der Link per E-Mail). </li><li>  Wir haben System Workbench f√ºr STM32 auf dem Hauptbetriebssystem installiert.  Hier herunterladen (Anmeldung erforderlich). </li></ol><br><h3>  Phase 1. Erstellen eines Projekts </h3><br>  √ñffnen Sie zun√§chst STM32CubeMX und erstellen Sie dort ein neues Projekt f√ºr unser stm32f4-Discovery-Board.  Schalten Sie RCC, Ethernet (ETH), SYS, USART2, USART3 und dann FREERTOS und LWIP ein. <br><br><img src="https://habrastorage.org/webt/vr/jk/ve/vrjkveavft5ry-oasa7h2e07rwe.png"><br><img src="https://habrastorage.org/webt/9c/v2/rv/9cv2rv-_8yf5w67mr7bw7ynp1vk.png"><br><br>  F√ºr die Diagnose ben√∂tigen wir LEDs auf der Platine.  Konfigurieren Sie dazu die Beine von PD12-PD15 als GPIO_Output. <br><br><img src="https://habrastorage.org/webt/-s/bb/lk/-sbblkybmbdz1wrftiow38tq4eg.png"><br><br>  Stellen Sie auf der Registerkarte Uhrenkonfiguration die Frequenz wie in der Abbildung unten ein. <br><br><img src="https://habrastorage.org/webt/sd/cc/qy/sdccqyreetba7g_m8yq_gypc-ge.png"><br><br>  Konfigurieren Sie als N√§chstes auf der Registerkarte Konfiguration die USART-Ports.  Wir werden mit ihnen im DMA-Modus arbeiten.  Wir haben zwei USART-Ports, einen zum Senden und Empfangen von Daten √ºber PPP und einen zum Protokollieren.  Damit sie funktionieren, m√ºssen wir DMA auf RX und TX f√ºr beide Ports konfigurieren.  Stellen Sie f√ºr alle DMA-Tuning-Beine Mittel auf Priorit√§t ein.  Stellen Sie f√ºr USART2 leg RX den Modus auf "Circular".  Die restlichen Einstellungen bleiben standardm√§√üig erhalten. <br><br><img src="https://habrastorage.org/webt/96/s8/9u/96s89uloxfrdtxd0scqvcyb-zng.png"><br><br>  Sie m√ºssen auch den globalen Interrupt f√ºr beide Ports auf der Registerkarte "NVIC-Einstellungen" aktivieren. <br><br>  Damit ist die Ersteinrichtung des Projekts in STM32CubeMX abgeschlossen.  Wir speichern die Projektdatei und f√ºhren die Codegenerierung f√ºr System Workbench f√ºr STM32 durch. <br><br><img src="https://habrastorage.org/webt/ss/_d/8l/ss_d8lzdxneoj5mjasvmyhhhxiu.png"><br><br><h4>  Implementierung </h4><br>  Lassen Sie uns nun √ºberpr√ºfen, ob der heruntergeladene Code kompiliert und funktioniert.  Zu diesem Zweck ersetzen wir in der Datei main.c in der Funktion "StartDefaultTask" den K√∂rper der Endlosschleife f√ºr (;;) durch den LED-Ein- und Ausschaltcode. <br><br>  Es sollte so sein: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* StartDefaultTask function */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> MX_LWIP_Init(); <span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Infinite loop */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(<span class="hljs-number"><span class="hljs-number">1000</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* USER CODE END 5 */</span></span> }</code> </pre> <br>  Wir kompilieren die Firmware und schauen.  Alle vier LEDs sollten auf der Platine blinken. <br><br><h3>  Stufe 2. Arbeiten Sie mit USART </h3><br>  Unsere n√§chste Aufgabe ist es, den korrekten Betrieb unseres USART zu √ºberpr√ºfen. <br><br>  Als erstes m√ºssen wir unseren FT232 mit Discovery verbinden.  √úberpr√ºfen Sie dazu, auf welchen Beinen die USART-Schnittstellen geschieden sind.  Ich habe es PD6 und PD5 f√ºr USART2_RX bzw. USART2_TX. <br><br><img src="https://habrastorage.org/webt/qj/yh/yo/qjyhyoohdofxtqedphuhzq7qcac.png"><br><br>  Sowie PD9 und PD8 f√ºr USART3_RX bzw. USART3_TX. <br><br><img src="https://habrastorage.org/webt/37/bf/om/37bfomzqqcapediljrf14flpuiu.png"><br><br>  Au√üerdem brauchen wir einen GND-Fu√ü. <br><br>  Wir finden diese Pins auf der Platine und verbinden sie mit den FT232-Pins, w√§hrend der GND-Pin auf der Platine beliebig sein kann, der RX-Pin auf der Platine mit dem TX-Pin auf dem FT232 verbunden sein muss und der TX-Pin auf der Platine mit dem RX-Pin auf dem FT232 verbunden sein muss.  Die √ºbrigen Schlussfolgerungen werden nicht verwendet. <br><br>  Es bleibt, unseren FT232 an die USB-Anschl√ºsse des Computers anzuschlie√üen und die Discovery-Karte selbst √ºber den Mini-USB-Anschluss an den Computer anzuschlie√üen (nicht zu verwechseln mit Micro-USB). <br><br>  Nach dem Anschlie√üen von FT232 installiert das Hauptbetriebssystem die Treiber f√ºr diese. Anschlie√üend m√ºssen diese Ger√§te an den Windows-Gast auf der virtuellen Maschine weitergeleitet werden. <br><br>  Jetzt f√ºgen wir den Programmcode hinzu, der f√ºr den Betrieb unseres USART ben√∂tigt wird.  Dazu f√ºgen wir vier Dateien hinzu: usart.h, usart.c, logger.h, logger.c. <br><br>  Dateiinhalt: <br><br>  <b>Datei usart.h</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _USART_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> void usart_Open(void); bool usart_Send(char* bArray, int size_bArray); uint16_t usart_Recv(char* bArray, uint16_t maxLength); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _USART_ */</span></span></span></span></code> </pre><br>  <b>Datei usart.c</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cmsis_os.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Q_USART2_SIZE 200 xQueueHandle g_qUsart; osThreadId g_usart_rxTaskHandle; extern UART_HandleTypeDef huart2; void usart_rxTask(void); uint8_t bGet[Q_USART2_SIZE] = {0}; uint16_t g_tail = 0; void usart_Open(void) { g_qUsart = xQueueCreate( Q_USART2_SIZE, sizeof( unsigned char ) ); osThreadDef(usart_rxTask_NAME, usart_rxTask, osPriorityNormal, 0, Q_USART2_SIZE/4+128); g_usart_rxTaskHandle = osThreadCreate(osThread(usart_rxTask_NAME), NULL); HAL_UART_Receive_DMA(&amp;huart2, bGet, Q_USART2_SIZE); } void usart_rxTask(void) { for(;;) { uint16_t length = Q_USART2_SIZE - huart2.hdmarx-&gt;Instance-&gt;NDTR; while(length - g_tail) { uint8_t tmp = bGet[g_tail]; xQueueSendToBack( g_qUsart, &amp;tmp, 100 ); g_tail++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (g_tail == Q_USART2_SIZE) g_tail = 0; } } } bool usart_Send(char* bArray, int size_bArray) { HAL_StatusTypeDef status; status = HAL_UART_Transmit_DMA(&amp;huart2, bArray, size_bArray); while (HAL_UART_GetState(&amp;huart2) != HAL_UART_STATE_READY) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (HAL_UART_GetState(&amp;huart2) == HAL_UART_STATE_BUSY_RX) break; osDelay(1); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (status == HAL_OK) return true; return false; } uint16_t usart_Recv(char* bArray, uint16_t maxLength) { uint8_t tmp = 0; uint16_t length = 0; while(uxQueueMessagesWaiting(g_qUsart)) { xQueueReceive( g_qUsart, &amp;tmp, 100 ); bArray[length] = tmp; length++; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length &gt;= maxLength) break; } return length; }</span></span></code> </pre><br>  <b>logger.h Datei</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _LOGGER_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _LOGGER_ void logger(const char *format, ...); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* _LOGGER_ */</span></span></span></span></code> </pre><br>  <b>logger.c Datei</b> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stm32f4xx_hal.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdarg.h&gt; extern UART_HandleTypeDef huart3; #define MAX_STRING_SIZE 1024 HAL_StatusTypeDef logger_Send(char* bArray, uint32_t size_bArray) { HAL_StatusTypeDef status; for(int i=0;i&lt;5;i++) { status = HAL_UART_Transmit_DMA(&amp;huart3, bArray, size_bArray); if (status == HAL_OK) break; osDelay(2); } while (HAL_UART_GetState(&amp;huart3) != HAL_UART_STATE_READY) { osDelay(1); } return status; } void logger(const char *format, ...) { char buffer[MAX_STRING_SIZE]; va_list args; va_start (args, format); vsprintf(buffer, format, args); va_end(args); buffer[MAX_STRING_SIZE-1]=0; logger_Send(buffer, strlen(buffer)); }</span></span></span></span></code> </pre><br>  Wir brauchen usart, um Daten auf usart2 zu senden und zu empfangen.  Es wird unsere Hauptschnittstelle f√ºr die Kommunikation mit einem PPP-Server sein. <br><br>  Wir ben√∂tigen Logger, um die Protokollierung durch Senden von Nachrichten an das Terminal zu implementieren.  Die Funktion void usart_Open (void) bildet eine Warteschlange und startet die Wartung dieser Warteschlange.  Diese Funktion muss abgeschlossen sein, bevor USART verwendet werden kann.  Dann ist alles einfach, die Funktion bool usart_Send (char * bArray, int size_bArray) sendet Daten an den Port und <br>  uint16_t usart_Recv (char * bArray, uint16_t maxLength) ruft sie aus der Warteschlange ab, in die die Funktion void usart_rxTask (void) sie freundlicherweise hinzugef√ºgt hat. <br><br>  F√ºr den Logger ist es noch einfacher, da keine Daten abgerufen werden m√ºssen. Daher werden weder die Warteschlangen- noch die Warteschlangenwartungsaufgabe ben√∂tigt. <br><br>  Am Anfang der Datei <b>main.h</b> m√ºssen Sie mehrere <b>Definitionen</b> hinzuf√ºgen, die den Bool-Typ beschreiben, der in C nicht verf√ºgbar ist. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Includes */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> true 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> false 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Includes */</span></span></span></span></code> </pre><br>  Jetzt ist es Zeit, die Funktionalit√§t des resultierenden Codes zu √ºberpr√ºfen.  <b>√Ñndern</b> Sie dazu in der Datei <b>main.c</b> den Code der bereits bekannten Task "StartDefaultTask". <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_MESSAGE_LENGTH 100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> MX_LWIP_Init(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE BEGIN 5 */</span></span></span><span class="hljs-meta"> usart_Open(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Infinite loop */</span></span></span><span class="hljs-meta"> uint8_t send[] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Send message\r\n"</span></span></span><span class="hljs-meta">; uint8_t recv[MAX_MESSAGE_LENGTH] = {0}; uint16_t recvLength = 0; for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (usart_Send(send, sizeof(send)-1)) logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SEND - %s"</span></span></span><span class="hljs-meta">, send); recvLength = usart_Recv(recv, MAX_MESSAGE_LENGTH-1); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (recvLength) { recv[recvLength] = 0; logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"RECV - %s\r\n"</span></span></span><span class="hljs-meta">, recv); } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 5 */</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br>  Au√üerdem m√ºssen wir dem Stapel unserer Aufgabe mehr Speicher geben.  Dazu m√ºssen Sie beim Aufruf der Funktion osThreadDef (), der Datei main.c, 128 x 128 * 10 korrigieren, um Folgendes zu erhalten: <br><br><pre> <code class="hljs lisp">osThreadDef(<span class="hljs-name"><span class="hljs-name">defaultTask</span></span>, StartDefaultTask, osPriorityNormal, <span class="hljs-number"><span class="hljs-number">0</span></span>, &lt;b&gt;128*10&lt;/b&gt;)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  Wir kompilieren und flashen.  Die LEDs blinken auf die gleiche Weise wie in der vorherigen Aufgabe. <br><br>  Um das Ergebnis unserer Arbeit zu sehen, m√ºssen Sie das Terminal-Programm in unserer virtuellen Maschine ausf√ºhren.  Eine Instanz des Programms f√ºr den Protokollierungsport, die zweite f√ºr den Hauptport.  √úberpr√ºfen Sie im Ger√§te-Manager, welche Portnummern Ihrem FT232 zugewiesen wurden.  Wenn mehr als 10 Nummern zugewiesen wurden, weisen Sie sie neu zu. <br><br>  Wenn Sie die zweite Instanz des Programms starten, kann ein Fehler auftreten. Schlie√üen Sie das Fenster mit dem Fehler und arbeiten Sie weiter mit dem Programm. <br><br>  F√ºr beide Ports stellen wir eine Verbindung mit 115200 Baud her, Datenbits - 8, Parit√§t - keine, Stoppbits - 1, Handshake - keine. <br><br>  Wenn Sie alles richtig gemacht haben, wird im Terminalfenster f√ºr usart2 die Nachricht ‚ÄûNachricht senden‚Äú gesendet.  Dieselbe Nachricht wird im Terminalfenster f√ºr den Logger nur mit dem Pr√§fix "SEND -" dupliziert. <br><br>  Wenn Sie im Terminalfenster f√ºr usart2 Text in das Feld "Senden" eingeben und auf die entsprechende Schaltfl√§che rechts neben diesem Feld klicken, wird im Protokollierungsfenster dieselbe Meldung mit dem Pr√§fix "RECV -" angezeigt. <br><br>  Im Bild unten: Links ist der Logger, rechts ist usart2. <br><br><img src="https://habrastorage.org/webt/k5/v6/hc/k5v6hcxebj6hfdgbitfwyzs1ffw.png"><br><br><h3>  Phase 3. Erste Schritte mit PPP </h3><br>  Im Rahmen dieser Aufgabe werden wir eine PPP-Verbindung herstellen.  Aktivieren Sie zun√§chst die Verwendung von PPP und √§ndern Sie den Wert der PPP_SUPPORT-Definition in der Datei ppp_opts.h in 1. Anschlie√üend definieren wir die erforderlichen Definitionen in der Datei lwipopts.h neu. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 1 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MEMP_NUM_SYS_TIMEOUT 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_IP 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CHECKSUM_GEN_TCP 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 1 */</span></span></span></span></code> </pre><br>  Gleichzeitig m√ºssen alte Definitionen auskommentiert werden. <br><br>  Jetzt √§ndern wir die Datei lwip.c und f√ºgen den folgenden Code in den Block "/ * USER CODE BEGIN 0 * /" ein: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 0 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"usart.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pppos.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sio.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp.h"</span></span></span><span class="hljs-meta"> static ppp_pcb *ppp; struct netif pppos_netif; void PppGetTask(void const * argument) { uint8_t recv[2048]; uint16_t length = 0; for(;;) { length=usart_Recv(recv, 2048); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (length) { pppos_input(ppp, recv, length); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"read - PppGetTask() len = %d\n"</span></span></span><span class="hljs-meta">, length); } osDelay(10); } } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ip4_addr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dns.h"</span></span></span><span class="hljs-meta"> static void ppp_link_status_cb(ppp_pcb *pcb, int err_code, void *ctx) { struct netif *pppif = ppp_netif(pcb); LWIP_UNUSED_ARG(ctx); switch(err_code) { case PPPERR_NONE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* No error. */</span></span></span><span class="hljs-meta"> { logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_NONE\n\r"</span></span></span><span class="hljs-meta">); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" our_ip4addr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_addr(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" his_ipaddr = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_gw(pppif))); logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">" netmask = %s\n\r"</span></span></span><span class="hljs-meta">, ip4addr_ntoa(netif_ip4_netmask(pppif))); } break; case PPPERR_PARAM: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid parameter. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PARAM\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_OPEN: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to open PPP session. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_OPEN\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_DEVICE: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Invalid I/O device for PPP. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_DEVICE\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_ALLOC: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Unable to allocate resources. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_ALLOC\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_USER: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* User interrupt. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_USER\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection lost. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_AUTHFAIL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed authentication challenge. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_AUTHFAIL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PROTOCOL: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Failed to meet protocol. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PROTOCOL\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_PEERDEAD: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_PEERDEAD\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_IDLETIMEOUT: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Idle Timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_IDLETIMEOUT\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_CONNECTTIME: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* PPPERR_CONNECTTIME. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_CONNECTTIME\n"</span></span></span><span class="hljs-meta">); break; case PPPERR_LOOPBACK: </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Connection timeout. */</span></span></span><span class="hljs-meta"> logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: PPPERR_LOOPBACK\n"</span></span></span><span class="hljs-meta">); break; default: logger(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ppp_link_status_cb: unknown errCode %d\n"</span></span></span><span class="hljs-meta">, err_code); break; } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Callback used by ppp connection static u32_t ppp_output_cb(ppp_pcb *pcb, u8_t *data, u32_t len, void *ctx) { LWIP_UNUSED_ARG(pcb); LWIP_UNUSED_ARG(ctx); if (len &gt; 0) { if (!usart_Send(data, len)) return 0x05; } logger("write - ppp_output_cb() len = %d\n", len); return len; } void pppConnect(void) { ppp = pppos_create(&amp;pppos_netif, ppp_output_cb, ppp_link_status_cb, NULL); ppp_set_default(ppp); osThreadId PppGetTaskHandle; osThreadDef(PPP_GET_TASK_NAME, PppGetTask, osPriorityNormal, 0, 128*10); PppGetTaskHandle = osThreadCreate(osThread(PPP_GET_TASK_NAME), NULL); err_t err = ppp_connect(ppp,0); if (err == ERR_ALREADY) { logger("Connected successfully"); } for(int i=0;i&lt;40;i++) { osDelay(500); if (ppp-&gt;phase &gt;= PPP_PHASE_RUNNING) break; } } /* USER CODE END 0 */</span></span></span></span></code> </pre><br>  Dann f√ºgen wir in der Funktion MX_LWIP_Init () im Block ‚Äû/ * USER CODE BEGIN 3 * /‚Äú der Funktion pppConnect () einen Aufruf hinzu. <br><br>  Au√üerdem m√ºssen Sie die Heap-Gr√∂√üe erh√∂hen. Dazu m√ºssen Sie in der Datei FreeRTOSConfig.h die Definition configTOTAL_HEAP_SIZE auskommentieren und am Ende der Datei im Block / * USER CODE BEGIN Defines * / mit einem neuen Wert deklarieren. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN Defines */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Section where parameter definitions can be added (for instance, to override default ones in FreeRTOS.h) */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> configTOTAL_HEAP_SIZE ((size_t)1024*30) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END Defines */</span></span></span></span></code> </pre><br>  √Ñndern Sie au√üerdem in der Datei usart.c den Wert der Definition Q_USART2_SIZE in 2048. <br><br>  Der Verbindungsaufbau beginnt mit der Funktion MX_LWIP_Init (), die automatisch erstellt wurde. Wir haben der Funktion pppConnect () gerade einen Aufruf hinzugef√ºgt.  In dieser Funktion werden Aufgaben gestartet, die die PPPOS-Verbindung bedienen.  Den Funktionen pppos_create () m√ºssen die Adressen der Funktionen √ºbergeben werden, die zum Senden von Nachrichten und zum Ausgeben von Informationen zum √Ñndern des Verbindungsstatus dienen.  F√ºr uns sind dies die Funktionen ppp_output_cb () bzw. ppp_link_status_cb ().  Dar√ºber hinaus startet die Funktion pppConnect () die Bearbeitung empfangener Nachrichten.  Am Ende des Betriebs wartet die Funktion pppConnect () darauf, dass eine Verbindung zum Server hergestellt wird, und schlie√üt dann den Betrieb ab. <br><br>  Die Arbeit mit dem Netzwerk wird auf einer h√∂heren Ebene ausgef√ºhrt. Sobald LWIP entscheidet, dass eine Nachricht an das Netzwerk gesendet werden muss, wird die Funktion ppp_output_cb () automatisch aufgerufen.  Die Antwort vom Netzwerk wird von der Funktion PppGetTask () als Teil der Aufgabe der Bearbeitung eingehender Nachrichten empfangen und an den Darm von LWIP √ºbertragen.  Wenn sich der Verbindungsstatus √§ndert, wird die Funktion ppp_link_status_cb () automatisch aufgerufen. <br><br>  Schlie√ülich werden wir die StartDefaultTask-Aufgabe √§ndern.  Jetzt sollte es so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartDefaultTask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * argument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* init code for LWIP */</span></span> <span class="hljs-comment"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); } /* USER CODE END 5 */ }</span></span></code> </pre><br>  Fertig, Sie k√∂nnen kompilieren und flashen. <br><br>  Zu diesem Zeitpunkt m√ºssen Sie den PPP-Server starten.  Dazu m√ºssen Sie zuerst eine virtuelle Maschine unter Linux bereitstellen.  Ich habe Ubuntu 16.04 x32 verwendet.  Nach der Installation des Betriebssystems m√ºssen Sie die Verwendung des COM-Anschlusses konfigurieren. <br><br>  In diesem Teil ben√∂tigen wir keine virtuelle Maschine mit Windows, wir k√∂nnen sie sicher deaktivieren.  Wir verbinden beide FT232 unter Linux. <br><br>  Bevor Sie unter Linux mit einem COM-Port arbeiten, m√ºssen Sie dem Benutzer erlauben, ihn zu verwenden.  F√ºhren Sie dazu den folgenden Befehl aus: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sudo</span></span> addgroup USERNAME dialout</code> </pre> <br>  Dabei ist USERNAME der Name des aktuellen Benutzers. <br><br>  Um die verf√ºgbaren Ports im COM-System anzuzeigen, m√ºssen Sie den folgenden Befehl ausf√ºhren: <br><br><pre> <code class="hljs perl">dmesg | <span class="hljs-keyword"><span class="hljs-keyword">grep</span></span> tty</code> </pre> <br><img src="https://habrastorage.org/webt/zc/h4/mp/zch4mpfwyybln76dl1jnhpxjt0s.png"><br><br>  Wir sehen, dass es zwei ttyUSB-Ports im System gibt.  Wir k√∂nnen nicht sofort sagen, welcher Logger und welcher usart2 ist.  Sie m√ºssen sie nur der Reihe nach √ºberpr√ºfen. <br><br>  F√ºhren Sie zun√§chst die Befehle aus, die von einem Port gelesen werden sollen: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB0 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB0</code> </pre> <br>  dann von einem anderen: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">stty</span></span> -F /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> cat /dev/ttyUSB1</code> </pre> <br>  Wo wir so ein Bild sehen, ist das Logger. <br><br><img src="https://habrastorage.org/webt/u0/cu/zc/u0cuzcnbhzppwdhpibm2o6zelpk.png"><br><br>  Sie k√∂nnen dieses Fenster verlassen, es wird uns nicht st√∂ren. <br><br>  Als n√§chstes m√ºssen Sie zulassen, dass von unserem Board gesendete Pakete die Grenzen ihres Subnetzes verlassen.  Konfigurieren Sie dazu iptables.  Wir f√ºhren folgende Aktionen durch: <br><br>  1. √ñffnen Sie ein neues Konsolenfenster <br>  2. Sie m√ºssen Ihre IP und den Namen der Netzwerkschnittstelle herausfinden (f√ºhren Sie den Befehl <b>ifconfig aus</b> ). <br><br><img src="https://habrastorage.org/webt/jy/d4/9s/jyd49satpc3erdlzeddi44gwcy4.png"><br><br>  3. F√ºhren Sie die nat-Konfigurationsbefehle aus <br><br><pre> <code class="hljs powershell">sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_forward &gt; /dev/null sudo echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee <span class="hljs-literal"><span class="hljs-literal">-a</span></span> /proc/sys/net/ipv4/ip_dynaddr &gt; /dev/null sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> FORWARD sudo iptables <span class="hljs-operator"><span class="hljs-operator">-F</span></span> <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-A</span></span> POSTROUTING <span class="hljs-literal"><span class="hljs-literal">-o</span></span> enp0s3 <span class="hljs-literal"><span class="hljs-literal">-j</span></span> SNAT -<span class="hljs-literal"><span class="hljs-literal">-to</span></span><span class="hljs-literal"><span class="hljs-literal">-source</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span>.<span class="hljs-number"><span class="hljs-number">10.196</span></span> sudo iptables <span class="hljs-literal"><span class="hljs-literal">-t</span></span> nat <span class="hljs-literal"><span class="hljs-literal">-L</span></span></code> </pre> <br>  Dabei ist enp0s3 der Name der Netzwerkschnittstelle <br>  192.168.10.196 - Ihre IP-Adresse <br>  / proc / sys / net / ipv4 / - Pfad zur entsprechenden Datei. <br><br>  Diese Befehle k√∂nnen in eine Batchdatei umgeschrieben und jedes Mal ausgef√ºhrt werden, bevor der PPP-Server gestartet wird.  Sie k√∂nnen es zu Autorun hinzuf√ºgen, aber ich habe es nicht getan. <br><br>  Jetzt k√∂nnen wir den Server starten. Es bleibt nur noch eine Einstellungsdatei zu erstellen.  Ich habe es " <b>pppd.conf</b> " genannt, ich schlage vor, die folgenden Einstellungen zu verwenden: <br><br><pre> <code class="hljs pgsql">nodetach noauth passive <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> <span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>:<span class="hljs-number"><span class="hljs-number">192.168</span></span><span class="hljs-number"><span class="hljs-number">.250</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> /dev/ttyUSB1 <span class="hljs-number"><span class="hljs-number">115200</span></span> lcp-echo-<span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> lcp-echo-failure <span class="hljs-number"><span class="hljs-number">1</span></span> cdtrcts</code> </pre> <br>  Wir schreiben die Einstellungen in eine Datei und dann k√∂nnen Sie den Server starten.  Dies erfolgt mit dem <b>Befehl sudo pppd file ./pppd.conf</b> <br><br>  Der PPPD-Server muss vor dem Start der Erkennung gestartet werden. Nach dem Start von PPPD m√ºssen Sie auf die Schaltfl√§che "Zur√ºcksetzen" auf der Karte klicken. <br><br>  Wenn Sie alles richtig gemacht haben, sehen Sie das folgende Bild: <br><br><img src="https://habrastorage.org/webt/kv/-p/lj/kv-pljob3duk3bigzj3iazcsasa.png"><br><br>  Links pppd ausf√ºhren, rechts Logger. <br><br><h3>  Stufe 4. Wir schicken eine Tasche </h3><br>  Zu diesem Zeitpunkt ben√∂tigen wir beide virtuellen Maschinen.  Linux f√ºr pppd und Windows, um das Paket zu erhalten.  Um die Aufgabe zu vereinfachen, m√ºssen sich beide Computer im selben Subnetz befinden. Die ideale L√∂sung besteht darin, in den VirtualBox-Netzwerkeinstellungen eine Network Bridge-Verbindung f√ºr beide Computer anzugeben und die Firewall in Windows zu deaktivieren. <br><br>  Wir starten die virtuellen Maschinen und konfigurieren die ppp-Verbindung des Discovery Boards mit pppd.  Unter Windows finden wir die IP-Adresse des Computers heraus (Befehl ipconfig), ich habe sie 192.168.10.97 erhalten. <br><br>  Starten Sie Packet Sender und konfigurieren Sie es wie folgt: <br><br><img src="https://habrastorage.org/webt/k8/zt/uv/k8ztuv4eccjueyvlk8gigjbmkj0.png"><br><br>  √Ñndern Sie nun erneut die StartDefaultTask-Task in der Datei <b>main.c.</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* USER CODE BEGIN 4 */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"logger.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sockets.h"</span></span></span><span class="hljs-meta"> typedef uint32_t SOCKET; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* USER CODE END 4 */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* StartDefaultTask function */</span></span></span><span class="hljs-meta"> void StartDefaultTask(void const * argument) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* init code for LWIP */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// MX_LWIP_Init(); /* USER CODE BEGIN 5 */ usart_Open(); MX_LWIP_Init(); /* Infinite loop */ uint8_t sendStr[]="Test message TCP/IP."; uint8_t resvStr[100]={0}; int resvLength = 0; struct sockaddr_in sockAddr; sockAddr.sin_family = AF_INET; sockAddr.sin_port = htons( 6565 ); uint32_t addr = inet_addr("192.168.10.97"); sockAddr.sin_addr.s_addr = addr; SOCKET socket = NULL; int nError = 0; /* Infinite loop */ for(;;) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_SET); osDelay(1000); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET); osDelay(1000); socket = socket( AF_INET, SOCK_STREAM, 0 ); nError = connect( socket, (struct sockaddr*)&amp;sockAddr, sizeof(sockAddr) ); if ( nError == 0 ) { nError = send( socket, sendStr, sizeof(sendStr)-1, 0 ); if ( nError &lt; 0 ) logger("SEND ERROR %d\n", nError); else { logger("SEND - %s\n", sendStr); resvLength = 0; while(resvLength &lt; 1) resvLength = lwip_recv( socket, resvStr, sizeof(resvStr), MSG_WAITALL); resvStr[resvLength]=0; logger("GET - %s\n", resvStr); } lwip_close(socket); } else logger("CONNECT ERROR %d\n", nError); } /* USER CODE END 5 */ }</span></span></span></span></code> </pre><br>  Als Wert der Variablen addr verwenden wir die Adresse des Windows-Computers, Portnummer 6565. <br>  Gesendete Nachricht "Testnachricht TCP / IP.", Antwort "Die Nachricht wird empfangen." <br><br>  Hier sehen Sie, dass PPP-Funktionen nicht direkt zum Senden und Empfangen von Nachrichten verwendet werden.  Alle Arbeiten finden auf einer h√∂heren Ebene statt und unsere Funktionen werden automatisch aufgerufen. <br><br>  Wir kompilieren und flashen. <br><br>  Das Ergebnis der Verbindung zu pppd ist auf einem Linux-Computer sichtbar: <br><br><img src="https://habrastorage.org/webt/il/og/h6/ilogh6wuak7zym8unedcnddcjr4.png"><br><br>  Empfangene Anforderungen und gesendete Antworten werden im Paketsender-Programm auf einem Windows-Computer angezeigt: <br><br><img src="https://habrastorage.org/webt/30/yh/4m/30yh4m_l52nvlkdixrv9zmivehc.png"><br><br>  Nun, das ist alles, das von uns vom Discovery Board gesendete Paket ging an den COM-Port, ging an den pppd-Server, wurde an den Windows-Port 6565 des Computers gesendet, dort wurde es erfolgreich empfangen, als Antwort darauf wurde ein anderes Paket gesendet, das dies bestanden hat Weg in die entgegengesetzte Richtung und wurde erfolgreich in den Vorstand √ºbernommen.  Sie k√∂nnen auch Nachrichten an jeden Computer im Internet senden. <br><br>  ‚Üí Den vollst√§ndigen Projektcode k√∂nnen Sie hier herunterladen </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de419037/">https://habr.com/ru/post/de419037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de419025/index.html">@ Pythonetc-Zusammenstellung, Juli 2018</a></li>
<li><a href="../de419027/index.html">Informationssicherheit bei bargeldlosen Bankzahlungen. Teil 6 - Analyse der Bankenkriminalit√§t</a></li>
<li><a href="../de419029/index.html">Fortnite ist zu einem sozialen Ph√§nomen geworden. Eltern stellen zunehmend Trainer f√ºr ihre Kinder ein und spielen mit ihnen</a></li>
<li><a href="../de419033/index.html">Ein kleiner Hinweis zum Thema Ausf√ºhren von vue.js im kubernetes-Cluster</a></li>
<li><a href="../de419035/index.html">Buch ‚ÄûHead First Agile. Flexibles Projektmanagement ‚Äú</a></li>
<li><a href="../de419041/index.html">Die neun Elasticsearch-Rechen, auf die ich getreten bin</a></li>
<li><a href="../de419043/index.html">Das schwer fassbare Problem mit dem Frame-Timing</a></li>
<li><a href="../de419047/index.html">Reddit gehackte, durchgesickerte Datenbank mit Passw√∂rtern und E-Mail f√ºr 2005-2007</a></li>
<li><a href="../de419049/index.html">GeekBrains startet den kostenlosen Online-Bildungsmarathon ‚ÄûFind Yourself in Digital‚Äú</a></li>
<li><a href="../de419051/index.html">Wie Flant Anf√§ngern hilft</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>