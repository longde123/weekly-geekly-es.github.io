<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ½ ğŸ¹ ğŸ‘†ğŸ¼ Backend, pembelajaran mesin, dan tanpa server adalah yang paling menarik dari konferensi Habr Juli ğŸ€ ğŸ•§ ğŸ¤±ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr conference - ceritanya bukan debut. Kami biasanya mengadakan acara pemanggang roti yang agak besar untuk 300-400 orang, tetapi sekarang kami memu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Backend, pembelajaran mesin, dan tanpa server adalah yang paling menarik dari konferensi Habr Juli</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/habr/blog/472916/">  Habr conference - ceritanya bukan debut.  Kami biasanya mengadakan acara pemanggang roti yang agak besar untuk 300-400 orang, tetapi sekarang kami memutuskan bahwa pertemuan tematik kecil akan relevan, arah yang juga dapat Anda tetapkan - misalnya, dalam komentar.  Konferensi pertama format ini diadakan pada bulan Juli dan didedikasikan untuk pengembangan backend.  Peserta mendengarkan laporan tentang fitur-fitur transisi dari backend ke ML dan pada desain layanan Quadrupel di portal State Services, dan juga mengambil bagian dalam sebuah meja bundar yang ditujukan untuk Serverless.  Bagi yang tidak bisa menghadiri acara tersebut secara pribadi, dalam posting ini kami sampaikan yang paling menarik. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9bd/04a/8ab/9bd04a8ab9b6a12c0d985c7d2a13bc3e.jpg"><br><a name="habracut"></a><br><h2>  Dari pengembangan backend ke pembelajaran mesin </h2><br>  Apa yang dilakukan insinyur data ML?  Apa persamaan dan perbedaan antara tugas pengembang backend dan insinyur ML?  Jalur apa yang perlu Anda tempuh untuk mengubah profesi pertama ke yang kedua?  Ini diceritakan oleh Alexander Parinov, yang masuk ke pembelajaran mesin setelah 10 tahun backend. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71d/4b7/e23/71d4b7e2307b78cefd6f1868a33b983d.jpg"><br>  <i>Alexander Parinov</i> <br><br>  Saat ini, Alexander bekerja sebagai arsitek sistem visi komputer di X5 Retail Group dan berkontribusi pada proyek sumber terbuka yang terkait dengan visi komputer dan pembelajaran mendalam (github.com/creafz).  Keahliannya dikonfirmasi oleh partisipasinya di 100 teratas Master Kaggle peringkat dunia (kaggle.com/creafz) - platform paling populer yang menyelenggarakan kompetisi pembelajaran mesin. <br><br><h3>  Mengapa beralih ke pembelajaran mesin </h3><br>  Setahun setengah yang lalu, Jeff Dean, kepala Google Brain, proyek penelitian kecerdasan buatan dalam belajar Google, memberi tahu Google bagaimana setengah juta baris kode dalam Google Translate digantikan oleh jaringan saraf dengan Tensor Flow, yang hanya terdiri dari 500 baris.  Setelah pelatihan jaringan, kualitas data telah berkembang dan infrastruktur telah disederhanakan.  Tampaknya inilah masa depan kita yang cerah: tidak perlu lagi menulis kode, cukup membuat neuron dan membuangnya dengan data.  Namun dalam praktiknya, semuanya jauh lebih rumit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e1/ef3/f8d/6e1ef3f8d1dc8a5c0b9997d067fd42e0.png">  <i>Infrastruktur Google ML</i> <br><br>  Jaringan saraf hanyalah sebagian kecil dari infrastruktur (kotak hitam kecil pada gambar di atas).  Banyak sistem tambahan yang diperlukan untuk menerima data, mengolahnya, menyimpannya, memeriksa kualitasnya, dll., Kita membutuhkan infrastruktur untuk pelatihan, menyebarkan kode pembelajaran mesin dalam produksi, menguji kode ini.  Semua tugas ini persis seperti yang dilakukan pengembang backend. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a40/21b/908/a4021b9083599fca9590b8e4e86f264e.png">  <i>Proses pembelajaran mesin</i> <br><br><h3>  Apa perbedaan antara ML dan backend </h3><br>  Dalam pemrograman klasik, kita menulis kode, dan ini menentukan perilaku program.  Dalam ML, kami memiliki kode model kecil dan banyak data yang digunakan untuk menjatuhkan model.  Data dalam ML sangat penting: model yang sama, dilatih dengan data yang berbeda, dapat menunjukkan hasil yang sama sekali berbeda.  Masalahnya adalah bahwa hampir selalu data terfragmentasi dan terletak pada sistem yang berbeda (database relasional, database NoSQL, log, file). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/337/654/f0f/337654f0fe47cacf9bc67106a4220f27.png">  <i>Versi data</i> <br><br>  ML membutuhkan versi tidak hanya dari kode, seperti dalam pengembangan klasik, tetapi juga data: perlu untuk memahami dengan jelas apa model yang dilatih.  Anda dapat menggunakan pustaka Kontrol Versi Versi Data Ilmu Pengetahuan (dvc.org) untuk ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c6/72e/c94/8c672ec94474cfe5514c2cd63ef7e19d.png"><br>  <i>Markup data</i> <br><br>  Tugas selanjutnya adalah markup data.  Misalnya, tandai semua objek dalam gambar atau katakan kelasnya milik siapa.  Ini dilakukan oleh layanan khusus seperti Yandex.Tolki, pekerjaan yang sangat menyederhanakan ketersediaan API.  Kesulitan timbul karena "faktor manusia": adalah mungkin untuk meningkatkan kualitas data dan meminimalkan kesalahan dengan mempercayakan tugas yang sama kepada beberapa pemain. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/106/5a6/ead/1065a6eadbc73ed0b75a57c7b5f81a4b.png">  <i>Visualisasi dalam Papan Tensor</i> <br><br>  Pencatatan eksperimen diperlukan untuk membandingkan hasil, memilih model terbaik untuk beberapa metrik.  Untuk visualisasi ada seperangkat alat besar - misalnya, Tensor Board.  Tetapi tidak ada metode yang ideal untuk menyimpan eksperimen.  Di perusahaan kecil, mereka sering menghabiskan biaya yang sangat tinggi, di perusahaan besar mereka menggunakan platform khusus untuk menyimpan hasil dalam database. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c2/bf3/74f/0c2bf374fc82ea80c96757253e2575b1.png">  <i>Ada banyak platform untuk pembelajaran mesin, tetapi tidak satu pun yang mencakup bahkan 70% dari kebutuhan</i> <br><br>  Masalah pertama yang harus Anda hadapi ketika Anda membawa model terlatih untuk produksi terkait dengan alat ilmuwan data favorit Anda - Jupyter Notebook.  Tidak ada modularitas di dalamnya, yaitu, output seperti "kaki-jatuh" kode yang tidak dipecah menjadi potongan-potongan logis - modul.  Semuanya tercampur aduk: kelas, fungsi, konfigurasi, dll. Kode ini sulit untuk versi dan diuji. <br><br>  Bagaimana cara mengatasinya?  Anda dapat memasang Netflix dan membuat platform Anda sendiri yang memungkinkan Anda untuk menjalankan laptop ini secara langsung dalam produksi, mentransfer data kepada mereka dan mendapatkan hasilnya.  Anda dapat memaksa pengembang yang menggulung model menjadi produksi untuk menulis ulang kode secara normal, memecahnya menjadi modul.  Tetapi dengan pendekatan ini, mudah untuk membuat kesalahan, dan model tidak akan berfungsi sebagaimana dimaksud.  Oleh karena itu, opsi yang ideal adalah untuk melarang penggunaan Notebook Jupyter untuk kode model.  Jika, tentu saja, Ilmuwan Data menyetujui hal ini. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fee/071/6bf/fee0716bf440a4cf5a28b405c0a4f775.png">  <i>Model sebagai kotak hitam</i> <br><br>  Cara termudah untuk membawa model ke produksi adalah menggunakannya sebagai kotak hitam.  Anda memiliki beberapa kelas model, bobot model (parameter neuron dari jaringan terlatih) diteruskan kepada Anda, dan jika Anda menginisialisasi kelas ini (panggil metode prediksi, letakkan gambar di atasnya), maka output akan mendapatkan semacam prediksi.  Apa yang terjadi di dalam tidak masalah. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/1dc/5a3/7ed1dc5a3f28c94339439c1625a2263d.png"><br>  <i>Pisahkan proses server dengan model</i> <br><br>  Anda juga dapat mengambil proses terpisah dan mengirimkannya melalui antrian RPC (dengan gambar atau data sumber lainnya. Pada output, kami akan menerima prediksi. <br><br>  Contoh menggunakan model dalam Flask: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@app.route("/predict", methods=["POST"]) def predict(): image = flask.request.files["image"].read() image = preprocess_image(image) predictions = model.predict(image) return jsonify_prediction(predictions)</span></span></code> </pre> <br>  Masalah dengan pendekatan ini adalah keterbatasan kinerja.  Misalkan kita memiliki kode Phyton yang ditulis oleh para ilmuwan data yang melambat, dan kami ingin memeras kinerja maksimum.  Untuk melakukan ini, Anda dapat menggunakan alat yang mengubah kode menjadi asli atau mengubahnya ke kerangka kerja lain, dipertajam untuk produksi.  Ada alat seperti itu untuk setiap kerangka kerja, tetapi tidak ada alat yang ideal, Anda harus menyelesaikannya sendiri. <br><br>  Infrastruktur dalam ML sama dengan backend biasa.  Ada Docker dan Kubernetes, hanya untuk Docker Anda perlu mengatur runtime NVIDIA, yang memungkinkan proses di dalam wadah untuk mengakses kartu video di host.  Kubernetes membutuhkan plugin sehingga dapat mengelola server dengan kartu video. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e2/d36/09d/5e2d3609d69dc2930e63945ab2dcb97d.png"><br><br>  Tidak seperti pemrograman klasik, dalam kasus ML, infrastruktur memiliki banyak elemen bergerak yang berbeda yang perlu diperiksa dan diuji - misalnya, kode pemrosesan data, model pipa pelatihan dan produksi (lihat diagram di atas).  Penting untuk menguji kode yang menghubungkan potongan pipa yang berbeda: ada banyak potongan, dan masalah sangat sering muncul di perbatasan modul. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c81/f25/9b4/c81f259b4781c850a896b5dbeb6d0302.png"><br>  <i>Cara Kerja AutoML</i> <br><br>  Layanan AutoML berjanji untuk memilih model terbaik untuk tujuan Anda dan melatihnya.  Tetapi Anda perlu memahami: dalam data ML sangat penting, hasilnya tergantung pada persiapan mereka.  Orang-orang menandai, yang penuh dengan kesalahan.  Tanpa kontrol yang ketat, sampah dapat berubah, tetapi otomatisasi belum berhasil, verifikasi oleh para ahli - ilmuwan data diperlukan.  Di sinilah AutoML "istirahat".  Tetapi dapat berguna untuk pemilihan arsitektur - ketika Anda telah menyiapkan data dan ingin melakukan serangkaian percobaan untuk menemukan model terbaik. <br><br><h3>  Cara masuk ke pembelajaran mesin </h3><br>  Masuk ke ML paling mudah jika Anda berkembang di Python, yang digunakan di semua kerangka pembelajaran yang mendalam (dan kerangka kerja biasa).  Bahasa ini praktis diperlukan untuk bidang kegiatan ini.  C ++ digunakan untuk beberapa tugas dengan visi komputer - misalnya, dalam sistem kontrol kendaraan tak berawak.  JavaScript dan Shell - untuk visualisasi dan hal-hal aneh seperti meluncurkan neuron di browser.  Java dan Scala digunakan ketika bekerja dengan Big Data dan untuk pembelajaran mesin.  R dan Julia dicintai oleh orang-orang yang melakukan statistik. <br><br>  Mendapatkan pengalaman praktis untuk memulai adalah yang paling nyaman di Kaggle, partisipasi dalam salah satu kontes platform memberi lebih dari satu tahun mempelajari teori.  Pada platform ini, Anda dapat mengambil kode seseorang yang ditata dan dikomentari dan mencoba memperbaikinya, mengoptimalkan untuk tujuan Anda.  Peringkat bonus di Kaggle memengaruhi gaji Anda. <br><br>  Pilihan lain adalah pergi sebagai pengembang backend ke tim ML.  Sekarang ada banyak startup yang terlibat dalam pembelajaran mesin, di mana Anda mendapatkan pengalaman dengan membantu rekan kerja dalam memecahkan masalah mereka.  Terakhir, Anda dapat bergabung dengan salah satu komunitas ilmuwan data - Open Data Science (ods.ai) dan lainnya. <br><br>  <i>Pembicara menempatkan informasi tambahan pada topik di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://bit.ly/backend-to-ml</a></i> <i><br></i> <br><br><h2>  "Quadrupel" - layanan pemberitahuan yang ditargetkan dari portal "Layanan Negara" </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/a44/cf2/054/a44cf20548a8c0798c440c878570afff.jpg">  Evgeny Smirnov <br><br>  Pembicara berikutnya adalah Yevgeny Smirnov, kepala departemen pengembangan infrastruktur e-government, yang berbicara tentang Quadrupel.  Ini adalah layanan notifikasi yang ditargetkan dari portal Gosuslugi (gosuslugi.ru), sumber daya negara yang paling banyak dikunjungi di Internet Rusia.  Pemirsa harian adalah 2,6 juta, semuanya, 90 juta pengguna terdaftar di situs, yang 60 juta di antaranya dikonfirmasi.  Beban pada API portal adalah 30 ribu RPS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b8/e5a/e05/3b8e5ae05d254b59de3b67093a7b0a47.png">  <i>Teknologi yang digunakan dalam backend Gosuslug</i> <br><br>  "Quadruple" adalah layanan pemberitahuan alamat, dengan bantuan yang pengguna menerima tawaran layanan pada saat yang paling tepat baginya dengan menyiapkan aturan informasi khusus.  Persyaratan utama dalam pengembangan layanan adalah pengaturan yang fleksibel dan waktu yang cukup untuk pengiriman. <br><br><h3>  Bagaimana cara Quadruple bekerja? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/4a3/d78/484/4a3d78484bbe63c0ef0f1f439125b816.png"><br><br>  Diagram di atas menunjukkan salah satu aturan â€œQuadrupleâ€ pada contoh situasi dengan kebutuhan untuk mengganti SIM.  Pertama, layanan mencari pengguna yang tanggal kedaluwarsanya habis dalam sebulan.  Mereka memasang spanduk dengan tawaran untuk menerima layanan yang sesuai dan mengirim pesan email.  Bagi pengguna yang sudah kedaluwarsa, spanduk dan email berubah.  Setelah pertukaran hak berhasil, pengguna menerima pemberitahuan lain - dengan proposal untuk memperbarui data dalam sertifikat. <br><br>  Dari sudut pandang teknis, ini adalah skrip asyik di mana kode ditulis.  Pada input - data, pada output - benar / salah, cocok / tidak cocok.  Secara total, lebih dari 50 aturan - mulai dari menentukan ulang tahun pengguna (tanggal saat ini sama dengan ulang tahun pengguna) hingga situasi sulit.  Setiap hari, menurut aturan ini, sekitar satu juta pertandingan ditentukan - orang yang perlu diberi tahu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/018/480/a99/018480a990a48fb2d6af080d4e16d20c.png">  <i>Saluran Pemberitahuan Quadruple</i> <br><br>  Di bawah kap Quadrupel ada database di mana data pengguna disimpan, dan tiga aplikasi: <br><br><ul><li>  <b>Pekerja</b> dirancang untuk memperbarui data. <br></li><li>  <b>API Istirahat</b> mengambil dan memberikan spanduk sendiri ke portal dan ke aplikasi seluler. <br></li><li>  <b>Penjadwal</b> meluncurkan penghitungan ulang spanduk atau pengiriman massal. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/fe6/b64/57f/fe6b6457f25777215b56879621a2a0f9.png"><br><br>  Backend berorientasi pada peristiwa untuk memperbarui data.  Dua antarmuka - istirahat atau JMS.  Ada banyak acara, sebelum disimpan dan diproses, mereka dikumpulkan agar tidak membuat permintaan yang tidak perlu.  Basis data itu sendiri, pelat tempat data disimpan, tampak seperti penyimpanan nilai kunci - kunci pengguna dan nilai itu sendiri: bendera yang menunjukkan ada atau tidaknya dokumen yang relevan, periode validitasnya, statistik agregat pada urutan layanan oleh pengguna ini, dan sebagainya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ee/0d6/89b/5ee0d689be5f4dd6a2deb353b3523316.png"><br><br>  Setelah menyimpan data, tugas diatur dalam JMS sehingga spanduk segera dihitung ulang - ini harus segera ditampilkan di web.  Sistem dimulai pada malam hari: dalam tugas JMS dilemparkan pada interval pengguna, sesuai dengan yang Anda perlu menceritakan aturan.  Ini diambil oleh recounters.  Selanjutnya, hasil pemrosesan jatuh ke antrian berikutnya, yang menyimpan spanduk di database, atau mengirim tugas kepada pengguna untuk memberi tahu pengguna.  Proses ini memakan waktu 5-7 jam, mudah untuk diskalakan karena Anda selalu dapat menjatuhkan prosesor atau meningkatkan instans dengan prosesor baru. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca9/491/685/ca94916852f26beb07515670f718219e.png"><br><br>  Layanan bekerja dengan sangat baik.  Tetapi jumlah data bertambah karena semakin banyak pengguna.  Hal ini menyebabkan peningkatan beban pada basis data - bahkan dengan mempertimbangkan fakta bahwa API Istirahat sedang melihat replika.  Poin kedua adalah JMS, yang, ternyata, sangat tidak cocok karena konsumsi memori yang besar.  Ada risiko tinggi overflow antrian dengan crash JMS dan pemrosesan berhenti.  Tidak mungkin untuk meningkatkan JMS setelah ini tanpa membersihkan log. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/114/bb1/ad6/114bb1ad6e5870eb3ea7d0fb2228233a.png"><br><br>  Direncanakan untuk memecahkan masalah menggunakan sharding, yang akan memungkinkan menyeimbangkan beban di pangkalan.  Ada juga rencana untuk mengubah skema penyimpanan data, dan mengubah JMS ke Kafka - solusi yang lebih toleran terhadap kesalahan yang akan menyelesaikan masalah memori. <br><br><h2>  Backend-as-a-Service Vs.  Tanpa server </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e71/98c/48d/e7198c48dcf015593d8753bbb53b9164.jpg"><br>  <i>Dari kiri ke kanan: Alexander Borgart, Andrey Tomilenko, Nikolai Markov, Ara Israelyan</i> <br><br>  Backend sebagai solusi layanan atau serverless?  Orang-orang berikut berpartisipasi dalam diskusi tentang masalah mendesak ini di meja bundar: <br><br><ul><li>  Ara Israelyan, CTO CTO dan pendiri Scorocode. <br></li><li>  Nikolay Markov, Insinyur Data Senior di Aligned Research Group. <br></li><li>  Andrey Tomilenko, Kepala Departemen Pengembangan RUVDS. <br></li></ul><br>  Percakapan dimoderatori oleh pengembang senior Alexander Borgart.  Kami menyajikan debat, di mana audiens berpartisipasi, dalam versi singkat. <br><br>  <b>- Apa yang dimaksud dengan Serverless dalam pemahaman Anda?</b> <b><br></b> <br>  <b>Andrei</b> : Ini adalah model komputasi - fungsi Lambda yang harus memproses data sehingga hasilnya hanya bergantung pada data.  Istilah ini berasal dari Google, atau dari Amazon dan layanan AWS Lambda.  Lebih mudah bagi penyedia untuk memproses fungsi seperti itu dengan mengalokasikan kumpulan kapasitas untuk ini.  Pengguna yang berbeda dapat dipertimbangkan secara mandiri di server yang sama. <br>  <b>Nikolay</b> : Jika sederhana, kami mentransfer sebagian dari infrastruktur TI kami, logika bisnis ke cloud, untuk melakukan outsourcing. <br>  <b>Ara</b> : Pada bagian pengembang - upaya yang baik untuk menghemat sumber daya, pada bagian dari pemasar - untuk mendapatkan lebih banyak uang. <br><br>  <b>- Serverless - sama dengan microservices?</b> <b><br></b> <br>  <b>Nikolai</b> : Tidak, Serverless lebih merupakan organisasi arsitektur.  Microservice adalah unit atom dari logika tertentu.  Serverless adalah pendekatan, bukan "entitas yang terpisah." <br>  <b>Ara</b> : Fungsi Serverless dapat dikemas dalam microservice, tetapi dari sini akan berhenti menjadi Serverless, berhenti menjadi fungsi Lambda.  Di Serverless, suatu fungsi hanya dimulai ketika diminta. <br>  <b>Andrew</b> : Mereka berbeda dalam waktu hidup.  Kami meluncurkan dan melupakan fungsi Lambda.  Itu berfungsi selama beberapa detik, dan klien berikutnya dapat memproses permintaannya pada mesin fisik lain. <br><br>  <b>- Timbangan mana yang lebih baik?</b> <b><br></b> <br>  <b>Ara</b> : Dengan penskalaan horizontal, fungsi Lambda berperilaku persis sama dengan layanan microser. <br>  <b>Nikolai</b> : Berapa banyak replika yang Anda tanyakan - akan ada begitu banyak, tidak ada masalah dengan penskalaan Serverless.  Kubernetes membuat set replika, meluncurkan 20 contoh "di suatu tempat", dan 20 tautan anonim kembali ke Anda.  Silakan! <br><br>  <b>- Apakah mungkin untuk menulis backend di Serverless?</b> <b><br></b> <br>  <b>Andrew</b> : Secara teoritis, tetapi tidak ada gunanya dalam hal ini.  Fungsi Lambda akan bersandar pada repositori tunggal - kita perlu memberikan jaminan.  Misalnya, jika pengguna melakukan transaksi tertentu, maka saat berikutnya ia akan melihat: transaksi telah selesai, dana telah dikreditkan.  Semua fungsi Lambda akan diblokir pada panggilan ini.  Bahkan, sekelompok fungsi Serverless akan berubah menjadi satu layanan dengan satu titik sempit akses ke database. <br><br>  <b>- Dalam situasi apa masuk akal untuk menggunakan arsitektur tanpa server?</b> <b><br></b> <br>  <b>Andrew</b> : Tugas di mana penyimpanan umum tidak diperlukan - penambangan yang sama, blockchain.  Di mana Anda perlu banyak menghitung.  Jika Anda memiliki banyak daya komputasi, maka Anda dapat mendefinisikan fungsi seperti "menghitung hash dari sesuatu di sana ..." Tetapi Anda dapat memecahkan masalah penyimpanan data dengan mengambil, misalnya, fungsi Amazon dan Lambda, dan penyimpanan terdistribusi mereka.  Dan ternyata Anda menulis layanan reguler.  Fungsi Lambda akan mengakses repositori dan memberikan semacam respons kepada pengguna. <br>  <b>Nikolai</b> : Kontainer yang berjalan di Serverless sangat terbatas sumber daya.  Ada sedikit memori dan yang lainnya.  Tetapi jika Anda memiliki semua infrastruktur yang digunakan sepenuhnya pada beberapa jenis cloud - Google, Amazon - dan Anda memiliki kontrak permanen dengan mereka, ada anggaran untuk semua ini, maka untuk beberapa tugas Anda dapat menggunakan wadah tanpa Server.  Penting untuk ditempatkan tepat di dalam infrastruktur ini, karena semuanya dirancang untuk digunakan dalam lingkungan tertentu.  Artinya, jika Anda siap untuk mengikat semuanya dengan infrastruktur cloud, Anda bisa bereksperimen.  Kelebihannya adalah Anda tidak harus mengelola infrastruktur ini. <br>  <b>Ara</b> : Serverless itu tidak mengharuskan Anda untuk mengelola Kubernetes, Docker, menginstal Kafka, dan sebagainya, adalah penipuan diri sendiri.  Amazon dan Google yang sama adalah manajer dan mereka menaruhnya.  Hal lain adalah Anda memiliki SLA.  Dengan kesuksesan yang sama, Anda dapat melakukan outsourcing semua, dan tidak memprogramnya sendiri. <br>  <b>Andrew</b> : Serverless itu sendiri tidak mahal, tetapi Anda harus membayar banyak untuk sisa layanan Amazon - misalnya, database.  Orang-orang sudah menggugat mereka karena fakta bahwa mereka merobek uang gila untuk gerbang API. <br>  <b>Ara</b> : Jika kita berbicara tentang uang, maka Anda perlu mempertimbangkan hal ini: Anda harus menggunakan 180 derajat seluruh metodologi pengembangan di perusahaan untuk mentransfer semua kode ke Serverless.  Itu akan memakan banyak waktu dan uang. <br><br>  <b>- Apakah ada alternatif yang layak untuk Amazon Serverless dan Google berbayar?</b> <b><br></b> <br>  <b>Nikolay</b> : Di Kubernetes, Anda memulai beberapa jenis pekerjaan, memenuhi dan mati - ini cukup Serverless dari sudut pandang arsitektur.  Jika Anda ingin membuat logika bisnis yang benar-benar menarik dengan antrian, dengan basis, maka Anda perlu berpikir lebih banyak tentangnya.  Ini semua diselesaikan tanpa meninggalkan Kubernetes.  Saya tidak akan mulai menyeret implementasi tambahan. <br><br>  <b>- Seberapa pentingkah untuk memantau apa yang terjadi di Serverless?</b> <b><br></b> <br>  <b>Ara</b> : Tergantung pada arsitektur sistem dan persyaratan bisnis.  Bahkan, penyedia harus menyediakan laporan yang akan membantu devo mengetahui kemungkinan masalah. <br>  <b>Nikolai</b> : Di Amazon ada CloudWatch, tempat semua log dialirkan, termasuk dengan Lambda.  Integrasikan penerusan log dan gunakan beberapa alat terpisah untuk melihat, mengingatkan, dan sebagainya.  Dalam wadah yang Anda mulai, Anda bisa menjejalkan agen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/173/767/b57/173767b57ac15dd164ad69c428d9ae03.jpg"><br><br>  <b>- Mari kita simpulkan.</b> <b><br></b> <br>  <b>Andrew</b> : Memikirkan fungsi Lambda bermanfaat.  Jika Anda membuat layanan dengan lutut - bukan layanan microser, tetapi layanan yang menulis permintaan, mengakses database dan mengirim jawaban - fungsi Lambda memecahkan sejumlah masalah: multithreading, skalabilitas, dan banyak lagi.  Jika logika Anda dibangun dengan cara ini, maka di masa depan Anda akan dapat mentransfer Lambda ini ke layanan microser atau menggunakan layanan pihak ketiga seperti Amazon.  Teknologi ini bermanfaat, ide yang menarik.  Berapa banyak dibenarkan untuk bisnis masih merupakan pertanyaan terbuka. <br>  Nikolai: Serverless lebih baik digunakan untuk operasi-tugas daripada menghitung semacam logika bisnis.  Saya selalu menganggap ini sebagai pemrosesan acara.  Jika Anda memilikinya di Amazon, jika Anda berada di Kubernetes - ya.  Jika tidak, Anda harus melakukan banyak upaya untuk meningkatkan Serverless sendiri.  Anda perlu menonton kasus bisnis tertentu.  Sebagai contoh, saya memiliki salah satu tugas sekarang: ketika file muncul pada disk dalam format tertentu, Anda perlu mengunggahnya ke Kafka.  Saya bisa menggunakan WatchDog atau Lambda ini.  Secara logis, keduanya cocok, tetapi Serverless lebih sulit untuk diimplementasikan, dan saya lebih suka cara yang lebih sederhana, tanpa Lambda. <br>  <b>Ara</b> : Serverless - ide yang menarik, dapat diterapkan, sangat indah secara teknis.  Cepat atau lambat, teknologi akan mencapai titik di mana fungsi apa pun akan naik dalam waktu kurang dari 100 milidetik.  Kemudian, pada prinsipnya, tidak akan ada pertanyaan apakah waktu tunggu sangat penting bagi pengguna.  Pada saat yang sama, penerapan Serverless, seperti yang telah dikatakan rekan kerja, sepenuhnya tergantung pada tugas bisnis. <br><br>  <b>Kami berterima kasih kepada para sponsor kami yang telah banyak membantu kami:</b> <b><br></b> <br><ul><li>  Ruang konferensi TI " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spring</a> " di belakang platform untuk konferensi. </li><li>  Kalender acara TI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Runet-ID</a> dan publikasi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Internet dalam angka</a> " untuk dukungan informasi dan berita. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Akronis</a> untuk hadiah. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Avito</a> untuk kreasi bersama. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RAEC</a> "Asosiasi Komunikasi Elektronik" untuk keterlibatan dan pengalaman. </li><li>  Sponsor utama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RUVDS</a> - untuk semuanya! </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/7d5/374/7cc/7d53747cc37e595ec4ec995267865c93.jpg"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472916/">https://habr.com/ru/post/id472916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472902/index.html">Windows for IoT: Dukungan Perangkat Keras yang Disempurnakan dan Fitur Perangkat Cerdas Baru</a></li>
<li><a href="../id472904/index.html">Bagaimana Amazon Mengubah Saham Bekerja menjadi Game</a></li>
<li><a href="../id472908/index.html">Dagaz: Episodes (Bagian 2)</a></li>
<li><a href="../id472910/index.html">Temukan teks pada tanda dan paket menggunakan smartphone</a></li>
<li><a href="../id472912/index.html">Database ClickHouse untuk manusia, atau Teknologi Asing</a></li>
<li><a href="../id472918/index.html">ZX Spectrum di Rusia dan CIS: bagaimana pengejaran online berubah secara offline</a></li>
<li><a href="../id472922/index.html">Programmer defender lebih kuat dari entropi</a></li>
<li><a href="../id472926/index.html">Hukum percepatan pengembalian (bagian 1)</a></li>
<li><a href="../id472928/index.html">Layanan komputasi GPU yang sangat dimuat</a></li>
<li><a href="../id472930/index.html">Silicon Valley, Astrofisika, Mengukur Mode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>