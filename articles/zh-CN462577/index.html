<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋🏼 🧜🏻 🏢 我的Nim开发经验 ☹️ 🦇 😵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！ 


 现在已经有一段时间了，我一直在编写我的游戏框架-这样的灵魂工程。 而且由于灵魂需要选择自己喜欢的东西（在这种情况下，是您喜欢写的东西），所以我的选择落在了尼姆身上。 在本文中，我想专门讨论一下nim，它的功能，优缺点，而gamedev的主题仅设置了我的经验背景-我解决了什么任务，出...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我的Nim开发经验</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462577/"><p><img src="https://habrastorage.org/webt/vx/0d/ig/vx0dignqhsbwiaewbqugebd06iw.jpeg"></p><br><p> 哈Ha！ </p><br><p> 现在已经有一段时间了，我一直在编写我的游戏框架-这样的灵魂工程。 而且由于灵魂需要选择自己喜欢的东西（在这种情况下，是您喜欢写的东西），所以我的选择落在了尼姆身上。 在本文中，我想专门讨论一下nim，它的功能，优缺点，而gamedev的主题仅设置了我的经验背景-我解决了什么任务，出现了什么困难。 </p><br><p> 从前，当草更绿，天空更清洁时，我遇到了尼姆。 不，不是那样。 从前，我想开发游戏来编写自己最酷的游戏-我认为很多人都经历了这一过程。 在那些日子里，Unity和Unreal Engine刚刚开始出现在听证会上，并且好像还不是免费的。 我之所以没有使用它们，不是因为贪婪，而是因为我自己写所有东西的愿望，从而完全从零开始，从头开始创建游戏世界。 <del> 第一个 </del> 零字节。 是的，很长一段时间，是的，这很困难，但是过程本身带来了乐趣-但是幸福还需要什么呢？ </p><a name="habracut"></a><br><p> 带着Straustrup和Qt武装起来，我最大程度地喝了屎，因为，首先，我不是世界上十分了解C ++的10个人中的一个，其次，加号积极地使我的手忙脚乱。 我认为没有理由再重复已经为我写的引人注目的内容： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我如何找到世界上最好的编程语言。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我如何找到世界上最好的编程语言。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我如何找到世界上最好的编程语言。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Yo部分（2.72）</a> </p><br><blockquote> 当您自由地编写代码，几乎没有思考，无需等待每次启动之前将内核转储，当我们眼前添加功能时，这是一个疯狂的嗡嗡声，现在我们可以做到，现在，请告诉我，这对我有什么影响我什至都不会错过模板吗？ 生产力是做事的程序员的主要目标，也是他使用工具的唯一任务。 </blockquote><p> 使用C ++时，我一直在思考<em>如何</em>写自己想要的东西，而不是写给我的东西。 所以我改用了尼姆。 故事结束了，让我在nim工作了几年后与您分享我的经验。 </p><br><h2 id="obschie-svedeniya-dlya-teh-kto-ne-v-kurse"> 那些不认识的人的一般信息 </h2><br><ul><li> 发烧友开发的开源编译器（MIT）。 该语言的创建者是Andreas Rumpf（Araq）。 第二位开发人员是Dominik Picheta（dom96），他撰写了《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">行动中的尼姆</a> 》一书。 另外，不久前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Status</a>开始赞助该语言的开发，因此nim拥有了2名全职开发人员。 除了他们，其他人当然也会有所贡献。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">1.0版</a>最近已<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">发布</a> ，这意味着该语言是稳定的，不再需要“重大更改”。 如果以前您不想使用不稳定版本，因为更新可能会破坏应用程序，那么现在是时候在项目中尝试使用nim了。 </li><li>  Nim编译（或转置）为C，C ++（进一步编译为本机代码）或JS（具有某些限制）。 因此，在FFI的帮助下，您可以使用所有现有的C和C ++库。 如果nim上没有必要的软件包-寻找s或pluses。 </li><li> 最接近的语言是python（乍看之下是语法）和D（通过功能来看）-IMHO </li></ul><br><h2 id="dokumentaciya"> 该文件 </h2><br><p> 这实际上是不好的。 问题： </p><br><ol><li> 该文档散布在不同的来源 </li><li> 该文件 <del> 狗屎 </del> 不能完全描述语言的所有功能 </li><li> 文档有时过于简洁。 </li></ol><br><p>示例：如果要编写多线程应用程序，则有很多核心，但是无处可去。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">这是有关流的官方文档部分</a> 。 不，您知道， <em>线程</em>是语言的独立主要部分，在编译时甚至需要在<code>--threads:on</code>标志中包含其功能。 在那里，取决于垃圾回收器，各种共享内存和锁，线程安全性，特殊的共享模块，共享堆或线程本地堆，地狱知道其他什么。 我怎么知道这一切？ 没错，从实际行动的nim，论坛，堆栈溢出，电视以及邻居（通常在任何地方，而不是官方文档中）的角度出发。 </p><br><p> 还是有所谓的。  “注释”-在使用模板等时，通常在您需要传递回调或仅代码块的任何地方，都可以很好地工作。 我在哪里可以读到它？ 是的，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">实验功能手册中</a> 。 </p><br><p> 同意，收集有关各种非情报来源的信息仍然是一种荣幸。 如果用nim编写，则<em>必须</em>这样做。 </p><br><p> 在论坛和github问题上，有关于改进文档的建议，但是事情没有进展。 在我看来，似乎缺少某种硬手，它会说“一切，社区，拿铁锹去耙这堆……精巧而分散的文字。” </p><br><p> 幸运的是，我击中了自己，所以我向您展示了尼姆冠军的名单。 </p><br><h3 id="dokumentaciya-1"> 该文件 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">教程1</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">教程2-</a>从他们开始 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">行动</a>中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">尼姆</a>是一本解释性的书，确实很好地解释了语言的许多方面，有时甚至比语言要好得多。 文件资料 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim手册</a> -实际上是手册-几乎所有内容都已描述，但没有 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim实验手册</a> -为什么不真正在单独的页面上继续文档？ </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">索引</a> -链接到此处的所有内容，即通常可以在nim中找到的所有内容。 如果您在教程和手册中找不到所需的内容，则肯定会在索引中找到它。 </li></ul><br><h3 id="uroki-i-tutorialy"> 经验教训 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim基础知识</a> -初学者基础知识，复杂主题未涵盖 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim Days-</a>小型项目（现场示例） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Rosetta代码</a> -比较不同PL上相同任务的解决方案非常酷，包括 尼姆 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Exercism.io-</a>在这里您可以进入“ nim path”，完成任务 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">尼姆的例子</a> </li></ul><br><h3 id="pomosch"> 帮忙 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">IRC</a>是nimmers？的主要栖息地……，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Discord</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Gitter</a>上播放。 我从未使用过IRC（现在仍然不使用它）。 通常，这是一个非常奇怪的选择。 还有鸽子信给他...好吧，开玩笑。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim论坛</a>该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">论坛的</a>功能很少，但是1）在这里您可以找到答案2）在这里您可以问一个问题，如果第1项不起作用3）答案的可能性大于50％4）语言开发人员正坐在论坛上并正在积极响应。 顺便说一下，该论坛是用nim编写的，因此没有任何功能 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim电报组</a> -可以提出问题，但不能获得答案。 </li><li> 还有一个俄罗斯电报小组，如果您对nim感到厌倦并且不想听到任何有关它的信息，则应该去那里:)（部分是个玩笑） </li></ul><br><h3 id="playground"> 游乐场 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim Playground-</a>在这里您可以直接在浏览器中在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim</a>上运行程序 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim docker交叉编译</a> -在这里您可以阅读如何启动docker映像以及针对不同平台编译程序。 </li></ul><br><h3 id="pakety"> 配套 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">nimble.directory-</a>这是所有可通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">nimble</a>软件包管理器安装的已发布软件包。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">精选的套餐清单</a> -爱好者汇编的或多或少的实时套餐清单 </li></ul><br><h3 id="perehod-na-nim-s-drugih-yazykov"> 从其他语言切换到nim </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在Nim中</a>进行导入-文章介绍了如何最好地导入模块以及为什么使您暂时摆脱pythonist的精神 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">面向Python程序员的Nim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Nim for C程序员</a> </li></ul><br><h2 id="chto-nravitsya"> 你喜欢什么 </h2><br><p> 列出该语言的所有功能没有任何意义，但是这里有一些功能： </p><br><h3 id="fraktal-slozhnosti"> 分形复杂度 </h3><br><p>  Nim为您提供了“复杂程度”。 您可以编写高级代码。 您可以使用原始指针进行对接，并尽一切可能<code>attempt to read from nil</code> 。 您可以嵌入C代码。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在汇编程序中</a>编写<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">插入内容</a> 。 您可以编写过程（静态调度）。 不够-有“方法”（动态分配）。 还有吗 有泛型，也有模仿功能的泛型。 有模板-一种替换机制，但不像C ++那样呕吐（这里是否有宏-它仅仅是文本替换，还是更聪明？）。 最后有宏-就像IDDQD，它们启用了上帝模式，并允许您直接使用AST并从字面上替换语法树的各个部分，或者根据需要自己扩展语言。 <br> 就是说，在“高”级别上，您可以编写不知道的地狱之词和悲痛，但没有人禁止您进行任何复杂的欺诈。 </p><br><h3 id="skorost-razrabotki"> 发展速度 </h3><br><p> 学习曲线不是曲线。 这是直接的。 通过安装nim，您将在第一分钟开始您的第一个问候世界，在第一天，您将编写一个简单的实用程序。 但是在接下来的几个月中，您将学到一些东西。 例如，我从程序开始，然后我需要方法，过了一会儿泛型对我非常有用，最近我发现模板的功能非常丰富，而我却完全不使用宏。 与相同的rust或c ++相比，与nim合并要容易得多。 </p><br><h3 id="package-management"> 包装管理 </h3><br><p> 有一个名为nimble的软件包管理器，可以安装，卸载，创建软件包和加载依赖项。 创建软件包（=项目）时，可以使用nimble编写不同的任务（使用nimscript，它是在VM上执行的nim的子集），例如，生成文档，运行测试，复制资产等。  Nimble不仅放置必要的依赖项，而且还允许您为项目配置工作环境。 也就是说，从广义上讲，敏捷是CMake，它不是由变态者而是由普通人编写的。 </p><br><h3 id="chitaemost-i-vyrazitelnost"> 可读性和表现力 </h3><br><p> 从外部看，nim与带类型注释的python非常相似，尽管nim根本不是python。  Python主义者将不得不忘记动态类型，继承，装饰器和其他乐趣，并且通常会重新构造他们的思维。 不要尝试将您的python经验转移给nim，因为两者之间的差异太大。 一开始，我真的很想要异构集合和带有装饰器的mixin。 但是后来你以某种方式习惯了艰苦的生活:) </p><br><p> 这是一个nim程序示例： </p><br><pre> <code class="plaintext hljs"> type NumberGenerator = object of Service # this service just generates some numbers NumberMessage = object of Message number: int proc run(self: NumberGenerator) = if not waitAvailable("calculator"): echo "Calculator is unavailable, shutting down" return for number in 0..&lt;10: echo &amp;"Sending number {number}" (ref NumberMessage)(number: number).send("calculator")</code> </pre> <br><h3 id="modulnost"> 模块化 </h3><br><p> 一切都分为模块，您可以根据需要导入-仅导入某些字符，或者仅导入某些字符，或者导入全部或全部字符，或者不导入任何字符，并强制用户指定<code>module.function()</code>的完整路径，并使用其他名称进行导入。 当然，所有这些变化在辩论“哪种编程语言更好”中非常有用，在您的项目中，您将安静地<code>import mymodule</code>编写<code>import mymodule</code>而不会提及其他选项。 </p><br><h3 id="method-call-syntax"> 方法调用语法 </h3><br><p> 可以通过不同方式记录函数调用： </p><br><pre> <code class="plaintext hljs"> double(2) double 2 2.double() 2.double</code> </pre> <br><p> 一方面，现在每个人都……按自己喜欢的方式写作（当然，每个人都喜欢以不同的方式，甚至在一个项目的框架内也以不同的方式）。 但是随后所有函数都可以编写为方法调用，从而大大提高了可读性。 在python中，它可以是： </p><br><pre> <code class="python hljs">list(set(some_list)) <span class="hljs-comment"><span class="hljs-comment"># -:   ,     map  filter    </span></span></code> </pre> <br><p>  nim中的相同代码可以更逻辑地重写： </p><br><pre> <code class="plaintext hljs">some_list.set.list #   </code> </pre> <br><h3 id="oop"> 面向对象 </h3><br><p>  OOP尽管存在，但在plus和python上却与之不同：对象和方法是不同的实体，并且很可能存在于不同的模块中。 此外，您可以为<code>int</code>等基本类型编写方法 </p><br><pre> <code class="plaintext hljs"> proc double(number: int): int = number * 2 echo $2.double() # prints "4"</code> </pre> <br><p> 另一方面，在nim中有封装（在nim中模块的第一条规则是不告诉任何人没有星号的标识符）。 这是标准模块的示例： </p><br><pre> <code class="plaintext hljs"># sharedtables.nim type SharedTable*[A, B] = object ## generic hash SharedTable data: KeyValuePairSeq[A, B] counter, dataLen: int lock: Lock</code> </pre> <br><p>  <code>SharedTable*</code>类型标有星号，表示它在其他模块中“可见”并且可以导入。 但是这里<code>data</code> ， <code>counter</code>和<code>lock</code>是私有成员，而<code>sharedtables.nim</code>不能从外部访问。 当我决定为<code>SharedTable</code>类型编写一些其他函数（例如<code>len</code>或<code>hasKey</code> ，这让我感到非常高兴，发现我无法访问<code>counter</code>或<code>data</code> ，并且“扩展” <code>SharedTable</code>的唯一方法是编写自己的 <del>  ，加上bl </del></p><br><p> 通常，与同一个python（根据个人经验）相比，使用继承的频率要少得多，因为存在方法调用语法（请参见上文）和对象变量（请参见下文）。  nim路径是组合而不是继承。 多态性也是如此：在nim中，有一些方法可以在后继类中重写，但是必须在编译期间使用<code>--multimethods:on</code>标志明确指定这些<code>--multimethods:on</code> 。 也就是说，默认情况下，方法不起作用，这稍微鼓励了没有它们的工作。 </p><br><h3 id="compile-time-execution"> 编译时执行 </h3><br><p> 常量-在编译阶段计算某些内容并将其“缝制”成结果二进制文件的能力。 凉爽舒适。 通常，nim与“编译时间”有特殊关系，甚至还有一个<code>when</code>关键字-就像<code>if</code> ，但比较是在编译阶段。 你可以写类似 </p><br><pre> <code class="plaintext hljs"> when defined(SDL_VIDEO_DRIVER_WINDOWS): import windows ## oldwinapi lib elif defined(SDL_VIDEO_DRIVER_X11): import x11/x, x11/xlib ## x11 lib</code> </pre> <br><p> 尽管在编译阶段可以执行的操作受到限制（例如，无法进行FFI调用），这非常方便。 </p><br><h3 id="reference-type"> 参考类型 </h3><br><p> 引用类型-C ++中shared_ptr的类似物，垃圾收集器将处理它。 但是，您也可以在方便时自行调用垃圾收集器。 或者，您可以尝试使用其他垃圾收集器选项。 或者，您可以完全禁用垃圾收集器并使用常规指针。 </p><br><p> 理想情况下，如果不使用原始指针和FFI，则不太可能出现分段错误。 实际上，到目前为止，任何地方都没有FFI。 </p><br><h3 id="lambdas">  Lambdas </h3><br><p> 有匿名过程（在python中又称为lambdas），但是与匿名过程中的python不同，您可以使用以下语句： </p><br><pre> <code class="plaintext hljs">someProc(callback=proc(a: int) -&gt; int = var b = 5*a; result = a)</code> </pre> <br><h3 id="exceptions"> 例外情况 </h3><br><p> 有一些异常，它们抛出起来非常不便：python <code>raise ValueError('bad value')</code> ，nim <code>raise newException(ValueError, "bad value")</code> 。 没什么不寻常的-尝试一下，除了最后，一切都和其他人一样。 我作为例外（而不是错误代码）的支持者感到高兴。 顺便说一下，您可以为函数指出它们可以抛出哪些异常，编译器将检查以下内容： </p><br><pre> <code class="plaintext hljs">proc p(what: bool) {.raises: [IOError, OSError].} = if what: raise newException(IOError, "IO") else: raise newException(OSError, "OS")</code> </pre> <br><h3 id="generics"> 泛型 </h3><br><p> 泛型非常有表现力，例如，您可以限制可能的类型 </p><br><pre> <code class="plaintext hljs">proc onlyIntOrString[T: int|string](x, y: T) = discard #  int  string</code> </pre> <br><p> 您可以将类型作为参数传递给它-它看起来像一个普通函数，但实际上是一个泛型： </p><br><pre> <code class="plaintext hljs">proc p(a: typedesc; b: a) = discard # is roughly the same as: proc p[T](a: typedesc[T]; b: T) = discard # hence this is a valid call: p(int, 4) # as parameter 'a' requires a type, but 'b' requires a value.</code> </pre> <br><h3 id="templates"> 范本 </h3><br><p> 模板就像C ++中的宏一样，只是<em>正确地</em>完成了:)-您可以安全地将整个代码块转移到模板中，而不用认为替换会破坏外部代码中的某些内容（但是您可以再次，如果确实需要，可以将其弄乱）。 </p><br><p> 这是一个示例<code>app</code>模板，根据变量的值，它调用以下代码块之一： </p><br><pre> <code class="plaintext hljs">template app*(serverCode: untyped, clientCode: untyped) = # ... case mode of client: clientCode of server: serverCode else: discard</code> </pre> <br><p> 使用<code>do</code>我可以将整个块传递给模板，例如： </p><br><pre> <code class="plaintext hljs">app do: # serverCode echo "I'm server" serverProc() do: # clientCode echo "I'm client" clientProc()</code> </pre> <br><h3 id="interactive-shell"> 互动壳 </h3><br><p> 如果您需要快速测试某些东西，即调用“解释器”或“ nim shell”的能力（就像您在不带参数的情况下运行<code>python</code> ）。 为此，请使用<code>nim secret</code>命令或下载<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">inim</a>软件包。 </p><br><h3 id="ffi"> 联邦调查局 </h3><br><p>  FFI-与C / C ++中的第三方库进行交互的能力。 不幸的是，要使用外部库，您必须编写一个包装程序，以说明从何处以及从何处进行导入。 例如： </p><br><pre> <code class="plaintext hljs">{.link: "/usr/lib/libOgreMain.so".} type ManualObjectSection* {.importcpp: "Ogre::ManualObject::ManualObjectSection", bycopy.} = object</code> </pre> <br><p> 有一些工具可以使该过程成为半自动的： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">c2nim</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">尼姆特罗普</a> </li></ul><br><h2 id="chto-ne-nravitsya"> 什么不喜欢 </h2><br><h3 id="slozhnost"> 难点 </h3><br><p> 太多了 该语言被认为是极简主义的，但是现在离真相还很远。 例如，为什么我们要对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">代码重新排序</a> ？ </p><br><h3 id="izbytochnost"> 冗余度 </h3><br><p> 很多东西： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">system.addInt-</a> “将整数转换为其字符串表示形式并将其附加到结果中”。 在我看来，这是一个非常方便的功能，我在每个项目中都使用它。 这是另一个有趣的例子：fileExists和existFile（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">https://forum.nim-lang.org/t/3636</a> ） </p><br><h3 id="net-unifikacii"> 没有统一 </h3><br><p>  “只有一种方法可以做到”-根本没有： </p><br><ul><li> 方法调用语法-根据需要编写函数调用 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><code>fmt</code> vs <code>&amp;</code></a> </li><li>  camelCase和underscore_notation </li><li> 这和他的（破坏者：是同一回事） </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">功能</a> vs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">程序</a> vs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">模板</a> </li></ul><br><h3 id="bagi-net-bagi"> 虫子（没有包！） </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">大约有1400个</a> bug。 或者只是去论坛- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">他们</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">不断</a>发现<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">一些</a>错误。 </p><br><h3 id="stabilnost"> 稳定度 </h3><br><p> 除了上一段之外，v1还意味着稳定性，对吗？ 阿拉克语的创建者在这里飞到论坛上说：“伙计，我这里有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">另一个（第六个）</a>垃圾收集器，它更凉，更快，更年轻，为您提供线程共享内存（哈哈，在此之前您遭受了苦难，使用拐杖），下载开发分支并尝试。 所有这些<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">“哇，太酷了！这对凡人意味着什么？我们现在需要再次更改所有代码吗？”</a> 似乎没有，所以我更新了nim，运行了一个新的垃圾收集器<code>--gc:arc</code> ，我的程序在编译c ++代码的阶段崩溃了（即不是在nim中，而是在gcc中）： </p><br><pre> <code class="plaintext hljs">/usr/lib/nim/system.nim:274:77: error: 'union pthread_cond_t' has no member named 'abi' 274 | result = x</code> </pre> <br><p> 太好了！ 现在，我不必修复新代码，而必须修复旧代码。 那不是我选择nim时的运行方式吗？ </p><br><p> 很高兴知道我<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">并不孤单</a> </p><br><h3 id="metody-i-mnogopotochnost"> 方法和多线程 </h3><br><p> 默认情况下，multimethods和threads标志是关闭的-您不会 <del>  2019年 </del>  2020年编写具有重写方法的多线程应用程序？ 如果在不考虑流程的情况下创建您的库，然后<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">用户打开它们</a> ，那真是太棒<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">了</a> ……哦，是的，有许多很棒的编译指示{.inheritable。}和{.base。}对于继承，以便您的代码不太简洁。 </p><br><h3 id="object-variants"> 对象变体 </h3><br><p> 您可以通过使用所谓的避免继承 对象变体： </p><br><pre> <code class="plaintext hljs">type CoordinateSystem = enum csCar, # Cartesian csCyl, # Cylindrical Coordinates = object case cs: CoordinateSystem: # cs is the coordinate discriminator of csCar: x: float y: float z: float of csCyl: r: float phi: float k: float</code> </pre> <br><p> 根据<code>cs</code>的值，您可以使用x，y，z字段或r，phi和k。 </p><br><p> 缺点是什么？ <br> 首先，为“最大选项”保留了内存-从而确保可以容纳为对象分配的内存。 <br> 其次，继承仍然更加灵活-您始终可以创建后代并添加更多字段，并且在对象变体中，所有字段都在一个部分中严格定义。 <br> 第三，最<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">让人</a>生气的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">您不能“重用”</a>不同类型的字段： </p><br><pre> <code class="plaintext hljs">type # The 3 notations refer to the same 3-D entity, and some coordinates are shared CoordinateSystem = enum csCar, # Cartesian (x,y,z) csCyl, # Cylindrical (r,φ,z) Coordinates = object case cs: CoordinateSystem: # cs is the coordinate discriminator of csCar: x: float y: float z: float # z already defined here of csCyl: r: float phi: float z: float # fails to compile due to redefinition of z</code> </pre> <br><h3 id="do-notation"> 做记号 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">引用</a>一下： </p><br><ul><li> 用括号做是一个匿名过程 </li><li> 不用括号只是一段代码 <br> 一个表达式表示不同的事物__（ツ）_ /¯ </li></ul><br><h3 id="kogda-chto-ispolzovat"> 何时使用 </h3><br><p> 因此，我们具有函数，过程，泛型，多方法，模板和宏。 什么时候使用模板更好，什么时候使用程序？ 模板还是通用？ 功能或程序？ 那么，宏呢？ 我想你明白了。 </p><br><h3 id="custom-pragma"> 自定义杂物 </h3><br><p>  python中有装饰器，甚至可以应用于类甚至函数。 <br> 尼姆对此有一些实用说明。 这是什么： </p><br><ul><li> 您可以编写自己的杂注来装饰过程： <br><pre> <code class="plaintext hljs">proc fib(n : int) : int {.cached.} = # do smth</code> </pre> </li><li> 您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">不能</a>编写自己的杂物来修饰类型（=类）。 </li></ul><br><h3 id="nimble"> 敏捷 </h3><br><p> 死了的人不会死。 在敏捷中，一堆项目已经很长时间没有更新了（在敏捷中，这就像死亡一样），并且它们不会被删除。 没有人关注此事。 向后兼容很明显，“您不能只是从萝卜中取出包装”，但仍然...好吧，谢谢，至少不像npm。 </p><br><h3 id="dyryavye-abstrakcii"> 泄漏抽象 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">漏洞抽象</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">法则</a>是这样的-您使用某种抽象，但迟早会在其中发现一个“漏洞”，这将使您进入一个较低的层次。  Nim是C和C ++的抽象，迟早您会在那儿失败。 赌你在那里不喜欢吗？ </p><br><pre> <code class="plaintext hljs">Error: execution of an external compiler program 'g++ -c -w -w -fpermissive -pthread -I/usr/lib/nim -I/home/user/c4/systems/network -o /home/user/.cache/nim/enet_d/@m..@s..@s..@s..@s..@s..@s.nimble@spkgs@smsgpack4nim-0.3.0@smsgpack4nim.nim.cpp:6987:136: note: initializing argument 2 of 'void unpack_type__k2dhaoojunqoSwgmQ9bNNug(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA*, NU&amp;)' 6987 | N_LIB_PRIVATE N_NIMCALL(void, unpack_type__k2dhaoojunqoSwgmQ9bNNug)(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA* s, NU&amp; val) { nimfr_("unpack_type", "/home/user/.nimble/pkgs/msgpack4nim-0.3.0/msgpack4nim.nim"); |</code> tyObject_MsgStreamcolonObjectType ___ kto5qgghQl207nm2KQZEDA * S，NU＆VAL）{nimfr _（ “unpack_type”， “/home/user/.nimble/pkgs/msgpack4nim-0.3.0/msgpack4nim.nim”）; <code class="plaintext hljs">Error: execution of an external compiler program 'g++ -c -w -w -fpermissive -pthread -I/usr/lib/nim -I/home/user/c4/systems/network -o /home/user/.cache/nim/enet_d/@m..@s..@s..@s..@s..@s..@s.nimble@spkgs@smsgpack4nim-0.3.0@smsgpack4nim.nim.cpp:6987:136: note: initializing argument 2 of 'void unpack_type__k2dhaoojunqoSwgmQ9bNNug(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA*, NU&amp;)' 6987 | N_LIB_PRIVATE N_NIMCALL(void, unpack_type__k2dhaoojunqoSwgmQ9bNNug)(tyObject_MsgStreamcolonObjectType___kto5qgghQl207nm2KQZEDA* s, NU&amp; val) { nimfr_("unpack_type", "/home/user/.nimble/pkgs/msgpack4nim-0.3.0/msgpack4nim.nim"); |</code> </pre> <br><pre> <code class="plaintext hljs">/usr/bin/ld: /home/user/.cache/nim/enet_d/stdlib_dollars.nim.cpp.o: in function `dollar___uR9bMx2FZlD8AoPom9cVY9ctA(tyObject_ConnectMessage__e5GUVMJGtJeVjEZUTYbwnA*)': stdlib_dollars.nim.cpp:(.text+0x229): undefined reference to `resizeString(NimStringDesc*, long)' /usr/bin/ld: stdlib_dollars.nim.cpp:(.text+0x267): undefined reference to `resizeString(NimStringDesc*, long)' /usr/bin/ld: stdlib_dollars.nim.cpp:(.text+0x2a2): undefined reference to `resizeString(NimStringDesc*, long)'</code> </pre> <br><h1 id="itak"> 所以 </h1><br><p> 我是一个愚蠢的程序员。 我不想知道GC的工作原理，存在的地方以及如何链接，将其缓存在何处以及如何清除垃圾。 它就像一辆汽车-原则上，我知道它的工作原理，关于车轮定位，关于变速箱，我需要填充机油和东西，但总的来说，我只是想坐下来（快速）参加聚会。 机器不是目标，而是达到目的的手段。 如果它崩溃了，我不想陷入困境，而只是将其带到服务中（从某种意义上说，我将在github上打开该问题），如果他们能尽快解决它，那就太好了。 </p><br><p> 尼姆应该是这样的机器。 在某种程度上，他成为了他，但与此同时，当我沿着这辆车在高速公路上行驶时，我的车轮掉了下来，后视镜指向前方。 工程师追赶我，并随手附上一些东西（“现在，有了这种新的扰流板，您的汽车甚至更快了”），但是后备箱掉下来了。 你知道吗？ 我还是喜欢这辆车，因为这是我所见过的所有车中最好的。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462577/">https://habr.com/ru/post/zh-CN462577/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462567/index.html">Sodinokibi勒索软件：详细研究</a></li>
<li><a href="../zh-CN462569/index.html">与我们以及与他们的运输系统或“针对聚合器2的汽车站”</a></li>
<li><a href="../zh-CN462571/index.html">难以捉摸的马尔瓦里历险记：全面的防御（最终思想）</a></li>
<li><a href="../zh-CN462573/index.html">项目竞赛：什么，为什么和为什么？</a></li>
<li><a href="../zh-CN462575/index.html">安全周32：iMessage漏洞，语音输入隐私</a></li>
<li><a href="../zh-CN462581/index.html">我们是如何组织第一笔电子租赁的？</a></li>
<li><a href="../zh-CN462583/index.html">满足确定性垃圾收集器指针</a></li>
<li><a href="../zh-CN462585/index.html">使用nest，@ nestjsx / crud和TestMace快速创建CRUD</a></li>
<li><a href="../zh-CN462587/index.html">AirTest IDE和图像识别-基于图像识别的手机游戏自动化测试</a></li>
<li><a href="../zh-CN462589/index.html">创建用于流数据处理的管道。 第二部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>