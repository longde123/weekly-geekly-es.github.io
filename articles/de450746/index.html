<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëµ üóùÔ∏è ü§úüèº Einf√ºhrung in CLI Builder üë®üèæ‚Äçüè≠ üöÇ üôé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird die neue Angular CLI-API vorgestellt, mit der Sie vorhandene CLI-Funktionen erweitern und neue hinzuf√ºgen k√∂nnen. Wir werden di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einf√ºhrung in CLI Builder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450746/"><img src="https://habrastorage.org/webt/sm/xo/kb/smxokbjs_uhwjcb1rjv7cwt5k3m.png" alt="Einf√ºhrung in CLI Builder"><br><br>  In diesem Artikel wird die neue Angular CLI-API vorgestellt, mit der Sie vorhandene CLI-Funktionen erweitern und neue hinzuf√ºgen k√∂nnen.  Wir werden diskutieren, wie mit dieser API gearbeitet wird und welche Punkte ihrer Erweiterung vorhanden sind, die es erm√∂glichen, der CLI neue Funktionen hinzuzuf√ºgen. <br><a name="habracut"></a><br><h2>  Die Geschichte </h2><br>  Vor ungef√§hr einem Jahr haben wir die Arbeitsbereichsdatei ( <i>angle.json</i> ) in der Angular-CLI eingef√ºhrt und viele der Grundprinzipien f√ºr die Implementierung ihrer Befehle <i>√ºberarbeitet</i> .  Wir sind zu der Tatsache gekommen, dass wir die Teams in die ‚ÄûBoxen‚Äú gestellt haben: <br><br><ol><li>  <b>Schematische Befehle - "Schematische Befehle".</b>  Inzwischen haben Sie wahrscheinlich bereits von Schematics geh√∂rt, der Bibliothek, mit der die CLI Ihren Code generiert und √§ndert.  Es wurde in Version 5 ver√∂ffentlicht und wird derzeit in den meisten Befehlen verwendet, die Ihren Code betreffen, z. B. <i>neu</i> , <i>generieren</i> , <i>hinzuf√ºgen</i> und <i>aktualisieren</i> . </li><li>  <b>Verschiedene Befehle - "Andere Teams"</b> .  Dies sind Befehle, die nicht direkt mit Ihrem Projekt zusammenh√§ngen: <i>Hilfe</i> , <i>Version</i> , <i>Konfiguration</i> , <i>Dokument</i> .  Vor kurzem sind auch <i>Analysen</i> erschienen, ebenso wie unsere Ostereier (Shhh! Kein Wort an irgendjemanden!). </li><li>  <b>Aufgabenbefehle - "Aufgabenbefehle".</b>  Diese Kategorie "startet im Gro√üen und Ganzen Prozesse, die mit dem Code anderer Personen ausgef√ºhrt werden".  - Als Beispiel ist <i>Build</i> ein Projekt-Build, <i>Lint</i> debuggt und <i>Test</i> testet. </li></ol><br>  Wir <i>haben vor</i> langer Zeit angefangen, <i>angular.json zu</i> entwerfen.  Urspr√ºnglich wurde es als Ersatz f√ºr die Webpack-Konfiguration konzipiert.  Dar√ºber hinaus sollte es Entwicklern erm√∂glichen, die Implementierung der Projektassembly unabh√§ngig zu w√§hlen.  Als Ergebnis erhielten wir ein grundlegendes Task-Startsystem, das f√ºr unsere Experimente einfach und bequem blieb.  Wir haben diese API "Architekt" genannt. <br><br>  Trotz der Tatsache, dass Architect nicht offiziell unterst√ºtzt wurde, war es bei Entwicklern beliebt, die die Zusammenstellung von Projekten anpassen wollten, sowie bei Bibliotheken von Drittanbietern, die ihren Workflow steuern mussten.  Nx verwendete es, um Bazel-Befehle auszuf√ºhren, Ionic, um Unit-Tests f√ºr Jest auszuf√ºhren, und Benutzer konnten ihre Webpack-Konfigurationen mit Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ngx-build-plus erweitern</a> .  Und das war erst der Anfang. <br><br>  <b>In Angular CLI Version 8 wird eine offiziell unterst√ºtzte, stabile und verbesserte Version dieser API verwendet.</b> <br><br><h2>  Konzept </h2><br>  Die Architect-API bietet Tools zum Planen und Koordinieren von Aufgaben, mit denen die Angular CLI ihre Befehle implementiert.  Es verwendet aufgerufene Funktionen <br>  "Bauherren" - "Sammler", die als Aufgaben oder Planer anderer Sammler fungieren k√∂nnen.  Dar√ºber hinaus wird angle.json als Befehlssatz f√ºr die Kollektoren selbst verwendet. <br><br>  Dies ist ein sehr allgemeines System, das flexibel und erweiterbar ist.  Es enth√§lt eine API zum Berichten, Protokollieren und Testen.  Bei Bedarf kann das System f√ºr neue Aufgaben erweitert werden. <br><br><h2>  Pfl√ºcker </h2><br>  Assembler sind Funktionen, die Logik und Verhalten f√ºr eine Aufgabe implementieren, die den CLI-Befehl ersetzen kann.  - Starten Sie zum Beispiel den Linter. <br><br>  Die Collector-Funktion akzeptiert zwei Argumente: den Eingabewert (oder die Optionen) und den Kontext, der die Beziehung zwischen der CLI und dem Collector selbst bereitstellt.  Die Aufteilung der Verantwortung ist hier dieselbe wie in Schema - der CLI-Benutzer legt die Optionen fest, die API ist f√ºr den Kontext verantwortlich und Sie (der Entwickler) legen das erforderliche Verhalten fest.  Das Verhalten kann synchron, asynchron implementiert werden oder einfach eine bestimmte Anzahl von Werten anzeigen.  Die Ausgabe muss vom Typ <i>BuilderOutput sein</i> , der den <i>Erfolg</i> des logischen Feldes und den optionalen <i>Feldfehler</i> enth√§lt, der die Fehlermeldung enth√§lt. <br><br><h2>  Arbeitsbereichsdatei und Aufgaben </h2><br>  Die Architect-API <i>basiert</i> auf <i>angle.json</i> , einer Arbeitsbereichsdatei zum Speichern von Aufgaben und deren Einstellungen. <br><br>  <i>angle.json</i> unterteilt den Arbeitsbereich in Projekte und diese wiederum in Aufgaben.  Beispielsweise ist Ihre mit dem Befehl <i>ng new</i> erstellte Anwendung ein solches Projekt.  Eine der Aufgaben in diesem Projekt ist die <i>Build-</i> Task, die mit dem <i>Befehl ng build</i> gestartet werden kann.  Standardm√§√üig hat diese Aufgabe drei Schl√ºssel: <br><br><ol><li>  <b>Builder</b> - Der Name des Kollektors, mit dem die Aufgabe ausgef√ºhrt werden soll, im Format <i>PACKAGE_NAME: ASSEMBLY_NAME</i> . </li><li>  <b>Optionen</b> - Einstellungen, die standardm√§√üig beim Starten einer Aufgabe verwendet werden. </li><li>  <b>Konfigurationen</b> - Einstellungen, die angewendet werden, wenn eine Aufgabe mit der angegebenen Konfiguration gestartet wird. </li></ol><br>  Die Einstellungen werden wie folgt angewendet: Wenn die Aufgabe gestartet wird, werden die Einstellungen aus dem Optionsblock √ºbernommen. Wenn eine Konfiguration angegeben wurde, werden deren Einstellungen √ºber die vorhandenen Einstellungen geschrieben.  Wenn danach zus√§tzliche Einstellungen an <i>ScheduleTarget ()</i> - den <i>√úberschreibungsblock</i> - √ºbergeben wurden, werden sie zuletzt geschrieben.  Bei Verwendung der Angular-CLI werden Befehlszeilenargumente an <i>√úberschreibungen √ºbergeben</i> .  Nachdem alle Einstellungen an den Kollektor √ºbertragen wurden, √ºberpr√ºft er sie gem√§√ü seinem Schema. Nur wenn die Einstellungen diesem entsprechen, wird der Kontext erstellt und der Kollektor beginnt zu arbeiten. <br><br>  Weitere Informationen zum Arbeitsbereich finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Erstellen Sie Ihren eigenen Sammler </h2><br>  Als Beispiel erstellen wir einen Kollektor, der einen Befehl in der Befehlszeile ausf√ºhrt.  Verwenden <i>Sie</i> zum Erstellen eines Kollektors die <i>createBuilder-</i> Factory und geben Sie das <i>BuilderOutput-</i> Objekt zur√ºck: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }); });</code> </pre> <br>  F√ºgen wir nun unserem Kollektor eine Logik hinzu: Wir m√∂chten den Kollektor √ºber die Einstellungen steuern, neue Prozesse erstellen, auf den Abschluss des Prozesses warten und, wenn der Prozess erfolgreich abgeschlossen wurde (dh den R√ºckkehrcode 0), dies dem Architekten signalisieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Ausgabeverarbeitung </h2><br>  Jetzt √ºbergibt die <i>Spawn-</i> Methode alle Daten an die Standardausgabe des Prozesses.  Wir m√∂chten sie m√∂glicherweise auf den <i>Logger √ºbertragen</i> - Logger.  In diesem Fall wird zum einen das Debuggen w√§hrend des Testens erleichtert, und zum anderen kann Architect selbst unseren Kollektor in einem separaten Prozess ausf√ºhren oder die Standardausgabe von Prozessen deaktivieren (z. B. in der Electron-Anwendung). <br><br>  Zu diesem Zweck k√∂nnen wir den im <i>Kontextobjekt</i> verf√ºgbaren <i>Logger verwenden</i> , mit dem wir die Ausgabe des Prozesses umleiten k√∂nnen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Leistungs- und Statusberichte </h2><br>  Der letzte Teil der API, der sich auf die Implementierung Ihres eigenen Kollektors bezieht, sind die Fortschritts- und aktuellen Statusberichte. <br><br>  In unserem Fall wird der Befehl entweder ausgef√ºhrt oder ausgef√ºhrt, sodass es keinen Sinn macht, einen Fortschrittsbericht hinzuzuf√ºgen.  Wir k√∂nnen dem √ºbergeordneten Sammler jedoch unseren Status mitteilen, damit er versteht, was passiert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Executing "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${options.command}</span></span></span><span class="hljs-string">"...`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Done.`</span></span>); child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br>  Verwenden Sie zum <i>√úbergeben</i> eines <i>Fortschrittsberichts</i> die <i>reportProgress-</i> Methode mit aktuellen und (optional) zusammenfassenden Werten als Argumente.  <i>total</i> kann eine beliebige Zahl sein.  Wenn Sie beispielsweise wissen, wie viele Dateien Sie verarbeiten m√ºssen, k√∂nnen Sie deren Anzahl auf <i>insgesamt √ºbertragen</i> . Anschlie√üend k√∂nnen Sie die Anzahl der bereits verarbeiteten Dateien auf <i>aktuell</i> √ºbertragen.  So berichtet <a href="">der tslint-Sammler</a> √ºber seinen Fortschritt. <br><br><h2>  Eingabevalidierung </h2><br>  Das an den Collector √ºbergebene Optionsobjekt wird mithilfe des JSON-Schemas √ºberpr√ºft.  Dies √§hnelt Schematics, wenn Sie wissen, was es ist. <br><br>  In unserem Kollektorbeispiel erwarten wir, dass unsere Parameter ein Objekt sind, das zwei Schl√ºssel empf√§ngt: <i>Befehl</i> - Befehl (Zeichenfolge) und Argumente - Argumente (Array von Zeichenfolgen).  Unser √úberpr√ºfungsschema sieht folgenderma√üen aus: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"$schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://json-schema.org/schema"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> } } }</code> </pre><br>  Schemata sind wirklich m√§chtige Werkzeuge, die eine gro√üe Anzahl von √úberpr√ºfungen durchf√ºhren k√∂nnen.  Weitere Informationen zu JSON-Schemata finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen JSON-Schema-Website</a> . <br><br><h2>  Erstellen Sie ein Build-Paket </h2><br>  Es gibt eine Schl√ºsseldatei, die wir f√ºr unseren eigenen Kollektor erstellen m√ºssen, um ihn mit der Angular CLI kompatibel zu machen - <i>builders.json</i> , die f√ºr die Beziehung zwischen unserer Implementierung des Kollektors, seinem Namen und dem √úberpr√ºfungsschema verantwortlich ist.  Die Datei selbst sieht folgenderma√üen aus: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"implementation"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command/schema.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Runs any command line in the operating system."</span></span> } } }</code> </pre><br>  Dann f√ºgen wir in der Datei <i>package.json</i> den <i>Builders-</i> Schl√ºssel hinzu, der auf die Datei <i>builders.json</i> verweist: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Builder for Architect"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: <span class="hljs-string"><span class="hljs-string">"builders.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"devDependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@angular-devkit/architect"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.0.0"</span></span> } }</code> </pre><br>  Dadurch wird Architect mitgeteilt, wo nach der Collector-Definitionsdatei gesucht werden soll. <br><br>  Daher lautet der Name unseres Sammlers <i>"@ example / command-running: command"</i> .  Der erste Teil des Namens vor dem Doppelpunkt (:) ist der Name des Pakets, das mit <i>package.json</i> definiert wurde.  Der zweite Teil ist der Name des Kollektors, der mithilfe der Datei <i>builders.json</i> definiert wird. <br><br><h2>  Testen Sie Ihre eigenen Builder </h2><br>  Die empfohlene Methode zum Testen von Assemblern besteht in Integrationstests.  Dies liegt daran, dass das Erstellen eines <i>Kontexts</i> nicht einfach ist. Verwenden Sie daher den Scheduler von Architect. <br><br>  Um die Muster zu vereinfachen, haben wir uns eine einfache M√∂glichkeit zum Erstellen einer Architect-Instanz <i>ausgedacht</i> : Zuerst erstellen Sie eine <i>JsonSchemaRegistry</i> (um das Schema zu testen), dann <i>TestingArchitectHost</i> und schlie√ülich eine <i>Architect-</i> Instanz.  Jetzt k√∂nnen Sie die Konfigurationsdatei <i>builders.json</i> kompilieren. <br><br>  Hier ist ein Beispiel f√ºr die Ausf√ºhrung des Collectors, der den <i>Befehl ls</i> ausf√ºhrt und √ºberpr√ºft, ob der Befehl erfolgreich ausgef√ºhrt wurde.  Bitte beachten Sie, dass wir die Standardausgabe von Prozessen in <i>Logger verwenden</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Architect, ArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TestingArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect/testing'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { logging, schema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/core'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Command Runner Builder'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architect: Architect; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architectHost: ArchitectHost; beforeEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.CoreSchemaRegistry(); registry.addPostTransform(schema.transforms.addUndefinedDefaults); <span class="hljs-comment"><span class="hljs-comment">//  TestingArchitectHost ‚Äì    . //     ,   . architectHost = new TestingArchitectHost(__dirname, __dirname); architect = new Architect(architectHost, registry); //      NPM-, //    package.json  . await architectHost.addBuilderFromPackage('..'); }); //      Windows it('can run ls', async () =&gt; { //  ,     . const logger = new logging.Logger(''); const logs = []; logger.subscribe(ev =&gt; logs.push(ev.message)); // "run"    ,       . const run = await architect.scheduleBuilder('@example/command-runner:command', { command: 'ls', args: [__dirname], }, { logger }); // "result" ‚Äì    . //    "BuilderOutput". const output = await run.result; //  . Architect     //   ,    ,    . await run.stop(); //   . expect(output.success).toBe(true); // ,     . // `ls $__dirname`. expect(logs).toContain('index_spec.ts'); }); });</span></span></code> </pre><br>  Um das obige Beispiel auszuf√ºhren, ben√∂tigen Sie das Paket <i>ts-node</i> .  Wenn Sie Node verwenden <i>m√∂chten</i> , benennen Sie <i>index_spec.ts</i> in <i>index_spec.js um</i> . <br><br><h2>  Verwenden des Kollektors in einem Projekt </h2><br>  Lassen Sie uns eine einfache angle.json erstellen, die alles demonstriert, was wir √ºber Assembler gelernt haben.  Angenommen, wir haben unseren Kollektor in <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Beispiel</a> / Befehlsl√§ufer</i> gepackt und dann mit <i>ng new builder-test</i> eine neue Anwendung erstellt, k√∂nnte die Datei <i>angle.json folgenderma√üen</i> aussehen (ein Teil des Inhalts wurde der K√ºrze <i>halber</i> entfernt): <br><br><pre> <code class="json hljs">{ // ...   . <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } }</code> </pre><br>  Wenn wir uns entschlie√üen, eine neue Aufgabe hinzuzuf√ºgen, um (zum Beispiel) den Befehl <i>touch</i> mit unserem Collector auf die Datei anzuwenden (aktualisiert das √Ñnderungsdatum der Datei), w√ºrden wir <i>npm install <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">example</a> / command-</i> <i>running ausf√ºhren</i> und dann √Ñnderungen an <i>angle.json vornehmen</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"touch"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner:command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"touch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fileReplacements"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"replace"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"with"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.prod.ts"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } } } } }</code> </pre><br>  Die Angular-CLI verf√ºgt √ºber einen Befehl <i>run</i> , der der Hauptbefehl zum Ausf√ºhren von Kollektoren ist.  Als erstes Argument wird eine Zeichenfolge im Format <i>PROJECT: TASK [: CONFIGURATION] verwendet</i> .  Um unsere Aufgabe auszuf√ºhren, k√∂nnen wir den Befehl <i>ng run builder-test: touch verwenden</i> . <br><br>  Jetzt m√∂chten wir vielleicht einige Argumente neu definieren.  Leider k√∂nnen wir Arrays √ºber die Befehlszeile noch nicht neu definieren, aber wir k√∂nnen den Befehl selbst zur Demonstration √§ndern: <i>ng run builder-test: touch --command = ls</i> .  - Dadurch wird die <i>Datei src / main.ts ausgegeben</i> . <br><br><h2>  Watch-Modus </h2><br>  Standardm√§√üig wird davon ausgegangen, dass Kollektoren einmal aufgerufen und beendet werden. Sie k√∂nnen jedoch <i>Observable zur√ºckgeben</i> , um ihren eigenen Beobachtungsmodus zu implementieren (wie dies der <i>Webpack-</i> Kollektor tut).  Der Architekt abonniert das <i>Observable,</i> bis es beendet oder gestoppt ist, und kann den Collector erneut abonnieren, wenn der Collector mit denselben Parametern aufgerufen wird (wenn auch nicht garantiert). <br><br><ol><li>  Der Kollektor sollte nach jeder Ausf√ºhrung ein <i>BuilderOutput-</i> Objekt zur√ºckgeben.  Nach Abschluss kann es in den Beobachtungsmodus wechseln, der durch ein externes Ereignis verursacht wird. Wenn es erneut <i>gestartet</i> wird, muss es die Funktion <i>context.reportRunning () aufrufen</i> , um Architect zu benachrichtigen, dass der Kollektor wieder arbeitet.  Dies sch√ºtzt den Kollektor davor, ihn vom Architekten bei einem neuen Aufruf zu stoppen. </li><li>  Der Architekt selbst meldet sich von <i>Observable ab,</i> wenn der Kollektor stoppt (z. B. mit run.stop ()), und verwendet dabei die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teardown-Logik</a> - den Zerst√∂rungsalgorithmus.  Auf diese Weise k√∂nnen Sie die Assembly stoppen und l√∂schen, wenn dieser Prozess bereits ausgef√ºhrt wird. </li></ol><br>  Zusammenfassend l√§sst sich sagen, dass Ihr Sammler, wenn er externe Ereignisse beobachtet, in drei Schritten arbeitet: <br><br><ol><li>  <b>Erf√ºllung.</b>  Zum Beispiel die Kompilierung von Webpack.  Dieser Schritt endet, wenn Webpack die Erstellung abgeschlossen hat und Ihr Kollektor <i>BuilderOutput</i> an <i>Observable</i> sendet. </li><li>  <b>Beobachtung.</b>  - Zwischen zwei Starts werden externe Ereignisse √ºberwacht.  Beispielsweise √ºberwacht Webpack das Dateisystem auf √Ñnderungen.  Dieser Schritt endet, wenn Webpack den Build fortsetzt und <i>context.reportRunning ()</i> aufgerufen wird.  Nach diesem Schritt beginnt Schritt 1 erneut. </li><li>  <b>Fertigstellung.</b>  - Die Aufgabe ist vollst√§ndig abgeschlossen (es wurde beispielsweise erwartet, dass Webpack eine bestimmte Anzahl von Malen gestartet wird) oder der Start des Kollektors wurde gestoppt (mit <i>run.stop ()</i> ).  In diesem Fall wird der <i>Observable-</i> Zerst√∂rungsalgorithmus ausgef√ºhrt und gel√∂scht. </li></ol><br><h2>  Fazit </h2><br>  Hier ist eine Zusammenfassung dessen, was wir in dieser Ver√∂ffentlichung gelernt haben: <br><br><ol><li>  Wir bieten eine neue API, mit der Entwickler das Verhalten von Angular CLI-Befehlen √§ndern und mithilfe von Assemblern, die die erforderliche Logik implementieren, neue hinzuf√ºgen k√∂nnen. </li><li>  Kollektoren k√∂nnen synchron, asynchron und auf externe Ereignisse reagieren.  Sie k√∂nnen sowohl mehrfach als auch von anderen Sammlern aufgerufen werden. </li><li>  Die Parameter, die der Kollektor beim Start der Task empf√§ngt, werden zuerst aus der Datei <i>angle.json</i> gelesen, dann von den Parametern aus der Konfiguration, falls vorhanden, √ºberschrieben und dann von den Befehlszeilenflags √ºberschrieben, wenn sie hinzugef√ºgt wurden. </li><li>  Die empfohlene Methode zum Testen von Kollektoren besteht in Integrationstests. Sie k√∂nnen jedoch Unit-Tests getrennt von der Kollektorlogik durchf√ºhren. </li><li>  Wenn der Kollektor ein Observable zur√ºckgibt, sollte es nach Durchlaufen des Zerst√∂rungsalgorithmus gel√∂scht werden. </li></ol><br>  In naher Zukunft wird die H√§ufigkeit der Verwendung dieser APIs zunehmen.  Zum Beispiel ist die Bazel-Implementierung stark mit ihnen verbunden. <br><br>  Wir sehen bereits, wie die Community neue CLI-Kollektoren zur Verwendung erstellt, z. B. <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jest</a></i> und <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cypress</a></i> zum Testen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450746/">https://habr.com/ru/post/de450746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450734/index.html">Fuzzing ist ein wichtiger Schritt f√ºr eine sichere Entwicklung</a></li>
<li><a href="../de450736/index.html">"Das Internet zu isolieren ist viel einfacher und billiger als das externe Blockieren."</a></li>
<li><a href="../de450738/index.html">Roboter im Rechenzentrum: Wie kann k√ºnstliche Intelligenz n√ºtzlich sein?</a></li>
<li><a href="../de450740/index.html">Smart Lamp Base REDMOND - Erg√§nzen Sie das Smart Home</a></li>
<li><a href="../de450744/index.html">Fahrradinfrastruktur in Minsk f√ºr einen IT-Expat</a></li>
<li><a href="../de450748/index.html">ISTQB-Zertifizierung. Teil 1: sein oder nicht sein?</a></li>
<li><a href="../de450752/index.html">"Ich habe nur eine Lehrmethode: nur arbeiten" - Interview mit Ryan Dahl (Node.js, Deno)</a></li>
<li><a href="../de450754/index.html">Rollstuhlrennen: Russischer Pilot gewinnt CYBATHLON-Meisterschaft in Tokio</a></li>
<li><a href="../de450756/index.html">√úber milit√§rische Arbeitsunf√§higkeit</a></li>
<li><a href="../de450758/index.html">factory_trace gem hilft beim Reinigen Ihrer Fabriken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>