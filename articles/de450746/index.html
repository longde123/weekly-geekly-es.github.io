<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵 🗝️ 🤜🏼 Einführung in CLI Builder 👨🏾‍🏭 🚂 🙎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel wird die neue Angular CLI-API vorgestellt, mit der Sie vorhandene CLI-Funktionen erweitern und neue hinzufügen können. Wir werden di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einführung in CLI Builder</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450746/"><img src="https://habrastorage.org/webt/sm/xo/kb/smxokbjs_uhwjcb1rjv7cwt5k3m.png" alt="Einführung in CLI Builder"><br><br>  In diesem Artikel wird die neue Angular CLI-API vorgestellt, mit der Sie vorhandene CLI-Funktionen erweitern und neue hinzufügen können.  Wir werden diskutieren, wie mit dieser API gearbeitet wird und welche Punkte ihrer Erweiterung vorhanden sind, die es ermöglichen, der CLI neue Funktionen hinzuzufügen. <br><a name="habracut"></a><br><h2>  Die Geschichte </h2><br>  Vor ungefähr einem Jahr haben wir die Arbeitsbereichsdatei ( <i>angle.json</i> ) in der Angular-CLI eingeführt und viele der Grundprinzipien für die Implementierung ihrer Befehle <i>überarbeitet</i> .  Wir sind zu der Tatsache gekommen, dass wir die Teams in die „Boxen“ gestellt haben: <br><br><ol><li>  <b>Schematische Befehle - "Schematische Befehle".</b>  Inzwischen haben Sie wahrscheinlich bereits von Schematics gehört, der Bibliothek, mit der die CLI Ihren Code generiert und ändert.  Es wurde in Version 5 veröffentlicht und wird derzeit in den meisten Befehlen verwendet, die Ihren Code betreffen, z. B. <i>neu</i> , <i>generieren</i> , <i>hinzufügen</i> und <i>aktualisieren</i> . </li><li>  <b>Verschiedene Befehle - "Andere Teams"</b> .  Dies sind Befehle, die nicht direkt mit Ihrem Projekt zusammenhängen: <i>Hilfe</i> , <i>Version</i> , <i>Konfiguration</i> , <i>Dokument</i> .  Vor kurzem sind auch <i>Analysen</i> erschienen, ebenso wie unsere Ostereier (Shhh! Kein Wort an irgendjemanden!). </li><li>  <b>Aufgabenbefehle - "Aufgabenbefehle".</b>  Diese Kategorie "startet im Großen und Ganzen Prozesse, die mit dem Code anderer Personen ausgeführt werden".  - Als Beispiel ist <i>Build</i> ein Projekt-Build, <i>Lint</i> debuggt und <i>Test</i> testet. </li></ol><br>  Wir <i>haben vor</i> langer Zeit angefangen, <i>angular.json zu</i> entwerfen.  Ursprünglich wurde es als Ersatz für die Webpack-Konfiguration konzipiert.  Darüber hinaus sollte es Entwicklern ermöglichen, die Implementierung der Projektassembly unabhängig zu wählen.  Als Ergebnis erhielten wir ein grundlegendes Task-Startsystem, das für unsere Experimente einfach und bequem blieb.  Wir haben diese API "Architekt" genannt. <br><br>  Trotz der Tatsache, dass Architect nicht offiziell unterstützt wurde, war es bei Entwicklern beliebt, die die Zusammenstellung von Projekten anpassen wollten, sowie bei Bibliotheken von Drittanbietern, die ihren Workflow steuern mussten.  Nx verwendete es, um Bazel-Befehle auszuführen, Ionic, um Unit-Tests für Jest auszuführen, und Benutzer konnten ihre Webpack-Konfigurationen mit Tools wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ngx-build-plus erweitern</a> .  Und das war erst der Anfang. <br><br>  <b>In Angular CLI Version 8 wird eine offiziell unterstützte, stabile und verbesserte Version dieser API verwendet.</b> <br><br><h2>  Konzept </h2><br>  Die Architect-API bietet Tools zum Planen und Koordinieren von Aufgaben, mit denen die Angular CLI ihre Befehle implementiert.  Es verwendet aufgerufene Funktionen <br>  "Bauherren" - "Sammler", die als Aufgaben oder Planer anderer Sammler fungieren können.  Darüber hinaus wird angle.json als Befehlssatz für die Kollektoren selbst verwendet. <br><br>  Dies ist ein sehr allgemeines System, das flexibel und erweiterbar ist.  Es enthält eine API zum Berichten, Protokollieren und Testen.  Bei Bedarf kann das System für neue Aufgaben erweitert werden. <br><br><h2>  Pflücker </h2><br>  Assembler sind Funktionen, die Logik und Verhalten für eine Aufgabe implementieren, die den CLI-Befehl ersetzen kann.  - Starten Sie zum Beispiel den Linter. <br><br>  Die Collector-Funktion akzeptiert zwei Argumente: den Eingabewert (oder die Optionen) und den Kontext, der die Beziehung zwischen der CLI und dem Collector selbst bereitstellt.  Die Aufteilung der Verantwortung ist hier dieselbe wie in Schema - der CLI-Benutzer legt die Optionen fest, die API ist für den Kontext verantwortlich und Sie (der Entwickler) legen das erforderliche Verhalten fest.  Das Verhalten kann synchron, asynchron implementiert werden oder einfach eine bestimmte Anzahl von Werten anzeigen.  Die Ausgabe muss vom Typ <i>BuilderOutput sein</i> , der den <i>Erfolg</i> des logischen Feldes und den optionalen <i>Feldfehler</i> enthält, der die Fehlermeldung enthält. <br><br><h2>  Arbeitsbereichsdatei und Aufgaben </h2><br>  Die Architect-API <i>basiert</i> auf <i>angle.json</i> , einer Arbeitsbereichsdatei zum Speichern von Aufgaben und deren Einstellungen. <br><br>  <i>angle.json</i> unterteilt den Arbeitsbereich in Projekte und diese wiederum in Aufgaben.  Beispielsweise ist Ihre mit dem Befehl <i>ng new</i> erstellte Anwendung ein solches Projekt.  Eine der Aufgaben in diesem Projekt ist die <i>Build-</i> Task, die mit dem <i>Befehl ng build</i> gestartet werden kann.  Standardmäßig hat diese Aufgabe drei Schlüssel: <br><br><ol><li>  <b>Builder</b> - Der Name des Kollektors, mit dem die Aufgabe ausgeführt werden soll, im Format <i>PACKAGE_NAME: ASSEMBLY_NAME</i> . </li><li>  <b>Optionen</b> - Einstellungen, die standardmäßig beim Starten einer Aufgabe verwendet werden. </li><li>  <b>Konfigurationen</b> - Einstellungen, die angewendet werden, wenn eine Aufgabe mit der angegebenen Konfiguration gestartet wird. </li></ol><br>  Die Einstellungen werden wie folgt angewendet: Wenn die Aufgabe gestartet wird, werden die Einstellungen aus dem Optionsblock übernommen. Wenn eine Konfiguration angegeben wurde, werden deren Einstellungen über die vorhandenen Einstellungen geschrieben.  Wenn danach zusätzliche Einstellungen an <i>ScheduleTarget ()</i> - den <i>Überschreibungsblock</i> - übergeben wurden, werden sie zuletzt geschrieben.  Bei Verwendung der Angular-CLI werden Befehlszeilenargumente an <i>Überschreibungen übergeben</i> .  Nachdem alle Einstellungen an den Kollektor übertragen wurden, überprüft er sie gemäß seinem Schema. Nur wenn die Einstellungen diesem entsprechen, wird der Kontext erstellt und der Kollektor beginnt zu arbeiten. <br><br>  Weitere Informationen zum Arbeitsbereich finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  Erstellen Sie Ihren eigenen Sammler </h2><br>  Als Beispiel erstellen wir einen Kollektor, der einen Befehl in der Befehlszeile ausführt.  Verwenden <i>Sie</i> zum Erstellen eines Kollektors die <i>createBuilder-</i> Factory und geben Sie das <i>BuilderOutput-</i> Objekt zurück: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }); });</code> </pre> <br>  Fügen wir nun unserem Kollektor eine Logik hinzu: Wir möchten den Kollektor über die Einstellungen steuern, neue Prozesse erstellen, auf den Abschluss des Prozesses warten und, wenn der Prozess erfolgreich abgeschlossen wurde (dh den Rückkehrcode 0), dies dem Architekten signalisieren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Ausgabeverarbeitung </h2><br>  Jetzt übergibt die <i>Spawn-</i> Methode alle Daten an die Standardausgabe des Prozesses.  Wir möchten sie möglicherweise auf den <i>Logger übertragen</i> - Logger.  In diesem Fall wird zum einen das Debuggen während des Testens erleichtert, und zum anderen kann Architect selbst unseren Kollektor in einem separaten Prozess ausführen oder die Standardausgabe von Prozessen deaktivieren (z. B. in der Electron-Anwendung). <br><br>  Zu diesem Zweck können wir den im <i>Kontextobjekt</i> verfügbaren <i>Logger verwenden</i> , mit dem wir die Ausgabe des Prozesses umleiten können: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br><h2>  Leistungs- und Statusberichte </h2><br>  Der letzte Teil der API, der sich auf die Implementierung Ihres eigenen Kollektors bezieht, sind die Fortschritts- und aktuellen Statusberichte. <br><br>  In unserem Fall wird der Befehl entweder ausgeführt oder ausgeführt, sodass es keinen Sinn macht, einen Fortschrittsbericht hinzuzufügen.  Wir können dem übergeordneten Sammler jedoch unseren Status mitteilen, damit er versteht, was passiert. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { BuilderOutput, createBuilder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> childProcess <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'child_process'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> createBuilder(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options, context</span></span></span><span class="hljs-function">) =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Executing "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${options.command}</span></span></span><span class="hljs-string">"...`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> child = childProcess.spawn(options.command, options.args, { <span class="hljs-attr"><span class="hljs-attr">stdio</span></span>: <span class="hljs-string"><span class="hljs-string">'pipe'</span></span> }); child.stdout.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.info(data.toString()); }); child.stderr.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, (data) =&gt; { context.logger.error(data.toString()); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>&lt;BuilderOutput&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> { context.reportStatus(<span class="hljs-string"><span class="hljs-string">`Done.`</span></span>); child.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, code =&gt; { resolve({ <span class="hljs-attr"><span class="hljs-attr">success</span></span>: code === <span class="hljs-number"><span class="hljs-number">0</span></span> }); }); }); });</code> </pre><br>  Verwenden Sie zum <i>Übergeben</i> eines <i>Fortschrittsberichts</i> die <i>reportProgress-</i> Methode mit aktuellen und (optional) zusammenfassenden Werten als Argumente.  <i>total</i> kann eine beliebige Zahl sein.  Wenn Sie beispielsweise wissen, wie viele Dateien Sie verarbeiten müssen, können Sie deren Anzahl auf <i>insgesamt übertragen</i> . Anschließend können Sie die Anzahl der bereits verarbeiteten Dateien auf <i>aktuell</i> übertragen.  So berichtet <a href="">der tslint-Sammler</a> über seinen Fortschritt. <br><br><h2>  Eingabevalidierung </h2><br>  Das an den Collector übergebene Optionsobjekt wird mithilfe des JSON-Schemas überprüft.  Dies ähnelt Schematics, wenn Sie wissen, was es ist. <br><br>  In unserem Kollektorbeispiel erwarten wir, dass unsere Parameter ein Objekt sind, das zwei Schlüssel empfängt: <i>Befehl</i> - Befehl (Zeichenfolge) und Argumente - Argumente (Array von Zeichenfolgen).  Unser Überprüfungsschema sieht folgendermaßen aus: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"$schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"http://json-schema.org/schema"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"object"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"items"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span> } } }</code> </pre><br>  Schemata sind wirklich mächtige Werkzeuge, die eine große Anzahl von Überprüfungen durchführen können.  Weitere Informationen zu JSON-Schemata finden Sie auf der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">offiziellen JSON-Schema-Website</a> . <br><br><h2>  Erstellen Sie ein Build-Paket </h2><br>  Es gibt eine Schlüsseldatei, die wir für unseren eigenen Kollektor erstellen müssen, um ihn mit der Angular CLI kompatibel zu machen - <i>builders.json</i> , die für die Beziehung zwischen unserer Implementierung des Kollektors, seinem Namen und dem Überprüfungsschema verantwortlich ist.  Die Datei selbst sieht folgendermaßen aus: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"implementation"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"schema"</span></span>: <span class="hljs-string"><span class="hljs-string">"./command/schema.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Runs any command line in the operating system."</span></span> } } }</code> </pre><br>  Dann fügen wir in der Datei <i>package.json</i> den <i>Builders-</i> Schlüssel hinzu, der auf die Datei <i>builders.json</i> verweist: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Builder for Architect"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"builders"</span></span>: <span class="hljs-string"><span class="hljs-string">"builders.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"devDependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@angular-devkit/architect"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.0.0"</span></span> } }</code> </pre><br>  Dadurch wird Architect mitgeteilt, wo nach der Collector-Definitionsdatei gesucht werden soll. <br><br>  Daher lautet der Name unseres Sammlers <i>"@ example / command-running: command"</i> .  Der erste Teil des Namens vor dem Doppelpunkt (:) ist der Name des Pakets, das mit <i>package.json</i> definiert wurde.  Der zweite Teil ist der Name des Kollektors, der mithilfe der Datei <i>builders.json</i> definiert wird. <br><br><h2>  Testen Sie Ihre eigenen Builder </h2><br>  Die empfohlene Methode zum Testen von Assemblern besteht in Integrationstests.  Dies liegt daran, dass das Erstellen eines <i>Kontexts</i> nicht einfach ist. Verwenden Sie daher den Scheduler von Architect. <br><br>  Um die Muster zu vereinfachen, haben wir uns eine einfache Möglichkeit zum Erstellen einer Architect-Instanz <i>ausgedacht</i> : Zuerst erstellen Sie eine <i>JsonSchemaRegistry</i> (um das Schema zu testen), dann <i>TestingArchitectHost</i> und schließlich eine <i>Architect-</i> Instanz.  Jetzt können Sie die Konfigurationsdatei <i>builders.json</i> kompilieren. <br><br>  Hier ist ein Beispiel für die Ausführung des Collectors, der den <i>Befehl ls</i> ausführt und überprüft, ob der Befehl erfolgreich ausgeführt wurde.  Bitte beachten Sie, dass wir die Standardausgabe von Prozessen in <i>Logger verwenden</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Architect, ArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TestingArchitectHost } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/architect/testing'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { logging, schema } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular-devkit/core'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'Command Runner Builder'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architect: Architect; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> architectHost: ArchitectHost; beforeEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> registry = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> schema.CoreSchemaRegistry(); registry.addPostTransform(schema.transforms.addUndefinedDefaults); <span class="hljs-comment"><span class="hljs-comment">//  TestingArchitectHost –    . //     ,   . architectHost = new TestingArchitectHost(__dirname, __dirname); architect = new Architect(architectHost, registry); //      NPM-, //    package.json  . await architectHost.addBuilderFromPackage('..'); }); //      Windows it('can run ls', async () =&gt; { //  ,     . const logger = new logging.Logger(''); const logs = []; logger.subscribe(ev =&gt; logs.push(ev.message)); // "run"    ,       . const run = await architect.scheduleBuilder('@example/command-runner:command', { command: 'ls', args: [__dirname], }, { logger }); // "result" –    . //    "BuilderOutput". const output = await run.result; //  . Architect     //   ,    ,    . await run.stop(); //   . expect(output.success).toBe(true); // ,     . // `ls $__dirname`. expect(logs).toContain('index_spec.ts'); }); });</span></span></code> </pre><br>  Um das obige Beispiel auszuführen, benötigen Sie das Paket <i>ts-node</i> .  Wenn Sie Node verwenden <i>möchten</i> , benennen Sie <i>index_spec.ts</i> in <i>index_spec.js um</i> . <br><br><h2>  Verwenden des Kollektors in einem Projekt </h2><br>  Lassen Sie uns eine einfache angle.json erstellen, die alles demonstriert, was wir über Assembler gelernt haben.  Angenommen, wir haben unseren Kollektor in <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Beispiel</a> / Befehlsläufer</i> gepackt und dann mit <i>ng new builder-test</i> eine neue Anwendung erstellt, könnte die Datei <i>angle.json folgendermaßen</i> aussehen (ein Teil des Inhalts wurde der Kürze <i>halber</i> entfernt): <br><br><pre> <code class="json hljs">{ // ...   . <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { // ... <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { // ...   <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } }</code> </pre><br>  Wenn wir uns entschließen, eine neue Aufgabe hinzuzufügen, um (zum Beispiel) den Befehl <i>touch</i> mit unserem Collector auf die Datei anzuwenden (aktualisiert das Änderungsdatum der Datei), würden wir <i>npm install <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">example</a> / command-</i> <i>running ausführen</i> und dann Änderungen an <i>angle.json vornehmen</i> : <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"projects"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder-test"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"architect"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"touch"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@example/command-runner:command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">"touch"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"args"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"build"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"builder"</span></span>: <span class="hljs-string"><span class="hljs-string">"@angular-devkit/build-angular:browser"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"outputPath"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/builder-test"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"index"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/index.html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/main.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"polyfills"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/polyfills.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tsConfig"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/tsconfig.app.json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"configurations"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"production"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fileReplacements"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"replace"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.ts"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"with"</span></span>: <span class="hljs-string"><span class="hljs-string">"src/environments/environment.prod.ts"</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"optimization"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"aot"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"buildOptimizer"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } } } } }</code> </pre><br>  Die Angular-CLI verfügt über einen Befehl <i>run</i> , der der Hauptbefehl zum Ausführen von Kollektoren ist.  Als erstes Argument wird eine Zeichenfolge im Format <i>PROJECT: TASK [: CONFIGURATION] verwendet</i> .  Um unsere Aufgabe auszuführen, können wir den Befehl <i>ng run builder-test: touch verwenden</i> . <br><br>  Jetzt möchten wir vielleicht einige Argumente neu definieren.  Leider können wir Arrays über die Befehlszeile noch nicht neu definieren, aber wir können den Befehl selbst zur Demonstration ändern: <i>ng run builder-test: touch --command = ls</i> .  - Dadurch wird die <i>Datei src / main.ts ausgegeben</i> . <br><br><h2>  Watch-Modus </h2><br>  Standardmäßig wird davon ausgegangen, dass Kollektoren einmal aufgerufen und beendet werden. Sie können jedoch <i>Observable zurückgeben</i> , um ihren eigenen Beobachtungsmodus zu implementieren (wie dies der <i>Webpack-</i> Kollektor tut).  Der Architekt abonniert das <i>Observable,</i> bis es beendet oder gestoppt ist, und kann den Collector erneut abonnieren, wenn der Collector mit denselben Parametern aufgerufen wird (wenn auch nicht garantiert). <br><br><ol><li>  Der Kollektor sollte nach jeder Ausführung ein <i>BuilderOutput-</i> Objekt zurückgeben.  Nach Abschluss kann es in den Beobachtungsmodus wechseln, der durch ein externes Ereignis verursacht wird. Wenn es erneut <i>gestartet</i> wird, muss es die Funktion <i>context.reportRunning () aufrufen</i> , um Architect zu benachrichtigen, dass der Kollektor wieder arbeitet.  Dies schützt den Kollektor davor, ihn vom Architekten bei einem neuen Aufruf zu stoppen. </li><li>  Der Architekt selbst meldet sich von <i>Observable ab,</i> wenn der Kollektor stoppt (z. B. mit run.stop ()), und verwendet dabei die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teardown-Logik</a> - den Zerstörungsalgorithmus.  Auf diese Weise können Sie die Assembly stoppen und löschen, wenn dieser Prozess bereits ausgeführt wird. </li></ol><br>  Zusammenfassend lässt sich sagen, dass Ihr Sammler, wenn er externe Ereignisse beobachtet, in drei Schritten arbeitet: <br><br><ol><li>  <b>Erfüllung.</b>  Zum Beispiel die Kompilierung von Webpack.  Dieser Schritt endet, wenn Webpack die Erstellung abgeschlossen hat und Ihr Kollektor <i>BuilderOutput</i> an <i>Observable</i> sendet. </li><li>  <b>Beobachtung.</b>  - Zwischen zwei Starts werden externe Ereignisse überwacht.  Beispielsweise überwacht Webpack das Dateisystem auf Änderungen.  Dieser Schritt endet, wenn Webpack den Build fortsetzt und <i>context.reportRunning ()</i> aufgerufen wird.  Nach diesem Schritt beginnt Schritt 1 erneut. </li><li>  <b>Fertigstellung.</b>  - Die Aufgabe ist vollständig abgeschlossen (es wurde beispielsweise erwartet, dass Webpack eine bestimmte Anzahl von Malen gestartet wird) oder der Start des Kollektors wurde gestoppt (mit <i>run.stop ()</i> ).  In diesem Fall wird der <i>Observable-</i> Zerstörungsalgorithmus ausgeführt und gelöscht. </li></ol><br><h2>  Fazit </h2><br>  Hier ist eine Zusammenfassung dessen, was wir in dieser Veröffentlichung gelernt haben: <br><br><ol><li>  Wir bieten eine neue API, mit der Entwickler das Verhalten von Angular CLI-Befehlen ändern und mithilfe von Assemblern, die die erforderliche Logik implementieren, neue hinzufügen können. </li><li>  Kollektoren können synchron, asynchron und auf externe Ereignisse reagieren.  Sie können sowohl mehrfach als auch von anderen Sammlern aufgerufen werden. </li><li>  Die Parameter, die der Kollektor beim Start der Task empfängt, werden zuerst aus der Datei <i>angle.json</i> gelesen, dann von den Parametern aus der Konfiguration, falls vorhanden, überschrieben und dann von den Befehlszeilenflags überschrieben, wenn sie hinzugefügt wurden. </li><li>  Die empfohlene Methode zum Testen von Kollektoren besteht in Integrationstests. Sie können jedoch Unit-Tests getrennt von der Kollektorlogik durchführen. </li><li>  Wenn der Kollektor ein Observable zurückgibt, sollte es nach Durchlaufen des Zerstörungsalgorithmus gelöscht werden. </li></ol><br>  In naher Zukunft wird die Häufigkeit der Verwendung dieser APIs zunehmen.  Zum Beispiel ist die Bazel-Implementierung stark mit ihnen verbunden. <br><br>  Wir sehen bereits, wie die Community neue CLI-Kollektoren zur Verwendung erstellt, z. B. <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Jest</a></i> und <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cypress</a></i> zum Testen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450746/">https://habr.com/ru/post/de450746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450734/index.html">Fuzzing ist ein wichtiger Schritt für eine sichere Entwicklung</a></li>
<li><a href="../de450736/index.html">"Das Internet zu isolieren ist viel einfacher und billiger als das externe Blockieren."</a></li>
<li><a href="../de450738/index.html">Roboter im Rechenzentrum: Wie kann künstliche Intelligenz nützlich sein?</a></li>
<li><a href="../de450740/index.html">Smart Lamp Base REDMOND - Ergänzen Sie das Smart Home</a></li>
<li><a href="../de450744/index.html">Fahrradinfrastruktur in Minsk für einen IT-Expat</a></li>
<li><a href="../de450748/index.html">ISTQB-Zertifizierung. Teil 1: sein oder nicht sein?</a></li>
<li><a href="../de450752/index.html">"Ich habe nur eine Lehrmethode: nur arbeiten" - Interview mit Ryan Dahl (Node.js, Deno)</a></li>
<li><a href="../de450754/index.html">Rollstuhlrennen: Russischer Pilot gewinnt CYBATHLON-Meisterschaft in Tokio</a></li>
<li><a href="../de450756/index.html">Über militärische Arbeitsunfähigkeit</a></li>
<li><a href="../de450758/index.html">factory_trace gem hilft beim Reinigen Ihrer Fabriken</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>