<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏾 😹 📕 Cara menembak diri Anda di kaki di C dan C ++. Haiku OS Cookbook 😲 🏴 🤭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kisah tentang bagaimana penganalisa statis PVS-Studio dan kode OS Haiku bertemu kembali ke tahun 2015. Itu adalah eksperimen yang menarik dan pengalam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menembak diri Anda di kaki di C dan C ++. Haiku OS Cookbook</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/461253/">  Kisah tentang bagaimana penganalisa statis PVS-Studio dan kode OS Haiku bertemu kembali ke tahun 2015. Itu adalah eksperimen yang menarik dan pengalaman yang berguna untuk tim dari kedua proyek.  Kenapa harus bereksperimen?  Pada saat itu, kami tidak memiliki analisa untuk Linux dan kami tidak akan memilikinya untuk satu setengah tahun lagi.  Bagaimanapun, upaya para penggemar dari tim kami telah dihargai: kami berkumpul dengan pengembang Haiku dan meningkatkan kualitas kode, memperluas basis kesalahan kami dengan bug langka yang dibuat oleh pengembang dan menyempurnakan penganalisis.  Sekarang Anda dapat memeriksa kode Haiku untuk kesalahan dengan mudah dan cepat. <br><div style="text-align:center;"><img src="https://import.viva64.com/docx/blog/0644_Haiku_3/image1.png" alt="Gambar 1"></div><br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  Temui karakter utama dari cerita kami - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Haiku</a> dengan kode sumber terbuka dan penganalisa statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> untuk C, C ++, C # dan Java.  Ketika kami menggali analisis proyek 4,5 tahun yang lalu, kami hanya harus berurusan dengan file penganalisa yang dapat dieksekusi yang dikompilasi.  Semua infrastruktur untuk parsing parameter kompiler, menjalankan preprosesor, sejajar dengan analisis dan seterusnya diambil dari utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Compiler Monitoring UI</a> , ditulis dalam C #.  Utilitas itu porting sebagian ke platform Mono untuk dijalankan di Linux.  Proyek Haiku dibangun menggunakan kompiler silang di bawah berbagai OS, kecuali Windows.  Sekali lagi, saya ingin menyebutkan kenyamanan dan kelengkapan dokumentasi terkait dengan gedung Haiku.  Saya juga ingin mengucapkan terima kasih kepada pengembang Haiku atas bantuan mereka dalam membangun proyek. <br><br>  Jauh lebih mudah untuk melakukan analisis sekarang.  Berikut adalah daftar semua perintah untuk membangun dan menganalisis proyek: <br><br><pre><code class="cpp hljs">cd /opt git clone https:<span class="hljs-comment"><span class="hljs-comment">//review.haiku-os.org/buildtools git clone https://review.haiku-os.org/haiku cd ./haiku mkdir generated.x86_64; cd generated.x86_64 ../configure --distro-compatibility official -j12 \ --build-cross-tools x86_64 ../../buildtools cd ../../buildtools/jam make all cd /opt/haiku/generated.x86_64 pvs-studio-analyzer trace -- /opt/buildtools/jam/bin.linuxx86/jam \ -q -j1 @nightly-anyboot pvs-studio-analyzer analyze -l /mnt/svn/PVS-Studio.lic -r /opt/haiku \ -C x86_64-unknown-haiku-gcc -o /opt/haiku/haiku.log -j12</span></span></code> </pre> <br>  Omong-omong, analisis proyek dilaksanakan dalam wadah Docker.  Baru-baru ini kami telah menyiapkan dokumentasi baru tentang topik ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menjalankan PVS-Studio di Docker</a> .  Ini dapat membuatnya sangat mudah bagi beberapa perusahaan untuk menerapkan teknik analisis statis untuk proyek mereka. <br><br><h2>  Variabel tidak diinisialisasi </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V614</a> 'rval' variabel tidak diinisialisasi digunakan.  fetch.c 1727 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">auto_fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argpos; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rval; <span class="hljs-comment"><span class="hljs-comment">// &lt;= argpos = 0; if (sigsetjmp(toplevel, 1)) { if (connected) disconnect(0, NULL); if (rval &gt; 0) // &lt;= rval = argpos + 1; return (rval); } .... }</span></span></code> </pre> <br>  Variabel <i>rval</i> belum diinisialisasi pada deklarasi, jadi perbandingannya dengan nilai nol akan menghasilkan hasil yang tidak ditentukan.  Jika keadaan gagal, nilai tidak pasti dari variabel <i>rval dapat</i> menjadi nilai kembali fungsi <i>auto_fetch</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V614</a> 'Res' pointer tidak diinisialisasi digunakan.  commands.c 2873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_family; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_socktype; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ai_protocol; <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> ai_addrlen; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ai_canonname; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_addr</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addrinfo</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ai_next</span></span></span><span class="hljs-class">;</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sourceroute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct addrinfo *ai, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *arg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **cpp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *lenp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *protop, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *optp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span> + ALIGNBYTES]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, *cp2, *lsrp, *ep; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_in</span></span></span><span class="hljs-class"> *_</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sin</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> INET6 struct sockaddr_in6 *sin6; struct ip6_rthdr *rth; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> struct addrinfo hints, *res; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= int error; char c; if (cpp == NULL || lenp == NULL) return -1; if (*cpp != NULL) { switch (res-&gt;ai_family) { // &lt;= case AF_INET: if (*lenp &lt; 7) return -1; break; .... } } .... }</span></span></span></span></code> </pre> <br>  Berikut adalah kasus serupa menggunakan variabel tidak diinisialisasi, kecuali bahwa <i>res</i> adalah pointer tidak diinisialisasi yang terjadi di sini. <br><br>  Pointer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V506</a> ke variabel lokal 'dinormalisasi' disimpan di luar ruang lingkup variabel ini.  Pointer seperti itu akan menjadi tidak valid.  TextView.cpp 5596 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BTextView::_ApplyStyleRange(...., <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BFont* font, ....) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (font != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { BFont normalized = *font; _NormalizeFont(&amp;normalized); font = &amp;normalized; } .... fStyles-&gt;SetStyleRange(fromOffset, toOffset, fText-&gt;Length(), mode, font, color); }</code> </pre> <br>  Pemrogram mungkin perlu menormalkan objek menggunakan variabel perantara.  Tapi sekarang pointer <i>font</i> berisi pointer ke objek yang <i>dinormalisasi</i> , yang akan dihapus setelah keluar dari ruang lingkup, tempat objek sementara dibuat. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V603</a> Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 27 <br><br><pre> <code class="cpp hljs">int8 BUnicodeChar::Type(uint32 c) { BUnicodeChar(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> u_charType(c); }</code> </pre> <br>  Kesalahan yang sangat umum di antara programmer C ++ adalah menggunakan panggilan konstruktor yang seharusnya untuk menginisialisasi / membatalkan bidang kelas.  Dalam hal ini, modifikasi bidang kelas tidak terjadi, tetapi objek baru yang tidak disebutkan namanya dari kelas ini dibuat dan kemudian segera dihancurkan.  Sayangnya, ada banyak tempat seperti itu di proyek: <br><br><ul><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 37 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 49 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 58 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 67 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 77 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 89 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 103 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 115 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 126 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 142 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 152 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 163 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 186 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 196 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 206 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 214 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 222 </li><li>  V603 Objek telah dibuat tetapi tidak sedang digunakan.  Jika Anda ingin memanggil konstruktor, 'this-&gt; BUnicodeChar :: BUnicodeChar (....)' harus digunakan.  UnicodeChar.cpp 230 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V670</a> Anggota kelas 'fPatternHandler' yang tidak diinisialisasi digunakan untuk menginisialisasi anggota 'fInternal'.  Ingat bahwa anggota diinisialisasi dalam urutan deklarasi mereka di dalam kelas.  Painter.cpp 184 <br><br><pre> <code class="cpp hljs">Painter::Painter() : fInternal(fPatternHandler), .... fPatternHandler(), .... { .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Painter</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> PainterAggInterface fInternal; <span class="hljs-comment"><span class="hljs-comment">// line 336 bool fSubpixelPrecise : 1; bool fValidClipping : 1; bool fDrawingText : 1; bool fAttached : 1; bool fIdentityTransform : 1; Transformable fTransform; float fPenSize; const BRegion* fClippingRegion; drawing_mode fDrawingMode; source_alpha fAlphaSrcMode; alpha_function fAlphaFncMode; cap_mode fLineCapMode; join_mode fLineJoinMode; float fMiterLimit; PatternHandler fPatternHandler; // line 355 mutable AGGTextRenderer fTextRenderer; };</span></span></code> </pre> <br>  Contoh lain inisialisasi yang salah.  Bidang kelas diinisialisasi dalam urutan deklarasi mereka di kelas itu sendiri.  Dalam contoh ini, bidang <i>fInternal</i> akan menjadi yang pertama menginisialisasi menggunakan nilai <i>fPatternHandler yang</i> tidak diinisialisasi. <br><br><h2>  #Define mencurigakan </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V523</a> Pernyataan 'lalu' sama dengan pernyataan 'lain'.  subr_gtaskqueue.c 191 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_LOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_lock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_lock(&amp;(tq)-&gt;tq_mutex); \ } while (0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_ASSERT_LOCKED(tq) mtx_assert(&amp;(tq)-&gt;tq_mutex, MA_OWNED) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TQ_UNLOCK(tq) \ do { \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((tq)-&gt;tq_spin) \ mtx_unlock_spin(&amp;(tq)-&gt;tq_mutex); \ </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> \ mtx_unlock(&amp;(tq)-&gt;tq_mutex); \ } while (0) void grouptask_block(struct grouptask *grouptask) { .... TQ_LOCK(queue); gtask-&gt;ta_flags |= TASK_NOENQUEUE; gtaskqueue_drain_locked(queue, gtask); TQ_UNLOCK(queue); }</span></span></code> </pre> <br>  Cuplikan kode ini tidak terlihat mencurigakan hingga Anda melihat hasil preprosesor: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grouptask_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct grouptask *grouptask)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_lock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); gtask-&gt;ta_flags |= <span class="hljs-number"><span class="hljs-number">0x4</span></span>; gtaskqueue_drain_locked(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>, gtask); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_spin) mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> mtx_unlock(&amp;(<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>)-&gt;tq_mutex); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Alat analisa benar-benar benar - <i>jika</i> dan cabang lainnya identik.  Tetapi di <i>manakah</i> fungsi <i>mtx_lock_spin</i> dan <i>mtx_unlock_spin</i> ?  Macros <i>TQ_LOCK</i> , <i>TQ_UNLOCK</i> dan fungsi <i>grouptask_block</i> dideklarasikan dalam satu file hampir di sebelah satu sama lain, tetapi meskipun demikian terjadi penggantian di suatu tempat di sini. <br><br>  Pencarian melalui file hanya menghasilkan <i>mutex.h</i> dengan konten berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* on FreeBSD these are different functions */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_lock_spin(x) mtx_lock(x) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> mtx_unlock_spin(x) mtx_unlock(x)</span></span></code> </pre> <br>  Pengembang proyek harus memeriksanya apakah penggantian semacam itu benar atau tidak.  Saya memeriksa proyek ini di Linux dan penggantian seperti itu tampak mencurigakan bagi saya. <br><br><h2>  Kesalahan dengan fungsi bebas </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V575 Penunjuk</a> nol dilewatkan ke fungsi 'bebas'.  Periksa argumen pertama.  setmime.cpp 727 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MimeType::_PurgeProperties() { fShort.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fLong.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefApp.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fPrefAppSig.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); fSniffRule.Truncate(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fSmallIcon; fSmallIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fBigIcon; fBigIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; fVectorIcon = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(fVectorIcon); // &lt;= fExtensions.clear(); fAttributes.clear(); }</span></span></code> </pre> <br>  Anda dapat melewatkan pointer nol di fungsi <i>bebas</i> , tetapi penggunaan seperti itu pasti mencurigakan.  Dengan demikian, penganalisa menemukan campuran garis kode.  Pertama, pembuat kode harus melepaskan memori dengan pointer <i>fVectorIcon</i> , hanya setelah itu tetapkan <i>NULL</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V575 Penunjuk</a> nol dilewatkan ke fungsi 'bebas'.  Periksa argumen pertama.  driver_settings.cpp 461 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> settings_handle * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_driver_settings_from_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *driverName)</span></span></span><span class="hljs-function"> </span></span>{ .... handle = new_settings(text, driverName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handle != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// everything went fine! return handle; } free(handle); // &lt;= .... }</span></span></code> </pre> <br>  Ini adalah contoh lain dari pengoperan null pointer secara eksplisit ke fungsi <i>bebas</i> .  Baris ini dapat dihapus, saat fungsi keluar setelah mendapatkan pointer dengan sukses. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V575 Penunjuk</a> nol dilewatkan ke fungsi 'bebas'.  Periksa argumen pertama.  PackageFileHeapWriter.cpp 166 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* _GetBuffer() { .... <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* buffer = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(fBufferSize); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> &amp;&amp; !fBuffers.AddItem(buffer)) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::bad_alloc(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer; }</code> </pre> <br>  Seseorang membuat kesalahan di sini.  Operator || harus digunakan alih-alih &amp;&amp;.  Hanya dalam kasus ini pengecualian <i>std :: bad_alloc ()</i> akan dilemparkan seandainya alokasi memori (menggunakan fungsi <i>malloc</i> ) gagal. <br><br><h2>  Kesalahan dengan operator hapus </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'T baru] tetapi dirilis menggunakan operator' hapus '.  Pertimbangkan untuk memeriksa kode ini.  Mungkin lebih baik menggunakan 'delete [] fMsg;'.  Err.cpp 65 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Err</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *fMsg; <span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span> fPos; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Err::Unset() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fMsg; <span class="hljs-comment"><span class="hljs-comment">// &lt;= fMsg = __null; fPos = -1; } void Err::SetMsg(const char *msg) { if (fMsg) { delete fMsg; // &lt;= fMsg = __null; } if (msg) { fMsg = new(std::nothrow) char[strlen(msg)+1]; // &lt;= if (fMsg) strcpy(fMsg, msg); } }</span></span></code> </pre> <br>  Pointer <i>fMsg</i> digunakan untuk mengalokasikan memori untuk berbagai karakter.  Operator <i>hapus</i> digunakan untuk melepaskan memori alih-alih <i>menghapus []</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'baru' tetapi dirilis menggunakan fungsi 'bebas'.  Pertimbangkan untuk memeriksa logika operasi di belakang variabel 'wrapperPool'.  vm_page.cpp 3080 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> vm_page_write_modified_page_range(....) { .... PageWriteWrapper* wrapperPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper[maxPages + <span class="hljs-number"><span class="hljs-number">1</span></span>]; PageWriteWrapper** wrappers = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(malloc_flags(allocationFlags)) PageWriteWrapper*[maxPages]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (wrapperPool == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || wrappers == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(wrapperPool); <span class="hljs-comment"><span class="hljs-comment">// &lt;= free(wrappers); // &lt;= wrapperPool = stackWrappersPool; wrappers = stackWrappers; maxPages = 1; } .... }</span></span></code> </pre> <br>  Di sini <i>malloc_flags</i> adalah fungsi yang memanggil <i>malloc</i> .  Kemudian <i>penempatan-baru</i> membangun objek di sini.  Karena kelas <i>PageWriteWrapper</i> diimplementasikan dengan cara berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PageWriteWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PageWriteWrapper(); ~PageWriteWrapper(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vm_page* page)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">status_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> result)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: vm_page* fPage; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VMCache</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fCache</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fIsActive; }; PageWriteWrapper::PageWriteWrapper() : fIsActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } PageWriteWrapper::~PageWriteWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fIsActive) panic(<span class="hljs-string"><span class="hljs-string">"page write wrapper going out of scope but isn't completed"</span></span>); }</code> </pre> <br>  penghancur objek dari kelas ini tidak akan dipanggil karena penggunaan fungsi <i>bebas</i> untuk melepaskan memori. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V611</a> Memori dialokasikan menggunakan operator 'T baru] tetapi dirilis menggunakan operator' hapus '.  Pertimbangkan untuk memeriksa kode ini.  Mungkin lebih baik menggunakan 'delete [] fOutBuffer;'.  Periksa baris: 26, 45. PCL6Rasterizer.h 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PCL6Rasterizer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Rasterizer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... ~PCL6Rasterizer() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> fOutBuffer; fOutBuffer = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fOutBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> uchar[fOutBufferSize]; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: uchar* fOutBuffer; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fOutBufferSize; };</code> </pre> <br>  Ini adalah kesalahan umum untuk menggunakan operator <i>hapus</i> alih-alih <i>menghapus [].</i>  Cara termudah untuk membuat kesalahan saat menulis kelas, karena kode destruktor sering jauh dari lokasi memori.  Di sini, programmer secara tidak benar membebaskan memori yang disimpan oleh pointer <i>fOutBuffer</i> di destructor. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V772</a> Memanggil operator 'hapus' untuk pointer kosong akan menyebabkan perilaku tidak terdefinisi.  Hashtable.cpp 207 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Hashtable::MakeEmpty(int8 keyMode,int8 valueMode) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (entry = fTable[index]; entry; entry = next) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (keyMode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> HASH_EMPTY_DELETE: <span class="hljs-comment"><span class="hljs-comment">// </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete (void*)entry-&gt;key; break; case HASH_EMPTY_FREE: free((void*)entry-&gt;key); break; } switch (valueMode) { case HASH_EMPTY_DELETE: // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> destructors are not called! delete entry-&gt;value; break; case HASH_EMPTY_FREE: free(entry-&gt;value); break; } next = entry-&gt;next; delete entry; } .... }</span></span></code> </pre> <br>  Selain pilihan yang salah antara <i>hapus</i> / <i>hapus []</i> dan <i>gratis</i> , Anda juga dapat mengalami perilaku yang tidak terdefinisi saat mencoba menghapus memori dengan pointer ke tipe <i>void (void *)</i> . <br><br><h2>  Fungsi tanpa nilai kembali </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi V591</a> Non-void harus mengembalikan nilai.  Referenceable.h 228 <br><br><pre> <code class="cpp hljs">BReference&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BReference&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Type&gt;&amp; other) { fReference = other.fReference; }</code> </pre> <br>  Operator penugasan yang kelebihan muatan tidak memiliki nilai balik.  Dalam hal ini, operator akan mengembalikan nilai acak, yang dapat menyebabkan kesalahan aneh. <br><br>  Berikut adalah masalah serupa di fragmen kode lain dari kelas ini: <br><br><ul><li>  Fungsi V591 Non-void harus mengembalikan nilai.  Referenceable.h 233 </li><li>  Fungsi V591 Non-void harus mengembalikan nilai.  Referenceable.h 239 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi V591</a> Non-void harus mengembalikan nilai.  main.c 1010 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *, ...)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getoptionvalue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">option</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with NULL name"</span></span>); c = getoption(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c-&gt;value); errx(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"getoptionvalue() invoked with unknown option '%s'"</span></span>, name); <span class="hljs-comment"><span class="hljs-comment">/* NOTREACHED */</span></span> }</code> </pre> <br>  Komentar pengguna NOTREACHED tidak berarti apa-apa di sini.  Anda perlu membuat anotasi fungsi sebagai noreturn agar dapat menulis kode dengan benar untuk skenario semacam itu.  Untuk melakukan ini, ada atribut noreturn: standar dan khusus-kompiler.  Pertama-tama, atribut-atribut ini diperhitungkan oleh kompiler untuk pembuatan kode yang tepat atau pemberitahuan tentang jenis bug tertentu yang menggunakan peringatan.  Berbagai alat analisis statis juga memperhitungkan atribut akun untuk meningkatkan kualitas analisis. <br><br><h2>  Menangani pengecualian </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V596</a> Objek telah dibuat tetapi tidak sedang digunakan.  Kata kunci 'lempar' bisa hilang: lempar ParseException (FOO);  Response.cpp 659 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Response::ExtractNumber(BDataIO&amp; stream) { BString <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> = ExtractString(stream); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* end; <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> number = strtoul(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.String(), (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>**)&amp;end, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (end == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || end[<span class="hljs-number"><span class="hljs-number">0</span></span>] != <span class="hljs-string"><span class="hljs-string">'\0'</span></span>) ParseException(<span class="hljs-string"><span class="hljs-string">"Invalid number!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number; }</code> </pre> <br>  <i>Pelemparan</i> kata kunci tidak sengaja terlupakan di sini.  Dengan demikian, pengecualian <i>ParseException</i> tidak akan dihasilkan sementara objek kelas ini akan dihancurkan saat keluar dari ruang lingkup.  Setelah itu, fungsi akan terus bekerja seolah-olah tidak ada yang terjadi, seolah-olah nomor yang benar telah dimasukkan. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1022</a> Pengecualian dilemparkan oleh pointer.  Pertimbangkan untuk melemparkannya dengan nilai saja.  gensyscallinfos.cpp 316 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">** argv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Main().Run(argc, argv); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception&amp; exception) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= fprintf(stderr, "%s\n", exception.what()); return 1; } } int Run(int argc, char** argv) { .... _ParseSyscalls(argv[1]); .... } void _ParseSyscalls(const char* filename) { ifstream file(filename, ifstream::in); if (!file.is_open()) throw new IOException(string("Failed to open '") + filename + "'."); // &lt;= .... }</span></span></code> </pre> <br>  Penganalisa mendeteksi pengecualian <i>IOException yang</i> dilemparkan oleh pointer.  Melempar pointer mengarah pada fakta bahwa pengecualian tidak akan ditangkap.  Jadi pengecualian akhirnya tertangkap oleh referensi.  Selain itu, penggunaan pointer memaksa sisi penangkap untuk memanggil operator <i>hapus</i> untuk menghancurkan objek yang dibuat, yang belum dilakukan. <br><br>  Beberapa fragmen kode lain yang bermasalah: <br><br><ul><li>  V1022 Pengecualian dilemparkan oleh pointer.  Pertimbangkan untuk melemparkannya dengan nilai saja.  gensyscallinfos.cpp 347 </li><li>  V1022 Pengecualian dilemparkan oleh pointer.  Pertimbangkan untuk melemparkannya dengan nilai saja.  gensyscallinfos.cpp 413 </li></ul><br><h2>  Keamanan formal </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V597</a> Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk flush objek 'f_key'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 1018 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SAFE_FREE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SAFE_FREE(a) \ do{</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(a != NULL){memset(a,0, sizeof(*a)); free(a); a=NULL;}} while (0) .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> DST_KEY * dst_free_key(DST_KEY *f_key) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key == NULL) return (f_key); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_func &amp;&amp; f_key-&gt;dk_func-&gt;destroy) f_key-&gt;dk_KEY_struct = f_key-&gt;dk_func-&gt;destroy(f_key-&gt;dk_KEY_struct); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { EREPORT((</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dst_free_key(): Unknown key alg %d\n"</span></span></span><span class="hljs-meta">, f_key-&gt;dk_alg)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_KEY_struct) { free(f_key-&gt;dk_KEY_struct); f_key-&gt;dk_KEY_struct = NULL; } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (f_key-&gt;dk_key_name) SAFE_FREE(f_key-&gt;dk_key_name); SAFE_FREE(f_key); return (NULL); }</span></span></code> </pre> <br>  Penganalisa telah mendeteksi kode yang mencurigakan, dimaksudkan untuk mengamankan data pribadi.  Sayangnya, makro <i>SAFE_FREE</i> yang meluas ke <i>memset</i> , panggilan <i>gratis</i> , dan penugasan <i>NULL</i> tidak membuat kode lebih aman, karena semuanya dihapus oleh kompiler saat dioptimalkan dengan <i>O2</i> . <br><br>  By the way, itu tidak lain adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CWE-14</a> : Penghapusan Kompiler Kode ke Hapus Buffer. <br><br>  Berikut adalah daftar tempat, di mana pembersihan buffer tidak dilakukan pada kenyataannya: <br><br><ul><li>  V597 Kompiler dapat menghapus pemanggilan fungsi 'memset', yang digunakan untuk membersihkan buffer 'encoded_block'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 446 </li><li>  V597 Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk menyiram objek 'key_st'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 685 </li><li>  V597 Kompiler dapat menghapus pemanggilan fungsi 'memset', yang digunakan untuk membersihkan buffer 'in_buff'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  dst_api.c 916 </li><li>  V597 Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk menyiram objek 'ce'.  Fungsi memset_s () harus digunakan untuk menghapus data pribadi.  fs_cache.c 1078 </li></ul><br><h2>  Perbandingan dengan variabel yang tidak ditandatangani </h2><br>  Ekspresi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> 'tersisa &lt;0' selalu salah.  Nilai tipe yang tidak ditandatangani tidak pernah &lt;0. DwarfFile.cpp 1947 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> DwarfFile::_UnwindCallFrame(....) { .... uint64 remaining = lengthOffset + length - dataReader.Offset(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (remaining &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_BAD_DATA; .... }</code> </pre> <br>  Penganalisa menemukan perbandingan eksplisit dari variabel unsigned dengan nilai negatif.  Mungkin, seseorang harus membandingkan variabel yang <i>tersisa</i> hanya dengan nol atau mengimplementasikan pemeriksaan untuk overflow. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> Ekspresi 'sleep ((unsigned) secs) &lt;0' selalu salah.  Nilai tipe yang tidak ditandatangani tidak pernah &lt;0. Misc.cpp 56 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">status_t</span></span> snooze(<span class="hljs-keyword"><span class="hljs-keyword">bigtime_t</span></span> amount) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (amount &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> B_OK; int64 secs = amount / <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; int64 usecs = amount % <span class="hljs-number"><span class="hljs-number">1000000L</span></span>L; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (secs &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sleep((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)secs) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= return errno; } if (usecs &gt; 0) { if (usleep((useconds_t)usecs) &lt; 0) return errno; } return B_OK; }</span></span></code> </pre> <br>  Untuk mendapatkan poin utama dari kesalahan, mari kita membahas tanda tangan fungsi <i>sleep</i> dan <i>usleep</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __seconds)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">usleep</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">__useconds_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> __useconds)</span></span></span></span>;</code> </pre> <br>  Seperti yang dapat kita lihat, fungsi <i>tidur</i> mengembalikan nilai yang tidak ditandatangani dan penggunaannya dalam kode salah. <br><br><h2>  Pointer berbahaya </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V774 Pointer</a> 'perangkat' digunakan setelah memori dilepaskan.  xhci.cpp 1572 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> XHCI::FreeDevice(Device *device) { uint8 slot = fPortSlots[device-&gt;HubPort()]; TRACE(<span class="hljs-string"><span class="hljs-string">"FreeDevice() port %d slot %d\n"</span></span>, device-&gt;HubPort(), slot); <span class="hljs-comment"><span class="hljs-comment">// Delete the device first, so it cleans up its pipes and tells us // what we need to destroy before we tear down our internal state. delete device; DisableSlot(slot); fDcba-&gt;baseAddress[slot] = 0; fPortSlots[device-&gt;HubPort()] = 0; // &lt;= delete_area(fDevices[slot].trb_area); delete_area(fDevices[slot].input_ctx_area); delete_area(fDevices[slot].device_ctx_area); memset(&amp;fDevices[slot], 0, sizeof(xhci_device)); fDevices[slot].state = XHCI_STATE_DISABLED; }</span></span></code> </pre> <br>  Objek <i>perangkat</i> dibuat oleh operator <i>hapus</i> .  Ini cukup logis untuk fungsi <i>FreeDevice</i> .  Tetapi, untuk beberapa alasan, untuk melepaskan sumber daya lain, objek yang sudah dihapus ditangani. <br><br>  Kode tersebut sangat berbahaya dan dapat dipenuhi di beberapa tempat lain: <br><br><ul><li>  V774 Pointer 'mandiri' digunakan setelah memori dilepaskan.  TranslatorRoster.cpp 884 </li><li>  V774 Pointer 'string' digunakan setelah memori dilepaskan.  RemoteView.cpp 1269 </li><li>  V774 Pointer 'bs' digunakan setelah memori dilepaskan.  mkntfs.c 4291 </li><li>  V774 Pointer 'bs' digunakan setelah memori dilepaskan.  mkntfs.c 4308 </li><li>  V774 Pointer 'al' digunakan setelah memori dialokasikan kembali.  inode.c 1155 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V522 Dereferencing</a> dari 'data' pointer nol mungkin terjadi.  Pointer nol dilewatkan ke fungsi 'malo_hal_send_helper'.  Periksa argumen ketiga.  Periksa baris: 350, 394. if_malohal.c 350 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malo_hal_fwload_helper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct malo_hal *mh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *helper)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* tell the card we're done and... */</span></span> error = malo_hal_send_helper(mh, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, MALO_NOWAIT); <span class="hljs-comment"><span class="hljs-comment">// &lt;= NULL .... } static int malo_hal_send_helper(struct malo_hal *mh, int bsize, const void *data, size_t dsize, int waitfor) { mh-&gt;mh_cmdbuf[0] = htole16(MALO_HOSTCMD_CODE_DNLD); mh-&gt;mh_cmdbuf[1] = htole16(bsize); memcpy(&amp;mh-&gt;mh_cmdbuf[4], data , dsize); // &lt;= data .... }</span></span></code> </pre> <br>  Analisis antar prosedural mengungkapkan kasus ketika <i>NULL</i> diteruskan ke fungsi dan penunjuk <i>data</i> dengan nilai seperti itu akhirnya direferensikan dalam fungsi <i>memcpy</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V773</a> Fungsi itu keluar tanpa melepaskan pointer 'inputFileFile'.  Kebocoran memori dimungkinkan.  command_recompress.cpp 119 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">command_recompress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv)</span></span></span><span class="hljs-function"> </span></span>{ .... BFile* inputFileFile = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BFile; error = inputFileFile-&gt;SetTo(inputPackageFileName, O_RDONLY); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != B_OK) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"Error: Failed to open input file \"%s\": %s\n"</span></span>, inputPackageFileName, strerror(error)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } inputFile = inputFileFile; .... }</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio dapat mendeteksi kebocoran memori</a> .  Dalam contoh ini, jika terjadi kesalahan, memori tidak akan dirilis.  Seseorang mungkin berpikir bahwa jika terjadi kesalahan Anda tidak perlu repot dengan rilis memori, karena program masih akan berakhir.  Tetapi tidak selalu demikian.  Ini adalah persyaratan bagi banyak program untuk menangani kesalahan dengan benar dan untuk terus bekerja. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595 Pointer</a> 'fReply' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 49, 52. BalasBuilder.cpp 49 <br><br><pre> <code class="cpp hljs">RPC::CallbackReply* ReplyBuilder::Reply() { fReply-&gt;Stream().InsertUInt(fStatusPosition, _HaikuErrorToNFS4(fStatus)); fReply-&gt;Stream().InsertUInt(fOpCountPosition, fOpCount); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fReply == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || fReply-&gt;Stream().Error() == B_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fReply; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; }</code> </pre> <br>  Ini adalah kesalahan yang sangat umum untuk pointer dereferensi sebelum memeriksanya.  Diagnostik <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595</a> hampir selalu berlaku dalam jumlah peringatan dalam suatu proyek.  Fragmen kode ini termasuk penggunaan pointer <i>fReply</i> yang <i>berbahaya</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595 Pointer</a> 'mq' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 782, 786. oce_queue.c 782 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oce_mq_free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct oce_mq *mq)</span></span></span><span class="hljs-function"> </span></span>{ POCE_SOFTC sc = (POCE_SOFTC) mq-&gt;parent; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">oce_mbx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbx_destroy_common_mq</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fwcmd</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mq) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Contoh serupa.  Pointer <i>mg</i> akan direferensikan beberapa baris lebih awal dari yang diperiksa untuk null.  Ada banyak tempat serupa dalam proyek ini.  Dalam beberapa cuplikan, penggunaan dan pemeriksaan pointer cukup jauh dari satu sama lain, jadi dalam artikel ini Anda hanya akan menemukan beberapa contoh seperti itu.  Pengembang dipersilakan untuk memeriksa contoh lain dalam laporan analisa lengkap. <br><br><h2>  Lain-lain </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V645</a> Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 101 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump_acpi_namespace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(acpi_ns_device_info *device, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *root, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> indenting)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> output[<span class="hljs-number"><span class="hljs-number">320</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> tabs[<span class="hljs-number"><span class="hljs-number">255</span></span>] = <span class="hljs-string"><span class="hljs-string">""</span></span>; .... strlcat(tabs, <span class="hljs-string"><span class="hljs-string">"|--- "</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(tabs)); .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { uint32 type = device-&gt;acpi-&gt;get_object_type(result); <span class="hljs-built_in"><span class="hljs-built_in">snprintf</span></span>(output, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output), <span class="hljs-string"><span class="hljs-string">"%s%s"</span></span>, tabs, result + depth); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_INTEGER: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" INTEGER"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ACPI_TYPE_STRING: <span class="hljs-built_in"><span class="hljs-built_in">strncat</span></span>(output, <span class="hljs-string"><span class="hljs-string">" STRING"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(output)); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... } .... }</code> </pre> <br>  Perbedaan antara fungsi <i>strlcat</i> dan <i>strncat</i> tidak terlalu jelas bagi seseorang yang tidak terbiasa dengan deskripsi fungsi-fungsi ini.  Fungsi <i>strlcat</i> mengharapkan ukuran seluruh buffer sebagai argumen ketiga sementara fungsi <i>strncat</i> - ukuran ruang kosong dalam buffer, yang mengharuskan mengevaluasi nilai yang diperlukan sebelum memanggil fungsi.  Tetapi pengembang sering lupa atau tidak tahu tentang itu.  Melewati seluruh ukuran buffer ke fungsi <i>strncat</i> dapat menyebabkan buffer overflow, karena fungsi akan mempertimbangkan nilai ini sebagai jumlah karakter yang dapat disalin.  Fungsi <i>strlcat</i> tidak memiliki masalah seperti itu.  Tetapi Anda harus melewatkan string, diakhiri dengan terminal null sehingga itu berfungsi dengan baik. <br><br>  Berikut ini seluruh daftar tempat berbahaya dengan string: <br><br><ul><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 104 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 107 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 110 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 113 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 118 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 119 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 120 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 123 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 126 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 129 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 132 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 135 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 138 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 141 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'output'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  NamespaceDump.cpp 144 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'fitur_string'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  VirtioDevice.cpp 283 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'fitur_string'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  VirtioDevice.cpp 284 </li><li>  V645 Panggilan fungsi 'strncat' dapat menyebabkan buffer overflow 'fitur_string'.  Batas tidak boleh berisi ukuran buffer, tetapi sejumlah karakter dapat menampungnya.  VirtioDevice.cpp 285 </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V792</a> Fungsi 'SetDecoratorSettings' terletak di sebelah kanan operator '|'  akan dipanggil terlepas dari nilai operan kiri.  Mungkin, lebih baik menggunakan '||'.  DesktopListener.cpp 324 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DesktopListener</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DoublyLinkedListLinkImpl&lt;DesktopListener&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDecoratorSettings</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Window* window, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BMessage&amp; settings)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> DesktopObservable::SetDecoratorSettings(Window* window, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BMessage&amp; settings) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fWeAreInvoking) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-function"><span class="hljs-function">InvokeGuard </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invokeGuard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fWeAreInvoking)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> changed = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (DesktopListener* listener = fDesktopListenerList.First(); listener != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; listener = fDesktopListenerList.GetNext(listener)) changed = changed | listener-&gt;SetDecoratorSettings(window, settings); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> changed; }</code> </pre> <br>  Kemungkinan besar, '|'  dan '||'  operator kacau.  Kesalahan ini menyebabkan panggilan yang tidak perlu dari fungsi <i>SetDecoratorSettings</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V627</a> Pertimbangkan untuk memeriksa ekspresi.  Argumen sizeof () adalah makro yang diperluas ke angka.  device.c 72 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PCI_line_size 0x0c </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* (1 byte) cache line size in 32 bit words */</span></span></span><span class="hljs-meta"> static status_t wb840_open(const char* name, uint32 flags, void** cookie) { .... data-&gt;wb_cachesize = gPci-&gt;read_pci_config(data-&gt;pciInfo-&gt;bus, data-&gt;pciInfo-&gt;device, data-&gt;pciInfo-&gt;function, PCI_line_size, sizeof(PCI_line_size)) &amp; 0xff; .... }</span></span></code> </pre> <br>  Melewati nilai <i>0x0c</i> ke <i>ukuran</i> operator terlihat mencurigakan.  Mungkin, penulis seharusnya mengevaluasi ukuran suatu objek, misalnya <i>data</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V562</a> Aneh membandingkan nilai tipe bool dengan nilai 18: 0x12 == IsProfessionalSpdif ().  CEchoGals_mixer.cpp 533 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BOOL; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsProfessionalSpdif</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ECHOSTATUS_DSP_DEAD 0x12 ECHOSTATUS CEchoGals::ProcessMixerFunction(....) { .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ( ECHOSTATUS_DSP_DEAD == IsProfessionalSpdif() ) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// &lt;= { Status = ECHOSTATUS_DSP_DEAD; } else { pMixerFunction-&gt;Data.bProfSpdif = IsProfessionalSpdif(); } .... }</span></span></span></span></code> </pre> <br>  Fungsi <i>IsProfessionalSpdif</i> mengembalikan nilai tipe <i>bool</i> .  Dengan demikian, hasil fungsi dibandingkan dengan angka <i>0x12</i> dalam kondisi. <br><br><h2>  Kesimpulan </h2><br>  Kami melewatkan rilis beta Haiku pertama musim gugur yang lalu, karena kami sibuk merilis PVS-Studio untuk Jawa.  Namun sifat kesalahan pemrograman adalah sedemikian rupa sehingga tidak hilang jika Anda tidak mencarinya dan tidak memperhatikan kualitas kode.  Pengembang proyek menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Coverity Scan</a> , tetapi yang terakhir hampir dua tahun yang lalu.  Ini pasti mengecewakan pengguna Haiku.  Meskipun analisis telah dikonfigurasi pada 2014 menggunakan Cakupan, itu tidak menghentikan kami dari menulis dua artikel panjang tentang tinjauan kesalahan pada tahun 2015 ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> ) <br><br>  Ulasan kesalahan Haiku lainnya akan segera keluar bagi mereka yang membaca posting ini sampai akhir.  Laporan analisa lengkap akan dikirim ke pengembang sebelum memposting ulasan kesalahan ini, sehingga beberapa kesalahan mungkin diperbaiki pada saat Anda membaca ini.  Untuk menghabiskan waktu di antara artikel, saya sarankan mengunduh dan mencoba <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> untuk proyek Anda. <br><br>  Apakah Anda ingin mencoba Haiku dan Anda memiliki pertanyaan?  Pengembang Haiku mengundang Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran telegram</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461253/">https://habr.com/ru/post/id461253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461241/index.html">Wolfram Mathematica dalam Geofisika</a></li>
<li><a href="../id461243/index.html">Jangan pergi ke Afrika untuk berjalan-jalan: apa situasinya dengan sensor internet di Benua Hitam</a></li>
<li><a href="../id461247/index.html">50 Sumber Terbaik tentang Manajemen Produk untuk Membaca, Mendengarkan, dan Menonton</a></li>
<li><a href="../id461249/index.html">Menulis Aplikasi Android untuk Penggemar Film - Bagian 2 (Desain)</a></li>
<li><a href="../id461251/index.html">Pilihan slide yang berguna dari Julia Evans</a></li>
<li><a href="../id461255/index.html">Cara menembak diri Anda di kaki di C dan C ++. Koleksi Resep OS Haiku</a></li>
<li><a href="../id461257/index.html">Bagaimana cara menghitung ROI dari otomatisasi uji dengan Selenium?</a></li>
<li><a href="../id461259/index.html">Pesta Penyimpanan, 8 Agustus, Moskow</a></li>
<li><a href="../id461261/index.html">Daftar periksa webinar RRC yang bermanfaat untuk produk RRC</a></li>
<li><a href="../id461265/index.html">Tentang penyalahgunaan penggunaan sistem operasi dalam proyek untuk mikrokontroler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>