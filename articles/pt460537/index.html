<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏻 🛀🏾 🧟 ZuriHac: praticando programação funcional 🤥 👩🏽‍🤝‍👩🏼 🗑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em junho deste ano, um evento chamado ZuriHac foi realizado pela décima vez na pequena cidade suíça de Rapperswil. Desta vez, mais de quinhentos amant...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ZuriHac: praticando programação funcional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hsespb/blog/460537/">  Em junho deste ano, um evento chamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ZuriHac</a> foi realizado pela décima vez na pequena cidade suíça de Rapperswil.  Desta vez, mais de quinhentos amantes de Haskell se reuniram desde iniciantes até os pais fundadores da língua.  Embora os organizadores chamem esse evento de hackathon, ainda não é uma conferência ou hackathon no sentido clássico.  Seu formato é diferente da programação tradicional.  Aprendemos sobre o ZuriHac por uma coincidência de sorte, participamos e agora consideramos nosso dever contar sobre uma descoberta incomum! <br><br><img src="https://habrastorage.org/webt/f_/eh/jb/f_ehjbbaqkbwz4k4dv3m4vqbw-g.jpeg"><br><br><a name="habracut"></a><br><h3></h3><h4>  Sobre nós </h4><br>  Este artigo foi preparado por dois alunos do terceiro ano do programa de Matemática Aplicada e Ciência da Computação da Escola Superior de Economia - São Petersburgo: Vasily Alferov e Elizaveta Vasilenko.  A paixão pela programação funcional para nós dois começou com uma série de palestras de D.N. Moskvin no 2º ano da universidade.  Atualmente, Vasily participa do programa Google Summer of Code, no qual está envolvido na implementação de gráficos algébricos na linguagem Haskell, sob a orientação da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">equipe do</a> projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alga</a> .  Elizabeth aplicou as habilidades adquiridas de programação funcional no trabalho do curso dedicado à implementação do algoritmo anti-unificação com o uso subsequente na teoria dos tipos. <br><br><h3>  Formato do Evento </h3><br>  O público-alvo são os proprietários de projetos de código aberto, programadores que desejam participar de seu desenvolvimento, pesquisadores de programação funcional e apenas pessoas apaixonadas por Haskell.  Este ano, o local da HSR Hochschule für Technik Rapperswil University reuniu desenvolvedores de mais de cinquenta projetos de código aberto Haskell de todo o mundo para falar sobre seus produtos e interessar pessoas novas em seu desenvolvimento. <br><br><img src="https://habrastorage.org/webt/i2/2l/3t/i22l3txhqzeaeezkwfc9vazvwj4.jpeg"><br><br>  <i>Foto do Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ZuriHac</a></i> <br><br>  O esquema é muito simples: você precisa escrever algumas propostas com antecedência sobre o seu projeto e enviá-las aos organizadores, que publicarão informações sobre o seu projeto na página do evento.  Além disso, no primeiro dia, os autores dos projetos têm trinta segundos para dizer muito brevemente desde o estágio o que estão fazendo e o que precisa ser feito.  Em seguida, as pessoas interessadas pesquisam autores e perguntam em detalhes sobre as tarefas. <br><br>  Ainda não temos nossos próprios projetos abertos, mas queremos realmente contribuir com os existentes, por isso nos registramos como participantes regulares.  Durante três dias, trabalhamos com duas equipes de desenvolvimento.  Acontece que o estudo conjunto do código e da comunicação ao vivo torna a interação dos autores e colaboradores do projeto muito produtiva - no ZuriHac, conseguimos descobrir novas áreas para nós e ajudar duas equipes completamente diferentes, fechando a tarefa em cada um dos projetos. <br><br>  Além da prática valiosa, várias palestras e master classes também foram ministradas no ZuriHac.  Lembramos especialmente duas palestras.  No início, Andrei Mokhov, da Universidade de Newcastle, falou sobre os agentes aplicadores seletivos - uma classe de tipos que deve se tornar intermediária entre os agentes aplicadores e as mônadas.  Em outra palestra, um dos fundadores de Haskell, Simon Peyton Jones, falou sobre como a inferência de tipos funciona no compilador do GHC. <br><br><img src="https://habrastorage.org/webt/ja/6h/6a/ja6h6axidsbvnwkymvgrushrhje.jpeg"><br><br>  <i>Palestra de Simon Peyton Jones.</i>  <i>Foto do Twitter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ZuriHac</a></i> <br><br>  As master classes realizadas durante o hackathon foram divididas em três categorias, dependendo do nível de treinamento dos participantes.  As tarefas oferecidas aos participantes que ingressaram no desenvolvimento dos projetos também tiveram notas com níveis de dificuldade.  A comunidade pequena, mas amigável, de programadores funcionais tem o prazer de receber os recém-chegados às suas fileiras.  Para entender as palestras de Andrei Mokhov e Simon Peyton Jones, no entanto, o curso de programação funcional aprovado na universidade foi muito útil para nós. <br><br>  Para participantes comuns e autores do projeto, a inscrição para o evento é gratuita.  Solicitamos a participação no início de junho, após o qual fomos transferidos rapidamente da lista de espera para a lista de participantes confirmados. <br><br>  E agora vamos falar sobre projetos em cujo desenvolvimento participamos. <br><br><h3>  Pandoc </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pandoc</a> é um conversor universal de documentos de texto - de qualquer formato para qualquer.  Por exemplo, de docx para pdf, ou de Markdown para MediaWiki.  Seu autor, John MacFarlane, é professor de filosofia na Universidade da Califórnia, Berkeley.  Em geral, Pandoc é bastante famoso e alguns de nossos amigos ficaram surpresos ao saber que Pandoc estava escrito em Haskell. <br><br><img src="https://habrastorage.org/webt/kq/9s/z2/kq9sz2zt0d4gttu5nmjtkxa3-k8.png"><br><br>  <i>Lista de formatos de documento suportados pelo Pandoc.</i>  <i>O site também possui um gráfico inteiro, mas esta imagem não se encaixa no artigo.</i> <br><br>  Obviamente, o Pandoc não implementa a conversão direta para cada par de formatos.  Para suportar um conjunto tão amplo de transformações, é usada uma solução arquitetural padrão: primeiro, o documento inteiro é traduzido em uma representação intermediária interna especial e, em seguida, um documento em um formato diferente é gerado a partir dessa representação interna.  Os desenvolvedores chamam a representação interna de "AST", que significa Árvore de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sintaxe abstrata</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">árvore de sintaxe abstrata</a> .  Você pode olhar para a representação intermediária de maneira muito simples: para isso, você só precisa definir "nativo" como o formato de saída <br><br><pre><code class="haskell hljs">$ cat example.html &lt;h1&gt;<span class="hljs-type"><span class="hljs-type">Hello</span></span>, <span class="hljs-type"><span class="hljs-type">World</span></span>!&lt;/h1&gt; $ pandoc -f html -t native example.html [<span class="hljs-type"><span class="hljs-type">Header</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-string"><span class="hljs-string">"hello-world"</span></span>,[],[]) [<span class="hljs-type"><span class="hljs-type">Str</span></span> <span class="hljs-string"><span class="hljs-string">"Hello,"</span></span>,<span class="hljs-type"><span class="hljs-type">Space</span></span>,<span class="hljs-type"><span class="hljs-type">Str</span></span> <span class="hljs-string"><span class="hljs-string">"World!"</span></span>]]</code> </pre> <br>  Os leitores que trabalharam com Haskell pelo menos um pouco já podem assumir que Pandoc está escrito especificamente em Haskell: a saída desse comando é uma representação da estrutura interna de Pandoc como uma string, criada à semelhança de como geralmente é feita em Haskell, por exemplo, na biblioteca padrão. <br><br>  Então, aqui você pode ver que a representação interna é uma estrutura recursiva, em cada nó interno do qual existe uma lista.  Por exemplo, no nível mais alto, há uma lista de um elemento - o cabeçalho do primeiro nível com os atributos "hello-world", [], [].  Dentro deste cabeçalho, há uma lista da string "Hello", um espaço e a string "World!". <br><br>  Como você pode ver, a representação interna não é muito diferente do HTML.  É uma árvore, em que cada nó interno relata algumas informações sobre a formatação de seus descendentes e as folhas contêm o conteúdo real do documento. <br><br>  Se você descer para o nível de uma implementação específica, o tipo de dados para todo o documento será definido assim: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pandoc</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pandoc</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Meta</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Block</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br>  Aqui, Block é precisamente os picos internos mencionados acima e Meta é meta-informação sobre o documento, como título, data de criação, autores - isso é diferente para diferentes formatos, e Pandoc tenta salvar essas informações sempre que possível ao transferir de um formato para outro. <br><br>  Quase todos os construtores do tipo Bloco - por exemplo, Cabeçalho ou Pará (parágrafo) - usam atributos e uma lista de vértices de um nível inferior - Inline, como regra, como argumentos.  Por exemplo, Space ou Str são designers do tipo Inline, e a tag HTML também é convertida em seu Inline especial.  Não vemos nenhum motivo para dar uma definição completa desses tipos, no entanto, observamos que isso pode ser visto <a href="">aqui</a> . <br><br>  Curiosamente, o tipo Pandoc é um monóide.  Isso significa que existe algum tipo de documento vazio e que os documentos podem ser empilhados entre si.  É conveniente usar ao escrever leitores - você pode dividir um documento em partes com lógica arbitrária, analisar cada um individualmente e, em seguida, juntar tudo em um documento.  Nesse caso, as meta-informações serão coletadas de todas as partes do documento de uma só vez. <br><br>  Ao converter, digamos, de LaTeX para HTML, primeiro um módulo especial chamado LaTeXReader converte o documento de entrada em AST, depois outro módulo chamado HTMLWriter converte AST em HTML.  Graças a essa arquitetura, não é necessário escrever um número quadrático de conversões - basta escrever o Reader e o Writer para cada novo formato, e todos os pares possíveis de conversões serão automaticamente suportados. <br><br>  É claro que essa arquitetura também tem suas desvantagens, previstas há muito tempo por especialistas no campo da arquitetura de software.  O mais significativo é o custo de fazer alterações na árvore de sintaxe.  Se a alteração for séria o suficiente, você precisará alterar o código em todos os leitores e gravadores.  Por exemplo, um dos desafios enfrentados pelos desenvolvedores do Pandoc é oferecer suporte a formatos complexos de tabelas.  Agora, o Pandoc pode apenas nas tabelas mais simples, com um cabeçalho, colunas e valor em cada célula.  Digamos que o atributo colspan em HTML seja simplesmente ignorado.  Uma das razões para esse comportamento é a falta de um esquema de representação de tabela única em todos ou pelo menos muitos formatos - portanto, não está claro em que tabelas de formulário devem ser armazenadas na representação interna.  Porém, mesmo depois de escolher uma visualização específica, será necessário alterar absolutamente todos os leitores e gravadores que suportam o trabalho com tabelas. <br><br>  Haskell foi escolhido não apenas por um grande amor dos autores pela programação funcional.  Haskell é conhecido por suas poderosas capacidades de processamento de texto.  Um exemplo é a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parsec</a> - uma biblioteca que usa ativamente os conceitos de programação funcional - monóides, mônadas, functores aplicativos e alternativos - para escrever analisadores arbitrários.  O poder total do Parsec pode ser visto no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> do HaskellWiki, que analisa o analisador completo de uma simples linguagem de programação imperativa.  Obviamente, o Parsec também é usado ativamente no Pandoc. <br><br>  Em suma, as mônadas são usadas para análise sequencial quando uma chega primeiro e depois a outra.  Por exemplo, neste exemplo: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">whileParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Stmt</span></span> whileParser = whiteSpace &gt;&gt; statement</code> </pre> <br>  Primeiro você precisa considerar um espaço e depois a instrução - que também tem o tipo Parser Stmt. <br><br>  Os functores alternativos são usados ​​para reverter se a análise falhar.  Por exemplo <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">statement</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Stmt</span></span> statement = parens statement &lt;|&gt; sequenceOfStmt</code> </pre> <br>  Significa que você precisa tentar ler a instrução entre parênteses ou sequencialmente tentar ler várias instruções. <br><br>  Os functores aplicáveis ​​são usados ​​principalmente como atalhos para mônadas.  Por exemplo, deixe a função tok ler algum tipo de token (essa é a função real do LaTeXReader).  Vamos olhar para essa combinação <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">const</span></span> &lt;$&gt; tok &lt;*&gt; tok</code> </pre> <br>  Ela lerá dois tokens seguidos e retornará o primeiro. <br><br>  Haskell possui belos operadores simbólicos para todas essas classes, o que faz com que os leitores de programação pareçam arte ASCII.  Apenas admire esse código maravilhoso. <br><br>  Nossas tarefas estavam relacionadas ao LaTeXReader.  A tarefa de Vasily era oferecer suporte aos comandos \ mbox e \ hbox, úteis ao escrever pacotes no LaTeX.  Elizabeth foi responsável pelo suporte da equipe \ epigraph, que permite a execução de epígrafos nos documentos do LaTeX. <br><br><h3>  Hatrace </h3><br>  Em sistemas operacionais do tipo UNIX, a chamada do sistema ptrace é frequentemente implementada.  É útil na depuração e simulação de ambientes de programas, permitindo rastrear as chamadas do sistema que o programa faz.  Por exemplo, o utilitário strace muito útil usa ptrace dentro de si. <br><br>  O Hatrace é uma biblioteca que fornece uma interface para o ptrace em Haskell.  O fato é que o ptrace em si é muito sofisticado e é muito difícil usá-lo diretamente, especialmente a partir de linguagens funcionais. <br><br>  O Hatrace na inicialização é executado como strace e aceita argumentos semelhantes.  Sua diferença em relação ao strace é que também é uma biblioteca que fornece uma interface mais simples do que apenas o ptrace. <br><br>  O Hatrace já detectou um bug desagradável no compilador Haskell GHC - quando morto na hora errada, gera arquivos de objeto incorretos e não os recompila quando é reiniciado.  Os scripts nas chamadas do sistema tornaram possível reproduzir o erro de forma garantida em uma execução, quando assassinatos aleatórios reproduziam o erro em cerca de duas horas. <br><br>  Adicionamos interfaces de chamada do sistema à biblioteca - Elizabeth adicionou brk e Vasily adicionou mmap.  De acordo com os resultados de nosso trabalho, podemos usar com mais facilidade e precisão os argumentos dessas chamadas de sistema ao usar a biblioteca. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460537/">https://habr.com/ru/post/pt460537/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460525/index.html">Bem-vindo ao DINS IT NOITE em julho: controle de qualidade e JS</a></li>
<li><a href="../pt460527/index.html">Solução de problemas com pwnable.kr 06 - aleatório e 09 - erro</a></li>
<li><a href="../pt460531/index.html">Perversões curiosas do mundo da TI - 5</a></li>
<li><a href="../pt460533/index.html">Você teve a ideia de um produto de TI, o que vem a seguir</a></li>
<li><a href="../pt460535/index.html">Criando um contêiner Docker mínimo para aplicativos Go</a></li>
<li><a href="../pt460539/index.html">Tratamento de erros no Vue</a></li>
<li><a href="../pt460541/index.html">Procure contornos faciais em um milissegundo usando um conjunto de árvores de regressão</a></li>
<li><a href="../pt460543/index.html">Novas certificações para desenvolvedores da Cisco. Visão geral da certificação do setor</a></li>
<li><a href="../pt460547/index.html">Antiguidades: Psion 5MX e Vida Aposentada</a></li>
<li><a href="../pt460551/index.html">Portugal As melhores praias e mil startups por ano</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>