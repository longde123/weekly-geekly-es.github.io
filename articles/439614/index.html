<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèº üßíüèº üëêüèæ C√≥mo distinguir una buena reparaci√≥n de una mala, o c√≥mo en SRG hicimos una biblioteca Java multiproceso del analizador Tomit üì± üë©üèª‚Äçüíª üßí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo discutir√° c√≥mo integramos el analizador Tomita desarrollado por Yandex en nuestro sistema, lo convertimos en una biblioteca din√°mica, no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo distinguir una buena reparaci√≥n de una mala, o c√≥mo en SRG hicimos una biblioteca Java multiproceso del analizador Tomit</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/srg/blog/439614/">  Este art√≠culo discutir√° c√≥mo integramos el analizador Tomita desarrollado por Yandex en nuestro sistema, lo convertimos en una biblioteca din√°mica, nos hicimos amigos de Java, lo hicimos multiproceso y resolvimos el problema de la clasificaci√≥n de texto para la valoraci√≥n de bienes ra√≠ces con √©l. <br><br><img src="https://habrastorage.org/webt/vi/om/ub/viomubb37jryhlbwqzqucsl583s.jpeg"><br><a name="habracut"></a><br><h3>  Declaraci√≥n del problema. </h3><br>  En la evaluaci√≥n de bienes ra√≠ces, el an√°lisis de los anuncios de venta es de gran importancia.  Desde el anuncio puede obtener toda la informaci√≥n necesaria sobre la propiedad, incluida la informaci√≥n sobre el estado de reparaci√≥n en el apartamento.  Por lo general, esta informaci√≥n est√° contenida en el texto del anuncio.  Es muy importante en la evaluaci√≥n, ya que una buena reparaci√≥n puede agregar varios miles al precio por metro cuadrado. <br><br>  Por lo tanto, tenemos un texto de anuncio que debe clasificarse en una de las categor√≠as de acuerdo con el estado de reparaci√≥n en el apartamento (sin terminar, justo, promedio, bueno, excelente, exclusivo).  Sobre las reparaciones, un anuncio puede decir una o dos oraciones, unas pocas palabras o nada, por lo que no tiene sentido clasificar el texto por completo.  Debido a la especificidad del texto y a un conjunto limitado de palabras relacionadas con el contexto de reparaci√≥n, la √∫nica soluci√≥n razonable era extraer toda la informaci√≥n necesaria del texto y clasificarlo. <br><br><img src="https://habrastorage.org/webt/p9/jr/id/p9jrid1dluodkjquebvvr7yc5dq.png" alt="imagen"><br><br>  Ahora necesitamos aprender a extraer del texto todos los hechos sobre el estado de la decoraci√≥n.  Espec√≠ficamente, lo que se relaciona directamente con la reparaci√≥n, as√≠ como todo lo que indirectamente puede hablar sobre la condici√≥n del apartamento: la presencia de techos suspendidos, electrodom√©sticos empotrados, ventanas de pl√°stico, un jacuzzi, el uso de costosos materiales de acabado, etc. <br><br>  En este caso, necesitamos extraer solo informaci√≥n sobre reparaciones en el departamento en s√≠, porque la condici√≥n de las entradas, s√≥tanos y √°ticos no nos interesa.  Tambi√©n es necesario tener en cuenta el hecho de que el texto est√° escrito en lenguaje natural con todos sus errores, errores tipogr√°ficos, abreviaturas y otras caracter√≠sticas inherentes. Personalmente encontr√© tres deletreos de las palabras "lin√≥leo" y "laminado" y cinco deletreos de la palabra "final";  Algunas personas no entienden por qu√© se necesitan espacios entre las palabras, mientras que otras no han o√≠do hablar de comas.  Por lo tanto, el analizador con gram√°ticas contextualmente libres se convirti√≥ en la soluci√≥n m√°s simple y razonable. <br><br>  Por lo tanto, a medida que se tom√≥ la decisi√≥n, se form√≥ una segunda tarea grande e interesante: aprender a extraer toda la informaci√≥n suficiente y necesaria sobre la reparaci√≥n del anuncio, es decir, proporcionar un r√°pido an√°lisis sint√°ctico y morfol√≥gico del texto, que puede funcionar en paralelo bajo carga en modo biblioteca. <br><br><h3>  Pasar a la soluci√≥n </h3><br>  De los medios disponibles para extraer hechos del texto basado en gram√°ticas libres de contexto que pueden funcionar con el idioma ruso, llamamos nuestra atenci√≥n sobre Tomita-parser y la biblioteca Yagry en python.  Yagry fue rechazado de inmediato, ya que est√° escrito completamente en Python y apenas est√° bien optimizado.  Y Tomita inicialmente parec√≠a muy atractiva: ten√≠a documentaci√≥n detallada para el desarrollador y muchos ejemplos, C ++ promet√≠a una velocidad aceptable.  No fue dif√≠cil entender las reglas para escribir gram√°ticas, y la primera versi√≥n del clasificador con su uso estaba lista al d√≠a siguiente. <br><br>  Ejemplos de reglas de nuestras gram√°ticas que extraen adjetivos y verbos relacionados con el contexto de reparaci√≥n: <br><br><pre><code class="javascript hljs">RepairW -&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span>; StopWords -&gt; <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span>; Repair -&gt; RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Adj&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt;+ interp (Repair.AdjGroup {weight = <span class="hljs-number"><span class="hljs-number">0.5</span></span>}); Repair -&gt; Verb&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Adj&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt;* interp (Repair.Verb) RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; {weight = <span class="hljs-number"><span class="hljs-number">0.5</span></span>};</code> </pre> <br>  Reglas utilizadas para garantizar que no se recupere informaci√≥n sobre el estado de los espacios p√∫blicos: <br><br><pre> <code class="javascript hljs">Repair -&gt; StopWords Verb* Prep* Adj* RepairW; Repair -&gt; Adj+ RepairW Prep* StopWords;</code> </pre><br>  Por defecto, el peso de la regla es 1, asignando un peso menor a la regla, establecemos el orden de su ejecuci√≥n. <br><br>  Era un poco vergonzoso que solo la aplicaci√≥n de consola y una tonelada de c√≥digo C ++ se subieran al p√∫blico.  Pero la ventaja indudable fue la facilidad de uso y los r√°pidos resultados en los experimentos.  Por lo tanto, se decidi√≥ pensar en las posibles dificultades de introducirlo en nuestro sistema m√°s cerca de la implementaci√≥n misma. <br><br>  Casi de inmediato, fue posible lograr una extracci√≥n de alta calidad de casi toda la informaci√≥n necesaria sobre la reparaci√≥n.  "Casi", porque inicialmente algunas palabras no fueron extra√≠das bajo ninguna condici√≥n y gram√°ticas.  Sin embargo, fue dif√≠cil evaluar de inmediato la escala de este problema, cu√°nto puede afectar la calidad de la soluci√≥n al problema de clasificaci√≥n en su conjunto. <br><br>  Despu√©s de asegurarnos de que, en una primera aproximaci√≥n, Tomita nos proporciona la funcionalidad necesaria, nos dimos cuenta de que no es una opci√≥n usarla como una aplicaci√≥n de consola: en primer lugar, la aplicaci√≥n de consola result√≥ inestable y se bloque√≥ de vez en cuando por razones desconocidas, y en segundo lugar, no proporcionar√≠a la carga de an√°lisis requerida de varios millones de anuncios por d√≠a.  Por lo tanto, se hizo definitivamente claro de qu√© hacer una biblioteca. <br><br><h3>  C√≥mo hicimos de Tomitha una biblioteca multiproceso y nos hicimos amigos de Java </h3><br>  Nuestro sistema est√° escrito en Java, tomita-parser en C ++.  Necesit√°bamos poder llamar al an√°lisis de texto de anuncios desde Java. <br><br>  El desarrollo de enlaces java para Tomita-parser se puede dividir condicionalmente en dos componentes: la implementaci√≥n de la posibilidad de usar Tomita como una biblioteca compartida y, de hecho, escribir una capa de integraci√≥n con jvm.  La principal dificultad se refer√≠a a la primera parte.  La propia Tomita fue dise√±ada originalmente para su ejecuci√≥n en un proceso separado.  Se dedujo que los principales obst√°culos para utilizar el analizador en el proceso de solicitud fueron dos factores. <br><br><ol><li>  El intercambio de datos se llev√≥ a cabo a trav√©s de varios tipos de IO.  Se requer√≠a implementar la capacidad de intercambiar datos con el analizador a trav√©s de la memoria.  Adem√°s, era necesario hacer esto para minimizar el c√≥digo del analizador.  La arquitectura de Tomita sugiri√≥ una forma de implementar la lectura de documentos de entrada de la memoria como una implementaci√≥n de las interfaces CDocStreamBase y CDocListRetrieverBase.  Fue m√°s dif√≠cil con la salida: tuve que tocar el c√≥digo del generador xml. </li><li>  El segundo factor que surge del principio de "un analizador - un proceso" es el estado global, modificado a partir de diferentes instancias del analizador.  Si observa el archivo <a href="">src / util / generic / singleton.h</a> , puede ver el mecanismo para usar el estado compartido.  Es f√°cil imaginar que cuando se usan dos instancias de analizador en el mismo espacio de direcciones, se producir√° una condici√≥n de carrera.  Para no reescribir todo el analizador, se decidi√≥ modificar esta clase, reemplazando el estado global con un estado local relativo al hilo (thread_local).  En consecuencia, antes de cualquier llamada al analizador en el contenedor JTextMiner, establecemos estas variables thread_local en la instancia del analizador actual, despu√©s de lo cual el c√≥digo del analizador funciona con las direcciones de la instancia del analizador actual. </li></ol><br>  Despu√©s de eliminar estos dos factores, el analizador estaba disponible para su uso como biblioteca compartida desde cualquier entorno.  Escribir jni-binders y un java wrapper ya no era dif√≠cil. <br><br>  El analizador Tomita debe configurarse antes de su uso.  Los par√°metros de configuraci√≥n son similares a los utilizados al invocar la utilidad de la consola.  El an√°lisis en s√≠ consiste en llamar al m√©todo parse (), que recibe documentos para analizar y devuelve xml como una cadena con los resultados del analizador. <br><br>  La versi√≥n multiproceso de Tomita: TomitaPooledParser utiliza para analizar un grupo de objetos TomitaParser que se configuran de la misma manera.  Para el an√°lisis, se utiliza el primer analizador gratuito.  Dado que el n√∫mero de analizadores creados es igual al n√∫mero de subprocesos en el grupo, siempre habr√° al menos un analizador disponible para la tarea.  El m√©todo de an√°lisis analiza asincr√≥nicamente los documentos proporcionados en el primer analizador libre. <br><br>  Un ejemplo de llamar a la biblioteca Tomita desde Java: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> threadAmount number of threads in the pool * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> tomitaConfigFilename tomita config.proto * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> configDirname dir with configs: grammars, gazetteer, facttypes.proto */</span></span> tomitaPooledParser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TomitaPooledParser(threadAmount, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(configDirname), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String[]{tomitaConfigFilename}); Future&lt;String&gt; result = tomitaPooledParser.parse(documents); String response = result.get();</code> </pre><br>  En respuesta, una cadena XML con el resultado del an√°lisis. <br><br><h3>  Problemas que encontramos y c√≥mo los resolvimos </h3><br>  Entonces, la biblioteca est√° lista, comenzamos el servicio con su uso en una gran cantidad de datos y recordamos el problema de no extraer algunas palabras, d√°ndonos cuenta de que esto es muy cr√≠tico para nuestra tarea. <br><br>  Entre estas palabras estaban "prefiltrado", as√≠ como "hecho", "producido" y otros participios resumidos.  Es decir, las palabras que se encuentran en el anuncio con mucha frecuencia y, a veces, esta es la informaci√≥n √∫nica o muy importante sobre la reparaci√≥n.  La raz√≥n de este comportamiento: la palabra "prefiltrado" result√≥ ser una palabra con una morfolog√≠a desconocida, es decir, Tomita simplemente no puede determinar qu√© parte del discurso es, y, en consecuencia, no puede extraerlo.  Y para los participios abreviados, tuve que escribir una regla separada, y el problema se resolvi√≥, pero me llev√≥ un tiempo descubrir que estos son participios abreviados, para cuya extracci√≥n se necesita una regla especial.  Y para el final "final" sufrido, tuve que escribir una regla separada en cuanto a una palabra con una morfolog√≠a desconocida. <br><br>  Para resolver problemas de an√°lisis utilizando gram√°ticas, agregamos una palabra con morfolog√≠a desconocida al diccionario geogr√°fico: <br><br><pre> <code class="javascript hljs">TAuxDicArticle <span class="hljs-string"><span class="hljs-string">"adjNonExtracted"</span></span> { key = <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span> }</code> </pre><br>  Para participios abreviados usamos las caracter√≠sticas gramaticales de partcp, brev. <br><br>  Y ahora podemos escribir las reglas para estos casos: <br><br><pre> <code class="javascript hljs">Repair -&gt; RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Word&lt;gram=<span class="hljs-string"><span class="hljs-string">"partcp,brev"</span></span>,gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; interp (Repair.AdjGroup) {weight = <span class="hljs-number"><span class="hljs-number">0.5</span></span>}; Repair -&gt; Word&lt;kwtype=<span class="hljs-string"><span class="hljs-string">"adjNonExtracted"</span></span>,gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; interp (Repair.AdjGroup) RepairW&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt; Prep* Adj&lt;gnc-agr[<span class="hljs-number"><span class="hljs-number">1</span></span>]&gt;+;</code> </pre><br>  Y el √∫ltimo de los problemas que descubrimos: un servicio con uso multiproceso de la biblioteca Tomita produce procesos myStem que no se destruyen y despu√©s de un tiempo llenan toda la memoria.  La soluci√≥n m√°s f√°cil fue limitar el n√∫mero m√°ximo y m√≠nimo de subprocesos en Tomcat. <br><br><h3>  Algunas palabras sobre la clasificaci√≥n. </h3><br>  Entonces, ahora tenemos la informaci√≥n de reparaci√≥n extra√≠da del texto.  No fue dif√≠cil clasificarlo usando uno de los algoritmos de aumento de gradiente.  No nos detendremos aqu√≠ por mucho tiempo sobre este tema, se ha dicho y escrito mucho sobre esto, y no hemos hecho nada radicalmente nuevo en esta √°rea.  Solo dar√© los indicadores de calidad de la clasificaci√≥n que obtuvimos en las pruebas: <br><br><ul><li>  Precisi√≥n = 95% </li><li>  Puntuaci√≥n F1 = 93% </li></ul><br><h3>  Conclusi√≥n </h3><br>  El servicio implementado que usa Tomita-parser en modo biblioteca actualmente funciona de manera constante, analizando y clasificando varios millones de anuncios por d√≠a. <br><br><h3>  PS </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Todo el c√≥digo de Tomita</a> que escribimos como parte de este proyecto se carga en el github.  Espero que esto sea √∫til para alguien, y esta persona ahorrar√° un poco de tiempo en algo a√∫n m√°s √∫til. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439614/">https://habr.com/ru/post/439614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439604/index.html">¬øC√≥mo se organiza el c√≥digo de barras?</a></li>
<li><a href="../439606/index.html">Producci√≥n piloto de electr√≥nica por un precio m√≠nimo.</a></li>
<li><a href="../439608/index.html">Religi√≥n moderna: ¬øqu√© le dan Google, Facebook, Amazon y Apple a las personas?</a></li>
<li><a href="../439610/index.html">Como en mi veh√≠culo el√©ctrico Chevrolet Bolt, bajo garant√≠a, se reemplazaron dos m√≥dulos de bater√≠a y el tercero bajo monitoreo</a></li>
<li><a href="../439612/index.html">JavaScript robusto: persiguiendo un mito</a></li>
<li><a href="../439616/index.html">El resumen de proyectos de TI interesantes en Kickstarter No. 7</a></li>
<li><a href="../439618/index.html">PHP para principiantes. Conexi√≥n de archivo</a></li>
<li><a href="../439620/index.html">Comprensi√≥n de la asincron√≠a en JavaScript [Traducci√≥n de Sukhjinder Arora]</a></li>
<li><a href="../439624/index.html">¬øPor qu√© almacenar datos en √≥rbita?</a></li>
<li><a href="../439626/index.html">Experiencia desarrollando una aplicaci√≥n gratuita para coleccionistas OpenNumismat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>