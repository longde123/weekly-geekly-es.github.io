<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∑Ô∏è üëàüèª üë®üèª‚Äçüåæ IDisposable: que su madre no habl√≥ sobre la liberaci√≥n de recursos. Parte 1 üè¶ üé≤ ‚ú°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es una traducci√≥n de la primera parte del art√≠culo. El art√≠culo fue escrito en 2008. Despu√©s de 10 a√±os, casi pierde su relevancia. 
 Liberaci√≥n ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IDisposable: que su madre no habl√≥ sobre la liberaci√≥n de recursos. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414873/"><p>  Esta es una traducci√≥n de la primera parte del art√≠culo.  El art√≠culo fue escrito en 2008.  Despu√©s de 10 a√±os, casi pierde su relevancia. </p><br><h2 id="determinirovannoe-osvobozhdenie-resursov---neobhodimost">  Liberaci√≥n determinista de recursos: una necesidad </h2><br><p>  En el transcurso de m√°s de 20 a√±os de experiencia en codificaci√≥n, a veces desarroll√© mis propios idiomas para resolver problemas.  Var√≠an desde lenguajes simples e imperativos hasta expresiones regulares especializadas para √°rboles.  Al crear idiomas, hay muchas recomendaciones y algunas reglas simples no deben ser violadas.  Uno de ellos: </p><br><blockquote>  Nunca cree un lenguaje de excepci√≥n en el que no haya una liberaci√≥n determinista de recursos. </blockquote><p>  ¬øAdivina qu√© recomendaciones no sigue el tiempo de ejecuci√≥n de .NET y, como resultado, todos los lenguajes basados ‚Äã‚Äãen √©l? </p><a name="habracut"></a><br><p> La raz√≥n por la que existe esta regla es que la <strong>liberaci√≥n determinista de recursos es necesaria para crear programas compatibles</strong> .  La liberaci√≥n determinada de recursos proporciona un cierto punto en el que el programador est√° seguro de que el recurso se libera.  Hay dos formas de escribir programas confiables: el enfoque tradicional es liberar recursos lo antes posible y el enfoque moderno es liberar recursos por un tiempo indefinido.  La ventaja del enfoque moderno es que el programador no necesita liberar recursos expl√≠citamente.  La desventaja es que es mucho m√°s dif√≠cil escribir una aplicaci√≥n confiable, hay muchos errores sutiles.  Desafortunadamente, el tiempo de ejecuci√≥n de .NET se cre√≥ utilizando un enfoque moderno. </p><br><p> .NET admite la liberaci√≥n no determinista de recursos utilizando el m√©todo <code>Finalize</code> , que tiene un significado especial.  Para la liberaci√≥n determinista de recursos, Microsoft tambi√©n agreg√≥ la interfaz <code>IDisposable</code> (y otras clases, que discutiremos m√°s adelante).  Sin embargo, para el tiempo de ejecuci√≥n, <code>IDisposable</code> es una interfaz normal, como todos los dem√°s.  Este estado de "segunda tasa" crea algunas dificultades. </p><br><p>  En C #, la "versi√≥n determinista para los pobres" se puede implementar usando las <code>try</code> y <code>finally</code> o <code>using</code> (que es casi lo mismo).  Microsoft ha estado discutiendo durante mucho tiempo si hacer recuentos de enlaces o no, y me parece que se tom√≥ una decisi√≥n incorrecta.  Como resultado, para la liberaci√≥n determinista de recursos, debe usar el torpe <code>finally</code> \ <code>using</code> constructos o una llamada directa a <code>IDisposable.Dispose</code> , que est√° llena de errores.  Para un programador de C ++ que est√° acostumbrado a usar <code>shared_ptr&lt;T&gt;</code> ambas opciones no son atractivas.  (La √∫ltima oraci√≥n deja en claro d√≥nde el autor tiene esa relaci√≥n - <em>aprox.</em> </p><br><h2 id="idisposable">  IDisposable </h2><br><p>  <code>IDisposable</code> es una soluci√≥n para la liberaci√≥n determinista de recursos ofrecidos por Misoftro.  Uno es para los siguientes casos: </p><br><ul><li>  Cualquier tipo que <em>posea</em> recursos gestionados ( <code>IDisposable</code> ).  Un tipo debe necesariamente <strong>poseer</strong> , es decir, administrar el tiempo de vida, los recursos y no solo referirse a ellos. </li><li>  Cualquier tipo que posea recursos no administrados. </li><li>  Cualquier tipo que posea recursos administrados y no administrados. </li><li>  Cualquier tipo heredado de una clase que implemente <code>IDisposable</code> .  No recomiendo heredar de clases que poseen recursos no administrados.  Mejor usar un archivo adjunto. </li></ul><br><p>  <code>IDisposable</code> ayuda a liberar recursos de manera determinista, pero tiene sus propios problemas. </p><br><h2 id="slozhnosti-idisposable---udobstvo-ispolzovaniya">  Dificultades IDisposable - Usabilidad </h2><br><p>  <code>IDisposable</code> objetos <code>IDisposable</code> son <code>IDisposable</code> usar bastante engorroso.  El uso de un objeto debe estar envuelto en una construcci√≥n de <code>using</code> .  La mala noticia es que C # no permite el <code>using</code> con un tipo que no implementa <code>IDisposable</code> .  Por lo tanto, el programador debe consultar la documentaci√≥n cada vez para comprender si es necesario escribir <code>using</code> , o simplemente escribir <code>using</code> todas partes, y luego borrar donde jura el compilador. </p><br><p>  C ++ administrado es mucho mejor en este sentido.  Admite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sem√°ntica de pila para tipos de referencia</a> , que funciona como <code>using</code> solo para tipos cuando sea necesario.  C # podr√≠a beneficiarse de la capacidad de escribir <code>using</code> cualquier tipo. </p><br><p>  Este problema se puede resolver con.  herramientas de an√°lisis de c√≥digo.  Para empeorar las cosas, si olvida usar, el programa puede pasar las pruebas, pero se bloquea mientras trabaja "en los campos". </p><br><p>  En lugar de contar enlaces, <code>IDisposable</code> tiene otro problema: determinar el propietario.  Cuando en C ++ la √∫ltima copia de <code>shared_ptr&lt;T&gt;</code> queda fuera de alcance, los recursos se liberan de inmediato, sin necesidad de pensar qui√©n deber√≠a liberar.  <code>IDisposable</code> por el contrario, obliga al programador a determinar qui√©n "posee" el objeto y es responsable de liberarlo.  A veces, la propiedad es obvia: cuando un objeto encapsula a otro e implementa <code>IDisposable</code> , por lo tanto, es responsable de la liberaci√≥n de los objetos secundarios.  A veces, la vida √∫til de un objeto est√° determinada por un bloque de c√≥digo, y el programador simplemente usa el <code>using</code> alrededor de este bloque.  Sin embargo, hay muchos casos en los que se puede usar un objeto en varios lugares y su vida √∫til es dif√≠cil de determinar (aunque en este caso el recuento de referencia estar√≠a bien). </p><br><h2 id="slozhnosti-idisposable---obratnaya-sovmestimost">  Dificultades IDisposable - Compatibilidad con versiones anteriores </h2><br><p>  Agregar <code>IDisposable</code> a la clase y eliminar <code>IDisposable</code> de la lista de interfaces implementadas es un cambio radical.  El c√≥digo de cliente que no espera <code>IDisposable</code> no liberar√° recursos si agrega <code>IDisposable</code> a una de sus clases aprobadas por referencia a una interfaz o clase base. </p><br><p>  Microsoft mismo se encontr√≥ con este problema.  <code>IEnumerator</code> no se hereda de <code>IDisposable</code> e <code>IEnumerator&lt;T&gt;</code> hereda.  Si pasa <code>IEnumerator&lt;T&gt;</code> c√≥digo que recibe <code>IEnumerator</code> , no se llamar√° a <code>Dispose</code> . </p><br><p>  Este no es el fin del mundo, pero da una esencia secundaria de <code>IDisposable</code> . </p><br><h2 id="slozhnosti-idisposable---proektirovanie-ierarhii-klassov">  Dificultades que no se pueden desechar: dise√±o de una jerarqu√≠a de clases </h2><br><p>  El mayor inconveniente causado por <code>IDisposable</code> en el campo del dise√±o de jerarqu√≠a es que cada clase e interfaz debe predecir si <code>IDisposable</code> ser√° necesario para sus descendientes. </p><br><p>  Si la interfaz no hereda <code>IDisposable</code> , pero las clases que implementan la interfaz tambi√©n implementan <code>IDisposable</code> , entonces el c√≥digo final ignorar√° la versi√≥n determinista o debe verificar si el objeto implementa la interfaz <code>IDisposable</code> .  Pero para esto, no ser√° posible usar el constructor de uso y tendr√° que escribir un <code>try</code> feo y <code>finally</code> . </p><br><p>  En resumen, <code>IDisposable</code> complica el desarrollo de software reutilizable.  La raz√≥n clave es la violaci√≥n de uno de los principios del dise√±o orientado a objetos: la separaci√≥n de la interfaz y la implementaci√≥n.  La liberaci√≥n de recursos debe ser un detalle de implementaci√≥n.  Microsoft decidi√≥ hacer de la liberaci√≥n determinista de recursos una interfaz de segunda clase. </p><br><p>  Una de las soluciones no tan hermosas es hacer que todas las clases implementen <code>IDisposable</code> , pero en la gran mayor√≠a de las clases, <code>IDisposable.Dispose</code> no har√° nada.  Pero esto no es demasiado hermoso. </p><br><p>  Otra dificultad con <code>IDisposable</code> son las colecciones.  Algunas colecciones "poseen" objetos en ellos, y otras no.  Sin embargo, las colecciones en s√≠ no implementan <code>IDisposable</code> .  El programador debe recordar llamar a <code>IDisposable.Dispose</code> en los objetos de la colecci√≥n, o crear sus propios descendientes de las clases de colecci√≥n que implementan <code>IDisposable</code> para significar la propiedad. </p><br><h2 id="slozhnosti-idisposable---dopolnitelnoe-oshibochnoe-sostoyanie">  Dificultades IDisposable - estado "err√≥neo" adicional </h2><br><p>  <code>IDisposable</code> se puede llamar expl√≠citamente en cualquier momento, independientemente de la vida √∫til del objeto.  Es decir, se agrega un estado "liberado" a cada objeto, en el que se recomienda lanzar una <code>ObjectDisposedException</code> .  Verificar el estado y lanzar excepciones es un gasto adicional. </p><br><p>  En lugar de verificar cada estornudo, es mejor considerar acceder al objeto en el estado "liberado" como "comportamiento indefinido" como una llamada a la memoria liberada. </p><br><h2 id="slozhnosti-idisposable---net-garantiy">  Dificultades IDisposable - sin garant√≠as </h2><br><p>  <code>IDisposable</code> es solo una interfaz.  Una clase que implementa <code>IDisposable</code> <strong>admite el</strong> lanzamiento determinista, pero no lo <strong>garantiza</strong> .  Para el c√≥digo del cliente, est√° bien no llamar a <code>Dispose</code> .  Por lo tanto, una clase que implementa <code>IDisposable</code> debe admitir la <code>IDisposable</code> tanto determinista como no determinista. </p><br><h2 id="slozhnosti-idisposable---slozhnaya-realizaciya">  Complejidades IDisposable - Implementaci√≥n compleja </h2><br><p>  Microsoft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ofrece un patr√≥n</a> para implementar <code>IDisposable</code> .  (Anteriormente hab√≠a un patr√≥n generalmente terrible, pero relativamente recientemente, despu√©s de la aparici√≥n de .NET 4, la documentaci√≥n se corrigi√≥, incluso bajo la influencia de este art√≠culo. En las ediciones antiguas de libros .NET, puede encontrar la versi√≥n anterior. - <em>aprox.</em> ) </p><br><ul><li>  <code>IDisposable.Dispose</code> no se puede llamar en absoluto, por lo que la clase debe incluir un finalizador para liberar recursos. </li><li>  <code>IDisposable.Dispose</code> se puede llamar varias veces y deber√≠a funcionar sin efectos secundarios visibles.  Por lo tanto, es necesario agregar verificaci√≥n si el m√©todo ya se ha llamado o no. </li><li>  Los finalizadores se llaman en un hilo separado y se pueden llamar antes de <code>IDisposable.Dispose</code> .  El uso de <code>GC.SuppressFinalize</code> para evitar tales "razas". </li></ul><br><p>  Adem√°s </p><br><ul><li>  Se llama a los finalizadores, incluidos los objetos que generan una excepci√≥n en el constructor.  Por lo tanto, el c√≥digo de lanzamiento debe funcionar con objetos parcialmente inicializados. </li><li>  Implementar un <code>IDisposable</code> en una clase heredada de <code>CriticalFinalizerObject</code> requiere construcciones no triviales.  <code>void Dispose(bool disposing)</code> es un m√©todo viral y debe ejecutarse en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Regi√≥n de ejecuci√≥n</a> <code>RuntimeHelpers.PrepareMethod</code> , que requiere una llamada a <code>RuntimeHelpers.PrepareMethod</code> . </li></ul><br><h2 id="slozhnosti-idisposable---ne-podhodit-dlya-logiki-zaversheniya">  Dificultades IDisposable - No es adecuado para la l√≥gica de finalizaci√≥n </h2><br><p>  Apagar un objeto: a menudo ocurre en programas en subprocesos paralelos o asincr√≥nicos.  Por ejemplo, una clase usa un hilo separado y quiere completarlo usando <code>ManualResetEvent</code> .  Esto se puede hacer en <code>IDisposable.Dispose</code> , pero puede provocar un error si se llama al c√≥digo en el finalizador. </p><br><p>  Para comprender las limitaciones en el finalizador, debe comprender c√≥mo funciona el recolector de basura.  A continuaci√≥n se muestra un diagrama simplificado en el que se omiten muchos detalles relacionados con generaciones, enlaces d√©biles, reactivaci√≥n de objetos, recolecci√≥n de basura de fondo, etc. </p><br><p>  El recolector de basura .NET utiliza el algoritmo de marcado y barrido.  En general, la l√≥gica se ve as√≠: </p><br><ol><li>  Pausa todos los hilos. </li><li>  Tome todos los objetos ra√≠z: variables en la pila, campos est√°ticos, objetos <code>GCHandle</code> , cola de finalizaci√≥n.  En el caso de descargar el dominio de la aplicaci√≥n (terminaci√≥n del programa), se considera que las variables en la pila y los campos est√°ticos no son ra√≠ces. </li><li>  Revise recursivamente todos los enlaces de los objetos y m√°rquelos como "accesibles". </li><li>  Revise todos los dem√°s objetos que tienen destructores (finalizadores), declare que son accesibles y col√≥quelos en la cola de finalizaci√≥n ( <code>GC.SuppressFinalize</code> le dice a GC que no haga esto).  Los objetos se ponen en cola en un orden impredecible. </li></ol><br><p>  En segundo plano, una secuencia (o varias) de finalizaci√≥n funciona: </p><br><ol><li>  Toma un objeto de la cola y comienza su finalizador.  Es posible ejecutar varios finalizadores de diferentes objetos al mismo tiempo. </li><li>  El objeto se elimina de la cola y, si nadie m√°s se refiere a √©l, se borrar√° en la pr√≥xima recolecci√≥n de basura. </li></ol><br><p>  Ahora debe quedar claro por qu√© es imposible acceder a los recursos administrados desde el finalizador: no sabe en qu√© orden se llaman los finalizadores.  Incluso llamar a <code>IDisposable.Dispose</code> otro objeto del finalizador puede provocar un error, ya que el c√≥digo de liberaci√≥n de recursos puede funcionar en otro hilo. </p><br><p>  Existen algunas excepciones cuando puede acceder a los recursos administrados desde un finalizador: </p><br><ol><li>  <code>CriticalFinalizerObject</code> finalizaci√≥n de los objetos heredados de <code>CriticalFinalizerObject</code> se realiza <strong>despu√©s de la</strong> finalizaci√≥n de los objetos no heredados de esta clase.  Esto significa que puede llamar a <code>ManualResetEvent</code> desde el finalizador hasta que la clase se herede de <code>CriticalFinalizerObject</code> </li><li>  Algunos objetos y m√©todos son especiales, como la consola y algunos m√©todos de subprocesos.  Se pueden llamar desde finalizadores incluso si el programa finaliza. </li></ol><br><p>  En el caso general, es mejor no acceder a los recursos gestionados de los finalizadores.  Sin embargo, la l√≥gica de finalizaci√≥n es necesaria para el software no trivial.  En <code>Windows.Forms</code> contiene la l√≥gica de finalizaci√≥n en el m√©todo <code>Application.Exit</code> .  Cuando desarrolle su biblioteca de componentes, lo mejor que puede hacer es completar la l√≥gica de finalizaci√≥n con <code>IDisposable</code> .  Terminaci√≥n normal en caso de llamar a <code>IDisposable.Dispose</code> . De lo contrario, <code>IDisposable.Dispose</code> emergencia. </p><br><p>  Microsoft tambi√©n se top√≥ con este problema.  La clase <code>StreamWriter</code> posee un objeto <code>Stream</code> (dependiendo de los par√°metros del constructor en la √∫ltima versi√≥n - <em>aprox. Por.</em> ).  <code>StreamWriter.Close</code> el b√∫fer y llama a <code>Stream.Close</code> (tambi√©n ocurre si se <code>using</code> - <em>aprox. Por.</em> ).  Si <code>StreamWriter</code> no <code>StreamWriter</code> cerrado, el b√∫fer no se vac√≠a y se pierde el chat de datos.  Microsoft simplemente no redefini√≥ el finalizador, "resolviendo" el problema de finalizaci√≥n.  Un gran ejemplo de la necesidad de completar la l√≥gica. </p><br><h2 id="rekomenduyu-pochitat">  Recomiendo leer </h2><br><p>  Mucha informaci√≥n sobre los componentes internos de .NET en este art√≠culo proviene del CLR de Jeffrey Richter a trav√©s de C #.  Si a√∫n no lo tiene, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥mprelo</a> .  En serio  Este es el conocimiento necesario para cualquier programador de C #. </p><br><h2 id="zaklyuchenie-ot-perevodchika">  Conclusi√≥n del traductor </h2><br><p>  La mayor√≠a de los programadores .NET nunca se encontrar√°n con los problemas descritos en este art√≠culo.  .NET evolucionar√° para aumentar el nivel de abstracci√≥n y reducir la necesidad de "hacer malabares" con recursos no administrados.  Sin embargo, este art√≠culo es √∫til porque describe los detalles profundos de cosas simples y su impacto en el dise√±o del c√≥digo. </p><br><p>  La siguiente parte ser√° una discusi√≥n detallada de c√≥mo trabajar con recursos administrados y no administrados en .NET con un mont√≥n de ejemplos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es414873/">https://habr.com/ru/post/es414873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es414861/index.html">Modelado de t√∫nel - Versi√≥n 1.0</a></li>
<li><a href="../es414865/index.html">iMaterialist Furniture Challenge o 50 tonos de sillas</a></li>
<li><a href="../es414867/index.html">ThinkingHome.Migrator: migraci√≥n versionada del esquema de base de datos en la plataforma .NET Core</a></li>
<li><a href="../es414869/index.html">Marcos desaparecidos</a></li>
<li><a href="../es414871/index.html">La tormenta de polvo en Marte alcanz√≥ la escala planetaria, incluso la curiosidad se vio afectada</a></li>
<li><a href="../es414875/index.html">La integraci√≥n de contenedores Kubernetes reemplaza a Docker listo para la producci√≥n</a></li>
<li><a href="../es414877/index.html">Una lente inusual para una c√°mara normal o c√≥mo dejar de pensar en el enfoque.</a></li>
<li><a href="../es414879/index.html">¬øPor qu√© 2 extrusoras en una impresora 3D?</a></li>
<li><a href="../es414881/index.html">Un poco de backstage VK</a></li>
<li><a href="../es414883/index.html">Los recuerdos sonaron de una nueva manera: la BBC actualiz√≥ el archivo de sonido del proyecto RemArc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>