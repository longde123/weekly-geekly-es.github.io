<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§úüèø ‚ñ´Ô∏è üßóüèæ Cinzel - (n√£o exatamente) uma nova abordagem para o desenvolvimento da l√≥gica digital üê™ üë©üèΩ‚Äçüé§ üë©‚Äçüë©‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Com o desenvolvimento da microeletr√¥nica, os projetos de RTL tornaram-se cada vez mais. A reutiliza√ß√£o do c√≥digo verilog √© um grande inconveniente, me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cinzel - (n√£o exatamente) uma nova abordagem para o desenvolvimento da l√≥gica digital</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419413/"><p><img src="https://habrastorage.org/webt/ka/wc/b5/kawcb52amqtfs9chlivqku8sj-a.jpeg"></p><br><p>  Com o desenvolvimento da microeletr√¥nica, os projetos de RTL tornaram-se cada vez mais.  A reutiliza√ß√£o do c√≥digo verilog √© um grande inconveniente, mesmo com gerar, macros e chips de sistema verilog.  O Chisel, no entanto, permite aplicar toda a pot√™ncia da programa√ß√£o de objetos e funcional ao desenvolvimento de rtl, que √© uma etapa muito esperada que pode encher os pulm√µes dos desenvolvedores de ASIC e FPGA com ar fresco. </p><br><p>  Este artigo fornecer√° uma breve vis√£o geral das principais funcionalidades e considerar√° alguns casos de uso do usu√°rio. Tamb√©m falaremos sobre as defici√™ncias desse idioma.  No futuro, se o t√≥pico for interessante, continuaremos o artigo em tutoriais mais detalhados. </p><a name="habracut"></a><br><h3 id="sistemnye-trebovaniya">  Requisitos de sistema </h3><br><ul><li>  n√≠vel de base scala </li><li>  verilog e os princ√≠pios b√°sicos da constru√ß√£o de projetos digitais. </li><li>  mantenha a documenta√ß√£o do cinzel √† m√£o </li></ul><br><p>  Vou tentar entender o b√°sico do cinzel usando exemplos simples, mas se algo n√£o estiver claro, voc√™ pode dar uma olhada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Quanto √† scala, esta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">folha de dicas</a> pode ajudar a dar um mergulho r√°pido. </p><br><p>  Existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> semelhante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para o cinzel</a> . </p><br><p>  O c√≥digo completo do artigo (na forma de um projeto scala sbt) pode ser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">encontrado aqui</a> . </p><br><h3 id="prostoy-schetchik">  Contador simples </h3><br><p>  Como o nome indica, o cinzel 'Construindo hardware em uma linguagem incorporada da scala' √© uma linguagem de descri√ß√£o de hardware criada sobre a scala. </p><br><p>  Resumidamente, sobre como tudo funciona: um gr√°fico de hardware √© constru√≠do a partir da descri√ß√£o rtl no cinzel, que, por sua vez, se transforma em uma descri√ß√£o intermedi√°ria na linguagem firrtl e, depois disso, o interpretador de back-end incorporado √© gerado a partir do firrtl verilog. </p><br><p>  Vejamos duas implementa√ß√µes de um contador simples. </p><br><p>  verilog: </p><br><pre><code class="plaintext hljs">module SimpleCounter #( parameter WIDTH = 8 )( input clk, input reset, input wire enable, output wire [WIDTH-1:0] out ); reg [WIDTH-1:0] counter; assign out = counter; always @(posedge clk) if (reset) begin counter &lt;= {(WIDTH){1'b0}}; end else if (enable) begin counter &lt;= counter + 1; end endmodule</code> </pre> <br><p>  cinzel: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.<span class="hljs-type"><span class="hljs-type">W</span></span>)) io.out &lt;&gt; counter when(io.enable) { counter := counter + <span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span> } }</code> </pre> <br><p>  Um pouco sobre o cinzel: </p><br><ul><li>  <code>Module</code> - container para descri√ß√£o do m√≥dulo rtl </li><li>  <code>Bundle</code> √© uma estrutura de dados no cinzel, usada principalmente para definir interfaces. </li><li>  <code>io</code> - vari√°vel para determinar portas </li><li>  <code>Bool</code> - tipo de dados, sinal simples de bit √∫nico </li><li>  <code>UInt(width: Width)</code> - n√∫mero inteiro sem sinal, o construtor aceita a profundidade do bit do sinal como entrada. </li><li>  <code>RegInit[T &lt;: Data](init: T)</code> √© um construtor de registradores, que recebe um valor de redefini√ß√£o na entrada e tem o mesmo tipo de dados. </li><li>  <code>&lt;&gt;</code> - operador de conex√£o de sinal universal </li><li>  <code>when(cond: =&gt; Bool) { /*...*/ }</code> - o <code>if</code> anal√≥gico no verilog </li></ul><br><p>  Falaremos sobre qual verilog gera form√£o um pouco mais tarde.  Agora basta comparar esses dois modelos.  Como voc√™ pode ver, n√£o h√° men√ß√£o de sinais <code>clk</code> e <code>reset</code> no cinzel.  O fato √© que o cinzel adiciona esses sinais ao m√≥dulo por padr√£o.  O valor de redefini√ß√£o para o registrador do <code>counter</code> √© <code>RegInit</code> construtor <code>RegInit</code> registrador com a redefini√ß√£o do <code>RegInit</code> .  O cinzel tem suporte para m√≥dulos com muitos sinais de clock, mas um pouco mais tarde. </p><br><h3 id="schetchik-chut-poslozhnee">  O balc√£o √© um pouco mais complicado </h3><br><p>  Vamos prosseguir e complicar um pouco a tarefa, por exemplo - criaremos um contador multicanal com um par√¢metro de entrada na forma de uma sequ√™ncia de bits para cada canal. </p><br><p>  Vamos come√ßar agora com a vers√£o do cinzel </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiChannelCounter</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">] = </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">(32, 16, 8, 4</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enable = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(width.sum.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOut</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">UInt</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> right = width.dropRight(width.length - i).sum <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.out(right + width(i) - <span class="hljs-number"><span class="hljs-number">1</span></span>, right) } }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counters: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>] = width.map(x =&gt; <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SimpleCounter</span></span>(x)) ) io.out &lt;&gt; util.<span class="hljs-type"><span class="hljs-type">Cat</span></span>(counters.map(_.io.out)) width.indices.foreach { i =&gt; counters(i).io.enable &lt;&gt; io.enable(i) } }</code> </pre> <br><p>  Um pouco sobre scala: </p><br><ul><li>  <code>width: Seq[Int]</code> - par√¢metro de entrada para o construtor da classe <code>MultiChannelCounter</code> , possui o tipo <code>Seq[Int]</code> - uma sequ√™ncia com elementos inteiros. </li><li>  <code>Seq</code> √© um dos tipos de cole√ß√µes em scala com uma sequ√™ncia bem definida de elementos. </li><li>  <code>.map</code> √© uma fun√ß√£o familiar para cole√ß√µes para todos, capaz de converter uma cole√ß√£o em outra devido √† mesma opera√ß√£o em cada elemento. No nosso caso, uma sequ√™ncia de valores inteiros se transforma em uma sequ√™ncia de <code>SimpleCounter</code> com a profundidade de bits correspondente. </li></ul><br><p>  Um pouco sobre o cinzel: </p><br><ul><li>  <code>Vec[T &lt;: Data](gen: T, n: Int): Vec[T]</code> - tipo de dados cinzel √© um an√°logo da matriz. </li><li>  <code>Module[T &lt;: BaseModule](bc: =&gt; T): T</code> √© o m√©todo de inv√≥lucro necess√°rio para m√≥dulos instanciados. </li><li>  <code>util.Cat[T &lt;: Bits](r: Seq[T]): UInt</code> - fun√ß√£o de concatena√ß√£o, anal√≥gico <code>{1'b1, 2'b01, 4'h0}</code> no verilog </li></ul><br><p>  Preste aten√ß√£o √†s portas: <br>  <code>enable</code> - implantado j√° no <code>Vec[Bool]</code> *, grosso modo, em uma matriz de sinais de um bit, um para cada canal, foi poss√≠vel criar <code>UInt(width.length.W)</code> . <br>  <code>out</code> - expandido para a soma das larguras de todos os nossos canais. </p><br><p>  Os <code>counters</code> vari√°veis ‚Äã‚Äãs√£o uma matriz dos nossos contadores.  Conectamos o sinal de <code>enable</code> de cada contador √† porta de entrada correspondente e combinamos todos <code>out</code> sinais de <code>out</code> em um usando a fun√ß√£o <code>util.Cat</code> incorporada e a encaminhamos para a sa√≠da. </p><br><p>  Tamb√©m observamos a fun√ß√£o <code>getOut(i: Int)</code> - essa fun√ß√£o calcula e retorna o intervalo de bits no sinal de <code>out</code> para o <code>i</code> - <code>i</code> canal.  Ser√° muito √∫til em trabalhos futuros com esse contador.  Implementar algo assim no verilog n√£o funcionar√° </p><br><p>  * <code>Vec</code> n√£o deve ser confundido com <code>Vector</code> , o primeiro √© uma matriz de dados no cinzel, o segundo √© uma cole√ß√£o no scala. </p><br><p>  Vamos agora tentar escrever este m√≥dulo no verilog, por conveni√™ncia, mesmo no systemVerilog. </p><br><p>  Depois de pensar, cheguei a essa op√ß√£o (provavelmente n√£o √© a √∫nica verdadeira e a mais ideal, mas voc√™ sempre pode sugerir sua implementa√ß√£o nos coment√°rios). </p><br><div class="spoiler">  <b class="spoiler_title">verilog</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module MultiChannelCounter #( parameter TOTAL = 4, parameter integer WIDTH_SEQ [TOTAL] = {32, 16, 8, 4} )(clk, reset, enable, out); localparam OUT_WIDTH = get_sum(TOTAL, WIDTH_SEQ); input clk; input reset; input wire [TOTAL - 1 : 0] enable; output wire [OUT_WIDTH - 1 :0] out; genvar j; generate for(j = 0; j &lt; TOTAL; j = j + 1) begin : counter_generation localparam OUT_INDEX = get_sum(j, WIDTH_SEQ); SimpleCounter #( WIDTH_SEQ[j] ) SimpleCounter_unit ( .clk(clk), .reset(reset), .enable(enable[j]), .out(out[OUT_INDEX + WIDTH_SEQ[j] - 1: OUT_INDEX]) ); end endgenerate function automatic integer get_sum; input integer array_width; input integer array [TOTAL]; integer counter = 0; integer i; begin for(i = 0; i &lt; array_width; i = i + 1) counter = counter + array[i]; get_sum = counter; end endfunction endmodule</code> </pre> </div></div><br><p>  J√° parece muito mais impressionante.  Mas e se formos mais longe e mexer na popular interface wishbone com acesso a registros. </p><br><h3 id="bundle-interfeysy">  Interfaces de pacotes </h3><br><p>  O Wishbone √© um pequeno barramento semelhante ao AMBA APB, usado principalmente para n√∫cleos IP de c√≥digo aberto. </p><br><p>  Mais detalhes no wiki: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://ru.wikipedia.org/wiki/Wishbone</a> </p><br><p>  Porque  O cinzel nos fornece cont√™ineres de dados do tipo <code>Bundle</code> ; faz sentido agrupar o barramento em um cont√™iner que possa ser usado posteriormente em qualquer projeto de cinzel. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMasterSignals</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, gotTag: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = false</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> adr = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(addrWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dat_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>(dataWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stb = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> we = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cyc = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sel = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">UInt</span></span>((dataWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_master = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ack_slave = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_master: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> tag_slave: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gotTag) <span class="hljs-type"><span class="hljs-type">Some</span></span>(<span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>())) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbTransaction</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = cyc &amp;&amp; stb <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbWrite</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; we <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wbRead</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Bool</span></span> = wbTransaction &amp;&amp; !we <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMasterSignals.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth, dataWidth, gotTag).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Um pouco sobre scala: </p><br><ul><li>  <code>Option</code> - um inv√≥lucro de dados opcional no scala que pode ser um elemento ou <code>None</code> , <code>Option[UInt]</code> √© <code>Some(UInt(/*...*/))</code> ou <code>None</code> , √∫til ao parametrizar sinais. </li></ul><br><p>  Parece nada de anormal.  Apenas uma descri√ß√£o da interface pelo assistente, com exce√ß√£o de alguns sinais e m√©todos: </p><br><p>  <code>tag_master</code> e <code>tag_slave</code> s√£o sinais opcionais de uso geral no protocolo wishbone, vamos v√™-los se o par√¢metro <code>gotTag</code> for <code>true</code> . </p><br><p>  <code>wbTransaction</code> , <code>wbWrite</code> , <code>wbRead</code> - funciona para simplificar o trabalho com o barramento. </p><br><p>  <code>cloneType</code> - m√©todo de clonagem de tipo necess√°rio para todas as classes <code>[T &lt;: Bundle]</code> parametrizadas </p><br><p>  Mas tamb√©m precisamos de uma interface escrava, vamos ver como ela pode ser implementada. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlave</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-type"><span class="hljs-type">Flipped</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneSlave.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  O m√©todo <code>Flipped</code> , como voc√™ pode imaginar pelo nome, inverte a interface e agora nossa interface do assistente se transformou em escrava, adicionamos a mesma classe ao assistente. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneMaster</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 32, tagWidht: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params"> = 0</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMasterSignals(addrWidth , dataWidth, tagWidht) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloneType</span></span></span></span>: wishboneMaster.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, tagWidht).asInstanceOf[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>] }</code> </pre> <br><p>  Bem, √© isso, a interface est√° pronta.  Mas antes de escrever um manipulador, vamos ver como podemos usar essas interfaces, caso precisemos fazer uma troca ou algo com um grande conjunto de interfaces de wishbone. </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneCrossbarIo</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">n: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, addrWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, dataWidth: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bundle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> slaves = <span class="hljs-type"><span class="hljs-type">Vec</span></span>(n, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> master = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneMaster(addrWidth, dataWidth, <span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WBCrossBar</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">WishboneCrossbarIo</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>)) io.master &lt;&gt; io.slaves(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>  Este √© um pequeno espa√ßo em branco para o comutador.  √â conveniente declarar uma interface do tipo <code>Vec[wishboneSlave]</code> e voc√™ pode conectar as interfaces com o mesmo operador <code>&lt;&gt;</code> .  Chisel chips √∫teis quando se trata de gerenciar um grande conjunto de sinais. </p><br><h3 id="universalnyy-kontroller-shiny">  Controlador de barramento universal </h3><br><p>  Como mencionado anteriormente sobre o poder da programa√ß√£o funcional e de objetos, tentaremos aplic√°-lo.  Al√©m disso, falaremos sobre a implementa√ß√£o do controlador de barramento universal wishbone na forma de <code>trait</code> , ser√° algum tipo de combina√ß√£o para qualquer m√≥dulo com o barramento <code>wishboneSlave</code> , para o m√≥dulo, voc√™ s√≥ precisa definir um cart√£o de mem√≥ria e misturar o controlador de <code>trait</code> durante a gera√ß√£o. </p><br><h4 id="realizaciya">  Implementa√ß√£o </h4><br><div class="spoiler">  <b class="spoiler_title">Para quem ainda est√° entusiasmado</b> <div class="spoiler_text"><p>  Vamos seguir para a implementa√ß√£o do manipulador.  Ser√° simples e responder√° imediatamente a transa√ß√µes √∫nicas; em caso de queda do pool de endere√ßos, retorne zero. </p><br><p>  Vamos analisar em partes: </p><br><ul><li><p>  cada transa√ß√£o precisa ser respondida com reconhecimento </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave = <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } wb_ack &lt;&gt; io.wb.ack_slave</code> </pre> <br></li><li>  Respondemos √† leitura com dados <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// getWidth   when(io.wb.wbRead) { wb_dat := MuxCase(default = 0.U, Seq( (io.wb.addr === ADDR_1) -&gt; data_1, (io.wb.addr === ADDR_3) -&gt; data_2, (io.wb.addr === ADDR_3) -&gt; data_2 )) } wb_dat &lt;&gt; io.wb.dat_slave</span></span></code> </pre> <br><ul><li>  <code>MuxCase[T &lt;: Data] (default: T, mapping: Seq[(Bool, T)]): T</code> √© o esquema de coordena√ß√£o interno do tipo de <code>case</code> no verilog *. </li></ul></li></ul><br><p>  Como seria no verilog: </p><br><pre> <code class="plaintext hljs"> always @(posedge clock) if(reset) wb_dat_o &lt;= 0; else if(wb_read) case (wb_adr_i) `ADDR_1 : wb_dat_o &lt;= data_1; `ADDR_2 : wb_dat_o &lt;= data_2; `ADDR_3 : wb_dat_o &lt;= data_3; default : wb_dat_o &lt;= 0; endcase }</code> </pre> <br><p>  * Em geral, neste caso, este √© um pequeno truque para parametrizar, no cinzel, existe um design padr√£o que √© melhor usar se, escreva algo mais simples. </p><br><pre> <code class="scala hljs">switch(x) { is(value1) { <span class="hljs-comment"><span class="hljs-comment">// ... } is(value2) { // ... } }</span></span></code> </pre> <br><p>  Bem, o registro </p><br><pre> <code class="scala hljs"> when(io.wb.wbWrite) { data_4 := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(io.wb.addr === <span class="hljs-type"><span class="hljs-type">ADDR_4</span></span>, io.wb.dat_master, data_4) }</code> </pre> <br><ul><li>  <code>Mux[T &lt;: Data](cond: Bool, con: T, alt: T): T</code> - multiplexador regular </li></ul><br><p>  Incorporamos algo semelhante ao nosso contador multicanal, desligamos os registros para gerenciamento de canais e um chap√©u.  Mas aqui est√° pr√≥ximo do controlador de barramento WB universal para o qual transferiremos um cart√£o de mem√≥ria desse tipo: </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Para tal tarefa, a <code>trait</code> nos ajudar√° - algo como mixins em Sala.  A principal tarefa ser√° fazer com que o <code>readMemMap: [Int, Data]</code> pare√ßa com <code>Seq( -&gt; )</code> , e tamb√©m seria bom se voc√™ pudesse transferir o endere√ßo base e a matriz de dados para dentro do cart√£o de mem√≥ria </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  O que ser√° expandido para algo semelhante, onde WB_DAT_WIDTH √© a largura dos dados em bytes </p><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_0</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_1</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_2</span></span>, <span class="hljs-type"><span class="hljs-type">ADDR_1_BASE</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> * (<span class="hljs-type"><span class="hljs-type">WB_DAT_WIDHT</span></span>)-&gt; <span class="hljs-type"><span class="hljs-type">DATA_SEQ_3</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> <span class="hljs-type"><span class="hljs-type">ADDR_2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">DATA_2</span></span> <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> )</code> </pre> <br><p>  Para implementar isso, escrevemos uma fun√ß√£o de convers√£o de <code>Map[Int, Any]</code> para <code>Seq[(Bool, UInt)]</code> .  Voc√™ precisa usar o padr√£o matem√°tico de scala. </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = memMap.flatMap { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addr, data) =&gt; data <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">UInt</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Seq</span></span>((io.wb.adr === addr.<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; a) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> a: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">UInt</span></span>] =&gt; a.map(x =&gt; (io.wb.adr === (addr + io.wb.dat_slave.getWidth / <span class="hljs-number"><span class="hljs-number">8</span></span>).<span class="hljs-type"><span class="hljs-type">U</span></span>) -&gt; x) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"WRONG MEM MAP!!!"</span></span>) } }.toSeq</code> </pre> <br><p>  Finalmente, nossa caracter√≠stica ficar√° assim: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io : wishboneSlave <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedReadMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(readMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> parsedWriteMap: <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = parseMemMap(writeMemMap) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_ack = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wb_dat = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(io.wb.dat_slave.getWidth.<span class="hljs-type"><span class="hljs-type">W</span></span>)) when(io.wb.wbTransaction) { wb_ack := <span class="hljs-literal"><span class="hljs-literal">true</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> }.otherwise { wb_ack := <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span> } when(io.wb.wbRead) { wb_dat := <span class="hljs-type"><span class="hljs-type">MuxCase</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">default</span></span> = <span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>, parsedReadMap) } when(io.wb.wbWrite) { parsedWriteMap.foreach { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span>(addrMatched, data) =&gt; data := <span class="hljs-type"><span class="hljs-type">Mux</span></span>(addrMatched, io.wb.dat_master, data) } } wb_dat &lt;&gt; io.wb.dat_slave wb_ack &lt;&gt; io.wb.ack_slave <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseMemMap</span></span></span></span>(memMap: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Any</span></span>]): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[(<span class="hljs-type"><span class="hljs-type">Bool</span></span>, <span class="hljs-type"><span class="hljs-type">UInt</span></span>)] = { <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span>} }</code> </pre> <br><p>  Um pouco sobre scala: </p><br><ul><li>  <code>io , readMemMap, writeMemMap</code> s√£o os campos abstratos de nossa <code>trait</code> 'a, que devem ser definidos na classe na qual a misturaremos. </li></ul></div></div><br><h4 id="kak-im-polzovatsya">  Como us√°-lo </h4><br><p>  Para misturar nossa <code>trait</code> com o m√≥dulo, v√°rias condi√ß√µes devem ser atendidas: </p><br><ul><li>  <code>io</code> deve herdar da classe <code>wishboneSlave</code> </li><li>  precisa declarar dois cart√µes de mem√≥ria como <code>readMemMap</code> e <code>writeMemMap</code> </li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">BASE</span></span> = <span class="hljs-number"><span class="hljs-number">0x11A00000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">OUT</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">S_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000200</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">H_EN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000300</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbAddrWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbDataWidth = <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> wbTagWidth = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> width = <span class="hljs-type"><span class="hljs-type">Seq</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishboneSlave(wbAddrWidth, wbDataWidth, wbTagWidth) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hardwareEnable: <span class="hljs-type"><span class="hljs-type">Vec</span></span>[<span class="hljs-type"><span class="hljs-type">Bool</span></span>] = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Vec</span></span>(width.length, <span class="hljs-type"><span class="hljs-type">Bool</span></span>())) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> counter = <span class="hljs-type"><span class="hljs-type">Module</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MultiChannelCounter</span></span>(width)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> softwareEnable = <span class="hljs-type"><span class="hljs-type">RegInit</span></span>(<span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-type"><span class="hljs-type">U</span></span>(width.length.<span class="hljs-type"><span class="hljs-type">W</span></span>)) width.indices.foreach(i =&gt; counter.io.enable(i) := io.hardwareEnable(i) &amp;&amp; softwareEnable(i)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> readMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">OUT</span></span> -&gt; width.indices.map(counter.io.getOut), <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable, <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">H_EN</span></span> -&gt; io.hardwareEnable.asUInt ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> writeMemMap = <span class="hljs-type"><span class="hljs-type">Map</span></span>( <span class="hljs-type"><span class="hljs-type">BASE</span></span> + <span class="hljs-type"><span class="hljs-type">S_EN</span></span> -&gt; softwareEnable ) }</code> </pre> <br><p>  N√≥s criamos o registro <code>softwareEnable</code> , ele √© adicionado a 'e' pelo sinal de entrada <code>hardwareEnable</code> e vai ativar o <code>counter[MultiChannelCounter]</code> . </p><br><p>  Declaramos dois cart√µes de mem√≥ria para leitura e grava√ß√£o: <code>readMemMap</code> <code>writeMemMap</code> , para obter mais detalhes sobre a estrutura, consulte o cap√≠tulo acima. <br>  No cart√£o de mem√≥ria de leitura, transferimos o valor do contador de cada canal *, <code>softwareEnable</code> e <code>hardwareEnable</code> .  E para o registro, damos apenas o registro <code>softwareEnable</code> . </p><br><p>  * <code>width.indices.map(counter.io.getOut)</code> - um design estranho, vamos analis√°-lo em partes. </p><br><ul><li>  <code>width.indices</code> - retornar√° uma matriz com √≠ndices de elementos, ou seja,  se <code>width.length == 4</code> , <code>width.indices = {0, 1, 2, 3}</code> </li><li>  <code>{0, 1, 2, 3}.map(counter.io.getOut)</code> - fornece algo parecido com isto: <br> <code>{ counter.io.getOut(0), counter.io.getOut(1), /*...*/ }</code> </li> </ul><br><p>  Agora, para qualquer m√≥dulo no cinzel, podemos declarar cart√µes de mem√≥ria para leitura e grava√ß√£o e simplesmente conectar nosso controlador de barramento universal wishbone ao gerar, algo como isto: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishbone_multicahnnel_counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WishboneMultiChannelCounter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wishboneSlaveDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">countersDriver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">Driver</span></span>.execute(<span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-string"><span class="hljs-string">"-td"</span></span>, <span class="hljs-string"><span class="hljs-string">"./src/generated"</span></span>), () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> wishbone_multicahnnel_counter ) }</code> </pre> <br><p>  <code>wishboneSlaveDriver</code> - esse √© exatamente o mix de caracter√≠sticas que descrevemos no spoiler. </p><br><p>  Obviamente, esta vers√£o do controlador universal est√° longe de ser final, mas √© grosseira pelo contr√°rio.  Seu principal objetivo √© demonstrar uma das abordagens poss√≠veis para o desenvolvimento de rtl no cinzel.  Com todos os recursos do scala, essas abordagens podem ser muito maiores, para que cada desenvolvedor tenha seu pr√≥prio campo de criatividade.  Verdade, especialmente em nenhum lugar para ser especialmente inspirado, exceto: </p><br><ul><li>  a biblioteca de utilit√°rios de cinzel nativa, sobre a qual um pouco mais adiante, voc√™ pode ver a heran√ßa de m√≥dulos e interfaces </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/freechipsproject/rocket-chip</a> - o kernel do risc-v √© totalmente implementado no cinzel, desde que voc√™ conhe√ßa muito bem o scala, para iniciantes sem meio litro, como eles dizem, levar√° muito tempo para entender.  n√£o h√° documenta√ß√£o oficial sobre a estrutura interna do projeto. </li></ul><br><h3 id="multiclockdomain">  MultiClockDomain </h3><br><p>  E se quisermos controlar manualmente o rel√≥gio e redefinir os sinais no cinzel.  At√© recentemente, isso n√£o podia ser feito, mas com uma das vers√µes mais recentes, o suporte <code>withClock {}</code> , <code>withReset {}</code> e <code>withClockAndReset {}</code> .  Vejamos um exemplo: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DoubleClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Module</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> out = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClock = <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) regClock &lt;&gt; io.out <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClock(io.clockB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><ul><li>  <code>regClock</code> - um registro que ser√° cronometrado pelo sinal de <code>clock</code> padr√£o e redefinido pelo <code>reset</code> padr√£o </li><li>  <code>regClockB</code> - o mesmo registro √© cronometrado, voc√™ adivinhou, pelo sinal <code>io.clockB</code> , mas a redefini√ß√£o padr√£o ser√° usada. </li></ul><br><p>  Se queremos remover completamente o <code>clock</code> padr√£o e <code>reset</code> sinais, podemos usar o recurso experimental - <code>RawModule</code> (m√≥dulo sem sinais padr√£o de rel√≥gio e redefini√ß√£o, todos ter√£o que ser controlados manualmente).  Um exemplo: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiClockModule</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> io = <span class="hljs-type"><span class="hljs-type">IO</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Bundle</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clockB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Clock</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetA = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> resetB = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> in = <span class="hljs-type"><span class="hljs-type">Input</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outA = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> outB = <span class="hljs-type"><span class="hljs-type">Output</span></span>(<span class="hljs-type"><span class="hljs-type">Bool</span></span>()) }) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockA = withClockAndReset(io.clockA, io.resetA) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockA &lt;&gt; io.outA <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> regClockB = withClockAndReset (io.clockB, io.resetB) { <span class="hljs-type"><span class="hljs-type">RegNext</span></span>(io.in, <span class="hljs-literal"><span class="hljs-literal">false</span></span>.<span class="hljs-type"><span class="hljs-type">B</span></span>) } regClockB &lt;&gt; io.outB }</code> </pre> <br><h3 id="utils-biblioteka">  Biblioteca Utils </h3><br><p>  Os agrad√°veis ‚Äã‚Äãb√¥nus do cinzel n√£o param por a√≠.  Seus criadores trabalharam duro e escreveram uma biblioteca pequena, mas muito √∫til, de pequenas interfaces, m√≥dulos, fun√ß√µes.  Curiosamente, n√£o h√° descri√ß√£o da biblioteca no wiki, mas voc√™ pode ver o link da folha de dicas para o qual, no in√≠cio (h√° duas √∫ltimas se√ß√µes) </p><br><p>  Interfaces: </p><br><ul><li>  <code>DecoupledIO</code> √© a interface pronta / v√°lida comumente usada. <br>  <code>DecoupledIO(UInt(32.W))</code> - conter√° sinais: <br> <code>val ready = Input(Bool())</code> <br> <code>val valid = Output(Bool())</code> <br> <code>val data = Output(UInt(32.W))</code> </li> <li>  <code>ValidIO</code> - o mesmo que o <code>DecoupledIO</code> apenas sem <code>ready</code> </li></ul><br><p>  M√≥dulos: </p><br><ul><li>  <code>Queue</code> - o m√≥dulo FIFO s√≠ncrono √© uma coisa muito √∫til.A interface parece <br>  <code>val enq: DecoupledIO[T]</code> - <code>DecoupledIO</code> invertido <br>  <code>val deq: DecoupledIO[T]</code> - <code>DecoupledIO</code> regular <br>  <code>val count: UInt</code> - quantidade de dados na fila </li><li>  M√≥dulo <code>Pipe</code> - delay, insere o en√©simo n√∫mero de fatias de registro </li><li>  <code>Arbiter</code> - √°rbitro nas interfaces <code>DecoupledIO</code> , tem muitas subesp√©cies diferentes no tipo de arbitragem <br>  <code>val in: Vec[DecoupledIO[T]]</code> - conjunto de interfaces de entrada <br> <code>val out: DecoupledIO[T]</code> <br>  <code>val chosen: UInt</code> - mostra o canal selecionado </li></ul><br><p>  At√© onde voc√™ pode entender da discuss√£o sobre o github - nos planos globais, h√° uma extens√£o significativa dessa biblioteca de m√≥dulos: como FIFO ass√≠ncrono, LSFSR, divisores de freq√º√™ncia, modelos de PLL para FPGA;  v√°rias interfaces;  controladores para eles e muito mais. </p><br><h3 id="chisel-io-teseters">  Cinzel io-teseters </h3><br><p>  A possibilidade de testar no cinzel deve ser mencionada, no momento existem duas maneiras de testar isso: </p><br><ul><li>  <code>peekPokeTesters</code> - testes puramente de simula√ß√£o que testam a l√≥gica do seu design </li><li><p>  <code>hardwareIOTeseters</code> j√° √© mais interessante, pois  com essa abordagem, voc√™ obter√° um banco de tesets gerado com testes que voc√™ escreveu no cinzel e, mesmo se voc√™ tiver verilator, receber√° uma linha do tempo. </p><br><p>  Mas at√© agora, a abordagem para o teste n√£o foi finalizada e a discuss√£o ainda est√° em andamento.  No futuro, provavelmente uma ferramenta universal aparecer√°, para testes e testes tamb√©m ser√° poss√≠vel escrever no cinzel.  Mas, por enquanto, voc√™ pode ver o que j√° est√° l√° e como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">us√°-lo aqui</a> . </p><br></li></ul><br><h3 id="nedostatki-chisel">  Desvantagens do cinzel </h3><br><p>  Isso n√£o quer dizer que o cinzel √© uma ferramenta universal e que todos devem mudar para ele.  Ele, como talvez todos os projetos na fase de desenvolvimento, tem suas desvantagens, que vale a pena mencionar para completar o quadro. </p><br><p>  A primeira e talvez mais importante desvantagem √© a falta de descargas ass√≠ncronas.  Pesado o suficiente, mas pode ser resolvido de v√°rias maneiras, e um deles √© o script no topo do verilog, que transforma a redefini√ß√£o s√≠ncrona em ass√≠ncrona.  Isso √© f√°cil de fazer porque  todas as constru√ß√µes no verilog gerado com <code>always</code> bastante uniformes. </p><br><p>  A segunda desvantagem, segundo muitos, √© a ilegibilidade do verilog gerado e, como conseq√º√™ncia, a complica√ß√£o da depura√ß√£o.  Mas vamos dar uma olhada no c√≥digo gerado a partir do exemplo com um contador simples </p><br><div class="spoiler">  <b class="spoiler_title">verilog gerado</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">`ifdef RANDOMIZE_GARBAGE_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_INVALID_ASSIGN `define RANDOMIZE `endif `ifdef RANDOMIZE_REG_INIT `define RANDOMIZE `endif `ifdef RANDOMIZE_MEM_INIT `define RANDOMIZE `endif module SimpleCounter( input clock, input reset, input io_enable, output [7:0] io_out ); reg [7:0] counter; reg [31:0] _RAND_0; wire [8:0] _T_7; wire [7:0] _T_8; wire [7:0] _GEN_0; assign _T_7 = counter + 8'h1; assign _T_8 = _T_7[7:0]; assign _GEN_0 = io_enable ? _T_8 : counter; assign io_out = counter; `ifdef RANDOMIZE integer initvar; initial begin `ifndef verilator #0.002 begin end `endif `ifdef RANDOMIZE_REG_INIT _RAND_0 = {1{$random}}; counter = _RAND_0[7:0]; `endif // RANDOMIZE_REG_INIT end `endif // RANDOMIZE always @(posedge clock) begin if (reset) begin counter &lt;= 8'h0; end else begin if (io_enable) begin counter &lt;= _T_8; end end end endmodule</code> </pre> </div></div><br><p>  √Ä primeira vista, o verilog gerado pode se afastar, mesmo em um design de tamanho m√©dio, mas vamos dar uma olhada. </p><br><ul><li>  RANDOMIZE define - (pode ser √∫til ao testar com cinz√©is) - geralmente s√£o in√∫teis, mas n√£o interferem particularmente </li><li>  Como vemos o nome de nossas portas, e o registro √© preservado </li><li>  _GEN_0 √© uma vari√°vel in√∫til para n√≥s, mas necess√°ria para que o firrtl ao int√©rprete gere o verilog.  Tamb√©m n√£o prestamos aten√ß√£o a isso. </li><li>  Restam _T_7 e _T_8, toda a l√≥gica combinat√≥ria no verilog gerado ser√° apresentada passo a passo na forma das vari√°veis ‚Äã‚Äã_T. </li></ul><br><p>  Mais importante, todas as portas, registradores e fios necess√°rios para depura√ß√£o mant√™m seus nomes do cinzel.  E se voc√™ olhar n√£o apenas para o verilog, mas tamb√©m para o cinzel, em breve o processo de depura√ß√£o ser√° t√£o f√°cil quanto o verilog puro. </p><br><h3 id="zaklyuchenie">  Conclus√£o </h3><br><p>  Nas realidades modernas, o desenvolvimento de RTL, seja asic ou fpga fora do ambiente acad√™mico, deixou de usar apenas c√≥digo verilog manuscrito puro para um ou outro tipo de script de gera√ß√£o, seja um pequeno script tcl ou um IDE inteiro com v√°rios recursos. </p><br><p>  Cinzelar, por sua vez, √© o desenvolvimento l√≥gico de linguagens para o desenvolvimento e teste da l√≥gica digital.  Suponha que, nesta fase, ele esteja longe de ser perfeito, mas j√° seja capaz de oferecer oportunidades para as quais voc√™ pode aturar suas defici√™ncias.      ,                   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419413/">https://habr.com/ru/post/pt419413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419401/index.html">Interfaces de linha de comando Java: picocli</a></li>
<li><a href="../pt419405/index.html">Como est√£o as coisas com o IPv6 ou o que dificulta a transi√ß√£o para uma nova vers√£o do protocolo - discuta a situa√ß√£o</a></li>
<li><a href="../pt419407/index.html">Uma an√°lise detalhada da correspond√™ncia do Dota 2 entre o OpenAI e as pessoas no formato 5x5. Pessoas perdidas</a></li>
<li><a href="../pt419409/index.html">Novas NUCs da Intel baseadas em processadores Coffee Lake</a></li>
<li><a href="../pt419411/index.html">Sobre o fogo em um arranha-c√©u. Cinema e realidade</a></li>
<li><a href="../pt419415/index.html">Mattermost e Powershell - grande pot√™ncia ou pequena automa√ß√£o em casa</a></li>
<li><a href="../pt419417/index.html">GDPR: mapeamento de dados ou como os clientes encontram laptops h√° muito esquecidos</a></li>
<li><a href="../pt419419/index.html">Testes autom√°ticos de interface do usu√°rio: como fazer isso n√£o vale a pena</a></li>
<li><a href="../pt419423/index.html">Nos √© prometido um v√≠deo em tempo real, sem frisos e contra√ß√µes musculares</a></li>
<li><a href="../pt419425/index.html">Semana de Seguran√ßa 29. Hacking Reddit, uma carteira para roteadores de criptomoeda e MikroTik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>