<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🚒 🍿 📪 t1ha = Fast Positive Hash 🈁 🤽🏾 🌕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hampir seperti fungsi hash portabel 64-bit tercepat dengan kualitas yang layak. 


 Ini adalah terjemahan dari artikel asli oleh Leonid Yuriev . 
 Ali...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>t1ha = Fast Positive Hash</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439156/"><p>  Hampir seperti fungsi hash portabel 64-bit tercepat dengan kualitas yang layak. </p><br><p> Ini adalah terjemahan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel</a> asli oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Leonid Yuriev</a> . </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Alih-alih Penafian</b> <div class="spoiler_text"><p>  Saya akan menghilangkan definisi fungsi hash bersama dengan daftar terperinci dari properti dan persyaratan untuk aplikasi kriptografi mereka, dan menganggap bahwa pembaca memiliki pengetahuan minimum yang diperlukan atau akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membacanya</a> .  Perlu juga dicatat, bahwa selanjutnya saya akan berbicara tentang fungsi hash non-kriptografi (tidak cocok untuk kriptografi), kecuali dinyatakan sebaliknya. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Dangkal</b> <div class="spoiler_text"><p>  Hashing digunakan dalam banyak algoritma, dan hampir selalu diperlukan pemrosesan data yang paling efisien (cepat), bersama dengan level minimum kualitas hashing tertentu.  Di sini istilah "kualitas" berarti, pertama-tama, semacam "keacakan" (stochasticity) dalam kaitannya dengan data awal.  Agak jarang persyaratan tambahan diberlakukan seperti resistensi untuk generasi tabrakan yang disengaja atau ireversibilitas. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">Menjadi sedikit lebih membosankan</b> <div class="spoiler_text"><p>  Untuk kejelasan, perlu untuk mendefinisikan konsep "kualitas" dari fungsi hash dan persyaratan lainnya dengan sedikit lebih detail: <br>  Kualitas dasar dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">efek longsoran</a> : mengubah satu atau lebih bit yang sewenang-wenang dalam set data sumber yang berubah-ubah menyebabkan setiap bit dari hasil berubah dengan probabilitas ½. </p><br><ul><li>  Irreversibilitas atau resistensi preimage pertama: ketidakmungkinan mendapatkan data asli atau bit individu dari hasil hash. </li><li>  Resistensi terhadap tumbukan orde pertama dan / atau resistensi pra-gambar kedua: kesulitan menemukan / menyesuaikan set data asli untuk mendapatkan hasil atau bagian tertentu, termasuk ketika set data awal diketahui. </li><li>  Resistensi terhadap tumbukan orde kedua: kesulitan menemukan / menyesuaikan dua set data yang berbeda yang akan memberikan hasil yang sama atau kecocokan dari bagian yang signifikan. </li></ul></div></div><br><p>  Menghilangkan kutipan panjang dari matematika yang mendasarinya, dapat diringkas: </p><br><ul><li>  Memuaskan semua persyaratan di atas sambil memastikan kinerja tinggi adalah masalah yang cukup sulit, pemecahan yang akan memberi kita fungsi hash kriptografi yang baik.  Tetapi kami belum akan melakukan ini. </li><li>  Memberikan kualitas dasar memerlukan sejumlah besar operasi ALU.  Sederhananya, kualitas selalu berkompromi dengan kecepatan. </li><li>  Mendapatkan hasil berkualitas tinggi dengan lebar bit lebih besar dari lebar bit operasi ALU membutuhkan lebih dari beberapa kali lipat dalam jumlah pencampuran, dan karenanya operasi ALU dasar. </li><li>  Secara umum, <em>membuat fungsi hash cepat melibatkan mencapai kompromi tertimbang antara kecepatan, kualitas dan bitness hasil</em> . </li></ul><br><p>  Oleh karena itu, saya dapat mengatakan bahwa <strong>t1ha</strong> muncul sebagai hasil dari pencarian kompromi antara kualitas dan kecepatan, pada saat yang sama memperhitungkan kemampuan prosesor modern dan metode yang sudah ditemukan (kombinasi aritmatika-logis) dari pencampuran dan penyebaran dependensi ( efek longsoran salju). </p><br><p>  Versi dasar <strong>t1ha</strong> adalah salah satu fungsi hash portabel tercepat untuk membangun tabel hash dan aplikasi terkait lainnya.  Versi dasar <strong>t1ha</strong> difokuskan pada arsitektur little-endian 64-bit, mengambil nilai garam (biji) 64-bit dan menghasilkan hasil 64-bit, yang mencakup penguatan oleh panjang kunci dan benih.  Perlu dicatat bahwa <strong>t1ha</strong> sengaja dirancang untuk mengembalikan 0 untuk data input nol (kunci ukuran nol dan nol seed). </p><br><div class="spoiler">  <b class="spoiler_title">Menjawab pertanyaan paling populer</b> <div class="spoiler_text"><p>  <strong>Operasi 64-bit</strong> : Mungkin perlu dicatat bahwa operasi 64-bit yang memberikan kecepatan dan kualitas tanpa mengganggu portabilitas.  Bahkan, semakin lebar kapasitas digit operasi aritmatika, semakin banyak efek longsor yang mereka hasilkan dan semakin baik mereka mencampur data.  Selain itu, pemrosesan data, semua hal lain dianggap sama, tentu saja lebih cepat dengan 8 byte daripada 4. Di sisi lain, operasi 64-bit sebenarnya tersedia secara native pada banyak prosesor modern, dan dapat lebih kurang memadai diterjemahkan ke dalam 32- yang sedikit.  Semua opsi lain, termasuk operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SIMD</a> , memaksa kami untuk sangat mengorbankan portabilitas dan / atau kecepatan pada platform non-asli. </p><br><p>  <strong>Hasil 64-bit</strong> : Untuk membangun tabel hash, dalam banyak kasus, hasil lebar bit yang lebih kecil sudah cukup.  Bahkan 32 bit mungkin lebih dari cukup.  Namun, ketika menggunakan operasi 64-bit, hasil 64-bit datang secara alami.  Pada saat yang sama, hasil hash 64-bit yang cukup berkualitas tinggi memungkinkan Anda untuk dengan cepat melakukan perbandingan untuk non-kesetaraan, dan dengan akurasi yang baik untuk membandingkan untuk kesetaraan. </p><br><p>  "Keajaiban" penggantian perbandingan di atas bisa tampak tidak jelas dan tidak perlu, atau dapat <strong>meningkatkan kecepatan hashing dengan urutan besarnya</strong> hanya dengan cara lokalitas data, yaitu lebih sedikit polusi cache CPU.  Sederhananya, orang dapat membangun struktur tabel hash sedemikian rupa sehingga nilai hash yang dihitung berdampingan (dikemas dalam garis cache).  CPU kemudian hanya akan mengambil data nyata jika nilai hash cocok.  Dan dalam hal ini, <em>64-bit dari t1ha memungkinkan untuk mendapatkan hasil terbaik</em> .  Yang sedang berkata, 128 bit tidak akan memberikan keuntungan lagi, sementara mengambil kurang dari 64 bit selalu mungkin. </p><br><p>  <strong>Perbandingan dengan HighwayHash</strong> : Saya memiliki perasaan campur aduk tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek tidak resmi ini oleh karyawan Google</a> . </p><br><ol><li>  Di satu sisi, ia memiliki kode yang baik dan implementasi teknis yang sangat baik.  Di sisi lain, <em>HighwayHash</em> diposisikan sebagai kuat secara kriptografi (setidaknya sama dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SipHash</a> ).  Di dalam HighwayHash ada beberapa manipulasi yang memungkinkan kita berharap bahwa hasilnya tidak akan buruk.  Namun, tidak ada bukti yang memungkinkan kami untuk mengatakannya dengan andal.  Bukti "kekuatan" yang diberikan turun ke hasil tes statistik, tetapi tanpa kemampuan untuk mereproduksi mereka (pada satu titik saya bahkan membiarkan diri saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komentar yang</a> agak berlebihan). </li><li>  HighwayHash sangat cepat hanya pada x86_64 dengan AVX2 atau SSE41.  Tidakkah lebih mudah menggunakan akselerasi AES-NI atau SHA saja? </li></ol><br><p>  Jika semuanya berjalan dengan baik, opsi tambahan akan ditambahkan ke t1ha suite (terutama untuk bitness hasil) dan dioptimalkan untuk E2K.  Dengan ini saya ingin menutup topik perbandingan dengan HighwayHash. </p></div></div><br><hr><br><h2 id="quality">  Kualitas </h2><br><p>  Mengevaluasi kualitas fungsi hash dalam semua aspek bisa sangat sulit.  Ini dapat dilakukan baik secara analitik atau dengan menerapkan berbagai tes statistik.  Sayangnya, pendekatan analitis tidak terlalu efektif untuk mengevaluasi fungsi hash dengan kompromi antara kualitas dan kecepatan.  Selain itu, evaluasi analitik komparatif dari fungsi-fungsi tersebut cenderung subyektif. </p><br><p>  Sebaliknya, uji statistik dapat memberikan perkiraan kuantitatif yang jelas.  Untuk tujuan seperti itu ada paket pengujian yang terbukti, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SMHasher</a> .  Untuk <em>t1ha</em> , hasilnya sederhana - semua <strong>opsi t1ha</strong> lulus semua tes tanpa komentar.  Di sisi lain, orang tidak boleh berasumsi bahwa t1ha memiliki properti lebih dari yang diperlukan untuk aplikasi target (membangun tabel hash). </p><br><p>  Jumlah tabrakan di semua tingkatan (varian) <strong>t1ha</strong> sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paradoks ulang tahun</a> .  Untuk merumuskannya secara ketat - probabilitas tabrakan dalam <strong>t1ha</strong> sesuai dengan probabilitas kebetulan dari nilai diskrit acak dengan bitness yang sesuai. <br>  Probabilitas tabrakan yang serupa diamati pada semua fungsi hash berkualitas tinggi.  Namun, ini hanya probabilitas, sehingga jumlah sebenarnya dari tabrakan dapat bervariasi untuk setiap set data tertentu. </p><br><p> Setelah artikel ini pertama kali diterbitkan, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Yves Orton menemukan</a> , bahwa <code>t1ha1()</code> pertama tidak selalu memenuhi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kriteria longsoran yang ketat</a> .  Kelemahan ini tidak signifikan untuk aplikasi bertarget <code>t1ha1()</code> dan tidak terlihat dari sudut pandang praktis.  Namun, kerugian ini dihilangkan pada level / varian <code>t1ha2()</code> berikutnya, yang pada awalnya direncanakan untuk memberikan kualitas yang sedikit lebih tinggi.  Pada prosesor baru, yang menggunakan versi kompiler saat ini, <code>t1ha2()</code> rata-rata satu siklus lebih cepat dari <code>t1ha1()</code> , dan dalam kasus-kasus lainnya dapat menjadi satu siklus lebih lambat.  Perlu dicatat bahwa <code>t1ha2()</code> juga menawarkan mode hashing stream dan hasil 128-bit. </p><br><p>  Pembaca tentu akan menghargai analisis mendalam dan mendalam tentang kualitas dan / atau kekuatan <strong>t1ha</strong> .  Namun, berdasarkan area aplikasi target <strong>t1ha</strong> , ini tampaknya berlebihan.  Sederhananya, kecepatan lebih penting bagi kami, bahkan untuk tombol pendek.  Oleh karena itu, pencampuran multi-putaran tidak dipertimbangkan.  Versi <em>t1ha</em> saat ini menghemat siklus dan memberikan hasil 64-bit - praktis tidak ada gunanya untuk mengukur kompromi yang ditemukan dengan cara apa pun selain secara statistik, dan hasilnya cukup bagus. </p><br><div class="spoiler">  <b class="spoiler_title">Sebenarnya</b> <div class="spoiler_text"><p>  Saya hanya mengikuti rekan-rekan saya dari Google tentang cara mereka memberikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bukti statistik</a> mereka </p></div></div><br><hr><br><h2 id="benchmarks">  Tingkatan yang dicapai </h2><br><p>  Mengenai klaim sebagai " <em>yang tercepat</em> ".  Penting untuk dicatat bahwa tidak mungkin ada fungsi hash yang berguna sekaligus tercepat di semua platform / arsitektur.  Prosesor yang berbeda memiliki set instruksi berbeda yang tersedia dan menjalankan instruksi serupa dengan efisiensi yang berbeda.  Jelas, fungsi " <em>tercepat secara universal</em> " kemungkinan besar tidak dapat dibuat.  Namun, tampaknya dapat diterima untuk menggunakan istilah "itu <br>  tercepat »untuk fungsi yang portabel dan sekaligus tercepat, setidaknya pada platform paling umum (x86_64), sementara memiliki sedikit peluang untuk kehilangan prosesor modern dengan kompiler optimalisasi yang layak. </p><br><p>  Kode sumber proyek mencakup tes yang memeriksa kebenaran hasil dan mengukur kecepatan setiap varian yang diimplementasikan.  Pada saat yang sama, pada x86, tergantung pada kemampuan prosesor (dan kompiler), varian fungsi tambahan dapat diperiksa, dan pengukuran dilakukan dalam siklus prosesor. </p><br><p>  Selain itu, situs web proyek berisi tabel dengan hasil pengukuran kinerja melalui versi modifikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SMHasher dari Reini Urban</a> .  Satu dapat memeriksa ulang semua angka dan / atau mendapatkan hasil pada prosesor tertentu menggunakan kompiler tertentu. </p><br><p>  Di sini Anda dapat membandingkan t1ha dengan beberapa pesaing terdekatnya. </p><br><p>  <strong>Hashing kunci pendek</strong> (rata-rata untuk 1,.31 byte). <br>  <em>Lihatlah kolom kanan "Cycles / Hash" (lebih kecil lebih baik)</em> : </p><br><table><thead><tr><th>  Fungsi </th><th>  MiB / Detik </th><th>  Siklus / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35.55 </td></tr><tr><td>  Fasthash64 </td><td>  5578.06 </td><td>  43.42 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51.77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56.17 </td></tr><tr><td>  Metrohash </td><td>  11808.92 </td><td>  46.33 </td></tr></tbody></table><br><p>  <strong>Hashing kunci panjang</strong> (256 Kb). <br>  <em>Lihatlah kolom tengah "MiB / Second" (lebih besar lebih baik)</em> : </p><br><table><thead><tr><th>  Fungsi </th><th>  MiB / Detik </th><th>  Siklus / Hash </th></tr></thead><tbody><tr><td>  t1ha </td><td>  12228.80 </td><td>  35.55 </td></tr><tr><td>  Farmhash64 </td><td>  12145.36 </td><td>  60.12 </td></tr><tr><td>  CityHash64 </td><td>  11041.72 </td><td>  51.77 </td></tr><tr><td>  xxHash64 </td><td>  11123.15 </td><td>  56.17 </td></tr><tr><td>  Spooky64 </td><td>  11820.20 </td><td>  60.39 </td></tr></tbody></table><br><hr><br><h2 id="variants-of-t1ha">  Varian t1ha </h2><br><p>  Pengembangan <strong>t1ha</strong> Tujuan pertama adalah untuk mendapatkan fungsi portabel cepat yang berkualitas tinggi untuk membuat tabel hash. </p><br><p>  Kemudian kami ingin memiliki versi tercepat dari fungsi hash yang akan memberikan hasil kualitas yang sebanding tetapi disesuaikan dengan platform target sebanyak mungkin.  Misalnya, versi <strong>t1ha</strong> dasar berfungsi dengan urutan byte little-endian, yang <strong>karenanya</strong> diperlukan konversi untuk arsitektur big-endian dengan kehilangan kinerja yang tak terhindarkan.  Jadi mengapa tidak menyingkirkan operasi yang tidak perlu pada platform target spesifik?  Dengan cara ini, beberapa opsi ditambahkan: </p><br><ul><li>  Versi sederhana untuk platform 32-bit, baik kecil maupun big-endian. </li><li>  Varian menggunakan instruksi AES-NI, tetapi tanpa AVX. </li><li>  Dua varian menggunakan petunjuk AES-NI dan AVX. </li></ul><br><p>  Kemudian menjadi jelas bahwa lebih banyak opsi yang dirancang untuk berbagai aplikasi akan dibutuhkan, termasuk hasil lebar bit yang berbeda, persyaratan kualitas dan daya tahan.  Keragaman seperti itu membutuhkan sistematisasi yang tepat.  Ini dicapai dengan mengubah skema penamaan, di mana sufiks numerik menunjukkan "level" dari fungsi: </p><br><ul><li>  <code>t1ha0()</code> - adalah opsi tercepat untuk prosesor saat ini. </li><li>  <code>t1ha1()</code> - adalah versi portabel dasar 64-bit dari t1ha. </li><li>  <code>t1ha2()</code> - adalah versi portabel 64-bit dengan sedikit lebih memperhatikan kualitas. </li><li>  <code>t1ha3()</code> - adalah versi 128-bit portabel yang cepat untuk sidik jari. </li><li>  dll. </li></ul><br><p>  Dalam skema ini, diasumsikan bahwa <code>t1ha0()</code> adalah dispatcher yang mengimplementasikan pengalihan tergantung pada platform dan kemampuan prosesor saat ini.  Selain itu, penggunaan sufiks "_le" dan "_be" untuk pilihan eksplisit antara varian little-endian dan big-endian dapat diperkenalkan.  Jadi, di bawah papan "t1ha" sekarang ada beberapa fungsi hash, dan keluarga ini akan menumbuhkan saya di masa depan, termasuk versi yang dioptimalkan untuk "Elbrus" E2K Rusia. </p><br><p>  Gagasan umum dari sekumpulan fungsi saat ini dan propertinya dapat dipahami dengan melihat output tes bawaan ( <code>make check</code> ).  Perlu dicatat bahwa semua fungsi lulus semua tes SM Hasher, dan kinerja varian AES-NI sangat bervariasi tergantung pada model prosesor: </p><br><pre> <code class="diff hljs">Intel(R) Core(TM) i7-6700K CPU @ 3.00GHz Build by GNU C/C++ compiler 8.2 [...] - use RDPMC_40000001 as clock source - measure granularity and overhead: 53 cycles, 0.0188679 iteration/cycle Bench for tiny keys (7 bytes): t1ha0 : 13.14 cycle/hash, 1.877 cycle/byte, 1.598 Gb/s @3GHz t1ha1_64le : 15.14 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha2_atonce : 15.50 cycle/hash, 2.163 cycle/byte, 1.387 Gb/s @3GHz t1ha1_64be : 16.78 cycle/hash, 2.397 cycle/byte, 1.251 Gb/s @3GHz xxhash32 : 17.17 cycle/hash, 2.453 cycle/byte, 1.223 Gb/s @3GHz StadtX : 17.59 cycle/hash, 2.513 cycle/byte, 1.194 Gb/s @3GHz t1ha0_32le : 18.28 cycle/hash, 2.612 cycle/byte, 1.149 Gb/s @3GHz t1ha0_32be : 20.24 cycle/hash, 2.892 cycle/byte, 1.037 Gb/s @3GHz xxhash64 : 22.17 cycle/hash, 3.167 cycle/byte, 0.947 Gb/s @3GHz t1ha2_atonce128* : 29.93 cycle/hash, 4.277 cycle/byte, 0.701 Gb/s @3GHz t1ha2_stream* : 79.81 cycle/hash, 11.402 cycle/byte, 0.263 Gb/s @3GHz HighwayHash64_avx2 : 83.75 cycle/hash, 11.964 cycle/byte, 0.251 Gb/s @3GHz HighwayHash64_sse41 : 85.25 cycle/hash, 12.179 cycle/byte, 0.246 Gb/s @3GHz t1ha2_stream128* : 99.06 cycle/hash, 14.152 cycle/byte, 0.212 Gb/s @3GHz HighwayHash64_portable: 480.75 cycle/hash, 68.679 cycle/byte, 0.044 Gb/s @3GHz HighwayHash64_pure_c : 652.58 cycle/hash, 93.226 cycle/byte, 0.032 Gb/s @3GHz Bench for large keys (16384 bytes): t1ha0 : 1185.00 cycle/hash, 0.072 cycle/byte, 41.478 Gb/s @3GHz t1ha2_atonce : 3436.00 cycle/hash, 0.210 cycle/byte, 14.305 Gb/s @3GHz t1ha2_atonce128* : 3440.00 cycle/hash, 0.210 cycle/byte, 14.288 Gb/s @3GHz t1ha1_64le : 3449.00 cycle/hash, 0.211 cycle/byte, 14.251 Gb/s @3GHz t1ha2_stream* : 3479.00 cycle/hash, 0.212 cycle/byte, 14.128 Gb/s @3GHz t1ha2_stream128* : 3508.00 cycle/hash, 0.214 cycle/byte, 14.011 Gb/s @3GHz StadtX : 3550.00 cycle/hash, 0.217 cycle/byte, 13.846 Gb/s @3GHz xxhash64 : 4121.00 cycle/hash, 0.252 cycle/byte, 11.927 Gb/s @3GHz t1ha1_64be : 4567.00 cycle/hash, 0.279 cycle/byte, 10.762 Gb/s @3GHz HighwayHash64_avx2 : 4580.00 cycle/hash, 0.280 cycle/byte, 10.732 Gb/s @3GHz HighwayHash64_sse41 : 6412.00 cycle/hash, 0.391 cycle/byte, 7.666 Gb/s @3GHz t1ha0_32le : 7191.00 cycle/hash, 0.439 cycle/byte, 6.835 Gb/s @3GHz t1ha0_32be : 7928.00 cycle/hash, 0.484 cycle/byte, 6.200 Gb/s @3GHz xxhash32 : 8197.00 cycle/hash, 0.500 cycle/byte, 5.996 Gb/s @3GHz HighwayHash64_portable: 41895.27 cycle/hash, 2.557 cycle/byte, 1.173 Gb/s @3GHz HighwayHash64_pure_c : 53296.11 cycle/hash, 3.253 cycle/byte, 0.922 Gb/s @3GHz</code> </pre><br><hr><br><div class="spoiler">  <b class="spoiler_title">Sedikit tentang struktur internal</b> <div class="spoiler_text"><p>  Untuk mempelajari sedikit lebih detail, <strong>t1ha</strong> dibangun sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema Merkle-Damgård</a> (versi "wipe-pipe") dengan penguatan dari ukuran data dan nilai seed.  Di dalam loop kompresi utama, keadaan 256-bit digunakan, dengan ukuran yang sama dari blok input.  Selain itu, untuk setiap operan data ada dua titik injeksi dengan penyerbukan silang.  Setelah menyelesaikan siklus kompresi, keadaan 256-bit dikompresi menjadi 128 bit. </p><br><p>  Saat melakukan tindakan di atas, operasi 64-bit, digabung menjadi mixer ARX (Add-Rotate-Xor) dan MUX / MRX (Mul-Rotate-Xor), digunakan.  Adalah penting bahwa semua perhitungan ini dibangun sedemikian rupa untuk memastikan kemungkinan eksekusi paralel sebagian besar operasi dan pengemasan ketat u-ops baik ke dalam pipa dan ke dalam unit-unit eksekusi x86_64.  Karena ini, kualitas yang cukup baik dicapai dengan tingkat hash yang hampir maksimum untuk kunci panjang. </p><br><p>  Perlu dicatat bahwa loop kompresi hanya berjalan untuk blok dengan ukuran yang cukup.  Jika ada lebih sedikit data, maka status 128-bit antara hanya akan terdiri dari ukuran kunci dan nilai garam. </p><br><p>  Kemudian, sisa data yang tersisa dicampur dalam bagian-bagian dari 64 bit secara bergantian dengan bagian dari keadaan 128-bit.  Akhirnya, keadaan dicampur dan secara bersamaan dikompresi menjadi hasil 64-bit.  Fitur penting dari t1ha di sini adalah penggunaan mixer berdasarkan penggandaan lebar (produk 128-bit dari dua pengganda 64-bit).  Hal ini memungkinkan tercampurnya kualitas yang baik dengan efek longsoran yang baik dan operasi yang lebih sedikit.  Meskipun penggandaan lebar adalah operasi yang relatif mahal, lebih sedikit operasi seperti itu yang memungkinkan t1ha memproses kunci pendek dalam jumlah siklus prosesor yang rendah. </p><br><p>  Perlu dicatat bahwa mixer berdasarkan perkalian luas dan eksklusif ATAU tidak sempurna.  Meskipun <em>t1ha</em> lolos dari semua <em>ujian SMHasher</em> , penulis memahami konsekuensi dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">non-injeksi</a> .  Namun demikian, kualitas yang dihasilkan tampaknya cukup rasional, dan rencana pengembangan untuk lini t1ha sudah mencerminkan niat untuk memberikan opsi kualitas yang sedikit lebih tinggi. </p></div></div><br><p>  Anda dapat menemukan informasi lebih lanjut dan kode sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  <em>Terima kasih sudah membaca!</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439156/">https://habr.com/ru/post/id439156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439142/index.html">Desain Model Kematangan</a></li>
<li><a href="../id439148/index.html">Bekerja dengan nRF51822 menggunakan ST-Link dan Clion + OpenOCD</a></li>
<li><a href="../id439150/index.html">Siapa yang harus membayar biaya transaksi</a></li>
<li><a href="../id439152/index.html">Gaji di IT pada paruh kedua 2018: menurut kalkulator gaji "My Circle"</a></li>
<li><a href="../id439154/index.html">Bagaimana Freelancer Lepas: Desain Sampul Buku, Produksi Ransel Sendiri, dan Perjalanan</a></li>
<li><a href="../id439158/index.html">DataArt Meluncurkan Layanan Peningkatan Resume Bebek CV Gratis</a></li>
<li><a href="../id439160/index.html">Keadaan algoritme: apa yang terjadi pada pengembang indie di Steam?</a></li>
<li><a href="../id439162/index.html">Cara men-debug frontend dan backend: petunjuk langkah demi langkah</a></li>
<li><a href="../id439166/index.html">mmWave dalam perjalanan menuju komersialisasi dalam faktor bentuk ponsel cerdas</a></li>
<li><a href="../id439168/index.html">Sistem analisis klien</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>