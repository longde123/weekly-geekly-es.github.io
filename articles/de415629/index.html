<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëçüèΩ üôà üïñ Automatisierung tibetischer Klangschalen mit Hilfe von "Arduino". Schrittmotor statt M√∂nch. Drahtlose Programmierung üëêüèª üëàüèø üôçüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="UND √úBERTRAGUNG DES G√ñTTLICHEN WILLENS VON GENAUEN ZEITSIGNALEN DURCH ESP8266 . 
 VIERTER TEIL 



 Also stimmte alles √ºberein. Zuerst sah ich einen A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automatisierung tibetischer Klangschalen mit Hilfe von "Arduino". Schrittmotor statt M√∂nch. Drahtlose Programmierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415629/">  <b>UND √úBERTRAGUNG <s>DES G√ñTTLICHEN WILLENS VON GENAUEN ZEITSIGNALEN DURCH ESP8266</s> .</b> <b><br></b>  <b>VIERTER TEIL</b> <br><br><img src="https://habrastorage.org/webt/gx/au/0j/gxau0jnutvametc-igezo5zkpvk.jpeg"><br><br>  Also stimmte alles √ºberein.  Zuerst sah ich einen Artikel √ºber Gytayms √ºber Vorh√§nge, die von einem Schrittmotor gesteuert werden.  Ich erinnerte mich, dass ich das zweite Jahr den gleichen Motor im Leerlauf hatte.  Dann fiel mein Blick auf die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klangschale</a> , die seit f√ºnf Jahren im Regal verstaubt war.  Und dann kamen mir verschiedene kluge Gedanken in den Sinn ... <br><br>  Nein, nat√ºrlich, manchmal, je nach Stimmung, nahm ich diese Tasse in die Hand und extrahierte einige Zeit verschiedene Arten von bezaubernden Ger√§uschen daraus, aber das war nicht ganz das, was ich wollte.  Und ich wollte etwas parallel machen und die Tasse selbst zu dieser Zeit klingen lassen.  Es ist klar, dass dies vor tausend Jahren einen separaten <s>Sklavenmann</s> erfordert h√§tte, vor dreihundert Jahren w√§re es ein ausgekl√ºgeltes Uhrwerk gewesen, und jetzt ... Nun, jetzt haben wir einen Schrittmotor und ein Arduino ProMini-Board und andere <s>nicht</s> ausgefeilte Elektronik.  Es bleibt nur ein wenig auf <s>Vieh</s> zu codieren.  Und stellen Sie gleichzeitig sicher, dass dieser tibetische Mei√üel gleichzeitig die genaue Zeit abwehrt - vergebens oder etwas, das so viele genaue Zeitserver hervorgebracht hat.  Und lassen Sie ESP8266 mit ihnen kommunizieren, sie wei√ü wie. <br><br>  Also ... <br><a name="habracut"></a><br>  Es gibt eine Klangschale mit einem Kl√∂ppel. <br><br><img src="https://habrastorage.org/webt/tk/d_/hy/tkd_hy9acctcthkplro1s8fs20k.jpeg"><br><br>  Es ist notwendig, den Hammer gegen den Rand der Sch√ºssel schlagen zu lassen.  Automatisch.  Auch mit der M√∂glichkeit der Fernbedienung (und Neuprogrammierung!).  Und nur um die Zeit wie eine alte Uhr zu schlagen, aber mit moderner Pr√§zision. <br><br>  Mit Blick auf die Zukunft werde ich zeigen, was am Ende passiert ist.  Mit Ton besser zuschauen. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0jCoLDa7Xx0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Aber fangen wir in der richtigen Reihenfolge an.  Zuerst musste ich verstehen, wie die Mechanik aussehen und funktionieren w√ºrde.  F√ºr Elektronik und Software war ich ruhig - hinter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">drei Artikeln</a> √ºber den Umgang mit Arduinki aus der Ferne. <br><br>  Das Hauptbewegungselement sollte ein einfacher 28YBJ-48-Schrittmotor sein, und ich musste verstehen, ob er mit dem Hammer umgehen konnte. <br><br><img src="https://habrastorage.org/webt/vl/kt/sn/vlktsnvvvzlckt-wjpsmztiqtqs.jpeg"><br><br>  Die Verbindung der Dvigun mit dem Arduino ist nicht schwierig, zum Gl√ºck wurde sie mit einem vorgefertigten ULN2003-Treiber verkauft.  Es war nur notwendig, eine separate Stromversorgung f√ºr 5 Volt und eine Reserve von 200-300 mA bereitzustellen, da Sie definitiv nicht genug Konverter am Arduino selbst haben werden.  Dann √ºbertragen wir an vier beliebigen digitalen Ports (ich habe PB1, PB2, PB3, PB4 genommen) die folgenden Bit-Notebooks in der Menge von acht Teilen. <br><br><pre><code class="cpp hljs">PORTB=<span class="hljs-number"><span class="hljs-number">0b00000010</span></span>;<span class="hljs-comment"><span class="hljs-comment">//     PORTB=0b00000110; PORTB=0b00000100; PORTB=0b00001100; PORTB=0b00001000; PORTB=0b00011000; PORTB=0b00010000; PORTB=0b00010010;</span></span></code> </pre> <br>  Bei Drehung in die entgegengesetzte Richtung √ºbertragen wir dieselben Notebooks, jedoch in umgekehrter Reihenfolge. <br><br><pre> <code class="cpp hljs"> PORTB=<span class="hljs-number"><span class="hljs-number">0b00010010</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00010000</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00011000</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00001000</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00001100</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00000100</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00000110</span></span>; PORTB=<span class="hljs-number"><span class="hljs-number">0b00000010</span></span>;</code> </pre><br>  Das einzige, was entsteht, ist die Geschwindigkeit, mit der Daten √ºbertragen werden.  Es ist klar, dass sich die Motorwelle umso schneller dreht, je √∂fter, aber bis zu welcher Grenze?  Die Beschreibung enth√§lt eine mysteri√∂se Frequenz von 100 Hz, aber was genau bedeutet das - die Periode eines vollst√§ndigen Zyklus oder jedes Knabbern einzeln? <br><br>  Im Verlauf der Experimente stellte sich heraus, dass anscheinend die H√§ufigkeit der √Ñnderung von genau Tetraden gemeint war.  Bis zum Maximum gelang es mir, diese Frequenz auf 147 Hz zu beschleunigen, bei der sich die Motorwelle in ein oder zwei Sekunden drehte.  Ich habe es nicht genau gemessen, aber Sie k√∂nnen selbst beurteilen, dass sich dieses Modell mit diesem Getriebe nicht in besonderer Agilit√§t unterscheidet.  Aber f√ºr meinen Hammer schien es im Prinzip geeignet zu sein. <br><br>  Schlie√ülich ist uns nicht nur die Geschwindigkeit wichtig (oder vielmehr nicht einmal sehr wichtig), sondern auch die Kraft, mit der der Motor das Arbeitsmedium beeinflussen kann.  In Beitr√§gen zu diesem Motor wurde argumentiert, dass sie nicht mit einer Hand anhalten k√∂nnten.  Wie sich herausstellte, wird der Schaft selbst, ja, Sie werden nicht anhalten, aber bereits ein kleiner Hebel (und ich habe mich f√ºr ein Hebelsystem entschieden), der buchst√§blich 10 cm lang ist, stoppt und bleibt auch bei einem kleinen lokalen Aufprall sehr leicht stehen. <br><br>  Daher passierte die anf√§nglich einfachste Option, wenn der mit der Welle verschraubte Hebel den Schl√§ger auf die Aufh√§ngung dr√ºckt, die dementsprechend die Sch√ºssel schl√§gt, nicht.  Der Ton war zu schwach.  Also beschloss ich, die Schwerkraft um Hilfe zu bitten (die sehr ‚Äûherzlose Schlampe‚Äú in den Worten von Sheldon Cooper).  In dieser Ausf√ºhrungsform zog der Hebel eine Klappe bis zu einem Winkel von ungef√§hr 30 Grad relativ zur Richtung zum Erdmittelpunkt und l√∂ste sich dann von dieser und schickte sie auf ihren Weg zur Sch√ºssel.  Ich mochte den Sound sehr, sowohl von unten als auch von meinen Nachbarn.  Der Entriegelungsmechanismus wurde an einem Magneten hergestellt, der am Ende des Hebels angebracht war.  Als sie aufstiegen, besiegte die Schwerkraft die magnetische und das Schloss wurde gel√∂st.  Dann machte ich einen helfenden mechanischen Stopp - eine Querstange, mit der sich der Hammer nahe dem √§u√üersten Anstiegspunkt traf.  Der Motor drehte sich weiter, der Hebel zog und l√∂ste die Magnetverriegelung gewaltsam.  Hier wurde der Motor durch die Schwerkraft unterst√ºtzt, so dass der Aufwand zum Ausr√ºcken sehr gering war. <br><br>  Das Design selbst wurde auf Basis der Details des Eiffelturm-Kinderdesigners zusammengestellt.  Ich kaufte es f√ºr eine lange Zeit und benutzte seine Teile regelm√§√üig f√ºr mein Handwerk.  Der Turm stellte sich nat√ºrlich nicht als Eiffel heraus, aber meiner Meinung nach ist es keineswegs schlimmer :) <br><br><div class="spoiler">  <b class="spoiler_title">Fast Eiffelturm</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/wl/la/as/wllaasusy0nhw9s_ad0y7depa9k.jpeg"><br></div></div><br>  Alles hat perfekt funktioniert, aber mit einem Minus - der Sound war immer die gleiche Leistung.  Dies ist normal f√ºr das Schlagen der Zeit, aber im freien Modus m√∂chte ich nicht nur verschiedene Pausen in der Zeit h√∂ren, sondern auch Ger√§usche unterschiedlicher St√§rke.  Daher war es notwendig, einen Elektromagneten anzulegen, was ebenfalls sehr n√ºtzlich war.  Herk√∂mmliche Magnete waren ebenfalls n√ºtzlich - eine S√§ule mit f√ºnf kleinen Magneten, die ich als D√§mpfer verwendete, um die Vibrationen des Schl√§gers nach dem Auftreffen auf die Sch√ºssel zu z√§hmen. <br><br><img src="https://habrastorage.org/webt/vs/yv/gb/vsyvgb5eqgcdqze2hyhxesgya9k.jpeg"><br><br>  Zuerst habe ich es am Ende des Hebels installiert, aber das Design war umst√§ndlich, fadenscheinig und unzuverl√§ssig.  Daher bewegte sich der Elektromagnet zu einem Hammer.  Er verbrauchte ungef√§hr 300 mA und nat√ºrlich war es unm√∂glich, es vom Hafen von Arduino aus zu kontrollieren.  Ich musste einen einfachen Transistorschl√ºssel auf ein kleines Steckbrett legen. <br><br><img src="https://habrastorage.org/webt/sm/2j/w6/sm2jw69rz-nfepnkzp99bebnn9i.png"><br><br>  R1 - 560 Ohm, VD1 - 1N4007, VT1 - BD139 <br><br>  Ich habe das elektronische Hauptteil auf dem ‚ÄûArduino ProMini‚Äú und dem ESP8266-07-Modul zusammengebaut, dessen Firmware ich gem√§√ü meinem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">alten Artikel</a> Schritt f√ºr Schritt vollst√§ndig fertiggestellt habe.  Infolgedessen hatte ich wie √ºblich die M√∂glichkeit, das Arduino drahtlos zu programmieren und auch remote mit ihm zu kommunizieren und Daten auszutauschen, die ich schlie√ülich erfolgreich nutzte.  Das Diagramm zeigt jedoch den Arduino Nano aus historischen Gr√ºnden, aber seine Verbindung ist nicht anders. <br><br><img src="https://habrastorage.org/webt/ce/bu/6d/cebu6dvlctxn46bgg2cu5k6cnlc.png"><br><br>  Also, was habe ich mir gew√ºnscht und dann im Programmcode verk√∂rpert. <br><br><ol><li>  Wenn Sie das System einschalten, muss es unabh√§ngig in den √úberwachungsmodus wechseln. </li><li>  Auf dem Computer (Smartphone) sollte eine Anwendung zum √Ñndern der Betriebsmodi und zum √úbertragen der erforderlichen Daten vorhanden sein. </li><li>  Die Modi sollten einfach sein - eine Uhr, zuf√§lliges Murmeln und manuelle Steuerung. </li></ol><br>  Ich begann, wie es schien, mit der einfachsten Sache - Stunden.  In der Tat sammelt jeder Amateurfunk-Anf√§nger zuerst eine Sonde und dann eine elektronische Uhr.  Und dann wundert er sich jedoch, warum diese Uhr um eine Minute pro Stunde zur√ºckbleibt - es scheint, dass er theoretisch alles richtig berechnet hat. <br><br>  Ich hatte bereits die zusammengebaute elektronische Uhr. <br><br><img src="https://habrastorage.org/webt/lw/5u/eu/lw5ueutxi1xyqmu9bz8r6vpy-e0.jpeg"><br><br>  Und ihr Hauptmerkmal, das mir jetzt n√ºtzlich war, war ihre F√§higkeit, die genaue Zeit von NTP-Servern mit demselben ESP8266-Mikroschaltkreis in der Person seiner allerersten und einfachsten Inkarnation zu ziehen. <br><br>  Ich wollte vor ein paar Jahren sogar einen Artikel zu diesem Thema einreichen, aber nachdem ich gesehen hatte, wie oft dies bereits getan wurde, √§nderte ich meine Meinung.  Sie werden doch lachen.  Aber im Rahmen dieses Beitrags ist eine Analyse ihrer Arbeit durchaus angebracht.  Wie ich bereits in den Artikeln erw√§hnt habe, schreibe ich Programme f√ºr ESP8266 in der LUA-Sprache.  Es hat sich so ergeben. <br><br><div class="spoiler">  <b class="spoiler_title">Daher war der in dieses ESP-Modul geladene Code so.</b> <div class="spoiler_text"><pre> <code class="lua hljs">uart.setup(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">9600</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) timezone = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">--  tmr.alarm(1,5000,0,function() -- try once connect to NTP-server sk=net.createUDPSocket() sk:send(123,"130.149.17.21",string.char( 227, 0, 6, 236, 0,0,0,0,0,0,0,0, 49, 78, 49, 52, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)) sk:on("receive", function(sck, payload) ntp = payload:byte(41) * 128 * 256 * 256 + payload:byte(42) * 128 * 256 + payload:byte(43) * 128 + payload:byte(44) /2 + timezone * 1800 hour =ntp % 43200 / 1800 minute = ntp % 1800 / 30 secund = ntp % 60 uart.write(0,hour) uart.write(0,minute) uart.write(0,secund) sk:close() end ) end)</span></span></code> </pre><br></div></div><br>  Das Endergebnis ist einfach.  Einmal (oder nicht) wird die Funktion aufgerufen, die den UDP-Client einrichtet, der den genauen Zeitserver aufruft und die genaue Zeit entsprechend abfragt.  Als Antwort gibt der Server zweiunddrei√üig Bytes aus, von denen die gew√ºnschten vier Datenbytes abgerufen werden m√ºssen.  Leider sind dies nicht Minuten und Stunden, sondern die Anzahl der Sekunden, die seit dem 1. Januar 1900 vergangen sind.  Daher m√ºssen Sie dann die aktuelle Zeit aus den vier Bytes dieser Sekunden mit verschiedenen komplexen Manipulationen berechnen. <br><br>  Au√üerdem ist alles einfacher.  Starten Sie den UART-Sender und lassen Sie die berechnete Zeit um drei Bytes fallen - Stunden, Minuten und Sekunden. <br><br>  Und ich habe diesen Code erneut in meinen LUA-Bootloader (Link) eingef√ºgt, genau an der Stelle, an der die Verbindung zum WI-FI-Netzwerk bereits hergestellt wurde, aber die weiteren Arbeiten haben noch nicht begonnen. <br><br><div class="spoiler">  <b class="spoiler_title">In voller Sicht sieht es so aus.</b> <div class="spoiler_text"><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstrProgrammingEnable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">-- instruction for MC "enable programming" p=0 while p&lt;31 do p=p+1 pin=8 gpio.write(pin, gpio.LOW) spi.send(1, 0xAC,0x53) read = spi.recv( 1, 8) spi.send(1,0,0) gpio.write(pin, gpio.HIGH) if (string.byte(read)== 83) then --print("connection established") p=33 if(p==31) then --print("no connection") end end end end function ProgrammingDisable () pin=2--END OF ESET FOR MK GPIO4 gpio.mode(pin, gpio.INPUT) pin=8 gpio.mode(pin, gpio.INPUT) -- CE chip enable not used GPIO15 pin=5--CLK MASTER for SPI GPIO14 used gpio.mode(pin, gpio.INPUT) pin=6--MISO MASTER for SPI GPIO 12 may not used gpio.mode(pin, gpio.INPUT) pin=7--MOSI MASTER for SPI //GPIO13 used gpio.mode(pin, gpio.INPUT) end --PROGRAMMING ENABLE function ProgrammingEnable () pin=2-- RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) pin=2--POZITIV FOR 4MSEC RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(4) gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) tmr.delay(25000) end function InstrFlashErase() --FFFFFFFFFFFFFFFFFF pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0xAC,0x80,0,0) gpio.write(pin, gpio.HIGH) tmr.delay(15000) pin=2--RESET FOR MK gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) tmr.delay(20000) gpio.write(pin, gpio.LOW) --print( "FLASH is erased") InstrProgrammingEnable () end function InstrStorePAGE(H, address, data) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,H,0,address,data) gpio.write(pin, gpio.HIGH) tmr.delay(500) end function InstrWriteFLASH(page_address_low,page_address_high) pin=8 gpio.write(pin, gpio.LOW) spi.send(1,0x4C,page_address_high,page_address_low,0) gpio.write(pin, gpio.HIGH) tmr.delay(5000)--        end function Programming (payload) pin=8--CS MASTER for SPI gpio.mode(pin, gpio.OUTPUT, gpio.PULLUP) pin=4--LED LIGHTS ON LOW gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.LOW) --print(string.len(payload)) page_count = 7 --  1  for k =0 ,page_count ,1 do--quantity of pages for i=0 , 127, 2 do-- -1 address = i/2 data=payload:byte(i+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x40,address,data) -- tmr.delay(100)-- otherwise not in time write data =payload:byte(i+1+1+128*k) if data == nil then data = 0xff end InstrStorePAGE(0x48,address,data) -- tmr.delay(100) end page_address_low=bit.band(k ,3)*64 -- 3   11 page_address_high=k/4+frame1024*2 tmr.delay(1000) InstrWriteFLASH(page_address_low,page_address_high) tmr.wdclr() end pin=4--LED gpio.mode(pin, gpio.OUTPUT) gpio.write(pin, gpio.HIGH) end --MAIN BLOCK wifi.setmode(wifi.STATION) --wifi.sta.config("mixa","M1sh8111") -- set SSID and password of your access point station_cfg={} tmr.delay(30000) station_cfg.ssid="mixa" tmr.delay(30000) station_cfg.pwd="M1sh8111" tmr.delay(30000) wifi.sta.config(station_cfg) tmr.delay(30000) wifi.sta.connect() tmr.delay(1000000) --print(wifi.sta.status()) --print(wifi.sta.getip()) while ( wifi.sta.status()~=1 ) do if( wifi.sta.status()==5) then break end end uart.setup(0,9600,8,0,1,0) --     NTP      AVR timezone = 3 --  tmr.alarm(1,5000,0,function() -- try once connect to NTP-server sk=net.createUDPSocket() sk:send(123,"130.149.17.21",string.char( 227, 0, 6, 236, 0,0,0,0,0,0,0,0, 49, 78, 49, 52, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)) sk:on("receive", function(sck, payload) ntp = payload:byte(41) * 128 * 256 * 256 + payload:byte(42) * 128 * 256 + payload:byte(43) * 128 + payload:byte(44) /2 + timezone * 1800 hour =ntp % 43200 / 1800 minute = ntp % 1800 / 30 secund = ntp % 60 uart.write(0,100)-- AVR    uart.write(0,hour) uart.write(0,minute) uart.write(0,secund) sk:close() end ) end) prog_address=""; sv=net.createServer(net.TCP,30) tmr.delay(100) --print("SERVER READY") sv:listen(40000,function(c)-- ,   c:on("receive", function(c, payload) --print(payload) if (payload =="program\r\n") then c:send("ready\r\n") --print("ready for program\r\n") tmr.wdclr() spi.setup(1, spi.MASTER, spi.CPOL_LOW, spi.CPHA_LOW, spi.DATABITS_8,80,spi.FULLDUPLEX) --  SPI 320  115 000  ProgrammingEnable ()---------------------------------------------------------------------  80    1  tmr.delay(100) InstrProgrammingEnable () tmr.delay(100) InstrFlashErase() tmr.delay(100) frame1024=0--   st=net.createServer(net.TCP,30)--         AWR,   stop program st:listen(40001,function(c) c:on("receive", function(c, payload) tmr.wdclr() Programming (payload) frame1024=frame1024+1 end) end) end if (payload =="data\r\n") then tmr.wdclr() c:send("ready\r\n") -- print("ready for data\r\n") c:on("receive", function(c, prog_address_payload) prog_address=prog_address_payload-- IP  UDP       -- print(prog_address) c:send(prog_address) srv=net.createUDPSocket()--     ,   data stop srv:listen(50000) -- uart.setup(0,9600,8,0,1,0) srv:on("receive", function(srv, pl) --      UDP pl=pl*1 -- print(pl) uart.write(0,pl) --    UART  AVR end) uart.on("data", 1, function(data) --    UART  AVR srv:send(50000,prog_address,data) --    UDP   end, 0) tmr.wdclr() end) end if (payload =="stop data\r\n") --      then ready = false if(srv~=nil) then srv:close() -- print("stop data") end collectgarbage() end if (payload =="stop program\r\n") then if(st~=nil) then st:close() frame1024=0 ProgrammingDisable () -- print("stop program") end collectgarbage() end end) end)</span></span></code> </pre><br></div></div><br>  Dies widerspricht nat√ºrlich meinem Konzept, bei dem der ESP8266 eine saubere drahtlose Br√ºcke ist und der ATMEL-Mikrocontroller den Rest erledigt, aber wie sie sagen: "einmal, nicht ...". <br><br>  Wir haben also die anf√§ngliche genaue Zeit erhalten (direkt vom NTP-Server oder indirekt √ºber die Anwendung auf dem Computer, es spielt keine Rolle), dann m√∂chten wir die Zeit selbst ber√ºcksichtigen.  Erstens muss das Netzwerk nicht geladen werden, und zweitens k√∂nnen Sie mit ATMEL theoretisch Sekunden mit guter Genauigkeit z√§hlen.  Theoretisch ja.  In der Praxis gibt es jedoch Fallstricke. <br><br>  <b>Ein kleiner Exkurs √ºber die Echtzeituhr am AVR.</b> <br><br>  Theoretisch ist es nicht kompliziert, eine Uhr auf dem AVR-Mikrocontroller aufzubauen.  Die tollw√ºtigsten Designer haben daf√ºr sogar einen Taktquarz mit 32768 Hz in die Schaltung geschoben.  Tats√§chlich ist dies jedoch nicht erforderlich.  Tats√§chlich ist ein Taktquarz erforderlich, um ein Interrupt-Vielfaches einer Sekunde zu bilden und einen <b>schlafenden</b> (Noten-) Mikrocontroller zu wecken.  Wenn Ihr Ger√§t st√§ndig arbeitet und die Uhr normalerweise funktioniert, ist es r√ºcksichtslos, zus√§tzlichen Quarz auf den vorhandenen zu setzen und zwei Eingabe- / Ausgabezweige darunter zu nehmen.  Es ist m√∂glich, einen Quarzresonator zu verwenden, der bereits vorhanden ist, acht oder sechzehn Megahertz.  Die Quantisierungsgenauigkeit reicht f√ºr Ihre Augen aus, und das Z√§hlen einer Sekunde als Timer-Z√§hler ist ebenfalls einfach. <br><br>  Tats√§chlich hat der AVR-Mikrocontroller bereits alles daf√ºr.  Wie Sie wissen, kommt das Eingangstaktsignal (z. B. 8 MHz) im Chip (z. B. AVRmega328P als das f√ºr Arduino am h√§ufigsten verwendete) auf dem sogenannten Pre-Splitter an, wo es durch den Wunsch des Programmierers weiter unterteilt werden kann (normalerweise durch 8, 64, 256, 1024).  Und dann kommt er zu einer Art Zeitz√§hler (z. B. T1), der sofort zu erh√∂hen beginnt. <br><br>  Nehmen wir also 8 MHz und dividieren durch 256. Wir erhalten jeweils die Taktfrequenz des Z√§hlers 31250 Hz.  Da der T1-Z√§hler sechzehnstellig ist und entsprechend bis zu 65535 z√§hlen kann, hat er dementsprechend nur Zeit, in einer Sekunde bis zu 31250 zu z√§hlen.  Was wir brauchen.  Dar√ºber hinaus verf√ºgt unser Timer √ºber ein weiteres sehr n√ºtzliches Vergleichsregister.  Wenn wir dort die Nummer 31250 notieren, wird sie unter bestimmten Bedingungen st√§ndig mit dem Inhalt des T1-Z√§hlers verglichen, und schlie√ülich erzeugt der Z√§hler, wenn er gleich ist, ein Interrupt-Signal, z. B. behalten Sie Ihr zweites. <br><br>  Es stellt sich als bequem heraus, aber leider nicht ganz genau.  Denn unser Z√§hler wird mit einem Quantisierungsfehler von 256 / 8.000.000 gez√§hlt, was einen ziemlich gro√üen Fehler bei der Berechnung einer Sekunde in bis zu 32 Mikrosekunden ergibt.  Dies f√ºhrt zu einem Fehler von 2,8 Sekunden pro Tag (0,000032 * 3600 * 24). <br>  Wenn wir jedoch die urspr√ºnglichen 8 MHz durch einen kleineren Betrag teilen, beispielsweise durch 64, erh√∂ht sich die Quantisierungsgenauigkeit um das Vierfache auf 8 Œºs und verringert den resultierenden Fehler auf 0,33 Sekunden pro Tag.  In diesem Fall muss der Z√§hler jedoch leider bis zu 125.000 gez√§hlt werden, und eine solche Nummer im 16-Bit-Register wird nicht eingegeben.  Wir m√ºssen eine kleinere Zahl in das Vergleichsregister schreiben (62500 kann noch passen) und eine Schleife im Programm selbst hinzuf√ºgen, wobei eine Sekunde nicht von einem, sondern von zwei Interrupts gez√§hlt wird. <br><br>  Aber wir haben einen Idealfall angenommen, und ein echter Quarzresonator, der speziell auf einer ‚ÄûMade in China‚Äú -Platte installiert ist, kann Ihnen viele √úberraschungen bringen.  Nein, wenn Sie sich Standardquarz auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datenbl√§ttern</a> ansehen, ist theoretisch nicht alles so schlecht. <br><br>  Wie wir sehen k√∂nnen, verh√§lt sich Quarz im mittleren Bereich ziemlich gut.  Es hat eine eigene Instabilit√§t bei 25 ppm (oder mit anderen Worten 25 ppm), dh es schwingt bei einer Frequenz von nicht 8 MHz mit, aber beispielsweise bei einer Frequenz von 8 0002 MHz, was zu einem Fehler von bis zu 2,1 Sekunden f√ºhrt pro Tag.  Dies ist jedoch ein st√§ndiger Fehler und kann ber√ºcksichtigt werden.  Ein solcher Quarz kann auch bei einer Temperatur von 5 bis 10 ppm pro Grad schweben, aber unter Raumbetriebsbedingungen der Vorrichtung ist der Fehler ebenfalls gering.  Es gibt immer noch einen Faktor wie das Altern, aber es ist sehr sp√§rlich und ver√§ndert die Eigenschaften von Quarz in einen Zustand von mindestens einer gewissen Auff√§lligkeit, also vielleicht f√ºnf Jahren.  Oder zehn. <br><br>  Und hier freuen wir uns, einen chinesischen Arduino-Klon zu nehmen, zum Beispiel ARDUINO UNO. <br><br><img src="https://habrastorage.org/webt/p0/bk/ca/p0bkca_wthxj3_9hx9ttr6ivzbw.png"><br><br>  Wir f√ºhren darauf ein Testprogramm zum Z√§hlen der Zeit aus und legen los.  R√ºckstand pro Stunde f√ºr eine Minute?  Einfach!  Zweites Arduino UNO Board?  Nicht besser. <br><br>  Nimm den Arduino ProMini. <br><br><img src="https://habrastorage.org/webt/r4/b5/e6/r4b5e6ggnkxbbgmeefim9cv5-8i.jpeg"><br><br>  Und hier ist besser, ja.  Der Fehler verringerte sich auf zwanzig Sekunden pro Stunde.  Na ja, schon vergleichbar mit einer mechanischen Kuckucksuhr. <br><br>  Das letzte Board, das ich zur Hand hatte, war das Arduino Nano. <br><br><img src="https://habrastorage.org/webt/k_/iz/iq/k_iziqqu4ag5ywb2rm39qlvi8ng.jpeg"><br><br>  Und sie war die einzige, die mehr oder weniger gesunde Ergebnisse zeigte. <br><br>  Aber selbst mit einem solchen Board, das nur theoretische Konstrukte verwendet, verstehen Sie selbst, dass Sie keine exakte Uhr machen.  Das Board muss konfiguriert werden und ich stieg seufzend hinter das Oszilloskop. <br><br>  Wie sich herausstellte, haben Arduino-Platinen eine unangenehme Eigenschaft: Der Ausgang, an den der Quarzresonator angeschlossen ist, hat keinen Ausgang zum Stiftkamm, obwohl er Port PB7 entspricht.  Da der Hafen von Quarz besetzt ist, klammern Sie sich nicht daran.  Und genau am Fu√ü des Mikrocontrollers ist es sehr schwierig, die Oszilloskopsonde f√ºr die Oberfl√§chenmontage und einen Abstand von 0,5 mm zwischen den Anschl√ºssen aufzunehmen.  Aber selbst das rechte Bein zu verbinden, gab mir nichts.  Entweder weil ich falsch gestochert habe oder weil ich an der falschen Stelle gestochert habe, weil der Ausgang des Quarzresonators m√∂glicherweise nicht der Ausgang des Taktgenerators ist und sich im Allgemeinen im Mikrocontroller selbst befindet.  Daher musste ich Problemumgehungen umgehen - den Vorteiler auf den minimalen Teilungskoeffizienten setzen - eins, Null in das Vergleichsregister schreiben, damit der Interrupt sofort ruckelte, und in einem speziellen Modus in den Mikrocontroller eintreten, in dem der Portabschnitt PB1 mit jedem solchen Interrupt seinen logischen Zustand √§ndert. <br>  Wenn Sie die Arduino Nano 16-MHz-Karte einschalten, sollte logischerweise ein 8-MHz-M√§ander am Ausgang dieses Ports erscheinen. <br><br>  Welches ist passiert.  Das Oszilloskop zeigte eine Frequenz von 8,002 bis 31 MHz.  Dar√ºber hinaus lebte die letzte Entladung ihr eigenes Leben und ich verstand immer noch nicht, ob die Genauigkeit des Oszilloskops fehlt oder ob die Frequenz des Kristalloszillators so schwebt.  Eher wie eine Sekunde. <br><br>  Auch dort roch eine gute thermische Stabilit√§t nicht.  Wenn Sie auf dem Brett atmen (vielleicht kommen die Beh√§lter √ºbrigens immer noch aus Feuchtigkeit?) Oder einen L√∂tkolben (von weit her) mitbringen, kann sich der Quarz sofort um f√ºnfzig Hertz entfernen.  Und diese Messungen sind immer noch ungef√§hr verdoppelt, da die Anfangsfrequenz 16 MHz betr√§gt. <br><br>  Daher ist es bei Arduino-Boards (zumindest solchen chinesischen Ursprungs) unm√∂glich, eine Genauigkeit von mehr als 200 Hz bei einer Taktfrequenz von 16 MHz zu erreichen.  Dies gibt uns die ultimative Genauigkeit der auf solchen Brettern montierten Uhren nicht mehr als eine Sekunde pro Tag.  Und das ist gut so. <br><br>  Weil es chinesische Klone von Arduino UNO gibt, die ich bereits erw√§hnt habe und bei denen im Allgemeinen alles schlecht ist.  Und sie sind sehr verbreitet, weil sie billig und bequem sind. <br><br>  Ihre Frequenz kann also um mehr als hundert Kilohertz von der angegebenen abweichen!  Das ist sogar f√ºr den schlimmsten chinesischen Quarz untypisch. <br><br>  Das R√§tsel beginnt damit, dass 12 MHz auf den Quarz selbst geschrieben sind!  Und auch in den Beschreibungen der Verk√§ufer. <br><br><img src="https://habrastorage.org/webt/5l/ab/pj/5labpjeqa-grafww3mkdqnnawb4.jpeg"><br><br>  Aber es gibt keine 12 MHz, das ist sicher.  Wenn Sie die serielle UART-Schnittstelle auf der Karte aktivieren, werden Sie es selbst sehen.  Da der UART auf diese Frequenz eingestellt ist, werden Sie nicht arbeiten.  Und auf eine Frequenz von 16 MHz abgestimmt - wird sein.  Au√üerdem habe ich mir die Wellenformen auf beiden meiner Arduino Uno-Boards pers√∂nlich angesehen.  Die erste Karte hatte eine Generatorfrequenz von 15,8784 MHz und die zweite 15,8661 MHz. <br><br>  Aber pl√∂tzlich stellte sich heraus, dass 12-MHz-Quarz nicht direkt mit dem AVR-Mikrocontroller zusammenh√§ngt, sondern daf√ºr ausgelegt ist, die serielle Schnittstelle mit einem Computer √ºber USB zu betreiben (um Skizzen herunterzuladen).  Daher kam die Annahme, dass sich kein Quarz im Inneren befand, sondern eine schlecht abgestimmte RC-Kette, nicht zustande.  Und der Quarz, den wir brauchen, ist viel kleiner und befindet sich neben dem Mikrocontroller-Chip.  Aber es ist sehr klein und es gibt keine Inschrift darauf. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infolgedessen konnte ich immer noch nicht verstehen, wie und wo man Quarzresonatoren von solch schrecklicher Qualit√§t findet. </font><font style="vertical-align: inherit;">Aber anscheinend ist in China alles m√∂glich. </font><font style="vertical-align: inherit;">Und irgendwie dachte ich an die Draufg√§nger, die Arduinki f√ºr ernsthafte Gesch√§fte benutzten. </font><font style="vertical-align: inherit;">Nun, Software kann und sollte selbst geschrieben werden, aber was tun mit der Qualit√§t der Module selbst? </font><font style="vertical-align: inherit;">Anscheinend schieben die Chinesen von den elektronischen Bauteilen die billigsten und abgelehnten in sie hinein. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Singing Bowl Programm f√ºr AVR. </font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachdem ich alle Schwierigkeiten mit genauem Timing √ºberwunden hatte, schrieb ich am Ende den folgenden Code f√ºr meinen Arduino ProMini</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C-Programm f√ºr den Mikrocontroller AVRmega328P</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * Tibetian_Bowl.c * * Created: 07.06.2018 0:29:57 * Author: User */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> F_CPU 8000000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;avr/io.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;stdint.h&gt;//    #include &lt;math.h&gt; //  #include &lt;stdio.h&gt; // - #include &lt;avr/eeprom.h&gt; #include &lt;stdbool.h&gt; #include &lt;setjmp.h&gt; #include &lt;stdlib.h&gt; volatile bool change_mode = false; volatile bool boom =false; volatile bool go_ahead=true; volatile bool go_back=false; volatile bool gerkon=false; volatile uint8_t latency=2;//     latency = 1 volatile uint8_t hour=12; volatile uint8_t hour24=12;//       12 volatile uint8_t minute=0; volatile uint8_t secund=0; volatile uint8_t power=0; volatile uint8_t pause_between_boom=0; volatile uint8_t first_byte=0; volatile uint8_t second_byte=0; volatile uint8_t third_byte=0; volatile uint8_t firth_byte=0; volatile uint8_t fifth_byte=0; volatile uint8_t cSREG; ISR(USART_RX_vect) { //     ,  //   ‚Äì  ,    . if (first_byte==0) { first_byte=UDR0; change_mode=true; goto ret; } if (second_byte==0) { second_byte=UDR0; goto ret; } if (third_byte==0) { third_byte=UDR0; goto ret; } if (firth_byte==0) { firth_byte=UDR0; goto ret; } if (fifth_byte==0) { fifth_byte=UDR0; goto ret; } cSREG=UDR0; ret: return; } ISR(PCINT1_vect )//PC2 int 10 //    { if (go_ahead) { UDR0=44; //      44 } if (go_back) { gerkon=true; } } ISR(TIMER1_COMPA_vect) { //        secund++; if (secund ==60) { secund=0; minute++; if(minute==60) { minute=0; hour++; if(hour==12) { hour=1;//     12  } hour24++; if(hour24==24) { hour24=1; } boom=true; } } } void time_delay(long dell)//       { long i; dell=dell*796;//  8  for(i=0;i&lt;dell;i++){;;}; sei();//    ,  -    .WTF ?????????????????????? } void turn_onkward()//       { uint8_t legnth=170;//    ( 0  170) for(uint16_t i =0;i&lt;=legnth;i++) { go_ahead=true; PORTB=0b00000010;//       time_delay(latency); PORTB=0b00000110; time_delay(latency); PORTB=0b00000100; time_delay(latency); PORTB=0b00001100; time_delay(latency); PORTB=0b00001000; time_delay(latency); PORTB=0b00011000; time_delay(latency); PORTB=0b00010000; time_delay(latency); PORTB=0b00010010; time_delay(latency); if (i&gt;140) { PORTD |=(1&lt;&lt;PORTD2);//     , 1 -   } } time_delay(100); go_ahead=false; } void turn_backward(uint8_t pause, uint8_t force_of_sound)//     // //       { uint8_t legnth=170;//       ( 0  170) for(uint16_t i =0;i&lt;=legnth;i++) { go_back=true; PORTB=0b00010010; time_delay(latency); PORTB=0b00010000; time_delay(latency); PORTB=0b00011000; time_delay(latency); PORTB=0b00001000; time_delay(latency); PORTB=0b00001100; time_delay(latency); PORTB=0b00000100; time_delay(latency); PORTB=0b00000110; time_delay(latency); PORTB=0b00000010;//16 ms   ,  latency = 2 time_delay(latency); if (i==force_of_sound*17) { PORTD &amp;=~(1&lt;&lt;PORTD2);//     , 0 -   } if (gerkon) { gerkon=false; break; } } time_delay(50); time_delay(pause*1000);//       go_back=false; } void sound(uint8_t force,uint8_t pause) //       1  10           { turn_onkward(); turn_backward(pause,force); } int main(void) { sei(); // UART  9600    8  time_delay(2000);//  , esp     -  UCSR0A=0; UCSR0B=0b10011000;// a UART UCSR0C=0b00000110; UBRR0L=51;// 8  9600  UART UBRR0H=0; //   INT0   2   10 //        PCICR|=(1&lt;&lt;PCIE1);//   14-8 PCMSK1|=(1&lt;&lt;PCINT10);//    INT10 DDRC&amp;=~(1&lt;&lt;PORTC2); DDRB=0b00111110;//PB1-PB4    , PB5      DDRD=0b00000100; // PD2      //SET INTERRUPT FROM TIMER1 AND SET TIMER1 GTCCR=0;//RESET PRESCALER TCCR1A=0;//I/O NORMAL WORK TCCR1C=0; TCCR1B=0B00001100;//1/256 PRESCALING AND CTC MODE TCNT1H=0;//RESET TIMER1 TCNT1L=0; TIMSK1=0B00000010;//SET COMPARE A INTERRUPT ENABLED OCR1AH=0x79;//SET TIME CONSTANT IN COMPARE REGISTER OCR1AL=0xa7;// 31143    7 972 608  TCCR0B=0b00000010;// 8        0  255 while (1) { begining: time_delay(1000); if (first_byte!=0) { UDR0=first_byte;//      .     (100,101,102)    } if (first_byte==100)//   (     NTP  { hour=second_byte;//  if (hour&gt;12)//      12  (24  ) { hour=hour-12; } if (hour==0) { hour=12; } minute=third_byte;//  secund=firth_byte;//  power=fifth_byte;//   first_byte=0;//   second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; change_mode=false; goto clock_mode; } if (first_byte==101)//   { power=second_byte; pause_between_boom=third_byte; first_byte=0; second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; change_mode=false; goto random_mode; } if (first_byte==102)//  { power=second_byte; first_byte=0; second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; change_mode=false; goto hand_mode; } //     ,      first_byte=0; second_byte=0; third_byte=0; firth_byte=0; fifth_byte=0; goto begining; clock_mode: while(change_mode==false) { if (boom)//   { for(uint8_t i =0;i&lt;hour;i++) { if ((hour24&gt;21)|(hour24&lt;10))//  { sound(3,0);//   10 (),  0  boom=false; } else { sound(power,0);//   10 (),  0  boom=false; } } } } goto begining; random_mode: while(change_mode==false) { uint8_t random_power = TCNT0;//      1 uint8_t random_pause = TCNT1L;//      1 random_pause=TCNT0;//      1 random_power=random_power/25; if (random_power&lt;5) { random_power=random_power+2;//      } random_pause=(random_pause/25)+pause_between_boom; UDR0=random_pause; time_delay(100); sound(random_power,random_pause); } goto begining; hand_mode: sound(power,0); goto begining; } }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles funktioniert einfach. Nach der Initialisierung der Peripherieger√§te geht der Mikrocontroller in eine Endlosschleife und wartet auf einen UART-Befehl. Die Befehlscodes lauten wie folgt: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100-Takt- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modus 101 Zufallsmodus </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">102 Manueller Modus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da der AVR keine Rolle spielt, woher der Befehl stammt, wird der erste Befehl von ESP8266 nach dem Einschalten ausgel√∂st. Wie bereits erw√§hnt, klammert sich das ESP-Modul an das Netzwerk, zieht die genaue Zeit vom NTP-Server und sendet sie an den Mikrocontroller. Somit tritt die Arduinka zuerst in den Taktschlagmodus ein. Durch Unterbrechen des T1-Zeitz√§hlers werden Sekunden, Minuten und Stunden gez√§hlt und bei Bedarf Funktionen aufgerufen, um den Schrittmotor hin und her zu stellen, um die Zeit zu verk√ºrzen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Unterbrechung durch den Reed-Schalter setzt den gleichen Nullpunkt, wenn sich der Hebel, der an der Klappe zieht, im Laufe der Zeit relativ zur Motorwelle zu bewegen beginnt. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Anwendung f√ºr den Computer.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Es basiert trotzdem auf denselben alten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nur die visuelle Darstellung √§ndert sich hier.</font></font><br><br><img src="https://habrastorage.org/webt/cl/fo/k4/clfok4_1edajbwxdondtz9h9dpk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trotzdem steigt der Kommunikationskanal mit AVR √ºber HTTP- und UDP-Verbindungen an. Bei Bedarf werden dann der erforderliche Steuerbefehl und die zugeh√∂rigen Daten in Form von UDP-Paketen gesendet. Nat√ºrlich w√§re es korrekter, die Steuerung und die Daten auf verschiedenen Kan√§len zu trennen, aber erstens m√ºssen Sie den LUA-Code im Bootloader bearbeiten, und zweitens macht dies keinen Sinn, da der Mikrocontroller und die Befehle und Daten einzeln und empfangen werden der gleiche UART. Und doch verwirrt AVR sie manchmal (selten). Dies ist jedoch nicht be√§ngstigend, denn wenn der Mikrocontroller den Befehl nicht erkennt, f√ºhrt er ihn nicht aus und wird auch in der Computeranwendung dar√ºber informiert, wodurch Sie aufgefordert werden, die Eingabe zu wiederholen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code ist bei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github erh√§ltlich.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen schlagen tibetische M√∂nche nicht nur mit Klatschern in Klangschalen. </font><font style="vertical-align: inherit;">Wenn Sie den Hammer vorsichtig am Rand der Sch√ºssel entlang fahren, entsteht ohne Klopfen ein wunderbarer Klang, der die </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√∂ttliche</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Natur der Resonanz unter sich hat. </font><font style="vertical-align: inherit;">Aber das ist eine wirklich ernsthafte Herausforderung f√ºr Arduino.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415629/">https://habr.com/ru/post/de415629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415619/index.html">Apple und Samsung schlie√üen 7-j√§hrigen Patentkrieg ab</a></li>
<li><a href="../de415621/index.html">Bergbau√ºberwachungssystem</a></li>
<li><a href="../de415623/index.html">Die Dynamik des Vertikalfluges eines Flugzeugs ist leichter als Luft</a></li>
<li><a href="../de415625/index.html">Kubernetes: Webinar (4. Juli um 19:30 Uhr) und intensiv (3.-5. August)</a></li>
<li><a href="../de415627/index.html">Wie (nicht) muss man ein Arschloch sein: die Geschichte eines technischen Direktors</a></li>
<li><a href="../de415637/index.html">Wie Yandex k√ºnstliche Intelligenz einsetzte, um Webseiten zu √ºbersetzen</a></li>
<li><a href="../de415641/index.html">Verkostung von M√∂wen. Im Arsenal eines Radiohackers</a></li>
<li><a href="../de415643/index.html">Magento Meetup Kharkov - Videoberichte</a></li>
<li><a href="../de415645/index.html">Ein Blick auf Highload ++ aus Sibirien</a></li>
<li><a href="../de415647/index.html">Ab dem 1. Juli m√ºssen Internetdienste Nachrichten von russischen Benutzern 6 Monate lang speichern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>