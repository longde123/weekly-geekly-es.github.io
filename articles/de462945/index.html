<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé© ü§∏üèΩ üçÇ Generieren Sie Einmalkennw√∂rter f√ºr 2FA in JS mithilfe der Web Crypto API üÜë üî∑ üëÇüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 


 Zwei-Faktor-Authentifizierung ist heute √ºberall. Dank ihr reicht es nicht aus, nur ein Passwort zu stehlen, um ein Konto zu stehlen. Un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generieren Sie Einmalkennw√∂rter f√ºr 2FA in JS mithilfe der Web Crypto API</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462945/"><h2 id="vvedenie">  Einf√ºhrung </h2><br><p>  Zwei-Faktor-Authentifizierung ist heute √ºberall.  Dank ihr reicht es nicht aus, nur ein Passwort zu stehlen, um ein Konto zu stehlen.  Und obwohl seine Anwesenheit nicht garantiert, dass Ihr Konto nicht entfernt wird, um es zu umgehen, ist ein komplexerer und mehrstufiger Angriff erforderlich.  Wie Sie wissen, ist es umso wahrscheinlicher, dass etwas nicht funktioniert, je komplizierter etwas auf dieser Welt ist. </p><br><p> Ich bin sicher, dass jeder, der diesen Artikel liest, mindestens einmal in seinem Leben eine Zwei-Faktor-Authentifizierung (im Folgenden: 2FA, eine lange, schmerzhafte Phrase) verwendet hat.  Heute lade ich Sie ein, herauszufinden, wie diese Technologie funktioniert, die t√§glich unz√§hlige Konten sch√ºtzt. </p><br><p>  Aber f√ºr den Anfang k√∂nnen Sie sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> ansehen, was wir heute machen werden. </p><a name="habracut"></a><br><h2 id="osnovy">  Die Grundlagen </h2><br><p>  Das erste, was bei Einmalkennw√∂rtern erw√§hnenswert ist, ist, dass es sich um zwei Typen handelt: <strong>HOTP</strong> und <strong>TOTP</strong> .  <strong>HMAC-basiertes Einmalkennwort</strong> und <strong>zeitbasiertes OTP</strong> .  TOTP ist nur ein Add-On zu HOTP. Lassen Sie uns zun√§chst √ºber einen einfacheren Algorithmus sprechen. </p><br><p>  HOTP wird durch die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC4226-</a> Spezifikation beschrieben.  Es ist klein, nur 35 Seiten und enth√§lt alles, was Sie brauchen: eine formale Beschreibung, eine Beispielimplementierung und Testdaten.  Schauen wir uns die Grundkonzepte an. </p><br><p>  Was ist <strong>HMAC</strong> ?  HMAC steht auf Russisch f√ºr <strong>Hash-basierten Nachrichtenauthentifizierungscode</strong> oder "Nachrichtenauthentifizierungscode mit Hash-Funktionen".  MAC ist ein Mechanismus zum √úberpr√ºfen des Absenders einer Nachricht.  Der <strong>MAC-</strong> Algorithmus generiert ein <strong>MAC-Tag unter</strong> Verwendung eines geheimen Schl√ºssels, der nur dem Sender und dem Empf√§nger bekannt ist.  Nach Erhalt der Nachricht k√∂nnen Sie das MAC-Tag selbst generieren und die beiden Tags vergleichen.  Wenn sie zusammenfallen - alles ist in Ordnung, gab es keine St√∂rung im Kommunikationsprozess.  Als Bonus k√∂nnen Sie auf die gleiche Weise √ºberpr√ºfen, ob die Nachricht w√§hrend der √úbertragung besch√§digt wurde.  Nat√ºrlich wird es nicht funktionieren, Interferenzen von Sch√§den zu unterscheiden, aber die Tatsache der Informationskorruption reicht aus. </p><br><p><img src="https://habrastorage.org/webt/ug/0m/yf/ug0myfmi3y1iwrq3csxfsp1j6c0.png" alt="MAC-Tag"></p><br><p>  Was ist ein Hash?  Ein Hash ist das Ergebnis der Anwendung einer Hash-Funktion auf eine Nachricht.  Hash-Funktionen nehmen Ihre Daten und machen sie zu einer Zeichenfolge fester L√§nge.  Ein gutes Beispiel ist die bekannte <strong>MD5-</strong> Funktion, die h√§ufig zur √úberpr√ºfung der Dateiintegrit√§t verwendet wird. </p><br><p>  <strong>MAC</strong> selbst ist kein spezifischer Algorithmus, sondern nur ein allgemeiner Begriff.  <strong>HMAC</strong> wiederum ist bereits eine konkrete Implementierung.  Insbesondere HMAC- <em>X</em> , wobei X eine der kryptografischen Hash-Funktionen ist.  HMAC akzeptiert zwei Argumente: einen geheimen Schl√ºssel und eine Nachricht, mischt sie auf eine bestimmte Weise, wendet die ausgew√§hlte Hash-Funktion zweimal an und gibt ein MAC-Tag zur√ºck. </p><br><p>  Wenn Sie sich gerade √ºberlegen, was dies alles mit Einmalkennw√∂rtern zu tun hat - keine Sorge, wir haben fast den Hauptpunkt erreicht. </p><br><p>  Gem√§√ü der Spezifikation wird HOTP basierend auf zwei Werten berechnet: </p><br><ul><li>  K ist der <strong>geheime Schl√ºssel</strong> , den Client und Server kennen.  Es sollte mindestens 128 Bit lang und vorzugsweise 160 Bit lang sein und bei der Konfiguration von 2FA erstellt werden. </li><li>  <strong>C</strong> ist der <strong>Z√§hler</strong> . </li></ul><br><p>  Ein Z√§hler ist ein 8-Byte-Wert, der zwischen Client und Server synchronisiert wird.  Es wird aktualisiert, wenn Sie neue Passw√∂rter generieren.  Im HOTP-Schema wird jedes Mal, wenn Sie ein neues Kennwort generieren, ein clientseitiger Z√§hler erh√∂ht.  Auf der Serverseite jedes Mal, wenn das Kennwort die Validierung erfolgreich besteht.  Da es m√∂glich ist, ein Kennwort zu generieren, es aber nicht zu verwenden, l√§sst der Server den Z√§hlerwert im Fenster etwas weiter laufen.  Wenn Sie jedoch im HOTP-Schema zu viel mit dem Passwortgenerator spielen, m√ºssen Sie ihn erneut synchronisieren. </p><br><p>  Also.  Wie Sie wahrscheinlich bemerkt haben, nimmt HMAC auch zwei Argumente an.  RFC4226 definiert die HOTP-Generierungsfunktion wie folgt: </p><br><pre><code class="plaintext hljs">HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))</code> </pre> <br><p>  Erwartungsgem√§√ü wird <strong>K</strong> als geheimer Schl√ºssel verwendet.  Der Z√§hler wird wiederum als Nachricht verwendet.  Nachdem die HMAC-Funktion ein MAC-Tag generiert hat, zieht die mysteri√∂se Funktion " <code>Truncate</code> das uns bereits bekannte Einmalkennwort heraus, das Sie in Ihrer Generatoranwendung oder auf dem Token sehen. </p><br><p>  Beginnen wir mit dem Schreiben des Codes und k√ºmmern uns um den Rest. </p><br><h2 id="plan-realizacii">  Umsetzungsplan </h2><br><p>  Um Einmalkennw√∂rter zu erhalten, m√ºssen wir diese Schritte ausf√ºhren. </p><br><p><img src="https://habrastorage.org/webt/tl/v7/br/tlv7brjdmq9e7s-1rmc2bxpkrfm.png" alt="Implementierung"></p><br><ul><li>  Generieren Sie einen HMAC-SHA1-Hash aus den Parametern <strong>K</strong> und <strong>C.</strong>  Dies ist eine 20-Byte-Zeichenfolge. </li><li>  Ziehen Sie 4 Bytes auf eine bestimmte Weise aus dieser Zeichenfolge. </li><li>  Konvertieren Sie den herausgezogenen Wert in eine Zahl und teilen Sie ihn durch 10 ^ n, wobei n = die Anzahl der Stellen im Einmalkennwort ist (normalerweise n = 6).  Und schlie√ülich nehmen Sie den Rest dieser Abteilung.  Dies wird unser Passwort sein. </li></ul><br><p>  Das klingt nicht zu schwer, oder?  Beginnen wir mit der Hash-Generation. </p><br><h2 id="generiruem-hmac-sha1">  Generieren Sie HMAC-SHA1 </h2><br><p>  Dies ist m√∂glicherweise der einfachste der oben aufgef√ºhrten Schritte.  Wir werden nicht versuchen, den Algorithmus selbst neu zu erstellen (wir m√ºssen niemals versuchen, etwas aus der Kryptographie selbst zu implementieren).  Stattdessen verwenden wir die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><strong>Web Crypto API</strong></a> .  Das kleine Problem ist, dass diese Spezifikations-API nur unter Secure Context (HTTPS) verf√ºgbar ist.  F√ºr uns ist dies mit der Tatsache behaftet, dass wir es nicht verwenden k√∂nnen, ohne HTTPS auf dem Entwicklungsserver einzurichten.  Ein bisschen Geschichte und Diskussion dar√ºber, wie dies die richtige Entscheidung ist, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </p><br><p>  Gl√ºcklicherweise k√∂nnen Sie in Firefox Web Crypto in einem unsicheren Kontext verwenden und m√ºssen das Rad nicht neu erfinden oder in Bibliotheken von Drittanbietern ziehen.  F√ºr die Entwicklung einer Demo empfehle ich daher die Verwendung von FF. </p><br><p>  Die Crypto-API selbst ist in <code>window.crypto.subtle</code> definiert.  Wenn Sie vom Namen √ºberrascht sind, zitiere ich aus der Spezifikation: </p><br><blockquote>  Die API wird als <code>SubtleCrypto</code> , da viele der Algorithmen spezifische Verwendungsanforderungen haben.  Nur wenn diese Anforderungen erf√ºllt sind, behalten sie ihre Haltbarkeit. </blockquote><p>  Lassen Sie uns die Methoden durchgehen, die wir brauchen.  Hinweis: Alle hier genannten Methoden sind asynchron und geben <code>Promise</code> . </p><br><p>  Erstens ben√∂tigen wir die <code>importKey</code> Methode, da wir unseren privaten Schl√ºssel verwenden und ihn nicht im Browser generieren.  <code>importKey</code> 5 Argumente: </p><br><pre> <code class="javascript hljs">importKey( format, keyData, algorithm, extractable, usages );</code> </pre> <br><p>  In unserem Fall: </p><br><ul><li>  <code>format</code> wird <code>'raw'</code> , d.h.  Wir werden den Schl√ºssel als <code>ArrayBuffer</code> Byte-Array <code>ArrayBuffer</code> . </li><li>  <code>keyData</code> ist der gleiche ArrayBuffer.  Sehr bald werden wir dar√ºber sprechen, wie man es generiert. </li><li>  <code>algorithm</code> wird gem√§√ü der Spezifikation <code>HMAC-SHA1</code> .  Dieses Argument muss mit dem Format von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">HmacImportParams √ºbereinstimmen</a> . </li><li>  <code>extractable</code> auf false, da wir nicht vorhaben, den geheimen Schl√ºssel zu exportieren </li><li>  Und schlie√ülich brauchen wir ausgerechnet nur das <code>'sign'</code> . </li></ul><br><p>  Unser geheimer Schl√ºssel wird eine lange zuf√§llige Zeichenfolge sein.  In der realen Welt kann dies eine Folge von Bytes sein, die m√∂glicherweise nicht druckbar sind. Der Einfachheit halber werden wir in diesem Artikel jedoch eine Zeichenfolge betrachten.  Um es in <code>ArrayBuffer</code> zu konvertieren, <code>ArrayBuffer</code> wir die <code>TextEncoder</code> Schnittstelle.  Damit wird der Schl√ºssel in zwei Codezeilen vorbereitet: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextEncoder(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secretBytes = encoder.encode(secret);</code> </pre> <br><p>  Nun lassen Sie uns alles zusammenf√ºgen: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Crypto = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.crypto.subtle; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> encoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TextEncoder(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> secretBytes = encoder.encode(secret); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Crypto.importKey( <span class="hljs-string"><span class="hljs-string">'raw'</span></span>, secretBytes, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'HMAC'</span></span>, <span class="hljs-attr"><span class="hljs-attr">hash</span></span>: { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'SHA-1'</span></span> } }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, [<span class="hljs-string"><span class="hljs-string">'sign'</span></span>] );</code> </pre> <br><p>  Gro√üartig!  Kryptographie wurde vorbereitet.  Jetzt werden wir uns um den Z√§hler k√ºmmern und schlie√ülich die Nachricht unterschreiben. </p><br><p>  Gem√§√ü der Spezifikation sollte unser Z√§hler 8 Byte lang sein.  Wir werden wieder damit arbeiten, wie mit <code>ArrayBuffer</code> .  Um es in diese Form zu √ºbersetzen, verwenden wir den Trick, der normalerweise in JS verwendet wird, um Nullen in den oberen Ziffern einer Zahl zu speichern.  Danach werden wir jedes Byte mithilfe einer <code>DataView</code> in einen <code>ArrayBuffer</code> .  Beachten Sie, dass das Format <strong>laut</strong> Spezifikation f√ºr alle Bin√§rdaten <strong>Big Endian ist</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">padCounter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ArrayBuffer</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bView = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">DataView</span></span>(buffer); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> byteString = <span class="hljs-string"><span class="hljs-string">'0'</span></span>.repeat(<span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 8 bytes const bCounter = (byteString + counter.toString(2)).slice(-64); for (let byte = 0; byte &lt; 64; byte += 8) { const byteValue = parseInt(bCounter.slice(byte, byte + 8), 2); bView.setUint8(byte / 8, byteValue); } return buffer; }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/w0/cs/uh/w0csuhhkbyxccigknindlgpf3t0.png" alt="Pad Z√§hler"></p><br><p>  Nachdem Sie den Schl√ºssel und den Z√§hler vorbereitet haben, k√∂nnen Sie einen Hash generieren!  Dazu verwenden wir die <code>sign</code> von <code>SubtleCrypto</code> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterArray = padCounter(counter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> HS = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Crypto.sign(<span class="hljs-string"><span class="hljs-string">'HMAC'</span></span>, key, counterArray);</code> </pre> <br><p>  Damit haben wir den ersten Schritt abgeschlossen.  Am Ausgang erhalten wir einen etwas mysteri√∂sen Wert namens HS.  Und obwohl dies nicht der beste Name f√ºr eine Variable ist, wird sie (und einige der folgenden) in der Spezifikation so genannt.  Wir lassen diese Namen, um den Vergleich des Codes zu vereinfachen.  Was weiter? </p><br><blockquote>  Schritt 2: Generieren Sie eine 4-Byte-Zeichenfolge (Dynamic Truncation). <br>  Sei Sbits = DT (HS) // DT, unten definiert, <br>  // gibt eine 31-Bit-Zeichenfolge zur√ºck </blockquote><p>  DT steht f√ºr Dynamic Truncation.  Und so funktioniert es: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DT</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HS</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// First we take the last byte of our generated HS and extract last 4 bits out of it. // This will be our _offset_, a number between 0 and 15. const offset = HS[19] &amp; 0b1111; // Next we take 4 bytes out of the HS, starting at the offset const P = ((HS[offset] &amp; 0x7f) &lt;&lt; 24) | (HS[offset + 1] &lt;&lt; 16) | (HS[offset + 2] &lt;&lt; 8) | HS[offset + 3] // Finally, convert it into a binary string representation const pString = P.toString(2); return pString; }</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/80/0n/5x/800n5xjrszlpbiriupg6acom-oq.png" alt="K√ºrzung"></p><br><p>  Beachten Sie, wie wir bitweise UND auf das erste Byte von HS angewendet haben.  <code>0x7f</code> im Bin√§rsystem ist <code>0b01111111</code> , also verwerfen wir im Wesentlichen nur das erste Bit.  In JS endet hier die Bedeutung dieses Ausdrucks, in anderen Sprachen wird jedoch auch das Vorzeichenbit abgeschnitten, um Verwechslungen zwischen positiven und negativen Zahlen zu beseitigen und diese Zahl als vorzeichenlos darzustellen. </p><br><p>  Fast fertig!  Es bleibt nur, den von DT erhaltenen Wert in eine Zahl umzuwandeln und zum dritten Schritt weiterzuleiten. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">truncate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uKey</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Sbits = DT(uKey); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Snum = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(Sbits, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Snum; }</code> </pre> <br><p>  Der dritte Schritt ist auch ziemlich klein.  Alles, was getan werden muss, ist, die resultierende Zahl durch <code>10 ** (   )</code> zu teilen und dann den Rest dieser Teilung zu √ºbernehmen.  Daher schneiden wir die letzten N Ziffern von dieser Zahl ab.  Gem√§√ü der Spezifikation sollte unser Code in der Lage sein, mindestens sechsstellige Passw√∂rter und m√∂glicherweise sieben- und achtstellige Passw√∂rter abzurufen.  Theoretisch h√§tten wir, da dies eine 31-Bit-Zahl ist, 9 Zeichen herausziehen k√∂nnen, aber in Wirklichkeit habe ich pers√∂nlich nie mehr als 6 Zeichen gesehen.  Und Sie? </p><br><p>  Der Code f√ºr die endg√ºltige Funktion, der alle vorherigen kombiniert, sieht in diesem Fall ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateHOTP</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">secret, counter</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> generateKey(secret, counter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(key); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Snum = truncate(uKey); <span class="hljs-comment"><span class="hljs-comment">// Make sure we keep leading zeroes const padded = ('000000' + (Snum % (10 ** 6))).slice(-6); return padded; }</span></span></code> </pre> <br><p>  Hurra!  Aber wie kann man jetzt √ºberpr√ºfen, ob unser Code korrekt ist? </p><br><h2 id="testirovanie">  Testen </h2><br><p>  Um die Implementierung zu testen, verwenden wir Beispiele aus dem RFC.  Anhang D enth√§lt Testwerte f√ºr den geheimen Schl√ºssel <code>"12345678901234567890"</code> und Z√§hlerwerte von 0 bis 9. Es werden auch HMAC-Hashes und Zwischenergebnisse der Funktion "Abschneiden" gez√§hlt.  Ziemlich n√ºtzlich zum Debuggen aller Schritte des Algorithmus.  Hier ist ein kleines Beispiel f√ºr diese Tabelle (nur der Z√§hler und HOTP sind noch √ºbrig): </p><br><pre> <code class="plaintext hljs"> Count HOTP 0 755224 1 287082 2 359152 3 969429 ...</code> </pre> <br><p>  Wenn Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> noch nicht gesehen haben, ist jetzt die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">richtige</a> Zeit daf√ºr.  Sie k√∂nnen darin die Werte aus dem RFC eintreiben.  Und komm zur√ºck, weil wir TOTP starten. </p><br><h2 id="totp">  Totp </h2><br><p>  So kamen wir endlich zum moderneren Teil von 2FA.  Wenn Sie Ihren Einmalkennwortgenerator √∂ffnen und einen kleinen Timer sehen, der z√§hlt, wie viel mehr Code g√ºltig ist, handelt es sich um TOTP.  Was ist der Unterschied? </p><br><p>  <strong>Zeitbasiert</strong> bedeutet, dass anstelle eines statischen Werts die aktuelle Zeit als Z√§hler verwendet wird.  Oder genauer gesagt das "Intervall" (Zeitschritt).  Oder sogar die Nummer des aktuellen Intervalls.  Um dies zu berechnen, nehmen wir die Unix-Zeit (die Anzahl der Millisekunden seit Mitternacht am 1. Januar 1970 UTC) und teilen die G√ºltigkeit des Passworts durch das Fenster (normalerweise 30 Sekunden).  Der Server toleriert normalerweise kleine Abweichungen aufgrund einer unvollst√§ndigen Taktsynchronisation.  Normalerweise 1 Intervall hin und her je nach Konfiguration. </p><br><p>  Dies ist nat√ºrlich viel sicherer als das HOTP-Schema.  In einem zeitgebundenen Schema √§ndert sich der g√ºltige Code alle 30 Sekunden, auch wenn er nicht verwendet wurde.  Im urspr√ºnglichen Algorithmus wird ein g√ºltiges Kennwort durch den aktuellen Z√§hlerwert im Fenster Server + Toleranz bestimmt.  Wenn Sie sich nicht authentifizieren, wird das Passwort nicht auf unbestimmte Zeit ge√§ndert.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen zu</a> TOTP finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RFC6238</a> . </p><br><p>  Da das zeitbasierte Schema eine Erg√§nzung zum urspr√ºnglichen Algorithmus darstellt, m√ºssen wir keine √Ñnderungen an der urspr√ºnglichen Implementierung vornehmen.  Wir werden <code>requestAnimationFrame</code> und f√ºr jeden Frame pr√ºfen, ob wir uns noch innerhalb des Zeitintervalls befinden.  Wenn nicht, generieren Sie einen neuen Z√§hler und berechnen Sie den HOTP erneut.  Wenn Sie den gesamten Steuercode weglassen, sieht die L√∂sung ungef√§hr so ‚Äã‚Äãaus: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> stepWindow = <span class="hljs-number"><span class="hljs-number">30</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 30 seconds in ms let lastTimeStep = 0; const updateTOTPCounter = () =&gt; { const timeSinceStep = Date.now() - lastTimeStep * stepWindow; const timeLeft = Math.ceil(stepWindow - timeSinceStep); if (timeLeft &gt; 0) { return requestAnimationFrame(updateTOTPCounter); } timeStep = getTOTPCounter(); lastTimeStep = timeStep; &lt;...update counter and regenerate...&gt; requestAnimationFrame(updateTOTPCounter); }</span></span></code> </pre> <br><h2 id="poslednie-shtrihi--podderzhka-qr-kodov">  Finishing Touches - QR-Code-Unterst√ºtzung </h2><br><p>  Wenn wir 2FA konfigurieren, scannen wir normalerweise die Anfangsparameter mit einem QR-Code.  Es enth√§lt alle erforderlichen Informationen: das ausgew√§hlte Schema, den geheimen Schl√ºssel, den Kontonamen, den Anbieternamen und die Anzahl der Ziffern im Kennwort. </p><br><p>  In einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Artikel habe</a> ich dar√ºber gesprochen, wie Sie QR-Codes mithilfe der <code>getDisplayMedia</code> API direkt vom Bildschirm aus <code>getDisplayMedia</code> .  Basierend auf diesem Material habe ich eine kleine Bibliothek erstellt, die wir jetzt verwenden werden.  Die Bibliothek hei√üt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stream-Display</a> und zus√§tzlich verwenden wir das wunderbare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jsQR-</a> Paket. </p><br><p>  Der QR-codierte Link hat das folgende Format: </p><br><pre> <code class="plaintext hljs">otpauth://TYPE/LABEL?PARAMETERS</code> </pre> <br><p>  Zum Beispiel: </p><br><pre> <code class="plaintext hljs">otpauth://totp/label?secret=oyu55d4q5kllrwhy4euqh3ouw7hebnhm5qsflfcqggczoafxu75lsagt&amp;algorithm=SHA1&amp;digits=6&amp;period=30</code> </pre> <br><p>  Ich werde den Code weglassen, der den Prozess zum Starten der Bildschirmaufnahme und -erkennung einrichtet, da dies alles in der Dokumentation zu finden ist.  Stattdessen k√∂nnen Sie diesen Link folgenderma√üen analysieren: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> setupFromQR = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> URL(data); <span class="hljs-comment"><span class="hljs-comment">// drop the "//" and get TYPE and LABEL const [scheme, label] = url.pathname.slice(2).split('/'); const params = new URLSearchParams(url.search); const secret = params.get('secret'); let counter; if (scheme === 'hotp') { counter = params.get('counter'); } else { stepWindow = parseInt(params.get('period'), 10) * 1000; counter = getTOTPCounter(); } }</span></span></code> </pre> <br><p>  In der realen Welt ist der geheime Schl√ºssel eine Base- <strong>32</strong> (!) -Codierte Zeichenfolge, da einige Bytes m√∂glicherweise nicht druckbar sind.  Der Einfachheit halber lassen wir diesen Punkt jedoch weg.  Leider konnte ich keine Informationen finden, warum Base-32 oder nur ein solches Format.  Anscheinend gibt es keine offizielle Spezifikation f√ºr dieses URL-Format, und das Format selbst wurde von Google gepr√§gt.  Hier k√∂nnen Sie ein wenig √ºber ihn lesen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a> </p><br><p>  Um Test-QR-Codes zu generieren, empfehle ich die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">FreeOTP</a> . </p><br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Und das ist alles!  Vergessen Sie nicht, sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> anzuschauen.  Es gibt auch einen Link zum Repository mit dem Code, der dahinter steckt. </p><br><p>  Heute haben wir eine ziemlich wichtige Technologie zerlegt, die wir t√§glich verwenden.  Ich hoffe du hast etwas Neues f√ºr dich gelernt.  Dieser Artikel hat viel l√§nger gedauert als ich dachte.  Es ist jedoch sehr interessant, eine Papierspezifikation in etwas Funktionierendes und Vertrautes zu verwandeln. </p><br><p>  Bis bald! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462945/">https://habr.com/ru/post/de462945/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462933/index.html">Funktionsweise der Internetblockierung: Ein √úberblick √ºber moderne Methoden anhand eines realen Beispiels</a></li>
<li><a href="../de462935/index.html">Wie kann man bei der Arbeit in einem Gro√üraumb√ºro konzentriert bleiben?</a></li>
<li><a href="../de462937/index.html">Das Konzept der persistenten Struktur zur Steuerung der IT-Infrastruktur</a></li>
<li><a href="../de462939/index.html">Top 10 C ++ Russia-Berichte und Open Access-Konferenz-Playlist</a></li>
<li><a href="../de462943/index.html">Jagen Sie den Wumpus oder erleben Sie das Schreiben eines klassischen Android-Spiels</a></li>
<li><a href="../de462947/index.html">Die Geschichte, wie PVS-Studio einen Fehler in der in ... PVS-Studio verwendeten Bibliothek gefunden hat</a></li>
<li><a href="../de462949/index.html">Die Geschichte, wie PVS-Studio einen Fehler in der in ... PVS-Studio verwendeten Bibliothek gefunden hat</a></li>
<li><a href="../de462951/index.html">Wo eine Person Formen sieht, sieht KI Texturen</a></li>
<li><a href="../de462955/index.html">Digitale Transformation der Schulung und Zertifizierung von Au√üendienstmitarbeitern</a></li>
<li><a href="../de462957/index.html">Vor- und Nachteile: Die Preisschwelle f√ºr .org ist weiterhin aufgehoben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>