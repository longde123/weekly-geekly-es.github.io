<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙁 👨‍👨‍👧‍👦 ⌨️ 创建用于劫持dll操作检查的代理dll 👩🏼‍🏫 🎄 📢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当我检查软件安全性时，要检查的要点之一是使用动态库。 诸如劫持DLL（“ dll欺骗”或“ dll拦截”）之类的攻击非常罕见。 这很可能是因为Windows开发人员正在添加安全机制来防止攻击，而软件开发人员在安全性方面更加谨慎。 但是更有趣的是目标软件容易受到攻击的情况。 

 简要描述攻击，劫持D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>创建用于劫持dll操作检查的代理dll</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pm/blog/449904/"> 当我检查软件安全性时，要检查的要点之一是使用动态库。 诸如劫持DLL（“ dll欺骗”或“ dll拦截”）之类的攻击非常罕见。 这很可能是因为Windows开发人员正在添加安全机制来防止攻击，而软件开发人员在安全性方面更加谨慎。 但是更有趣的是目标软件容易受到攻击的情况。 <br><br> 简要描述攻击，劫持DLL造成了一种情况，其中某些可执行文件试图加载dll，但是攻击者干预了此过程，而不是预期的库，而是使用从攻击者获得的有效负载加载了特别准备的dll。 结果，来自dll的代码将以已启动应用程序的权限执行，因此通常会选择具有较高权限的应用程序作为目标。 <br><br> 为了正确加载该库，必须满足许多条件：可执行文件的位大小和该库必须匹配，并且如果在应用程序启动时加载了该库，则dll必须导出该应用程序期望导入的所有功能。 通常，一次导入是不够的-非常希望应用程序在加载dll之后继续其工作。 为此，准备好的库的功能必须与原始库的功能相同。 最简单的方法是将函数调用从一个库传递到另一个库。 这些是称为代理dll的dll。 <br><br><img src="https://habrastorage.org/webt/9l/cw/yb/9lcwyb3oo0wolz45digsbnh6wmw.jpeg"><br><br> 削减部分将包括创建代码库和实用程序两种形式的创建此类库的选项。 <br><a name="habracut"></a><br>
<h2>  <font color="orange">小理论回顾</font> </h2><br> 库通常是使用LoadLibrary函数加载的，库名会传递到该函数中。 如果通过名称而不是名称传递完整路径，则应用程序将尝试加载指定的库。 例如，调用LoadLibrary（“ C：\ Windows \ system32 \ version.dll”）将加载指定的dll。 或者，如果该库不存在，则将不会加载该库。 <br><br><div class="spoiler">  <b class="spoiler_title">有点乏味</b> <div class="spoiler_text"> 如果某些dll已经加载到应用程序中，则不会再次加载。 鉴于几乎在所有exe文件的开头都加载了version.dll，实际上，上述调用实际上不会加载任何东西。 但是我们仍然考虑一般情况，将示例视为对某些抽象库的调用。 <br></div></div><br> 如果编写LoadLibrary（“ version.dll”），则完全是另一回事。 在正常情况下，结果将与之前的情况完全相同-C：\ Windows \ system32 \ version.dll将被加载，但并非如此简单。 <br><br> 首先，将搜索一个库，其<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">顺序</a>如下： <br><br><ol><li> 可执行文件夹 </li><li> 文件夹C：\ Windows \ System32 </li><li> 文件夹C：\ Windows \ System </li><li> 文件夹C：\ Windows </li><li> 文件夹设置为当前应用程序 </li><li>  PATH环境变量中的文件夹 </li></ol><br><div class="spoiler">  <b class="spoiler_title">一些乏味</b> <div class="spoiler_text"> 在64位系统上启动32位应用程序时，所有对C：\ Windows \ system32的调用都将转发到C：\ Windows \ SysWOW64。 这只是出于描述的准确性，从攻击者的角度来看，区别并不是特别重要。 <br></div></div><br> 运行exe文件时，操作系统将从文件导入部分加载所有库。 从一般意义上讲，我们可以假设OS强制文件调用LoadLibrary，并传递在import节中编写的所有库名。 由于在99.9％的情况下是名称而不是路径，因此当应用程序启动时，将在系统中搜索所有已加载的库。 <br><br> 从dll搜索位置的列表中，有两点对我们非常重要-1和6。如果将version.dll放在启动文件的同一文件夹中，则将加载已加载的文件而不是系统文件。 这种情况几乎从未遇到过，因为如果有机会放置库，那么很可能可以替换可执行文件本身。 但是，这种情况还是可能的。 例如，如果可执行文件位于可写文件夹中并且是具有自动启动功能的服务，则在服务本身运行时无法对其进行更改。 或者在启动之前通过校验和从外部检查启动的文件，然后仍然不能选择替换文件。 但是将库放在旁边将是非常真实的。 <br><br> 您可能无法在可执行文件旁边创建文件，但是可以创建文件夹。 在这种情况下，WinSxS重定向机制（也称为“ DotLocal”）可能会起作用。 <br><br><div class="spoiler">  <b class="spoiler_title">简要介绍DotLocal</b> <div class="spoiler_text"> 文件的清单可能包含对特定版本库的依赖。 在这种情况下，启动可执行文件（例如，将其命名为application.exe）时，操作系统将检查与文件本身相同的文件夹中是否存在名为application.exe.local的文件夹。 此文件夹应具有复杂名称的子文件夹，如amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.9600.19291_none_6248a9f3ecb5e89b，其中已经有comctl32.dll库。 库名称和文件夹名称信息应在清单中指出，这只是遇到的第一个过程的示例。 如果没有文件夹或文件，则该库将从C：\ Windows \ WinSxS中获取。 在示例中，C：\ Windows \ WinSxS \ amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.9600.19291_none_6248a9f3ecb5e89b \ comctl32.dll。 <br></div></div><br> 但这更多的是例外，而不是规则。 但是，当dll搜索达到列表中第6个数字时，情况确实很真实。 如果应用程序尝试加载不在系统上或文件旁边的dll，则所有搜索将最多上升6点，这可能是可写文件夹。 <br><br> 例如，典型的Python安装最常出现在C：\ Python（或close）文件夹中。  python安装程序本身建议将其文件夹添加到PATH系统变量。 因此，我们为发起攻击提供了一个很好的跳板-该文件夹可被所有用户写入，并且任何尝试加载不存在的库的尝试都会从PATH进入路径搜索。 <br><br> 现在理论已经完成，请考虑有效负载的创建-代理库本身。 <br><br><h2>  <font color="orange">第一种选择。</font>  <font color="orange">诚实的代理库</font> </h2><br> 让我们从一个相对简单的例子开始-我们将创建一个诚实的代理库。 在这种情况下，诚实意味着将显式注册dll中的所有函数，并且将为每个函数编写一个与原始库具有相同名称的函数调用。 使用这样的库对于被调用的代码将是完全透明的：如果它调用某些函数，则它将收到正确的答案，结果以及应并行执行的所有操作。 <br><br> 这是指向version.dll库的完成的示例（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a> ）的链接。 <br><br> 代码重点： <br><br><ul><li> 诚实地描述了原始库导出表中的所有函数原型。 </li><li> 原始库已加载，所有对我们函数的调用都被扔进了库中。 </li></ul><br>  <b>方便地</b> ，该应用程序可以继续正常运行，而不会遇到任何“特殊影响”。  <b>不方便的</b>是，我必须为每个函数编写一堆统一的代码，而且还要仔细检查原型的一致性。 <br><br><h2>  <font color="orange">第二种选择。</font>  <font color="orange">简化代码编写</font> </h2><br> 当处理像version.dll这样的库时，其中的导入表很小，只有17个函数，原型很简单，那么诚实的代理库是一个不错的选择。 <br><br><img src="https://habrastorage.org/webt/ws/cl/yv/wsclyv4uqz71puco7dp5jhsrhgq.png"><br><br> 但是，如果使用该库的代理服务器（例如bcrypt），则一切都会更加复杂。 这是她的导入表： <br><br><img src="https://habrastorage.org/webt/b7/1v/5e/b71v5exl1zruqbn_0xlidadlpfs.png"><br><br>  57个功能！ 以下是几个原型示例： <br><br><img src="https://habrastorage.org/webt/_5/du/ve/_5duve7awc84bk3btklrsqq6wzq.png"><br><img src="https://habrastorage.org/webt/7p/kq/5x/7pkq5xz7uxvpju2zcc3q4q78zcs.png"><br><br> 我们只能说没有什么是不可能的，但是为这样的库创建一个诚实的代理并不是一件令人愉快的事情。 <br><br> 如果您对函数作弊，则可以简化代码。 我们将库中的所有函数声明为__declspec（裸露），在正文中，我们将使用仅使原始库中的函数成为jmp的汇编代码。 这将使我们不必使用冗长的原型，而可以在没有视图参数的情况下在任何地方放置简单的公告： <br><br> 无效foo（） <br><br> 当应用程序调用我们的函数时，代理库将不会对寄存器和堆栈执行任何操作，从而使原始函数能够按需完成所有工作。 <br><br> 使用此方法的version.dll库的示例（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a> ）。 <br><br> 重点： <br><br><ul><li> 原始库已加载，所有对我们函数的调用均被抛入其中。 函数体和加载都包装在宏中。 </li></ul><br>  <b>借助</b>宏，可以<b>方便</b> ，正确地运行应用程序，甚至可以轻松描述甚至很多功能。  <b>不便之处</b>是x64中出现了意外的情况。  Visual Studio（如果我没有记错的话，自2012年以来一直存在）禁止在64位代码中使用裸露和asm插入。 从头开始编写代理时，每个函数都必须验证它是否在def文件中描述，是否已加载原始文件以及函数的主体是否已描述。 <br><br><h2>  <font color="orange">第三种选择。</font>  <font color="orange">我们一般丢掉身体</font> </h2><br> 使用裸露建议另一种选择。 您可以创建一个导入表，该表的所有功能都将引用一行真实的代码： <br><br> 无效nop（）{} <br><br> 这样的库将由应用程序加载，但将不起作用。 调用任何函数时，堆栈很可能会被撕裂或发生其他问题。 但这并不总是不好的-例如，如果dll注入的目标只是简单地使用必要的权限运行代码，则足以执行DllMain代理库中的有效负载并立即安静地终止应用程序。 在这种情况下，将不会真正调用函数，也不会出现错误。 <br><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github</a>上的一个例子，再次是version.dll。 <br><br> 代码重点： <br><br><ul><li>  def文件中的所有功能都引用一个nop功能。 </li></ul><br>  <b>方便地，</b>这样的代理库只编写了几分钟。  <b>被</b>调用的应用程序停止工作<b>是很不方便</b>的。 <br><br><h2>  <font color="orange">第四个选项。</font>  <font color="orange">取现成的工具</font> </h2><br> 编写dll很好，但并不总是很方便，而且也不是很快，因此您应该考虑使用自动选项。 <br><br> 您可以沿用旧病毒的路径-获取我们要创建其代理的库，在其中创建代码的可执行部分，在其中写下有效负载，并将入口点更改为该部分。 这不是最简单的方法，因为您可能会意外破坏某些内容，因此必须编写汇编程序，记住PE文件的设备。 这不是我们的方式。 <br><br> 要操作dll劫持，我们将添加另一个dll劫持。 <br><br><img src="https://habrastorage.org/webt/lo/rr/ux/lorruxyxi0m-fjomp-j22b18are.jpeg"><br><br> 这是相对容易做到的。 我们复制要制作其代理的库，然后将具有任意功能的dll添加到此副本的导入表中。 现在下载将沿着链进行-在可执行文件的开始处，将加载代理dll，这将加载指定的库本身。 <br><br>  “嘿，您将加载一个库替换为另一个。 有什么意义？ 都是一样的，必须对dll进行编码！ 一切都正确，但是仍然有一种感觉。 现在，对具有有效负载的库的需求将减少。 您可以指定任何名称，主要是仅导出一个可以具有任何原型的函数。 在导入表中输入库和函数的主要名称。 <br><br> 具有有效负载的库可以在任何情况下都可以使用。 <br><br> 您可以使用许多PE编辑器（例如CFF Explorer或pe-bear）修改导入表。 对于我自己，我在C＃中编写了一个小实用程序，该程序可以纠正表而没有不必要的手势。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github上的</a>源代码， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">发布版本中的</a> binar。 <br><br><h2>  <font color="orange">结论</font> </h2><br> 在本文中，我尝试介绍了自己创建代理dll的基本方法。 剩下的只是告诉如何捍卫。 <br><br> 通用建议不多： <br><br><ul><li> 不要在用户可写的文件夹中存储可执行文件，尤其是那些具有较高权限的可执行文件。 </li><li> 最好在执行LoadLibrary之前先找到并验证该库的存在。 </li><li> 查看操作系统中可用的现有保护方法。 例如，在Windows 10中，可以设置<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PreferSystem32标志，以便</a> dll搜索不是从可执行文件文件夹开始，而是以system32开始。 </li></ul><br> 感谢您的关注，我很高兴听到问题，建议，意见和评论。 <br><br>  <b>UPD：</b>根据评论员的建议，我提醒您，您需要仔细选择图书馆。 如果该库包含在KnownDlls列表中，或者名称类似于MinWin（ApiSetSchema，api-ms-win-core-console-l1-1-0.dll-仅此而已），则由于处理功能，很可能将无法拦截该库操作系统中的此类dll。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN449904/">https://habr.com/ru/post/zh-CN449904/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN449888/index.html">量子物理学：退相干</a></li>
<li><a href="../zh-CN449890/index.html">Yandex采访中的算法部分如何</a></li>
<li><a href="../zh-CN449896/index.html">如何放牧猫，或给年轻程序员的建议</a></li>
<li><a href="../zh-CN449898/index.html">由内而外的新闻</a></li>
<li><a href="../zh-CN449902/index.html">最小的有线电视网络。 第2部分：组成和波形</a></li>
<li><a href="../zh-CN449906/index.html">自记录REST服务器（Node.JS，TypeScript，Koa，Joi，Swagger）</a></li>
<li><a href="../zh-CN449910/index.html">GitLab Shell Runner。 使用Docker Compose竞争性地启动测试服务</a></li>
<li><a href="../zh-CN449916/index.html">高负载情况下部署PHP代码的5种方法</a></li>
<li><a href="../zh-CN449918/index.html">带有传感器的红外测温仪MLX90614</a></li>
<li><a href="../zh-CN449920/index.html">更改CMS时会损害SEO的10种非标准方式（+1奖励）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>