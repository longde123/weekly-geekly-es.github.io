<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛍️ 👩🏼‍🏭 🗞️ PVS-Studio untuk Java 👦🏽 🚜 🚵</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam versi ketujuh dari analisa statis PVS-Studio, kami menambahkan dukungan dari bahasa Java. Saatnya untuk cerita singkat tentang bagaimana kami mu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PVS-Studio untuk Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/436496/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/859/2ca/ccd/8592caccdc92ac430645bd487d7b5284.png" alt="PVS-Studio untuk Java"></div><br>  Dalam versi ketujuh dari analisa statis PVS-Studio, kami menambahkan dukungan dari bahasa Java.  Saatnya untuk cerita singkat tentang bagaimana kami mulai membuat dukungan bahasa Jawa, seberapa jauh kami telah datang, dan apa yang ada dalam rencana kami selanjutnya.  Tentu saja, artikel ini akan mendaftar uji coba analisa pertama pada proyek open source. <br><a name="habracut"></a><br><h2>  PVS-Studio </h2><br>  Berikut ini adalah deskripsi singkat tentang PVS-Studio untuk pengembang Java yang belum pernah mendengarnya. <br><br>  Alat ini dirancang untuk mendeteksi kesalahan dan kerentanan potensial dalam kode sumber program, ditulis dalam C, C ++, C #, dan Java.  Ia bekerja di lingkungan Windows, Linux, dan macOS. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PVS-Studio</a> melakukan analisis kode statis dan menghasilkan laporan yang membantu pengembang menemukan dan menghilangkan cacat.  Bagi mereka yang tertarik pada bagaimana tepatnya PVS-Studio mencari kesalahan, saya sarankan untuk melihat artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teknologi yang digunakan dalam analisa kode PVS-Studio untuk menemukan bug dan potensi kerentanan</a> ". <br><br><h2>  Awal </h2><br>  Saya bisa saja datang dengan cerita yang cerdik tentang bagaimana kami telah berspekulasi tentang apa bahasa berikutnya untuk mendukung di PVS-Studio.  Tentang pilihan Jawa yang masuk akal, yang didasarkan pada popularitas tinggi bahasa ini, dan sebagainya. <br><br>  Namun, seperti yang terjadi dalam hidup, pilihan itu dibuat bukan dengan analisis mendalam, tetapi dengan eksperimen :).  Ya, kami memikirkan arah pengembangan lebih lanjut dari penganalisa PVS-Studio.  Kami mempertimbangkan bahasa-bahasa tersebut, seperti: Java, PHP, Python, JavaScript, IBM RPG.  Kami bahkan cenderung ke bahasa Jawa tetapi pilihan terakhir tidak dibuat.  Bagi mereka yang pandangannya tertuju pada IBM RPG yang tidak dikenal, saya ingin mengarahkan Anda ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan</a> ini, dari mana semuanya akan menjadi jelas. <br><br>  Pada akhir 2017, kolega saya Egor Bredikhin meninjau pustaka kode parsing (dengan kata lain - parser) untuk arah pengembangan baru, menarik bagi kami.  Akhirnya, ia menemukan beberapa proyek untuk mem-parsing kode Java.  Dia berhasil dengan cepat membuat prototipe analyzer dengan beberapa diagnostik berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spoon</a> .  Selain itu, telah menjadi jelas bahwa kita akan dapat menggunakan dalam Java analyzer beberapa mekanisme dari C ++ analyzer menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SWIG</a> .  Kami melihat apa yang kami dapatkan dan menyadari bahwa penganalisa kami berikutnya adalah untuk Java. <br><br>  Kami ingin mengucapkan terima kasih kepada Egor atas usaha dan kerja kerasnya yang telah ia lakukan selama menganalisis Java.  Proses pengembangan itu sendiri dijelaskan olehnya dalam artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengembangan analisa statis baru: PVS-Studio Java</a> ." <br><br><h2>  Bagaimana dengan pesaing? </h2><br>  Ada banyak penganalisa kode statis gratis dan komersial untuk Java di seluruh dunia.  Tidak ada gunanya mencantumkan semuanya dalam artikel.  Saya hanya akan meninggalkan tautan ke " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftar alat untuk analisis kode statis</a> " (lihat bagian Java dan Multi-Bahasa). <br><br>  Namun, saya tahu bahwa pertama dan terpenting kita akan ditanya tentang IntelliJ IDEA, FindBugs, dan SonarQube (SonarJava). <br><br>  <b>IntelliJ IDEA</b> <br><br>  Penganalisa kode statis yang sangat kuat dibangun di IntelliJ IDEA.  Terlebih lagi, penganalisa terus berkembang, penulisnya mengikuti dengan cermat kegiatan kami.  Jadi, IntelliJ IDEA adalah cookie yang sulit bagi kami.  Kami tidak akan dapat melampaui IntelliJ IDEA dalam kemampuan diagnostik, setidaknya untuk saat ini.  Karena itu, kami akan berkonsentrasi pada keunggulan kami yang lain. <br><br>  Analisis statis di IntelliJ IDEA terutama adalah salah satu fitur lingkungan, yang membebankan batasan tertentu padanya.  Bagi kami, kami memiliki kebebasan dalam apa yang dapat kami lakukan dengan analis kami.  Misalnya, kami dapat dengan cepat mengadaptasinya untuk kebutuhan pelanggan tertentu.  Dukungan cepat dan mendalam adalah keunggulan kompetitif kami.  Klien kami berkomunikasi secara langsung dengan pengembang, mengerjakan satu atau bagian lain dari PVS-Studio. <br><br>  Dalam PVS-Studio, ada banyak peluang untuk mengintegrasikannya ke dalam siklus pengembangan proyek-proyek besar yang lama.  Misalnya, ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">integrasi</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan SonarQube</a> .  Ini juga mencakup <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penindasan massal terhadap</a> penganalisa, yang memungkinkan Anda untuk segera mulai menggunakan alat dalam proyek besar untuk melacak bug hanya dalam kode baru atau yang dimodifikasi.  PVS-Studio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat dibangun</a> dalam proses integrasi berkelanjutan.  Saya pikir ini dan fitur lainnya akan membantu penganalisa kami untuk menemukan tempat di bawah Matahari di dunia Jawa. <br><br>  <b>Findbugs</b> <br><br>  Proyek FindBugs ditinggalkan.  Namun demikian, kita harus menyebutkannya dengan alasan bahwa, mungkin, ini adalah penganalisa statis bebas yang paling terkenal dari kode Java. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpotBugs</a> bisa disebut penerus FindBugs.  Namun, itu kurang populer, dan belum jelas apa yang akan terjadi dengannya. <br><br>  Secara umum, kami berpikir bahwa meskipun FindBugs telah dan masih tetap sangat populer, dan selain itu penganalisa gratis, kita tidak boleh memikirkannya.  Proyek ini hanya akan diam-diam menjadi sejarah. <br><br>  Ngomong-ngomong, sekarang PVS-Studio juga dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">digunakan secara gratis</a> ketika bekerja dengan proyek terbuka. <br><br>  <b>SonarQube (SonarJava)</b> <br><br>  Kami percaya bahwa kami tidak bersaing dengan SonarQube, tetapi melengkapinya.  PVS-Studio terintegrasi dalam SonarQube, yang memungkinkan pengembang untuk menemukan lebih banyak bug dan kerentanan keamanan potensial dalam proyek mereka.  Kami secara teratur memberi tahu cara mengintegrasikan alat PVS-Studio dan analisis lain di SonarQube pada kelas master yang kami pegang dalam hal konferensi yang berbeda. <br><br><h2>  Cara Menjalankan PVS-Studio untuk Java </h2><br>  Kami menyediakan cara-cara paling populer dari integrasi penganalisa dalam sistem build untuk pengguna: <br><br><ul><li>  Plugin untuk Maven; </li><li>  Plugin untuk Gradle; </li><li>  Plugin untuk IntelliJ IDEA </li></ul><br>  Selama fase pengujian, kami bertemu banyak pengguna yang memiliki sistem pembangunan yang ditulis sendiri, terutama di bidang pengembangan ponsel.  Mereka menikmati kesempatan untuk menjalankan alat analisis secara langsung, mendaftar sumber dan classpath. <br><br>  Anda dapat menemukan informasi terperinci tentang semua cara untuk menjalankan analisa pada halaman dokumentasi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara Menjalankan PVS-Studio Java</a> ". <br><br>  Kami tidak dapat menghindar dari platform kontrol kualitas kode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SonarQube</a> , yang sangat populer di kalangan pengembang Java, jadi kami menambahkan dukungan bahasa Java di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">plugin</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk SonarQube</a> . <br><br><h2>  Rencana selanjutnya </h2><br>  Kami memiliki banyak ide yang mungkin memerlukan penyelidikan lebih lanjut, tetapi beberapa rencana spesifik, yang melekat pada salah satu analis kami, adalah sebagai berikut: <br><br><ul><li>  Pembuatan diagnostik baru dan peningkatan yang sudah ada; </li><li>  Peningkatan Analisis Dataflow; </li><li>  Meningkatkan keandalan dan kegunaan. </li></ul><br>  Mungkin, kita akan menemukan waktu untuk mengadaptasi plugin IntelliJ IDEA untuk CLion.  Hai untuk pengembang C ++ yang membaca tentang Java analyzer :-) <br><br><h2>  Contoh Kesalahan Ditemukan di Proyek Sumber Terbuka </h2><br>  Menggigil kayu saya jika saya tidak menunjukkan dalam artikel beberapa bug ditemukan dengan analisa baru!  Yah, kita bisa mengambil proyek Java open source yang besar dan menulis artikel klasik yang meninjau kesalahan, seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biasa kita lakukan</a> . <br><br>  Namun, saya segera mengantisipasi pertanyaan tentang apa yang dapat kami temukan dalam proyek-proyek seperti IntelliJ IDEA, FindBugs, dan sebagainya.  Jadi saya tidak punya jalan keluar, selain mulai dengan proyek-proyek ini.  Jadi, saya memutuskan untuk segera memeriksa dan menulis beberapa contoh kesalahan yang menarik dari proyek-proyek berikut: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Edisi Komunitas IntelliJ IDEA</a> .  Saya pikir tidak perlu menjelaskan mengapa proyek ini dipilih :). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SpotBugs</a>  Seperti yang saya tulis sebelumnya, proyek FindBugs tidak mengalami kemajuan.  Jadi mari kita lihat ke dalam proyek SpotBugs, yang merupakan penerus FindBugs.  SpotBugs adalah penganalisa statis kode Java klasik. </li><li>  Sesuatu dari proyek perusahaan SonarSource, yang mengembangkan perangkat lunak untuk pemantauan terus menerus terhadap kualitas kode.  Sekarang mari kita lihat ke dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SonarQube</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SonarJava</a> . </li></ul><br>  Menulis tentang bug dari proyek-proyek ini adalah sebuah tantangan.  Faktanya adalah bahwa proyek-proyek ini berkualitas sangat tinggi.  Sebenarnya, itu tidak mengejutkan.  Pengamatan kami menunjukkan bahwa penganalisa kode statis selalu diuji dengan baik dan diverifikasi menggunakan alat lain. <br><br>  Terlepas dari semua ini, saya harus memulai persis dengan proyek-proyek ini.  Saya tidak akan memiliki kesempatan kedua untuk menulis tentang mereka.  Saya yakin bahwa setelah rilis PVS-Studio untuk Java, pengembang proyek yang terdaftar akan menggunakan PVS-Studio dan mulai menggunakannya untuk reguler atau, setidaknya, sesekali memeriksa kode mereka.  Sebagai contoh, saya tahu bahwa Tagir Valeev ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">lany</a> ), salah satu pengembang JetBrains, bekerja pada penganalisis kode statis IntelliJ IDEA, saat ini, ketika saya sedang menulis artikel tersebut sudah bermain dengan versi Beta dari PVS-Studio .  Dia menulis kepada kami sekitar 15 email dengan laporan bug dan rekomendasi.  Terima kasih, Tagir! <br><br>  Untungnya, saya tidak perlu menemukan banyak bug dalam satu proyek tertentu.  Saat ini tugas saya adalah menunjukkan bahwa penganalisa PVS-Studio untuk Java muncul tidak sia-sia, dan akan dapat mengisi sederet alat lain yang dirancang untuk meningkatkan kualitas kode.  Saya baru saja memeriksa laporan alat analisa dan membuat daftar beberapa kesalahan yang sepertinya menarik.  Jika memungkinkan, saya mencoba mengutip berbagai jenis kesalahan.  Mari kita lihat bagaimana hasilnya. <br><br><h3>  IntelliJ IDEA, Divisi Integer </h3><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkSentenceCapitalization</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String value)</span></span></span><span class="hljs-function"> </span></span>{ List&lt;String&gt; words = StringUtil.split(value, <span class="hljs-string"><span class="hljs-string">" "</span></span>); .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> capitalized = <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> capitalized / words.size() &lt; <span class="hljs-number"><span class="hljs-number">0.2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// allow reasonable amount of // capitalized words }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V6011 [CWE-682] Literal '0,2' dari tipe 'ganda' dibandingkan dengan nilai tipe 'int'.  TitleCapitalizationInspection.java 169 <br><br>  Intinya adalah bahwa fungsi harus mengembalikan true jika kurang dari 20% dari kata-kata dimulai dengan huruf kapital.  Sebenarnya, pemeriksaan tidak berfungsi, karena pembagian bilangan bulat terjadi.  Sebagai hasil pembagian, kita hanya dapat memperoleh dua nilai: 0 atau 1. <br><br>  Fungsi akan mengembalikan false, hanya jika semua kata dimulai dengan huruf kapital.  Dalam semua kasus lain, operasi pembagian akan menghasilkan 0 dan fungsi akan mengembalikan true. <br><br><h3>  IntelliJ IDEA, Loop Mencurigakan </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPreviousIndex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> current)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = myPainter.getErrorStripeCount(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundIndex = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= current &amp;&amp; current &lt; count) { current--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= int layer = getLayer(index); if (layer &gt; foundLayer) { foundIndex = index; foundLayer = layer; } } .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'indeks&gt; = 0' selalu benar.  Updater.java 184 <br><br>  Pertama, lihat kondisinya <i>(0 &lt;= saat &amp;&amp; saat ini &lt;hitung)</i> .  Ini dijalankan hanya dalam kasus jika nilai variabel <i>jumlah</i> lebih besar dari 0. <br><br>  Sekarang lihat loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index++)</code> </pre> <br>  <i>Indeks</i> variabel diinisialisasi dengan <i>jumlah</i> ekspresi <i>- 1</i> .  Karena variabel <i>jumlah</i> lebih besar dari 0, nilai awal dari variabel <i>indeks</i> akan selalu lebih besar atau sama dengan 0. Ternyata loop akan dieksekusi sampai terjadi overflow dari variabel <i>indeks</i> . <br><br>  Kemungkinan besar, itu hanya kesalahan ketik, dan penurunan, bukan kenaikan variabel yang harus dijalankan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = count - <span class="hljs-number"><span class="hljs-number">1</span></span>; index &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; index--)</code> </pre> <br><h3>  IntelliJ IDEA, Copy-Paste </h3><br><pre> <code class="cpp hljs">@NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String BEFORE_STR_OLD = <span class="hljs-string"><span class="hljs-string">"before:"</span></span>; @NonNls <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> final String AFTER_STR_OLD = <span class="hljs-string"><span class="hljs-string">"after:"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBeforeOrAfterKeyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String str, boolean trimKeyword)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (trimKeyword ? LoadingOrder.BEFORE_STR.trim() : LoadingOrder.BEFORE_STR).equalsIgnoreCase(str) || (trimKeyword ? LoadingOrder.AFTER_STR.trim() : LoadingOrder.AFTER_STR).equalsIgnoreCase(str) || LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str) || <span class="hljs-comment"><span class="hljs-comment">// &lt;= LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase(str); // &lt;= }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V6001 [CWE-570] Ada sub-ekspresi identik 'LoadingOrder.BEFORE_STR_OLD.equalsIgnoreCase (str)' ke kiri dan ke kanan '||'  operator.  Periksa baris: 127, 128. ExtensionOrderConverter.java 127 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek</a> lama yang bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari baris terakhir</a> .  Seorang pengembang melompat pistol dan telah memperbanyak baris kode, lupa memperbaikinya.  Akibatnya, string <i>str</i> dibandingkan dengan <i>BEFORE_STR_OLD</i> dua kali.  Kemungkinan besar, salah satu perbandingan harus dengan <i>AFTER_STR_OLD</i> . <br><br><h3>  IntelliJ IDEA, Typo </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> synchronized boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String name, final Project project)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\''</span></span>) &amp;&amp; !StringUtil.startsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name = <span class="hljs-string"><span class="hljs-string">"\""</span></span> + name; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'"'</span></span>) &amp;&amp; !StringUtil.endsWithChar(name,<span class="hljs-string"><span class="hljs-string">'\"'</span></span>)) { name += <span class="hljs-string"><span class="hljs-string">"\""</span></span>; } .... }</code> </pre> <br>  Peringatan PVS-Studio: V6001 [CWE-571] Ada sub-ekspresi identik '! StringUtil.endsWithChar (nama,' "')' di sebelah kiri dan di sebelah kanan operator '&amp;&amp;'. JsonNamesValidator.java 27 <br><br>  Fragmen kode ini memeriksa bahwa nama terlampir dalam tanda kutip tunggal atau ganda.  Jika tidak, tanda kutip ganda ditambahkan secara otomatis. <br><br>  Karena kesalahan ketik, akhir nama diperiksa hanya untuk adanya tanda kutip ganda.  Akibatnya, nama dalam tanda kutip tunggal akan diproses secara tidak benar. <br><br>  Nama <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span></code> </pre> <br>  karena menambahkan tanda kutip ganda tambahan akan berubah menjadi: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">'Abcd'</span></span><span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><h3>  IntelliJ IDEA, Perlindungan Salah dari Array Overrun </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = offset; i &lt; endOffset; i++) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = text.charAt(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> &amp;&amp; i &lt; endOffset &amp;&amp; text.charAt(i + <span class="hljs-number"><span class="hljs-number">1</span></span>) == <span class="hljs-string"><span class="hljs-string">'/'</span></span> &amp;&amp; startTag != null &amp;&amp; CharArrayUtil.regionMatches(text, i + <span class="hljs-number"><span class="hljs-number">2</span></span>, endOffset, startTag)) { endTagStartOffset = i; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } .... }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'i &lt;endOffset' selalu benar.  MasukkanAfterJavadocTagHandler.java 183 <br><br>  Subekspresi <i>i &lt;endOffset</i> dalam kondisi <i>jika</i> operator tidak masuk akal.  Variabel <i>i</i> selalu kurang dari <i>endOffset</i> dalam hal apa pun, yang mengikuti kondisi eksekusi loop. <br><br>  Kemungkinan besar, pengembang ingin melindungi dari string overrun saat memanggil fungsi: <br><br><ul><li>  text.charAt (i +1) </li><li>  CharArrayUtil.regionMatches (teks, i + 2, endOffset, startTag) </li></ul><br>  Dalam hal ini, subekspresi untuk memeriksa indeks harus: <i>(i) &lt;endOffset-2</i> . <br><br><h3>  IntelliJ IDEA, Pengecekan Berulang </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateWarningMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { buffer.append(<span class="hljs-string"><span class="hljs-string">" "</span></span>).append( IdeBundle.message(<span class="hljs-string"><span class="hljs-string">"prompt.delete.and"</span></span>)).append(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } } .... }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'buffer.length ()&gt; 0' selalu benar.  DeleteUtil.java 62 <br><br>  Ini bisa berupa kode berlebihan yang tidak berbahaya atau kesalahan penting. <br><br>  Jika pemeriksaan duplikat muncul secara tidak sengaja, misalnya selama refactoring, tidak ada yang salah dengan itu.  Anda bisa menghapus cek kedua. <br><br>  Skenario lain juga dimungkinkan.  Pemeriksaan kedua harus sangat berbeda dan kode berperilaku tidak seperti yang dimaksudkan.  Maka itu adalah kesalahan nyata. <br><br>  <b>Catatan</b>  Ngomong-ngomong, ada banyak berbagai macam cek berlebihan.  Yah, sering kali jelas bahwa itu bukan kesalahan.  Namun, kami tidak dapat menganggap peringatan penganalisa sebagai positif palsu.  Untuk penjelasan, saya ingin mengutip contoh seperti itu, juga diambil dari IntelliJ IDEA: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isMultiline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ String text = element.getText(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.contains(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>) || text.contains(<span class="hljs-string"><span class="hljs-string">"\r\n"</span></span>); }</code> </pre> <br>  Penganalisa mengatakan bahwa function <i>text.contains ("\ r \ n")</i> selalu mengembalikan false.  Memang, jika karakter "\ n" dan "\ r" tidak ditemukan, tidak ada gunanya mencari "\ r \ n".  Ini bukan bug, dan kodenya buruk hanya karena bekerja sedikit lebih lambat, melakukan pencarian yang tidak berarti untuk substring. <br><br>  Bagaimana menangani kode semacam itu, dalam setiap kasus, merupakan pertanyaan bagi pengembang.  Saat menulis artikel, saya biasanya tidak memperhatikan kode seperti itu. <br><br><h3>  IntelliJ IDEA, Ada Yang Salah </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">satisfiedBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull PsiElement element)</span></span></span><span class="hljs-function"> </span></span>{ .... @NonNls final String text = expression.getText().replaceAll(<span class="hljs-string"><span class="hljs-string">"_"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text == null || text.length() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-string"><span class="hljs-string">"0"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0L"</span></span>.equals(text) || <span class="hljs-string"><span class="hljs-string">"0l"</span></span>.equals(text)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.charAt(<span class="hljs-number"><span class="hljs-number">0</span></span>) == <span class="hljs-string"><span class="hljs-string">'0'</span></span>; }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-570] Ekspresi '"0". Equals (text)' selalu salah.  ConvertIntegerToDecimalPredicate.java 46 <br><br>  Kode berisi kesalahan logis pasti.  Saya merasa sulit untuk mengatakan apa sebenarnya yang ingin diperiksa oleh programmer dan cara memperbaiki cacat.  Jadi di sini, saya hanya akan menunjuk pada cek yang tidak berarti. <br><br>  Pada awalnya harus diperiksa bahwa string berisi setidaknya dua simbol.  Jika tidak, maka fungsi mengembalikan <i>false</i> . <br><br>  Selanjutnya muncul tanda centang <i>"0". Equals (text)</i> .  Ini tidak ada artinya, karena tidak ada string yang hanya dapat berisi satu karakter. <br><br>  Jadi, ada yang salah di sini, dan kodenya harus diperbaiki. <br><br><h3>  SpotBugs (Penerus FindBugs), Kesalahan Batasan Jumlah Iterasi </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getXMLType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@WillNotClose InputStream in)</span></span></span><span class="hljs-function"> throws IOException </span></span>{ .... String s; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (count &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { s = r.readLine(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s == null) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } Matcher m = tag.matcher(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m.find()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m.group(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IOException(<span class="hljs-string"><span class="hljs-string">"Didn't find xml tag"</span></span>); .... }</code> </pre> <br>  Peringatan PVS-Studio: V6007 [CWE-571] Ekspresi 'count &lt;4' selalu benar.  Util.java 394 <br><br>  Secara teori, pencarian tag xml harus dilakukan hanya dalam empat baris pertama file.  Tetapi karena fakta bahwa seseorang lupa untuk menambah variabel <i>jumlah</i> , seluruh file akan dibaca. <br><br>  Pertama, ini bisa menjadi operasi yang sangat lambat, dan kedua, di suatu tempat di tengah file, sesuatu mungkin ditemukan yang akan dianggap sebagai tag xml, bukan itu. <br><br><h3>  SpotBugs (Penerus FindBugs), Kliring Nilai </h3><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reportBug</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> priority = LOW_PRIORITY; String pattern = <span class="hljs-string"><span class="hljs-string">"NS_NON_SHORT_CIRCUIT"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawDangerOld) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sawNullTestVeryOld) { priority = HIGH_PRIORITY; <span class="hljs-comment"><span class="hljs-comment">// &lt;= } if (sawMethodCallOld || sawNumericTestVeryOld &amp;&amp; sawArrayDangerOld) { priority = HIGH_PRIORITY; // &lt;= pattern = "NS_DANGEROUS_NON_SHORT_CIRCUIT"; } else { priority = NORMAL_PRIORITY; // &lt;= } } bugAccumulator.accumulateBug( new BugInstance(this, pattern, priority).addClassAndMethod(this), this); }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V6021 [CWE-563] Nilai diberikan ke variabel 'prioritas' tetapi tidak digunakan.  FindNonShortCircuit.java 197 <br><br>  Nilai variabel <i>prioritas</i> diatur tergantung pada nilai variabel <i>sawNullTestVeryOld</i> .  Namun, itu tidak masalah sama sekali.  Setelah itu, variabel <i>prioritas</i> akan diberi nilai lain dalam kasus apa pun.  Kesalahan yang jelas dalam logika fungsi. <br><br><h3>  SonarQube, Salin-Tempel </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RuleDto</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleDefinitionDto definition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final RuleMetadataDto metadata; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setUpdatedAtFromMetadata</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Long updatedAt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatedAt != null &amp;&amp; updatedAt &gt; definition.getUpdatedAt()) { setUpdatedAt(updatedAt); } } .... }</code> </pre> <br>  PVS-Studio: V6032 Aneh bahwa tubuh metode 'setUpdatedAtFromDefinition' sepenuhnya setara dengan tubuh metode lain 'setUpdatedAtFromMetadata'.  Periksa baris: 396, 405. RuleDto.java 396 <br><br>  Bidang <i>definisi</i> digunakan dalam metode <i>setUpdatedAtFromMetadata</i> .  Kemungkinan besar, bidang <i>metadata</i> harus digunakan.  Ini sangat mirip dengan efek dari Copy-Paste yang gagal. <br><br><h3>  SonarJava, Duplikat Saat Menginisialisasi Peta </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> final Map&lt;JavaPunctuator, Tree.Kind&gt; assignmentOperators = Maps.newEnumMap(JavaPunctuator.class); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KindMaps</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... assignmentOperators.put(JavaPunctuator.PLUSEQU, Tree.Kind.PLUS_ASSIGNMENT); .... }</code> </pre> <br>  Peringatan PVS-Studio: V6033 [CWE-462] Item dengan kunci yang sama 'JavaPunctuator.PLUSEQU' telah ditambahkan.  Periksa baris: 104, 100. KindMaps.java 104 <br><br>  Pasangan nilai kunci yang sama diatur di peta dua kali.  Kemungkinan besar, itu terjadi secara tidak sengaja dan sebenarnya tidak ada kesalahan nyata.  Namun, kode ini harus diperiksa dalam hal apa pun, karena, mungkin, seseorang lupa menambahkan pasangan lain. <br><br><h2>  Kesimpulan </h2><br>  Mengapa menulis kesimpulan ketika itu sangat jelas ?!  Saya sarankan Anda mengunduh PVS-Studio sekarang juga dan coba periksa proyek kerja Anda dalam bahasa Jawa!  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Unduh PVS-Studio</a> . <br><br>  Terima kasih atas perhatiannya.  Saya berharap bahwa segera kami akan menyenangkan pembaca kami dengan serangkaian artikel tentang memeriksa berbagai proyek Java open source. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436496/">https://habr.com/ru/post/id436496/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436486/index.html">Apa yang terjadi di pasar podcast audio</a></li>
<li><a href="../id436488/index.html">Aplikasi kari dan sebagian dalam C ++ 14</a></li>
<li><a href="../id436490/index.html">Motorola berencana untuk memperkenalkan inkarnasi Razr v3</a></li>
<li><a href="../id436492/index.html">Kami mencari pembicara di Mitap DIY ke-10 17 Februari 2019</a></li>
<li><a href="../id436494/index.html">Mengganti disk sambil mempertahankan penomoran yang tepat dalam CEPH</a></li>
<li><a href="../id436498/index.html">Perangkat Lunak AG: Tidak Hanya ARIS</a></li>
<li><a href="../id436500/index.html">Bagaimana kerangka Rise of the Tomb Raider ditampilkan</a></li>
<li><a href="../id436502/index.html">Pampers Berlangganan atau Cara Menjual Lebih Banyak ke Pelanggan yang Sama</a></li>
<li><a href="../id436504/index.html">Sistem dalam Paket, atau Penutup Paket Apa Yang Ada Dalam Chip?</a></li>
<li><a href="../id436506/index.html">Cara membuat AI-rasis tanpa banyak usaha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>