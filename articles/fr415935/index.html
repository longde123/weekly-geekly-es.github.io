<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏼 🏇🏼 🚵🏿 Tri d'insertion 🥉 👊🏼 👩🏽‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'essence générale des tri par insertion est la suivante: 



1. Itère les éléments de la partie non triée du tableau. 
2. Chaque élément est inséré d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tri d'insertion</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415935/"><div style="text-align:center;"><img width="700" height="288" src="https://habrastorage.org/webt/ha/sk/1-/hask1-5bxk5ncdv33awxot2alcq.png"></div><br><br>  L'essence générale des tri par insertion est la suivante: <br><br><ol><li>  Itère les éléments de la partie non triée du tableau. </li><li> Chaque élément est inséré dans la partie triée du tableau à l'endroit où il devrait être. </li></ol><br><a name="habracut"></a>  <s>C'est, en principe, tout ce que vous devez savoir sur le tri par encarts.</s>  Autrement dit, les tris par insertion divisent toujours le tableau en 2 parties - triées et non triées.  Tout élément est récupéré de la partie non triée.  Puisque l'autre partie du tableau est triée, vous pouvez rapidement trouver votre place dans ce tableau pour cet élément extrait.  L'élément est inséré si nécessaire, à la suite de quoi la partie triée du tableau augmente et la partie non triée diminue.  C’est tout.  Toutes sortes d'inserts fonctionnent selon ce principe. <br><br>  Le point le plus faible de cette approche est l'insertion d'un élément dans la partie triée du tableau.  En fait, ce n'est pas facile et quelles astuces vous n'avez pas à suivre pour terminer cette étape. <br><br><h2>  Tri par insertion simple </h2><br><img width="684" height="95" src="https://habrastorage.org/webt/x4/nz/uu/x4nzuuiuosxzaj2y88ewj-vu9zo.gif"><br><br>  Nous parcourons le tableau de gauche à droite et traitons chaque élément tour à tour.  À gauche de l'élément suivant, nous augmentons la partie triée du tableau, à droite, au fur et à mesure que le processus progresse, la partie non triée s'évapore lentement.  Dans la partie triée du tableau, le point d'insertion de l'élément suivant est recherché.  L'élément lui-même est envoyé au tampon, à la suite duquel une cellule vide apparaît dans le tableau - cela vous permet de déplacer les éléments et de libérer le point d'insertion. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data)): j = i - <span class="hljs-number"><span class="hljs-number">1</span></span> key = data[i] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> data[j] &gt; key <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>: data[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = data[j] j -= <span class="hljs-number"><span class="hljs-number">1</span></span> data[j + <span class="hljs-number"><span class="hljs-number">1</span></span>] = key <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br>  En utilisant des insertions simples à titre d'exemple, le principal avantage de la plupart (mais pas de toutes!) Le tri par insertions semble démonstratif, à savoir un traitement très rapide de tableaux presque ordonnés: <br><br><img width="684" height="95" src="https://habrastorage.org/webt/qq/6e/ud/qq6eudehsux_10xmkh1b-x1sata.gif"><br><br>  Dans ce scénario, même l'implémentation la plus primitive des insertions de tri est susceptible de dépasser l'algorithme super-optimisé pour un tri rapide, y compris sur les grands tableaux. <br><br>  Ceci est facilité par l'idée principale de cette classe - le transfert d'éléments de la partie non triée du tableau vers la partie triée.  À proximité de données de magnitude similaire, le point d'insertion est généralement situé près du bord de la partie triée, ce qui vous permet d'insérer avec le moins de frais généraux. <br><br>  Il n'y a rien de mieux pour gérer des tableaux presque ordonnés que le tri par insertion.  Lorsque vous rencontrez des informations quelque part selon lesquelles la meilleure complexité temporelle du tri par insertions est <nobr>O ( <b>n</b> )</nobr> , vous faites probablement référence à des situations avec des tableaux presque ordonnés. <br><br><h2>  Trier par de simples insertions de recherche binaire </h2><br><img width="684" height="96" src="https://habrastorage.org/webt/ni/rs/nv/nirsnv-0nl-tntp5fecd21-4eiu.gif"><br><br>  Puisque l'endroit à insérer est recherché dans la partie triée du tableau, l'idée d'utiliser une recherche binaire se suggère.  Une autre chose est que la recherche du site d'insertion n'est pas critique pour la complexité temporelle de l'algorithme (le principal mangeur de ressources est l'étape d'insertion de l'élément dans la position trouvée elle-même), donc cette optimisation fait peu. <br><br>  Et dans le cas d'un tableau presque trié, une recherche binaire peut fonctionner encore plus lentement, car elle commence au milieu de la section triée, ce qui, très probablement, sera trop loin du point d'insertion (et il faudra moins d'étapes pour effectuer une recherche normale de la position de l'élément au point d'insertion si les données dans le tableau dans son ensemble ordonné). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insertion_binary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(data)): key = data[i] lo, hi = <span class="hljs-number"><span class="hljs-number">0</span></span>, i - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> lo &lt; hi: mid = lo + (hi - lo) // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key &lt; data[mid]: hi = mid <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: lo = mid + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i, lo + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>): data[j] = data[j - <span class="hljs-number"><span class="hljs-number">1</span></span>] data[lo] = key <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br>  Pour la défense de la recherche binaire, je note qu'il peut dire le dernier mot dans l'efficacité des autres tris par encarts.  Grâce à lui, en particulier, des algorithmes tels que le tri bibliothécaire et le tri solitaire vont à la complexité temporelle moyenne <nobr>O ( <b>n</b> log <b>n</b> )</nobr> .  Mais à leur sujet plus tard. <br><br><h2>  Tri des paires par inserts simples </h2><br>  Modification d'inserts simples, développés dans les laboratoires secrets d'Oracle Corporation.  Ce tri fait partie du JDK et fait partie du tri rapide à double pivot.  Il est utilisé pour trier les petits tableaux (jusqu'à 47 éléments) et trier les petites zones des grands tableaux. <br><br><img width="684" height="95" src="https://habrastorage.org/webt/fi/iv/q6/fiivq621vdspxj9bxxq0pqe3jne.gif"><br><br>  Pas un mais deux éléments adjacents sont envoyés au tampon à la fois.  Tout d'abord, le plus grand élément de la paire est inséré, et immédiatement après, la méthode d'insertion simple est appliquée au plus petit élément de la paire. <br><br>  Qu'est-ce que ça donne?  Économies pour la manipulation d'un petit article d'une paire.  Pour lui, la recherche du point d'insertion et l'insertion elle-même ne sont effectuées que sur cette partie triée du tableau, qui n'inclut pas la zone triée utilisée pour traiter un élément plus grand de la paire.  Cela devient possible car les éléments plus grands et plus petits sont traités immédiatement l'un après l'autre en un seul passage de la boucle extérieure. <br><br>  Cela n'affecte pas la complexité temporelle moyenne (elle reste toujours égale à <nobr>O ( <b>n <sup>2</sup></b> )),</nobr> cependant, les inserts appariés fonctionnent un peu plus vite que les inserts habituels. <br><br>  J'illustre les algorithmes en Python, mais ici je donne la source originale (modifiée pour plus de lisibilité) en Java: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = left; ++left &lt;= right; k = ++left) { <span class="hljs-comment"><span class="hljs-comment">//   ́  //     int a1 = a[k], a2 = a[left]; if (a1 &lt; a2) { a2 = a1; a1 = a[left]; } //     while (a1 &lt; a[--k]) { a[k + 2] = a[k]; } a[++k + 1] = a1; //     while (a2 &lt; a[--k]) { a[k + 1] = a[k]; } a[k + 1] = a2; } // ,       //       int last = a[right]; while (last &lt; a[--right]) { a[right + 1] = a[right]; } a[right + 1] = last;</span></span></code> </pre> <br><br><h2>  Tri des coques </h2><br><img width="684" height="95" src="https://habrastorage.org/webt/ig/rb/aa/igrbaajcuoxuj4q-l-38x0qsoq4.gif"><br><br>  Cet algorithme a une approche très spirituelle pour déterminer quelle partie du tableau est considérée comme triée.  Dans les insertions simples, tout est simple: à partir de l'élément courant, tout à gauche est déjà trié, tout à droite n'est pas encore trié.  Contrairement aux insertions simples, le tri Shell n'essaie pas de former immédiatement une partie strictement triée du tableau à gauche d'un élément.  Il crée une partie <em>presque triée</em> du tableau à gauche de l'élément et le fait assez rapidement. <br><br>  Le tri par shell jette l'élément actuel dans le tampon et le compare avec le côté gauche du tableau.  S'il trouve des éléments plus gros sur la gauche, il les déplace vers la droite, laissant de la place pour l'insertion.  Mais en même temps, il ne prend pas toute la partie gauche, mais seulement un certain groupe d'éléments, où les éléments sont espacés les uns des autres d'une certaine distance.  Un tel système vous permet d'insérer rapidement des éléments dans approximativement la zone du réseau où ils doivent être situés. <br><br>  À chaque itération de la boucle principale, cette distance diminue progressivement et lorsqu'elle devient égale à un, le tri Shell se transforme à ce moment en un tri classique avec des insertions simples, qui ont été données au traitement d'un tableau presque trié.  Un tableau de tri presque trié s'insère en convertis entièrement triés rapidement. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function">:</span></span> inc = len(data) // <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> inc: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, el <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(data): <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &gt;= inc <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> data[i - inc] &gt; el: data[i] = data[i - inc] i -= inc data[i] = el inc = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> inc == <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> int(inc * <span class="hljs-number"><span class="hljs-number">5.0</span></span> / <span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data</code> </pre> <br><br>  Le tri par peigne selon un principe similaire améliore le tri à bulles, de sorte que la complexité temporelle de l'algorithme avec <nobr>O ( <b>n <sup>2</sup></b> )</nobr> passe directement à <nobr>O ( <b>n</b> log <b>n</b> )</nobr> .  Hélas, Shell ne parvient pas à répéter cet exploit - la meilleure complexité temporelle atteint <nobr>O ( <b>n</b> log <sup>2</sup> <b>n</b> )</nobr> . <br><br>  Plusieurs habrastati ont été écrits sur le tri de Shell, nous ne serons donc pas surchargés d'informations et continuerons. <br><br><h2>  Tri des arbres </h2><br><img width="570" height="277" src="https://habrastorage.org/webt/uo/6e/d8/uo6ed8lcpyvdpg9fzfwsye2pnuu.gif"><br><br>  Le tri avec une arborescence en raison de la mémoire supplémentaire résout rapidement le problème de l'ajout d'un autre élément à la partie triée du tableau.  De plus, l'arbre binaire agit comme la partie triée du tableau.  Un arbre se forme littéralement à la volée lors de l'itération sur des éléments. <br><br>  L'élément est d'abord comparé avec la racine, puis avec plus de nœuds imbriqués selon le principe: si l'élément est plus petit que le nœud, alors on descend la branche gauche, sinon moins, puis la droite.  Un arbre construit par une telle règle peut alors être facilement contourné de manière à passer de nœuds avec des valeurs plus faibles à des nœuds avec des valeurs plus grandes (et ainsi obtenir tous les éléments dans un ordre croissant). <br><br>  Le problème principal du tri par insertions (le coût de l'insertion d'un élément à sa place dans la partie triée du tableau) est résolu ici, la construction se déroule assez rapidement.  Dans tous les cas, pour libérer le point d'insertion, il n'est pas nécessaire de déplacer lentement les caravanes d'éléments comme dans les algorithmes précédents.  Il semblerait que le voici, le meilleur des trieurs.  Mais il y a un problème. <br><br>  Lorsque vous obtenez un bel arbre de Noël symétrique (le soi-disant arbre parfaitement équilibré) comme dans l'animation trois paragraphes ci-dessus, l'insertion se produit rapidement, car l'arbre dans ce cas a les niveaux d'imbrication les plus bas possibles.  Mais une structure équilibrée (ou au moins proche de cela) à partir d'un tableau aléatoire est rarement obtenue.  Et l'arbre, très probablement, sera imparfait et déséquilibré - avec des distorsions, un horizon jonché et un nombre excessif de niveaux. <br><br>  <em>Un tableau aléatoire avec des valeurs de 1 à 10. Les éléments dans cet ordre génèrent un arbre binaire déséquilibré:</em> <br><br><img width="564" height="384" src="https://habrastorage.org/webt/io/mj/25/iomj25xs6mtppplwt02gdgmbsiq.png"><br><br>  Un arbre ne suffit pas à construire, il doit encore être contourné.  Plus le déséquilibre est important, plus l'algorithme de traversée de l'arbre glissera fort.  Ici, comme le disent les étoiles, un tableau aléatoire peut générer à la fois un vilain accroc (ce qui est plus probable) et une fractale en forme d'arbre. <br><br>  <em>Les valeurs des éléments sont les mêmes, mais l'ordre est différent.</em>  <em>Un arbre binaire équilibré est généré:</em> <br><br><img height="311" src="https://habrastorage.org/webt/sc/k8/_y/sck8_y-fbutnw-ulr6bg1rg4nbg.png"><br><img align="left" width="218" height="90" src="https://habrastorage.org/webt/ah/eu/wi/aheuwi2kiu2l361frutx_qpvawq.png"><br clear="right">  <em>Sur la belle sakura</em> <em><br></em>  <em>Pas assez de pétale:</em> <em><br></em>  <em>Un arbre binaire de dizaines.</em> <br><br>  Le problème des arbres déséquilibrés est résolu par le tri par inversion, qui utilise un type spécial d'arbre de recherche binaire - arbre splay.  Il s'agit d'un magnifique arbre de transformateur qui, après chaque opération, est reconstruit dans un état équilibré.  À ce sujet sera un article séparé.  À ce moment-là, je préparerai des implémentations Python pour le tri arborescent et le tri Splay. <br><br>  Eh bien, eh bien, nous avons brièvement examiné les encarts de tri les plus populaires.  Inserts simples, coque et arbre binaire que nous connaissons tous à l'école.  Considérons maintenant d'autres représentants de cette classe, moins connus. <br><br>  <b>Wiki / Wiki</b> - <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Insertion</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Shell</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Shell</a> ,</nobr> <nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Arbre</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Arbre</a></nobr> <br><br><h3>  Articles de série: </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application Excel AlgoLab.xlsm</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exchange Sorts</a> </li><li>  <b>Tri d'insertion</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tri bibliothécaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tri solitaire</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trier "Tour de Hanoi"</a> </li><li>  Tri des jeunes tables </li><li>  Inverser le tri </li><li>  Insérer une comparaison de tri </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trier par sélection</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fusionner les tris</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trier par distribution</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tri hybride</a> </li></ul><br>  Qui utilise AlgoLab - Je recommande de mettre à jour le fichier.  J'ai ajouté des insertions de recherche binaires simples et des insertions appariées à cette application.  Il a également complètement réécrit la visualisation pour Shell (dans la version précédente, il n'y avait rien à comprendre) et a ajouté une surbrillance à la branche parent lors de l'insertion d'un élément dans l'arbre binaire. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415935/">https://habr.com/ru/post/fr415935/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415923/index.html">L'unité est-elle lente? Attention LINQ</a></li>
<li><a href="../fr415925/index.html">Technologie de blockchain anonyme brevetée MasterCard</a></li>
<li><a href="../fr415927/index.html">Lampe industrielle Breeze 50</a></li>
<li><a href="../fr415929/index.html">Optimisation de l'architecture de l'intelligence artificielle: la course commence</a></li>
<li><a href="../fr415933/index.html">Comment construire une architecture IIoT à faire soi-même</a></li>
<li><a href="../fr415937/index.html">La fusée privée japonaise MOMO-2 a explosé sur la rampe de lancement</a></li>
<li><a href="../fr415939/index.html">Traitement graphique distribué avec Spark GraphX</a></li>
<li><a href="../fr415943/index.html">"Développement du jeu et théorie du divertissement": points clés du livre de Raff Coster</a></li>
<li><a href="../fr415945/index.html">Nouvel automate chinois avec Aliexpress: Wecon LX3VP / LX3VE</a></li>
<li><a href="../fr415947/index.html">Système de compensation d'erreur d'installation de fibre optique lors de son traitement par rayonnement laser lors de la rotation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>