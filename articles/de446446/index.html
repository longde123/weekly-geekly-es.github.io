<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôåüèΩ üñêÔ∏è ‚úÖ Grundlagen der JavaScript-Engine: Allgemeine Formulare und Inline-Caching. Teil 1 üë®üèΩ‚Äçüç≥ üèôÔ∏è üßí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Freunde. Ende April starten wir einen neuen Kurs ‚ÄûSicherheit von Informationssystemen‚Äú . Und jetzt m√∂chten wir Ihnen eine √úbersetzung des Artike...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der JavaScript-Engine: Allgemeine Formulare und Inline-Caching. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/">  Hallo Freunde.  Ende April starten wir einen neuen Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">‚ÄûSicherheit von Informationssystemen‚Äú</a> .  Und jetzt m√∂chten wir Ihnen eine √úbersetzung des Artikels mitteilen, die f√ºr den Kurs sicherlich sehr n√ºtzlich sein wird.  Den Originalartikel finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . <br><br>  Der Artikel beschreibt die wichtigsten Grundlagen, die allen JavaScript-Engines gemeinsam sind und nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8</a> , an dem die Autoren der Engine ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benedict</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matias</a> ) arbeiten.  Als JavaScript-Entwickler kann ich sagen, dass ein tieferes Verst√§ndnis der Funktionsweise der JavaScript-Engine Ihnen dabei hilft, effizienten Code zu schreiben. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>Hinweis</b> : Wenn Sie lieber Pr√§sentationen als Artikel lesen m√∂chten, sehen Sie sich dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video an</a> .  Wenn nicht, √ºberspringen Sie es und lesen Sie weiter. </blockquote>  <b>Pipeline (Pipeline) JavaScript-Engine</b> <br><br>  Alles beginnt damit, dass Sie JavaScript-Code schreiben.  Danach verarbeitet die JavaScript-Engine den Quellcode und pr√§sentiert ihn als abstrakten Syntaxbaum (AST).  Basierend auf dem konstruierten AST kann der Interpreter endlich an die Arbeit gehen und mit der Generierung von Bytecode beginnen.  Gro√üartig!  Dies ist der Moment, in dem die Engine JavaScript-Code ausf√ºhrt. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  Um die Ausf√ºhrung zu beschleunigen, k√∂nnen Sie Bytecode zusammen mit Profildaten an den optimierenden Compiler senden.  Der optimierende Compiler trifft bestimmte Annahmen basierend auf Profildaten und generiert dann hochoptimierten Maschinencode. <br><br>  Wenn sich die Annahmen irgendwann als falsch herausstellen, optimiert der Optimierungs-Compiler den Code und kehrt zur Interpreter-Phase zur√ºck. <br><br>  <b>Interpreter-Pipelines / Compiler in JavaScript-Engines</b> <br><br>  Schauen wir uns nun die Teile der Pipeline genauer an, die Ihren JavaScript-Code ausf√ºhren, n√§mlich wo der Code interpretiert und optimiert wird, und einige Unterschiede zwischen den wichtigsten JavaScript-Engines. <br><br>  Das Herzst√ºck von allem ist eine Pipeline, die einen Interpreter und einen optimierenden Compiler enth√§lt.  Der Interpreter generiert schnell nicht optimierten Bytecode, der optimierende Compiler arbeitet wiederum l√§nger, aber die Ausgabe verf√ºgt √ºber einen stark optimierten Maschinencode. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  Als n√§chstes folgt eine Pipeline, die zeigt, wie V8 funktioniert, die von Chrome und Node.js verwendete JavaScript-Engine. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  Der Interpreter in V8 hei√üt Ignition und ist f√ºr die Generierung und Ausf√ºhrung des Bytecodes verantwortlich.  Es sammelt Profildaten, mit denen die Ausf√ºhrung im n√§chsten Schritt beschleunigt werden kann, w√§hrend der Bytecode verarbeitet wird.  Wenn eine Funktion <i>hei√ü wird</i> , beispielsweise wenn sie h√§ufig gestartet wird, werden der generierte Bytecode und die Profildaten an den TurboFan √ºbertragen, dh an den optimierenden Compiler, um auf der Grundlage der Profildaten hochoptimierten Maschinencode zu generieren. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  Beispielsweise funktioniert Mozillas SpiderMonkey-JavaScript-Engine, die in Firefox und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpiderNode verwendet wird</a> , etwas anders.  Es gibt nicht einen, sondern zwei optimierende Compiler.  Der Interpreter ist in einen Basis-Compiler (Baseline-Compiler) optimiert, der optimierten Code erzeugt.  Zusammen mit den w√§hrend der Codeausf√ºhrung gesammelten Profildaten kann der IonMonkey-Compiler stark optimierten Code generieren.  Wenn die spekulative Optimierung fehlschl√§gt, kehrt IonMonkey zum Baseline-Code zur√ºck. <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra - Microsofts JavaScript-Engine, die in Edge und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node-ChakraCore verwendet wird</a> , hat eine sehr √§hnliche Struktur und verwendet zwei optimierende Compiler.  Der Interpreter ist in SimpleJIT optimiert (wobei JIT f√ºr ‚ÄûJust-In-Time-Compiler‚Äú steht, der etwas optimierten Code erzeugt. Zusammen mit den Profildaten kann FullJIT noch st√§rker optimierten Code erstellen. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  JavaScriptCore (abgek√ºrzt als JSC), Apples JavaScript-Engine, die von Safari und React Native verwendet wird, verf√ºgt im Allgemeinen √ºber drei verschiedene Optimierungscompiler.  LLInt ist ein Low-Level-Interpreter, der f√ºr den Basis-Compiler optimiert ist, der wiederum f√ºr den DFG-Compiler (Data Flow Graph) optimiert ist und bereits f√ºr den FTL-Compiler (Faster Than Light) optimiert ist. <br><br>  Warum haben einige Engines mehr optimierende Compiler als andere?  Es geht um Kompromisse.  Der Interpreter kann Bytecode schnell verarbeiten, aber Bytecode allein ist nicht besonders effizient.  Der optimierende Compiler arbeitet dagegen etwas l√§nger, erzeugt aber effizienteren Maschinencode.  Dies ist ein Kompromiss zwischen dem schnellen Abrufen des Codes (Interpreter) oder dem Warten und Ausf√ºhren des Codes mit maximaler Leistung (Optimierung des Compilers).  Einige Engines f√ºgen mehrere optimierende Compiler mit unterschiedlichen Zeit- und Effizienzmerkmalen hinzu, sodass Sie diese Kompromissl√∂sung optimal steuern und die Kosten f√ºr zus√§tzliche Komplikationen des internen Ger√§ts verstehen k√∂nnen.  Ein weiterer Nachteil ist die Speichernutzung. Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden</a> Sie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> . <br><br>  Wir haben gerade die Hauptunterschiede zwischen Interpreter- und Optimizer-Compiler-Pipelines f√ºr verschiedene JavaScript-Engines untersucht.  Trotz dieser gro√üen Unterschiede haben alle JavaScript-Engines dieselbe Architektur: Sie haben alle einen Parser und eine Art Interpreter / Compiler-Pipeline. <br><br>  <b>JavaScript-Objektmodell</b> <br><br>  Mal sehen, was JavaScript-Engines sonst noch gemeinsam haben und welche Tricks sie verwenden, um den Zugriff auf die Eigenschaften von JavaScript-Objekten zu beschleunigen.  Es stellt sich heraus, dass alle Hauptmotoren dies auf √§hnliche Weise tun. <br><br>  Die ECMAScript-Spezifikation definiert alle Objekte als W√∂rterb√ºcher mit Zeichenfolgenschl√ºsseln, die den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigenschaftsattributen entsprechen</a> . <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  Zus√§tzlich zu <code>[[Value]]</code> definiert die Spezifikation die folgenden Eigenschaften: <br><br><ul><li>  <code>[[Writable]]</code> bestimmt, ob eine Eigenschaft neu zugewiesen werden kann. </li><li>  <code>[[Enumerable]]</code> bestimmt, ob die Eigenschaft in For-In-Schleifen angezeigt wird. </li><li>  <code>[[Configurable]]</code> bestimmt, ob eine Eigenschaft gel√∂scht werden kann. </li></ul><br>  Die Notation <code>[[  ]]</code> sieht seltsam aus, aber so beschreibt die Spezifikation Eigenschaften in JavaScript.  Sie k√∂nnen diese Eigenschaftsattribute f√ºr jedes Objekt und jede Eigenschaft in JavaScript mithilfe der <code>Object.getOwnPropertyDescriptor</code> API weiterhin <code>Object.getOwnPropertyDescriptor</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  Ok, also JavaScript definiert Objekte.  Was ist mit Arrays? <br><br>  Sie k√∂nnen sich Arrays als spezielle Objekte vorstellen.  Der einzige Unterschied besteht darin, dass Arrays √ºber eine spezielle Indexverarbeitung verf√ºgen.  Hier ist ein Array-Index ein spezieller Begriff in der ECMAScript-Spezifikation.  In JavaScript ist die Anzahl der Elemente in einem Array begrenzt - bis zu 2¬≥¬≤ - 1.  Ein Array-Index ist ein beliebiger verf√ºgbarer Index aus diesem Bereich, dh ein ganzzahliger Wert von 0 bis 2¬≥¬≤ - 2. <br><br>  Ein weiterer Unterschied besteht darin, dass Arrays die magische Eigenschaft der <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 2 array[2] = 'c'; array.length; // ‚Üí 3</span></span></code> </pre> <br>  In diesem Beispiel hat das Array zum Zeitpunkt der Erstellung eine L√§nge von 2.  Dann weisen wir Index 2 ein weiteres Element zu und die L√§nge erh√∂ht sich automatisch. <br><br>  JavaScript definiert sowohl Arrays als auch Objekte.  Beispielsweise werden alle Schl√ºssel, einschlie√ülich Array-Indizes, explizit als Zeichenfolgen dargestellt.  Das erste Element des Arrays wird unter dem Schl√ºssel '0' gespeichert. <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  Die <code>length</code> Eigenschaft ist nur eine weitere Eigenschaft, die sich als nicht aufz√§hlbar und nicht konfigurierbar herausstellt. <br><br>  Sobald ein Element zum Array hinzugef√ºgt wird, aktualisiert JavaScript automatisch das Attribut der Eigenschaft <code>[[Value]]</code> Eigenschaft <code>length</code> . <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  Im Allgemeinen k√∂nnen wir sagen, dass sich Arrays √§hnlich wie Objekte verhalten. <br><br>  <b>Optimierung des Zugriffs auf Immobilien</b> <br><br>  Nachdem wir nun wissen, wie Objekte in JavaScript definiert sind, werfen wir einen Blick darauf, wie Sie mit JavaScript-Engines effizient mit Objekten arbeiten k√∂nnen. <br><br>  Im Alltag ist der Zugang zu Immobilien die h√§ufigste Operation.  Es ist √§u√üerst wichtig, dass der Motor dies schnell erledigt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>Formulare</b> <br><br>  In JavaScript-Programmen ist es durchaus √ºblich, vielen Objekten dieselben Eigenschaftsschl√ºssel zuzuweisen.  Sie sagen, dass solche Objekte die gleiche <i>Form haben</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  Eine √ºbliche Mechanik ist auch der Zugriff auf die Eigenschaft von Objekten derselben Form: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  In diesem Wissen k√∂nnen JavaScript-Engines den Zugriff auf die Eigenschaft eines Objekts basierend auf seiner Form optimieren.  Sehen Sie, wie es funktioniert. <br><br>  Angenommen, wir haben ein Objekt mit den Eigenschaften x und y, es verwendet die W√∂rterbuchdatenstruktur, √ºber die wir zuvor gesprochen haben.  Es enth√§lt Schl√ºsselzeichenfolgen, die auf ihre jeweiligen Attribute verweisen. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  Wenn Sie auf eine Eigenschaft wie <code>object.y,</code> sucht die JavaScript-Engine nach einem JSObject mit dem Schl√ºssel <code>'y'</code> , l√§dt dann die Eigenschaftsattribute, die dieser Abfrage entsprechen, und gibt schlie√ülich <code>[[Value]]</code> . <br><br>  Aber wo werden diese Eigenschaftsattribute gespeichert?  Sollten wir sie als Teil eines JSObject speichern?  Wenn wir dies tun, werden wir sp√§ter weitere Objekte dieses Formulars sehen. In diesem Fall ist es eine Verschwendung von Speicherplatz, ein vollst√§ndiges W√∂rterbuch mit den Namen von Eigenschaften und Attributen in JSObject selbst zu speichern, da Eigenschaftsnamen f√ºr alle Objekte desselben Formulars wiederholt werden.  Dies f√ºhrt zu vielen √úberschneidungen und zu einer Fehlallokation des Speichers.  Zur Optimierung speichern die Engines die Form des Objekts separat. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  Diese <code>Shape</code> enth√§lt alle Eigenschaftsnamen und Attribute au√üer <code>[[Value]]</code> .  Stattdessen enth√§lt das Formular die Versatzwerte im JSObject, sodass die JavaScript-Engine wei√ü, wo nach den Werten gesucht werden muss.  Jedes JSObject mit einem gemeinsamen Formular gibt eine bestimmte Instanz des Formulars an.  Jetzt muss jedes JSObject nur Werte speichern, die f√ºr das Objekt eindeutig sind. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  Der Vorteil wird offensichtlich, sobald wir viele Objekte haben.  Ihre Anzahl spielt keine Rolle, denn wenn sie ein Formular haben, speichern wir Informationen √ºber das Formular und die Eigenschaft nur einmal. <br><br>  Alle JavaScript-Engines verwenden Formulare als Optimierungsmittel, benennen sie jedoch nicht direkt als <code>shapes</code> : <br><br><ol><li>  In der akademischen Dokumentation werden sie als versteckte Klassen bezeichnet (√§hnlich wie bei JavaScript-Klassen). </li><li>  V8 nennt sie Karten; </li><li>  Chakra nennt sie Typen; </li><li>  JavaScriptCore nennt sie Strukturen; </li><li>  SpiderMonkey nennt sie Shapes. </li></ol><br>  In diesem Artikel nennen wir sie weiterhin <code>shapes</code> . <br><br>  <b>√úbergangsketten und B√§ume</b> <br><br>  Was passiert, wenn Sie ein Objekt mit einer bestimmten Form haben, aber eine neue Eigenschaft hinzuf√ºgen?  Wie definiert die JavaScript-Engine ein neues Formular? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Formulare erstellen sogenannte √úbergangsketten in der JavaScript-Engine.  Hier ist ein Beispiel: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  Ein Objekt hat zun√§chst keine Eigenschaften, es entspricht einem leeren Formular.  Der folgende Ausdruck f√ºgt diesem Objekt die Eigenschaft <code>'x'</code> mit dem Wert 5 hinzu. Anschlie√üend wechselt die Engine zu dem Formular, das die Eigenschaft <code>'x'</code> enth√§lt <code>'x'</code> und der Wert 5 wird beim ersten Versatz 0 zu JSObject hinzugef√ºgt. In der n√§chsten Zeile wird die Eigenschaft <code>'y'</code> hinzugef√ºgt, und die Engine wechselt zum n√§chsten Ein Formular, das bereits <code>'x'</code> und <code>'y'</code> und JSObject bei Offset 1 den Wert 6 hinzuf√ºgt. <br><blockquote>  <b>Hinweis</b> : Die Reihenfolge, in der Eigenschaften hinzugef√ºgt werden, wirkt sich auf das Formular aus.  Zum Beispiel f√ºhrt {x: 4, y: 5} zu einer anderen Form als {y: 5, x: 4}. <br></blockquote>  Wir m√ºssen nicht einmal die gesamte Eigenschaftentabelle f√ºr jedes Formular speichern.  Stattdessen muss jedes Formular nur eine neue Eigenschaft kennen, die es aufnehmen m√∂chte.  In diesem Fall m√ºssen wir beispielsweise keine Informationen √ºber 'x' in der letzteren Form speichern, da diese fr√ºher in der Kette gefunden werden k√∂nnen.  Damit dies funktioniert, wird das Formular mit dem vorherigen Formular zusammengef√ºhrt. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  Wenn Sie <code>ox</code> in Ihren JavaScript-Code schreiben, sucht JavaScript entlang der √úbergangskette nach der Eigenschaft <code>'x'</code> , bis ein Formular erkannt wird, das bereits die Eigenschaft <code>'x'</code> . <br><br>  Aber was passiert, wenn es unm√∂glich ist, eine √úbergangskette zu erstellen?  Was passiert beispielsweise, wenn Sie zwei leere Objekte haben und ihnen unterschiedliche Eigenschaften hinzuf√ºgen? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  In diesem Fall wird ein Zweig angezeigt, und anstelle der √úbergangskette erhalten wir einen √úbergangsbaum: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  Wir erstellen ein leeres Objekt <code>a</code> und f√ºgen ihm die Eigenschaft <code>'x'</code> .  Als Ergebnis haben wir ein <code>JSObject</code> das einen einzelnen Wert und zwei Formulare enth√§lt: leer und ein Formular mit einer einzelnen <code>'x'</code> <code>JSObject</code> <code>'x'</code> Eigenschaft. <br><br>  Das zweite Beispiel beginnt mit der Tatsache, dass wir ein leeres Objekt <code>b</code> , aber dann f√ºgen wir eine weitere Eigenschaft <code>'y'</code> .  Als Ergebnis erhalten wir hier zwei Ketten von Formen, aber am Ende erhalten wir drei Ketten. <br><br>  Bedeutet das, dass wir immer mit einem leeren Formular beginnen?  Nicht unbedingt.  Die Engines verwenden eine Optimierung von Objektliteralen, die bereits Eigenschaften enthalten.  Angenommen, wir f√ºgen x hinzu, beginnend mit einem leeren Objektliteral, oder wir haben ein Objektliteral, das bereits <code>x</code> enth√§lt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  Im ersten Beispiel beginnen wir mit einem leeren Formular und gehen zu einer Kette, die auch <code>x</code> enth√§lt, wie wir zuvor gesehen haben. <br><br>  Im Fall von <code>object2</code> es sinnvoll, Objekte, die bereits von Anfang an x ‚Äã‚Äãhaben, direkt zu erstellen, anstatt mit einem leeren Objekt und einem √úbergang zu beginnen. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  Das Literal eines Objekts, das die Eigenschaft <code>'x'</code> enth√§lt <code>'x'</code> beginnt von Anfang an mit einem Formular, das <code>'x'</code> enth√§lt, und das leere Formular wird effektiv √ºbersprungen.  Dies ist (zumindest) das, was V8 und SpiderMonkey tun.  Die Optimierung verk√ºrzt die √úbergangskette und erleichtert das Zusammensetzen von Objekten aus Literalen. <br><br>  In Benedikts Blogbeitrag √ºber den erstaunlichen Polymorphismus von Anwendungen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React wird</a> erl√§utert, wie sich solche Feinheiten auf die Leistung auswirken k√∂nnen. <br><br>  Weiter sehen Sie ein Beispiel f√ºr Punkte eines dreidimensionalen Objekts mit den Eigenschaften <code>'x'</code> , <code>'y'</code> , <code>'z'</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Wie Sie zuvor verstanden haben, erstellen wir ein Objekt mit drei Formularen im Speicher (ohne das leere Formular).  Wenn Sie beispielsweise auf die Eigenschaft <code>'x'</code> dieses Objekts <code>point.x</code> , wenn Sie <code>point.x</code> in Ihr Programm schreiben, muss die JavaScript-Engine einer verkn√ºpften Liste folgen: <code>point.x</code> Sie mit dem Formular ganz unten und <code>point.x</code> Sie dann schrittweise zu dem Formular mit <code>'x'</code> ganz oben. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  Es stellt sich sehr langsam heraus, besonders wenn Sie es oft und mit vielen Eigenschaften des Objekts tun.  Die Verweilzeit einer Eigenschaft ist <code>O(n)</code> , d. H. Es ist eine lineare Funktion, die mit der Anzahl der Eigenschaften des Objekts korreliert.  Um die Suche nach Eigenschaften zu beschleunigen, f√ºgen JavaScript-Engines eine ShapeTable-Datenstruktur hinzu.  ShapeTable ist ein W√∂rterbuch, in dem die Schl√ºssel auf bestimmte Weise den Formularen zugeordnet werden und die gew√ºnschte Eigenschaft erzeugen. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  Warten Sie eine Sekunde, jetzt kehren wir zur W√∂rterbuchsuche zur√ºck ... Genau damit haben wir begonnen, als wir √ºberhaupt Formulare eingef√ºgt haben!  Warum interessieren wir uns √ºberhaupt f√ºr Formulare? <br>  Tatsache ist, dass Formulare zu einer weiteren Optimierung beitragen, die als <i>Inline-Caches bezeichnet wird.</i> <br><br>  Wir werden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Teil des</a> Artikels √ºber das Konzept von Inline-Caches oder ICs sprechen und m√∂chten Sie nun zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen offenen Webinar</a> einladen, das am 9. April vom ber√ºhmten Virenanalytiker und Teilzeitlehrer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Kolesnikov</a> abgehalten wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446446/">https://habr.com/ru/post/de446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446434/index.html">Skalierung der Zimbra Collaboration Suite</a></li>
<li><a href="../de446436/index.html">So erstellen Sie Hypothesen √ºber die Bed√ºrfnisse potenzieller Verbraucher Ihres zuk√ºnftigen Produkts</a></li>
<li><a href="../de446438/index.html">Unsere Erfahrung bei der Erstellung von Gateway-APIs</a></li>
<li><a href="../de446440/index.html">Das Buch Reagieren Sie schnell. Webanwendungen in React, JSX, Redux und GraphQL ¬ª</a></li>
<li><a href="../de446444/index.html">Von Skype zu WebRTC: Wie wir die Webvideokommunikation organisiert haben</a></li>
<li><a href="../de446448/index.html">5 Grundregeln f√ºr die Durchf√ºhrung von Probleminterviews zur Ermittlung der Verbraucherbed√ºrfnisse</a></li>
<li><a href="../de446452/index.html">Mondmission "Bereshit" - 4. April 2019, der √úbergang zur Mondumlaufbahn ist abgeschlossen, 7 Flugtage voraus, 6 Man√∂ver und 1 Landung</a></li>
<li><a href="../de446454/index.html">Golang Webserver-Entwicklung - Von einfach zu komplex</a></li>
<li><a href="../de446456/index.html">Importsubstitution in der Praxis. Teil 1. Optionen</a></li>
<li><a href="../de446458/index.html">Universal DRO basierend auf Arduino Nano - shDRO. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>