<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙌🏽 🖐️ ✅ Grundlagen der JavaScript-Engine: Allgemeine Formulare und Inline-Caching. Teil 1 👨🏽‍🍳 🏙️ 🧒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Freunde. Ende April starten wir einen neuen Kurs „Sicherheit von Informationssystemen“ . Und jetzt möchten wir Ihnen eine Übersetzung des Artike...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlagen der JavaScript-Engine: Allgemeine Formulare und Inline-Caching. Teil 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/446446/">  Hallo Freunde.  Ende April starten wir einen neuen Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Sicherheit von Informationssystemen“</a> .  Und jetzt möchten wir Ihnen eine Übersetzung des Artikels mitteilen, die für den Kurs sicherlich sehr nützlich sein wird.  Den Originalartikel finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie hier</a> . <br><br>  Der Artikel beschreibt die wichtigsten Grundlagen, die allen JavaScript-Engines gemeinsam sind und nicht nur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V8</a> , an dem die Autoren der Engine ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benedict</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Matias</a> ) arbeiten.  Als JavaScript-Entwickler kann ich sagen, dass ein tieferes Verständnis der Funktionsweise der JavaScript-Engine Ihnen dabei hilft, effizienten Code zu schreiben. <br><br><img src="https://habrastorage.org/webt/14/ef/xe/14efxewawb3ttgslcsxyzicgjy0.png"><br><a name="habracut"></a><br><blockquote>  <b>Hinweis</b> : Wenn Sie lieber Präsentationen als Artikel lesen möchten, sehen Sie sich dieses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video an</a> .  Wenn nicht, überspringen Sie es und lesen Sie weiter. </blockquote>  <b>Pipeline (Pipeline) JavaScript-Engine</b> <br><br>  Alles beginnt damit, dass Sie JavaScript-Code schreiben.  Danach verarbeitet die JavaScript-Engine den Quellcode und präsentiert ihn als abstrakten Syntaxbaum (AST).  Basierend auf dem konstruierten AST kann der Interpreter endlich an die Arbeit gehen und mit der Generierung von Bytecode beginnen.  Großartig!  Dies ist der Moment, in dem die Engine JavaScript-Code ausführt. <br><br><img src="https://habrastorage.org/webt/i6/8r/f2/i68rf23urqlxa20gzhubwz2-snq.jpeg"><br><br>  Um die Ausführung zu beschleunigen, können Sie Bytecode zusammen mit Profildaten an den optimierenden Compiler senden.  Der optimierende Compiler trifft bestimmte Annahmen basierend auf Profildaten und generiert dann hochoptimierten Maschinencode. <br><br>  Wenn sich die Annahmen irgendwann als falsch herausstellen, optimiert der Optimierungs-Compiler den Code und kehrt zur Interpreter-Phase zurück. <br><br>  <b>Interpreter-Pipelines / Compiler in JavaScript-Engines</b> <br><br>  Schauen wir uns nun die Teile der Pipeline genauer an, die Ihren JavaScript-Code ausführen, nämlich wo der Code interpretiert und optimiert wird, und einige Unterschiede zwischen den wichtigsten JavaScript-Engines. <br><br>  Das Herzstück von allem ist eine Pipeline, die einen Interpreter und einen optimierenden Compiler enthält.  Der Interpreter generiert schnell nicht optimierten Bytecode, der optimierende Compiler arbeitet wiederum länger, aber die Ausgabe verfügt über einen stark optimierten Maschinencode. <br><br><img src="https://habrastorage.org/webt/gh/ap/o6/ghapo68sxzyqniyjqw0v0xewpry.jpeg"><br><br>  Als nächstes folgt eine Pipeline, die zeigt, wie V8 funktioniert, die von Chrome und Node.js verwendete JavaScript-Engine. <br><br><img src="https://habrastorage.org/webt/8i/nu/0w/8inu0wkuzc8_enexkp8o7pn7jgi.jpeg"><br><br>  Der Interpreter in V8 heißt Ignition und ist für die Generierung und Ausführung des Bytecodes verantwortlich.  Es sammelt Profildaten, mit denen die Ausführung im nächsten Schritt beschleunigt werden kann, während der Bytecode verarbeitet wird.  Wenn eine Funktion <i>heiß wird</i> , beispielsweise wenn sie häufig gestartet wird, werden der generierte Bytecode und die Profildaten an den TurboFan übertragen, dh an den optimierenden Compiler, um auf der Grundlage der Profildaten hochoptimierten Maschinencode zu generieren. <br><br><img src="https://habrastorage.org/webt/ww/n5/zi/wwn5zi7l8vzzcfaik86qwhdtprc.jpeg"><br><br>  Beispielsweise funktioniert Mozillas SpiderMonkey-JavaScript-Engine, die in Firefox und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SpiderNode verwendet wird</a> , etwas anders.  Es gibt nicht einen, sondern zwei optimierende Compiler.  Der Interpreter ist in einen Basis-Compiler (Baseline-Compiler) optimiert, der optimierten Code erzeugt.  Zusammen mit den während der Codeausführung gesammelten Profildaten kann der IonMonkey-Compiler stark optimierten Code generieren.  Wenn die spekulative Optimierung fehlschlägt, kehrt IonMonkey zum Baseline-Code zurück. <br><br><img src="https://habrastorage.org/webt/gu/ek/ps/guekpsu0p1nqwv-pynj7ts8skdo.jpeg"><br><br>  Chakra - Microsofts JavaScript-Engine, die in Edge und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Node-ChakraCore verwendet wird</a> , hat eine sehr ähnliche Struktur und verwendet zwei optimierende Compiler.  Der Interpreter ist in SimpleJIT optimiert (wobei JIT für „Just-In-Time-Compiler“ steht, der etwas optimierten Code erzeugt. Zusammen mit den Profildaten kann FullJIT noch stärker optimierten Code erstellen. <br><br><img src="https://habrastorage.org/webt/z-/bl/0v/z-bl0va0qlsrvgandnxrb08q52g.jpeg"><br><br>  JavaScriptCore (abgekürzt als JSC), Apples JavaScript-Engine, die von Safari und React Native verwendet wird, verfügt im Allgemeinen über drei verschiedene Optimierungscompiler.  LLInt ist ein Low-Level-Interpreter, der für den Basis-Compiler optimiert ist, der wiederum für den DFG-Compiler (Data Flow Graph) optimiert ist und bereits für den FTL-Compiler (Faster Than Light) optimiert ist. <br><br>  Warum haben einige Engines mehr optimierende Compiler als andere?  Es geht um Kompromisse.  Der Interpreter kann Bytecode schnell verarbeiten, aber Bytecode allein ist nicht besonders effizient.  Der optimierende Compiler arbeitet dagegen etwas länger, erzeugt aber effizienteren Maschinencode.  Dies ist ein Kompromiss zwischen dem schnellen Abrufen des Codes (Interpreter) oder dem Warten und Ausführen des Codes mit maximaler Leistung (Optimierung des Compilers).  Einige Engines fügen mehrere optimierende Compiler mit unterschiedlichen Zeit- und Effizienzmerkmalen hinzu, sodass Sie diese Kompromisslösung optimal steuern und die Kosten für zusätzliche Komplikationen des internen Geräts verstehen können.  Ein weiterer Nachteil ist die Speichernutzung. Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen finden</a> Sie in diesem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> . <br><br>  Wir haben gerade die Hauptunterschiede zwischen Interpreter- und Optimizer-Compiler-Pipelines für verschiedene JavaScript-Engines untersucht.  Trotz dieser großen Unterschiede haben alle JavaScript-Engines dieselbe Architektur: Sie haben alle einen Parser und eine Art Interpreter / Compiler-Pipeline. <br><br>  <b>JavaScript-Objektmodell</b> <br><br>  Mal sehen, was JavaScript-Engines sonst noch gemeinsam haben und welche Tricks sie verwenden, um den Zugriff auf die Eigenschaften von JavaScript-Objekten zu beschleunigen.  Es stellt sich heraus, dass alle Hauptmotoren dies auf ähnliche Weise tun. <br><br>  Die ECMAScript-Spezifikation definiert alle Objekte als Wörterbücher mit Zeichenfolgenschlüsseln, die den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigenschaftsattributen entsprechen</a> . <br><br><img src="https://habrastorage.org/webt/7s/vv/qq/7svvqqqqfcqi2y-v88nlstidtik.jpeg"><br><br>  Zusätzlich zu <code>[[Value]]</code> definiert die Spezifikation die folgenden Eigenschaften: <br><br><ul><li>  <code>[[Writable]]</code> bestimmt, ob eine Eigenschaft neu zugewiesen werden kann. </li><li>  <code>[[Enumerable]]</code> bestimmt, ob die Eigenschaft in For-In-Schleifen angezeigt wird. </li><li>  <code>[[Configurable]]</code> bestimmt, ob eine Eigenschaft gelöscht werden kann. </li></ul><br>  Die Notation <code>[[  ]]</code> sieht seltsam aus, aber so beschreibt die Spezifikation Eigenschaften in JavaScript.  Sie können diese Eigenschaftsattribute für jedes Objekt und jede Eigenschaft in JavaScript mithilfe der <code>Object.getOwnPropertyDescriptor</code> API weiterhin <code>Object.getOwnPropertyDescriptor</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// → { value: 42, writable: true, enumerable: true, configurable: true }</span></span></code> </pre> <br>  Ok, also JavaScript definiert Objekte.  Was ist mit Arrays? <br><br>  Sie können sich Arrays als spezielle Objekte vorstellen.  Der einzige Unterschied besteht darin, dass Arrays über eine spezielle Indexverarbeitung verfügen.  Hier ist ein Array-Index ein spezieller Begriff in der ECMAScript-Spezifikation.  In JavaScript ist die Anzahl der Elemente in einem Array begrenzt - bis zu 2³² - 1.  Ein Array-Index ist ein beliebiger verfügbarer Index aus diesem Bereich, dh ein ganzzahliger Wert von 0 bis 2³² - 2. <br><br>  Ein weiterer Unterschied besteht darin, dass Arrays die magische Eigenschaft der <code>length</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> array = [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]; array.length; <span class="hljs-comment"><span class="hljs-comment">// → 2 array[2] = 'c'; array.length; // → 3</span></span></code> </pre> <br>  In diesem Beispiel hat das Array zum Zeitpunkt der Erstellung eine Länge von 2.  Dann weisen wir Index 2 ein weiteres Element zu und die Länge erhöht sich automatisch. <br><br>  JavaScript definiert sowohl Arrays als auch Objekte.  Beispielsweise werden alle Schlüssel, einschließlich Array-Indizes, explizit als Zeichenfolgen dargestellt.  Das erste Element des Arrays wird unter dem Schlüssel '0' gespeichert. <br><br><img src="https://habrastorage.org/webt/a0/nr/18/a0nr18etozy9wzmzzsd9zbykxt0.jpeg"><br><br>  Die <code>length</code> Eigenschaft ist nur eine weitere Eigenschaft, die sich als nicht aufzählbar und nicht konfigurierbar herausstellt. <br><br>  Sobald ein Element zum Array hinzugefügt wird, aktualisiert JavaScript automatisch das Attribut der Eigenschaft <code>[[Value]]</code> Eigenschaft <code>length</code> . <br><br><img src="https://habrastorage.org/webt/ws/hs/89/wshs896vflemplsrai-wqu5brkw.jpeg"><br><br>  Im Allgemeinen können wir sagen, dass sich Arrays ähnlich wie Objekte verhalten. <br><br>  <b>Optimierung des Zugriffs auf Immobilien</b> <br><br>  Nachdem wir nun wissen, wie Objekte in JavaScript definiert sind, werfen wir einen Blick darauf, wie Sie mit JavaScript-Engines effizient mit Objekten arbeiten können. <br><br>  Im Alltag ist der Zugang zu Immobilien die häufigste Operation.  Es ist äußerst wichtig, dass der Motor dies schnell erledigt. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-string"><span class="hljs-string">'qux'</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">// Here, we're accessing the property `foo` on `object`: doSomething(object.foo); // ^^^^^^^^^^</span></span></code> </pre> <br>  <b>Formulare</b> <br><br>  In JavaScript-Programmen ist es durchaus üblich, vielen Objekten dieselben Eigenschaftsschlüssel zuzuweisen.  Sie sagen, dass solche Objekte die gleiche <i>Form haben</i> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// `object1` and `object2` have the same shape.</span></span></code> </pre> <br>  Eine übliche Mechanik ist auch der Zugriff auf die Eigenschaft von Objekten derselben Form: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(object.x); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^ } const object1 = { x: 1, y: 2 }; const object2 = { x: 3, y: 4 }; logX(object1); logX(object2);</span></span></code> </pre> <br>  In diesem Wissen können JavaScript-Engines den Zugriff auf die Eigenschaft eines Objekts basierend auf seiner Form optimieren.  Sehen Sie, wie es funktioniert. <br><br>  Angenommen, wir haben ein Objekt mit den Eigenschaften x und y, es verwendet die Wörterbuchdatenstruktur, über die wir zuvor gesprochen haben.  Es enthält Schlüsselzeichenfolgen, die auf ihre jeweiligen Attribute verweisen. <br><br><img src="https://habrastorage.org/webt/ss/ne/v9/ssnev9md3jko58annrfjraz35ay.jpeg"><br><br>  Wenn Sie auf eine Eigenschaft wie <code>object.y,</code> sucht die JavaScript-Engine nach einem JSObject mit dem Schlüssel <code>'y'</code> , lädt dann die Eigenschaftsattribute, die dieser Abfrage entsprechen, und gibt schließlich <code>[[Value]]</code> . <br><br>  Aber wo werden diese Eigenschaftsattribute gespeichert?  Sollten wir sie als Teil eines JSObject speichern?  Wenn wir dies tun, werden wir später weitere Objekte dieses Formulars sehen. In diesem Fall ist es eine Verschwendung von Speicherplatz, ein vollständiges Wörterbuch mit den Namen von Eigenschaften und Attributen in JSObject selbst zu speichern, da Eigenschaftsnamen für alle Objekte desselben Formulars wiederholt werden.  Dies führt zu vielen Überschneidungen und zu einer Fehlallokation des Speichers.  Zur Optimierung speichern die Engines die Form des Objekts separat. <br><br><img src="https://habrastorage.org/webt/mc/yr/mt/mcyrmt9jarqodgtvnwoxzatiwyy.jpeg"><br><br>  Diese <code>Shape</code> enthält alle Eigenschaftsnamen und Attribute außer <code>[[Value]]</code> .  Stattdessen enthält das Formular die Versatzwerte im JSObject, sodass die JavaScript-Engine weiß, wo nach den Werten gesucht werden muss.  Jedes JSObject mit einem gemeinsamen Formular gibt eine bestimmte Instanz des Formulars an.  Jetzt muss jedes JSObject nur Werte speichern, die für das Objekt eindeutig sind. <br><br><img src="https://habrastorage.org/webt/-0/-q/t5/-0-qt5an58iyuoeskzaibbtgcno.jpeg"><br><br>  Der Vorteil wird offensichtlich, sobald wir viele Objekte haben.  Ihre Anzahl spielt keine Rolle, denn wenn sie ein Formular haben, speichern wir Informationen über das Formular und die Eigenschaft nur einmal. <br><br>  Alle JavaScript-Engines verwenden Formulare als Optimierungsmittel, benennen sie jedoch nicht direkt als <code>shapes</code> : <br><br><ol><li>  In der akademischen Dokumentation werden sie als versteckte Klassen bezeichnet (ähnlich wie bei JavaScript-Klassen). </li><li>  V8 nennt sie Karten; </li><li>  Chakra nennt sie Typen; </li><li>  JavaScriptCore nennt sie Strukturen; </li><li>  SpiderMonkey nennt sie Shapes. </li></ol><br>  In diesem Artikel nennen wir sie weiterhin <code>shapes</code> . <br><br>  <b>Übergangsketten und Bäume</b> <br><br>  Was passiert, wenn Sie ein Objekt mit einer bestimmten Form haben, aber eine neue Eigenschaft hinzufügen?  Wie definiert die JavaScript-Engine ein neues Formular? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = {}; object.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; object.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Formulare erstellen sogenannte Übergangsketten in der JavaScript-Engine.  Hier ist ein Beispiel: <br><br><img src="https://habrastorage.org/webt/tm/tz/np/tmtznpiuyzkz9vpxqe6byhw2x-k.jpeg"><br><br>  Ein Objekt hat zunächst keine Eigenschaften, es entspricht einem leeren Formular.  Der folgende Ausdruck fügt diesem Objekt die Eigenschaft <code>'x'</code> mit dem Wert 5 hinzu. Anschließend wechselt die Engine zu dem Formular, das die Eigenschaft <code>'x'</code> enthält <code>'x'</code> und der Wert 5 wird beim ersten Versatz 0 zu JSObject hinzugefügt. In der nächsten Zeile wird die Eigenschaft <code>'y'</code> hinzugefügt, und die Engine wechselt zum nächsten Ein Formular, das bereits <code>'x'</code> und <code>'y'</code> und JSObject bei Offset 1 den Wert 6 hinzufügt. <br><blockquote>  <b>Hinweis</b> : Die Reihenfolge, in der Eigenschaften hinzugefügt werden, wirkt sich auf das Formular aus.  Zum Beispiel führt {x: 4, y: 5} zu einer anderen Form als {y: 5, x: 4}. <br></blockquote>  Wir müssen nicht einmal die gesamte Eigenschaftentabelle für jedes Formular speichern.  Stattdessen muss jedes Formular nur eine neue Eigenschaft kennen, die es aufnehmen möchte.  In diesem Fall müssen wir beispielsweise keine Informationen über 'x' in der letzteren Form speichern, da diese früher in der Kette gefunden werden können.  Damit dies funktioniert, wird das Formular mit dem vorherigen Formular zusammengeführt. <br><br><img src="https://habrastorage.org/webt/ks/ou/pv/ksoupve8bep3jsp0v7u2ahyv9jg.jpeg"><br><br>  Wenn Sie <code>ox</code> in Ihren JavaScript-Code schreiben, sucht JavaScript entlang der Übergangskette nach der Eigenschaft <code>'x'</code> , bis ein Formular erkannt wird, das bereits die Eigenschaft <code>'x'</code> . <br><br>  Aber was passiert, wenn es unmöglich ist, eine Übergangskette zu erstellen?  Was passiert beispielsweise, wenn Sie zwei leere Objekte haben und ihnen unterschiedliche Eigenschaften hinzufügen? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; object2.y = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  In diesem Fall wird ein Zweig angezeigt, und anstelle der Übergangskette erhalten wir einen Übergangsbaum: <br><br><img src="https://habrastorage.org/webt/bc/ga/ax/bcgaaxeskfqwqt8geu_pxmqwdou.jpeg"><br><br>  Wir erstellen ein leeres Objekt <code>a</code> und fügen ihm die Eigenschaft <code>'x'</code> .  Als Ergebnis haben wir ein <code>JSObject</code> das einen einzelnen Wert und zwei Formulare enthält: leer und ein Formular mit einer einzelnen <code>'x'</code> <code>JSObject</code> <code>'x'</code> Eigenschaft. <br><br>  Das zweite Beispiel beginnt mit der Tatsache, dass wir ein leeres Objekt <code>b</code> , aber dann fügen wir eine weitere Eigenschaft <code>'y'</code> .  Als Ergebnis erhalten wir hier zwei Ketten von Formen, aber am Ende erhalten wir drei Ketten. <br><br>  Bedeutet das, dass wir immer mit einem leeren Formular beginnen?  Nicht unbedingt.  Die Engines verwenden eine Optimierung von Objektliteralen, die bereits Eigenschaften enthalten.  Angenommen, wir fügen x hinzu, beginnend mit einem leeren Objektliteral, oder wir haben ein Objektliteral, das bereits <code>x</code> enthält: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; object1.x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> };</code> </pre> <br>  Im ersten Beispiel beginnen wir mit einem leeren Formular und gehen zu einer Kette, die auch <code>x</code> enthält, wie wir zuvor gesehen haben. <br><br>  Im Fall von <code>object2</code> es sinnvoll, Objekte, die bereits von Anfang an x ​​haben, direkt zu erstellen, anstatt mit einem leeren Objekt und einem Übergang zu beginnen. <br><br><img src="https://habrastorage.org/webt/qv/_0/l-/qv_0l-f5eekqflfmto7lfd-awwq.jpeg"><br><br>  Das Literal eines Objekts, das die Eigenschaft <code>'x'</code> enthält <code>'x'</code> beginnt von Anfang an mit einem Formular, das <code>'x'</code> enthält, und das leere Formular wird effektiv übersprungen.  Dies ist (zumindest) das, was V8 und SpiderMonkey tun.  Die Optimierung verkürzt die Übergangskette und erleichtert das Zusammensetzen von Objekten aus Literalen. <br><br>  In Benedikts Blogbeitrag über den erstaunlichen Polymorphismus von Anwendungen auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React wird</a> erläutert, wie sich solche Feinheiten auf die Leistung auswirken können. <br><br>  Weiter sehen Sie ein Beispiel für Punkte eines dreidimensionalen Objekts mit den Eigenschaften <code>'x'</code> , <code>'y'</code> , <code>'z'</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> point = {}; point.x = <span class="hljs-number"><span class="hljs-number">4</span></span>; point.y = <span class="hljs-number"><span class="hljs-number">5</span></span>; point.z = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  Wie Sie zuvor verstanden haben, erstellen wir ein Objekt mit drei Formularen im Speicher (ohne das leere Formular).  Wenn Sie beispielsweise auf die Eigenschaft <code>'x'</code> dieses Objekts <code>point.x</code> , wenn Sie <code>point.x</code> in Ihr Programm schreiben, muss die JavaScript-Engine einer verknüpften Liste folgen: <code>point.x</code> Sie mit dem Formular ganz unten und <code>point.x</code> Sie dann schrittweise zu dem Formular mit <code>'x'</code> ganz oben. <br><br><img src="https://habrastorage.org/webt/tv/rn/mp/tvrnmp1s5p25dseplockgifr6x0.jpeg"><br><br>  Es stellt sich sehr langsam heraus, besonders wenn Sie es oft und mit vielen Eigenschaften des Objekts tun.  Die Verweilzeit einer Eigenschaft ist <code>O(n)</code> , d. H. Es ist eine lineare Funktion, die mit der Anzahl der Eigenschaften des Objekts korreliert.  Um die Suche nach Eigenschaften zu beschleunigen, fügen JavaScript-Engines eine ShapeTable-Datenstruktur hinzu.  ShapeTable ist ein Wörterbuch, in dem die Schlüssel auf bestimmte Weise den Formularen zugeordnet werden und die gewünschte Eigenschaft erzeugen. <br><br><img src="https://habrastorage.org/webt/y8/vh/40/y8vh40rwdlx99jdv-rpumbe1u3u.jpeg"><br><br>  Warten Sie eine Sekunde, jetzt kehren wir zur Wörterbuchsuche zurück ... Genau damit haben wir begonnen, als wir überhaupt Formulare eingefügt haben!  Warum interessieren wir uns überhaupt für Formulare? <br>  Tatsache ist, dass Formulare zu einer weiteren Optimierung beitragen, die als <i>Inline-Caches bezeichnet wird.</i> <br><br>  Wir werden im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zweiten Teil des</a> Artikels über das Konzept von Inline-Caches oder ICs sprechen und möchten Sie nun zu einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlosen offenen Webinar</a> einladen, das am 9. April vom berühmten Virenanalytiker und Teilzeitlehrer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexander Kolesnikov</a> abgehalten wird. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446446/">https://habr.com/ru/post/de446446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446434/index.html">Skalierung der Zimbra Collaboration Suite</a></li>
<li><a href="../de446436/index.html">So erstellen Sie Hypothesen über die Bedürfnisse potenzieller Verbraucher Ihres zukünftigen Produkts</a></li>
<li><a href="../de446438/index.html">Unsere Erfahrung bei der Erstellung von Gateway-APIs</a></li>
<li><a href="../de446440/index.html">Das Buch Reagieren Sie schnell. Webanwendungen in React, JSX, Redux und GraphQL »</a></li>
<li><a href="../de446444/index.html">Von Skype zu WebRTC: Wie wir die Webvideokommunikation organisiert haben</a></li>
<li><a href="../de446448/index.html">5 Grundregeln für die Durchführung von Probleminterviews zur Ermittlung der Verbraucherbedürfnisse</a></li>
<li><a href="../de446452/index.html">Mondmission "Bereshit" - 4. April 2019, der Übergang zur Mondumlaufbahn ist abgeschlossen, 7 Flugtage voraus, 6 Manöver und 1 Landung</a></li>
<li><a href="../de446454/index.html">Golang Webserver-Entwicklung - Von einfach zu komplex</a></li>
<li><a href="../de446456/index.html">Importsubstitution in der Praxis. Teil 1. Optionen</a></li>
<li><a href="../de446458/index.html">Universal DRO basierend auf Arduino Nano - shDRO. Teil 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>