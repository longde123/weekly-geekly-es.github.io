<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🌾 🕚 🤚🏼 Aspek bermasalah pemrograman di C ++ ⛅️ ☦️ 🤲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam C ++, ada beberapa fitur yang dapat dianggap berpotensi berbahaya - dengan kesalahan perhitungan dalam desain atau pengkodean yang tidak akurat,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aspek bermasalah pemrograman di C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428898/"><hr><p>  <i>Dalam C ++, ada beberapa fitur yang dapat dianggap berpotensi berbahaya - dengan kesalahan perhitungan dalam desain atau pengkodean yang tidak akurat, mereka dapat dengan mudah menyebabkan kesalahan.</i>  <i>Artikel ini menyediakan pilihan fitur seperti itu, memberikan tips tentang cara mengurangi dampak negatifnya.</i> <i><br></i> </p><hr><br><a name="habracut"></a><br><h1>  Daftar isi </h1><br><div class="spoiler">  <b class="spoiler_title">Daftar isi</b> <div class="spoiler_text"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1. Jenis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Petunjuk dan operator bersyarat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konversi tersirat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2. Resolusi Nama</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menyembunyikan Variabel dalam Lingkup Bertingkat</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelebihan fungsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3. Konstruktor, destruktor, inisialisasi, penghapusan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fungsi anggota kelas yang dihasilkan oleh kompiler</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Variabel tidak diinisialisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prosedur Inisialisasi untuk Kelas Dasar dan Anggota Kelas Non-Statis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prosedur Inisialisasi untuk Anggota Kelas Statis dan Variabel Global</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengecualian dalam destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghapus objek dan array dinamis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penghapusan dengan deklarasi kelas yang tidak lengkap</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4. Operator, ekspresi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prioritas Operator</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Operator Kelebihan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Prosedur untuk menghitung subekspresi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. Fungsi virtual</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.1 Mengesampingkan fungsi virtual</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.2 Overloading dan menggunakan parameter default</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.3 Memanggil fungsi virtual dalam konstruktor dan destruktor</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5.4 Penghancur virtual</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6. Bekerja langsung dengan memori</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.1 Meluap buffer</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.2 string yang diakhiri Z</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6.3 Fungsi dengan sejumlah variabel parameter</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7. Sintaks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7.1 Pengumuman yang rumit</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">7.2 Ambiguitas sintaksis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8. Lain-lain</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8.1 Kata kunci inline dan ODR</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8.2 File header</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8,3 pernyataan beralih</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8.4 Melewati parameter dengan nilai</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8.5 Manajemen Sumber Daya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8.6 Link yang memiliki dan tidak memiliki</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8.7 Kompatibilitas Biner</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">8.8 Macro</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">9. Ringkasan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Referensi</a> <br></p><br></div></div><br><p>  <i>Praemonitus, praemunitus.</i> <i><br></i>  <i>Diperingatkan berarti dipersenjatai.</i>  <i>(lat.)</i> <br></p><br><a name="id-introdaction"></a><br><h1>  Pendahuluan </h1><br><p>  Dalam C ++ ada banyak fitur yang dapat dianggap berpotensi berbahaya - ketika salah perhitungan dalam desain atau pengkodean yang tidak akurat, mereka dapat dengan mudah menyebabkan kesalahan.  Beberapa dari mereka dapat dikaitkan dengan masa kanak-kanak yang sulit, beberapa dengan standar C ++ 98 yang ketinggalan zaman, tetapi yang lain sudah dikaitkan dengan fitur-fitur dari C ++ modern.  Pertimbangkan yang utama dan cobalah untuk memberikan saran tentang cara mengurangi dampak negatifnya. </p><br><a name="id-1"></a><br><h1>  1. Jenis </h1><br><a name="id-1-1"></a><br><h2>  1.1.  Petunjuk dan operator bersyarat </h2><br><p> Kebutuhan kompatibilitas dengan C mengarah pada fakta bahwa dalam pernyataan <code>if(...)</code> dan sejenisnya, Anda dapat mengganti setiap ekspresi numerik atau penunjuk, dan bukan hanya ekspresi seperti <code>bool</code> .  Masalahnya diperparah oleh konversi implisit dari <code>bool</code> ke <code>int</code> dalam ekspresi aritmatika dan prioritas beberapa operator.  Ini mengarah, misalnya, ke kesalahan berikut: </p><br><p>  <code>if(a=b)</code> ketika dengan benar <code>if(a==b)</code> , <br>  <code>if(a&lt;x&lt;b)</code> , ketika dengan benar <code>if(a&lt;x &amp;&amp; x&lt;b)</code> , <br>  <code>if(a&amp;x==0)</code> , ketika dengan benar <code>if((a&amp;x)==0)</code> , <br>  <code>if(Foo)</code> ketika dengan benar <code>if(Foo())</code> , <br>  <code>if(arr)</code> bila benar <code>if(arr[0])</code> , <br>  <code>if(strcmp(s,r))</code> ketika benar <code>if(strcmp(s,r)==0)</code> . </p><br><p>  Beberapa kesalahan ini menyebabkan peringatan kompiler, tetapi bukan kesalahan.  Penganalisa kode terkadang juga bisa membantu.  Dalam C #, kesalahan seperti itu hampir tidak mungkin, pernyataan <code>if(...)</code> dan sejenisnya memerlukan tipe <code>bool</code> , Anda tidak dapat mencampur tipe <code>bool</code> dan numerik dalam ekspresi aritmatika. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Program tanpa peringatan.  Sayangnya, ini tidak selalu membantu, beberapa kesalahan yang dijelaskan di atas tidak memberikan peringatan. </li><li>  Gunakan penganalisa kode statis. </li><li>  Teknik penerimaan kuno: ketika membandingkan dengan konstanta, letakkan di sebelah kiri, misalnya <code>if(MAX_PATH==x)</code> .  Itu terlihat cantik kondominium (dan bahkan memiliki namanya sendiri - "notasi Yoda"), dan membantu dalam sejumlah kecil kasus dipertimbangkan. </li><li>  Gunakan kualifikasi <code>const</code> seluas mungkin.  Sekali lagi, itu tidak selalu membantu. </li><li>  Biasakan diri Anda untuk menulis ekspresi logis yang benar: <code>if(x!=0)</code> alih-alih <code>if(x)</code> .  (Meskipun Anda dapat jatuh ke dalam perangkap prioritas operator di sini, lihat contoh ketiga.) </li><li>  Menjadi sangat perhatian. </li></ul><br><a name="id-1-2"></a><br><h2>  1.2.  Konversi tersirat </h2><br><p>  C ++ mengacu pada bahasa yang diketik dengan kuat, tetapi konversi tipe implisit banyak digunakan untuk membuat kode lebih pendek.  Konversi tersirat ini dalam beberapa kasus dapat menyebabkan kesalahan. </p><br><p>  Konversi tersirat yang paling menyebalkan adalah konversi dari tipe numerik atau pointer ke <code>bool</code> dan dari <code>bool</code> ke <code>int</code> .  Transformasi ini (diperlukan untuk kompatibilitas dengan C) yang menyebabkan masalah yang dijelaskan dalam bagian 1.1.  Konversi tersirat yang berpotensi menyebabkan hilangnya keakuratan data numerik (penyempitan konversi), misalnya, dari <code>double</code> ke <code>int</code> juga tidak selalu sesuai.  Dalam banyak kasus, kompiler menghasilkan peringatan (terutama ketika mungkin ada kehilangan keakuratan data numerik), tetapi peringatan bukan kesalahan.  Dalam C #, konversi antara tipe numerik dan <code>bool</code> dilarang (bahkan eksplisit), dan konversi yang berpotensi menyebabkan hilangnya presisi dalam data numerik hampir selalu merupakan kesalahan. </p><br><p>  Programmer dapat menambahkan konversi tersirat lainnya: (1) mendefinisikan konstruktor dengan satu parameter tanpa kata kunci <code>explicit</code> ;  (2) definisi operator konversi tipe.  Transformasi ini memecah celah keamanan tambahan berdasarkan pada prinsip pengetikan yang kuat. </p><br><p>  Dalam C #, jumlah konversi implisit bawaan jauh lebih kecil, konversi kustom tersirat harus dinyatakan menggunakan kata kunci <code>implicit</code> . </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Program tanpa peringatan. </li><li>  Berhati-hatilah dengan desain yang dijelaskan di atas, jangan menggunakannya tanpa kebutuhan ekstrim. </li></ul><br><a name="id-2"></a><br><h1>  2. Resolusi Nama </h1><br><a name="id-2-1"></a><br><h2>  2.1.  Menyembunyikan Variabel dalam Lingkup Bertingkat </h2><br><p>  Di C ++, aturan berikut ini berlaku.  Biarkan </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {        int x;        // ...    } }</span></span></code> </pre> <br><p>  Menurut aturan C ++, variabel <code></code> dideklarasikan dalam <code></code> menyembunyikan variabel <code></code> dideklarasikan dalam <code></code>  Deklarasi pertama <code>x</code> tidak harus dalam sebuah blok: itu bisa menjadi anggota kelas atau variabel global, hanya perlu terlihat di blok <code></code> </p><br><p>  Bayangkan sekarang situasi ketika Anda perlu memperbaiki kode berikut </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    int x;    // ... //  ,       {    // -         } }</span></span></code> </pre> <br><p>  Secara tidak sengaja, perubahan dilakukan: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   {    //  , :    int x;    // -         // ...    //  :    // -      }</span></span></code> </pre> <br><p>  Dan sekarang kode "sesuatu sedang dilakukan dengan <code></code> dari <code></code> " akan melakukan sesuatu dengan <code></code> dari <code></code> !  Jelas bahwa semuanya tidak berfungsi seperti sebelumnya, dan untuk menemukan apa yang seringkali sangat sulit.  Tidak sia-sia bahwa dalam C # dilarang untuk menyembunyikan variabel lokal (meskipun anggota kelas bisa).  Perhatikan bahwa mekanisme menyembunyikan variabel dalam satu bentuk atau yang lain digunakan di hampir semua bahasa pemrograman. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Deklarasikan variabel dalam ruang lingkup sesempit mungkin. </li><li>  Jangan menulis blok yang panjang dan bersarang. </li><li>  Gunakan konvensi pengkodean untuk membedakan secara visual pengidentifikasi dari cakupan yang berbeda. </li><li>  Menjadi sangat perhatian. </li></ul><br><a name="id-2-2"></a><br><h2>  2.2.  Kelebihan fungsi </h2><br><p>  Function overloading adalah fitur integral dari banyak bahasa pemrograman dan tidak terkecuali C ++.  Tetapi kesempatan ini harus digunakan dengan hati-hati, jika tidak Anda dapat mengalami masalah.  Dalam beberapa kasus, misalnya, ketika konstruktor kelebihan beban, programmer tidak punya pilihan, tetapi dalam kasus lain, penolakan terhadap kelebihan dapat dibenarkan.  Pertimbangkan masalah yang muncul saat menggunakan fungsi kelebihan beban. </p><br><p>  Jika Anda mencoba mempertimbangkan semua opsi yang mungkin muncul saat menyelesaikan kelebihan, maka aturan untuk menyelesaikan kelebihan menjadi sangat rumit, dan karenanya sulit diprediksi.  Kompleksitas tambahan diperkenalkan oleh fungsi template dan kelebihan operator bawaan.  C ++ 11 menambahkan masalah dengan tautan nilai dan daftar inisialisasi. </p><br><p>  Masalah dapat dibuat oleh algoritme pencarian bagi kandidat untuk mengatasi kelebihan muatan di area visibilitas bersarang.  Jika kompiler menemukan kandidat dalam ruang lingkup saat ini, maka pencarian lebih lanjut dihentikan.  Jika kandidat yang ditemukan tidak cocok, bertentangan, dihapus atau tidak dapat diakses, kesalahan dihasilkan, tetapi tidak ada pencarian lebih lanjut yang dicoba.  Dan hanya jika tidak ada kandidat dalam lingkup saat ini, pencarian bergerak ke lingkup selanjutnya yang lebih luas.  Nama mekanisme persembunyian berfungsi, yang hampir sama dengan yang dibahas di bagian 2.1, lihat [Dewhurst]. </p><br><p>  Fungsi overloading dapat mengurangi pembacaan kode, yang berarti memicu kesalahan. </p><br><p>  Menggunakan fungsi dengan parameter default sepertinya menggunakan fungsi kelebihan beban, meskipun, tentu saja, ada sedikit potensi masalah.  Tetapi masalah dengan keterbacaan yang buruk dan kemungkinan kesalahan tetap ada. </p><br><p>  Dengan sangat hati-hati, parameter kelebihan beban dan standar untuk fungsi virtual harus digunakan, lihat bagian 5.2. </p><br><p>  C # juga mendukung fungsi yang berlebihan, tetapi aturan untuk menyelesaikan kelebihan sedikit berbeda. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Jangan menyalahgunakan fungsi yang berlebihan, serta merancang fungsi dengan parameter default. </li><li>  Jika fungsi kelebihan beban, maka gunakan tanda tangan yang tidak diragukan saat menyelesaikan kelebihan. </li><li>  Jangan mendeklarasikan fungsi dengan nama yang sama dalam lingkup bersarang. </li><li>  Jangan lupa bahwa mekanisme fungsi jarak jauh ( <code>=delete</code> ) yang muncul di C ++ 11 dapat digunakan untuk melarang opsi overload tertentu. </li></ul><br><a name="id-3"></a><br><h1>  3. Konstruktor, destruktor, inisialisasi, penghapusan </h1><br><a name="id-3-1"></a><br><h2>  3.1.  Fungsi anggota kelas yang dihasilkan oleh kompiler </h2><br><p>  Jika programmer tidak mendefinisikan fungsi anggota kelas dari daftar berikut - konstruktor default, copy constructor, operator penugasan copy, destructor - maka kompiler dapat melakukan ini untuknya.  C ++ 11 menambahkan konstruktor bergerak dan operator penugasan pindah ke daftar ini.  Fungsi anggota ini disebut fungsi anggota khusus.  Mereka dihasilkan hanya jika digunakan, dan kondisi tambahan khusus untuk setiap fungsi terpenuhi.  Kami menarik perhatian pada kenyataan bahwa penggunaan ini ternyata cukup tersembunyi (misalnya, ketika menerapkan warisan).  Jika fungsi yang diperlukan tidak dapat dibuat, kesalahan dihasilkan.  (Dengan pengecualian operasi relokasi, mereka digantikan oleh operasi copy.) Fungsi anggota yang dihasilkan oleh kompilator bersifat publik dan dapat di-embed.  Detail tentang fungsi anggota khusus dapat ditemukan di [Meyers2]. </p><br><p>  Dalam beberapa kasus, bantuan seperti itu dari kompiler dapat menjadi "layanan beruang".  Tidak adanya fungsi khusus khusus anggota dapat menyebabkan pembuatan tipe sepele, dan ini, pada gilirannya, menyebabkan masalah variabel tidak diinisialisasi, lihat bagian 3.2.  Fungsi anggota yang dihasilkan bersifat publik, dan ini tidak selalu konsisten dengan desain kelas.  Di kelas dasar, konstruktor harus dilindungi, kadang-kadang, untuk kontrol yang lebih baik atas siklus hidup objek, destruktor yang dilindungi diperlukan.  Jika kelas memiliki deskriptor sumber daya mentah sebagai anggota dan memiliki sumber daya ini, maka programmer perlu mengimplementasikan copy constructor, copy copy operator, dan destructor.  Apa yang disebut "aturan Tiga Besar" dikenal luas, yang menyatakan bahwa jika seorang programmer mendefinisikan setidaknya satu dari tiga operasi - copy constructor, copy copy operator atau destructor - maka ia harus mendefinisikan ketiga operasi.  Konstruktor pemindahan dan operator penugasan pemindahan yang dihasilkan oleh kompilator juga jauh dari yang Anda butuhkan.  Destructor yang dihasilkan oleh kompiler dalam beberapa kasus mengarah ke masalah yang sangat halus, yang hasilnya mungkin merupakan kebocoran sumber daya, lihat bagian 3.7. </p><br><p>  Programmer dapat melarang pembuatan fungsi anggota khusus, dalam C ++ 11 perlu menggunakan konstruk <code>"=delete"</code> ketika mendeklarasikan, dalam C ++ 98 mendeklarasikan fungsi anggota terkait pribadi dan tidak mendefinisikan. </p><br><p>  Jika pemrogram merasa nyaman dengan fungsi anggota yang dihasilkan oleh kompiler, maka dalam C ++ 11 ia dapat menunjukkan ini secara eksplisit, dan tidak hanya menjatuhkan deklarasi.  Untuk melakukan ini, Anda harus menggunakan konstruksi <code>"=default"</code> ketika mendeklarasikan, sementara kode lebih baik dibaca dan fitur tambahan muncul terkait dengan mengelola tingkat akses. </p><br><p>  Dalam C #, kompiler dapat menghasilkan konstruktor default, biasanya ini tidak menyebabkan masalah. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Mengontrol kompiler menghasilkan fungsi anggota khusus.  Jika perlu, terapkan sendiri atau larang. </li></ul><br><a name="id-3-2"></a><br><h2>  3.2.  Variabel tidak diinisialisasi </h2><br><p>  Konstruktor dan destruktor dapat disebut elemen kunci dari model objek C ++.  Saat membuat objek, konstruktor harus dipanggil, dan ketika menghapus, destruktor dipanggil.  Tetapi masalah kompatibilitas dengan C telah memaksa beberapa pengecualian, dan pengecualian ini disebut tipe sepele.  Mereka diperkenalkan untuk mensimulasikan jenis sichny dan siklus hidup syshny variabel, tanpa panggilan wajib dari konstruktor dan destruktor.  Kode C, jika dikompilasi dan dieksekusi dalam C ++, harus berfungsi seperti dalam C. Tipe sepele termasuk tipe numerik, pointer, enumerasi, serta kelas, struktur, serikat, dan array yang terdiri dari tipe sepele.  Kelas dan struktur harus memenuhi beberapa kondisi tambahan: tidak adanya konstruktor kustom, destruktor, salin, fungsi virtual.  Untuk kelas sepele, kompiler dapat menghasilkan konstruktor default dan destruktor.  Konstruktor default nol objek, destruktor tidak melakukan apa pun.  Tetapi konstruktor ini akan dihasilkan dan digunakan hanya jika secara eksplisit dipanggil ketika variabel diinisialisasi.  Variabel tipe sepele akan diinisialisasi jika Anda tidak menggunakan beberapa varian inisialisasi eksplisit.  Sintaks inisialisasi tergantung pada jenis dan konteks deklarasi variabel.  Variabel statis dan lokal diinisialisasi ketika dideklarasikan.  Untuk kelas, kelas dasar langsung dan anggota kelas non-statis diinisialisasi dalam daftar inisialisasi konstruktor.  (C ++ 11 memungkinkan Anda untuk menginisialisasi anggota kelas non-statis saat mendeklarasikan, lihat nanti.) Untuk objek dinamis, ekspresi <code>new T()</code> membuat objek yang diinisialisasi oleh konstruktor default, tetapi <code>new T</code> untuk tipe sepele membuat objek yang tidak diinisialisasi.  Saat membuat array dinamis dari tipe sepele, <code>new T[N]</code> , elemen-elemennya akan selalu diinisialisasi.  Jika turunan <code>std::vector&lt;T&gt;</code> dibuat atau diperluas dan parameter tidak disediakan untuk inisialisasi eksplisit elemen, maka mereka dijamin akan memanggil konstruktor default.  C ++ 11 memperkenalkan sintaks inisialisasi baru - menggunakan kurung kurawal.  Sepasang kurung kosong berarti inisialisasi menggunakan konstruktor default.  Inisialisasi tersebut dimungkinkan di mana-mana di mana inisialisasi tradisional digunakan, selain itu menjadi mungkin untuk menginisialisasi anggota kelas non-statis ketika mendeklarasikan, yang menggantikan inisialisasi dalam daftar inisialisasi konstruktor. </p><br><p>  Variabel yang tidak diinisialisasi disusun sebagai berikut: jika ia didefinisikan dalam lingkup <code>namespace</code> (secara global), ia akan memiliki semua bit nol, jika dibuat secara lokal atau secara dinamis, ia akan menerima serangkaian bit acak.  Jelas bahwa penggunaan variabel semacam itu dapat menyebabkan perilaku program yang tidak dapat diprediksi. </p><br><p>  Benar, kemajuan tidak berhenti, kompiler modern, dalam beberapa kasus, mendeteksi variabel yang tidak diinisialisasi dan melemparkan kesalahan.  Penganalisa kode yang tidak diinisialisasi mendeteksi lebih baik. </p><br><p>  Pustaka standar C ++ 11 memiliki templat yang disebut tipe properties (file header <code>&lt;type_traits&gt;</code> ).  Salah satunya memungkinkan Anda untuk menentukan apakah jenisnya sepele.  Ekspresi <code>std::is_trivial&lt;&gt;::value</code> <code>true</code> jika <code>T</code> tipe trivial dan <code>false</code> sebaliknya. </p><br><p>  Struktur sysylic juga sering disebut Data Lama Biasa (POD).  Kita dapat berasumsi bahwa POD dan "tipe trivial" adalah istilah yang hampir setara. </p><br><p>  Dalam C #, variabel yang tidak diinisialisasi menyebabkan kesalahan, ini dikendalikan oleh kompiler.  Bidang objek dari tipe referensi diinisialisasi secara default jika inisialisasi eksplisit tidak dilakukan.  Bidang objek dari tipe signifikan diinisialisasi baik semua secara default, atau semua harus diinisialisasi secara eksplisit. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Memiliki kebiasaan menginisialisasi variabel secara eksplisit.  Variabel tidak diinisialisasi harus "memotong mata." </li><li>  Deklarasikan variabel dalam ruang lingkup sesempit mungkin. </li><li>  Gunakan penganalisa kode statis. </li><li>  Jangan mendesain tipe sepele.  Untuk memastikan bahwa jenisnya tidak sepele, cukup mendefinisikan konstruktor khusus. </li></ul><br><a name="id-3-3"></a><br><h2>  3.3.  Prosedur Inisialisasi untuk Kelas Dasar dan Anggota Kelas Non-Statis </h2><br><p>  Ketika menerapkan konstruktor kelas, kelas dasar langsung dan anggota kelas non-statis diinisialisasi.  Urutan inisialisasi ditentukan oleh standar: pertama, kelas dasar dalam urutan di mana mereka dinyatakan dalam daftar kelas dasar, kemudian anggota kelas yang tidak statis dalam urutan deklarasi.  Jika perlu, inisialisasi eksplisit dari kelas dasar dan anggota non-statis menggunakan daftar inisialisasi konstruktor.  Sayangnya, item dalam daftar ini tidak harus dalam urutan inisialisasi yang terjadi.  Ini harus diperhitungkan jika, selama inisialisasi, item daftar menggunakan referensi ke item daftar lainnya.  Kesalahan, tautan mungkin ke objek yang belum diinisialisasi.  C ++ 11 memungkinkan Anda untuk menginisialisasi anggota kelas non-statis saat mendeklarasikan (menggunakan kurung kurawal).  Dalam hal ini, mereka tidak perlu diinisialisasi dalam daftar inisialisasi konstruktor dan masalahnya dihapus sebagian. </p><br><p>  Dalam C #, sebuah objek diinisialisasi sebagai berikut: pertama bidang diinisialisasi, dari sub-objek dasar ke turunan terakhir, maka konstruktor dipanggil dalam urutan yang sama.  Masalah yang dijelaskan tidak terjadi. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Menyimpan daftar inisialisasi konstruktor dalam urutan deklarasi. </li><li>  Cobalah untuk membuat inisialisasi kelas dasar dan anggota kelas independen. </li><li>  Gunakan inisialisasi anggota non-statis saat mendeklarasikan. </li></ul><br><a name="id-3-4"></a><br><h2>  3.4.  Prosedur Inisialisasi untuk Anggota Kelas Statis dan Variabel Global </h2><br><p>  Anggota kelas statis, serta variabel yang didefinisikan dalam lingkup <code>namespace</code> (global) dalam unit kompilasi yang berbeda (file), diinisialisasi dalam urutan yang ditentukan oleh implementasi.  Ini harus diperhitungkan jika selama inisialisasi variabel seperti menggunakan referensi satu sama lain.  Tautan mungkin ke variabel tidak diinisialisasi. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Ambil tindakan khusus untuk mencegah situasi ini.  Misalnya, gunakan variabel statis lokal (tunggal), mereka diinisialisasi pada penggunaan pertama. </li></ul><br><a name="id-3-5"></a><br><h2>  3.5.  Pengecualian dalam destruktor </h2><br><p>  Destruktor seharusnya tidak melempar pengecualian.  Jika Anda melanggar aturan ini, Anda bisa mendapatkan perilaku tidak terdefinisi, paling sering penghentian tidak normal. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Hindari melempar pengecualian di destructor. </li></ul><br><a name="id-3-6"></a><br><h2>  3.6.  Menghapus objek dan array dinamis </h2><br><p>  Jika objek dinamis dari beberapa tipe <code>T</code> </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T(<span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>);</code> </pre> <br><p>  kemudian dihapus dengan operator <code>delete</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> pt;</code> </pre> <br><p>  Jika array dinamis dibuat </p><br><pre> <code class="cpp hljs">T* pt = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[N];</code> </pre> <br><p>  kemudian dihapus dengan operator <code>delete[]</code> </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] pt;</code> </pre> <br><p>  Jika Anda tidak mengikuti aturan ini, Anda bisa mendapatkan perilaku yang tidak terdefinisi, yaitu, apa pun bisa terjadi: kebocoran memori, kerusakan, dll.  Lihat [Meyers1] untuk detailnya. </p><br><p>  Bagaimana cara bertarung: </p><br><ul><li>  Gunakan formulir <code>delete</code> benar. </li></ul><br><a name="id-3-7"></a><br><h2>  3.7.  Penghapusan dengan deklarasi kelas yang tidak lengkap </h2><br><p>  Omnivora dari operator <code>delete</code> dapat menciptakan masalah tertentu, dapat diterapkan pada pointer bertipe <code>void*</code> atau ke pointer ke kelas yang memiliki deklarasi tidak lengkap (preemptive).  Operator <code>delete</code> diterapkan ke pointer ke kelas adalah operasi dua fase, pertama, destruktor dipanggil, kemudian memori dibebaskan.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika operator diterapkan </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke pointer ke kelas dengan deklarasi tidak lengkap, tidak ada kesalahan terjadi, kompilator hanya melewatkan panggilan ke destruktor (meskipun peringatan dikeluarkan).</font></font> Pertimbangkan sebuah contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//   X* CreateX(); void Foo() {    X* p = CreateX();    delete p; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode ini mengkompilasi bahkan jika </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deklarasi kelas penuh tidak tersedia </font><font style="vertical-align: inherit;">di dial-peer </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Visual Studio menampilkan peringatan berikut:</font></font><br><p> <code>warning C4150: deletion of pointer to incomplete type 'X'; no destructor called</code> <br> </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika ada implementasi </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kemudian kode dikompilasi, jika ia </font></font><code>CreateX()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan pointer ke objek yang dibuat oleh operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka panggilan </font></font><code>Foo()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berhasil dieksekusi, destructor tidak dipanggil. </font><font style="vertical-align: inherit;">Jelas bahwa ini dapat menyebabkan sumber daya terkuras, jadi sekali lagi tentang perlunya berhati-hati tentang peringatan.</font></font></p><br><p>    ,           -.      ,  .       ,      ,   ,   ,   .        [Meyers2]. </p><br><p>  : </p><br><ul><li>   . </li><li>            . </li><li>     . </li></ul><br><a name="id-4"></a><br><h1> 4. ,  </h1><br><a name="id-4-1"></a><br><h2>  4.1.   </h2><br><p>   ++ ,     .      .       .   ,    1.1. </p><br><p>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c?x:y;</code> </pre> <br><p>        </p><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;c)?x:y;</code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::out&lt;&lt;(c?x:y);</code> </pre> <br><p> ,  ,  . </p><br><p>         .            <code>&lt;&lt;</code>      <code>?:</code>      <code>std::out</code>  <code>void*</code> .  ++            ,     . -,          ,    .    <code>?:</code>      .       ,     (  ). </p><br><p>   :  <code>x&amp;f==0</code>    <code>x&amp;(f==0)</code> ,   <code>(x&amp;f)==0</code> , ,  ,  .     -  , ,     ,         ,   . </p><br><p>  . /          .  /    ,  /,    . ,     <code>x/4+1</code>  <code>x&gt;&gt;2+1</code> ,   <code>x&gt;&gt;(2+1)</code> ,   <code>(x&gt;&gt;2)+1</code> ,  . </p><br><p> C#      ,   C++,      ,    -      . </p><br><p>  : </p><br><ul><li>   ,     . , ,    . </li></ul><br><a name="id-4-2"></a><br><h2>  4.2.   </h2><br><p> ++     ,      .        .        ,          , .  4.1.    —    <code>+</code>  <code>+=</code>   .     . ,   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code>  .   ,         (-),            (short-circuit evaluation semantics),        ,        .      &amp; ( ).     &amp;    , ..       . </p><br><p>        ,  -    (-) ,  .      . </p><br><p>  -  ,    ,    .  . [Dewhurst]. </p><br><p> C#    ,     , ,   . </p><br><p>  : </p><br><ul><li>    . </li><li>       . </li></ul><br><a name="id-4-3"></a><br><h2>  4.3.    </h2><br><p>   ++           ,         . (   : <code>,</code> (), <code>&amp;&amp;</code> , <code>||</code> , <code>?:</code> .)     ,  ,   ,    .    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y=(++x*<span class="hljs-number"><span class="hljs-number">2</span></span>)+(++x*<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  <code>y</code>     . </p><br><p>      ,        .  . </p><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;X&gt;, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Y&gt;)</span></span></span></span>;</code> </pre> <br><p>  <code>Foo()</code>   : </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()));</code> </pre> <br><p>     :  <code>X</code> ,  <code>Y</code> ,  <code>std::shared_ptr&lt;X&gt;</code> ,  <code>std::shared_ptr&lt;Y&gt;</code> .   <code>Y</code>  ,   <code>X</code>   . </p><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Y&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Y()); Foo(p1, p2);</code> </pre> <br><p>     <code>std::make_shared&lt;Y&gt;</code> (    ,     ): </p><br><pre> <code class="cpp hljs">Foo(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;X&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;Y&gt;());</code> </pre> <br><p>  . [Meyers2]. </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-5"></a><br><h1> 5.   </h1><br><a name="id-5-1"></a><br><h2>  5.1.    </h2><br><p>  ++98  ,           ( ), ,     (     ,    ).      <code>virtual</code> ,   ,    .   ( ),   ,   ,     . ,     ,  .  ,  ++11    <code>override</code> ,    ,    ,       .          . </p><br><p>  : </p><br><ul><li>    <code>override</code> . </li><li>    .    ,         . </li></ul><br><a name="id-5-2"></a><br><h2>  5.2.       </h2><br><p>            .   ,              ,     .               .    . [Dewhurst]. </p><br><p>  : </p><br><ul><li>           . </li></ul><br><a name="id-5-3"></a><br><h2>  5.3.        </h2><br><p> ,     ,          . , ,     post_construct  pre_destroy. ,      —         .    .   ,        :     ( )   . (, ,      .)     ,           ( ),    ( ).  . [Dewhurst]. ,         ,  . </p><br><p>       —  -         . </p><br><p> ,   C#  ,     ,   ,     .  C#    :   ,      ,       .  ,           ( ,    ). </p><br><p>  : </p><br><ul><li>        ,     ,   . </li></ul><br><a name="id-5-4"></a><br><h2>  5.4.   </h2><br><p>     ,        ,           <code>delete</code>     .          , -    . </p><br><p>  : </p><br><ul><li>     . </li></ul><br><a name="id-6"></a><br><h1> 6.     </h1><br><p>        —      C/C++,        .           .        .     «  ». </p><br><p>  C#        unsafe mode,    . </p><br><a name="id-6-1"></a><br><h2> 6.1.     </h2><br><p>    /++  ,        : <code>strcpy()</code> , <code>strcat()</code> , <code>sprinf()</code> , etc.    ( <code>std::vector&lt;&gt;</code> , etc.)         ,    . (,         ,         ,     . . <strong>Checked Iterators</strong>  MSDN.)      ,      :   ,      ,     ;     ,      . </p><br><p>  C#,   unsafe mode,      . </p><br><p>  : </p><br><ul><li>    , . </li><li>     . </li><li>   z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-2"></a><br><h2> 6.2. Z-terminated  </h2><br><p>       ,  .    ,  : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">strncpy</span></span>(dst,src,n);</code> </pre> <br><p>  <code>strlen(src)&gt;=n</code> ,  <code>dst</code>     (,      ).      ,       , .  .       —       .   <code>if(*str)</code> ,  <code>if(strlen(str)&gt;0)</code> ,           .         [Spolsky]. </p><br><p>  C#  <code>string</code>      . </p><br><p>  : </p><br><ul><li>    . </li><li>     z-terminated   ,    <code>_s</code> (.   ). </li></ul><br><a name="id-6-3"></a><br><h2> 6.3.      </h2><br><p>    <code>...</code>    .      <code>printf</code> - ,     C.          , ,  ,     ,      .         ,       . </p><br><p>  C#    <code>printf</code> ,     . </p><br><p>  : </p><br><ul><li>     . ,  <code>printf</code> -    /. </li><li>   . </li></ul><br><a name="id-7"></a><br><h1> 7.  </h1><br><a name="id-7-1"></a><br><h2> 7.1.   </h2><br><p>  ++     , ,   ,        .  Berikut ini sebuah contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">4</span></span>, M = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x,                <span class="hljs-comment"><span class="hljs-comment">// 1    *px,              // 2    ax[N],            // 3    *apx[N],          // 4    F(char),          // 5    *G(char),          // 6    (*pF)(char),      // 7    (*apF[N])(char),  // 8    (*pax)[N],        // 9    (*apax[M])[N],    // 10    (*H(char))(long);  // 11</span></span></code> </pre> <br><p>        : </p><br><ol><li>   <code>int</code> ; </li><li>   <code>int</code> ; </li><li>   <code>N</code>   <code>int</code> ; </li><li>   <code>N</code>     <code>int</code> ; </li><li> ,  <code>char</code>   <code>int</code> ; </li><li> ,  <code>char</code>     <code>int</code> ; </li><li>   ,  <code>char</code>   <code>int</code> ; </li><li>   <code>N</code>     ,  <code>char</code>   <code>int</code> ; </li><li>     <code>N</code>   <code>int</code> ; </li><li>   <code>M</code>       <code>N</code>   <code>int</code> ; </li><li> ,  <code>char</code>     ,  <code>long</code>   <code>int</code> . </li></ol><br><p> ,             . (     .) </p><br><p>     <code>*</code>    <code>&amp;</code>     . (    .) </p><br><p>        <code>typedef</code> ( <code>using</code> -). ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*P)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; PH(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>);</code> </pre> <br><p>      ,     . </p><br><p>  C#    ,    . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-7-2"></a><br><h2> 7.2.   </h2><br><p>           .     </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>:    X(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>     </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>    <code>x</code>  <code>X</code> ,   5.    </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">X </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>    <code>x</code> ,    <code>X</code>    ,     <code>x</code>  <code>X</code> ,    .     <code>X</code> ,    ,     : </p><br><pre> <code class="cpp hljs">X x; X x = X(); X x{};    <span class="hljs-comment"><span class="hljs-comment">//   C++11</span></span></code> </pre> <br><p>   ,    ,          ,   .         [Sutter]. </p><br><p>  ,  ,   C++     (      ).         . (    C++  .) </p><br><p>  , ,      ,       ,         . </p><br><p>  C#   ,         ,      . </p><br><p>  : </p><br><ul><li>    . </li></ul><br><a name="id-8"></a><br><h1> 8.  </h1><br><a name="id-8-1"></a><br><h2> 8.1.   <code>inline</code>  ODR </h2><br><p>   ,    <code>inline</code> —             .  ,     .   <code>inline</code>          (One Defenition Rule, ODR).  .            ,   .          ,  ODR.       <code>static</code> :    ,       ,   .   <code>static</code>  <code>inline</code> .      ,        ,  ODR,     . ,       .   - ,          -.         . </p><br><p>  : </p><br><ul><li>  «» <code>inline</code> .          <code>namespace</code> .      ,     . </li><li>        —  <code>namespace</code> . </li></ul><br><a name="id-8-2"></a><br><h2> 8.2.   </h2><br><p>        .        .    ,    ,     ,   ,      . </p><br><p>  : </p><br><ul><li>     ,     . </li><li>  ,     :  () ,    -. </li><li>            <code>using</code> -: <code>using namespace <i></i></code> ,   <code>using</code> -. </li><li>           . </li></ul><br><a name="id-8-3"></a><br><h2> 8.3.  <code>switch</code> <br></h2><br><p>   —  <code>break</code>    <code>case</code> . (  .)  C#     . </p><br><p>  : </p><br><ul><li>   . </li></ul><br><a name="id-8-4"></a><br><h2> 8.4.     </h2><br><p>  ++    ,      —     , —       .    (  <code>class</code>  <code>struct</code> )    ,         . (      ,      #  Java.)    —   ,     . </p><br><ol><li>      ,   .           (  <code>std::string</code> , <code>std::vector</code> , etc.),    ,           . </li><li>    ,        ,     . </li><li>          ,      (slicing),      ,       . </li></ol><br><p>     ,      ,  ,     .      . ,       ,         . ,          .           .    —     ( <code>=delete</code> ),   —     <code>explicit</code> . </p><br><p>  C#      ,           . </p><br><p>  : </p><br><ul><li>   ,     . </li><li>       . </li></ul><br><a name="id-8-5"></a><br><h2> 8.5.  Manajemen sumber daya </h2><br><p>  ++         .     ,     . -       (    ),   ++11   ,        ,   ,           . </p><br><p>      C++   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </p><br><p>  C#   ,       .        ,     .        (using-)      Basic Dispose. </p><br><p>  : </p><br><ul><li>  -       . </li></ul><br><a name="id-8-6"></a><br><h2> 8.6.     </h2><br><p>     «»     .     ,  , C++ , STL-   - . </p><br><p>       .         .     ,        .      .        «»,      .          COM-      . (,    .)      ,    C++   .      —      .        .            .  ,      («»     )    ,      .        . </p><br><p>  #    ,     .     —    . </p><br><p>  : </p><br><ul><li>   . </li><li>        . </li></ul><br><a name="id-8-7"></a><br><h2> 8.7.   </h2><br><p>  C++      ,     :   ,    ,   . (     !)      .        ,      .     ,   .     ,   ,     . (,           .) </p><br><p>      C (    ),   C++       C  (   <code>extern "C"</code> ).      C/C++ . </p><br><p>          -.   <code>#pragma</code> -    ,    ,   . </p><br><p>        , ,    ,    . </p><br><p>     , ,    COM. COM-,    ,   (     ,      ).  COM     ,   ,     . </p><br><p>  C#     . ,   —    ,      C#,    C#  C/C++. </p><br><p>  : </p><br><ul><li>        . </li></ul><br><a name="id-8-8"></a><br><h2> 8.8.  </h2><br><p>        ,         .    ,       .  C++    .  Sebaliknya </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> XXL 32</span></span></code> </pre> <br><p>   </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> XXL=<span class="hljs-number"><span class="hljs-number">32</span></span>;</code> </pre> <br><p>   .       <code>inline</code>   . </p><br><p>  #   (   ). </p><br><p>  : </p><br><ul><li>       . </li></ul><br><a name="id-conclusion"></a><br><h1> 9.  </h1><br><ol><li>      .       .   .      ,       . </li><li>    . </li><li>    .   ++      — ++11/14/17. </li><li>   - ,  -   . </li><li>        . </li></ol><br><a name="id-refs"></a><br><h1>  Referensi </h1><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"><p> [Dewhurst] <br> ,  .   C++.         .: .  . — .:  , 2012. </p><br><p> [Meyers1] <br> , .   C++. 55        .: .  . — .:  , 2014. </p><br><p> [Meyers2] <br> , .    C++: 42    C++11  C++14.: .  . — .:  «.. », 2016. </p><br><p> [Sutter] <br> , .     C++.: .  . — :  «.. », 2015. </p><br><p> [Spolsky] <br> , .   .: .  . — .: -, 2008. </p><br></div></div><br><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428898/">https://habr.com/ru/post/id428898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428888/index.html">qml: kekuatan dan kesederhanaan</a></li>
<li><a href="../id428890/index.html">Seluruh kebenaran tentang RTOS. Artikel # 18. Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a></li>
<li><a href="../id428892/index.html">Cara membuat game AI: panduan untuk pemula</a></li>
<li><a href="../id428894/index.html">PPN untuk pembelian domestik</a></li>
<li><a href="../id428896/index.html">Sensor syaraf sensor hentai</a></li>
<li><a href="../id428900/index.html">Robot beroda mulai mengirimkan barang ke penduduk Amerika Serikat dan Inggris</a></li>
<li><a href="../id428902/index.html">Tag Nirkabel NFC</a></li>
<li><a href="../id428904/index.html">Integrasi Fintech: Robotika Bank Sentral, Ethereum 2.0, Kontrol Cryptocurrency oleh Rosfinmonitoring dan Tren di Fintech</a></li>
<li><a href="../id428906/index.html">Membuat game puzzle pada Puzzle Script</a></li>
<li><a href="../id428908/index.html">Frostpunk: mekanika pembongkaran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>