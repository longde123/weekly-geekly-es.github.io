<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßìüèº üöÅ üó®Ô∏è Comme nous avons √©crit le code r√©seau du tireur PvP mobile: synchronisation du joueur sur le client #‚É£ üï∫üèΩ ü•ü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans l'un des articles pr√©c√©dents , nous avons pass√© en revue les technologies utilis√©es dans notre nouveau projet - un jeu de tir rapide pour les app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comme nous avons √©crit le code r√©seau du tireur PvP mobile: synchronisation du joueur sur le client</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/415959/">  Dans l'un des articles <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©c√©dents</a> , nous avons pass√© en revue les technologies utilis√©es dans notre nouveau projet - un jeu de tir rapide pour les appareils mobiles.  Maintenant, je veux partager comment la partie client du code r√©seau du futur jeu est organis√©e, quelles difficult√©s nous avons rencontr√©es et comment les r√©soudre. <br><br><img src="https://habrastorage.org/webt/va/gz/nl/vagznl64ylol9qhxysj5ti1akpy.jpeg"><br><a name="habracut"></a><br><br>  En g√©n√©ral, les approches pour cr√©er des jeux multijoueurs rapides au cours des 20 derni√®res ann√©es n'ont pas beaucoup chang√©.  Plusieurs m√©thodes peuvent √™tre distingu√©es dans l'architecture de code r√©seau: <br><br><ol><li>  Mauvais calcul de l'√©tat du monde sur le serveur, et affichage des r√©sultats sur le client sans pr√©diction pour le joueur local et avec la possibilit√© de perdre l'entr√©e du joueur (entr√©e).  Cette approche, soit dit en passant, est utilis√©e sur notre autre projet en d√©veloppement - vous pouvez en lire plus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lockstep</a> </li><li>  Synchronisation de l'√©tat du monde sans logique d√©terministe avec pr√©diction pour un acteur local. </li><li>  Synchronisation des entr√©es avec une logique et une pr√©diction enti√®rement d√©terministes pour un joueur local. </li></ol><br>  La particularit√© r√©side dans le fait que dans les tireurs, le plus important est la r√©activit√© du contr√¥le - le joueur appuie sur un bouton (ou d√©place le joystick) et veut voir imm√©diatement le r√©sultat de son action.  Tout d'abord, car l'√©tat du monde dans de tels jeux change tr√®s rapidement et il est n√©cessaire de r√©agir imm√©diatement √† la situation. <br><br>  De ce fait, les approches sans le m√©canisme de pr√©diction des actions des acteurs locaux (pr√©diction) n'√©taient pas adapt√©es au projet, et nous avons opt√© pour une m√©thode de synchronisation de l'√©tat du monde, sans logique d√©terministe. <br><br>  <b>Avantage de l'approche:</b> moins de complexit√© de mise en ≈ìuvre par rapport √† la m√©thode de synchronisation lors de l'√©change d'entr√©e. <br>  <b>Moins:</b> une augmentation du trafic lors de l'envoi de l'√©tat du monde entier au client.  Nous avons d√ª appliquer plusieurs techniques diff√©rentes d'optimisation du trafic pour que le jeu fonctionne de mani√®re stable sur un r√©seau mobile. <br><br>  Au c≈ìur de l'architecture de gameplay, nous avons ECS, dont nous avons d√©j√† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parl√©</a> .  Cette architecture vous permet de stocker facilement des donn√©es sur le monde du jeu, de les s√©rialiser, de les copier et de les transf√©rer sur le r√©seau.  Et aussi pour ex√©cuter le m√™me code √† la fois sur le client et sur le serveur. <br><br>  La simulation du monde du jeu se d√©roule √† une fr√©quence fixe de 30 ticks par seconde.  Cela vous permet de r√©duire le d√©calage de l'entr√©e du lecteur et de ne presque pas utiliser d'interpolation pour afficher visuellement l'√©tat du monde.  Mais il y a un inconv√©nient important √† consid√©rer lors du d√©veloppement d'un tel syst√®me: pour que le syst√®me de pr√©diction du joueur local fonctionne correctement, le client doit simuler le monde avec la m√™me fr√©quence que le serveur.  Et nous avons pass√© beaucoup de temps √† optimiser suffisamment la simulation pour les appareils cibles. <br><br><h2>  M√©canisme de pr√©diction d'action du joueur local (pr√©diction) </h2><br>  Le m√©canisme de pr√©diction client est impl√©ment√© sur la base d'ECS en raison de l'ex√©cution des m√™mes syst√®mes sur le client et le serveur.  Cependant, tous les syst√®mes ne sont pas ex√©cut√©s sur le client, mais seulement ceux qui sont responsables du joueur local et ne n√©cessitent pas de donn√©es pertinentes sur les autres joueurs. <br><br>  Exemple de listes de syst√®mes fonctionnant sur le client et le serveur: <br><br><img src="https://habrastorage.org/webt/sm/jl/wc/smjlwcvyu5mv2omhgnggu9zbbnc.png"><br><br>  √Ä l'heure actuelle, nous avons environ 30 syst√®mes fonctionnant sur le client qui fournissent la pr√©diction du joueur et environ 80 syst√®mes fonctionnant sur le serveur.  Mais nous ne pr√©disons pas des choses comme infliger des d√©g√¢ts, utiliser des capacit√©s ou soigner des alli√©s.  Il y a deux probl√®mes dans ces m√©canismes: <br><br><ol><li>  Le client ne sait rien sur l'entr√©e d'autres joueurs et la pr√©diction de choses comme les dommages ou la gu√©rison divergera presque toujours des donn√©es sur le serveur. </li><li>  La cr√©ation locale de nouvelles entit√©s (tirs, obus, capacit√©s uniques) g√©n√©r√©es par un joueur pose le probl√®me de l'appariement avec les entit√©s cr√©√©es sur le serveur. </li></ol><br>  Pour un tel m√©canicien, le d√©calage se cache du joueur par d'autres moyens. <br><br>  <i>Exemple: nous tirons imm√©diatement l'effet de la frappe du tir et nous mettons √† jour la vie de l'ennemi uniquement apr√®s avoir re√ßu la confirmation du coup du serveur.</i> <br><br><h2>  Le sch√©ma g√©n√©ral du code r√©seau dans le projet </h2><br><br><img src="https://habrastorage.org/webt/so/vq/gw/sovqgwxy7gc2rxtsqedxdlkpdew.png"><br>  Le client et le serveur synchronisent l'heure par des num√©ros de tick.  √âtant donn√© que la transmission des donn√©es sur le r√©seau prend un certain temps, le client est toujours en avance sur le serveur de moiti√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTT</a> + la taille du tampon d'entr√©e sur le serveur.  Le diagramme ci-dessus montre que le client envoie une entr√©e pour tick 20 (a).  Dans le m√™me temps, le tick 15 (b) est trait√© sur le serveur.  Au moment o√π l'entr√©e du client atteint le serveur, le tick 20 sera trait√© sur le serveur. <br><br>  L'ensemble du processus comprend les √©tapes suivantes: le client envoie l'entr√©e du lecteur au serveur (a) ‚Üí cette entr√©e est trait√©e sur le serveur apr√®s HRTT + taille du tampon d'entr√©e (b) ‚Üí le serveur envoie l'√©tat mondial r√©sultant au (x) client (s) ‚Üí le client applique l'√©tat mondial confirm√© avec temps du serveur RTT + taille du tampon d'entr√©e + taille du tampon d'interpolation de l'√©tat du jeu (d). <br><br>  Une fois que le client a re√ßu un nouvel √©tat du monde confirm√© du serveur (d), il doit terminer le processus de r√©conciliation.  Le fait est que le client effectue une pr√©diction mondiale bas√©e uniquement sur l‚Äôentr√©e du joueur local.  Les entr√©es des autres joueurs ne lui sont pas connues.  Et lors du calcul de l'√©tat du monde sur le serveur, le lecteur peut √™tre dans un √©tat diff√©rent, diff√©rent de ce que le client avait pr√©dit.  Cela peut se produire lorsqu'un joueur est assomm√© ou tu√©. <br><br>  Le processus d'approbation se compose de deux parties: <br><br><ol><li>  Comparaisons de l'√©tat pr√©vu du monde pour le tick N re√ßu du serveur.  Seules les donn√©es relatives au joueur local sont impliqu√©es dans la comparaison.  Les donn√©es du reste du monde sont toujours extraites de l'√©tat du serveur et ne participent pas √† la coordination. </li><li>  Lors de la comparaison, deux cas peuvent se produire: </li></ol><br>  - si l'√©tat pr√©dit du monde co√Øncide avec celui confirm√© par le serveur, le client, en utilisant les donn√©es pr√©dites pour le joueur local et les nouvelles donn√©es pour le reste du monde, continue de simuler le monde en mode normal; <br>  - si l'√©tat pr√©dit ne correspond pas, le client utilise tout l'√©tat du serveur du monde et l'historique des entr√©es du client et raconte le nouvel √©tat pr√©dit du monde du joueur. <br><br><div class="spoiler">  <b class="spoiler_title">Dans le code, cela ressemble √† ceci:</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-function">GameState </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reconcile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentTick, ServerGameStateData serverStateData, GameState currentState, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerID</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverState = serverStateData.GameState; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> serverTick = serverState.Time; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> predictedState = _localStateHistory.Get(serverTick); <span class="hljs-comment"><span class="hljs-comment">//if predicted state matches server last state use server predicted state with predicted player if (_gameStateComparer.IsSame(predictedState, serverState, playerID)) { _tempState.Copy(serverState); _gameStateCopier.CopyPlayerEntities(currentState, _tempState, playerID); return _localStateHistory.Put(_tempState); // replace predicted state with correct server state } //if predicted state doesn't match server state, reapply local inputs to server state var last = _localStateHistory.Put(serverState); // replace wrong predicted state with correct server state for (var i = serverTick; i &lt; currentTick; i++) { last = _prediction.Predict(last); // resimulate all wrong states } return last; }</span></span></code> </pre> <br></div></div><br>  La comparaison de deux √©tats mondiaux se produit uniquement pour les donn√©es qui se rapportent au joueur local et participent au syst√®me de pr√©diction.  Les donn√©es sont √©chantillonn√©es par ID de joueur. <br><br><div class="spoiler">  <b class="spoiler_title">M√©thode de comparaison:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState s1, GameState s2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> avatarId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> || s1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; s2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity1 = s1.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> entity2 = s2.WorldState[avatarId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1 == <span class="hljs-literal"><span class="hljs-literal">null</span></span> || entity2 == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Time != s2.Time) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.WorldState.Transform[avatarId] != s2.WorldState.Transform[avatarId]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Weapon <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s1.WorldState.Weapon) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value.Owner.Id != avatarId) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Weapon = s2.WorldState.Weapon[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Weapon.Value != s2Weapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Ammo = s1.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Ammo = s2.WorldState.WeaponAmmo[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Ammo != s2Ammo) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s1Reload = s1.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s2Reload = s2.WorldState.WeaponReloading[s1Weapon.Key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1Reload != s2Reload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.Aiming != entity2.Aiming) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entity1.ChangeWeapon != entity2.ChangeWeapon) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Des op√©rateurs de comparaison pour des composants sp√©cifiques sont g√©n√©r√©s avec l'ensemble de la structure EC, sp√©cialement √©crits par un g√©n√©rateur de code.  Pour un exemple, je vais donner le code g√©n√©r√© de l'op√©rateur de comparaison de composants Transform: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ==(Transform a, Transform b) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)a != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)b == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Angle - b.Angle) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Math.Abs(a.Position.x - b.Position.x) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span> || Math.Abs(a.Position.y - b.Position.y) &gt; <span class="hljs-number"><span class="hljs-number">0.01f</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br></div></div><br>  Il convient de noter que nos valeurs flottantes sont compar√©es √† une erreur plut√¥t √©lev√©e.  Ceci est fait afin de r√©duire la quantit√© de d√©synchronisation entre le client et le serveur.  Pour le joueur, une telle erreur sera invisible, mais cela √©conomise consid√©rablement les ressources informatiques du syst√®me. <br><br>  La complexit√© du m√©canisme de coordination est qu'en cas de mauvaise synchronisation des √©tats client et serveur (erreur de pr√©diction), il est n√©cessaire de simuler de mani√®re r√©p√©t√©e tous les √©tats client pr√©dits pour lesquels il n'y a pas de confirmation du serveur, jusqu'au tick actuel dans une seule trame.  Selon le ping du joueur, cela peut aller de 5 √† 20 ticks de simulation.  Nous avons d√ª optimiser consid√©rablement le code de simulation pour l'adapter √† la p√©riode: 30 ips. <br><br>  Pour terminer le processus d'approbation, deux types de donn√©es doivent √™tre stock√©s sur le client: <br><br><ol><li>  Une histoire des √©tats de joueurs pr√©vus. </li><li>  Et l'histoire de l'entr√©e. </li></ol><br>  √Ä ces fins, nous utilisons un tampon circulaire.  La taille du tampon est de 32 ticks.  Cela √† une fr√©quence de 30 Hz donne environ 1 seconde de temps r√©el.  Le client peut continuer √† travailler en toute s√©curit√© sur le m√©canisme de pr√©diction, sans recevoir de nouvelles donn√©es du serveur, jusqu'√† remplir ce tampon.  Si la diff√©rence entre l'heure du client et celle du serveur commence √† √™tre sup√©rieure √† une seconde, le client est oblig√© de se d√©connecter en tentant de se reconnecter.  Nous avons une telle taille de tampon en raison des co√ªts du processus de coordination en cas de divergence entre les √âtats du monde.  Mais si la diff√©rence entre le client et le serveur est sup√©rieure √† une seconde, il est moins co√ªteux d'effectuer une reconnexion compl√®te au serveur. <br><br><h2>  R√©duction du temps de latence </h2><br>  Le diagramme ci-dessus montre que dans le jeu, il existe deux tampons dans le sch√©ma de transfert de donn√©es: <br><br><ul><li>  tampon d'entr√©e sur le serveur; </li><li>  un tampon d'√©tats du monde sur le client. </li></ul><br>  Le but de ces tampons est le m√™me - pour compenser les sauts de r√©seau (gigue).  Le fait est que la transmission de paquets sur le r√©seau est in√©gale.  Et puisque le moteur de r√©seau fonctionne √† une fr√©quence fixe de 30 Hz, les donn√©es doivent √™tre fournies au moteur √† la m√™me fr√©quence.  Nous n'avons pas la possibilit√© "d'attendre" quelques ms jusqu'√† ce que le prochain paquet atteigne le destinataire.  Nous utilisons des tampons pour les donn√©es d'entr√©e et les √©tats du monde afin d'avoir une marge de temps pour la compensation de la gigue.  Nous utilisons √©galement le tampon gamestate pour l'interpolation si l'un des paquets est perdu. <br><br>  Au d√©but du jeu, le client ne d√©marre la synchronisation avec le serveur qu'apr√®s avoir re√ßu plusieurs √©tats mondiaux du serveur et que la m√©moire tampon gamestate est pleine.  En r√®gle g√©n√©rale, la taille de ce tampon est de 3 ticks (100 ms). <br><br>  Dans le m√™me temps, lorsque le client se synchronise avec le serveur, il ¬´s'ex√©cute¬ª en avance sur l'heure du serveur de la valeur du tampon d'entr√©e sur le serveur.  C'est-√†-dire  le client lui-m√™me contr√¥le sa distance par rapport au serveur.  La taille de d√©part du tampon d'entr√©e est √©galement √©gale √† 3 ticks (100 ms). <br><br>  Initialement, nous avons impl√©ment√© la taille de ces tampons sous forme de constantes.  C'est-√†-dire  que la gigue ait r√©ellement exist√© sur le r√©seau ou non, il y avait un d√©lai fixe de 200 ms (taille du tampon d'entr√©e + taille du tampon d'√©tat du jeu) pour la mise √† jour des donn√©es.  Si nous ajoutons √† cela le ping estim√© moyen sur les appareils mobiles quelque part autour de 200 ms, alors le vrai d√©lai entre l'utilisation de l'entr√©e sur le client et la confirmation de l'application depuis le serveur √©tait de 400 ms! <br><br>  Cela ne nous convenait pas. <br><br>  Le fait est que certains syst√®mes ne fonctionnent que sur le serveur, comme par exemple le calcul des HP du joueur.  Avec ce d√©lai, le joueur tire et seulement apr√®s 400 ms voit comment il tue l'adversaire.  Si cela se produisait en mouvement, le joueur r√©ussissait g√©n√©ralement √† courir derri√®re le mur ou √† l'abri et y mourait d√©j√†.  Les tests de jeu au sein de l'√©quipe ont montr√© qu'un tel retard rompt compl√®tement tout le gameplay. <br><br>  La solution √† ce probl√®me a √©t√© l'impl√©mentation de tailles dynamiques de tampons d'entr√©e et de gamestates: <br><ul><li>  pour un tampon gamestate, le client conna√Æt toujours le contenu du tampon actuel.  Au moment du calcul du prochain tick, le client v√©rifie combien d'√©tats sont d√©j√† dans le tampon; </li><li>  pour le tampon d'entr√©e - le serveur, en plus de l'√©tat du jeu, a commenc√© √† envoyer au client la valeur du remplissage actuel du tampon d'entr√©e pour un client sp√©cifique.  Le client analyse √† son tour ces deux valeurs. </li></ul><br>  L'algorithme de redimensionnement du tampon gamestate est approximativement le suivant: <br><br><ol><li>  Le client consid√®re la valeur moyenne de la taille du tampon sur une p√©riode de temps et de la variance. </li><li>  Si la variance se situe dans les limites normales (c'est-√†-dire, pendant une p√©riode de temps donn√©e, il n'y a pas eu de sauts importants dans le remplissage et la lecture du tampon), le client v√©rifie la valeur de la taille moyenne du tampon pour cette p√©riode de temps. </li><li>  Si le remplissage moyen du tampon √©tait sup√©rieur √† la condition aux limites sup√©rieures (c'est-√†-dire que le tampon serait rempli plus que n√©cessaire), le client ¬´r√©duit¬ª la taille du tampon en effectuant un tick de simulation suppl√©mentaire. </li><li>  Si le remplissage moyen du tampon √©tait inf√©rieur √† la condition aux limites inf√©rieures (c'est-√†-dire que le tampon n'a pas eu le temps de se remplir avant que le client ne commence √† le lire) - dans ce cas, le client ¬´augmente¬ª la taille du tampon en sautant une coche de la simulation. </li><li>  Dans le cas o√π la variance √©tait sup√©rieure √† la normale, nous ne pouvons pas nous fier √† ces donn√©es, car  les surtensions du r√©seau pendant une p√©riode donn√©e √©taient trop importantes.  Ensuite, le client supprime toutes les donn√©es actuelles et recommence √† collecter des statistiques. </li></ol><br><h2>  Compensation du d√©calage du serveur </h2><br>  En raison du fait que le client re√ßoit les mises √† jour du monde du serveur avec un retard (retard), le joueur voit le monde un peu diff√©rent de celui qui existe sur le serveur.  Le joueur se voit dans le pr√©sent et dans le reste du monde - dans le pass√©.  Sur le serveur, le monde entier existe en une seule fois. <br><br><img src="https://habrastorage.org/webt/jo/ca/5d/joca5d_dhigvw1i9gjlpcd-tgqa.png"><br>  Pour cette raison, la situation est que le joueur tire localement sur une cible qui se trouve sur le serveur √† un autre endroit. <br><br>  Pour compenser le d√©calage, nous utilisons le rembobinage temporel sur le serveur.  L'algorithme de fonctionnement est approximativement le suivant: <br><br><ol><li>  Le client avec chaque entr√©e envoie en outre au serveur le temps de tick dans lequel il voit le reste du monde. </li><li>  Le serveur valide cette heure: est la diff√©rence entre l'heure actuelle et l'heure visible du monde du client dans l'intervalle de confiance. </li><li>  Si l'heure est valide, le serveur laisse le joueur √† l'heure actuelle et le reste du monde revient √† l'√©tat que le joueur a vu et calcule le r√©sultat du tir. </li><li>  Si un joueur frappe, les d√©g√¢ts sont caus√©s dans le temps du serveur actuel. </li></ol><br>  Le rembobinage du temps sur un serveur fonctionne comme suit: l'histoire du monde (en ECS) et l'histoire de la physique (support√©e par le moteur de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">physique volatile</a> ) sont stock√©es dans le nord.  Au moment du calcul du tir, les donn√©es du joueur sont extraites de l'√©tat actuel du monde et les autres joueurs de l'historique. <br><br><div class="spoiler">  <b class="spoiler_title">Le code du syst√®me de validation de prise de vue ressemble √† ceci:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shotPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Shot) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shot = shotPair.Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooter = gs.WorldState[shotPair.Key]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shooterTransform = shooter.Transform; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> weaponStats = gs.WorldState.WeaponStats[shot.WeaponId]; <span class="hljs-comment"><span class="hljs-comment">// DeltaTime shouldn't exceed physics history size var shootDeltaTime = (int) (gs.Time - shot.ShotPlayerWorldTime); if (shootDeltaTime &gt; PhysicsWorld.HistoryLength) { continue; } // Get the world at the time of shooting. var oldState = _immutableHistory.Get(shot.ShotPlayerWorldTime); var potentialTarget = oldState.WorldState[shot.Target.Id]; var hitTargetId = _singleShotValidator.ValidateTargetAvailabilityInLine(oldState, potentialTarget, shooter, shootDeltaTime, weaponStats.ShotDistance, shooter.Transform.Angle.GetDirection()); if (hitTargetId != 0) { gs.WorldState.CreateEntity().AddDamage(gs.WorldState[hitTargetId], shooter, weaponStats.ShotDamage); } } }</span></span></code> </pre> <br></div></div><br>  Un inconv√©nient majeur de l'approche est que nous faisons confiance au client dans les donn√©es sur l'heure de la tique qu'il voit.  Potentiellement, un joueur peut gagner un avantage en augmentant artificiellement le ping.  Parce que  plus un joueur a de ping, plus il tire loin dans le pass√©. <br><br><h2>  Quelques probl√®mes rencontr√©s </h2><br>  Lors de la mise en ≈ìuvre de ce moteur de r√©seau, nous avons rencontr√© de nombreux probl√®mes, dont certains m√©ritent un article s√©par√©, mais ici je n'aborderai que certains d'entre eux. <br><br><h4>  Simulation du monde entier dans un syst√®me de pr√©diction et copie </h4><br>  Initialement, tous les syst√®mes de notre ECS n'avaient qu'une seule m√©thode: void Execute (GameState gs).  Dans cette m√©thode, les composants li√©s √† tous les joueurs √©taient g√©n√©ralement trait√©s. <br><br><div class="spoiler">  <b class="spoiler_title">Un exemple de syst√®me de mouvement dans l'impl√©mentation initiale:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> transform = gs.WorldState.Transform[movementPair.Key]; transform.Position += movementPair.Value.Velocity * GameState.TickDuration; } } }</code> </pre> <br></div></div><br>  Mais dans le syst√®me de pr√©diction des joueurs locaux, nous n'avions besoin que de traiter les composants li√©s √† un joueur sp√©cifique.  Initialement, nous l'avons impl√©ment√© √† l'aide de la copie. <br><br>  Le processus de pr√©diction √©tait le suivant: <br><br><ol><li>  Une copie de l'√©tat du jeu a √©t√© cr√©√©e. </li><li>  Une copie a √©t√© fournie √† l'entr√©e ECS. </li><li>  Il y avait une simulation du monde entier dans ECS. </li><li>  Toutes les donn√©es relatives au joueur local ont √©t√© copi√©es √† partir du nouvel √©tat de jeu re√ßu. </li></ol><br><div class="spoiler">  <b class="spoiler_title">La m√©thode de pr√©diction ressemblait √† ceci:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _tempGameState.Copy(state); _ecsExecutor.Execute(_tempGameState, input); _playerEntitiesCopier.Copy(_tempGameState, newState); }</code> </pre> <br></div></div><br>  Il y avait deux probl√®mes dans cette mise en ≈ìuvre: <br><br><ol><li>  Parce que  nous utilisons des classes, pas des structures - la copie est une op√©ration assez co√ªteuse pour nous (environ 0,1-0,15 ms sur iPhone 5S). </li><li>  La simulation du monde entier prend √©galement beaucoup de temps (environ 1,5 √† 2 ms sur l'iPhone 5S). </li></ol><br>  Si nous tenons compte du fait qu'au cours du processus de coordination, il est n√©cessaire de recalculer de 5 √† 15 √âtats mondiaux dans un seul cadre, alors avec une telle mise en ≈ìuvre, tout a √©t√© terriblement lent. <br><br>  La solution √©tait assez simple: apprendre √† simuler le monde en plusieurs parties, c'est-√†-dire √† ne simuler qu'un joueur sp√©cifique.  Nous avons r√©√©crit tous les syst√®mes afin que vous puissiez transf√©rer l'ID du joueur et simuler uniquement lui. <br><br><div class="spoiler">  <b class="spoiler_title">Un exemple de syst√®me de mouvement apr√®s un changement:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MovementSystem</span></span> : <span class="hljs-title"><span class="hljs-title">ISystem</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movementPair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> gs.WorldState.Movement) { Move(gs.WorldState.Transform[movementPair.Key], movementPair.Value); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutePlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState gs, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> movement = gs.WorldState.Movement[playerId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(movement != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Move(gs.WorldState.Transform[playerId], movement); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Transform transform, Movement movement</span></span></span><span class="hljs-function">)</span></span> { transform.Position += movement.Velocity * GameState.TickDuration; } }</code> </pre> <br></div></div><br>  Apr√®s les changements, nous avons pu nous d√©barrasser des copies inutiles dans le syst√®me de pr√©diction et r√©duire la charge sur le syst√®me correspondant. <br><br><div class="spoiler">  <b class="spoiler_title">Code:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PredictNewState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameState state, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> playerId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newState = _stateHistory.Get(state.Tick+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = _inputHistory.Get(state.Tick); newState.Copy(state); _ecsExecutor.Execute(newState, input, playerId); }</code> </pre> <br></div></div><br><h4>  Cr√©ation et suppression d'entit√©s dans un syst√®me de pr√©diction </h4><br>  Dans notre syst√®me, la correspondance des entit√©s sur le serveur et le client se produit par un identifiant entier (id).  Pour toutes les entit√©s, nous utilisons une num√©rotation de bout en bout des identifiants, chaque nouvelle entit√© a la valeur id = oldID + 1. <br><br>  Cette approche est tr√®s pratique √† mettre en ≈ìuvre, mais elle pr√©sente un inconv√©nient important: l'ordre de cr√©ation de nouvelles entit√©s sur le client et le serveur peut √™tre diff√©rent et, par cons√©quent, les identifiants des entit√©s seront diff√©rents. <br><br>  Ce probl√®me s'est manifest√© lorsque nous avons impl√©ment√© un syst√®me de pr√©diction des tirs des joueurs.  Chaque prise de vue avec nous est une entit√© distincte avec la composante de prise de vue.  Pour chaque client, l'identifiant des entit√©s de tir dans le syst√®me de pr√©diction √©tait s√©quentiel.  Mais si au m√™me moment un autre joueur tirait, alors sur le serveur l'identifiant de tous les coups diff√©rait du client. <br><br>  Les prises de vue sur le serveur ont √©t√© cr√©√©es dans un ordre diff√©rent: <br><br><img src="https://habrastorage.org/webt/gl/dg/fy/gldgfykw7m30fuwspkra-xytgqe.png"><br><br>  Pour les tirs, nous avons contourn√© cette limitation, bas√©e sur les fonctionnalit√©s de jeu du jeu.  Les tirs sont des entit√©s √† vie rapide qui sont d√©truites dans le syst√®me une fraction de seconde apr√®s leur cr√©ation.  Sur le client, nous avons mis en √©vidence une plage distincte d'ID qui ne se croisent pas avec les ID de serveur et ne prennent plus en compte les plans dans le syst√®me de coordination.  C'est-√†-dire  les coups des joueurs locaux sont toujours dessin√©s dans le jeu uniquement selon le syst√®me de pr√©diction et ne prennent pas en compte les donn√©es du serveur. <br><br>  Avec cette approche, le joueur ne voit pas d'artefacts √† l'√©cran (suppression, recr√©ation, annulations de plans) et les √©carts avec le serveur sont mineurs et n'affectent pas le gameplay dans son ensemble. <br><br>  Cette m√©thode a permis de r√©soudre le probl√®me des tirs, mais pas tout le probl√®me de la cr√©ation d'entit√©s sur le client dans son ensemble.  Nous travaillons toujours sur les m√©thodes possibles pour r√©soudre la comparaison des objets cr√©√©s sur le client et le serveur. <br><br>  Il convient √©galement de noter que ce probl√®me ne concerne que la cr√©ation de nouvelles entit√©s (avec de nouveaux identifiants).  L'ajout et la suppression de composants sur des entit√©s d√©j√† cr√©√©es se font sans probl√®me: les composants n'ont pas d'identifiants et chaque entit√© ne peut avoir qu'un seul composant d'un type sp√©cifique.  Par cons√©quent, nous cr√©ons g√©n√©ralement des entit√©s sur le serveur, et dans les syst√®mes de pr√©diction, nous ajoutons / supprimons uniquement des composants. <br><br>  En conclusion, je tiens √† dire que la t√¢che de mise en ≈ìuvre du multijoueur n'est pas la plus simple et la plus rapide, mais il y a beaucoup d'informations sur la fa√ßon de proc√©der. <br><br><h2>  Que lire </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Multiplayer in fast games</a> - traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fast-Paced Multiplayer (Part I): Introduction</a> (√† mon avis, c'est le meilleur article sur Habr√© sur l'interaction r√©seau dans les jeux). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GDC Vault Overwatch Gameplay Architecture et Netcode</a> - une conf√©rence avec GDC 17, sur ECS et le code r√©seau dans Overwatch (malheureusement, l'acc√®s est payant). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GDC Vault: 8 images en 16 ms: Rollback Networking dans Mortal Kombat et Injustice 2</a> - comment cela se fait dans les jeux de combat. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">R√©seau multijoueur source</a> - Comment fonctionne le multijoueur dans Counter Strike. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Gaffer on Games</a> concerne g√©n√©ralement le code r√©seau dans les jeux. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">UDP dans les moteurs de jeux</a> . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GDC Vault: I Shot you first networking</a> - comment fonctionne le multijoueur dans Halo: Reach. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415959/">https://habr.com/ru/post/fr415959/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415947/index.html">Syst√®me de compensation d'erreur d'installation de fibre optique lors de son traitement par rayonnement laser lors de la rotation</a></li>
<li><a href="../fr415949/index.html">Extraction √©lev√©e: la derni√®re option pour prot√©ger la blockchain PoW d'une ¬´attaque de 51%¬ª</a></li>
<li><a href="../fr415951/index.html">Mitap Sberbank et IBM sur HyperLedger Fabric</a></li>
<li><a href="../fr415953/index.html">Comment une entreprise sanglante remporte l'open source: la bataille pour BPMS</a></li>
<li><a href="../fr415957/index.html">Nous avons besoin de plus de sacs √† dos: le Bobby XL de XD Design</a></li>
<li><a href="../fr415961/index.html">Stockage distribu√© russe. Comment √ßa marche</a></li>
<li><a href="../fr415963/index.html">Naive Bayes, ou comment les math√©matiques vous permettent de filtrer le spam</a></li>
<li><a href="../fr415965/index.html">√Ä lire en juillet: 19 nouveaux livres pour les professionnels du num√©rique</a></li>
<li><a href="../fr415967/index.html">SolidFire - Stockage pour ces ** cking hate stockage</a></li>
<li><a href="../fr415969/index.html">HyperX Pulsefire Surge RGB - un tueur n√© naturel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>