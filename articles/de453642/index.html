<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛎ 🍿 🐿️ Intelligenter Parser für eine in Worten geschriebene Zahl 👉🏼 👲🏻 💲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog 


 Guten Tag, liebe Leser. In diesem Artikel werde ich darüber sprechen, wie man eine Zahl analysiert, die in russischen Wörtern geschrieben i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intelligenter Parser für eine in Worten geschriebene Zahl</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453642/"><img src="https://habrastorage.org/webt/x_/al/d2/x_ald2dbs-mrb8gyk1v9z7fzk9w.png"><br><br><h1>  Prolog </h1><br><p>  Guten Tag, liebe Leser.  In diesem Artikel werde ich darüber sprechen, wie man eine Zahl analysiert, die in russischen Wörtern geschrieben ist. </p><br><p>  Smart Dieser Parser ermöglicht das Extrahieren von Zahlen aus Text mit Fehlern, die durch falsche Eingabe oder durch optische Erkennung von Text aus einem Bild (OCR) verursacht wurden. </p><br><p>  Für die Faulen: <br>  Link zum Github-Projekt: <a href="">Link</a> . </p><br><a name="habracut"></a><br><h1>  Vom Algorithmus zum Ergebnis </h1><br><p>  In diesem Abschnitt werden die verwendeten Algorithmen beschrieben.  Achtung, viele Briefe! </p><br><h2>  Erklärung des Problems </h2><br><p> Bei der Arbeit muss ich Text aus einem gedruckten Dokument erkennen, das mit einer Smartphone- / Tablet-Kamera fotografiert wurde.  Aufgrund der Geheimhaltungsvereinbarung kann ich kein Beispiel für ein Foto geben, aber der Punkt ist, dass das Dokument eine Tabelle enthält, in der bestimmte Indikatoren in Zahlen und Worten geschrieben sind und diese Daten gelesen werden müssen.  Das Parsen von Text in Wörtern ist als zusätzliches Validierungswerkzeug erforderlich, um sicherzustellen, dass die Nummer korrekt erkannt wird.  Wie Sie wissen, garantiert OCR jedoch keine genaue Texterkennung.  Zum Beispiel kann die in Worten geschriebene Zahl zwanzig als "dvupat" oder sogar als "dvupat" erkannt werden.  Es ist notwendig, dies zu berücksichtigen und die maximale Informationsmenge zu extrahieren, um die Größe des möglichen Fehlers zu bewerten. </p><br><p>  <b>Hinweis</b>  Für die Texterkennung verwende ich tesseract 4. Für .NET gibt es kein fertiges NuGet-Paket der vierten Version, daher habe ich eines aus dem Hauptprojektzweig erstellt, das nützlich sein kann: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genesis.Tesseract4</a> . </p><br><br><h2>  Grundlegender Algorithmus zum Parsen von Zahlen </h2><br><p>  Beginnen wir mit einem einfachen, nämlich mit einem in Worten geschriebenen Texterkennungsalgorithmus, der bisher fehlerfrei war.  Wenn Sie an Smart Parsing interessiert sind, überspringen Sie diesen Abschnitt. </p><br><p>  Ich kann nicht besonders gut googeln, daher habe ich nicht sofort einen vorgefertigten Algorithmus zur Lösung dieses Problems gefunden.  Dies ist jedoch sogar zum Besseren, weil  Ein von uns erfundener Algorithmus bietet mehr Raum für die Codierung.  Und die Aufgabe selbst erwies sich als interessant. </p><br><p>  Nehmen wir also eine kleine Zahl, zum Beispiel "einhundertdreiundzwanzig".  Es besteht aus drei Wörtern ( <i>Token</i> ), von denen jedes einer Zahl entspricht. Alle diese Zahlen werden zusammengefasst: </p><br> <code>"  " =  +  +  = 100 + 20 + 3 = 123</code> <br> <br><p>  Bisher ist alles einfach, aber wir graben tiefer, zum Beispiel betrachten wir die Zahl "zweihundert, zwölftausend, einhundertfünf". </p><br> <code>"    " = ( + ) ×  + ( + ) = 212 * 1.000 + 105 = 212.105.</code> <br> <br><p>  Wie Sie sehen können, wird die Zahl bei Tausenden in der Zahl (sowie Millionen und anderen Graden von Tausend) in Teile unterteilt, die aus einer lokalen kleinen Zahl im obigen Beispiel - 212 und einem Faktor (1000) bestehen.  Es kann mehrere solcher Fragmente geben, aber alle gehen in absteigender Reihenfolge des Multiplikators vor, zum Beispiel können tausend oder eintausend nicht tausend folgen.  Dies gilt auch für Teile einer kleinen Anzahl, da Hunderte nicht Hunderten und Zehntausenden folgen können, sodass der Eintrag „einhundertfünfhundert“ falsch ist.  Wir werden ein Merkmal, das zwei Token desselben Typs in Beziehung setzt, als <i>Stufe bezeichnen</i> . Beispielsweise haben die Token „einhundert“ und „dreihundert“ eine Stufe und sind größer als die Marke „fünfzig“. </p><br><p>  Aus diesen Überlegungen entsteht die Idee eines Algorithmus.  Schreiben wir alle möglichen Token ( <i>Samples</i> ) auf, denen wir jeweils eine Zahl zuweisen, sowie zwei Parameter - den Pegel und das Vorzeichen des Multiplikators. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token </th><th>  Nummer </th><th>  Level </th><th>  Multiplikator? </th></tr><tr><td>  Null <br></td><td>  0 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  Single / Single <br></td><td>  1 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  zwei / zwei <br></td><td>  2 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  neunzehn <br></td><td>  19 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  zwanzig <br></td><td>  20 <br></td><td>  2 <br></td><td>  Nein <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  2 <br></td><td>  Nein <br></td></tr><tr><td>  neunzig <br></td><td>  90 <br></td><td>  2 <br></td><td>  Nein <br></td></tr><tr><td>  einhundert <br></td><td>  100 <br></td><td>  3 <br></td><td>  Nein <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  3 <br></td><td>  Nein <br></td></tr><tr><td>  neunhundert <br></td><td>  900 <br></td><td>  3 <br></td><td>  Nein <br></td></tr><tr><td>  tausend / tausend / tausend <br></td><td>  1.000 <br></td><td>  4 <br></td><td>  ja <br></td></tr><tr><td>  Millionen / Millionen / Millionen <br></td><td>  1.000.000 <br></td><td>  5 <br></td><td>  ja <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td><td>  ja <br></td></tr><tr><td>  Billiarde / Billiarde / Billiarde <br></td><td>  1.000.000.000.000.000 <br></td><td>  8 <br></td><td>  ja <br></td></tr></tbody></table></div><br><p>  Sie können dieser Tabelle auch andere Token hinzufügen, auch für Fremdsprachen. Vergessen Sie jedoch nicht, dass in einigen Ländern eher ein langes als ein kurzes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benennungssystem verwendet wird</a> . </p><br><p>  Fahren wir nun mit dem Parsen fort.  Wir erhalten vier Mengen: </p><br><ol><li>  <i>Globale Ebene</i> (globalLevel).  Zeigt den Pegel des letzten Multiplikators an.  Anfangs undefiniert und zur Kontrolle notwendig.  Wenn wir auf ein Multiplikator-Token stoßen, dessen Pegel größer oder gleich dem globalen ist, ist dies ein Fehler. </li><li>  <i>Globaler Wert</i> (globalValue).  Der Gesamtaddierer, wobei das Ergebnis das Ergebnis der Multiplikation der lokalen Zahl und des Faktors ist. </li><li>  <i>Lokale Ebene</i> (localLevel).  Gibt an, welche Stufe der letzte Token hatte.  Anfänglich undefiniert, funktioniert ähnlich wie auf globaler Ebene, wird jedoch nach der Ermittlung des Multiplikators zurückgesetzt. </li><li>  <i>Lokaler Wert</i> (localValue)  Ein Nicht-Multiplikator-Token-Addierer, d.h.  Zahlen bis zu 999. </li></ol><br><p>  Der Algorithmus ist wie folgt: </p><br><ol><li>  Teilen Sie die Zeichenfolge mit dem regulären "\ s +" in Token auf. </li><li>  Wir nehmen das nächste Token und erhalten Informationen darüber aus dem Beispiel. </li><li>  Wenn es ein Multiplikator ist: <br><ul><li>  Wenn die globale Ebene festgelegt ist, stellen wir sicher, dass sie größer oder gleich der Ebene des Tokens ist.  Wenn nicht, ist dies ein Fehler, die Nummer ist falsch. </li><li>  Stellen Sie die globale Ebene auf die Ebene des aktuellen Tokens ein. </li><li>  Multiplizieren Sie den Wert des Tokens mit dem lokalen Wert und addieren Sie das Ergebnis zum globalen Wert. </li><li>  Wir löschen den lokalen Wert und das Niveau. </li></ul></li><li>  Wenn dies kein Multiplikator ist: <br><ul><li>  Wenn die lokale Ebene festgelegt ist, stellen wir sicher, dass sie größer oder gleich der Ebene des Tokens ist.  Wenn nicht, ist dies ein Fehler, die Nummer ist falsch. </li><li>  Stellen Sie die lokale Ebene auf die Ebene des aktuellen Tokens ein. </li><li>  Fügen Sie den Token-Wert zum lokalen Wert hinzu. </li></ul></li><li>  Wir geben das Ergebnis als Summe der globalen und lokalen Werte zurück. </li></ol><br><p>  Ein Arbeitsbeispiel für die Zahl "zwei Millionen zweihundertzwölftausendeinhundertfünfundachtzig". </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token <br></th><th>  globalLevel <br></th><th>  globalValue <br></th><th>  localLevel <br></th><th>  localValue <br></th></tr><tr><td></td><td>  - - <br></td><td>  - - <br></td><td>  - - <br></td><td>  - - <br></td></tr><tr><td>  zwei <br></td><td>  - - <br></td><td>  - - <br></td><td>  1 <br></td><td>  2 <br></td></tr><tr><td>  Millionen <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  - - <br></td><td>  - - <br></td></tr><tr><td>  zweihundert <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  3 <br></td><td>  200 <br></td></tr><tr><td>  zwölf <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  1 <br></td><td>  212 <br></td></tr><tr><td>  tausend <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  - - <br></td><td>  - - <br></td></tr><tr><td>  einhundert <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  3 <br></td><td>  100 <br></td></tr><tr><td>  achtzig <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  2 <br></td><td>  180 <br></td></tr><tr><td>  fünf <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  1 <br></td><td>  185 <br></td></tr></tbody></table></div><p>  Das Ergebnis ist 2.212.185. </p><br><h2>  Intelligentes Parsen </h2><br><p>  Dieser Algorithmus kann verwendet werden, um andere Vergleiche zu implementieren, und nicht nur zum Parsen von Zahlen. Aus diesem Grund werde ich versuchen, ihn genauer zu beschreiben. </p><br><p>  Mit dem Parsen der korrekt geschriebenen Nummer herausgefunden.  Lassen Sie uns nun darüber nachdenken, welche Fehler auftreten können, wenn die durch OCR erhaltene Nummer falsch geschrieben wird.  Ich erwäge keine anderen Optionen, aber Sie können den Algorithmus für eine bestimmte Aufgabe ändern. </p><br><p>  Ich habe drei Arten von Fehlern identifiziert, auf die ich bei der Arbeit gestoßen bin: </p><br><ol><li>  Ersetzen Sie Zeichen durch andere mit einem ähnlichen Stil.  Zum Beispiel wird der Buchstabe "c" aus irgendeinem Grund durch "p" und "n" durch "und" ersetzt und umgekehrt.  Bei Verwendung der dritten Version von tesseract ist es möglich, den Buchstaben „o“ durch Null zu ersetzen.  Diese Fehler sind spontan am häufigsten und erfordern die Optimierung für eine bestimmte Erkennungsbibliothek.  Die Arbeitsprinzipien der Tesseract-Versionen 3 und 4 weisen also grundlegende Unterschiede auf, daher sind die Fehler dort unterschiedlich. <br></li><li>  Token zusammenführen.  Wörter können zusammengeführt werden (haben das Gegenteil noch nicht getroffen).  In Kombination mit dem ersten Fehler werden dämonische Phrasen wie "doppelte Eins" generiert.  Versuchen wir auch solche Monster zu dämonisieren. <br></li><li>  Rauschen - linke Zeichen und Phrasen im Text.  Leider kann im Moment wenig getan werden, aber es gibt eine Perspektive, wenn ausreichend signifikante Statistiken gesammelt werden. <br></li></ol><br><p>  Gleichzeitig ändert sich der oben beschriebene Parsing-Algorithmus fast nicht. Der Hauptunterschied besteht darin, die Zeichenfolge in Token zu zerlegen. </p><br><p>  Beginnen wir jedoch mit der Erfassung einiger Statistiken zur Verwendung von Buchstaben in Token.  Von den 33 Buchstaben der russischen Sprache werden nur 20 beim Schreiben nicht negativer Ganzzahlen verwendet. Nennen wir sie <i>gute Buchstaben</i> : </p><br> <code></code> <br> <br><p>  Die restlichen 13 werden als <i>schlechte Buchstaben bezeichnet</i> .  Die maximale Größe des Tokens beträgt 12 Zeichen (13 bei Zählung bis Billiarde).  Teilzeichenfolgen, die länger als dieser Wert sind, müssen aufgeteilt werden. </p><br><p>  Um Zeichenfolgen und Token zu vergleichen, entschied ich mich für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Wagner-Fisher-Algorithmus</a> , obwohl ich ihn im Code den Namen Levenshtein nannte.  Ich benötige keine redaktionelle Anleitung, daher habe ich eine speicherfreundliche Version des Algorithmus implementiert.  Ich muss zugeben, dass sich die Implementierung dieses Algorithmus als schwieriger herausstellte als der Parser selbst. </p><br><p>  Ein kleines Bildungsprogramm: Die Levenshtein-Distanz ist ein Sonderfall des Wagner-Fisher-Algorithmus, wenn die Kosten für das Einfügen, Löschen und Ersetzen von Zeichen statisch sind.  Dies ist bei unserer Aufgabe nicht der Fall.  Wenn wir einen schlechten Buchstaben in einem Teilstring finden, muss dieser natürlich durch einen guten Buchstaben ersetzt werden, aber das Ersetzen eines guten durch einen schlechten ist äußerst unerwünscht.  Im Allgemeinen ist es unmöglich, aber die Situation hängt von der spezifischen Aufgabe ab. </p><br><p>  Um die Kosten für das Einfügen, Löschen und Ersetzen von Zeichen zu beschreiben, habe ich eine Tabelle wie diese erstellt: einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zu einer Tabelle mit Gewichten</a> .  Es ist zwar mit der Drei-P-Methode (Geschlecht, Finger, Decke) gefüllt, aber wenn Sie es mit Daten füllen, die auf OCR-Statistiken basieren, können Sie die Qualität der Nummernerkennung erheblich verbessern.  Der Bibliothekscode enthält die Ressourcendatei NumeralLevenshteinData.txt, in die Sie mit Strg + A, Strg + C und Strg + V Daten aus einer ähnlichen Tabelle einfügen können. </p><br><p>  Wenn im Text ein Nicht-Tabellenzeichen gefunden wird, z. B. Null, entsprechen die Kosten für das Einfügen dem Maximalwert aus der Tabelle, und die Kosten für das Löschen und Ersetzen entsprechen dem Minimum. Daher ersetzt der Algorithmus mit größerer Wahrscheinlichkeit Null durch den Buchstaben „o“, und wenn Sie die dritte Version von tesseract verwenden Dann ist es sinnvoll, der Tabelle Null hinzuzufügen und den Mindestpreis zu schreiben, um sie durch den Buchstaben „o“ zu ersetzen. </p><br><p>  Also haben wir die Daten für den Wagner-Fisher-Algorithmus vorbereitet. Nehmen wir Änderungen am Algorithmus zum Aufteilen der Zeichenfolge in Token vor.  Zu diesem Zweck werden wir eine zusätzliche Analyse jedes Tokens durchführen. Zuvor werden wir jedoch die Informationen über das Token mit den folgenden Merkmalen erweitern: </p><br><ul><li>  <i>Fehlerstufe</i> .  Eine reelle Zahl von 0 (kein Fehler) bis 1 (das Token ist falsch), was bedeutet, wie gut das Token mit der Stichprobe verglichen wurde. <br></li><li>  <i>Ein Zeichen für die Verwendung eines Tokens</i> .  Beim Parsen einer Zeichenfolge mit eingestreuten Trümmern wird ein Teil der Token verworfen, da dieses Attribut nicht festgelegt wird.  In diesem Fall wird der Gesamtfehlerwert als arithmetischer Durchschnitt der Fehler der verwendeten Token betrachtet. <br></li></ul><br><p>  Token-Analyse-Algorithmus: </p><br><ol><li>  Wir versuchen, das Token so wie es ist in der Tabelle zu finden.  Wenn wir finden - alles ist gut, geben Sie es zurück. </li><li>  Wenn nicht, erstellen Sie eine Liste möglicher Optionen: </li><li><p>  Wir versuchen, das Token mit dem Wagner-Fisher-Algorithmus mit dem Sample abzugleichen.  Diese Option besteht aus einem Token (zugeordnetes Sample) und sein Fehler entspricht dem besten Abstand geteilt durch die Länge des Samples. </p><br>  <b>Beispiel: Das</b> "Null" -Token wird mit dem "Null" -Sample verglichen, während der Abstand 0,5 beträgt, weil  Die Kosten für das Ersetzen des schlechten Buchstabens "y" durch ein gutes "o" betragen 0,5.  Der Gesamtfehler für dieses Token beträgt 0,5 / 4 = 0,125. <br></li><li><p>  Wenn der Teilstring groß genug ist (ich habe 6 Zeichen), versuchen wir, ihn in zwei Teile mit jeweils mindestens 3 Zeichen zu unterteilen.  Für eine Zeichenfolge mit 6 Zeichen gibt es eine einzelne Unterteilung: 3 + 3 Zeichen.  Für eine Zeichenfolge mit 7 Zeichen gibt es bereits zwei Optionen: 3 + 4 und 4 + 3 usw.  Für jede der Optionen rufen wir dieselbe Tokenanalysefunktion rekursiv auf und geben die empfangenen Optionen in die Liste ein. </p><br><p>  Um nicht in Rekursion zu sterben, bestimmen wir die maximale Fehlerquote.  Darüber hinaus werden die durch die Teilung erhaltenen Optionen um einen bestimmten Betrag künstlich verschlechtert (Option, standardmäßig 0,1), so dass die direkte Vergleichsoption wertvoller ist.  Ich musste diese Operation hinzufügen, weil  Teilschritte vom Typ "doppelt" wurden erfolgreich in die Token "zwei" und "fünf" unterteilt und nicht auf "zwanzig" reduziert.  Leider sind dies die Merkmale der russischen Sprache. </p><br><p>  <b>Beispiel: Das</b> "doppelte" Token hat einen direkten Vergleich mit der "zwanzig" Stichprobe, Fehler 0,25.  Darüber hinaus ist die beste Option zum Teilen „zwei“ + „fünf“ mit Kosten von 0,25 (Ersetzen von „a“ durch „i“), die künstlich auf 0,35 verschlechtert wurden, wodurch der Token „zwanzig“ bevorzugt wird. </p><br></li><li>  Nachdem wir alle Optionen zusammengestellt haben, wählen wir die beste aus der minimalen Fehleranzahl der daran teilnehmenden Token aus.  Das Ergebnis wird zurückgegeben. </li></ol><br><p>  Darüber hinaus wird die Token-Überprüfung in den Algorithmus zur Generierung von Hauptnummern eingeführt, sodass deren Fehler einen bestimmten Wert nicht überschreitet (Option, Standardwert 0,67).  Damit filtern wir potenziellen Müll aus, wenn auch nicht sehr erfolgreich. </p><br><h2>  Der Algorithmus auf den Punkt gebracht für diejenigen, die zu faul waren, um den obigen Text zu lesen </h2><br><p>  Wir teilen die Eingabezeichenfolge, bei der es sich um die Zahl in Worten handelt, unter Verwendung der Regelmäßigkeit \ s + in Teilzeichenfolgen auf. Anschließend versuchen wir, jede Teilzeichenfolge mit Beispieltoken abzugleichen oder sie in kleinere Teilzeichenfolgen aufzuteilen, um die besten Ergebnisse zu erzielen.  Als Ergebnis erhalten wir eine Reihe von Token, mit denen wir eine Zahl generieren, und der Fehlerwert wird als arithmetisches Mittel der Fehler unter den in der Generierung verwendeten Token verwendet. </p><br><h2>  Schärfen eines Algorithmus für eine bestimmte Aufgabe </h2><br><p>  In meiner Aufgabe sind die Zahlen nicht negativ und relativ klein, daher werde ich unnötige Token von der "Million" und höher ausschließen.  Für den Test, liebe Leser, habe ich im Gegenteil zusätzliche Jargon-Token hinzugefügt, mit denen Zeichenfolgen wie „fünf Teile“, „zweihundert mähen“ und sogar „drei Stolniks und zwei Goldstücke“ analysiert werden konnten.  Es ist lustig, aber es waren nicht einmal Änderungen am Algorithmus erforderlich. </p><br><h2>  Weitere Verbesserung </h2><br><p>  Der vorhandene Algorithmus weist folgende Mängel auf: </p><br><ol><li>  <b>Fallkontrolle.</b>  Die Zeichenfolgen "zweitausend" und "zweitausend" werden mit einem Fehler von Null als 2000 erkannt. In meiner Aufgabe ist keine Fallkontrolle erforderlich, sie ist sogar schädlich. Wenn Sie jedoch eine solche Funktion benötigen, wird dies durch Einfügen eines zusätzlichen Flags in das Token gelöst, das für den Fall des nächsten Tokens verantwortlich ist . <br></li><li>  <b>Negative Zahlen.</b>  Ein zusätzliches Minus-Token wird mit spezieller Verarbeitung eingeführt.  Nichts kompliziertes, aber vergessen Sie nicht, dass der Buchstabe „y“ schlecht ist und nicht in den Ziffern vorkommt. Sie müssen seine Gewichtseigenschaften ändern oder hoffen, dass er sich während des OCR-Prozesses nicht ändert. <br></li><li>  <b>Bruchzahlen.</b>  Es wird gelöst, indem der lange Typ durch einen doppelten Typ ersetzt und Token von "Zehntel", "Hundertstel" usw. eingeführt werden. Vergessen Sie nicht, die Buchstabenskala zu überarbeiten. <br></li><li>  <b>Erkennung von von Benutzern eingegebenen Nummern.</b>  Weil  Bei der manuellen Eingabe von Text machen wir meistens Fehler im Zusammenhang mit der erneuten Bearbeitung von siVMolov. Sie sollten diese Operation zum Wagner-Fisher-Algorithmus hinzufügen. <br></li><li>  <b>Unterstützung für andere Sprachen.</b>  Wir führen neue Token ein und erweitern die Gewichtstabelle. <br></li><li>  <b>Müllabfuhr.</b>  In einigen Dokumenten werden Daten gedruckt, die Bildqualität ist möglicherweise schlecht, die Zelle ist möglicherweise leer.  In diesem Fall gelangt Müll, der gereinigt werden muss, irgendwie in die Leitung.  Das Beste, was ich im Moment anbieten kann, ist, das Dokument vor der OCR vorzuverarbeiten.  Das Entfernen der Tabellenzeilen und das Füllen mit einer Farbe, die der Farbe des freien Raums der Zelle nahe kommt, hat mir sehr geholfen.  Dies löste nicht alle Probleme, verbesserte jedoch die Qualität der Erkennung von Text aus Dokumenten, bei denen die Tabelle aufgrund von Blutergüssen des Dokuments oder eines krummen Fotografen Krümmungen aufwies.  Idealerweise sollten Sie die Zelle selbst drehen und separat erkennen, wenn Sie natürlich überhaupt einen Tisch haben. <br></li></ol><br><h1>  Was ist das Endergebnis? </h1><br><p>  Das Projekt enthält ein Beispiel für eine Konsolenanwendung, die in der Datei samples.txt ausgeführt wird, mit Beispielen für den Parser.  Hier ist ein Screenshot der Ergebnisse: </p><br><img src="https://habrastorage.org/webt/fq/ed/ac/fqedacgduf7tewa8tvg-tn6zv3s.png"><br><br><p>  Ich fordere Sie auf, das Ergebnis zu bewerten, aber für mich ist es nicht schlecht.  Der Fehler für echte Erkennungsbeispiele überschreitet nicht 0,25, obwohl ich noch nicht den gesamten Satz verfügbarer Dokumente ausgeführt habe, wird dort wahrscheinlich nicht alles so reibungslos sein. </p><br><p>  Was den letzten Abschnitt betrifft, habe ich mich immer gefragt, wie sehr dies „Dofiga“ ist.  Außerdem gab sich das Programm eine angemessene Antwort darauf, wie viel es braucht (ich benutze es nicht, aber immer noch) und bestimmte sogar genau die Bedeutung des alten russischen Wortes "Dunkelheit".  Und ja, die Schlussfolgerung enthielt keine weitere Maßnahme, die die Bildung nicht hinzufügen durfte, aber das Programm geht davon aus, dass sie tausend entspricht =) </p><br><h1>  Ein paar Worte zur Bibliothek </h1><br><p>  Ursprünglich war nicht geplant, eine Bibliothek zu erstellen. Ich beschloss, sie exklusiv für einen Habr zu entwerfen.  Ich habe versucht, den Code in Ordnung zu bringen, aber wenn Sie ihn verwenden, machen Sie eine Gabel oder eine Kopie, als  Höchstwahrscheinlich benötigen Sie keinen Jargon und keine anderen in den Beispielen enthaltenen Token. </p><br><p>  Die Bibliothek selbst ist unter .NET Standart 2.0 und C # 7.x geschrieben, und die Algorithmen können problemlos in andere Sprachen übersetzt werden. </p><br><p>  Im Falle einer möglichen Erweiterung der Bibliothek werde ich die Zusammensetzung der wichtigen Komponenten des Zahlenparsers in Worten hinzufügen (Genesis.CV.NumberUtils-Namespace): </p><br><ul><li>  RussianNumber.cs - direkter Parser </li><li>  RussianNumber.Data.cs - Datei mit Beschreibung der Token </li><li>  RussianNumber.ToString.cs - Konverter von Zahl zu Text in Worten </li><li>  RussianNumberParserOptions.cs - Parser-Optionen </li><li>  NumeralLevenshtein.cs - Implementierung des Wagner-Fisher-Algorithmus </li><li>  NumeralLevenshteinData.txt - Ressource, Daten zur Buchstabengewichtung </li></ul><br><p>  Verwendung: </p><br><ul><li>  RussianNumber.ToString (Wert) - Konvertiert eine Zahl in Text </li><li>  RussianNumber.Parse (Wert, [Optionen]) - Konvertiert Text in Zahl </li></ul><br><h1>  Fazit </h1><br><p>  Ich hoffe wirklich, dass Ihnen der Artikel trotz der Fülle an Texten nicht langweilig erschien.  In letzter Zeit habe ich viele Themen im Zusammenhang mit Computer Vision entwickelt, über die es etwas zu erzählen gibt. Daher würde ich gerne eine Meinung zu diesem Artikelformat erfahren.  Was ist es wert, hinzugefügt oder umgekehrt entfernt zu werden?  Was ist für Sie, die Leser, die Algorithmen selbst oder die Codefragmente interessanter? </p><br><p>  Gefällt dir der Artikel?  Schauen Sie sich die anderen an: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse JavaScript Unterstützung der JavaScript-Serialisierung</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Füllen von Textvorlagen mit modellbasierten Daten.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET-Implementierung mit IL-Funktionen (Dynamic Bytecode)</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453642/">https://habr.com/ru/post/de453642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453618/index.html">Wie wir mit Ideen arbeiten und wie LANBIX geboren wurde</a></li>
<li><a href="../de453622/index.html">G-Shield Chip Programmer: Schreiben digitaler Zertifikate auf Chips in der Produktionsphase</a></li>
<li><a href="../de453626/index.html">Abenteuer in einem separaten Stream. Yandex-Bericht</a></li>
<li><a href="../de453628/index.html">Wofür wirst du in 20 Jahren bezahlen?</a></li>
<li><a href="../de453634/index.html">Alfa Bank School of System Analysis</a></li>
<li><a href="../de453644/index.html">Interview - 10 Fragen zu Swift. Teil 3</a></li>
<li><a href="../de453646/index.html">Normalisierung von Daten in einer verteilten Datenbank, Microservices und ERP</a></li>
<li><a href="../de453650/index.html">Softwarekern der On-Board-Cyber-Infrastruktur des einheitlichen Streikkämpfers F-35</a></li>
<li><a href="../de453652/index.html">LogRock: Testen durch Protokollierung</a></li>
<li><a href="../de453656/index.html">Statisches Web: Zurück zu den Grundlagen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>