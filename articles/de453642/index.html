<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õé üçø üêøÔ∏è Intelligenter Parser f√ºr eine in Worten geschriebene Zahl üëâüèº üë≤üèª üí≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prolog 


 Guten Tag, liebe Leser. In diesem Artikel werde ich dar√ºber sprechen, wie man eine Zahl analysiert, die in russischen W√∂rtern geschrieben i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intelligenter Parser f√ºr eine in Worten geschriebene Zahl</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453642/"><img src="https://habrastorage.org/webt/x_/al/d2/x_ald2dbs-mrb8gyk1v9z7fzk9w.png"><br><br><h1>  Prolog </h1><br><p>  Guten Tag, liebe Leser.  In diesem Artikel werde ich dar√ºber sprechen, wie man eine Zahl analysiert, die in russischen W√∂rtern geschrieben ist. </p><br><p>  Smart Dieser Parser erm√∂glicht das Extrahieren von Zahlen aus Text mit Fehlern, die durch falsche Eingabe oder durch optische Erkennung von Text aus einem Bild (OCR) verursacht wurden. </p><br><p>  F√ºr die Faulen: <br>  Link zum Github-Projekt: <a href="">Link</a> . </p><br><a name="habracut"></a><br><h1>  Vom Algorithmus zum Ergebnis </h1><br><p>  In diesem Abschnitt werden die verwendeten Algorithmen beschrieben.  Achtung, viele Briefe! </p><br><h2>  Erkl√§rung des Problems </h2><br><p> Bei der Arbeit muss ich Text aus einem gedruckten Dokument erkennen, das mit einer Smartphone- / Tablet-Kamera fotografiert wurde.  Aufgrund der Geheimhaltungsvereinbarung kann ich kein Beispiel f√ºr ein Foto geben, aber der Punkt ist, dass das Dokument eine Tabelle enth√§lt, in der bestimmte Indikatoren in Zahlen und Worten geschrieben sind und diese Daten gelesen werden m√ºssen.  Das Parsen von Text in W√∂rtern ist als zus√§tzliches Validierungswerkzeug erforderlich, um sicherzustellen, dass die Nummer korrekt erkannt wird.  Wie Sie wissen, garantiert OCR jedoch keine genaue Texterkennung.  Zum Beispiel kann die in Worten geschriebene Zahl zwanzig als "dvupat" oder sogar als "dvupat" erkannt werden.  Es ist notwendig, dies zu ber√ºcksichtigen und die maximale Informationsmenge zu extrahieren, um die Gr√∂√üe des m√∂glichen Fehlers zu bewerten. </p><br><p>  <b>Hinweis</b>  F√ºr die Texterkennung verwende ich tesseract 4. F√ºr .NET gibt es kein fertiges NuGet-Paket der vierten Version, daher habe ich eines aus dem Hauptprojektzweig erstellt, das n√ºtzlich sein kann: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Genesis.Tesseract4</a> . </p><br><br><h2>  Grundlegender Algorithmus zum Parsen von Zahlen </h2><br><p>  Beginnen wir mit einem einfachen, n√§mlich mit einem in Worten geschriebenen Texterkennungsalgorithmus, der bisher fehlerfrei war.  Wenn Sie an Smart Parsing interessiert sind, √ºberspringen Sie diesen Abschnitt. </p><br><p>  Ich kann nicht besonders gut googeln, daher habe ich nicht sofort einen vorgefertigten Algorithmus zur L√∂sung dieses Problems gefunden.  Dies ist jedoch sogar zum Besseren, weil  Ein von uns erfundener Algorithmus bietet mehr Raum f√ºr die Codierung.  Und die Aufgabe selbst erwies sich als interessant. </p><br><p>  Nehmen wir also eine kleine Zahl, zum Beispiel "einhundertdreiundzwanzig".  Es besteht aus drei W√∂rtern ( <i>Token</i> ), von denen jedes einer Zahl entspricht. Alle diese Zahlen werden zusammengefasst: </p><br> <code>"  " =  +  +  = 100 + 20 + 3 = 123</code> <br> <br><p>  Bisher ist alles einfach, aber wir graben tiefer, zum Beispiel betrachten wir die Zahl "zweihundert, zw√∂lftausend, einhundertf√ºnf". </p><br> <code>"    " = ( + ) √ó  + ( + ) = 212 * 1.000 + 105 = 212.105.</code> <br> <br><p>  Wie Sie sehen k√∂nnen, wird die Zahl bei Tausenden in der Zahl (sowie Millionen und anderen Graden von Tausend) in Teile unterteilt, die aus einer lokalen kleinen Zahl im obigen Beispiel - 212 und einem Faktor (1000) bestehen.  Es kann mehrere solcher Fragmente geben, aber alle gehen in absteigender Reihenfolge des Multiplikators vor, zum Beispiel k√∂nnen tausend oder eintausend nicht tausend folgen.  Dies gilt auch f√ºr Teile einer kleinen Anzahl, da Hunderte nicht Hunderten und Zehntausenden folgen k√∂nnen, sodass der Eintrag ‚Äûeinhundertf√ºnfhundert‚Äú falsch ist.  Wir werden ein Merkmal, das zwei Token desselben Typs in Beziehung setzt, als <i>Stufe bezeichnen</i> . Beispielsweise haben die Token ‚Äûeinhundert‚Äú und ‚Äûdreihundert‚Äú eine Stufe und sind gr√∂√üer als die Marke ‚Äûf√ºnfzig‚Äú. </p><br><p>  Aus diesen √úberlegungen entsteht die Idee eines Algorithmus.  Schreiben wir alle m√∂glichen Token ( <i>Samples</i> ) auf, denen wir jeweils eine Zahl zuweisen, sowie zwei Parameter - den Pegel und das Vorzeichen des Multiplikators. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token </th><th>  Nummer </th><th>  Level </th><th>  Multiplikator? </th></tr><tr><td>  Null <br></td><td>  0 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  Single / Single <br></td><td>  1 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  zwei / zwei <br></td><td>  2 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  neunzehn <br></td><td>  19 <br></td><td>  1 <br></td><td>  Nein <br></td></tr><tr><td>  zwanzig <br></td><td>  20 <br></td><td>  2 <br></td><td>  Nein <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  2 <br></td><td>  Nein <br></td></tr><tr><td>  neunzig <br></td><td>  90 <br></td><td>  2 <br></td><td>  Nein <br></td></tr><tr><td>  einhundert <br></td><td>  100 <br></td><td>  3 <br></td><td>  Nein <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  3 <br></td><td>  Nein <br></td></tr><tr><td>  neunhundert <br></td><td>  900 <br></td><td>  3 <br></td><td>  Nein <br></td></tr><tr><td>  tausend / tausend / tausend <br></td><td>  1.000 <br></td><td>  4 <br></td><td>  ja <br></td></tr><tr><td>  Millionen / Millionen / Millionen <br></td><td>  1.000.000 <br></td><td>  5 <br></td><td>  ja <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td><td>  ja <br></td></tr><tr><td>  Billiarde / Billiarde / Billiarde <br></td><td>  1.000.000.000.000.000 <br></td><td>  8 <br></td><td>  ja <br></td></tr></tbody></table></div><br><p>  Sie k√∂nnen dieser Tabelle auch andere Token hinzuf√ºgen, auch f√ºr Fremdsprachen. Vergessen Sie jedoch nicht, dass in einigen L√§ndern eher ein langes als ein kurzes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Benennungssystem verwendet wird</a> . </p><br><p>  Fahren wir nun mit dem Parsen fort.  Wir erhalten vier Mengen: </p><br><ol><li>  <i>Globale Ebene</i> (globalLevel).  Zeigt den Pegel des letzten Multiplikators an.  Anfangs undefiniert und zur Kontrolle notwendig.  Wenn wir auf ein Multiplikator-Token sto√üen, dessen Pegel gr√∂√üer oder gleich dem globalen ist, ist dies ein Fehler. </li><li>  <i>Globaler Wert</i> (globalValue).  Der Gesamtaddierer, wobei das Ergebnis das Ergebnis der Multiplikation der lokalen Zahl und des Faktors ist. </li><li>  <i>Lokale Ebene</i> (localLevel).  Gibt an, welche Stufe der letzte Token hatte.  Anf√§nglich undefiniert, funktioniert √§hnlich wie auf globaler Ebene, wird jedoch nach der Ermittlung des Multiplikators zur√ºckgesetzt. </li><li>  <i>Lokaler Wert</i> (localValue)  Ein Nicht-Multiplikator-Token-Addierer, d.h.  Zahlen bis zu 999. </li></ol><br><p>  Der Algorithmus ist wie folgt: </p><br><ol><li>  Teilen Sie die Zeichenfolge mit dem regul√§ren "\ s +" in Token auf. </li><li>  Wir nehmen das n√§chste Token und erhalten Informationen dar√ºber aus dem Beispiel. </li><li>  Wenn es ein Multiplikator ist: <br><ul><li>  Wenn die globale Ebene festgelegt ist, stellen wir sicher, dass sie gr√∂√üer oder gleich der Ebene des Tokens ist.  Wenn nicht, ist dies ein Fehler, die Nummer ist falsch. </li><li>  Stellen Sie die globale Ebene auf die Ebene des aktuellen Tokens ein. </li><li>  Multiplizieren Sie den Wert des Tokens mit dem lokalen Wert und addieren Sie das Ergebnis zum globalen Wert. </li><li>  Wir l√∂schen den lokalen Wert und das Niveau. </li></ul></li><li>  Wenn dies kein Multiplikator ist: <br><ul><li>  Wenn die lokale Ebene festgelegt ist, stellen wir sicher, dass sie gr√∂√üer oder gleich der Ebene des Tokens ist.  Wenn nicht, ist dies ein Fehler, die Nummer ist falsch. </li><li>  Stellen Sie die lokale Ebene auf die Ebene des aktuellen Tokens ein. </li><li>  F√ºgen Sie den Token-Wert zum lokalen Wert hinzu. </li></ul></li><li>  Wir geben das Ergebnis als Summe der globalen und lokalen Werte zur√ºck. </li></ol><br><p>  Ein Arbeitsbeispiel f√ºr die Zahl "zwei Millionen zweihundertzw√∂lftausendeinhundertf√ºnfundachtzig". </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token <br></th><th>  globalLevel <br></th><th>  globalValue <br></th><th>  localLevel <br></th><th>  localValue <br></th></tr><tr><td></td><td>  - - <br></td><td>  - - <br></td><td>  - - <br></td><td>  - - <br></td></tr><tr><td>  zwei <br></td><td>  - - <br></td><td>  - - <br></td><td>  1 <br></td><td>  2 <br></td></tr><tr><td>  Millionen <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  - - <br></td><td>  - - <br></td></tr><tr><td>  zweihundert <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  3 <br></td><td>  200 <br></td></tr><tr><td>  zw√∂lf <br></td><td>  5 <br></td><td>  2.000.000 <br></td><td>  1 <br></td><td>  212 <br></td></tr><tr><td>  tausend <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  - - <br></td><td>  - - <br></td></tr><tr><td>  einhundert <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  3 <br></td><td>  100 <br></td></tr><tr><td>  achtzig <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  2 <br></td><td>  180 <br></td></tr><tr><td>  f√ºnf <br></td><td>  4 <br></td><td>  2.212.000 <br></td><td>  1 <br></td><td>  185 <br></td></tr></tbody></table></div><p>  Das Ergebnis ist 2.212.185. </p><br><h2>  Intelligentes Parsen </h2><br><p>  Dieser Algorithmus kann verwendet werden, um andere Vergleiche zu implementieren, und nicht nur zum Parsen von Zahlen. Aus diesem Grund werde ich versuchen, ihn genauer zu beschreiben. </p><br><p>  Mit dem Parsen der korrekt geschriebenen Nummer herausgefunden.  Lassen Sie uns nun dar√ºber nachdenken, welche Fehler auftreten k√∂nnen, wenn die durch OCR erhaltene Nummer falsch geschrieben wird.  Ich erw√§ge keine anderen Optionen, aber Sie k√∂nnen den Algorithmus f√ºr eine bestimmte Aufgabe √§ndern. </p><br><p>  Ich habe drei Arten von Fehlern identifiziert, auf die ich bei der Arbeit gesto√üen bin: </p><br><ol><li>  Ersetzen Sie Zeichen durch andere mit einem √§hnlichen Stil.  Zum Beispiel wird der Buchstabe "c" aus irgendeinem Grund durch "p" und "n" durch "und" ersetzt und umgekehrt.  Bei Verwendung der dritten Version von tesseract ist es m√∂glich, den Buchstaben ‚Äûo‚Äú durch Null zu ersetzen.  Diese Fehler sind spontan am h√§ufigsten und erfordern die Optimierung f√ºr eine bestimmte Erkennungsbibliothek.  Die Arbeitsprinzipien der Tesseract-Versionen 3 und 4 weisen also grundlegende Unterschiede auf, daher sind die Fehler dort unterschiedlich. <br></li><li>  Token zusammenf√ºhren.  W√∂rter k√∂nnen zusammengef√ºhrt werden (haben das Gegenteil noch nicht getroffen).  In Kombination mit dem ersten Fehler werden d√§monische Phrasen wie "doppelte Eins" generiert.  Versuchen wir auch solche Monster zu d√§monisieren. <br></li><li>  Rauschen - linke Zeichen und Phrasen im Text.  Leider kann im Moment wenig getan werden, aber es gibt eine Perspektive, wenn ausreichend signifikante Statistiken gesammelt werden. <br></li></ol><br><p>  Gleichzeitig √§ndert sich der oben beschriebene Parsing-Algorithmus fast nicht. Der Hauptunterschied besteht darin, die Zeichenfolge in Token zu zerlegen. </p><br><p>  Beginnen wir jedoch mit der Erfassung einiger Statistiken zur Verwendung von Buchstaben in Token.  Von den 33 Buchstaben der russischen Sprache werden nur 20 beim Schreiben nicht negativer Ganzzahlen verwendet. Nennen wir sie <i>gute Buchstaben</i> : </p><br> <code></code> <br> <br><p>  Die restlichen 13 werden als <i>schlechte Buchstaben bezeichnet</i> .  Die maximale Gr√∂√üe des Tokens betr√§gt 12 Zeichen (13 bei Z√§hlung bis Billiarde).  Teilzeichenfolgen, die l√§nger als dieser Wert sind, m√ºssen aufgeteilt werden. </p><br><p>  Um Zeichenfolgen und Token zu vergleichen, entschied ich mich f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Wagner-Fisher-Algorithmus</a> , obwohl ich ihn im Code den Namen Levenshtein nannte.  Ich ben√∂tige keine redaktionelle Anleitung, daher habe ich eine speicherfreundliche Version des Algorithmus implementiert.  Ich muss zugeben, dass sich die Implementierung dieses Algorithmus als schwieriger herausstellte als der Parser selbst. </p><br><p>  Ein kleines Bildungsprogramm: Die Levenshtein-Distanz ist ein Sonderfall des Wagner-Fisher-Algorithmus, wenn die Kosten f√ºr das Einf√ºgen, L√∂schen und Ersetzen von Zeichen statisch sind.  Dies ist bei unserer Aufgabe nicht der Fall.  Wenn wir einen schlechten Buchstaben in einem Teilstring finden, muss dieser nat√ºrlich durch einen guten Buchstaben ersetzt werden, aber das Ersetzen eines guten durch einen schlechten ist √§u√üerst unerw√ºnscht.  Im Allgemeinen ist es unm√∂glich, aber die Situation h√§ngt von der spezifischen Aufgabe ab. </p><br><p>  Um die Kosten f√ºr das Einf√ºgen, L√∂schen und Ersetzen von Zeichen zu beschreiben, habe ich eine Tabelle wie diese erstellt: einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zu einer Tabelle mit Gewichten</a> .  Es ist zwar mit der Drei-P-Methode (Geschlecht, Finger, Decke) gef√ºllt, aber wenn Sie es mit Daten f√ºllen, die auf OCR-Statistiken basieren, k√∂nnen Sie die Qualit√§t der Nummernerkennung erheblich verbessern.  Der Bibliothekscode enth√§lt die Ressourcendatei NumeralLevenshteinData.txt, in die Sie mit Strg + A, Strg + C und Strg + V Daten aus einer √§hnlichen Tabelle einf√ºgen k√∂nnen. </p><br><p>  Wenn im Text ein Nicht-Tabellenzeichen gefunden wird, z. B. Null, entsprechen die Kosten f√ºr das Einf√ºgen dem Maximalwert aus der Tabelle, und die Kosten f√ºr das L√∂schen und Ersetzen entsprechen dem Minimum. Daher ersetzt der Algorithmus mit gr√∂√üerer Wahrscheinlichkeit Null durch den Buchstaben ‚Äûo‚Äú, und wenn Sie die dritte Version von tesseract verwenden Dann ist es sinnvoll, der Tabelle Null hinzuzuf√ºgen und den Mindestpreis zu schreiben, um sie durch den Buchstaben ‚Äûo‚Äú zu ersetzen. </p><br><p>  Also haben wir die Daten f√ºr den Wagner-Fisher-Algorithmus vorbereitet. Nehmen wir √Ñnderungen am Algorithmus zum Aufteilen der Zeichenfolge in Token vor.  Zu diesem Zweck werden wir eine zus√§tzliche Analyse jedes Tokens durchf√ºhren. Zuvor werden wir jedoch die Informationen √ºber das Token mit den folgenden Merkmalen erweitern: </p><br><ul><li>  <i>Fehlerstufe</i> .  Eine reelle Zahl von 0 (kein Fehler) bis 1 (das Token ist falsch), was bedeutet, wie gut das Token mit der Stichprobe verglichen wurde. <br></li><li>  <i>Ein Zeichen f√ºr die Verwendung eines Tokens</i> .  Beim Parsen einer Zeichenfolge mit eingestreuten Tr√ºmmern wird ein Teil der Token verworfen, da dieses Attribut nicht festgelegt wird.  In diesem Fall wird der Gesamtfehlerwert als arithmetischer Durchschnitt der Fehler der verwendeten Token betrachtet. <br></li></ul><br><p>  Token-Analyse-Algorithmus: </p><br><ol><li>  Wir versuchen, das Token so wie es ist in der Tabelle zu finden.  Wenn wir finden - alles ist gut, geben Sie es zur√ºck. </li><li>  Wenn nicht, erstellen Sie eine Liste m√∂glicher Optionen: </li><li><p>  Wir versuchen, das Token mit dem Wagner-Fisher-Algorithmus mit dem Sample abzugleichen.  Diese Option besteht aus einem Token (zugeordnetes Sample) und sein Fehler entspricht dem besten Abstand geteilt durch die L√§nge des Samples. </p><br>  <b>Beispiel: Das</b> "Null" -Token wird mit dem "Null" -Sample verglichen, w√§hrend der Abstand 0,5 betr√§gt, weil  Die Kosten f√ºr das Ersetzen des schlechten Buchstabens "y" durch ein gutes "o" betragen 0,5.  Der Gesamtfehler f√ºr dieses Token betr√§gt 0,5 / 4 = 0,125. <br></li><li><p>  Wenn der Teilstring gro√ü genug ist (ich habe 6 Zeichen), versuchen wir, ihn in zwei Teile mit jeweils mindestens 3 Zeichen zu unterteilen.  F√ºr eine Zeichenfolge mit 6 Zeichen gibt es eine einzelne Unterteilung: 3 + 3 Zeichen.  F√ºr eine Zeichenfolge mit 7 Zeichen gibt es bereits zwei Optionen: 3 + 4 und 4 + 3 usw.  F√ºr jede der Optionen rufen wir dieselbe Tokenanalysefunktion rekursiv auf und geben die empfangenen Optionen in die Liste ein. </p><br><p>  Um nicht in Rekursion zu sterben, bestimmen wir die maximale Fehlerquote.  Dar√ºber hinaus werden die durch die Teilung erhaltenen Optionen um einen bestimmten Betrag k√ºnstlich verschlechtert (Option, standardm√§√üig 0,1), so dass die direkte Vergleichsoption wertvoller ist.  Ich musste diese Operation hinzuf√ºgen, weil  Teilschritte vom Typ "doppelt" wurden erfolgreich in die Token "zwei" und "f√ºnf" unterteilt und nicht auf "zwanzig" reduziert.  Leider sind dies die Merkmale der russischen Sprache. </p><br><p>  <b>Beispiel: Das</b> "doppelte" Token hat einen direkten Vergleich mit der "zwanzig" Stichprobe, Fehler 0,25.  Dar√ºber hinaus ist die beste Option zum Teilen ‚Äûzwei‚Äú + ‚Äûf√ºnf‚Äú mit Kosten von 0,25 (Ersetzen von ‚Äûa‚Äú durch ‚Äûi‚Äú), die k√ºnstlich auf 0,35 verschlechtert wurden, wodurch der Token ‚Äûzwanzig‚Äú bevorzugt wird. </p><br></li><li>  Nachdem wir alle Optionen zusammengestellt haben, w√§hlen wir die beste aus der minimalen Fehleranzahl der daran teilnehmenden Token aus.  Das Ergebnis wird zur√ºckgegeben. </li></ol><br><p>  Dar√ºber hinaus wird die Token-√úberpr√ºfung in den Algorithmus zur Generierung von Hauptnummern eingef√ºhrt, sodass deren Fehler einen bestimmten Wert nicht √ºberschreitet (Option, Standardwert 0,67).  Damit filtern wir potenziellen M√ºll aus, wenn auch nicht sehr erfolgreich. </p><br><h2>  Der Algorithmus auf den Punkt gebracht f√ºr diejenigen, die zu faul waren, um den obigen Text zu lesen </h2><br><p>  Wir teilen die Eingabezeichenfolge, bei der es sich um die Zahl in Worten handelt, unter Verwendung der Regelm√§√üigkeit \ s + in Teilzeichenfolgen auf. Anschlie√üend versuchen wir, jede Teilzeichenfolge mit Beispieltoken abzugleichen oder sie in kleinere Teilzeichenfolgen aufzuteilen, um die besten Ergebnisse zu erzielen.  Als Ergebnis erhalten wir eine Reihe von Token, mit denen wir eine Zahl generieren, und der Fehlerwert wird als arithmetisches Mittel der Fehler unter den in der Generierung verwendeten Token verwendet. </p><br><h2>  Sch√§rfen eines Algorithmus f√ºr eine bestimmte Aufgabe </h2><br><p>  In meiner Aufgabe sind die Zahlen nicht negativ und relativ klein, daher werde ich unn√∂tige Token von der "Million" und h√∂her ausschlie√üen.  F√ºr den Test, liebe Leser, habe ich im Gegenteil zus√§tzliche Jargon-Token hinzugef√ºgt, mit denen Zeichenfolgen wie ‚Äûf√ºnf Teile‚Äú, ‚Äûzweihundert m√§hen‚Äú und sogar ‚Äûdrei Stolniks und zwei Goldst√ºcke‚Äú analysiert werden konnten.  Es ist lustig, aber es waren nicht einmal √Ñnderungen am Algorithmus erforderlich. </p><br><h2>  Weitere Verbesserung </h2><br><p>  Der vorhandene Algorithmus weist folgende M√§ngel auf: </p><br><ol><li>  <b>Fallkontrolle.</b>  Die Zeichenfolgen "zweitausend" und "zweitausend" werden mit einem Fehler von Null als 2000 erkannt. In meiner Aufgabe ist keine Fallkontrolle erforderlich, sie ist sogar sch√§dlich. Wenn Sie jedoch eine solche Funktion ben√∂tigen, wird dies durch Einf√ºgen eines zus√§tzlichen Flags in das Token gel√∂st, das f√ºr den Fall des n√§chsten Tokens verantwortlich ist . <br></li><li>  <b>Negative Zahlen.</b>  Ein zus√§tzliches Minus-Token wird mit spezieller Verarbeitung eingef√ºhrt.  Nichts kompliziertes, aber vergessen Sie nicht, dass der Buchstabe ‚Äûy‚Äú schlecht ist und nicht in den Ziffern vorkommt. Sie m√ºssen seine Gewichtseigenschaften √§ndern oder hoffen, dass er sich w√§hrend des OCR-Prozesses nicht √§ndert. <br></li><li>  <b>Bruchzahlen.</b>  Es wird gel√∂st, indem der lange Typ durch einen doppelten Typ ersetzt und Token von "Zehntel", "Hundertstel" usw. eingef√ºhrt werden. Vergessen Sie nicht, die Buchstabenskala zu √ºberarbeiten. <br></li><li>  <b>Erkennung von von Benutzern eingegebenen Nummern.</b>  Weil  Bei der manuellen Eingabe von Text machen wir meistens Fehler im Zusammenhang mit der erneuten Bearbeitung von siVMolov. Sie sollten diese Operation zum Wagner-Fisher-Algorithmus hinzuf√ºgen. <br></li><li>  <b>Unterst√ºtzung f√ºr andere Sprachen.</b>  Wir f√ºhren neue Token ein und erweitern die Gewichtstabelle. <br></li><li>  <b>M√ºllabfuhr.</b>  In einigen Dokumenten werden Daten gedruckt, die Bildqualit√§t ist m√∂glicherweise schlecht, die Zelle ist m√∂glicherweise leer.  In diesem Fall gelangt M√ºll, der gereinigt werden muss, irgendwie in die Leitung.  Das Beste, was ich im Moment anbieten kann, ist, das Dokument vor der OCR vorzuverarbeiten.  Das Entfernen der Tabellenzeilen und das F√ºllen mit einer Farbe, die der Farbe des freien Raums der Zelle nahe kommt, hat mir sehr geholfen.  Dies l√∂ste nicht alle Probleme, verbesserte jedoch die Qualit√§t der Erkennung von Text aus Dokumenten, bei denen die Tabelle aufgrund von Bluterg√ºssen des Dokuments oder eines krummen Fotografen Kr√ºmmungen aufwies.  Idealerweise sollten Sie die Zelle selbst drehen und separat erkennen, wenn Sie nat√ºrlich √ºberhaupt einen Tisch haben. <br></li></ol><br><h1>  Was ist das Endergebnis? </h1><br><p>  Das Projekt enth√§lt ein Beispiel f√ºr eine Konsolenanwendung, die in der Datei samples.txt ausgef√ºhrt wird, mit Beispielen f√ºr den Parser.  Hier ist ein Screenshot der Ergebnisse: </p><br><img src="https://habrastorage.org/webt/fq/ed/ac/fqedacgduf7tewa8tvg-tn6zv3s.png"><br><br><p>  Ich fordere Sie auf, das Ergebnis zu bewerten, aber f√ºr mich ist es nicht schlecht.  Der Fehler f√ºr echte Erkennungsbeispiele √ºberschreitet nicht 0,25, obwohl ich noch nicht den gesamten Satz verf√ºgbarer Dokumente ausgef√ºhrt habe, wird dort wahrscheinlich nicht alles so reibungslos sein. </p><br><p>  Was den letzten Abschnitt betrifft, habe ich mich immer gefragt, wie sehr dies ‚ÄûDofiga‚Äú ist.  Au√üerdem gab sich das Programm eine angemessene Antwort darauf, wie viel es braucht (ich benutze es nicht, aber immer noch) und bestimmte sogar genau die Bedeutung des alten russischen Wortes "Dunkelheit".  Und ja, die Schlussfolgerung enthielt keine weitere Ma√ünahme, die die Bildung nicht hinzuf√ºgen durfte, aber das Programm geht davon aus, dass sie tausend entspricht =) </p><br><h1>  Ein paar Worte zur Bibliothek </h1><br><p>  Urspr√ºnglich war nicht geplant, eine Bibliothek zu erstellen. Ich beschloss, sie exklusiv f√ºr einen Habr zu entwerfen.  Ich habe versucht, den Code in Ordnung zu bringen, aber wenn Sie ihn verwenden, machen Sie eine Gabel oder eine Kopie, als  H√∂chstwahrscheinlich ben√∂tigen Sie keinen Jargon und keine anderen in den Beispielen enthaltenen Token. </p><br><p>  Die Bibliothek selbst ist unter .NET Standart 2.0 und C # 7.x geschrieben, und die Algorithmen k√∂nnen problemlos in andere Sprachen √ºbersetzt werden. </p><br><p>  Im Falle einer m√∂glichen Erweiterung der Bibliothek werde ich die Zusammensetzung der wichtigen Komponenten des Zahlenparsers in Worten hinzuf√ºgen (Genesis.CV.NumberUtils-Namespace): </p><br><ul><li>  RussianNumber.cs - direkter Parser </li><li>  RussianNumber.Data.cs - Datei mit Beschreibung der Token </li><li>  RussianNumber.ToString.cs - Konverter von Zahl zu Text in Worten </li><li>  RussianNumberParserOptions.cs - Parser-Optionen </li><li>  NumeralLevenshtein.cs - Implementierung des Wagner-Fisher-Algorithmus </li><li>  NumeralLevenshteinData.txt - Ressource, Daten zur Buchstabengewichtung </li></ul><br><p>  Verwendung: </p><br><ul><li>  RussianNumber.ToString (Wert) - Konvertiert eine Zahl in Text </li><li>  RussianNumber.Parse (Wert, [Optionen]) - Konvertiert Text in Zahl </li></ul><br><h1>  Fazit </h1><br><p>  Ich hoffe wirklich, dass Ihnen der Artikel trotz der F√ºlle an Texten nicht langweilig erschien.  In letzter Zeit habe ich viele Themen im Zusammenhang mit Computer Vision entwickelt, √ºber die es etwas zu erz√§hlen gibt. Daher w√ºrde ich gerne eine Meinung zu diesem Artikelformat erfahren.  Was ist es wert, hinzugef√ºgt oder umgekehrt entfernt zu werden?  Was ist f√ºr Sie, die Leser, die Algorithmen selbst oder die Codefragmente interessanter? </p><br><p>  Gef√§llt dir der Artikel?  Schauen Sie sich die anderen an: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse JavaScript Unterst√ºtzung der JavaScript-Serialisierung</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">F√ºllen von Textvorlagen mit modellbasierten Daten.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET-Implementierung mit IL-Funktionen (Dynamic Bytecode)</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453642/">https://habr.com/ru/post/de453642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453618/index.html">Wie wir mit Ideen arbeiten und wie LANBIX geboren wurde</a></li>
<li><a href="../de453622/index.html">G-Shield Chip Programmer: Schreiben digitaler Zertifikate auf Chips in der Produktionsphase</a></li>
<li><a href="../de453626/index.html">Abenteuer in einem separaten Stream. Yandex-Bericht</a></li>
<li><a href="../de453628/index.html">Wof√ºr wirst du in 20 Jahren bezahlen?</a></li>
<li><a href="../de453634/index.html">Alfa Bank School of System Analysis</a></li>
<li><a href="../de453644/index.html">Interview - 10 Fragen zu Swift. Teil 3</a></li>
<li><a href="../de453646/index.html">Normalisierung von Daten in einer verteilten Datenbank, Microservices und ERP</a></li>
<li><a href="../de453650/index.html">Softwarekern der On-Board-Cyber-Infrastruktur des einheitlichen Streikk√§mpfers F-35</a></li>
<li><a href="../de453652/index.html">LogRock: Testen durch Protokollierung</a></li>
<li><a href="../de453656/index.html">Statisches Web: Zur√ºck zu den Grundlagen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>