<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé≤ ü§¶ üéì Sobre [[trivial_abi]] em Clang üçÜ üòù üßôüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por fim, escrevi um post sobre [[trivial_abi]]! 

 Esse √© um novo recurso propriet√°rio no tronco Clang, novo em fevereiro de 2018. Esta √© uma extens√£o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sobre [[trivial_abi]] em Clang</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/">  Por fim, escrevi um post sobre [[trivial_abi]]! <br><br>  Esse √© um novo recurso propriet√°rio no tronco Clang, novo em fevereiro de 2018. Esta √© uma extens√£o de fornecedor da linguagem C ++, n√£o √© C ++ padr√£o, n√£o √© suportada pelo tronco GCC e n√£o h√° propostas ativas do WG21 para inclu√≠-lo no padr√£o C ++, tanto quanto eu sei. <br><br><img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br><br>  Eu n√£o participei da implementa√ß√£o desse recurso.  Apenas olhei para os remendos na lista de e-mails do commit e aplaudi silenciosamente para mim mesmo.  Mas esse √© um recurso t√£o interessante que acho que todo mundo deveria saber. <br><a name="habracut"></a><br>  Portanto, a primeira coisa que come√ßaremos: esse n√£o √© um atributo padr√£o, e o tronco Clang n√£o suporta a ortografia padr√£o do atributo [[trivial_abi]] para ele.  Em vez disso, voc√™ deve escrev√™-lo no estilo antigo, como mostrado abaixo: <br><br><pre><code class="cpp hljs">__attribute__((trivial_abi)) __attribute__((__trivial_abi__)) [[clang::trivial_abi]]</code> </pre> <br>  E, como esse √© um atributo, o compilador √© muito exigente sobre onde voc√™ o cola e passivamente agressivamente silencioso se voc√™ o cola no lugar errado (pois os atributos n√£o reconhecidos s√£o simplesmente ignorados sem mensagens).  Isso n√£o √© um bug, √© um recurso.  A sintaxe correta √© esta: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) class TRIVIAL_ABI Widget { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// ... };</span></span></span></span></code> </pre> <br><br><h3>  Que problema isso resolve? </h3><br><br>  Lembra da minha postagem em 17/04/2018, onde eu mostrei duas vers√µes da classe? <br><br><blockquote>  Nota  perev: Como o post de 17/04/2018 tem um pequeno volume, n√£o o publiquei separadamente, mas o inseri aqui embaixo do spoiler. <br></blockquote><div class="spoiler">  <b class="spoiler_title">post de 17/04/2018</b> <div class="spoiler_text"><h3>  Desvantagens da falta de chamada do trivial destruidor </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Consulte a lista de correspond√™ncia da proposta padr√£o do C ++.</a>  Qual das duas fun√ß√µes, foo ou bar, ter√° o melhor c√≥digo gerado pelo compilador? <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Integer() {} <span class="hljs-comment"><span class="hljs-comment">// deliberately non-trivial }; void foo(std::vector&lt;int&gt;&amp; v) { v.back() *= 0xDEADBEEF; v.pop_back(); } void bar(std::vector&lt;Integer&gt;&amp; v) { v.back().value *= 0xDEADBEEF; v.pop_back(); }</span></span></code> </pre><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compilando</a> com GCC e libstdc ++.  Adivinha certo? <br><br><pre> <code class="cpp hljs">foo: movq <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi), %rax imull $<span class="hljs-number"><span class="hljs-number">-559038737</span></span>, <span class="hljs-number"><span class="hljs-number">-4</span></span>(%rax), %edx subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, %rax movl %edx, (%rax) movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret bar: subq $<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) ret</code> </pre> <br><br>  Aqui est√° o que acontece aqui: O GCC √© inteligente o suficiente para entender que, quando um destruidor para uma √°rea de mem√≥ria √© iniciado, sua vida √∫til termina e todas as entradas anteriores nessa √°rea de mem√≥ria ficam "mortas".  Mas o GCC tamb√©m √© inteligente o suficiente para entender que um destruidor trivial (como o pseudo-destruidor ~ int ()) n√£o faz nada e n√£o produz efeitos. <br><br>  Portanto, a fun√ß√£o bar chama pop_back, que executa ~ Integer (), o que torna vec.back () morto, e o GCC remove completamente a multiplica√ß√£o por 0xDEADBEEF. <br><br>  Por outro lado, foo chama pop_back, que lan√ßa o pseudo-destruidor ~ int () (ele pode ignorar completamente a chamada, mas n√£o o faz), o GCC v√™ que est√° vazio e esquece.  Portanto, o GCC n√£o v√™ que vec.back () est√° morto e n√£o remove a multiplica√ß√£o por 0xDEADBEEF. <br><br>  Isso acontece para um destruidor trivial, mas n√£o para um pseudo-destruidor como ~ int ().  Substitua nosso ~ Integer () {} por ~ Integer () = padr√£o;  e veja como a instru√ß√£o original apareceu novamente! <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; ~Foo() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-comment"><span class="hljs-comment">// trivial }; struct Bar { int value; ~Bar() {} // deliberately non-trivial };</span></span></code> </pre> <br>  Nesse post, √© fornecido o c√≥digo no qual o compilador gerou o c√≥digo para Foo pior que para Bar.  Vale a pena discutir por que isso foi inesperado.  Os programadores esperam intuitivamente que o c√≥digo "trivial" seja melhor que o c√≥digo "n√£o trivial".  Este √© o caso na maioria das situa√ß√µes.  Em particular, este √© o caso quando fazemos uma chamada de fun√ß√£o ou retornamos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">incr</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">obj</span></span></span><span class="hljs-class">) {</span></span> obj.value += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; }</code> </pre> <br>  incr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compila</a> para o seguinte c√≥digo: <br><br><pre> <code class="cpp hljs">leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %eax retq</code> </pre> <br>  (leal √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comando</a> x86 que significa ‚Äúadicionar‚Äù.) Vemos que nosso objetivo de 4 bytes √© passado para incr no registro% edi e adicionamos 1 ao seu valor e o devolvemos a% eax.  Quatro bytes na entrada, quatro bytes na sa√≠da, f√°cil e simples. <br><br>  Agora vejamos incr (o caso de um destruidor n√£o trivial). <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rsi) movl %eax, (%rdi) movq %rdi, %rax retq</code> </pre> <br>  Aqui, obj n√£o √© passado no registro, apesar de aqui os mesmos 4 bytes com a mesma sem√¢ntica.  Aqui obj √© passado e retornado ao endere√ßo.  Aqui, o chamador reserva algum espa√ßo para o valor de retorno e nos passa um ponteiro para esse espa√ßo em rdi, e o chamador nos fornece um ponteiro para o valor de retorno obj no pr√≥ximo registro de argumentos% rsi.  Extra√≠mos o valor de (% rsi), adicionamos 1, salvamos de volta a (% rsi) para atualizar o valor de obj e depois copiamos (trivialmente) 4 bytes de obj no slot para o valor de retorno apontado por% rdi.  Por fim, copiamos o ponteiro original transmitido pelo chamador de% rdi para% rax, pois o documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ABI x86-64</a> (p. 22) nos diz para fazer isso. <br><br>  A raz√£o pela qual Bar √© t√£o diferente de Foo √© porque Bar tem um destruidor n√£o trivial e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ABI x86-64</a> (p. 19) especifica especificamente: <br><br><blockquote>  Se um objeto C ++ tiver um construtor de c√≥pia n√£o trivial ou um destruidor n√£o trivial, ele √© passado por um link invis√≠vel (o objeto √© substitu√≠do por um ponteiro na lista de par√¢metros) </blockquote><br>  Um documento posterior do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Itanium C ++ ABI</a> define o seguinte: <br><blockquote>  Se o tipo de par√¢metro n√£o for trivial para a finalidade da chamada, o chamador deve alocar um local tempor√°rio e passar um link para esse local tempor√°rio: <br>  [...] <br>  Um tipo √© considerado n√£o trivial para a finalidade da chamada se: <br><br>  Ele possui um construtor de c√≥pia n√£o trivial, um construtor em movimento, um destruidor ou todos os seus construtores em movimento e c√≥pia s√£o exclu√≠dos. </blockquote><br>  Ent√£o, isso explica tudo: a barra tem uma gera√ß√£o de c√≥digo pior porque √© passada por um link invis√≠vel.  √â transmitido atrav√©s de um link invis√≠vel desde que ocorreu uma combina√ß√£o infeliz de duas circunst√¢ncias independentes: <br><ul><li>  Documento da ABI diz que objetos com destruidor n√£o trivial s√£o passados ‚Äã‚Äãpor links invis√≠veis </li><li>  Bar tem um destruidor n√£o trivial. </li></ul><br>  Este √© um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">silogismo</a> cl√°ssico: o primeiro ponto √© a premissa principal, o segundo √© privado.  Como resultado, a barra √© transmitida atrav√©s de um link invis√≠vel. <br><br>  Que algu√©m nos d√™ um silogismo: <br><ul><li>  Todas as pessoas s√£o mortais </li><li>  S√≥crates √© um homem. </li><li>  Consequentemente, S√≥crates √© mortal. </li></ul><br><br>  Se queremos refutar a conclus√£o ‚ÄúS√≥crates √© mortal‚Äù, devemos refutar uma das premissas: refutar a coisa principal (talvez algumas pessoas n√£o sejam mortais) ou refutar o privado (talvez S√≥crates n√£o seja uma pessoa). <br><br>  Para que Bar seja passado em um registro (como Foo), devemos refutar uma das duas premissas.  O caminho C ++ padr√£o √© dar a Bar um destruidor trivial, destruindo a premissa particular.  Mas existe outro caminho! <br><br><h3>  Como [[trivial_abi]] resolve o problema </h3><br>  O novo atributo Clang destr√≥i a premissa principal.  Clang estende o documento ABI da seguinte maneira: <br><blockquote>  Se o tipo de par√¢metro n√£o for trivial para a finalidade da chamada, o chamador deve alocar um local tempor√°rio e passar um link para esse local tempor√°rio: <br>  [...] <br>  Um tipo √© considerado n√£o trivial para a finalidade da chamada se estiver marcado como [[trivial_abi]] e: <br>  Ele possui um construtor de c√≥pia n√£o trivial, um construtor em movimento, um destruidor ou todos os seus construtores em movimento e c√≥pia s√£o exclu√≠dos. <br></blockquote><br>  Mesmo que uma classe com um construtor ou destruidor m√≥vel n√£o trivial possa ser considerada trivial para o prop√≥sito da chamada, se estiver marcada como [[trivial_abi]]. <br><br>  Ent√£o agora, usando Clang, podemos escrever assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TRIVIAL_ABI __attribute__((trivial_abi)) struct TRIVIAL_ABI Baz { int value; ~Baz() {} </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// deliberately non-trivial };</span></span></span></span></code> </pre> <br>  compile incr &lt;Baz&gt; e obtenha o mesmo c√≥digo que incr &lt;Foo&gt;! <br><h3>  Aviso n¬∫ 1: [[trivial_abi]] √†s vezes n√£o faz nada </h3><br>  Eu espero que possamos criar inv√≥lucros "triviais para fins de chamada" sobre tipos de biblioteca padr√£o, como este: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trivial_unique_ptr</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;T, D&gt;::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>; };</code> </pre> <br>  Infelizmente, isso n√£o funciona.  Se a sua classe tiver alguma classe base ou campos n√£o est√°ticos "n√£o triviais para a finalidade da chamada", a extens√£o Clang na forma em que foi gravada agora tornar√° sua classe "irreversivelmente n√£o trivial" e o atributo n√£o ter√° efeito.  (Nenhuma mensagem de diagn√≥stico √© emitida. Isso significa que voc√™ pode usar [[trivial_abi]] no modelo de classe como um atributo opcional, e a classe ser√° "condicionalmente trivial", o que √†s vezes √© √∫til. A desvantagem, √© claro, √© que voc√™ pode marque a classe como trivial e descubra que o compilador a corrigiu silenciosamente.) <br><br>  O atributo ser√° ignorado sem mensagens se sua classe tiver uma classe base virtual ou fun√ß√µes virtuais.  Nesses casos, pode n√£o caber nos registros e n√£o sei o que voc√™ deseja obter, passando por valor, mas voc√™ provavelmente sabe. <br><br>  Ent√£o, at√© onde eu sei, a √∫nica maneira de usar o TRIVIAL_ABI para "tipos utilit√°rios padr√£o", como opcional &lt;T&gt;, unique_ptr &lt;T&gt; e shared_ptr &lt;T&gt;, √© <br><ul><li>  implement√°-los voc√™ mesmo do zero e aplicar o atributo ou </li><li>  entre na sua c√≥pia local da libc ++ e insira o atributo l√° com suas m√£os </li></ul><br>  (no mundo do c√≥digo aberto, os dois m√©todos s√£o essencialmente os mesmos) <br><br><h3>  Aviso # 2: responsabilidade do destruidor </h3><br>  No exemplo com Foo / Bar, a classe possui um destruidor vazio.  Deixe nossa classe realmente ter um destruidor n√£o trivial. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Up1</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } ~Up1() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"destroyed"</span></span>); } };</code> </pre> <br>  Isso deve ser familiar para voc√™, isso √© unique_ptr &lt;int&gt;, simplificado at√© o limite, com a impress√£o de uma mensagem quando exclu√≠da. <br><br>  Sem TRIVIAL_ABI, o incr &lt;Up1&gt; se parece com o incr &lt;Bar&gt;: <br><br><pre> <code class="cpp hljs">movl (%rsi), %eax addl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %eax movl %eax, (%rdi) movl $<span class="hljs-number"><span class="hljs-number">0</span></span>, (%rsi) movq %rdi, %rax retq</code> </pre> <br><br>  Com TRIVIAL_ABI, incr parece <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">maior e mais assustador</a> ! <br><br><pre> <code class="cpp hljs">pushq %rbx leal <span class="hljs-number"><span class="hljs-number">1</span></span>(%rdi), %ebx movl $.L.str, %edi callq <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span> movl %ebx, %eax popq %rbx retq</code> </pre> <br><br>  Na conven√ß√£o de chamada tradicional, tipos com um destruidor n√£o trivial s√£o sempre transmitidos por um link invis√≠vel, o que significa que o lado receptor (neste caso, incr) sempre aceita um ponteiro para um objeto de par√¢metro sem possuir esse objeto.  O objeto pertence ao chamador, o que faz o trabalho de elision funcionar! <br><br>  Quando um tipo com [[trivial_abi]] √© passado em registradores, essencialmente fazemos uma c√≥pia do objeto de par√¢metro. <br><br>  Como o x86-64 possui apenas um registro para retornar (aplausos), a fun√ß√£o chamada n√£o tem como retornar o objeto no final.  A fun√ß√£o chamada deve se apropriar do objeto que passamos para ele!  Isso significa que a fun√ß√£o chamada deve chamar o destruidor do objeto de par√¢metro quando terminar. <br><br>  No exemplo anterior, Foo / Bar / Baz, o destruidor √© chamado, mas estava vazio e n√£o percebemos.  Agora, no incr &lt;Up2&gt;, vemos o c√≥digo adicional gerado pelo destruidor no lado da fun√ß√£o chamada. <br><br>  Pode-se supor que esse c√≥digo adicional possa ser gerado em alguns casos de usu√°rio.  Mas, pelo contr√°rio, a chamada do destruidor n√£o aparece em lugar algum!  √â chamado incr, porque n√£o √© chamado na fun√ß√£o de chamada.  E, em geral, pre√ßo e benef√≠cios ser√£o equilibrados. <br><br><h3>  Aviso n¬∫ 3: ordem do destruidor </h3><br>  O destruidor de um par√¢metro com uma ABI trivial ser√° chamado pela fun√ß√£o chamada, e n√£o a chamada (aviso n¬∫ 2).  Richard Smith aponta que isso significa que ele n√£o ser√° chamado na ordem em que os destruidores dos outros par√¢metros est√£o localizados. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">alpha</span></span></span><span class="hljs-class"> {</span></span> alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha constructed"</span></span>); } ~alpha() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"alpha destroyed"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">beta</span></span></span><span class="hljs-class"> {</span></span> beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta constructed"</span></span>); } ~beta() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"beta destroyed"</span></span>); } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alpha, beta)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo(alpha{}, beta{}); }</code> </pre> <br>  Este c√≥digo imprime: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed alpha destroyed beta destroyed</code> </pre> <br>  quando TRIVIAL_ABI √© definido como [[clang :: trivial_abi]], ele imprime: <br><br><pre> <code class="cpp hljs">alpha constructed beta constructed beta destroyed alpha destroyed</code> </pre> <br><h3>  Relacionamento com um objeto "trivialmente reloc√°vel" / "mover-relocalizado" </h3><br>  Sem rela√ß√£o ... hein? <br><br>  Como voc√™ pode ver, n√£o h√° requisitos para a classe [[trivial_abi]] ter sem√¢ntica espec√≠fica para o construtor em movimento, destruidor ou construtor padr√£o.  Qualquer classe em particular provavelmente ser√° trivialmente reloc√°vel, simplesmente porque a maioria das classes √© trivialmente reloc√°vel. <br><br>  Podemos simplesmente criar a classe offset_ptr para que n√£o seja trivialmente reloc√°vel: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TRIVIAL_ABI</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset_ptr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span> value_; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: offset_ptr(T *p) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)p - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} offset_ptr(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) {} <span class="hljs-function"><span class="hljs-function">T *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (T *)((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> + value_); } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> offset_ptr&amp; rhs) { value_ = ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)rhs.get() - (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } offset_ptr&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> diff) { value_ += (diff * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> (T)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ offset_ptr&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; top = &amp;a[<span class="hljs-number"><span class="hljs-number">4</span></span>]; top = incr(top); assert(top.get() == &amp;a[<span class="hljs-number"><span class="hljs-number">5</span></span>]); }</code> </pre> <br>  <a href="">Aqui est√° o c√≥digo completo.</a> <br>  Quando TRIVIAL_ABI √© definido, o tronco Clang passa neste teste em -O0 e -O1, mas em -O2 (ou seja, assim que tenta alinhar chamadas para trivial_offset_ptr :: operator + = e o construtor de c√≥pia), ele falha na afirma√ß√£o. <br><br>  Ent√£o, mais um aviso.  Se o seu tipo faz algo t√£o louco com esse ponteiro, voc√™ provavelmente n√£o vai querer pass√°-lo nos registros. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bug 37319</a> , de fato, um pedido de documenta√ß√£o.  Nesse caso, verifica-se que n√£o h√° como fazer o c√≥digo funcionar da maneira que o programador deseja.  Dizemos que o valor de value_ deve depender do valor deste ponteiro, mas na fronteira entre a chamada e as fun√ß√µes chamadas, o objeto est√° nos registradores e o ponteiro para ele n√£o existe!  Portanto, a fun√ß√£o de chamada grava na mem√≥ria e passa o ponteiro this novamente, e como a fun√ß√£o chamada deve calcular o valor correto para grav√°-lo no valor_?  Talvez seja melhor perguntar como isso funciona em -O0?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Este c√≥digo n√£o deve funcionar.</a> <br><br>  Portanto, se voc√™ quiser usar [[trivial_abi]], evite fun√ß√µes-membro (n√£o apenas especiais, mas qualquer) que dependem muito do endere√ßo do pr√≥prio objeto (com algum significado indefinido da palavra "essencial"). <br><br>  Intuitivamente, quando uma classe √© marcada como [[trivial_abi]], sempre que voc√™ espera copiar, voc√™ pode obter c√≥pia mais memcpy.  Da mesma forma, quando voc√™ espera uma mudan√ßa, pode obter a mudan√ßa mais o memcpy. <br><br>  Quando um tipo √© "trivialmente reloc√°vel" (como definido por mim no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++ agora</a> ), a qualquer momento que voc√™ espera copiar e destruir, √© poss√≠vel obter o memcpy.  E da mesma forma, quando voc√™ espera deslocamento e destrui√ß√£o, pode realmente obter memcpy.  De fato, chamadas para fun√ß√µes especiais ser√£o perdidas se falarmos sobre "realoca√ß√£o trivial", mas quando a classe tiver o atributo [[trivial_abi]] de Clang, as chamadas n√£o ser√£o perdidas.  Voc√™ acabou de receber (por assim dizer) o memcpy, al√©m das chamadas que esperava.  Esse (tipo de) memcpy √© o pre√ßo que voc√™ paga por uma conven√ß√£o de registro de chamadas mais r√°pida. <br><br><h3>  Links para leitura adicional: </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">T√≥pico cfe-dev de Akira Hatanaka de novembro de 2017</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documenta√ß√£o oficial do Clang</a> <br>  <a href="">A unidade testa trivial_abi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bug 37319: trivial_offset_ptr n√£o pode funcionar</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468759/">https://habr.com/ru/post/pt468759/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468741/index.html">Internet na cidade inteligente</a></li>
<li><a href="../pt468747/index.html">Como passei o ver√£o na VK</a></li>
<li><a href="../pt468749/index.html">Eventos do Android LiveData</a></li>
<li><a href="../pt468753/index.html">Dalt√¥nico - amigo do homem (o Minist√©rio da Sa√∫de n√£o est√° certo)</a></li>
<li><a href="../pt468757/index.html">Conex√£o MySQL ap√≥s o erro 1040: muitas conex√µes</a></li>
<li><a href="../pt468761/index.html">Solu√ß√£o de problemas com pwnable.kr 24 - login simples. Sobreposi√ß√£o de quadro de pilha</a></li>
<li><a href="../pt468765/index.html">A import√¢ncia de confirmar comandos de controle usando o Delimobile como exemplo</a></li>
<li><a href="../pt468767/index.html">Brinquedos de madeira, parte dois - 1986-1988</a></li>
<li><a href="../pt468769/index.html">Xavier Noria no Rails 6, consultoria e muito mais</a></li>
<li><a href="../pt468773/index.html">Empresa de energia indiana NTPC para construir um parque solar de 5.000 megawatts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>