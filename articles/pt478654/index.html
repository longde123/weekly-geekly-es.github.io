<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöØ üë©üèæ‚Äçüç≥ üë©üèø‚Äçüé§ Contagem estimada de distribui√ß√£o - na maioria das vezes reinventou a classifica√ß√£o ü§∑üèæ üÜë üçÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O n√∫mero de tipos mais ou menos diferentes um do outro √© garantido em mais de cem. Entre eles, existem subgrupos de algoritmos que s√£o minimamente dif...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contagem estimada de distribui√ß√£o - na maioria das vezes reinventou a classifica√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/478654/"> <a href="https://habr.com/ru/company/edison/blog/478654/"><img align="left" width="280" height="430" src="https://habrastorage.org/webt/sd/nz/sa/sdnzsaij33eps-i9dygobdrznxe.png"></a> <br clear="right">  O n√∫mero de tipos mais ou menos diferentes um do outro √© garantido em mais de cem.  Entre eles, existem subgrupos de algoritmos que s√£o minimamente diferentes um do outro, coincidindo em alguma id√©ia principal geral.  De fato, em anos diferentes, pessoas diferentes criam as mesmas classifica√ß√µes novamente, diferindo em detalhes n√£o muito fundamentais. <br><br>  Essa ideia algor√≠tmica √© encontrada com mais frequ√™ncia do que outras. <br><br>  Cada elemento √© inserido <i>aproximadamente no local da</i> matriz em que deve estar localizado.  Acontece uma matriz <i>quase ordenada</i> .  √Ä qual a classifica√ß√£o por inser√ß√µes √© aplicada (√© mais eficaz para o processamento de matrizes quase ordenadas) ou √°reas n√£o ordenadas locais s√£o processadas recursivamente pelo mesmo algoritmo. <a name="habracut"></a><br><br><blockquote> <a href="https://www.edsd.ru/" title="EDISON Software - desenvolvimento web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - desenvolvimento web"></a> <br clear="right">  Este artigo foi escrito com o apoio da EDISON, que desenvolve uma ampla gama de solu√ß√µes para uma variedade de tarefas: desde <a href="https://www.edsd.ru/virtualnaya-primerochnaya">programas para experimenta√ß√£o online de roupas de lojas multimarcas</a> at√© um <a href="https://www.edsd.ru/peredacha-dannyh-s-pomoshhyu-svetodioda">sistema de transmiss√£o de LED entre embarca√ß√µes fluviais e mar√≠timas</a> . <br><br>  Adoramos a teoria dos algoritmos!  ;-) </blockquote>  Para avaliar aproximadamente onde voc√™ deseja colocar o elemento, √© necess√°rio descobrir o quanto ele difere do elemento m√©dio da matriz.  Para fazer isso, voc√™ precisa conhecer os valores dos elementos m√≠nimo e m√°ximo e o tamanho da matriz. <br><br>  A matriz classificada deve ter dados realmente aleat√≥rios.  Todos os inventores deste m√©todo v√™m com a mesma f√≥rmula: <br><br><div style="text-align:center;"><img width="460" height="81" src="https://habrastorage.org/webt/ik/qi/gt/ikqigtqyoqd41k5z3mfrjiwqwey.png"></div><br>  <b>k</b> √© o local aproximado da matriz em que o elemento <b>A</b> ( <b>i</b> ) deve ser <br>  <b>min</b> , <b>max</b> - valores dos elementos m√≠nimo e m√°ximo na matriz <b>A</b> <br>  <b>Tamanho</b> - o n√∫mero de elementos na matriz <b>A</b> <br><br>  Aqui est√° uma ideia t√£o geral.  Vamos ver em quais varia√ß√µes esse algoritmo nasceu v√°rias vezes. <br><br><h2>  Classifica√ß√£o Rei Salom√£o :: Ordem Salom√£o </h2><br><div style="text-align:center;"><img width="608" height="294" src="https://habrastorage.org/webt/ds/ry/ga/dsrygazdx_xtt2hwbvvwjhd0bbo.gif"></div><br>  Este m√©todo (e seu belo nome) foi <a href="https://habr.com/ru/post/208088/">proposto pelo</a> usu√°rio do <a href="https://habr.com/ru/users/v2008n/" class="user_link">V2008n h√°</a> cerca de 5 anos.  Tudo tem seu tempo, ‚Äúo tempo de espalhar pedras e o tempo de coletar pedras‚Äù (as palavras do rei Salom√£o do livro de Eclesiastes) - e no algoritmo, √© exatamente isso que acontece.  Primeiro, com a ajuda da f√≥rmula, dispersamos os elementos nos locais desejados na matriz.  Como a f√≥rmula fornece um lugar n√£o exato, mas aproximado, v√°rios elementos que se aproximam em valor reivindicam algumas posi√ß√µes ao mesmo tempo.  Esses grupos de elementos locais s√£o classificados por inser√ß√µes e depois montados na ordem final. <br><br><h2>  Classifica√ß√£o de interpola√ß√£o </h2><br>  "N√£o h√° nada novo sob o sol", para citar o mesmo autor novamente.  A Wikipedia descreve a classifica√ß√£o por interpola√ß√£o, reminiscentemente suspeita da classifica√ß√£o de Salom√£o.  Cada "pilha de pedras" √© uma pequena matriz din√¢mica adicional, onde est√£o localizados elementos de import√¢ncia semelhante.  A principal diferen√ßa √© que, ap√≥s a ‚Äúdispers√£o de pedras‚Äù, esses grupos locais de elementos n√£o classificados s√£o classificados n√£o por inser√ß√µes, mas pela classifica√ß√£o por interpola√ß√£o (recursivamente ou em loop). <br><br>  Uma matriz ordenada √© um conjunto de dados discreto que pode ser considerado como um conjunto finito de valores conhecidos de uma determinada fun√ß√£o desconhecida.  Na verdade, uma distribui√ß√£o aproximada do ponto de vista da matem√°tica computacional - isso √© interpola√ß√£o. <br><br><div class="spoiler">  <b class="spoiler_title">Classifica√ß√£o de interpola√ß√£o JavaScript - loopback</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.interpolationSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> divideSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; divideSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] = end; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(divideSize.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {divide(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = divideSize.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = end - size; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i] &lt; min) { min = A[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(A[i] &gt; max) {max = A[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(min == max) { end = end - size; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bucket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>();} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { p = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bucket[p].push(A[i]); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bucket[i].length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; bucket[i].length; j++) {A[start++] = bucket[i][j];} divideSize.push(bucket[i].length); } } } } };</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Classifica√ß√£o de interpola√ß√£o JavaScript - vers√£o recursiva</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.bucketSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(min != max) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bucket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) {bucket[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>();} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpolation = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++){ interpolation = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); bucket[interpolation].push(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(bucket[i].length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) {bucket[i].bucketSort();} <span class="hljs-comment"><span class="hljs-comment">//Recursion for(var j = 0; j &lt; bucket[i].length; j++) {this[start++] = bucket[i][j];} } } };</span></span></code> </pre> </div></div><br><h3>  Classifica√ß√£o de histograma :: Classifica√ß√£o de histograma </h3><br>  Essa √© uma otimiza√ß√£o da classifica√ß√£o por interpola√ß√£o, que conta o n√∫mero de elementos pertencentes a grupos n√£o classificados locais.  Essa contagem permite inserir itens n√£o classificados diretamente na matriz resultante (em vez de agrup√°-los em pequenas matrizes separadas). <br><br><div class="spoiler">  <b class="spoiler_title">Classifica√ß√£o da barra JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.histogramSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sortedArray = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> interpolation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hitCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> divideSize = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(); divideSize[<span class="hljs-number"><span class="hljs-number">0</span></span>] = end; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(divideSize.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) {distribute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distribute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">A</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = divideSize.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = end - size; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = A[start]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start + <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &lt; min) { min = A[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (A[i] &gt; max) {max = A[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (min == max) { end = end - size; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++){hitCount[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { interpolation[i] = start + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((A[i] - min) / (max - min)) * (size - <span class="hljs-number"><span class="hljs-number">1</span></span>)); hitCount[interpolation[i]]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hitCount[i] &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){divideSize.push(hitCount[i]);} } hitCount[end - <span class="hljs-number"><span class="hljs-number">1</span></span>] = end - hitCount[end - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = end - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; start; i--) { hitCount[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = hitCount[i] - hitCount[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) { sortedArray[hitCount[interpolation[i]]] = A[i]; hitCount[interpolation[i]]++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) {A[i] = sortedArray[i];} } } };</code> </pre> </div></div><br><h3>  Classifica√ß√£o de tag de interpola√ß√£o </h3><br>  Para otimizar ainda mais a sobrecarga, √© proposto aqui n√£o lembrar o n√∫mero de elementos de import√¢ncia semelhante em grupos n√£o classificados, mas simplesmente marcar o in√≠cio desses grupos com sinalizadores Verdadeiro / Falso.  True significa que o subgrupo j√° est√° classificado e False significa que ainda n√£o est√°. <br><br><div class="spoiler">  <b class="spoiler_title">Classifica√ß√£o de interpola√ß√£o marcada com JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.InterpolaionTagSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(end &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Tag = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-comment"><span class="hljs-comment">//Algorithm step-1 for(var i = 0; i &lt; end; i++) {Tag[i] = false;} Divide(this); } //Algorithm step-2 while(end &gt; 1) { while(Tag[--start] == false){} //Find the next bucket's start Divide(this); } function Divide(A) { var min = A[start]; var max = A[start]; for(var i = start + 1; i &lt; end; i++) { if(A[i] &lt; min) { min = A[i]; } else { if(A[i] &gt; max ) {max = A[i];} } } if(min == max) { end = start; } else { //Algorithm step-3 Start to be the next bucket's end var interpolation = 0; var size = end - start; var Bucket = new Array(size);//Algorithm step-4 for(var i = 0; i &lt; size; i++) {Bucket[i] = new Array();} for(var i = start; i &lt; end; i++) { interpolation = Math.floor(((A[i] - min) / (max - min)) * (size - 1)); Bucket[interpolation].push(A[i]); } for(var i = 0; i &lt; size; i++) { if(Bucket[i].length &gt; 0) {//Algorithm step-5 Tag[start] = true; for(var j = 0; j &lt; Bucket[i].length; j++) {A[start++] = Bucket[i][j];} } } } }//Algorithm step-6 };</span></span></code> </pre> </div></div><br><h3>  Classifica√ß√£o de tag de interpola√ß√£o (no local) </h3><br>  Se os valores dos elementos na matriz n√£o forem repetidos e distribu√≠dos uniformemente (grosso modo - se os dados na forma classificada forem algo como uma progress√£o aritm√©tica), voc√™ poder√° classificar em uma passagem, classificando no lugar certo, sem mover os elementos para matrizes intermedi√°rias. <br><br><div class="spoiler">  <b class="spoiler_title">Classificar por interpola√ß√£o com r√≥tulos (no local) em JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.InPlaceTagSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Tag = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(n); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) {Tag[i] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(Tag[i] == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { p = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(((<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] - min) / (max - min)) * (n - <span class="hljs-number"><span class="hljs-number">1</span></span>)); temp = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[p]; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[p] = temp; Tag[p] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } };</code> </pre> </div></div><br><h2>  Classifica√ß√£o do Flash :: Flashsort </h2><br>  Uma vez, <a href="https://habr.com/ru/post/195968/">escrevi</a> sobre sele√ß√£o, que foi inventada pelo professor de biof√≠sica Neubert em 1998. <br><br>  O professor sugeriu distribuir os elementos em v√°rias classes separadas (a participa√ß√£o na classe √© determinada pelo tamanho do elemento).  Com isso em mente, a f√≥rmula fica assim: <br><br><div style="text-align:center;"><img width="408" height="68" src="https://habrastorage.org/webt/t4/m0/35/t4m0350wkzaul4zp1xy6eoturik.png"></div><br>  Em vez de Tamanho (tamanho da matriz), a f√≥rmula indica <b>m</b> - o n√∫mero de classes pelas quais distribu√≠mos os elementos da matriz.  A f√≥rmula n√£o calcula a chave na matriz em que o elemento deve ser lan√ßado, mas o n√∫mero da classe √† qual o elemento pertence. <br><br>  Essa classifica√ß√£o n√£o √© ruim, pois √© mais econ√¥mica em termos de mem√≥ria adicional.  A redistribui√ß√£o de elementos ocorre no local.  Somente a localiza√ß√£o de classes √© armazenada separadamente (bem, se voc√™ olhar de um √¢ngulo diferente, o n√∫mero de elementos pertencentes a uma classe espec√≠fica √© armazenado separadamente). <br><br>  Bem, o resto √© a mesma m√∫sica. <br><br><div style="text-align:center;"><img width="684" height="190" src="https://habrastorage.org/webt/i_/4i/h0/i_4ih0amqa60afawupd2mykc4wo.gif"></div><br><div class="spoiler">  <b class="spoiler_title">Classifica√ß√£o Flash em Java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/** * FlashSort.java - integer version * Translation of Karl-Dietrich Neubert's algorithm into Java by * Rosanne Zhang */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FlashSort</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] a; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] l; <span class="hljs-comment"><span class="hljs-comment">/* constructor @param size of the array to be sorted */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flashSort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span><span class="hljs-function"> </span></span>{ n = size; generateRandomArray(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> start = System.currentTimeMillis(); partialFlashSort(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> mid = System.currentTimeMillis(); insertionSort(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> end = System.currentTimeMillis(); <span class="hljs-comment"><span class="hljs-comment">// print the time result System.out.println("Partial flash sort time : " + (mid - start)); System.out.println("Straight insertion sort time: " + (end - mid)); } /* Entry point */ public static void main(String[] args) { int size = 0; if (args.length == 0) { usage(); System.exit(1); } try { size = Integer.parseInt(args[0]); } catch (NumberFormatException nfe) { usage(); System.exit(1); } FlashSort.flashSort(size); } /* Print usage */ private static void usage() { System.out.println(); System.out.println("Usage: java FlashSort n "); System.out.println(" n is size of array to sort"); } /* Generate the random array */ private static void generateRandomArray() { a = new int[n]; for(int i=0; i &lt; n; i++) { a[i] = (int)(Math.random() * 5 * n); } m = n / 20; l = new int[m]; } /* Partial flash sort */ private static void partialFlashSort() { int i = 0, j = 0, k = 0; int anmin = a[0]; int nmax = 0; for(i=1; i &lt; n; i++) { if (a[i] &lt; anmin) anmin=a[i]; if (a[i] &gt; a[nmax]) nmax=i; } if(anmin == a[nmax]) return; double c1 = ((double)m - 1) / (a[nmax] - anmin); for(i=0; i &lt; n; i++) { k= (int) (c1 * (a[i] - anmin)); l[k]++; } for(k=1; k &lt; m; k++) { l[k] += l[k - 1]; } int hold = a[nmax]; a[nmax] = a[0]; a[0] = hold; int nmove = 0; int flash; j = 0; k = m - 1; while(nmove &lt; n - 1) { while(j &gt; (l[k] - 1)) { j++; k = (int) (c1 * (a[j] - anmin)); } flash = a[j]; while(!(j == l[k])) { k = (int) (c1 * (flash - anmin)); hold = a[l[k] - 1]; a[l[k] - 1] = flash; flash = hold; l[k]--; nmove++; } } } /* Straight insertion sort */ private static void insertionSort() { int i, j, hold; for(i = a.length - 3; i &gt;= 0; i--) { if(a[i + 1] &lt; a[i]) { hold = a[i]; j = i; while (a[j + 1] &lt; hold) { a[j] = a[j + 1]; j++; } a[j] = hold; } } } /* For checking sorting result and the distribution */ private static void printArray(int[] ary) { for(int i=0; i &lt; ary.length; i++) { if((i + 1) % 10 ==0) { System.out.println(ary[i]); } else { System.out.print(ary[i] + " "); } System.out.println(); } } }</span></span></code> </pre> </div></div><br><h2>  Classifica√ß√£o aproximada :: classifica√ß√£o do Proxmap </h2><br>  Essa classifica√ß√£o √© a mais antiga dentre as mencionadas aqui; foi introduzida em 1980 pelo professor Thomas Standish, da Universidade da Calif√≥rnia.  Na apar√™ncia, parece ser significativamente diferente, mas se voc√™ olhar de perto, tudo ser√° o mesmo. <br><br>  O algoritmo opera com um conceito como um <b>acerto</b> - um determinado n√∫mero que √© pr√≥ximo em valor a algum elemento da matriz. <br>  Para determinar se um elemento da matriz √© um acerto, uma <b>fun√ß√£o aproximada</b> √© aplicada ao elemento. <br><br>  O professor Standish classificou matrizes de n√∫meros reais.  A fun√ß√£o de aproxima√ß√£o era arredondar para baixo os n√∫meros reais para um n√∫mero inteiro. <br>  Ou seja, por exemplo, se a matriz contiver elementos 2.8, 2, 2.1, 2.6 etc.  ent√£o uma batida para esses n√∫meros ser√° deuce. <br><br><div style="text-align:center;"><img width="619" height="389" src="https://habrastorage.org/webt/-o/i_/cc/-oi_ccg-cbvv2pxdb9cb2-fbdpg.gif"></div><br><br>  Procedimento geral: <br><br><ol><li>  Aplicamos uma fun√ß√£o aproximada a cada elemento, determinando qual ocorr√™ncia corresponde ao pr√≥ximo elemento. </li><li>  Assim, para cada ocorr√™ncia, podemos calcular o n√∫mero de elementos correspondentes a essa ocorr√™ncia. </li><li>  Sabendo o n√∫mero de elementos para todos os hits, determinamos a localiza√ß√£o dos hits (bordas √† esquerda) na matriz. </li><li>  Conhecendo a localiza√ß√£o dos hits, determinamos a localiza√ß√£o de cada elemento. </li><li>  Depois de determinar a localiza√ß√£o do elemento, tentamos inseri-lo em seu lugar na matriz.  Se o local j√° estiver ocupado, movemos os vizinhos para a direita (se o elemento for menor que eles) para abrir espa√ßo para o elemento.  Ou, √† direita, inserimos o pr√≥prio elemento (se for mais que vizinho). </li></ol><br>  Como uma fun√ß√£o de aproxima√ß√£o, voc√™ pode atribuir qualquer um com base na natureza geral dos dados na matriz.  Nas implementa√ß√µes modernas dessa classifica√ß√£o, as ocorr√™ncias geralmente s√£o determinadas n√£o mordiscando a parte fracion√°ria, mas usando nossa f√≥rmula favorita. <br><br><div class="spoiler">  <b class="spoiler_title">Classifica√ß√£o por aproxima√ß√£o do JavaScript</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.ProxmapSort = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> end = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.length; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> A2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MapKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hitCount = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(end); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start; i &lt; end; i++) {hitCount[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[start]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[start]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = start+<span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; end; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &lt; min) { min = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i] &gt; max) {max = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[i];} } } <span class="hljs-comment"><span class="hljs-comment">//Optimization 1.Save the MapKey[i]. for (var i = start; i &lt; end; i++) { MapKey[i] = Math.floor(((this[i] - min ) / (max - min)) * (end - 1)); hitCount[MapKey[i]]++; } //Optimization 2.ProxMaps store in the hitCount. hitCount[end-1] = end - hitCount[end - 1]; for(var i = end-1; i &gt; start; i--){ hitCount[i-1] = hitCount[i] - hitCount[i - 1]; } //insert A[i]=this[i] to A2 correct position var insertIndex = 0; var insertStart = 0; for(var i = start; i &lt; end; i++){ insertIndex = hitCount[MapKey[i]]; insertStart = insertIndex; while(A2[insertIndex] != null) {insertIndex++;} while(insertIndex &gt; insertStart &amp;&amp; this[i] &lt; A2[insertIndex - 1]) { A2[insertIndex] = A2[insertIndex - 1]; insertIndex--; } A2[insertIndex] = this[i]; } for(var i = start; i &lt; end; i++) {this[i] = A2[i];} };</span></span></code> </pre> </div></div><br><h2>  Classifica√ß√£o de inser√ß√£o de classifica√ß√£o de hash :: Classifica√ß√£o de hash </h2><br>  Bem, encerraremos nossa an√°lise com o algoritmo <a href="https://habr.com/ru/users/bobbykdas/" class="user_link">sugerido</a> <a href="https://habr.com/ru/post/203032/">pelo</a> habraiser <a href="https://habr.com/ru/users/bobbykdas/" class="user_link">bobbyKdas</a> h√° 6 anos.  Este √© um algoritmo h√≠brido no qual, al√©m da distribui√ß√£o e inser√ß√µes, a mesclagem tamb√©m √© adicionada. <br><br><ol><li>  A matriz √© recursivamente dividida ao meio, at√© que, em algum momento, o tamanho das meias-sub-matrizes atinja o tamanho m√≠nimo (o autor n√£o possui mais de 500 elementos). </li><li>  No n√≠vel mais baixo de recurs√£o, um algoritmo familiar √© aplicado a cada semi-matriz - usando a mesma f√≥rmula, ocorre uma distribui√ß√£o aproximada dentro da matriz, com a classifica√ß√£o por inser√ß√µes de se√ß√µes locais n√£o classificadas. </li><li>  Ap√≥s o arranjo das duas metades, subarrays, elas se fundem. </li><li>  O ponto 3 (mesclagem de metades-subarranjos classificados) √© repetido ao elevar os n√≠veis de recurs√£o at√© o topo, quando a matriz original √© combinada de duas metades. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Classificar por inser√ß√£o de hash em Java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Arrays; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Date; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.Random; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashSort</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    static int SOURCELEN = 1000000; int source[] = new int[SOURCELEN]; //        int quick[] = new int[SOURCELEN]; //     static int SORTBLOCK = 500; static int k = 3; //  static int TMPLEN = (SOURCELEN &lt; SORTBLOCK * k) ? SORTBLOCK * k : SOURCELEN; int tmp[] = new int[TMPLEN]; //    static int MIN_VAL = 10; static int MAX_VAL = 1000000; int minValue = 0; int maxValue = 0; double hashKoef = 0; //      public void randomize() { int i; Random rnd = new Random(); for(i=0; i&lt;SOURCELEN; i++) { int rndValue = MIN_VAL + ((int)(rnd.nextDouble()*((double)MAX_VAL-MIN_VAL))); source[i] = rndValue; } } //         - public void findMinMax(int startIndex, int endIndex) { int i; minValue = source[startIndex]; maxValue = source[startIndex]; for(i=startIndex+1; i&lt;=endIndex; i++) { if( source[i] &gt; maxValue) { maxValue = source[i]; } if( source[i] &lt; minValue) { minValue = source[i]; } } hashKoef = ((double)(k-1)*0.9)*((double)(endIndex-startIndex)/((double)maxValue-(double)minValue)); } // (  - )      public void stickParts(int startIndex, int mediana, int endIndex) { int i=startIndex; int j=mediana+1; int k=0; //      -    while(i&lt;=mediana &amp;&amp; j&lt;=endIndex) { if(source[i]&lt;source[j]) { tmp[k] = source[i]; i++; } else { tmp[k] = source[j]; j++; } k++; } //     -      if( i&gt;mediana ) { while(j&lt;=endIndex) { tmp[k] = source[j]; j++; k++; } } //     -      if(j&gt;endIndex) { while(i&lt;=mediana) { tmp[k] = source[i]; i++; k++; } } System.arraycopy(tmp, 0, source, startIndex, endIndex-startIndex+1); } //        //         boolean shiftRight(int index) { int endpos = index; while( tmp[endpos] != 0) { endpos++; if(endpos == TMPLEN) return false; } while(endpos != index ) { tmp[endpos] = tmp[endpos-1]; endpos--; } tmp[endpos] = 0; return true; } //-    public int hash(int value) { return (int)(((double)value - (double)minValue)*hashKoef); } //        public void insertValue(int index, int value) { int _index = index; //  ,    //            - while(tmp[_index] != 0 &amp;&amp; tmp[_index] &lt;= value) { _index++; } //       ,    if( tmp[_index] != 0) { shiftRight(_index);//      } tmp[_index] = value;//  -   } //        public void extract(int startIndex, int endIndex) { int j=startIndex; for(int i=0; i&lt;(SORTBLOCK*k); i++) { if(tmp[i] != 0) { source[j] = tmp[i]; j++; } } } //   public void clearTMP() { if( tmp.length &lt; SORTBLOCK*k) { Arrays.fill(tmp, 0); } else { Arrays.fill(tmp, 0, SORTBLOCK*k, 0); } } //  public void hashingSort(int startIndex, int endIndex) { //1.          findMinMax(startIndex, endIndex); //2.    clearTMP(); //3.       - for(int i=startIndex; i&lt;=endIndex; i++) { insertValue(hash(source[i]), source[i]); } //4.         extract(startIndex, endIndex); } //         public void sortPart(int startIndex, int endIndex) { //    500,   - if((endIndex - startIndex) &lt;= SORTBLOCK ) { hashingSort(startIndex, endIndex); return; } //  &gt; 500         int mediana = startIndex + (endIndex - startIndex) / 2; sortPart(startIndex, mediana);//    sortPart(mediana+1, endIndex);//    stickParts(startIndex, mediana, endIndex);//   -   } //       public void sort() { sortPart(0, SOURCELEN-1); } public static void main(String[] args) { HashSort hs = new HashSort(); hs.randomize(); hs.sort(); } }</span></span></code> </pre> </div></div><br>  A pr√≥pria f√≥rmula √© chamada de fun√ß√£o hash, e a matriz auxiliar para distribui√ß√£o aproximada √© chamada de tabela hash. <br><br><h2>  Refer√™ncias </h2><br><img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png">  <a href="https://en.wikipedia.org/wiki/Interpolation_sort">Interpola√ß√£o e Histograma</a> , <a href="https://en.wikipedia.org/wiki/Flashsort">Flash</a> , <a href="https://en.wikipedia.org/wiki/Proxmap_sort">Proxmap</a> <br><br><img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png">  <a href="https://habr.com/ru/post/208088/">Salom√£o</a> , <a href="https://habr.com/ru/post/203032/">Tabela De Hash</a> , <a href="https://habr.com/ru/post/195968/">Flash</a> <br><br><h3>  Artigos da s√©rie: </h3><br><ul><li>  <a href="https://habr.com/post/414447/">Aplicativo Excel AlgoLab.xlsm</a> </li><li>  <a href="https://habr.com/post/414653/">Classifica√ß√µes de C√¢mbio</a> </li><li>  <a href="https://habr.com/post/415935/">Classifica√ß√µes de inser√ß√£o</a> </li><li>  <a href="https://habr.com/post/422085/">Classificar por sele√ß√£o</a> </li><li>  <a href="https://habr.com/ru/post/431964/">Mesclar classifica√ß√µes</a> </li><li>  <a href="https://habr.com/ru/post/472466/">Classificar por distribui√ß√£o</a> <ul><li>  <b>Contando sortes com distribui√ß√£o aproximada</b> </li><li>  <a href="https://habr.com/ru/post/481304/">Classifica√ß√£o da bandeira americana</a> </li><li>  √Årvore de sufixo na classifica√ß√£o bit a bit </li><li>  Comparando classifica√ß√µes por distribui√ß√£o </li></ul></li><li>  <a href="https://habr.com/ru/post/483786/">Classifica√ß√£o h√≠brida</a> </li></ul><br>  A classifica√ß√£o por aproxima√ß√£o apareceu no aplicativo AlgoLab Excel (nesse caso, na matriz inicial n√£o classificada, a parte fracion√°ria aleat√≥ria √© anexada aos n√∫meros inteiros).  Solomon e Flash est√£o l√° h√° muito tempo, mas ainda n√£o implementaram interpola√ß√£o, hash e histograma. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt478654/">https://habr.com/ru/post/pt478654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt478640/index.html">Carros aut√¥nomos em c√≥digo aberto</a></li>
<li><a href="../pt478642/index.html">MOXA Nport - Vis√£o interna</a></li>
<li><a href="../pt478646/index.html">JetQuad: Avi√µes a jato com decolagem e pouso verticais</a></li>
<li><a href="../pt478650/index.html">Dawn 3D</a></li>
<li><a href="../pt478652/index.html">Estrutura de pacotes DNS</a></li>
<li><a href="../pt478658/index.html">Como acordar tipo? Novo alarme Dawn Plus Light</a></li>
<li><a href="../pt478660/index.html">Engenheiros otimizam a captura de part√≠culas no CERN</a></li>
<li><a href="../pt478666/index.html">Placa de som USB no YM3812</a></li>
<li><a href="../pt478672/index.html">Teste e inicializa√ß√£o da IA: Entrevista com Adam Carmi (Applitools)</a></li>
<li><a href="../pt478680/index.html">Por que, e mais importante, para onde as pessoas v√£o da TI?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>