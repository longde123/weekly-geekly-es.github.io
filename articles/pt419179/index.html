<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏿 👃🏻 🤸🏽 Arquitetura pragmática pura. Brainstorming 👩🏾‍🤝‍👨🏼 👎🏿 ⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A idéia surgiu na sua cabeça para reescrever seu aplicativo corporativo ousado do zero? Se a partir do zero, então é uau. Pelo menos duas vezes menos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arquitetura pragmática pura. Brainstorming</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/419179/">  A idéia surgiu na sua cabeça para reescrever seu aplicativo corporativo ousado do zero?  Se a partir do zero, então é uau.  Pelo menos duas vezes menos código, certo?  Mas alguns anos se passarão, e também crescerá, se tornará legado ... não há muito tempo e dinheiro para que a reescrita funcione perfeitamente. <br><br>  Calma, as autoridades ainda não permitirão reescrever nada.  Resta refatorar.  Qual é a melhor maneira de gastar seus pequenos recursos?  Como refatorar onde limpar? <br><br>  O título deste artigo inclui uma referência ao livro do tio Bob <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Arquitetura limpa"</a> , e foi feito com base em um maravilhoso relatório de Victor Rentea ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">twitter</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site</a> ) na JPoint (sob o gato que ele começará a falar na primeira pessoa, mas por enquanto leia a introdução).  Lendo livros inteligentes, este artigo não substitui, mas para uma descrição tão curta é apresentada muito bem. <br><br>  A idéia é que coisas populares como “Arquitetura Limpa” sejam realmente úteis.  Surpresa  Se você precisar resolver um problema muito específico, um código simples e elegante não exige esforço extra e engenharia em excesso.  A arquitetura pura diz que você precisa proteger seu modelo de domínio contra efeitos externos e informa exatamente como isso pode ser feito.  Uma abordagem evolutiva para aumentar o volume de microsserviços.  Testes que tornam a refatoração menos assustadora.  Você já sabe tudo isso?  Ou você sabe, mas você tem medo de pensar nisso, porque é um horror o que você terá que fazer então? <br><br>  Quem deseja obter uma pílula mágica anti-procrastinação que ajudará a parar de tremer e começará a refatoração - bem-vindo à gravação em vídeo do relatório ou abaixo do gato. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mBxpOvlbAow" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><br>  Meu nome é Victor, sou da Romênia.  Formalmente, sou consultor, especialista técnico e arquiteto líder da IBM romena.  Mas, se me pedissem para definir uma definição de minha atividade, sou um evangelista de código puro.  Gosto de criar um código bonito, limpo e com suporte - como regra, falo sobre isso nos relatórios.  Ainda mais, sou inspirado pelo ensino: treinando desenvolvedores nas áreas de Java EE, Spring, Dojo, Desenvolvimento Orientado a Testes, Desempenho em Java, bem como no campo do evangelismo mencionado - os princípios dos padrões de código limpo e seu desenvolvimento. <br><br>  A experiência em que minha teoria se baseia é principalmente o desenvolvimento de aplicativos corporativos para o maior cliente IBM da Romênia - o setor bancário. <br><br>  O plano para este artigo é o seguinte: <br><br><ul><li>  Modelagem de dados: estruturas de dados não devem se tornar nossos inimigos; <br></li><li>  Organização da lógica: o princípio da "decomposição do código, que é demais"; <br></li><li>  "Onion" é a mais pura arquitetura de filosofia do Script de Transação; <br></li><li>  Testar como uma maneira de lidar com os medos dos desenvolvedores. <br></li></ul><br><br>  Mas primeiro, vamos relembrar os principais princípios que nós, como desenvolvedores, devemos sempre lembrar. <br><br><h4>  Princípio da responsabilidade exclusiva </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/353/dd0/cd5/353dd0cd58012749b70e379e37231265.jpg"><br><br>  Em outras palavras, quantidade versus qualidade.  Por via de regra, quanto mais funcionalidade a sua turma contiver, pior será a qualidade.  Ao desenvolver grandes classes, o programador começa a ficar confuso, cometer erros na criação de dependências e o código grande, entre outras coisas, é mais difícil de depurar.  É melhor dividir essa classe em várias classes menores, cada uma das quais será responsável por alguma subtarefa.  É melhor ter alguns módulos firmemente acoplados do que um - grande e lento.  A modularidade também permite a reutilização da lógica. <br><br><h4>  Ligação fraca do módulo </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f72/1c8/0f7/f721c80f7b3184be2218a01b66f7440a.jpg"><br><br>  O grau de ligação é uma medida de quão estreitamente seus módulos interagem entre si.  Ele mostra quão amplamente o efeito das alterações que você faz em qualquer ponto do sistema é capaz de se espalhar.  Quanto maior a vinculação, mais difícil é fazer modificações: você altera alguma coisa em um módulo e o efeito se estende para longe e nem sempre da maneira esperada.  Portanto, o indicador de ligação deve ser o mais baixo possível - isso fornecerá mais controle sobre o sistema que está passando por modificações. <br><br><h4>  Não repita </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b9/9de/5c0/2b99de5c00257d6123553c7bfaed0519.jpg"><br><br>  Suas próprias implementações podem ser boas hoje, mas não tão boas amanhã.  Não permita copiar suas próprias práticas recomendadas e, assim, distribuí-las em uma base de código.  Você pode copiar do StackOverflow, de livros - de qualquer fonte autorizada que (como você sabe com certeza) ofereça uma implementação ideal (ou próxima disso).  Melhorar sua própria implementação, que ocorre mais de uma vez, mas multiplicada por toda a base de código, pode ser muito cansativo. <br><br><h4>  Simplicidade e concisão </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7d4/8d4/c85/7d48d4c85408c620ddcbe644c4acb6f9.jpg"><br><br>  Na minha opinião, esse é o princípio principal que deve ser observado na engenharia e no desenvolvimento de software.  "O encapsulamento prematuro é a raiz do mal", disse Adam Bien.  Em outras palavras, a raiz do mal está na "reengenharia".  O autor da citação, Adam Bien, ao mesmo tempo estava envolvido em aceitar aplicativos herdados e, reescrevendo completamente seu código, recebeu uma base de código 2-3 vezes menor que a original.  De onde vem tanto código extra?  Afinal, surge por uma razão.  Seus medos dão origem a nós.  Parece-nos que, acumulando um grande número de padrões, gerando indiretos e abstrações, fornecemos nosso código com proteção - proteção contra as incógnitas de amanhã e os requisitos de amanhã.  Afinal, de fato, hoje não precisamos de nada disso, inventamos tudo isso apenas em prol de algumas "necessidades futuras".  E é possível que essas estruturas de dados interfiram posteriormente.  Para ser sincero, quando alguns de meus desenvolvedores me procuram e dizem que ele encontrou algo interessante que pode ser adicionado ao código de produção, eu sempre respondo da mesma maneira: "Cara, isso não será útil para você". <br><br>  Não deve haver muito código, e aquele que deve ser simples - a única maneira de trabalhar normalmente com ele.  Essa é uma preocupação para seus desenvolvedores.  Você deve se lembrar que eles são os índices do seu sistema.  Tente reduzir o consumo de energia, reduzir os riscos com os quais eles terão que trabalhar.  Isso não significa que você precise criar sua própria estrutura, além disso, eu não o aconselharia a fazer isso: sempre haverá erros em sua estrutura, todos precisarão estudá-la, etc.  É melhor usar os recursos existentes, dos quais existe uma massa hoje.  Estas devem ser soluções simples.  Anote manipuladores de erro globais, aplique tecnologia de aspecto, geradores de código, extensões Spring ou CDI, configure escopos de Solicitação / Encadeamento, use manipulação e geração de bytecodes em tempo real, etc. Tudo isso será sua contribuição para a coisa realmente mais importante - o conforto do seu desenvolvedor. <br><br>  Em particular, gostaria de demonstrar a você a aplicação das áreas Solicitação / Encadeamento.  Eu observei várias vezes como isso simplificou incrivelmente os aplicativos corporativos.  O ponto principal é que ele oferece a oportunidade, como usuário conectado, de salvar os dados do RequestContext.  Assim, o RequestContext armazenará os dados do usuário em um formato compacto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/341/6c5/474/3416c54740aca3b8f514696bf9cf7f3d.jpg"><br><br>  Como você pode ver, a implementação requer apenas algumas linhas de código.  Depois de escrever o pedido na anotação necessária (não é difícil fazê-lo se você usar o Spring ou CDI), você se libertará da necessidade de passar o login do usuário para os métodos e o que quer que seja: os metadados do pedido armazenados no contexto navegam de forma transparente no aplicativo.  O proxy com escopo definido permitirá que você acesse os metadados da solicitação atual a qualquer momento. <br><br><h4>  Testes de regressão </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c5/edf/d7a/5c5edfd7a14d760bc335d8e65f0d5666.jpg"><br><br>  Os desenvolvedores têm medo de requisitos atualizados porque têm medo de procedimentos de refatoração (modificações no código).  E a maneira mais fácil de ajudá-los é criar um conjunto de testes confiável para testes de regressão.  Com isso, o desenvolvedor terá a oportunidade, a qualquer momento, de testar seu tempo de operação - para garantir que não interrompa o sistema. <br><br>  O desenvolvedor não deve ter medo de quebrar nada.  Você deve fazer tudo para que a refatoração seja percebida como algo bom. <br>  A refatoração é um aspecto crítico do desenvolvimento.  Lembre-se, exatamente no momento em que seus desenvolvedores têm medo de refatorar, o aplicativo pode ser considerado um legado. <br><br><h2>  Onde implementar a lógica de negócios? </h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4fb/8a2/08d/4fb8a208dc6d89279a663747de74369f.jpg"><br><br>  Iniciando a implementação de qualquer sistema (ou componentes do sistema), nos perguntamos: onde é melhor implementar a lógica do domínio, ou seja, os aspectos funcionais da nossa aplicação?  Existem duas abordagens opostas. <br>  O primeiro é baseado na filosofia do <i>Script de Transação</i> .  Aqui, a lógica é implementada em procedimentos que funcionam com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">entidades anêmicas</a> (ou seja, com estruturas de dados).  Essa abordagem é boa porque, no decorrer de sua implementação, é possível confiar nas tarefas de negócios formuladas.  Enquanto trabalhava em aplicativos para o setor bancário, observei repetidamente a transferência de procedimentos de negócios para software.  Posso dizer que é realmente muito natural correlacionar cenários com software. <br><br>  Uma abordagem alternativa é usar os princípios do <i>Design Orientado a Domínio</i> .  Aqui você precisará correlacionar especificações e requisitos com uma metodologia orientada a objetos.  É importante considerar cuidadosamente os objetos e garantir um bom envolvimento comercial.  A vantagem dos sistemas projetados dessa maneira é que, no futuro, eles serão facilmente mantidos.  No entanto, na minha experiência, dominar essa metodologia é bastante difícil: você se sentirá mais ou menos corajoso não antes de seis meses estudando-a. <br><br>  Para meus desenvolvimentos, sempre escolhi a primeira abordagem.  Posso garantir que, no meu caso, funcionou perfeitamente. <br><br><h2>  Modelagem de dados </h2><br><br><h4>  Entidades </h4><br><br>  Como modelamos os dados?  Assim que o aplicativo tiver tamanhos mais ou menos decentes, <i>os dados persistentes</i> aparecerão necessariamente.  Esse é o tipo de dados que você precisa armazenar por mais tempo que o restante - são as <i>entidades de domínio do</i> seu sistema.  Onde armazená-los - seja no banco de dados, em um arquivo ou gerenciando diretamente a memória - não importa.  O importante é <i>como</i> você os armazenará - em quais estruturas de dados. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a8/56b/127/0a856b127ec938a8c17eb345610b0ee8.jpg"><br><br>  Essa opção é dada a você como desenvolvedor e depende apenas de você se essas estruturas de dados funcionarão a seu favor ou contra você ao implementar requisitos funcionais no futuro.  Para que tudo seja bom, você deve implementar entidades colocando neles grãos de <i>lógica de domínio reutilizada</i> .  Como especificamente?  Vou demonstrar vários métodos usando um exemplo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/e56/7da/c73e567da2fb69ceb3d627fb408530cd.jpg"><br><br>  Vamos ver o que eu forneci à entidade Cliente.  Em primeiro lugar, implementei um <code>getFullName()</code> <i>sintético</i> <code>getFullName()</code> <i>getter</i> que retornará a concatenação de firstName e lastName.  Também implementei o método <code>activate()</code> - para monitorar o estado da minha entidade, encapsulando-o.  Nesse método, coloquei, primeiramente, uma <i>operação de validação</i> e, em segundo lugar, <i>atribuir valores aos campos</i> status e enabledBy, para que não haja necessidade de setters para eles.  Também adicionei à entidade Customer os <code>isActive()</code> e <code>canPlaceOrders()</code> , que implementam a validação lambda dentro de mim.  Isso é chamado de encapsulamento de predicado.  Esses predicados são úteis se você usar filtros Java 8: você pode transmiti-los como argumentos aos filtros.  Eu aconselho você a usar esses ajudantes. <br><br>  Talvez você esteja usando algum tipo de ORM como o Hibernate.  Suponha que você tenha duas entidades com comunicação bidirecional.  A inicialização deve ser realizada em ambos os lados; caso contrário, como você entende, você terá problemas ao acessar esses dados no futuro.  Mas os desenvolvedores geralmente esquecem de inicializar um objeto de uma das partes.  Ao desenvolver essas entidades, você pode fornecer métodos especiais que garantam a inicialização bidirecional.  Dê uma olhada em <code>addAddress()</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c55/7fe/273/c557fe273cc1f2658573f9e78a70ca1d.png"><br><br>  Como você pode ver, esta é uma entidade muito comum.  Mas por dentro está a lógica do domínio.  Tais entidades não devem ser escassas e superficiais, mas não devem ser sobrecarregadas com a lógica.  O excesso de lógica ocorre com mais frequência: se você decidir implementar toda a lógica no domínio, para cada caso de uso, será tentador implementar algum método específico.  Como regra, existem muitos casos de uso.  Você não receberá uma entidade, mas uma grande pilha de todos os tipos de lógica.  Tente observar a medida aqui: apenas a <i>lógica reutilizada</i> é colocada no domínio e apenas <i>em uma pequena quantidade.</i> <i><br><br></i> <h4>  <i>Objetos de valor</i> </h4> <i><br><br></i>  Além das entidades, você provavelmente também precisará de valores de objetos.  Essa é apenas uma maneira de agrupar dados do domínio para que você possa movê-los posteriormente pelo sistema juntos. <br><br>  O objeto de valor deve ser: <br><br><ul><li>  <b>Pequeno</b> .  Sem <code>float</code> para variáveis ​​monetárias!  Tenha cuidado ao escolher tipos de dados.  Quanto mais compacto seu objeto, mais fácil é para um novo desenvolvedor descobrir isso.  Esta é a base para uma vida confortável. <br></li><li>  <b>Imutável</b> .  Se o objeto for realmente imutável, o desenvolvedor pode ficar calmo, pois seu objeto não alterará seu valor e não será interrompido após a criação.  Isso estabelece as bases para um trabalho calmo e confiante. <br></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a0e/765/284/a0e76528432de8c55dc146805a8b286d.jpg"><br><br>  E se você adicionar uma chamada de método <code>validate()</code> ao construtor, o desenvolvedor poderá se acalmar pela validade da entidade criada (ao passar, digamos, uma moeda inexistente ou uma quantia negativa de dinheiro, o construtor não funcionará). <br><br><h4>  A diferença entre uma entidade e um objeto de valor </h4><br><br>  Os objetos de valor diferem das entidades por não terem um ID fixo.  As entidades sempre terão campos associados à chave estrangeira de alguma tabela (ou outro armazenamento).  Objetos de valor não possuem esses campos.  Surge a pergunta: os procedimentos para verificar a igualdade de dois objetos de valor e duas entidades são diferentes?  Como os objetos de valor não possuem um campo de ID, para concluir que dois desses objetos são iguais, é necessário comparar os valores de todos os seus campos em pares (ou seja, examinar todo o conteúdo).  Ao comparar entidades, basta fazer uma única comparação - por ID do campo.  É no procedimento de comparação que reside a principal diferença entre entidades e objetos de valor. <br><br><h4>  Objetos de transferência de dados (DTOs) </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/72a/d31/681/72ad31681509cdef20509d4514b02139.jpg"><br><br>  Qual é a interação com a interface do usuário (UI)?  Você deve passar os <i>dados para exibição para ele</i> .  Você realmente precisará de outra estrutura?  Assim é.  E tudo porque a interface do usuário não é sua amiga.  Ele tem seus próprios pedidos: ele precisa que os dados sejam armazenados de acordo com a forma como eles devem ser exibidos.  Isso é maravilhoso - às vezes são as interfaces de usuário e seus desenvolvedores que nos exigem.  Então eles precisam obter dados para cinco linhas;  então, eles vêm à mente para criar um campo booleano <code>isDeletable</code> para o objeto (o objeto pode ter esse campo em princípio?) para saber se o botão Excluir está ativo ou não.  Mas não há nada para se indignar.  As interfaces de usuário simplesmente têm requisitos diferentes. <br><br>  A questão é: nossas entidades podem ser confiadas a eles para uso?  Muito provavelmente, eles os mudarão, e da maneira mais indesejável para nós.  Portanto, forneceremos a eles outra coisa - <i>Data Transfer Objects</i> (DTO).  Eles serão especialmente adaptados aos requisitos externos e a uma lógica diferente da nossa.  Alguns exemplos de estruturas de DTO são: Formulário / Solicitação (proveniente da interface do usuário), Visualização / Resposta (enviada à interface do usuário), Critérios de pesquisa / Resultados da pesquisa etc. Você pode, de certo modo, chamar isso de modelo de API. <br><br>  Primeiro princípio importante: o DTO deve conter um mínimo de lógica. <br>  Aqui está um exemplo de implementação do <code>CustomerDto</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ec/3bb/716/4ec3bb716c630f3b39ca82f8fe4c5e33.jpg"><br><br>  Conteúdo: campos <i>particulares</i> , getters <i>públicos</i> e setters para eles.  Tudo parece estar super.  OOP em toda a sua glória.  Mas uma coisa é ruim: na forma de getters e setters, eu implementei muitos métodos.  No DTO, deve haver o mínimo de lógica possível.  E então, qual é a minha saída?  Eu faço os campos públicos!  Você dirá que isso funciona mal com as referências de método do Java 8, que haverá limitações etc. Mas, acredite ou não, eu fiz todos os meus projetos (10 a 11 peças) com esses DTOs.  O irmão está vivo.  Agora, como meus campos são públicos, posso definir facilmente o valor como <code>dto.fullName</code> simplesmente colocando um sinal de igual.  O que poderia ser mais bonito e mais simples? <br><br><h2>  Organização lógica </h2><br><br><h4>  Mapeamento </h4><br><br>  Portanto, temos uma tarefa: precisamos transformar nossas entidades em DTO.  Implementamos a transformação da seguinte maneira: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/995/dfd/ca8/995dfdca8c1945fb92a64cee09851259.jpg"><br><br>  Como você pode ver, declarando um DTO, passamos para as operações de mapeamento (atribuição de valor).  Preciso ser desenvolvedor sênior para escrever tarefas regulares nesses números?  Para alguns, isso é tão incomum que eles começam a trocar de sapatos em movimento: por exemplo, copie dados usando algum tipo de estrutura de mapeamento usando reflexão.  Mas eles sentem falta do principal - que mais cedo ou mais tarde, a interface do usuário irá interagir com o DTO, como resultado da qual a entidade e o DTO divergem em seus significados. <br><br>  Pode-se, por exemplo, colocar operações de mapeamento no construtor.  Mas isso não é possível para nenhum mapeamento;  em particular, o designer não pode acessar o banco de dados. <br><br>  Portanto, somos forçados a deixar as operações de mapeamento na lógica de negócios.  E se eles têm uma aparência compacta, não há nada com que se preocupar.  Se o mapeamento não demorar algumas linhas, mas mais, é melhor colocá-lo no chamado <i>mapeador</i> .  Um mapeador é uma classe projetada especificamente para copiar dados.  Isso, em geral, é coisa antediluviana e clichê.  Mas, por trás deles, você pode ocultar nossas muitas tarefas - para tornar o código mais limpo e mais fino. <br><br>  Lembre-se: um <i>código que cresceu muito deve ser movido para uma estrutura separada</i> .  No nosso caso, as operações de mapeamento eram realmente um pouco demais, então as movemos para uma classe separada - o mapeador. <br><br>  Os mapeadores permitem acesso ao banco de dados?  Você pode ativá-lo por padrão - isso geralmente é feito por razões de simplicidade e pragmatismo.  Mas expõe você a certos riscos. <br><br>  Ilustrarei com um exemplo.  Com base no DTO existente, criamos a entidade <code>Customer</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef3/9e8/b82/ef39e8b82a023a2fad6afe8e3c22b5ec.png"><br><br>  Para o mapeamento, precisamos obter um link para o grupo de clientes no banco de dados.  Então, eu executo o método <code>getReference()</code> , e ele me devolve alguma entidade.  A solicitação provavelmente irá para o banco de dados (em alguns casos, isso não acontece, e a função stub funciona). <br><br>  Mas o problema não nos espera aqui, mas no método que executa a operação inversa - transformando a entidade em DTO. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6a/e27/7ff/e6ae277ff6b22588b5bc5aaffabf9d0e.png"><br><br>  Usando um loop, examinamos todos os endereços associados ao Cliente existente e os convertemos em endereços DTO.  Se você usa ORM, provavelmente, quando você chama o método <code>getAddresses()</code> , o carregamento lento será realizado.  Se você não usar o ORM, essa será uma solicitação aberta a todos os filhos desse pai.  E aqui você corre o risco de mergulhar no "problema N + 1".  Porque <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e54/001/2bb/e540012bbb4a242d84e55a2dffa5ca11.jpg"><br><br>  Você tem um conjunto de pais, cada um com filhos.  Por tudo isso, você precisa criar seus próprios análogos dentro do DTO.  Você precisará executar uma consulta <code>SELECT</code> para percorrer N entidades-pai e N consultas para selecionar os filhos de cada uma delas.  Pedido total de N + 1.  Para 1000 entidades pai do <code>Customer</code> , essa operação levará de 5 a 10 segundos, o que, é claro, leva muito tempo. <br><br>  Suponha que, no entanto, nosso método <code>CustomerDto()</code> seja chamado dentro do loop, convertendo a lista de objetos Customer para a lista CustomerDto. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/58c/9c3/2b3/58c9c32b3e8a01a96d500920dfe5ef07.jpg"><br><br>  O problema com as consultas N + 1 tem soluções padrão simples: no <i>JPQL,</i> você pode usar <code>FETCH</code> por customer.addresses para recuperar filhos e conectá-los usando <code>JOIN</code> ; no SQL, você pode usar o desvio <code>IN</code> e a <code>WHERE</code> . <br><br>  Mas eu faria diferente.  Você pode descobrir qual é o tamanho máximo da lista de filhos (isso pode ser feito, por exemplo, com base em uma pesquisa com paginação).  Se a lista contiver apenas 15 entidades, precisaremos de apenas 16 consultas.  Em vez de 5ms, gastaremos em tudo, digamos, 15ms - o usuário não perceberá a diferença. <br><br><h4>  Sobre otimização </h4><br><br>  Eu não o aconselharia a olhar para o desempenho do sistema no estágio inicial de desenvolvimento.  Como Donald Knud disse: "A otimização prematura é a raiz do mal".  Você não pode otimizar desde o início.  É exatamente isso que precisa ser deixado para mais tarde.  E o que é especialmente importante: <i>sem suposições - apenas medições e avaliação de medições!</i> <br><br>  Tem certeza de que é competente que é um verdadeiro especialista?  Seja humilde em se avaliar.  Não pense que você entende a JVM até ler pelo menos alguns livros sobre a compilação JIT.  Acontece que os melhores programadores da nossa equipe vêm até mim e dizem que <i>acham</i> que encontraram uma implementação mais eficiente.  Acontece que eles novamente inventaram algo que apenas complica o código.  Então eu respondo várias vezes: YAGNI.  Nós não precisamos disso. <br><br>  Freqüentemente, para aplicativos corporativos, nenhuma otimização de algoritmos é necessária.  O gargalo para eles, em regra, não é compilação e nem no que diz respeito ao processador, mas todos os tipos de operações de entrada e saída.  Por exemplo, lendo um milhão de linhas de um banco de dados, gravações volumosas em um arquivo, interação com soquetes. <br><br>  Com o tempo, você começa a entender quais gargalos o sistema contém e, reforçando tudo com as medidas, começará a otimizar gradualmente.  Por enquanto, mantenha o código o mais limpo possível.  Você descobrirá que esse código é muito mais fácil de otimizar ainda mais. <br><br><h4>  Preferir composição sobre herança </h4><br><br>  Voltar ao nosso DTO.  Suponha que definamos um DTO como este: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/180/39d/f91/18039df91fd1cc76a2413b7f373e7c0b.png"><br><br>  Podemos precisar dele em muitos fluxos de trabalho.  Mas esses fluxos são diferentes e, provavelmente, cada caso de uso assumirá um grau diferente de preenchimento de campo.  Por exemplo, obviamente precisaremos criar um DTO mais cedo do que quando tivermos informações completas do usuário.  Você pode deixar temporariamente os campos em branco.  Porém, quanto mais campos você ignorar, mais você desejará criar um novo DTO mais rígido para esse caso de uso. <br><br>  Como alternativa, você pode criar cópias de um DTO excessivamente grande (no número de casos de uso disponíveis) e, em seguida, remover campos extras para cada cópia.  Mas para muitos programadores, em virtude de sua inteligência e alfabetização, dói muito pressionar Ctrl + V.  O axioma diz que copiar e colar é ruim. <br><br>  Você pode recorrer ao princípio de <i>herança</i> conhecido na teoria OOP: basta definir um DTO básico e criar um herdeiro para cada caso de uso. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6f7/069/77f/6f706977fec8625d720323b64fe87ad8.png"><br><br>  Um princípio bem conhecido é: "Prefira composição ao invés de herança".  Leia o que diz: <i>"estende"</i> .  Parece que deveríamos ter “expandido” a classe de origem.  Mas se você pensar bem, o que fizemos não é "expansão".  Esta é a verdadeira "repetição" - a mesma vista lateral de copiar e colar.  Portanto, não usaremos herança. <br><br>  Mas o que devemos então ser?  Como ir para a composição?  Vamos fazer desta maneira: escreva um campo no CustomerView que aponte para o objeto do DTO subjacente. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f2/d49/831/1f2d49831b9b286b8bc069c824ac2871.jpg"><br><br>  Assim, nossa estrutura básica será aninhada por dentro.  É assim que a composição real sai. <br><br>  Independentemente de usarmos herança ou resolvermos o problema por composição - todos esses são detalhes, sutilezas que surgiram profundamente no curso de nossa implementação.  Eles são muito <i>frágeis</i> .  O que significa frágil?  Dê uma olhada neste código: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/921/eb1/ef2/921eb1ef20effd43b129ad5d28b88253.png"><br><br>  A maioria dos desenvolvedores para quem eu mostrei isso imediatamente deixou escapar que o número "2" é repetido e, portanto, precisa ser retirado como uma constante.  Eles não perceberam que o empate nos três casos tem um significado completamente diferente (ou "valor comercial") e que sua repetição nada mais é do que uma coincidência.  Colocar um dois em uma constante é uma decisão legítima, mas muito frágil.  Tente não permitir lógica frágil no domínio.  Nunca trabalhe com estruturas de dados externas, em particular com o DTO. <br><br>  Então, por que o trabalho de eliminar a herança e introduzir a composição é inútil?  Precisamente porque criamos o DTO não para nós mesmos, mas para um cliente externo.  E como o aplicativo cliente analisará o DTO recebido de você - você só pode adivinhar.  Mas, obviamente, isso terá pouco a ver com sua implementação.  Os desenvolvedores, por outro lado, podem não fazer distinção entre os DTOs básicos e não básicos que você pensou cuidadosamente;  eles provavelmente usam herança, e talvez copiar e colar estupidamente isso é tudo. <br><br><h4>  Fachadas </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/be7/31c/9e4/be731c9e4cfe002cb3b59c11a708f623.jpg"><br><br>  Vamos voltar à imagem geral do aplicativo.  Aconselho você a implementar a lógica do domínio através do <i>padrão Facade</i> , expandindo fachadas com <i>serviços de domínio,</i> conforme necessário.  Um serviço de domínio é criado quando muita lógica se acumula na fachada e é mais conveniente colocá-lo em uma classe separada. <br>  Seus serviços de domínio devem necessariamente falar o idioma do seu modelo de domínio (suas entidades e objetos de valor).  Em nenhum caso eles devem funcionar com o DTO, porque o DTO, como você se lembra, são estruturas que mudam constantemente no lado do cliente, muito frágeis para um domínio. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ad/eb8/657/3adeb86570a92f804ba491836c99b9e8.jpg"><br><br>  Qual é o objetivo da fachada? <br><br><ol><li>  Conversão de dados.  Se temos entidades de um lado e DTO do outro, é necessário realizar transformações de um para o outro.  E esta é a primeira coisa que as fachadas servem.  Se o procedimento de conversão aumentar em volume - use as classes do mapeador. <br></li><li>  A implementação da lógica.  Na fachada, você começará a escrever a lógica principal do aplicativo.  Assim que se tornar muito - leve as peças ao serviço de domínio. <br></li><li>  Validação de dados.  Lembre-se de que quaisquer dados recebidos do usuário são, por definição, incorretos (contendo erros).  A fachada tem a capacidade de validar dados.  Esses procedimentos, quando o volume é excedido, geralmente são levados aos <i>validadores</i> . <br></li><li>  Aspectos  Você pode ir além e fazer com que cada caso de uso passe por sua fachada.  Depois, adicionará coisas como transações, log e manipuladores de exceções globais aos métodos de fachada.Eu observo que é muito importante ter manipuladores de exceções globais em qualquer aplicativo que capture todos os erros não capturados por outros manipuladores.  Eles ajudarão muito seus programadores - eles lhes darão paz de espírito e liberdade de ação. <br></li></ol><br><br><h4>  Decomposição de muito código </h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/a9c/8e8/604a9c8e859ff1dc3fb38208d6bf836d.jpg"><br><br>  Mais algumas palavras sobre esse princípio.  Se a classe alcançou algum tamanho inconveniente para mim (digamos, 200 linhas), devo tentar dividi-la em pedaços.  Mas isolar uma nova classe de uma existente nem sempre é fácil.  Precisamos apresentar algumas maneiras universais.  Um desses métodos é procurar nomes: você está tentando encontrar um nome para um subconjunto dos métodos da sua classe.  Assim que você conseguir encontrar um nome, sinta-se à vontade para criar uma nova classe.  Mas isso não é tão simples.  Na programação, como você sabe, existem apenas duas coisas complexas: isso está invalidando o cache e inventando nomes.  Nesse caso, inventar um nome envolve a identificação de uma subtarefa oculta e, portanto, não previamente identificada por ninguém. <br><br>  Um exemplo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/81f/fe3/82b/81ffe382b74f6bbd4a91626d83249a97.jpg"><br><br>  Na fachada original do <code>CustomerFacade</code> alguns dos métodos estão diretamente relacionados ao cliente e outros relacionados às preferências do cliente.  Com base nisso, poderei dividir a classe em duas quando atingir tamanhos críticos.  Recebo duas fachadas: <code>CustomerFacade</code> e <code>CustomerPreferencesFacade</code> .  A única coisa ruim é que essas duas fachadas pertencem ao mesmo nível de abstração.  A separação por níveis de abstração implica em algo diferente. <br><br>  Outro exemplo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ac/84e/788/2ac84e788af60fb038091aed273a390e.jpg"><br><br>  Suponha que exista uma classe <code>OrderService</code> em nosso sistema na qual implementamos um mecanismo de notificação por email.  Agora, estamos criando um <code>DeliveryService</code> e gostaríamos de usar o mesmo mecanismo de notificação aqui.  Copiar e colar é excluído.  Vamos fazer assim: extrair a funcionalidade de notificação para a nova classe <code>AlertService</code> e gravá-la como uma dependência para as <code>OrderService</code> <code>DeliveryService</code> e <code>OrderService</code> .  Aqui, em contraste com o exemplo anterior, a separação ocorreu precisamente nos níveis de abstração. <code>DeliveryService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais abstrato que </font></font><code>AlertService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque o usa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como parte de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seu fluxo </font><i><font style="vertical-align: inherit;">de</font></i><font style="vertical-align: inherit;"> trabalho. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A separação por níveis de abstração sempre pressupõe que a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classe extraída se torne uma dependência</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">extração seja realizada para reutilização</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A tarefa de extração nem sempre é fácil. </font><font style="vertical-align: inherit;">Também pode acarretar algumas dificuldades e exigir alguma refatoração de testes de unidade. </font><font style="vertical-align: inherit;">No entanto, de acordo com minhas observações, é ainda mais difícil para os desenvolvedores procurar qualquer funcionalidade na enorme base de código monolítico do aplicativo.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Programação em par </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/625/5b2/346/6255b23467294d6224107235443379f1.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muitos consultores falarão sobre programação em pares, sobre o fato de que hoje é uma solução universal para qualquer problema de desenvolvimento de TI. Durante isso, os programadores desenvolvem suas habilidades técnicas e conhecimentos funcionais. Além disso, o processo em si é interessante, reúne a equipe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falando não como consultores, mas humanamente, o mais importante é o seguinte: a programação em pares melhora o "fator de barramento". A essência do "fator de barramento" é que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deve haver o maior número possível de pessoas com conhecimento sobre a estrutura do sistema</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Perder essas pessoas significa perder as últimas pistas para esse conhecimento.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A refatoração de programação em pares é uma arte que requer experiência e treinamento. É útil, por exemplo, a prática de refatoração agressiva, realização de hackathons, cortes, codificação de Dojos, etc. A </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">programação em pares funciona bem nos casos em que você precisa resolver problemas de alta complexidade. O processo de trabalho em conjunto nem sempre é simples. Mas garante que você evitará a "reengenharia" - pelo contrário, obterá uma implementação que atenda aos requisitos definidos com o mínimo de complexidade. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a5a/5aa/666/a5a5aa666cb29c58dc9bb5b7d5bc6651.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Organizar um formato de trabalho conveniente é uma das suas principais responsabilidades para a equipe. Você deve cuidar constantemente das condições de trabalho do desenvolvedor - fornecer a ele total conforto e liberdade de criatividade, especialmente se forem necessárias para aumentar a arquitetura do design e sua complexidade.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sou arquiteto. </font><font style="vertical-align: inherit;">Por definição, eu estou sempre certo. ”</font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa estupidez é periodicamente expressa publicamente ou nos bastidores. </font><font style="vertical-align: inherit;">Na prática de hoje, os arquitetos são encontrados cada vez menos. </font><font style="vertical-align: inherit;">Com o advento do Agile, esse papel passou gradualmente aos desenvolvedores seniores, porque geralmente todo o trabalho, de uma maneira ou de outra, é construído em torno deles. </font><font style="vertical-align: inherit;">O tamanho da implementação está aumentando gradualmente e, com isso, é necessário refatorar e novas funcionalidades estão sendo desenvolvidas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arquitetura de cebola </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cebola é a mais pura filosofia do Script de Transação. Construindo-o, somos guiados pelo objetivo de proteger o código que consideramos crítico e, para isso, o movemos para o módulo de domínio. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a45/bb4/94a/a45bb494a51b04ecfe92606b744c0857.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em nossa aplicação, os mais importantes são os serviços de domínio: eles implementam os fluxos mais críticos. Mova-os para o módulo de domínio. Obviamente, também vale a pena mover todos os seus objetos de domínio para cá - entidades e objetos de valor. Todo o resto que compilamos hoje - DTO, mapeadores, validadores etc. - se torna, por assim dizer, a primeira linha de defesa do usuário. Porque o usuário, infelizmente, não é nosso amigo, e é necessário proteger o sistema dele. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atenção a esta dependência:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7d/273/6bd/c7d2736bdc016b732c5c431299bf32ea.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O módulo de aplicativo dependerá do módulo de domínio - ou seja, não o contrário. Ao registrar essa conexão, garantimos que o DTO nunca entrará no território sagrado do módulo de domínio: eles simplesmente não são visíveis e inacessíveis a partir do módulo de domínio. Acontece que, em certo sentido, cercamos o território do domínio - restringimos o acesso a estranhos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, o domínio pode precisar interagir com algum serviço externo. Com meios externos hostis, porque ele está equipado com seu DTO. Quais são as nossas opções? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro: pule o inimigo dentro do módulo. </font></font><br><br><img src="https://habrastorage.org/webt/un/tn/hk/untnhkiksv5id_i-6c4qwdjxy1c.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, essa é uma opção ruim: é possível que amanhã o serviço externo não atualize para a versão 2.0 e tenhamos que redesenhar nosso domínio. Não deixe o inimigo dentro do domínio!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proponho uma abordagem diferente: criaremos um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especial para interação </font><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/8b1/09c/1238b109c54ac8f19524e6d41b32e85e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O adaptador receberá dados de um serviço externo, extrairá os dados que nosso domínio precisa e os converterá nos tipos de estruturas necessários. </font><font style="vertical-align: inherit;">Nesse caso, tudo o que é necessário de nós durante o desenvolvimento é correlacionar as chamadas ao sistema externo com os requisitos do domínio. </font><font style="vertical-align: inherit;">Pense nisso como um grande </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adaptador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como este </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Eu chamo essa camada de "anticorrupção". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, podemos precisar executar consultas LDAP de um domínio. </font><font style="vertical-align: inherit;">Para isso, estamos implementando o "módulo anticorrupção" </font></font><code>LDAPUserServiceAdapter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/520/fdc/84a/520fdc84a53641a26b957ac010a19c42.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No adaptador, podemos:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ocultar chamadas de API feias (no nosso caso, oculte o método que utiliza a matriz Object); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Embalar exceções em nossas próprias implementações; </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Converta estruturas de dados de outras pessoas em suas próprias (em nossos objetos de domínio); </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifique a validade dos dados recebidos. </font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esse é o objetivo do adaptador. </font><font style="vertical-align: inherit;">Bom, na interface com cada sistema externo com o qual você precisa interagir, seu adaptador deve estar instalado. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/b1a/663/9c5/b1a6639c58457537fb6a4d9c15e09eae.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, o domínio não direcionará a chamada para um serviço externo, mas para o adaptador. </font><font style="vertical-align: inherit;">Para fazer isso, a dependência correspondente deve ser registrada no domínio (do adaptador ou do módulo de infraestrutura em que está localizado). </font><font style="vertical-align: inherit;">Mas esse vício é seguro? </font><font style="vertical-align: inherit;">Se você instalá-lo assim, um DTO de serviço externo pode entrar em nosso domínio. </font><font style="vertical-align: inherit;">Não devemos permitir isso. </font><font style="vertical-align: inherit;">Portanto, sugiro outra maneira de modelar dependências.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Princípio de Inversão de Dependência </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/058/4a1/f7c/0584a1f7c309505e4e5ea0c2b0b26c21.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos criar uma interface, escrever nela a assinatura dos métodos necessários e colocá-la dentro do nosso domínio. A tarefa do adaptador é implementar essa interface. Acontece que a interface está dentro do domínio e o adaptador está fora, no módulo de infraestrutura que importa a interface. Assim, viramos a direção da dependência na direção oposta. No tempo de execução, o sistema de domínio chamará qualquer classe por meio de interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como você pode ver, ao introduzir interfaces na arquitetura, fomos capazes de implantar dependências e, assim, proteger nosso domínio de estruturas e APIs externas que caem nele. Essa abordagem é chamada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inversão de dependência</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c2c/cc2/cd0/c2ccc2cd0309a4c8f97b7521cfc63fb7.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em geral, a inversão de dependência pressupõe que você coloque os métodos de seu interesse na interface dentro de seu módulo de alto nível (no domínio) e implemente essa interface de fora - em um ou outro módulo feio de baixo nível (infraestrutura). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A interface implementada dentro do módulo de domínio deve falar o idioma do domínio, ou seja, operará em suas entidades, parâmetros e tipos de retorno. Em tempo de execução, o domínio chamará qualquer classe por meio de uma chamada polimórfica para a interface. As estruturas de injeção de dependência (como Spring e CDI) nos fornecem uma instância concreta da classe em tempo de execução.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas o principal é que, durante a compilação, o módulo de domínio não verá o conteúdo do módulo externo. </font><font style="vertical-align: inherit;">É disso que precisamos. </font><font style="vertical-align: inherit;">Nenhuma entidade externa deve cair no domínio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segundo o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tio Bob</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o princípio da inversão de controle (ou, como ele chama, “arquitetura de plug-in”) é talvez o melhor que o paradigma OOP oferece em geral. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a96/3cf/e13/a963cfe13d030fb1d7ec2bf0f780fe43.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa estratégia pode ser usada para integração com qualquer sistema, para chamadas e mensagens síncronas e assíncronas, para envio de arquivos etc.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visão geral da lâmpada </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/dc3/64d/cdb/dc364dcdb589b35a0597b6e478aace46.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Então, decidimos que protegeremos o módulo de domínio. </font><font style="vertical-align: inherit;">Dentro dele, há um serviço de domínio, entidades, objetos de valor e agora interfaces para serviços externos, além de interfaces para o repositório (para interagir com o banco de dados). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A estrutura fica assim: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/07e/983/0c7/07e9830c76d3b263743f8514b13bf42a.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O módulo de aplicativo, o módulo de infraestrutura (por inversão de dependência), o módulo de repositório (também consideramos o banco de dados como um sistema externo), o módulo de lote e, possivelmente, alguns outros módulos são dependências declaradas para o domínio. </font><font style="vertical-align: inherit;">Essa arquitetura é chamada de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"cebola"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">também é chamado de "limpo", "hexagonal" e "portas e adaptadores".</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Módulo de repositório </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vou falar brevemente sobre o módulo do repositório. A questão de retirá-lo do domínio é uma questão. A tarefa do repositório é tornar a lógica mais limpa, escondendo de nós o horror de trabalhar com dados persistentes. A opção para os veteranos é usar o JDBC para interagir com o banco de dados: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/d70/44a/7edd7044a76373b2c513e246bf6eabaa.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">você também pode usar o Spring e seu JdbcTemplate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/64b/d68/749/64bd68749f5b3de16591a23a8acda193.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou MyBatis DataMapper: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/423/31b/aa1/42331baa178ff3ad8f0ea8fb92704265.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mas é tão complicado e feio que desencoraja qualquer desejo de fazer mais alguma coisa. Portanto, sugiro usar JPA / Hibernate ou Spring Data JPA. Eles nos darão a oportunidade de enviar consultas criadas não no esquema do banco de dados, mas diretamente com base no modelo de nossas entidades. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação para JPA / Hibernate: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/110/ebf/ef7/110ebfef7dad2a2bb278c50668eecda9.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No caso de Spring Data JPA:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/10b/e2a/0ff/10be2a0ff082a8c1ac962c4754ec55a8.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Spring Data JPA pode gerar métodos automaticamente em tempo de execução, como, por exemplo, getById (), getByName (). Também permite executar consultas JPQL, se necessário - e não no banco de dados, mas no seu próprio modelo de entidade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O código JPA do Hibernate e Spring Data JPA realmente parece muito bom. Precisamos extraí-lo do domínio? Na minha opinião, isso não é tão e necessário. Muito provavelmente, o código será ainda mais limpo se você deixar esse fragmento dentro do domínio. Então, aja sobre a situação.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/055/f04/37c/055f0437cf059c9f7001db6b3d231e70.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No entanto, se você criar um módulo de repositório, para a organização de dependências, é melhor usar o princípio de inversão de controle da mesma maneira. </font><font style="vertical-align: inherit;">Para fazer isso, coloque a interface no domínio e implemente-a no módulo de repositório. </font><font style="vertical-align: inherit;">Quanto à lógica do repositório, é melhor transferi-lo para o domínio. </font><font style="vertical-align: inherit;">Isso torna o teste conveniente, pois você pode usar objetos Mock no domínio. </font><font style="vertical-align: inherit;">Eles permitirão que você teste a lógica rápida e repetidamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tradicionalmente, apenas uma entidade é criada para um repositório em um domínio. </font><font style="vertical-align: inherit;">Eles o quebram em pedaços apenas quando se tornam muito volumosos. </font><font style="vertical-align: inherit;">Lembre-se de que as classes devem ser compactas.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c8/9e1/7e7/1c89e17e784e4db6fe8d7c713bcf1ab6.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode criar um módulo separado, colocar a interface extraída da fachada e os DTOs que dependem dele, empacotá-lo em um JAR e transferi-lo para seus clientes Java neste formulário. </font><font style="vertical-align: inherit;">Com esse arquivo, eles poderão enviar solicitações para as fachadas.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lâmpada pragmática </font></font></h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além dos nossos “inimigos” aos quais entregamos funcionalidades, ou seja, clientes, também temos inimigos e, por outro lado, aqueles módulos dos quais dependemos. </font><font style="vertical-align: inherit;">Também precisamos nos proteger desses módulos. </font><font style="vertical-align: inherit;">E para isso, ofereço-lhe uma "cebola" levemente modificada - nela toda a infraestrutura é combinada em um módulo. </font></font><br><img src="https://habrastorage.org/getpro/habr/post_images/265/1f1/481/2651f1481062cfe6c18974df9a6dde9b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu chamo essa arquitetura de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"lâmpada pragmática"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Aqui, a separação dos componentes é realizada de acordo com o princípio “meu” e “integrável”: separadamente, que se refere ao meu domínio, e separadamente, que se refere à integração com colaboradores externos. Assim, apenas dois módulos são obtidos: o domínio e o aplicativo. Essa arquitetura é muito boa, mas apenas quando o módulo do aplicativo é pequeno. Caso contrário, é melhor você voltar para a cebola tradicional.</font></font><br><br><h2>  Testes </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como eu disse anteriormente, se todo mundo tem medo do seu aplicativo, considere que ele reabasteceu as fileiras do Legacy. </font></font><img src="https://habrastorage.org/getpro/habr/post_images/12a/508/d1b/12a508d1b9595239f6d9b9a8a72c9474.jpg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas os testes são bons. Eles nos dão uma sensação de confiança que nos permite continuar refatorando. Infelizmente, porém, essa confiança pode facilmente se tornar injustificada. Eu vou explicar o porquê. O TDD (desenvolvimento por meio de testes) assume que você é o autor do código e o autor dos casos de teste: você lê as especificações, implementa a funcionalidade e imediatamente escreve um conjunto de testes para ele. Testes, digamos, terão sucesso. Mas e se você entendeu mal os requisitos das especificações? Em seguida, os testes não verificarão o que é necessário. Portanto, sua confiança é inútil. E tudo porque você escreveu código e testes sozinho.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas tente fechar os olhos para isso. </font><font style="vertical-align: inherit;">Os testes ainda são necessários e, de qualquer forma, eles nos dão confiança. </font><font style="vertical-align: inherit;">Acima de tudo, é claro, adoramos testes funcionais: eles não implicam efeitos colaterais, não dependem - apenas dados de entrada e saída. </font><font style="vertical-align: inherit;">Para testar um domínio, você precisa usar objetos simulados: eles permitirão que você teste as classes isoladamente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quanto às consultas ao banco de dados, testá-las é desagradável. </font><font style="vertical-align: inherit;">Esses testes são frágeis, exigem que você adicione primeiro dados de teste ao banco de dados - e somente depois disso você poderá prosseguir com o teste da funcionalidade. </font><font style="vertical-align: inherit;">Mas, como você entende, esses testes também são necessários, mesmo se você usar o JPA.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testes unitários </font></font></h4><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bd/332/6ec/8bd3326ec6ca9886c78b4239491dc936.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu diria que o poder dos testes de unidade não está na possibilidade de executá-los, mas no que o processo de escrevê-los abrange. Enquanto você está escrevendo um teste, repensa e trabalha com o código - reduz a conectividade, divide-o em classes - em uma palavra, realiza a próxima refatoração. O código em teste é um código puro; é mais simples, a conexão é reduzida nele; em geral, também é documentado (um teste de unidade bem escrito descreve perfeitamente como a classe funciona). Não é de surpreender que seja difícil escrever testes de unidade, especialmente as primeiras peças. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/116/be7/361/116be7361d4d6a2dc8cac91983808378.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na fase dos primeiros testes de unidade, muitas pessoas têm realmente medo das perspectivas de que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">realmente precisam</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> testar alguma coisa. Por que eles recebem tão difícil? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porque esses testes são o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primeiro fardo para sua classe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Este é o primeiro golpe no sistema, que talvez mostre que é frágil e frágil. Mas você precisa entender que esses poucos testes são os mais importantes para o seu desenvolvimento. Eles são, em essência, seus melhores amigos, porque dirão tudo sobre a qualidade do seu código. Se você tem medo desse estágio, não vai longe. Você deve executar os testes para o seu sistema. Depois disso, a complexidade diminuirá, os testes serão gravados mais rapidamente. Adicionando-os um por um, você criará uma </font><i><font style="vertical-align: inherit;">base de testes de regressão</font></i><font style="vertical-align: inherit;"> confiável para o seu sistema</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">E isso é incrivelmente importante para o trabalho futuro de seus desenvolvedores. </font><font style="vertical-align: inherit;">Será mais fácil para eles refatorar; </font><font style="vertical-align: inherit;">Eles entenderão que o sistema pode ser testado por regressão a qualquer momento, e é por isso que trabalhar com a base de código é seguro. </font><font style="vertical-align: inherit;">E, garanto-lhe, eles se empenharão na refatoração com muito mais disposição. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb5/3d7/cbd/eb53d7cbdc3b190b2b597d6427088b1a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meu conselho para você: se você acha que hoje tem muita força e energia, dedique-se a escrever testes de unidade. </font><font style="vertical-align: inherit;">E certifique-se de que cada um seja limpo, rápido, tenha seu próprio peso e não repita os outros.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dicas </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resumindo tudo o que foi dito hoje, gostaria de advertir você com as seguintes dicas: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mantenha a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simplicidade</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pelo maior tempo possível (e não importa quanto custe) </font><font style="vertical-align: inherit;">: evite a "reengenharia" e a otimização tardia, não sobrecarregue o aplicativo;</font></font><br></li><li> <i>   </i> ,        ,   ; <br></li><li>  «»           — <i>     </i> ; <br></li><li>   ,        — <i></i> :         ; <br></li><li>    «»,  ,     — <i>           </i> ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não tenha medo dos testes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dê a eles a oportunidade de derrubar seu sistema, sentir todos os benefícios deles - no final, eles são seus amigos, porque podem apontar problemas honestamente.</font></font><br></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ao fazer essas coisas, você ajudará sua equipe e a si mesmo. </font><font style="vertical-align: inherit;">E então, quando chegar o dia da entrega do produto, você estará pronto para isso.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O que ler </font></font></h2><br><br><img src="https://habrastorage.org/getpro/habr/post_images/852/a4c/37d/852a4c37d17677fa3fb1e7e021f29e4a.jpg"><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7 virtudes de um bom objeto</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL é o pior erro da Ciência da Computação</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A arquitetura limpa</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Novo jargão de programação</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade do código: WTFs / minuto</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que cada elemento do SOLID está errado!</font></font></a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bom software é escrito 3 vezes</font></font></a> <br></li></ul><br><br><blockquote>  .        <b>JPoint</b> —  ,  19-20   -  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Joker 2018</a> —    Java-.       .        . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419179/">https://habr.com/ru/post/pt419179/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419165/index.html">Enviamos SMS "anônimo" do console para o número desejado usando o serviço bytehand e C ++</a></li>
<li><a href="../pt419169/index.html">"Mundo do Oeste Selvagem" através dos olhos do desenvolvedor</a></li>
<li><a href="../pt419171/index.html">Desativando verificações de estado de tempo de execução em um aplicativo Android</a></li>
<li><a href="../pt419173/index.html">Arquitetura limpa no contexto do desenvolvimento de plataforma cruzada</a></li>
<li><a href="../pt419177/index.html">Padrões de luz da Amazon</a></li>
<li><a href="../pt419181/index.html">Programação do mouse: como fugimos da rotina do CRM</a></li>
<li><a href="../pt419183/index.html">Demopati em Helsinque “Assembléia 2018”, reportagem fotográfica, primeiro dia</a></li>
<li><a href="../pt419185/index.html">Visão geral dos protocolos atuais de construção de consenso em um ambiente descentralizado</a></li>
<li><a href="../pt419189/index.html">Por que as ofertas de pacotes formarão em breve a base do varejo</a></li>
<li><a href="../pt419193/index.html">Lidamos com objetos em JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>