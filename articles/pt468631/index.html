<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏻 🎽 🕚 Testando aplicativos Flutter. Iniciar 👨‍👩‍👦‍👦 🏏 🤲🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O Flutter é lembrado quando é necessário criar rapidamente um aplicativo bonito e responsivo para várias plataformas ao mesmo tempo, mas como garantir...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testando aplicativos Flutter. Iniciar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/468631/"><p>  O Flutter é lembrado quando é necessário criar rapidamente um aplicativo bonito e responsivo para várias plataformas ao mesmo tempo, mas como garantir a qualidade do código "rápido"? <br>  Você ficará surpreso, mas o Flutter tem meios para não apenas garantir a qualidade do código, mas também garantir a operacionalidade da interface visual. <br>  No artigo, examinaremos como estão as coisas com os testes no Flutter, analisaremos os testes de widgets e os testes de integração do aplicativo como um todo. </p><br><p><img src="https://habrastorage.org/webt/nr/vc/tb/nrvctbv08rqv1xge9z2zknv69ym.jpeg"></p><a name="habracut"></a><br><p>  Comecei a estudar o Flutter há mais de um ano, antes de seu lançamento oficial, durante o estudo não foi um problema encontrar informações de desenvolvimento.  E quando eu queria experimentar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TDD</a> , as informações sobre os testes eram desastrosamente pequenas.  Em russo e, em geral, quase nenhum.  Os problemas de teste tiveram que ser estudados de forma independente, de acordo com o código fonte dos testes de Flutter e de artigos raros em inglês.  Tudo o que estudei sobre o teste de elementos visuais, descrevi em um artigo para ajudar aqueles que estão apenas começando a se aprofundar no tópico. </p><br><h2 id="widget-testing-vidzhet-testy">  Teste de Widget </h2><br><h3 id="obschie-svedeniya">  Informação geral </h3><br><p>  Um teste de widget testa um único widget.  Também pode ser chamado de teste de componente.  O objetivo do teste é provar que a interface do usuário do widget parece e interage conforme o planejado.  O teste de um widget requer um ambiente de teste que forneça o contexto apropriado para o ciclo de vida do widget. <br>  O widget testado tem a capacidade de receber ações e eventos do usuário e responder a eles, construir uma árvore de widgets filhos.  Portanto, os testes de widget são mais complexos que os testes de unidade.  No entanto, como o teste de unidade, o ambiente de teste de widget é uma simulação simples, muito mais simples que um sistema de interface de usuário completo. </p><br><p>  O teste de widget permite isolar e testar o comportamento de um único elemento da interface visual.  E, o que é digno de nota, para realizar todas as verificações no console, o que é ideal para testes executados como parte do processo de CI / CD. </p><br><p>  Os arquivos que contêm testes geralmente estão localizados no subdiretório de <strong>teste</strong> do projeto. <br>  Os testes podem ser executados no IDE ou no console com o comando: </p><br><pre><code class="plaintext hljs">$ flutter test</code> </pre> <br><p>  Nesse caso, todos os testes com a máscara * <strong>_test.dart</strong> do subdiretório <strong>test</strong> serão executados. <br>  Você pode executar um teste separado especificando o nome do arquivo: </p><br><pre> <code class="plaintext hljs">$ flutter test test/phone_screen_test.dart</code> </pre> <br><p>  O teste é criado pela função <strong>testWidgets</strong> , que recebe uma ferramenta como parâmetro do <strong>testador</strong> , com a qual o código de teste interage com o widget em teste: </p><br><pre> <code class="java hljs">testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><p>  Para combinar testes em blocos lógicos, as funções de teste podem ser combinadas em grupos, dentro da função de <strong>grupo</strong> : </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'  '</span></span>, (){ testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   }); testWidgets(' ', (WidgetTester tester) async { //   }); });</span></span></code> </pre> <br><p>  As <strong>funções</strong> <strong>setUp</strong> e <strong>tearDown</strong> permitem executar algum código "antes" e "depois" de cada teste.  Assim, as <strong>funções setUpAll</strong> e <strong>tearDownAll</strong> permitem executar o código "antes" e "depois" de todos os testes, e se essas funções forem chamadas dentro do grupo, elas serão chamadas "antes" e "depois" da execução de todos os testes no grupo: </p><br><pre> <code class="java hljs">setUp(() { <span class="hljs-comment"><span class="hljs-comment">//    }); tearDown(() { //    });</span></span></code> </pre> <br><h3 id="poisk-vidzhetov">  Pesquisa de widget </h3><br><p>  Para executar alguma ação em um widget aninhado, é necessário encontrá-lo na árvore de widgets.  Para fazer isso, existe um objeto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>localização</strong></a> global que permite encontrar widgets: </p><br><ul><li>  na árvore por texto - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  pela chave - <strong>find.byKey</strong> ; </li><li>  por ícone - <strong>find.byIcon</strong> , <strong>find.widgetWithIcon</strong> ; </li><li>  por tipo - <strong>find.byType</strong> ; </li><li>  pela posição na árvore - <strong>find.descendant</strong> e <strong>find.ancestor</strong> ; </li><li>  usando uma função que analisa widgets em uma lista - <strong>find.byWidgetPredicate</strong> . </li></ul><br><h3 id="vzaimodeystvie-s-testiruemym-vidzhetom">  Interação do widget de teste </h3><br><p>  A classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>WidgetTester</strong></a> fornece funções para criar um widget de teste, aguardar a alteração do estado e executar algumas ações nesses widgets. <br>  Qualquer alteração no widget causa uma alteração no seu estado.  Mas o ambiente de teste não reconstrói o widget ao mesmo tempo.  Você deve indicar independentemente ao ambiente de teste que deseja reconstruir o widget chamando as <strong>funções</strong> <strong>pump</strong> ou <strong>pumpAndSettle</strong> . </p><br><ul><li>  <strong>pumpWidget</strong> - crie um widget de teste; </li><li>  <strong>pump</strong> - inicia o processamento da transição de estado do widget e aguarda a conclusão dentro do tempo limite especificado (100 ms por padrão); </li><li>  <strong>pumpAndSettle</strong> - chama a bomba em um ciclo para alterar os estados durante um determinado tempo limite (100 ms por padrão); esta é a espera para que todas as animações sejam concluídas; </li><li>  <strong>toque</strong> - envie um clique para o widget; </li><li>  <strong>longPress</strong> - pressão longa; </li><li>  <strong>arremesso</strong> - furto / furto; </li><li>  <strong>arrastar</strong> - transferir; </li><li>  <strong>enterText</strong> - entrada de texto. </li></ul><br><p>  Os testes podem implementar cenários positivos, verificar oportunidades planejadas e negativos, para garantir que eles não levem a consequências fatais, por exemplo, quando um usuário clica na direção errada e não digita o que é necessário: </p><br><pre> <code class="java hljs">await tester.enterText(find.byKey(Key(<span class="hljs-string"><span class="hljs-string">'phoneField'</span></span>)), <span class="hljs-string"><span class="hljs-string">'bla-bla-bla'</span></span>);</code> </pre> <br><p>  Após qualquer ação com widgets, você precisa chamar <strong>tester.pumpAndSettle ()</strong> para alterar os estados. </p><br><h3 id="moki">  Moki </h3><br><p>  Muitos estão familiarizados com a biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>Mockito</strong></a> .  Essa biblioteca do mundo Java acabou sendo tão bem-sucedida que existem implementações dessa biblioteca em muitas linguagens de programação, incluindo o Dart. </p><br><p>  Para se conectar, você deve adicionar a dependência ao projeto.  Adicione as seguintes linhas ao arquivo <strong>pubspec.yaml</strong> : </p><br><pre> <code class="plaintext hljs">dependencies: mockito: any</code> </pre> <br><p>  E conecte-se no arquivo de teste: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:mockito/mockito.dart'</span></span>;</code> </pre> <br><p>  Essa biblioteca permite criar classes moque, das quais o widget testado depende, para que o teste seja mais simples e cubra apenas o código que estamos testando. <br>  Por exemplo, se testarmos o widget <strong>PhoneInputScreen</strong> , que, quando clicado, usando o serviço <strong>AuthInteractor</strong> , executa uma solicitação ao <strong>back-end</strong> authInteractor.checkAccess <strong>() e</strong> , em seguida, substituindo a simulação em vez do serviço, podemos verificar a coisa mais importante - o fato de acessar esse serviço. </p><br><p>  Os mobs de dependência são criados como descendentes da classe <strong>Mock</strong> e implementam a interface de dependência: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Uma classe no Dart também é uma interface, portanto, não há necessidade de declarar a interface separadamente, como em outras linguagens de programação. </p><br><p>  Para determinar a funcionalidade do mok, a função <strong>when</strong> é usada, o que permite determinar a resposta do mok à chamada de uma função: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.value(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre> <br><p>  Moki pode retornar erros ou dados errados: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.error(UnknownHttpStatusCode(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)));</code> </pre> <br><h3 id="proverki">  Cheques </h3><br><p>  Durante o teste, você pode verificar se há widgets na tela.  Isso permite que você verifique se o novo estado da tela está correto em termos de visibilidade dos widgets desejados: </p><br><pre> <code class="java hljs">expect(find.text(<span class="hljs-string"><span class="hljs-string">' '</span></span>), findsOneWidget); expect(find.text(<span class="hljs-string"><span class="hljs-string">'  '</span></span>), findsNothing);</code> </pre> <br><p>  Após a conclusão do teste, você também pode verificar quais métodos da classe mob foram chamados durante o teste e quantas vezes.  Isso é necessário, por exemplo, para entender se esses ou esses dados são solicitados com muita frequência, se há alterações desnecessárias no estado do aplicativo: </p><br><pre> <code class="java hljs">verify(appComponent.authInteractor).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verify(authInteractor.checkAccess(any)).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verifyNever(appComponent.profileInteractor);</code> </pre> <br><h3 id="otladka">  Depuração </h3><br><p>  Os testes são realizados no console sem nenhum gráfico.  Você pode executar testes no modo de depuração e definir pontos de interrupção no código do widget. </p><br><p>  Para ter uma idéia do que está acontecendo na árvore de widgets, você pode usar a função <strong>debugDumpApp ()</strong> , que, quando chamada no código de teste, exibe a representação textual da hierarquia de toda a árvore de widgets em um determinado momento no console. </p><br><p>  Para entender como o widget usa o moki, há uma função <strong>logInvocations ()</strong> .  Toma como parâmetro uma lista de moxas e emite para o console uma sequência de métodos que chama essas moxas que foram realizadas no teste. </p><br><p>  Um exemplo dessa conclusão está abaixo.  A marca <strong>VERIFIED</strong> está nas chamadas que foram verificadas no teste usando a função de <strong>verificação</strong> : </p><br><pre> <code class="plaintext hljs">AppComponentMock.sessionChangedInteractor [VERIFIED] AppComponentMock.authInteractor [VERIFIED] AuthInteractorMock.checkAccess(71111111111)</code> </pre> <br><h3 id="podgotovka">  Preparação </h3><br><p>  Todas as dependências devem ser enviadas ao widget testado na forma de mok: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponentMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  A transferência de dependências para o componente testado deve ser realizada de alguma maneira aceita na sua aplicação.  Para simplificar a narrativa, considere um exemplo em que as dependências são passadas pelo construtor. </p><br><p>  No exemplo de código, <strong>PhoneInputScreen</strong> é um widget de teste baseado em <strong>StatefulWidget</strong> envolvido no <strong>Scaffold</strong> .  Ele é criado em um ambiente de teste usando a função <strong>pumpWidget ()</strong> : </p><br><pre> <code class="java hljs">await tester.pumpWidget(PhoneInputScreen(mock));</code> </pre> <br><p>  No entanto, um widget real pode usar o alinhamento para widgets aninhados, o que exige o <strong>MediaQuery</strong> na árvore de widgets, provavelmente obtém <strong>Navigator.of (context)</strong> para navegação, portanto, é mais prático agrupar o widget em teste no <strong>MaterialApp</strong> ou no <strong>CupertinoApp</strong> : </p><br><pre> <code class="java hljs">await tester.pumpWidget( MaterialApp( home: PhoneInputScreen(mock), ), );</code> </pre> <br><p>  Depois de criar um widget de teste e depois de qualquer ação com ele, você precisa chamar <strong>tester.pumpAndSettle ()</strong> para que o ambiente de teste <strong>lide com</strong> todas as alterações no estado do widget. </p><br><h2 id="integration-tests-integracionnye-testy">  Testes de integração </h2><br><h3 id="obschie-svedeniya-1">  Informação geral </h3><br><p>  Diferentemente dos testes de widget, o teste de integração verifica o aplicativo inteiro ou parte dele.  O objetivo do teste de integração é garantir que todos os widgets e serviços funcionem juntos conforme o esperado.  A operação do teste de integração pode ser observada no simulador ou na tela do dispositivo.  Este método é um bom substituto para o teste manual.  Além disso, testes de integração podem ser usados ​​para testar o desempenho do aplicativo. </p><br><p>  O teste de integração geralmente é realizado em um dispositivo ou emulador real, como o iOS Simulator ou Android Emulator. </p><br><p>  Arquivos que contêm testes de integração geralmente estão localizados no subdiretório <strong>test_driver</strong> do projeto. </p><br><p>  O aplicativo é isolado do código do driver de teste e inicia após ele.  O driver de teste permite controlar o aplicativo durante o teste.  É assim: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:flutter_driver/driver_extension.dart'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:app_package_name/main.dart'</span></span> as app; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ enableFlutterDriverExtension(); app.main(); }</code> </pre> <br><p>  Os testes são executados na linha de comando.  Se o lançamento do aplicativo de destino for descrito no arquivo <strong>app.dart</strong> e o script de teste for chamado <strong>app_test.dart</strong> , o seguinte comando será suficiente: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart</code> </pre> <br><p>  Se o script de teste tiver um nome diferente, será necessário especificá-lo explicitamente: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart --driver=test_driver/home_test.dart</code> </pre> <br><p>  Um teste é criado pela função de <strong>teste</strong> e agrupado pela função de <strong>grupo</strong> . </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'park-flutter app'</span></span>, () { <span class="hljs-comment"><span class="hljs-comment">// ,       FlutterDriver driver; //     setUpAll(() async { driver = await FlutterDriver.connect(); }); //     tearDownAll(() async { if (driver != null) { driver.close(); } }); test(' ', () async { //   }); test(' ', () async { //   }); }</span></span></code> </pre> <br><p>  Este exemplo mostra o código para criar um driver de teste através do qual os testes interagem com o aplicativo em teste. </p><br><h3 id="vzaimodeystvie-s-testiruemym-prilozheniem">  Interação com o aplicativo testado </h3><br><p>  A ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>FlutterDriver</strong></a> interage com o aplicativo de teste através dos seguintes métodos: </p><br><ul><li>  <strong>toque</strong> - envie um clique para o widget; </li><li>  <strong>waitFor</strong> - aguarde o widget aparecer na tela; </li><li>  <strong>waitForAbsent</strong> - aguarde o widget desaparecer; </li><li>  <strong>scroll</strong> e <strong>scrollIntoView</strong> , <strong>scrollUntilVisible</strong> - role a tela para o deslocamento especificado ou para o widget desejado; </li><li>  <strong>enterText</strong> , <strong>getText</strong> - insira o texto ou pegue o texto do widget; </li><li>  <strong>captura de tela</strong> - obtenha uma captura de tela; </li><li>  <strong>requestData</strong> - interação mais complexa através de uma chamada de função dentro do aplicativo em teste. </li></ul><br><p>  Pode haver uma situação em que você precisa influenciar o estado global do aplicativo a partir do código de teste.  Por exemplo, para simplificar o teste de integração, substituindo parte dos serviços no aplicativo pelo moki.  No aplicativo, você pode especificar um manipulador de solicitação, que pode ser acessado por meio de uma chamada para <strong>driver.requestData ('some param')</strong> no código de teste: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg == <span class="hljs-string"><span class="hljs-string">"some param"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//       return 'some result'; } } enableFlutterDriverExtension(handler: dataHandler); app.main(); }</span></span></code> </pre> <br><h3 id="poisk-vidzhetov-1">  Pesquisa de widget </h3><br><p>  A procura de widgets durante o teste de integração com o objeto de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>localização</strong></a> global difere na composição dos métodos da funcionalidade semelhante nos testes de widgets.  No entanto, o significado geral praticamente não muda: </p><br><ul><li>  na árvore por texto - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  pela chave - <strong>find.byValueKey</strong> ; </li><li>  por tipo - <strong>find.byType</strong> ; </li><li>  no prompt - <strong>find.byTooltip</strong> ; </li><li>  por rótulo semântico - <strong>find.bySemanticsLabel</strong> ; </li><li>  por posição na árvore <strong>find.descendant</strong> e <strong>find.ancestor</strong> . </li></ul><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Vimos maneiras de organizar o teste de uma interface de aplicativo escrita usando Flutter.  Podemos implementar testes para verificar se o código atende aos requisitos das especificações técnicas e fazer testes com essa mesma tarefa.  Das deficiências observadas nos testes de integração - não há como interagir com os diálogos do sistema da plataforma.  Mas, por exemplo, as solicitações de permissões podem ser evitadas emitindo permissões da linha de comandos no estágio de instalação do aplicativo, conforme descrito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste ticket</a> . </p><br><p>  Este artigo é o ponto de partida para explorar um tópico de teste que apresenta brevemente ao leitor como o teste de interface do usuário funciona.  Ele não salva a leitura da documentação, da qual é fácil descobrir como uma determinada classe ou método funciona.  Afinal, o estudo de um novo tópico requer, antes de tudo, uma compreensão de todos os processos em andamento como um todo, sem detalhes excessivos. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468631/">https://habr.com/ru/post/pt468631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468621/index.html">Traduzimos a rede doméstica para DoH, ou outro clique no nariz do filtro</a></li>
<li><a href="../pt468623/index.html">Quero resenhas sobre Habr</a></li>
<li><a href="../pt468625/index.html">Sem servidor: 15% mais lento e oito vezes mais caro</a></li>
<li><a href="../pt468627/index.html">Módulos de E / S ADAM-6200</a></li>
<li><a href="../pt468629/index.html">Como criei um filtro que não corrompe a imagem mesmo depois de um milhão de execuções - parte 2</a></li>
<li><a href="../pt468635/index.html">Dichalcogenetos de metais de transição: desvendando os segredos do crescimento de cristais WS2</a></li>
<li><a href="../pt468637/index.html">Como lidar com grandes conjuntos de dados em pandas. Trabalhamos com o banco de dados FIAS usando python e 8 GB de memória</a></li>
<li><a href="../pt468639/index.html">Novidades nos consoles da web 2019</a></li>
<li><a href="../pt468641/index.html">Tutorial para criar solução Blockchain no Hyperledger Composer</a></li>
<li><a href="../pt468645/index.html">Duas páginas foram suficientes para provar a hipótese de 30 anos no campo da ciência da computação.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>