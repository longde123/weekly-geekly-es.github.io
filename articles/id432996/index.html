<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”¸ ğŸ‘©ğŸ¿â€ğŸš’ ğŸ‘° Sedikit kamus internal di CPython (dan PyPy) ğŸ¿ï¸ ğŸ”› ğŸ©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Struktur internal kamus dengan Python tidak terbatas pada bucket dan hashing pribadi saja. Ini adalah dunia yang luar biasa dari kunci bersama, cachin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sedikit kamus internal di CPython (dan PyPy)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432996/">  Struktur internal kamus dengan Python tidak terbatas pada bucket dan hashing pribadi saja.  Ini adalah dunia yang luar biasa dari kunci bersama, caching hash, DKIX_DUMMY dan perbandingan cepat, yang dapat dilakukan bahkan lebih cepat (dengan biaya bug dengan perkiraan probabilitas 2 ^ -64). <br><br>  Jika Anda tidak tahu jumlah elemen dalam kamus yang baru saja Anda buat, berapa banyak memori yang dihabiskan untuk setiap elemen, mengapa sekarang (CPython 3.6 dan seterusnya) kamus diimplementasikan dalam dua array dan bagaimana kaitannya dengan menjaga urutan penyisipan, atau Anda hanya tidak menonton presentasi oleh Raymond Hettinger â€œModern Python Kamus Sebuah pertemuan selusin ide-ide besar. "  Selamat datang <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p33CVV29OG8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Namun, orang-orang yang terbiasa dengan kuliah juga dapat menemukan beberapa rincian dan informasi baru, dan untuk pendatang baru yang tidak terbiasa dengan ember dan hashing tertutup, artikel ini juga akan menarik. <br><a name="habracut"></a><br>  Kamus di CPython ada di mana-mana, kelas, variabel global, parameter kwarg didasarkan pada mereka, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penerjemah menciptakan ribuan kamus</a> , bahkan jika Anda sendiri tidak menambahkan tanda kurung kurawal ke skrip Anda.  Tetapi untuk mengatasi banyak masalah yang diterapkan, kamus juga digunakan, tidak mengherankan bahwa penerapannya terus meningkat dan semakin tumbuh menjadi berbagai trik. <br><br><h2>  Implementasi dasar kamus (via Hashmap) </h2><br>  Jika Anda terbiasa dengan pekerjaan Hashmap standar dan hashing pribadi, Anda dapat melanjutkan ke bab berikutnya. <br><br>  Gagasan yang mendasari kamus sederhana: jika kita memiliki array di mana objek dengan ukuran yang sama disimpan, maka kita dengan mudah mendapatkan akses ke objek yang diinginkan, mengetahui indeks. <br><br><img src="https://habrastorage.org/webt/wq/m3/nk/wqm3nkortrkb_eyjwlorn4ahreq.png"><br><br>  Kami cukup menambahkan indeks dikalikan dengan ukuran objek ke offset array, dan kami mendapatkan alamat objek yang diinginkan. <br><br>  Tetapi bagaimana jika kita ingin mengatur pencarian bukan dengan indeks integer, tetapi dengan variabel jenis lain, misalnya, untuk menemukan pengguna di alamat email mereka? <br><br>  Dalam hal array sederhana, kita harus melihat mail dari semua pengguna dalam array dan membandingkannya dengan pencarian, pendekatan ini disebut pencarian linear dan, jelas, itu jauh lebih lambat daripada mengakses objek dengan indeks. <br><br>  Pencarian linear dapat dipercepat secara signifikan jika kami membatasi ukuran area di mana Anda ingin mencari.  Ini biasanya dicapai dengan mengambil sisa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">hash</a> .  Bidang yang dicari adalah kuncinya. <br><br><img src="https://habrastorage.org/webt/hn/1l/f4/hn1lf445vm6bnorbgvx7n5mbfos.png"><br><br>  Akibatnya, pencarian linier dilakukan bukan pada seluruh array besar, tetapi sepanjang bagiannya. <br><br>  Tetapi bagaimana jika sudah ada elemen di sana?  Ini bisa sangat baik terjadi, karena tidak ada yang menjamin bahwa residu dari membagi hash akan menjadi unik (seperti hash itu sendiri).  Dalam hal ini, objek akan ditempatkan pada indeks berikutnya, jika sibuk, itu akan bergeser oleh indeks lain dan seterusnya sampai menemukan yang bebas.  Saat mengambil item, semua kunci dengan hash yang sama akan dilihat. <br><br><img src="https://habrastorage.org/webt/8a/0d/uj/8a0dujuj4hduhrbihtpomacvg0i.png"><br><br>  Jenis hashing ini disebut pribadi.  Jika ada beberapa sel bebas dalam kamus, maka pencarian seperti itu mengancam untuk berubah menjadi linear, jadi kita akan kehilangan semua kemenangan yang diciptakan kamus, untuk menghindari ini penerjemah membuat array tetap diisi 1/2 - 2/3.  Jika tidak ada cukup sel bebas, array baru dibuat dua kali lebih besar dari yang sebelumnya dan elemen dari yang lama ditransfer ke yang baru sekaligus. <br><br>  Apa yang harus dilakukan jika item telah dihapus?  Dalam hal ini, sel kosong terbentuk dalam array dan algoritma pencarian dengan kunci tidak dapat membedakan, sel ini kosong karena elemen dengan hash seperti itu tidak ada dalam kamus, atau karena itu dihapus.  Untuk menghindari kehilangan data selama penghapusan, sel ditandai dengan bendera khusus (DKIX_DUMMY).  Jika bendera ini ditemukan selama pencarian elemen, pencarian berlanjut, sel dianggap sibuk, jika dimasukkan, sel akan ditimpa. <br><br><h2>  Fitur Implementasi dalam Python </h2><br>  Setiap elemen kamus harus berisi tautan ke objek dan kunci target.  Kunci harus disimpan untuk pemrosesan tabrakan, objek - untuk alasan yang jelas.  Karena kunci dan objek dapat dari jenis dan ukuran apa pun, kami tidak dapat menyimpannya secara langsung dalam struktur, mereka terletak di memori dinamis, dan tautan ke mereka disimpan dalam struktur item daftar.  Artinya, ukuran satu elemen harus sama dengan ukuran minimum dua pointer (16 byte pada sistem 64-bit).  Namun, juru bahasa juga menyimpan hash, ini dilakukan agar tidak menghitung ulang dengan setiap peningkatan ukuran kamus.  Alih-alih menghitung hash dari masing-masing kunci dengan cara baru dan mengambil sisa pembagian dengan jumlah ember, penerjemah hanya membaca nilai yang sudah disimpan.  Tetapi, bagaimana jika objek kunci diubah?  Dalam hal ini, hash harus dihitung ulang dan nilai yang disimpan akan salah?  Situasi seperti itu tidak mungkin, karena tipe yang bisa berubah tidak bisa menjadi kunci kamus. <br><br>  Struktur elemen kamus didefinisikan sebagai berikut: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Py_hash_t me_hash; <span class="hljs-comment"><span class="hljs-comment">//  PyObject *me_key; //    PyObject *me_value; //     } PyDictKeyEntry;</span></span></code> </pre> <br>  Ukuran minimum kamus dinyatakan oleh konstanta PyDict_MINSIZE, yaitu 8. Pengembang memutuskan bahwa ini adalah ukuran optimal untuk menghindari pemborosan memori yang tidak perlu untuk menyimpan nilai kosong dan waktu untuk ekspansi dinamis array.  Jadi, ketika membuat kamus (hingga versi 3.6), Anda memerlukan minimal 8 elemen dalam kamus * 24 byte dalam struktur = 192 byte (ini tidak memperhitungkan bidang yang tersisa: biaya variabel kamus itu sendiri, penghitung jumlah elemen, dll.) <br><br>  Kamus juga digunakan untuk mengimplementasikan bidang kelas khusus.  Python memungkinkan Anda untuk secara dinamis mengubah jumlah atribut, dinamika ini tidak memerlukan biaya tambahan, karena menambahkan / menghapus atribut pada dasarnya setara dengan operasi yang sesuai pada kamus.  Namun, sebagian kecil program menggunakan fungsi ini, sebagian besar terbatas pada bidang yang dideklarasikan dalam __init__.  Tetapi setiap objek harus menyimpan kamusnya sendiri, dengan kunci dan hashnya, meskipun fakta bahwa mereka bertepatan dengan objek lain.  Perbaikan logis di sini adalah penyimpanan kunci bersama hanya di satu tempat, yang persis seperti yang diterapkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">PEP 412 - Kamus Berbagi Kunci</a> .  Kemampuan untuk mengubah kamus secara dinamis tidak hilang: jika urutan atau jumlah kunci diubah, kamus diubah dari kunci yang membagi menjadi yang biasa. <br><br>  Untuk menghindari tabrakan, "pemuatan" maksimum kamus adalah 2/3 dari ukuran array saat ini. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USABLE_FRACTION(n) (((n) &lt;&lt; 1)/3)</span></span></code> </pre> <br>  Dengan demikian, ekstensi pertama akan terjadi ketika elemen ke-6 ditambahkan. <br><br>  Array ternyata cukup kosong, selama operasi program, dari setengah hingga sepertiga sel tetap kosong, yang mengarah pada peningkatan konsumsi memori.  Untuk menghindari batasan ini dan, jika mungkin, hanya menyimpan data yang diperlukan, <s>tingkat abstraksi</s> array baru ditambahkan. <br><br>  Alih-alih menyimpan array jarang, misalnya: <br><br><pre> <code class="python hljs"> d = {<span class="hljs-string"><span class="hljs-string">'timmy'</span></span>: <span class="hljs-string"><span class="hljs-string">'red'</span></span>, <span class="hljs-string"><span class="hljs-string">'barry'</span></span>: <span class="hljs-string"><span class="hljs-string">'green'</span></span>, <span class="hljs-string"><span class="hljs-string">'guido'</span></span>: <span class="hljs-string"><span class="hljs-string">'blue'</span></span>} <span class="hljs-comment"><span class="hljs-comment"># -&gt; entries = [['--', '--', '--'], [-8522787127447073495, 'barry', 'green'], ['--', '--', '--'], ['--', '--', '--'], ['--', '--', '--'], [-9092791511155847987, 'timmy', 'red'], ['--', '--', '--'], [-6480567542315338377, 'guido', 'blue']]</span></span></code> </pre><br>  Dimulai dengan versi 3.6, kamus disusun sebagai berikut: <br><br><pre> <code class="python hljs"> indices = [<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>] entries = [[<span class="hljs-number"><span class="hljs-number">-9092791511155847987</span></span>, <span class="hljs-string"><span class="hljs-string">'timmy'</span></span>, <span class="hljs-string"><span class="hljs-string">'red'</span></span>], [<span class="hljs-number"><span class="hljs-number">-8522787127447073495</span></span>, <span class="hljs-string"><span class="hljs-string">'barry'</span></span>, <span class="hljs-string"><span class="hljs-string">'green'</span></span>], [<span class="hljs-number"><span class="hljs-number">-6480567542315338377</span></span>, <span class="hljs-string"><span class="hljs-string">'guido'</span></span>, <span class="hljs-string"><span class="hljs-string">'blue'</span></span>]]</code> </pre><br>  Yaitu  hanya catatan yang benar-benar diperlukan yang disimpan, mereka dikeluarkan dari tabel hash dalam array yang terpisah, dan hanya indeks dari catatan yang sesuai disimpan di tabel hash.  Jika awalnya array mengambil 192 byte, sekarang hanya 80 (3 * 24-byte untuk setiap record + 8 byte untuk indeks).  Kompresi mencapai 58%. [2] <br><br>  Ukuran elemen dalam indeks juga berubah secara dinamis, awalnya itu sama dengan satu byte, yaitu seluruh array dapat ditempatkan dalam satu register, ketika indeks mulai masuk ke dalam 8 bit, kemudian elemen tersebut meluas menjadi 16 bit, kemudian elemen itu meluas menjadi 16, kemudian menjadi 32 bit.  Ada konstanta khusus DKIX_EMPTY dan DKIX_DUMMY untuk item yang kosong dan dihapus, masing-masing, indeks ekspansi ke 16 byte terjadi ketika ada lebih dari 127 item dalam kamus. <br><br>  Objek baru ditambahkan ke entri, yaitu, ketika memperluas kamus, tidak perlu memindahkannya, Anda hanya perlu menambah ukuran indeks dan memenuhi sampai melimpahi indeks. <br><br>  Ketika mengulangi kamus, array indeks tidak diperlukan, elemen dikembalikan secara berurutan dari entri, karena  elemen ditambahkan setiap kali ke akhir entri, kamus secara otomatis menyimpan urutan kemunculan elemen.  Jadi, selain mengurangi memori yang diperlukan untuk menyimpan kamus, kami menerima ekspansi dinamis yang lebih cepat dan pelestarian urutan tombol.  Mengurangi memori memang bagus, tetapi pada saat yang sama dapat meningkatkan kinerja, karena memungkinkan lebih banyak catatan untuk masuk ke cache prosesor. <br><br>  Pengembang CPython sangat menyukai implementasi ini sehingga kamus sekarang diminta untuk mempertahankan urutan penyisipan berdasarkan spesifikasi.  Jika sebelumnya urutan kamus ditentukan, mis.  itu secara ketat didefinisikan oleh hash dan tidak berubah dari awal hingga awal, kemudian sedikit keacakan ditambahkan sehingga kunci akan berbeda setiap kali, sekarang kunci kamus diperlukan untuk mempertahankan pesanan.  Berapa banyak ini diperlukan, dan apa yang harus dilakukan jika implementasi kamus yang lebih efektif muncul tetapi tidak mempertahankan urutan penyisipan, tidak jelas. <br><br>  Namun, ada permintaan untuk menerapkan mekanisme untuk menjaga deklarasi atribut di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kelas</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">kwarg</a> , dan implementasi ini memungkinkan Anda untuk menutup masalah ini tanpa mekanisme khusus. <br><br>  Begini tampilannya dalam <a href="" rel="nofollow">kode CPython</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dictkeysobject</span></span></span><span class="hljs-class"> {</span></span> Py_ssize_t dk_refcnt; <span class="hljs-comment"><span class="hljs-comment">/* Size of the hash table (dk_indices). It must be a power of 2. */</span></span> Py_ssize_t dk_size; <span class="hljs-comment"><span class="hljs-comment">/* Function to lookup in the hash table (dk_indices): - lookdict(): general-purpose, and may return DKIX_ERROR if (and only if) a comparison raises an exception. - lookdict_unicode(): specialized to Unicode string keys, comparison of which can never raise an exception; that function can never return DKIX_ERROR. - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further specialized for Unicode string keys that cannot be the &lt;dummy&gt; value. - lookdict_split(): Version of lookdict() for split tables. */</span></span> dict_lookup_func dk_lookup; <span class="hljs-comment"><span class="hljs-comment">/* Number of usable entries in dk_entries. */</span></span> Py_ssize_t dk_usable; <span class="hljs-comment"><span class="hljs-comment">/* Number of used entries in dk_entries. */</span></span> Py_ssize_t dk_nentries; <span class="hljs-comment"><span class="hljs-comment">/* Actual hash table of dk_size entries. It holds indices in dk_entries, or DKIX_EMPTY(-1) or DKIX_DUMMY(-2). Indices must be: 0 &lt;= indice &lt; USABLE_FRACTION(dk_size). The size in bytes of an indice depends on dk_size: - 1 byte if dk_size &lt;= 0xff (char*) - 2 bytes if dk_size &lt;= 0xffff (int16_t*) - 4 bytes if dk_size &lt;= 0xffffffff (int32_t*) - 8 bytes otherwise (int64_t*) Dynamically sized, SIZEOF_VOID_P is minimum. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> dk_indices[]; <span class="hljs-comment"><span class="hljs-comment">/* char is required to avoid strict aliasing. */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* "PyDictKeyEntry dk_entries[dk_usable];" array follows: see the DK_ENTRIES() macro */</span></span> };</code> </pre><br>  Tetapi iterasi lebih rumit daripada yang Anda bayangkan, ada mekanisme verifikasi tambahan bahwa kamus tidak berubah selama iterasi, salah satunya adalah versi 64-bit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dari kamus</a> yang menyimpan setiap kamus. <br><br>  Akhirnya, kami mempertimbangkan mekanisme untuk menyelesaikan tabrakan.  Masalahnya, dalam python, nilai hash mudah diprediksi: <br><br><pre> <code class="python hljs"> &gt;&gt;&gt;[hash(i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>)] [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre><br>  Dan karena ketika membuat kamus dari hash ini, sisa pembagian diambil, lalu, pada kenyataannya, mereka menentukan ke ember mana catatan akan menuju, hanya beberapa bit terakhir dari kunci (jika bilangan bulat).  Anda dapat membayangkan situasi di mana kami memiliki banyak objek "ingin" masuk ke keranjang tetangga, dalam hal ini Anda harus melihat banyak objek yang tidak pada tempatnya saat mencari.  Untuk mengurangi jumlah tabrakan dan meningkatkan jumlah bit yang menentukan ke ember mana catatan akan pergi, mekanisme berikut ini diterapkan: <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   i = i + 1 % n //   : #define PERTURB_SHIFT 5 perturb &gt;&gt;= PERTURB_SHIFT; j = (5*j) + 1 + perturb; //   j % n    </span></span></code> </pre><br>  perturb adalah variabel integer yang diinisialisasi oleh hash.  Perlu dicatat bahwa dalam kasus sejumlah besar tabrakan, diatur ulang ke nol dan indeks berikut dihitung dengan rumus: <br><br><pre> <code class="cpp hljs"> j = (<span class="hljs-number"><span class="hljs-number">5</span></span> * j + <span class="hljs-number"><span class="hljs-number">1</span></span>) % n</code> </pre><br>  Saat mengekstraksi elemen dari kamus, pencarian yang sama dilakukan: indeks slot di mana elemen harus ditempatkan dihitung, jika slot kosong, pengecualian "nilai tidak ditemukan" dilemparkan.  Jika ada nilai dalam slot ini, Anda perlu memeriksa bahwa kuncinya cocok dengan yang Anda cari, ini mungkin tidak mungkin jika terjadi tabrakan.  Namun, kuncinya dapat berupa hampir semua objek, termasuk yang operasi perbandingannya membutuhkan waktu cukup lama.  Untuk menghindari operasi perbandingan yang panjang, beberapa trik digunakan dengan Python: <br><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#   (   ,  C) def eq(key, entity): if id(key) == id(entity): return True if hash(key) != hash(entity): return False return key == entity</span></span></code> </pre><br>  pertama, pointer dibandingkan, jika pointer kunci dari objek yang diinginkan sama dengan pointer dari objek yang sedang dicari, yaitu, mereka menunjuk ke area memori yang sama, maka perbandingan segera mengembalikan true.  Tapi itu belum semuanya.  Seperti yang Anda ketahui, objek yang sama harus memiliki hash yang sama, yang berarti bahwa objek dengan hash yang berbeda tidak sama.  Setelah memeriksa pointer, hash diperiksa, jika tidak sama, false akan dikembalikan.  Dan hanya jika hash sama, perbandingan yang jujur â€‹â€‹akan dipanggil. <br><br>  Apa kemungkinan hasil seperti itu?  Tentang 2 ^ -64, tentu saja, karena mudah diprediksi nilai hash, Anda dapat dengan mudah mengambil contoh seperti itu, tetapi dalam kenyataannya, verifikasi ini tidak sering sampai seberapa banyak?  Raymond Hettinger mengumpulkan interpreter dengan mengubah operasi perbandingan terakhir dengan true return sederhana.  Yaitu  penerjemah menganggap objek sama jika hashnya sama.  Kemudian ia menetapkan tes otomatis dari banyak proyek populer pada juru bahasa ini, yang berakhir dengan sukses.  Mungkin aneh untuk menganggap objek dengan hash yang sama sama, tidak untuk tambahan memeriksa isinya, dan bergantung sepenuhnya pada hash saja, tetapi Anda melakukan ini secara teratur ketika menggunakan protokol git atau torrent.  Mereka menganggap file (blok file) sama jika hash mereka sama, yang mungkin menyebabkan kesalahan, tetapi pembuatnya (dan kita semua) berharap perlu dicatat, tanpa alasan, bahwa kemungkinan tabrakan sangat kecil. <br><br>  Sekarang Anda akhirnya harus memahami struktur kamus, yang terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> PyObject_HEAD <span class="hljs-comment"><span class="hljs-comment">/* Number of items in the dictionary */</span></span> Py_ssize_t ma_used; <span class="hljs-comment"><span class="hljs-comment">/* Dictionary version: globally unique, value change each time the dictionary is modified */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> ma_version_tag; PyDictKeysObject *ma_keys; <span class="hljs-comment"><span class="hljs-comment">/* If ma_values is NULL, the table is "combined": keys and values are stored in ma_keys. If ma_values is not NULL, the table is splitted: keys are stored in ma_keys and values are stored in ma_values */</span></span> PyObject **ma_values; } PyDictObject;</code> </pre><br><h2>  Perubahan di masa depan </h2><br>  Pada bab sebelumnya, kami mempertimbangkan apa yang telah diterapkan dan dapat digunakan oleh semua orang dalam pekerjaan mereka, tetapi perbaikannya, tentu saja, tidak terbatas pada: rencana untuk versi 3.8 termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">dukungan untuk kamus terbalik</a> .  Memang, tidak ada yang mencegah, bukan iterasi dari awal array elemen dan peningkatan indeks, mulai dari akhir dan penurunan indeks. <br><br><h2>  Bahan tambahan </h2><br>  Untuk perendaman yang lebih dalam dalam topik ini, disarankan untuk membiasakan diri dengan materi-materi berikut: <br><br><ol><li>  Rekam laporan di awal artikel </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Proposal untuk implementasi kamus baru</a> </li><li>  <a href="" rel="nofollow">Kode Sumber Kamus dalam CPython</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432996/">https://habr.com/ru/post/id432996/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432986/index.html">C vs Go loop dan matematika sederhana</a></li>
<li><a href="../id432988/index.html">Webmaster kedelapan. Langsung di HabrÃ©</a></li>
<li><a href="../id432990/index.html">Lampu Kayu Edison yang Diaktifkan Suara. Harga masalah $ 5</a></li>
<li><a href="../id432992/index.html">Dia memakai headphone dan mati: kita berurusan dengan kematian aneh seorang anak sekolah di Rimbau</a></li>
<li><a href="../id432994/index.html">Vivaldi 2.2 - Kuantitas Mengubah ke Kualitas</a></li>
<li><a href="../id432998/index.html">Cerita natal</a></li>
<li><a href="../id433000/index.html">Kompilasi Kotlin: JetBrains VS ANTLR VS JavaCC</a></li>
<li><a href="../id433002/index.html">Ayo dirimu sendiri ... atau aturan komunikasi dalam tim</a></li>
<li><a href="../id433004/index.html">Strategi migrasi awan yang kuat untuk tips 2019: 7</a></li>
<li><a href="../id433008/index.html">Perangkat USB adalah ancaman "mendadak"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>