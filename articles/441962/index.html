<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚¨úÔ∏è üöÉ üéâ √çndices en PostgreSQL - 1 üê´ üöú ‚õπüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Esta serie de art√≠culos se ocupa en gran medida de los √≠ndices en PostgreSQL. 

 Cualquier tema puede ser considerado desde diferentes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>√çndices en PostgreSQL - 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/441962/"><h1>  Introduccion </h1><br>  Esta serie de art√≠culos se ocupa en gran medida de los √≠ndices en PostgreSQL. <br><br>  Cualquier tema puede ser considerado desde diferentes perspectivas.  Discutiremos asuntos que deber√≠an interesar a un desarrollador de aplicaciones que usa DBMS: qu√© √≠ndices est√°n disponibles, por qu√© hay tantos tipos diferentes de ellos y c√≥mo usarlos para acelerar las consultas.  El tema probablemente se puede cubrir en menos palabras, pero en secreto esperamos un desarrollador curioso, que tambi√©n est√© interesado en los detalles de las partes internas, especialmente porque la comprensi√≥n de dichos detalles le permite no solo diferir el juicio de los dem√°s, sino tambi√©n sacar conclusiones de los tuyos <br><br>  El desarrollo de nuevos tipos de √≠ndices est√° fuera del alcance.  Esto requiere conocimiento del lenguaje de programaci√≥n C y pertenece a la experiencia de un programador de sistemas en lugar de un desarrollador de aplicaciones.  Por la misma raz√≥n, casi no discutiremos las interfaces de programaci√≥n, sino que nos centraremos solo en lo que importa para trabajar con √≠ndices listos para usar. <br><br>  En este art√≠culo discutiremos la distribuci√≥n de responsabilidades entre el <strong>motor de indexaci√≥n general</strong> relacionado con el n√∫cleo DBMS y los m√©todos de acceso al √≠ndice individual, que PostgreSQL nos permite agregar como extensiones.  En el pr√≥ximo art√≠culo discutiremos la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">interfaz del m√©todo de acceso</a> y conceptos cr√≠ticos como clases y familias de operadores.  Despu√©s de esa introducci√≥n larga pero necesaria, consideraremos los detalles de la estructura y la aplicaci√≥n de diferentes tipos de √≠ndices: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hash</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">B-tree</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SP-GiST</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GIN</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RUM</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BRIN</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Bloom</a> . <br><br><blockquote>  Antes de comenzar, me gustar√≠a agradecer a Elena Indrupskaya por traducir los art√≠culos al ingl√©s. <br>  Las cosas han cambiado un poco desde la publicaci√≥n original.  Mis comentarios sobre el estado actual de las cosas se indican as√≠. </blockquote><a name="habracut"></a><br><h2>  √çndices </h2><br>  En PostgreSQL, los √≠ndices son objetos especiales de la base de datos dise√±ados principalmente para acelerar el acceso a los datos.  Son estructuras auxiliares: cada √≠ndice se puede eliminar y volver a crear a partir de la informaci√≥n de la tabla.  Es posible que a veces escuche que un DBMS puede funcionar sin √≠ndices, aunque lentamente.  Sin embargo, este no es el caso, ya que los √≠ndices tambi√©n sirven para imponer algunas restricciones de integridad. <br><br>  Actualmente, seis tipos diferentes de √≠ndices est√°n integrados en PostgreSQL 9.6, y un √≠ndice m√°s est√° disponible como una extensi√≥n, gracias a cambios significativos en la versi√≥n 9.6.  Entonces, espere nuevos tipos de √≠ndices en un futuro cercano. <br><br>  A pesar de todas las diferencias entre los tipos de √≠ndices (tambi√©n llamados m√©todos de acceso), cada uno de ellos finalmente asocia una clave (por ejemplo, el valor de la columna indexada) con las filas de la tabla que contienen esta clave.  Cada fila se identifica por TID (tuple id), que consiste en el n√∫mero de bloque en el archivo y la posici√≥n de la fila dentro del bloque.  Dicho esto, con la clave conocida o alguna informaci√≥n al respecto, podemos leer r√°pidamente esas filas que pueden contener la informaci√≥n de nuestro inter√©s sin escanear toda la tabla. <br><br>  Es importante comprender que un √≠ndice acelera el acceso a los datos a un costo de mantenimiento determinado.  Para cada operaci√≥n en datos indexados, ya sea inserci√≥n, eliminaci√≥n o actualizaci√≥n de filas de la tabla, los √≠ndices para esa tabla tambi√©n deben actualizarse y en la misma transacci√≥n.  Tenga en cuenta que la actualizaci√≥n de los campos de la tabla para los que no se han creado √≠ndices no da como resultado la actualizaci√≥n del √≠ndice;  Esta t√©cnica se llama HOT (Tuplas de solo almacenamiento din√°mico). <br><br>  La extensibilidad conlleva algunas implicaciones.  Para permitir la adici√≥n f√°cil de un nuevo m√©todo de acceso al sistema, se implement√≥ una interfaz del motor de indexaci√≥n general.  Su tarea principal es obtener los TID del m√©todo de acceso y trabajar con ellos: <br><br><ul><li>  Lea los datos de las versiones correspondientes de las filas de la tabla. </li><li>  Obtenga versiones de fila TID por TID o en un lote utilizando un mapa de bits preconstruido. </li><li>  Verifique la visibilidad de las versiones de fila para la transacci√≥n actual teniendo en cuenta su nivel de aislamiento. </li></ul><br>  El motor de indexaci√≥n participa en la realizaci√≥n de consultas.  Se llama de acuerdo con un plan creado en la etapa de optimizaci√≥n.  El optimizador, clasificando y evaluando diferentes formas de realizar la consulta, debe comprender las capacidades de todos los m√©todos de acceso que son potencialmente aplicables.  ¬øEl m√©todo podr√° devolver datos en el orden necesario o deber√≠amos anticipar la clasificaci√≥n?  ¬øPodemos usar este m√©todo para buscar NULL?  Estos son problemas que el optimizador est√° resolviendo regularmente. <br><br>  No solo el optimizador necesita informaci√≥n sobre el m√©todo de acceso.  Al crear un √≠ndice, el sistema debe decidir si el √≠ndice se puede construir en varias columnas y si este √≠ndice garantiza la unicidad. <br><br>  Por lo tanto, cada m√©todo de acceso debe proporcionar toda la informaci√≥n necesaria sobre s√≠ mismo.  Las versiones inferiores a 9.6 usaban la tabla "pg_am" para esto, mientras que a partir de la versi√≥n 9.6 los datos se mov√≠an a niveles m√°s profundos, dentro de funciones especiales.  Nos familiarizaremos con esta interfaz un poco m√°s. <br><br>  Todo lo dem√°s es tarea del m√©todo de acceso: <br><br><ul><li>  Implemente un algoritmo para construir el √≠ndice y mapear los datos en p√°ginas (para que el administrador de cach√© de b√∫fer procese uniformemente cada √≠ndice). </li><li>  Busque informaci√≥n en el √≠ndice por un predicado en la forma " <em>expresi√≥n de operador de campo indexado</em> ". </li><li>  Evaluar el costo de uso del √≠ndice. </li><li>  Manipule los bloqueos necesarios para el correcto procesamiento paralelo. </li><li>  Generar registros de escritura anticipada (WAL). </li></ul><br>  Primero consideraremos las capacidades del motor de indexaci√≥n general y luego consideraremos diferentes m√©todos de acceso. <br><br><h2>  Motor de indexaci√≥n </h2><br>  El motor de indexaci√≥n permite a PostgreSQL trabajar con varios m√©todos de acceso de manera uniforme, pero teniendo en cuenta sus caracter√≠sticas. <br><br><h3>  Principales t√©cnicas de escaneo </h3><br><h4>  Exploraci√≥n de √≠ndice </h4><br>  Podemos trabajar de manera diferente con los TID proporcionados por un √≠ndice.  Consideremos un ejemplo: <br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(a <span class="hljs-type"><span class="hljs-type">integer</span></span>, b <span class="hljs-type"><span class="hljs-type">text</span></span>, c <span class="hljs-type"><span class="hljs-type">boolean</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t(a,b,c) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.id, chr((<span class="hljs-number"><span class="hljs-number">32</span></span>+random()*<span class="hljs-number"><span class="hljs-number">94</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), random() &lt; <span class="hljs-number"><span class="hljs-number">0.01</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> s(id) <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> random(); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre> <br>  Creamos una tabla de tres campos.  El primer campo contiene n√∫meros del 1 al 100.000, y se crea un √≠ndice (sin importar el tipo) en este campo.  El segundo campo contiene varios caracteres ASCII, excepto los no imprimibles.  Finalmente, el tercer campo contiene un valor l√≥gico que es verdadero para aproximadamente el 1% de las filas y falso para el resto.  Las filas se insertan en la tabla en un orden aleatorio. <br><br>  Intentemos seleccionar un valor por la condici√≥n "a = 1".  Tenga en cuenta que la condici√≥n se ve como " <em>expresi√≥n de operador de campo indexado</em> ", donde el <em>operador</em> es "igual" y la <em>expresi√≥n</em> (clave de b√∫squeda) es "1".  En la mayor√≠a de los casos, la condici√≥n debe verse as√≠ para que se utilice el √≠ndice. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t Index Cond: (a = 1) (2 rows)</code> </pre><br>  En este caso, el optimizador decidi√≥ usar el <em>escaneo de √≠ndice</em> .  Con el escaneo de √≠ndice, el m√©todo de acceso devuelve los valores TID uno por uno hasta que se alcanza la √∫ltima fila coincidente.  El motor de indexaci√≥n accede a las filas de la tabla indicadas por TID a su vez, obtiene la versi√≥n de la fila, verifica su visibilidad con respecto a las reglas de concurrencia multiversion y devuelve los datos obtenidos. <br><br><h4>  Escaneo de mapa de bits </h4><br>  El escaneo de √≠ndice funciona bien cuando tratamos solo con unos pocos valores.  Sin embargo, a medida que aumenta el n√∫mero de filas recuperadas, es m√°s probable que vuelva a la misma p√°gina de la tabla varias veces.  Por lo tanto, el optimizador cambia al <em>escaneo de mapa de bits</em> . <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  El m√©todo de acceso primero devuelve todos los TID que coinciden con la condici√≥n (nodo de exploraci√≥n de √≠ndice de mapa de bits), y el mapa de bits de las versiones de fila se crea a partir de estos TID.  Las versiones de fila se leen de la tabla (An√°lisis de mont√≥n de mapa de bits), y cada p√°gina se lee solo una vez. <br><br>  Tenga en cuenta que en el segundo paso, la condici√≥n puede volver a comprobarse (Volver a comprobar Cond).  El n√∫mero de filas recuperadas puede ser demasiado grande para que el mapa de bits de las versiones de fila se ajuste completamente a la RAM (limitado por el par√°metro "work_mem").  En este caso, el mapa de bits solo se crea para p√°ginas que contienen al menos una versi√≥n de fila coincidente.  Este mapa de bits "con p√©rdida" requiere menos espacio, pero al leer una p√°gina, debemos volver a verificar las condiciones para cada fila contenida all√≠.  Tenga en cuenta que incluso para un peque√±o n√∫mero de filas recuperadas y, por lo tanto, mapa de bits "exacto" (como en nuestro ejemplo), el paso "Recheck Cond" est√° representado en el plan de todos modos, aunque en realidad no se realiza. <br><br>  Si se imponen condiciones en varios campos de la tabla y estos campos est√°n indexados, el escaneo de mapa de bits permite el uso de varios √≠ndices simult√°neamente (si el optimizador lo considera eficiente).  Para cada √≠ndice, se crean mapas de bits de versiones de fila, para lo cual se realiza la multiplicaci√≥n booleana a nivel de bit (si las expresiones est√°n unidas por AND) o la suma booleana (si las expresiones est√°n unidas por OR).  Por ejemplo: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: ((a &lt;= 100) AND (b = 'a'::text)) -&gt; BitmapAnd -&gt; Bitmap Index Scan on t_a_idx Index Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_b_idx Index Cond: (b = 'a'::text) (7 rows)</code> </pre><br>  Aqu√≠ el nodo BitmapAnd une dos mapas de bits mediante la operaci√≥n bit a bit "y". <br><br>  El escaneo de mapa de bits nos permite evitar accesos repetidos a la misma p√°gina de datos.  Pero, ¬øqu√© pasa si los datos en las p√°ginas de la tabla se ordenan f√≠sicamente exactamente de la misma manera que los registros de √≠ndice?  Es indudable que no podemos confiar plenamente en el orden f√≠sico de los datos en las p√°ginas.  Si se necesitan datos ordenados, debemos especificar expl√≠citamente la cl√°usula ORDER BY en la consulta.  Pero es probable que haya situaciones en las que realmente se ordenan "casi todos" los datos: por ejemplo, si se agregan filas en el orden necesario y no cambian despu√©s de eso o despu√©s de ejecutar el comando CLUSTER.  En casos como este, construir un mapa de bits es un paso excesivo, y un escaneo de √≠ndice regular ser√° igual de bueno (a menos que tengamos en cuenta la posibilidad de unir varios √≠ndices).  Por lo tanto, al elegir un m√©todo de acceso, el planificador examina una estad√≠stica especial que muestra la correlaci√≥n entre el orden f√≠sico de las filas y el orden l√≥gico de los valores de las columnas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> attname, correlation <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | correlation ---------+------------- b | 0.533512 c | 0.942365 a | -0.00768816 (3 rows)</code> </pre><br>  Los valores absolutos cercanos a uno indican una alta correlaci√≥n (como para la columna "c"), mientras que los valores cercanos a cero, por el contrario, indican una distribuci√≥n ca√≥tica (columna "a"). <br><br><h4>  Exploraci√≥n secuencial </h4><br>  Para completar la imagen, debemos tener en cuenta que con una condici√≥n no selectiva, el optimizador tendr√° raz√≥n al preferir el escaneo secuencial de toda la tabla al uso del √≠ndice: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">40000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------ Seq Scan on t Filter: (a &lt;= 40000) (2 rows)</code> </pre><br>  La cuesti√≥n es que los √≠ndices funcionan mejor cuanto mayor sea la selectividad de la condici√≥n, es decir, menos filas coinciden.  El crecimiento del n√∫mero de filas recuperadas aumenta los costos generales de la lectura de las p√°ginas de √≠ndice. <br><br>  Los escaneos secuenciales son m√°s r√°pidos que los escaneos aleatorios agravan la situaci√≥n.  Esto se aplica especialmente a los discos duros, donde la operaci√≥n mec√°nica de llevar un cabezal magn√©tico a una pista lleva mucho m√°s tiempo que la lectura de datos.  Este efecto es menos notable para SSD.  Hay dos par√°metros disponibles para tener en cuenta las diferencias en los costos de acceso, "seq_page_cost" y "random_page_cost", que podemos establecer no solo globalmente, sino a nivel de espacios de tabla, de esta forma ajust√°ndonos a las caracter√≠sticas de los diferentes subsistemas de disco. <br><br><h3>  Cubriendo √≠ndices </h3><br>  Como regla general, la tarea principal de un m√©todo de acceso es devolver los identificadores de las filas de la tabla coincidentes para que el motor de indexaci√≥n lea los datos necesarios de estas filas.  Pero, ¬øqu√© sucede si el √≠ndice ya contiene todos los datos necesarios para la consulta?  Tal √≠ndice se llama <em>cobertura</em> , y en este caso, el optimizador puede aplicar el <em>escaneo de solo √≠ndice</em> : <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">vacuum</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------ Index Only Scan using t_a_idx on t Index Cond: (a &lt; 100) (2 rows)</code> </pre><br>  Este nombre puede dar una idea de que el motor de indexaci√≥n no accede a la tabla y obtiene toda la informaci√≥n necesaria solo del m√©todo de acceso.  Pero este no es exactamente el caso, ya que los √≠ndices en PostgreSQL no almacenan informaci√≥n que nos permita juzgar la visibilidad de la fila.  Por lo tanto, un m√©todo de acceso devuelve versiones de filas que coinciden con la condici√≥n de b√∫squeda, independientemente de su visibilidad en la transacci√≥n actual. <br><br>  Sin embargo, si el motor de indexaci√≥n necesitara mirar la tabla para ver la visibilidad cada vez, este m√©todo de escaneo no habr√≠a sido diferente de un escaneo de √≠ndice regular. <br><br>  Para resolver el problema, para las tablas PostgreSQL mantiene un denominado <em>mapa de visibilidad</em> en el que el vac√≠o marca las p√°ginas donde los datos no se modificaron lo suficiente como para que todas las transacciones puedan ver estos datos, independientemente de la hora de inicio y el nivel de aislamiento.  Si el identificador de una fila devuelta por el √≠ndice se relaciona con dicha p√°gina, se puede evitar la verificaci√≥n de visibilidad. <br><br>  Por lo tanto, la aspiraci√≥n regular aumenta la eficiencia de los √≠ndices de cobertura.  Adem√°s, el optimizador tiene en cuenta la cantidad de tuplas muertas y puede decidir no utilizar el escaneo de solo √≠ndice si predice altos costos generales para la verificaci√≥n de visibilidad. <br><br>  Podemos aprender el n√∫mero de accesos forzados a una tabla usando el comando EXPLAIN ANALYZE: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------- Index Only Scan using t_a_idx on t (actual time=0.025..0.036 rows=99 loops=1) Index Cond: (a &lt; 100) Heap Fetches: 0 Planning time: 0.092 ms Execution time: 0.059 ms (5 rows)</code> </pre><br>  En este caso, no era necesario acceder a la tabla (Heap Fetches: 0), ya que se acaba de pasar la aspiradora.  En general, cuanto m√°s cercano sea este n√∫mero a cero, mejor. <br><br>  No todos los √≠ndices almacenan valores indexados junto con identificadores de fila.  Si el m√©todo de acceso no puede devolver los datos, no puede usarse para escaneos de solo √≠ndice. <br><br><blockquote>  PostgreSQL 11 ha introducido una nueva caracter√≠stica: INCLUDE-indexes.  ¬øQu√© sucede si hay un √≠ndice √∫nico que carece de algunas columnas para ser utilizado como √≠ndice de cobertura para alguna consulta?  No puede simplemente agregar las columnas al √≠ndice, ya que romper√° su singularidad.  La funci√≥n permite incluir columnas <em>sin clave</em> que no afectan la unicidad y no pueden usarse en predicados de b√∫squeda, pero a√∫n pueden servir escaneos de solo √≠ndice.  El parche fue desarrollado por mi colega Anastasia Lubennikova. <br></blockquote><br><h3>  Nulo </h3><br>  Los NULL juegan un papel importante en las bases de datos relacionales como una forma conveniente de representar un valor inexistente o desconocido. <br><br>  Pero un valor especial es especial para tratar.  Un √°lgebra booleana regular se vuelve ternaria;  no est√° claro si NULL deber√≠a ser m√°s peque√±o o m√°s grande que los valores regulares (esto requiere construcciones especiales para la clasificaci√≥n, NULLS FIRST y NULLS LAST);  no es evidente si las funciones agregadas deber√≠an considerar NULL o no;  Se necesita una estad√≠stica especial para el planificador ... <br><br>  Desde la perspectiva del √≠ndice de soporte, tampoco est√° claro si necesitamos indexar estos valores o no.  Si los NULL no est√°n indexados, el √≠ndice puede ser m√°s compacto.  Pero si los NULL est√°n indexados, podremos usar el √≠ndice para condiciones como " <em>el campo indexado</em> IS [NOT] NULL" y tambi√©n como un √≠ndice de cobertura cuando no se especifican condiciones para la tabla (ya que en este caso, el index debe devolver los datos de todas las filas de la tabla, incluidas aquellas con NULL). <br><br>  Para cada m√©todo de acceso, los desarrolladores toman una decisi√≥n individual de indexar NULL o no.  Pero, por regla general, se indexan. <br><br><h3>  √çndices en varios campos </h3><br>  Para admitir condiciones para varios campos, se pueden usar <em>√≠ndices de</em> varias <em>columnas</em> .  Por ejemplo, podr√≠amos construir un √≠ndice en dos campos de nuestra tabla: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a,b); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  Lo m√°s probable es que el optimizador prefiera este √≠ndice a unirse a los mapas de bits, ya que aqu√≠ obtenemos f√°cilmente los TID necesarios sin ninguna operaci√≥n auxiliar: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------ Index Scan using t_a_b_idx on t Index Cond: ((a &lt;= 100) AND (b = 'a'::text)) (2 rows)</code> </pre><br>  Un √≠ndice de varias columnas tambi√©n se puede utilizar para acelerar la recuperaci√≥n de datos por una condici√≥n para algunos de los campos, comenzando por el primero: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------- Bitmap Heap Scan on t Recheck Cond: (a &lt;= 100) -&gt; Bitmap Index Scan on t_a_b_idx Index Cond: (a &lt;= 100) (4 rows)</code> </pre><br>  En general, si la condici√≥n no se impone en el primer campo, el √≠ndice no se utilizar√°.  Pero a veces el optimizador puede considerar el uso del √≠ndice como m√°s eficiente que la exploraci√≥n secuencial.  Ampliaremos este tema cuando consideremos los √≠ndices "btree". <br><br>  No todos los m√©todos de acceso admiten la creaci√≥n de √≠ndices en varias columnas. <br><br><h3>  √çndices sobre expresiones </h3><br>  Ya hemos mencionado que la condici√≥n de b√∫squeda debe verse como " <em>expresi√≥n de operador de campo indexado</em> ".  En el siguiente ejemplo, el √≠ndice no se usar√° ya que se usa una expresi√≥n que contiene el nombre del campo en lugar del nombre del campo en s√≠: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------ Seq Scan on t Filter: (lower((b)::text) = 'a'::text) (2 rows)</code> </pre><br>  No es necesario reescribir esta consulta espec√≠fica para que solo el nombre del campo se escriba a la izquierda del operador.  Pero si esto no es posible, los √≠ndices en expresiones (√≠ndices funcionales) ayudar√°n: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(lower(b)); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> lower(b) = <span class="hljs-string"><span class="hljs-string">'a'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------- Bitmap Heap Scan on t Recheck Cond: (lower((b)::text) = 'a'::text) -&gt; Bitmap Index Scan on t_lower_idx Index Cond: (lower((b)::text) = 'a'::text) (4 rows)</code> </pre><br>  El √≠ndice funcional no se crea en un campo de tabla, sino en una expresi√≥n arbitraria.  El optimizador considerar√° este √≠ndice para condiciones como " <em>expresi√≥n de operador de expresi√≥n indexada</em> ".  Si el c√°lculo de la expresi√≥n a indexar es una operaci√≥n costosa, la actualizaci√≥n del √≠ndice tambi√©n requerir√° importantes recursos de c√°lculo. <br><br>  Tenga en cuenta tambi√©n que se recopila una estad√≠stica individual para la expresi√≥n indexada.  Podemos conocer esta estad√≠stica en la vista "pg_stats" por el nombre del √≠ndice: <br><br><pre> <code class="pgsql hljs">postgres=# \dt</code> </pre><pre> <code class="plaintext hljs"> Table "public.t" Column | Type | Modifiers --------+---------+----------- a | integer | b | text | c | boolean | Indexes: "t_a_b_idx" btree (a, b) "t_a_idx" btree (a) "t_b_idx" btree (b) "t_lower_idx" btree (lower(b))</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_stats <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tablename = <span class="hljs-string"><span class="hljs-string">'t_lower_idx'</span></span>;</code> </pre><br>  Es posible, si es necesario, controlar el n√∫mero de cestas de histograma de la misma manera que para los campos de datos regulares (observando que el nombre de la columna puede diferir dependiendo de la expresi√≥n indexada): <br><br><pre> <code class="pgsql hljs">postgres=# \d t_lower_idx</code> </pre><pre> <code class="plaintext hljs"> Index "public.t_lower_idx" Column | Type | Definition --------+------+------------ lower | text | lower(b) btree, for table "public.t"</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_lower_idx <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> "lower" <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">statistics</span></span> <span class="hljs-number"><span class="hljs-number">69</span></span>;</code> </pre><br><blockquote>  PostgreSQL 11 ha introducido una forma m√°s limpia de controlar el objetivo de estad√≠sticas para √≠ndices especificando el <em>n√∫mero de</em> columna en el comando ALTER INDEX ... SET STATISTICS.  El parche fue desarrollado por mi colega Alexander Korotkov y Adrien Nayrat. </blockquote><br><h3>  √çndices parciales </h3><br>  A veces surge la necesidad de indexar solo parte de las filas de la tabla.  Esto generalmente est√° relacionado con una distribuci√≥n altamente no uniforme: tiene sentido buscar un valor poco frecuente por un √≠ndice, pero es m√°s f√°cil encontrar un valor frecuente mediante el escaneo completo de la tabla. <br><br>  Ciertamente podemos construir un √≠ndice regular en la columna "c", que funcionar√° de la manera que esperamos: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_c_idx on t Index Cond: (c = true) Filter: c (3 rows)</code> </pre><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> c;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------- Seq Scan on t Filter: (NOT c) (2 rows)</code> </pre><br>  Y el tama√±o del √≠ndice es de 276 p√°ginas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 276 (1 row)</code> </pre><br>  Pero como la columna "c" tiene el valor de verdadero solo para el 1% de las filas, el 99% del √≠ndice en realidad nunca se usa.  En este caso, podemos construir un √≠ndice parcial: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(c) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> t;</code> </pre><br>  El tama√±o del √≠ndice se reduce a 5 p√°ginas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> relpages <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relname=<span class="hljs-string"><span class="hljs-string">'t_c_idx1'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relpages ---------- 5 (1 row)</code> </pre><br>  A veces, la diferencia en el tama√±o y el rendimiento puede ser bastante significativa. <br><br><h3>  Clasificaci√≥n </h3><br>  Si un m√©todo de acceso devuelve identificadores de fila en un orden particular, esto le brinda al optimizador opciones adicionales para realizar la consulta. <br><br>  Podemos escanear la tabla y luego ordenar los datos: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------- Sort Sort Key: a -&gt; Seq Scan on t (3 rows)</code> </pre><br>  Pero podemos leer los datos usando el √≠ndice f√°cilmente en el orden deseado: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_indexscan=<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> a;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------- Index Scan using t_a_idx on t (1 row)</code> </pre><br>  Solo "btree" de todos los m√©todos de acceso puede devolver datos ordenados, as√≠ que pospongamos una discusi√≥n m√°s detallada hasta considerar este tipo de √≠ndice. <br><br><h3>  Edificio concurrente </h3><br>  Por lo general, la creaci√≥n de un √≠ndice adquiere un bloqueo COMPARTIR para la tabla.  Este bloqueo permite leer datos de la tabla, pero proh√≠be cualquier cambio mientras se construye el √≠ndice. <br><br>  Podemos asegurarnos de esto si, por ejemplo, durante la creaci√≥n de un √≠ndice en la tabla "t", realizamos la consulta a continuaci√≥n en otra sesi√≥n: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> mode, granted <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> relation = <span class="hljs-string"><span class="hljs-string">'t'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>;</code> </pre><pre> <code class="plaintext hljs"> mode | granted -----------+--------- ShareLock | t (1 row)</code> </pre><br>  Si la tabla es lo suficientemente grande y se usa ampliamente para la inserci√≥n, actualizaci√≥n o eliminaci√≥n, esto puede parecer inadmisible ya que los procesos de modificaci√≥n esperar√°n a que se libere el bloqueo durante mucho tiempo. <br><br>  En este caso, podemos usar la construcci√≥n concurrente de un √≠ndice. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">concurrently</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(a);</code> </pre><br>  Este comando bloquea la tabla en el modo COMPARTIR EXCLUSIVA ACTUALIZACI√ìN, lo que permite tanto la lectura como la actualizaci√≥n (solo est√° prohibido cambiar la estructura de la tabla, as√≠ como la aspiraci√≥n, el an√°lisis o la creaci√≥n simult√°nea de otro √≠ndice en esta tabla). <br><br>  Sin embargo, tambi√©n hay otro lado negativo.  Primero, el √≠ndice se construir√° m√°s lentamente de lo habitual ya que se realizan dos pases a trav√©s de la tabla en lugar de uno, y tambi√©n es necesario esperar la finalizaci√≥n de las transacciones paralelas que modifican los datos. <br><br>  Segundo, con la construcci√≥n concurrente del √≠ndice, puede ocurrir un punto muerto o pueden violarse restricciones √∫nicas.  Sin embargo, el √≠ndice se construir√°, aunque no operar√°.  Tal √≠ndice debe ser eliminado y reconstruido.  Los √≠ndices que no funcionan est√°n marcados con la palabra NO V√ÅLIDA en la salida del comando psql \ d, y la siguiente consulta devuelve una lista completa de esos: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> index_name, indrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table_name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> indisvalid;</code> </pre><pre> <code class="plaintext hljs"> index_name | table_name ------------+------------ t_a_idx | t (1 row)</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sigue leyendo</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441962/">https://habr.com/ru/post/441962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441946/index.html">API REST en Laravel en 100 l√≠neas de c√≥digo</a></li>
<li><a href="../441950/index.html">Eclipse Che 7 ya est√° aqu√≠</a></li>
<li><a href="../441952/index.html">Elegir un sistema de almacenamiento de archivos para trabajar en equipo</a></li>
<li><a href="../441954/index.html">Recompensa del usuario a los autores de Habr</a></li>
<li><a href="../441956/index.html">Manejo unificado de errores (opci√≥n C ++ para microcontroladores)</a></li>
<li><a href="../441964/index.html">Consejos y trucos de Kubernetes: reubicar recursos del cl√∫ster en Helm 2</a></li>
<li><a href="../441966/index.html">Kit de inicio de pruebas de seguridad web</a></li>
<li><a href="../441968/index.html">Desarrollo de una nueva rama de producto: c√≥mo deshacerse de lo poco pr√°ctico y seguir siendo √∫til</a></li>
<li><a href="../441970/index.html">An√°lisis FinFisher Butkit</a></li>
<li><a href="../441972/index.html">Invidious - interfaz de YouTube alternativa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>