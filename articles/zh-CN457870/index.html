<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⭕️ 🤗 📡 使用Docker构建项目基础架构 🎾 🏬 👀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr上已经有关于如何配置docker- container进行项目编译的材料。 例如， 使用Docker构建和运行C ++项目 。 在本文中，与前一篇文章一样，将讨论构建项目的问题，但是在这里，我想超越本教程，更深入地考虑在此类任务中使用容器以及使用docker构建构建基础结构的问题。 
 关于...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Docker构建项目基础架构</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457870/"><p>  Habr上已经有关于如何配置<strong>docker-</strong> container进行项目编译的材料。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用Docker构建和运行C ++项目</a> 。 在本文中，与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">前</a>一篇文章一样<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>将讨论构建项目的问题，但是在这里，我想超越本教程，更深入地考虑在此类任务中使用容器以及使用<strong>docker</strong>构建构建基础结构的问题。 </p><a name="habracut"></a><br><h2 id="nemnogo-o-docker"> 关于Docker的一些知识 </h2><br><p> 为了使讨论更加清晰，有必要提供一些<strong>docker</strong>组件的描述。 </p><br><h3 id="image"> 图片 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Docker映像</a>是一个<strong>只读</strong>模板，其中包含创建容器的说明。 为了构建<strong>映像，</strong>您需要创建一个<strong>Dockerfile</strong> ，它描述了组装的所有步骤。 每个这样的步骤都会在<strong>图像</strong>内部创建一个单独的层。 每个后续层都叠加在所有先前层之上，并且仅包含需要对先前层进行的更改。 </p><br><p> 例如，对于<strong>Dockerfile</strong> ： </p><br><pre><code class="plaintext hljs">FROM ubuntu:18.04 ADD app.sh /app ENTRYPOINT /bin/bash /app/app.sh</code> </pre> <br><p>  <strong>泊坞窗</strong>映像将具有以下结构： </p><br><p><img src="https://habrastorage.org/webt/va/pv/rh/vapvrhrjuhirk1fw2up-_h-osau.png"></p><br><p>  <strong>图像</strong>内的图层将<strong>被</strong>缓存，并且如果未检测到更改，则可以重复使用。 如果<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更改（添加/删除）</a>了图层，则随后的所有图层都是从头开始创建的。 要更改容器映像（并因此更改启动过程的环境），只需修复<strong>Dockerfile</strong>并开始构建映像即可。 </p><br><h3 id="konteyner"> 货柜 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">泊坞窗容器</a>是<strong>image</strong>的启动实例。 可以创建，启动，停止，删除等操作。默认情况下，容器彼此隔离，并且与主机系统隔离。 在开始时，容器启动一个命令，可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ENTRYPOINT</a>或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CMD中</a>指定该命令，并在完成时停止。 当<strong>CMD</strong>和<strong>ENTRYPOINT同时存在</strong>时，这是可以接受的情况，因为它们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在文档中</a> <strong>有所</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述</a> 。 </p><br><p> 创建每个容器时，将在所有现有容器之上添加一个新层。 它在当前容器中可写，并且与容器一起销毁。 在容器的操作过程中，所有写操作，创建新文件的所有操作均应用于此层， <strong>图像</strong>始终保持不变。 因此，创建的容器的层结构将如下所示： </p><br><p><img src="https://habrastorage.org/webt/yj/eb/rk/yjebrku_12g3cuu3qnl6xfdtdbo.png"></p><br><p> 使用<code>docker run</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>每次都会<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建一个<strong>新</strong></a>容器，并带有<strong>其自己</strong>的写入层。 在构建任务中，这意味着每次启动时，都会创建一个新的干净环境，该环境与以前的执行无关。 可以通过运行命令<code>docker container ls -a</code>来查看已创建容器的列表。 </p><br><h2 id="sobiraem-proekt-v-konteynere"> 我们将项目收集在容器中 </h2><br><p> 为了清楚起见，我们简要描述了在容器中构建应用程序的过程；此过程在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1条</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">条</a>中进行了更详细的描述。 </p><br><p> 在<strong>docker中</strong>构建应用程序的示意性步骤可以表示如下： <br><img src="https://habrastorage.org/webt/g_/ru/kt/g_ruktfloq-0loozoxjo9aafxga.png"></p><br><p> 让我们分析显示的步骤： </p><br><ol><li> 我们使用<strong>Dockerfile</strong> ，它描述了环境，用于组装和复制结果的命令，并基于此文件创建了容器的映像。 </li><li> 我们使用生成的映像通过<code>docker run</code>创建并启动容器。 我们安装源文件夹和将汇编结果复制到容器的文件夹。 </li><li> 容器完成后，程序集工件将放置在安装目录中。 </li></ol><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">本文</a>提供了一个示例。 </p><br><p> 由于此处使用了<code>docker run</code> ，因此每次启动都会创建一个单独的容器，该容器具有自己<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的写入层</a> ，因此以前程序集的临时文件不会进入当前容器。 切记清洁停止的容器。 </p><br><p> 挂载源目录使调试程序集更加容易。 但是它存在风险-您可以从尚未通过质量控制的代码中收集发布，或者根本不将其添加到版本控制系统中。 为了避免这种情况，您可以在每次构建时在容器内克隆git存储库，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在文件中</a> ： </p><br><pre> <code class="plaintext hljs">FROM ubuntu:bionic RUN apt-get update \ &amp;&amp; apt-get install -y apt-utils RUN apt-get update \ &amp;&amp; apt-get install -y make gcc g++ qt5-default git RUN mkdir -p /app/src WORKDIR /app/build #       ENTRYPOINT git -C /app/src clone https://github.com/sqglobe/SimpleQtProject.git \ &amp;&amp; qmake /app/src/SimpleQtProject/SimpleQtProject.pro \ &amp;&amp; make \ &amp;&amp; cp SimpleQtProject /app/res/SimpleQtProject-ubuntu-bionic</code> </pre> <br><p> 在这里，由于缓存，克隆是在<code>ENTRYPOINT</code>完成的，而不是在<code>RUN</code>语句中完成的。  <code>ENTRYPOINT</code> <strong>总是</strong>在容器启动时执行，并且<code>RUN</code>命令的结果可以<strong>从缓存中获取</strong> 。 </p><br><h2 id="infrastruktura-dlya-sborki"> 建立基础设施 </h2><br><p> 要为不同的操作系统或Linux <strong>发行版</strong>构建项目，可以使用服务器的特定配置（构建机器，具有版本控制系统的服务器等）。 实际上，我必须处理以下基础结构： </p><br><p><img src="https://habrastorage.org/webt/ue/0i/1w/ue0i1wmgapl-8x9h9-zw-bsrbi8.png"></p><br><p> 用户在这里访问<strong>Web</strong>服务器，通过该<strong>Web</strong>服务器在使用<strong>Ubuntu</strong>和<strong>Red Hat的</strong>计算机上构建项目。 接下来，在每台机器上，将git存储库与项目一起克隆到一个临时目录中，然后程序集开始。 用户可以从开始整个过程​​的同一页面下载结果文件。 </p><br><p> 这样的程序集是可重复的，因为开发人员使用相同的环境。 </p><br><p> 缺点-必须维护整个基础架构，管理多台服务器，消除脚本和<strong>Web</strong>应用程序中的错误等。 </p><br><h2 id="uproschaem-s-docker"> 使用Docker简化 </h2><br><p> 支持上述基础设施需要一定的成本，无论是金钱还是人力。 如果您的团队正在一家小型创业公司上工作，或者您是唯一的开发人员，则可以使用<strong>Docker</strong>容器来实现构建基础架构。 </p><br><p> 考虑一个使用<strong>qmake</strong> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SimpleQtProject</a>构建的普通<strong>Qt</strong>项目。 指定项目的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docker</a>文件夹包含许多文件： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">centos7.docker-</a>描述用于为<strong>CentOS 7</strong>构建项目的容器； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ubuntu-bionic.docker-</a>在<strong>Ubuntu 18.04</strong>下构建的容器; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ubuntu-xenial.docker-</a>描述了一个在<strong>Ubuntu 16.04</strong>下构建的容器。 </li></ul><br><p> 这些文件实现了在容器内部克隆源代码的想法。 </p><br><p> 整个程序集使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Makefile</a>启动。 它很短，包含足够的注释。 它的基础是图像的创建和容器的启动： </p><br><pre> <code class="plaintext hljs">%: %.docker docker build -t simple-qt-$(strip $(subst .docker,, $&lt; )) --file $&lt; . docker run --mount type=bind,source=$(RELEASE_DIR),target=/app/res simple-qt-$(strip $(subst .docker,, $&lt; ))</code> </pre> <br><p> 在组装的此阶段，将创建容器的映像，其名称由前缀<strong>simple-qt-</strong>和系统名称组成（对于<strong>centos 7</strong> ，它将是<strong>simple-qt-centos7</strong> ）。 作为<strong>Dockerfile</strong> ，使用具有<strong>.docker</strong>权限的相应文件。 接下来，根据创建的映像启动容器，并在其上安装一个文件夹以复制组件工件。 </p><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">docker</a>目录中运行<code>make</code>后， <strong>docker / releases</strong>文件夹将包含多个平台的构建结果。 </p><br><p> 因此，我们用于构建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SimpleQtProject</a>的基础<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结构</a>将如下所示： </p><br><p><img src="https://habrastorage.org/webt/bs/bg/ru/bsbgru5mo2bcrqb4z_31sdreyt8.png"></p><br><p> 这种配置的优点： </p><br><ol><li>  <strong>地方性</strong> 。 开发人员可以在其本地计算机上为多个平台收集一个项目，从而无需包含服务器群，通过网络在服务器之间配置复制工件，发送和处理网络命令。 </li><li>  <strong>隔离环境</strong> 。 容器为构建特定应用程序提供了完全隔离的环境。 可以在同一台机器上构建具有不兼容环境的项目（例如，那些需要同一库的不同版本的项目）。 </li><li>  <strong>版本控制</strong> 通过将<strong>Dockerfile</strong>放置在git仓库中，您可以通过新版本的发布来跟踪构建环境中的更改，回滚到构建环境的先前版本等。 </li><li>  <strong>流动性</strong> 。 如有必要，可以在另一台计算机上毫无问题地部署此基础结构。 创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">容器映像</a>的技术使您可以非常轻松地更改映像本身-只需更新<strong>Dockerfile</strong>并开始构建映像即可。 </li><li>  <strong>自我记录</strong> 。 本质上， <strong>Dockerfile</strong>包含用于部署程序集环境的步骤。 因此，如有必要，部署这样的环境，但是已经在常规系统中，则可以使用其中的命令。 </li><li>  <strong>轻便</strong> 。 容器在组件开始的那一刻开始，并在完成时自动停止。 这不会浪费CPU时间和RAM。 </li></ol><br><p> 但是，有一个很大的缺点-项目的组装将需要容器图像的组装。 首次启动时可能会花费很长时间。 但是对于重复的文件，尤其是在<strong>Dockerfile不变的情况下</strong> ，使用高速缓存收集映像的速度要快很多倍。 </p><br><p> 还需要记住清洁停止的容器。 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 总而言之，我想指出<strong>docker</strong>不是唯一的容器化技术。 但是有一些功能使它可以很好地区别于同一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LXC的</a>组装任务： </p><br><ol><li> 您可以使用文本<strong>Dockerfile</strong>创建容器。 这是一个语法简单的文件，您可以将其添加到项目存储库中（就像我经常做的那样），并且随时可以使用。 </li><li> 每次通过使用<code>docker run</code>启动<strong>docker</strong>容器<code>docker run</code>我们都会得到一个<em>干净的</em>环境，就像我们第一次做所有事情一样。 程序集之间的临时文件不会保存。 </li><li> 该容器不会启动整个操作系统，而只会启动必要的组装过程。 </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN457870/">https://habr.com/ru/post/zh-CN457870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN457854/index.html">80年代的程序员大家好</a></li>
<li><a href="../zh-CN457860/index.html">使用Node.js和React开发用于流式传输的应用程序</a></li>
<li><a href="../zh-CN457862/index.html">iOS摘要8（6月14日至6月27日）</a></li>
<li><a href="../zh-CN457864/index.html">系统分析的神话传说或银行分析师的行为</a></li>
<li><a href="../zh-CN457866/index.html">Laravel中的单元测试</a></li>
<li><a href="../zh-CN457872/index.html">如何管理时间并停止拖延？</a></li>
<li><a href="../zh-CN457874/index.html">员工为什么回来？ 出发和返回的故事</a></li>
<li><a href="../zh-CN457876/index.html">翻译：IEEE 802.15.4z标准。 将来有什么在等我们？</a></li>
<li><a href="../zh-CN457884/index.html">主权互联网-澄清订单</a></li>
<li><a href="../zh-CN457886/index.html">使用USB令牌在站点上进行两因素身份验证。 现在适用于Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>