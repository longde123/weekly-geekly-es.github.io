<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌊 🚣🏿 👪 Cómo mejorar el rendimiento de las aplicaciones web front-end: cinco consejos 🤞🏿 ♻️ 🤹🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En muchos de mis proyectos front-end, en algún momento me enfrenté a una disminución en la productividad; esto generalmente ocurre cuando aumenta la c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cómo mejorar el rendimiento de las aplicaciones web front-end: cinco consejos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/456808/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/p2/n1/fh/p2n1fhon961as8f21unatry3hfi.jpeg"></a> <br><br>  En muchos de mis proyectos front-end, en algún momento me enfrenté a una disminución en la productividad; esto generalmente ocurre cuando aumenta la complejidad de la aplicación, y esto es normal.  Sin embargo, los desarrolladores siguen siendo responsables del rendimiento, por lo que en mi artículo daré cinco consejos para optimizar las aplicaciones que aplico yo mismo: algunos pueden parecer obvios, otros afectan los principios básicos de la programación, pero creo que refrescar la memoria no es superfluo será.  Cada consejo está respaldado por pruebas: puede ejecutarlas usted mismo y probar el rendimiento. <br><br>  <b>Traducido a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Alconost</a></b> <br><a name="habracut"></a><br><h2>  Prólogo </h2><br>  Recuerde: si el código no necesita optimización, no entre en él.  Por supuesto, el código que escriba debería funcionar rápidamente, y siempre puede encontrar un algoritmo más rápido, pero el escrito debe permanecer claro para otros desarrolladores.  En la conferencia "Programación como arte", Donald Knuth expresó una idea muy importante sobre la optimización del código: <br><br><blockquote>  <i>El verdadero problema era que los programadores pasaban demasiado tiempo preocupándose por la eficiencia en lugares inapropiados y en momentos inapropiados.</i>  <i><b>La optimización prematura es la raíz de todos</b> los <b>errores de</b> programación (o al menos la mayoría).</i> <i><br></i> </blockquote><br><h2>  1. Búsqueda: en lugar de matrices ordinarias - objetos y matrices asociativas </h2><br>  Cuando se trabaja con datos, a menudo surgen situaciones en las que, por ejemplo, necesita encontrar un objeto, hacer algo con él, luego buscar otro objeto, etc.  La estructura de datos más común en JS es una matriz, por lo que almacenar datos en ellos es una práctica normal.  Sin embargo, cada vez que necesite encontrar algo en la matriz, debe usar métodos como "buscar", "indexOf", "filtro" o iterar con bucles, es decir, debe iterar sobre los elementos de principio a fin.  Por lo tanto, realizamos una búsqueda lineal, cuya complejidad es 0 (n) (en el peor de los casos, necesitaremos realizar tantas comparaciones como elementos en la matriz).  Si realiza esta operación un par de veces en arreglos pequeños, el impacto en el rendimiento será pequeño.  Sin embargo, si tenemos muchos elementos, y la operación se realiza muchas veces, el rendimiento ciertamente fallará. <br><br>  En este caso, será una buena solución convertir una matriz regular en un objeto o una matriz asociativa y realizar una búsqueda clave: en estas estructuras, se puede acceder a los elementos con complejidad O (1): tendremos una llamada de memoria, independientemente del tamaño.  La mejora de la velocidad del trabajo se logra mediante el uso de una estructura de datos llamada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tabla hash</a> . <br><br>  Puede probar el rendimiento aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jsperf.com/finding-element-object-vs-map-vs-array/1</a> .  A continuación están mis resultados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3c0/3e0/62f/3c03e062f1990f348bdd5fb7084e7278.png"><br><br>  La diferencia es muy significativa: para una matriz asociativa y un objeto, obtuve millones de operaciones por segundo, mientras que para una matriz, el mejor resultado es un poco más de cien operaciones.  Por supuesto, la conversión de datos no se tiene en cuenta aquí, pero incluso teniendo en cuenta su funcionamiento será mucho más rápido. <br><br><h2>  2. En lugar de excepciones, el operador condicional "if" </h2><br>  A veces parece más fácil omitir la comprobación nula y simplemente detectar las excepciones correspondientes.  Esto, por supuesto, es un mal hábito: no necesita hacer esto, y si tiene uno en su código, simplemente vuelva a escribir las secciones correspondientes.  Pero para convencerte por completo, apoyaré esta recomendación con pruebas.  Decidí probar tres formas de hacer verificaciones: la expresión "try-catch", la condición "if" y el cálculo de "cortocircuito". <br><br>  Prueba: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jsperf.com/try-catch-vs-conditions/1</a> .  A continuación están mis resultados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/4d8/9eb/d744d89eb0f25200abece3ccb5370f8b.png"><br><br>  Creo que es obvio a partir de aquí que es necesario verificar "nulo".  Además, como puede ver, casi no hay diferencia entre la condición "si" y el cálculo del "cortocircuito", entonces aplique a lo que miente el alma. <br><br><h2>  3. Cuantos menos ciclos, mejor </h2><br>  Otra consideración obvia, pero quizás controvertida.  Hay muchas funciones convenientes para las matrices: "mapa", "filtro", "reducir", por lo que su uso se ve atractivo, y el código con ellas se ve más ordenado y es más fácil de leer.  Pero cuando surge la pregunta de mejorar la productividad, puede intentar reducir la cantidad de funciones llamadas.  Decidí analizar dos casos: 1) "filtro", luego "mapa", y 2) "filtro", luego "reducir" - y compararlos con la cadena funcional, "forEach" y el bucle tradicional "for".  ¿Por qué exactamente estos dos casos?  De las pruebas se verá que los beneficios obtenidos pueden no ser muy significativos.  Además, en el segundo caso, también intenté usar "filtro" cuando llamé a "reducir". <br><br>  Prueba de rendimiento para "filtro" y "mapa": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jsperf.com/array-function-chains-vs-single-loop-filter-map/1</a> .  Mis resultados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/600/8f7/a78/6008f7a7819add9d68e1b4311d489461.png"><br><br>  Se puede ver que un ciclo es más rápido, pero la diferencia es pequeña.  La razón de una brecha tan pequeña es la operación de "empuje", que no es necesaria cuando se usa el "mapa".  Por lo tanto, en este caso, puede pensar si realmente es necesario continuar con un ciclo. <br><br>  Ahora revisemos "filtro" + "reducir": <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jsperf.com/array-function-chains-vs-single-loop-filter-reduce/1</a> .  Mis resultados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/0ae/a22/b6e0aea22e9b87555180ed93a7b0bdad.png"><br><br>  Aquí la diferencia ya es mayor: la combinación de dos funciones en una aceleró la ejecución en casi la mitad.  Sin embargo, la transición al ciclo tradicional "for" da un aumento mucho más significativo en la velocidad. <br><br><h2>  4. Use regular para bucles </h2><br>  Este consejo también puede parecer controvertido, porque a los desarrolladores les encantan los ciclos funcionales: son bien leídos y pueden simplificar el trabajo.  Sin embargo, son menos efectivos que los ciclos tradicionales.  Creo que ya puede notar la diferencia en el uso de for loops, pero echemos un vistazo en una prueba por separado: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jsperf.com/for-loops-in-few-different-ways/</a> .  Como puede ver, además de los mecanismos integrados, también verifiqué "forEach" de la biblioteca "Lodash" y "each" de "jQuery".  Resultados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1d/06f/e3d/f1d06fe3d1ff046226ff524737538676.png"><br><br>  Y nuevamente vemos que el ciclo "para" más simple es mucho más rápido que el resto.  Es cierto que estos bucles son buenos solo para matrices: en el caso de otros objetos iterables, debe usar "forEach", "for ... of" o el iterador en sí.  Pero "for ... in" debe aplicarse solo si no hay otros métodos.  Además, recuerde que "for ... in" acepta todas las propiedades del objeto (y en la matriz las propiedades son índices), lo que puede conducir a resultados impredecibles.  Sorprendentemente, los métodos de Lodash y jQuery no fueron tan malos en términos de rendimiento, por lo que en algunos casos puede usarlos de forma segura en lugar del "forEach" incorporado (curiosamente, en la prueba, el bucle de Lodash funcionó más rápido que el incorporado). <br><br><h2>  5. Use las funciones integradas para trabajar con el DOM </h2><br>  A veces miras el código de otra persona y ves que el desarrollador importó jQuery solo para manipular el DOM; estoy seguro de que también lo has visto, porque esta es una de las bibliotecas de JavaScript más populares.  Está claro que no hay nada de malo en usar bibliotecas para controlar el DOM: hoy usamos React y Angular, y ellos hacen lo mismo.  Sin embargo, a veces a algunos les parece que jQuery debería usarse incluso para operaciones simples para extraer un elemento del DOM y realizar pequeños cambios en él. <br><br>  Aquí hay una comparación de las funciones integradas para DOM y operaciones JQuery similares en tres casos diferentes: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jsperf.com/native-dom-functions-vs-jquery/1</a> .  Mis resultados: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1f/921/4ed/a1f9214ed02f914a5cf613d90bafb05c.png"><br><br>  Y de nuevo, las funciones más básicas - "getElementById" y "getElementsByClassName" - resultaron ser las más rápidas cuando se visualiza el DOM.  En el caso de identificadores y selectores avanzados, querySelector también es más rápido que jQuery.  Y en un solo caso es "querySelectorAll" más lento que jQuery (obteniendo elementos por nombre de clase).  Para obtener más información sobre cómo y cómo reemplazar jQuery, consulte aquí: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">http://youmightnotneedjquery.com</a> . <br><br>  Está claro que si ya está utilizando la biblioteca para administrar el DOM, se recomienda encarecidamente que se adhiera a ella; sin embargo, para casos simples, las herramientas integradas son suficientes. <br><br><h2>  Materiales adicionales </h2><br>  Estos cinco consejos lo ayudarán a escribir un código JavaScript más rápido.  Pero si está interesado en leer más sobre la optimización del rendimiento, aquí hay algunas recomendaciones: <br><br>  1. Optimización de paquetes de JavaScript usando Webpack: este es un tema muy extenso, pero si todo se hace correctamente, la carga de aplicaciones puede acelerarse significativamente. <br><br>  2. Estructuras de datos, algoritmos básicos y su complejidad: muchos creen que esto es "solo una teoría", pero en el primer párrafo vimos cómo funciona esta teoría en la práctica. <br><br>  3. Pruebas en la página <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jsPerf</a> : aquí puede familiarizarse con una comparación de diferentes formas de realizar la misma tarea en JavaScript y al mismo tiempo ver un indicador importante en la práctica: la diferencia de velocidad. <br><br>  <b>Sobre el traductor</b> <br><br>  El artículo fue traducido por Alconost. <br><br>  Alconost <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">localiza juegos</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aplicaciones y sitios</a> en 70 idiomas.  Traductores en lengua nativa, pruebas lingüísticas, plataforma en la nube con API, localización continua, gestores de proyectos 24/7, cualquier formato de recursos de cadena. <br><br>  También hacemos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">videos de publicidad y capacitación</a> , para sitios que venden, imágenes, publicidad, capacitación, teasers, expliner, trailers de Google Play y App Store. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Leer más</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456808/">https://habr.com/ru/post/456808/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456794/index.html">Arquitectura de la interfaz de usuario web: un pasado de madera, un presente extraño y un futuro brillante</a></li>
<li><a href="../456796/index.html">Svalbard - nuevo nombre para el proyecto Have I Been Pwned antes de la venta</a></li>
<li><a href="../456798/index.html">Tutoriales de SDL 2: Lección 5 - Texturas</a></li>
<li><a href="../456804/index.html">Siga el dinero: cómo el grupo RTM comenzó a ocultar las direcciones de los servidores C&C en una billetera criptográfica</a></li>
<li><a href="../456806/index.html">Un bot de todas las preocupaciones</a></li>
<li><a href="../456810/index.html">Los primeros Una historia libre de Tesla</a></li>
<li><a href="../456812/index.html">Qué hay en la Universidad ITMO: festivales de TI, hackatones, conferencias y seminarios abiertos</a></li>
<li><a href="../456814/index.html">Aprenda programación funcional en Python en 10 minutos</a></li>
<li><a href="../456818/index.html">El administrador del sistema en una empresa inaccesible. ¿La insoportable carga del ser?</a></li>
<li><a href="../456820/index.html">Arcilla → Ladrillo → Estufa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>