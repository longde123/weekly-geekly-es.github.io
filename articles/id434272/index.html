<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕝 🚃 📱 RoadRunner: PHP tidak dibuat untuk mati, atau Golang untuk menyelamatkan 👨🏻‍🔬 🥘 🤚🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Kami di Badoo secara aktif bekerja pada kinerja PHP , karena kami memiliki sistem yang cukup besar dalam bahasa ini dan masalah kinerja ad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RoadRunner: PHP tidak dibuat untuk mati, atau Golang untuk menyelamatkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/badoo/blog/434272/"><img src="https://habrastorage.org/webt/iw/kn/au/iwknauolmahz8ueoadgkp3mp0zs.jpeg"><br><br>  Halo, Habr!  Kami di Badoo secara aktif <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bekerja pada kinerja PHP</a> , karena kami memiliki sistem yang cukup besar dalam bahasa ini dan masalah kinerja adalah masalah menghemat uang.  Lebih dari sepuluh tahun yang lalu, kami membuat untuk PHP-FPM ini, yang pertama merupakan satu set tambalan untuk PHP, dan kemudian masuk ke pengiriman resmi. <br><br>  Dalam beberapa tahun terakhir, PHP telah membuat langkah besar: pengumpul sampah telah meningkat, tingkat stabilitas telah meningkat - hari ini di PHP Anda dapat menulis setan dan skrip berumur panjang tanpa masalah khusus.  Ini memungkinkan Spiral Scout untuk melangkah lebih jauh: RoadRunner, tidak seperti PHP-FPM, tidak menghapus memori di antara permintaan, yang memberikan peningkatan kinerja tambahan (meskipun pendekatan ini mempersulit proses pengembangan).  Kami sekarang sedang bereksperimen dengan alat ini, tetapi kami belum memiliki hasil yang dapat dibagikan.  Untuk menunggu mereka lebih menyenangkan, kami <b>menerbitkan terjemahan dari pengumuman RoadRunner dari Spiral Scout.</b> <br><br>  Pendekatan dari artikel ini dekat dengan kami: ketika menyelesaikan masalah kami, kami juga paling sering menggunakan banyak PHP dan Go, mendapatkan keuntungan dari kedua bahasa dan tidak mengabaikan satu demi yang lain. <br><br>  Selamat menikmati! <br><a name="habracut"></a><br><hr><br>  Selama sepuluh tahun terakhir, kami telah membuat aplikasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perusahaan Fortune 500</a> dan untuk bisnis dengan jumlah pemirsa tidak lebih dari 500 pengguna.  Selama ini, teknisi kami mengembangkan backend terutama dalam PHP.  Tapi dua tahun lalu, sesuatu yang sangat mempengaruhi tidak hanya kinerja produk kami, tetapi juga skalabilitasnya - kami memperkenalkan Golang (Go) ke tumpukan teknologi kami. <br><br>  Hampir segera, kami menemukan bahwa Go memungkinkan kami untuk membuat aplikasi yang lebih besar dengan kinerja hingga 40 kali lebih tinggi.  Dengan itu, kami dapat memperluas produk yang sudah ada yang ditulis dalam PHP, meningkatkannya melalui kombinasi keunggulan dari kedua bahasa. <br><br>  Kami akan memberi tahu Anda bagaimana kombinasi Go dan PHP membantu menyelesaikan masalah pengembangan nyata dan bagaimana hal itu menjadi bagi kami alat yang dapat meringankan sebagian masalah yang terkait dengan model <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP "sekarat"</a> . <br><br><h3>  Lingkungan Pengembangan PHP Sehari-Hari Anda </h3><br>  Sebelum kita berbicara tentang bagaimana Go dapat menghidupkan model "sekarat" PHP, mari kita lihat lingkungan pengembangan PHP standar Anda. <br><br>  Dalam kebanyakan kasus, Anda meluncurkan aplikasi menggunakan kombinasi server web nginx dan server PHP-FPM.  Yang pertama menyajikan file statis dan mengarahkan permintaan khusus ke PHP-FPM, dan PHP-FPM sendiri mengeksekusi kode PHP.  Mungkin Anda menggunakan bundel yang kurang populer dari Apache dan mod_php.  Tetapi meskipun kerjanya sedikit berbeda, prinsip-prinsipnya sama. <br><br>  Pertimbangkan bagaimana PHP-FPM mengeksekusi kode aplikasi.  Ketika permintaan datang, PHP-FPM menginisialisasi proses PHP anak, dan meneruskan detail permintaan sebagai bagian dari kondisinya (_GET, _POST, _SERVER, dll.). <br><br>  Keadaan tidak dapat berubah selama pelaksanaan skrip PHP, jadi Anda bisa mendapatkan satu set data input baru hanya dengan satu cara: dengan menghapus memori proses dan menginisialisasi lagi. <br><br>  Model eksekusi ini memiliki banyak keunggulan.  Anda tidak perlu terlalu khawatir tentang konsumsi memori, semua proses sepenuhnya terisolasi, dan jika salah satu dari mereka mati, itu akan dibuat ulang secara otomatis dan ini tidak akan mempengaruhi proses lainnya.  Tetapi pendekatan ini juga memiliki kelemahan yang muncul ketika mencoba untuk skala aplikasi. <br><br><h3>  Kerugian dan inefisiensi dari lingkungan PHP biasa </h3><br>  Jika Anda terlibat dalam pengembangan profesional dalam PHP, maka Anda tahu di mana harus memulai proyek baru, dengan pilihan kerangka kerja.  Ini adalah perpustakaan untuk injeksi ketergantungan, ORM, terjemahan, dan templat.  Dan, tentu saja, semua input pengguna dapat dengan mudah ditempatkan di satu objek (Symfony / HttpFoundation atau PSR-7).  Kerangka itu keren! <br><br>  Tapi semuanya punya harga.  Dalam kerangka kerja tingkat perusahaan apa pun, untuk memproses permintaan pengguna sederhana atau mengakses database, Anda harus mengunduh setidaknya lusinan file, membuat banyak kelas, dan memilah beberapa konfigurasi.  Tetapi bagian terburuknya adalah setelah menyelesaikan setiap tugas, Anda harus mengatur ulang semuanya dan mulai lagi: semua kode yang baru Anda mulai menjadi tidak berguna, dengan itu Anda tidak akan lagi memproses permintaan lain.  Beri tahu programmer mana pun yang menulis dalam bahasa lain tentang hal itu dan Anda akan melihat kebingungan di wajahnya. <br><br>  Selama bertahun-tahun, para insinyur PHP telah mencari cara untuk mengatasi masalah ini, menggunakan metode pemuatan malas, mikroframe, perpustakaan yang dioptimalkan, cache, dll. Namun pada akhirnya, Anda masih harus mengatur ulang seluruh aplikasi dan mulai lagi, berulang-ulang.  <i>(Catatan Penerjemah: masalah ini sebagian akan diselesaikan dengan munculnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">preload</a> di PHP 7.4)</i> <i><br><br></i> <h3>  <i>Bisakah PHP menggunakan Go untuk bertahan lebih dari satu permintaan?</i> </h3> <i><br></i>  Anda dapat menulis skrip PHP yang akan hidup lebih dari beberapa menit (hingga berjam-jam atau berhari-hari): misalnya, tugas cron, parser CSV, pemecah antrian.  Mereka semua bekerja berdasarkan satu skenario: mereka mengekstrak tugas, menyelesaikannya, menunggu yang berikutnya.  Kode ini selalu ada dalam memori, menghemat milidetik yang berharga, karena banyak langkah tambahan diperlukan untuk mengunduh kerangka kerja dan aplikasi. <br><br>  Tetapi mengembangkan skrip berumur panjang tidak sesederhana itu.  Kesalahan apa pun benar-benar membunuh proses, diagnosis kebocoran memori menyebalkan, dan debugging menggunakan F5 tidak lagi mungkin. <br><br>  Situasi membaik dengan rilis PHP 7: seorang pengumpul sampah yang andal muncul, menjadi lebih mudah untuk menangani kesalahan, dan ekstensi kernel sekarang dilindungi dari kebocoran.  Benar, insinyur masih perlu hati-hati menangani memori dan mengingat tentang masalah status dalam kode (apakah ada bahasa di mana Anda dapat mengabaikan hal-hal ini?).  Namun, di PHP 7, ada lebih sedikit kejutan. <br><br>  Apakah mungkin untuk mengambil model untuk bekerja dengan skrip PHP berumur panjang, mengadaptasinya untuk tugas yang lebih sepele seperti memproses permintaan HTTP dan dengan demikian menyingkirkan kebutuhan untuk mengunduh semuanya dari awal dengan setiap permintaan? <br><br>  Untuk mengatasi masalah ini, pertama-tama perlu untuk mengimplementasikan aplikasi server yang mampu menerima permintaan HTTP dan mengarahkan mereka satu per satu ke pekerja PHP, tanpa membunuhnya setiap saat. <br><br>  Kami tahu bahwa kami dapat menulis server web dalam PHP murni (PHP-PM) atau menggunakan ekstensi-C (Swoole).  Dan meskipun masing-masing metode memiliki kelebihannya sendiri, kedua opsi tidak cocok untuk kita - saya menginginkan sesuatu yang lebih.  Bukan hanya server web yang dibutuhkan - kami berharap mendapatkan solusi yang dapat menyelamatkan kami dari masalah yang terkait dengan "awal yang sulit" dalam PHP, yang dapat dengan mudah diadaptasi dan diperluas untuk aplikasi tertentu.  Artinya, kami membutuhkan server aplikasi. <br><br>  Bisakah Go membantu dengan ini?  Kami tahu itu bisa, karena bahasa ini mengkompilasi aplikasi menjadi file biner tunggal;  itu adalah lintas platform;  menggunakan model konkurensi sendiri, sangat elegan, dan perpustakaan untuk bekerja dengan HTTP;  dan akhirnya, ribuan perpustakaan sumber terbuka dan integrasi akan tersedia bagi kami. <br><br><h3>  Kesulitan dalam menggabungkan dua bahasa pemrograman </h3><br>  Pertama-tama, perlu untuk menentukan bagaimana dua atau lebih aplikasi akan berkomunikasi satu sama lain. <br><br>  Misalnya, dengan bantuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan yang sangat baik dari</a> Alex Palaestras, dimungkinkan untuk menerapkan berbagi memori dengan proses PHP dan Go (mirip dengan mod_php di Apache).  Tetapi perpustakaan ini memiliki fitur yang membatasi penggunaannya untuk menyelesaikan masalah kita. <br><br>  Kami memutuskan untuk menggunakan pendekatan yang berbeda dan lebih umum: untuk membangun interaksi antar proses melalui soket / jalur pipa.  Pendekatan ini selama beberapa dekade terakhir telah terbukti andal dan telah dioptimalkan dengan baik di tingkat sistem operasi. <br><br>  Untuk mulai dengan, kami membuat protokol biner sederhana untuk bertukar data antara proses dan menangani kesalahan transmisi.  Dalam bentuknya yang paling sederhana, protokol jenis ini mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">netstring</a> dengan <a href="">header paket ukuran-tetap</a> (dalam kasus kami, 17 byte), yang berisi informasi tentang jenis paket, ukurannya dan topeng biner untuk memeriksa integritas data. <br><br>  Di sisi PHP, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi paket</a> , dan di sisi Go, perpustakaan <a href="">encoding / biner</a> . <br><br>  Satu protokol tidak cukup bagi kami - dan kami menambahkan kemampuan untuk memanggil layanan <a href="">net / rpc langsung dari PHP</a> .  Kemudian, ini banyak membantu kami dalam pengembangan, karena kami dapat dengan mudah mengintegrasikan Go library ke aplikasi PHP.  Hasil dari pekerjaan ini dapat dilihat, misalnya, di produk open-source kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Goridge</a> . <br><br><h3>  Distribusi tugas di antara beberapa pekerja PHP </h3><br>  Setelah menerapkan mekanisme interaksi, kami mulai berpikir tentang cara terbaik mentransfer tugas ke proses PHP.  Ketika tugas tiba, server aplikasi harus memilih pekerja gratis untuk menyelesaikannya.  Jika pekerja / proses diakhiri dengan kesalahan atau "mati", kami menyingkirkannya dan membuat yang baru sebagai balasannya.  Dan jika pekerja / proses bekerja dengan sukses, kami mengembalikannya ke kumpulan pekerja yang tersedia untuk menyelesaikan tugas. <br><br><img src="https://habrastorage.org/webt/we/eo/5_/weeo5_2hl44jkd6xgtqt33gzbza.png"><br><br>  Kami menggunakan <a href="">saluran buffered</a> untuk menyimpan kumpulan pekerja aktif, untuk menghapus pekerja “mati” yang tak terduga dari kumpulan, kami menambahkan mekanisme untuk melacak kesalahan dan keadaan pekerja. <br><br>  Sebagai hasilnya, kami mendapatkan server PHP yang berfungsi yang mampu memproses permintaan yang disajikan dalam bentuk biner. <br><br>  Agar aplikasi kami mulai berfungsi sebagai server web, saya harus memilih standar PHP yang dapat diandalkan untuk menyajikan permintaan HTTP yang masuk.  Dalam kasus kami, kami cukup <a href="https://github.com/spiral/roadrunner/blob/master/service/">mengonversi permintaan</a> net / http dari Go ke format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PSR-7</a> sehingga itu kompatibel dengan sebagian besar kerangka kerja PHP yang tersedia saat ini. <br><br>  Karena PSR-7 dianggap tidak dapat diubah (seseorang akan mengatakan bahwa secara teknis tidak demikian), pengembang harus menulis aplikasi yang, pada prinsipnya, tidak menangani permintaan sebagai entitas global.  Ini berjalan dengan baik dengan konsep proses PHP berumur panjang.  Implementasi akhir kami, yang belum menerima nama, tampak seperti ini: <br><br><img src="https://habrastorage.org/webt/xa/px/ak/xapxakkcbhrws7c2-p83lqgkmhk.png"><br><br><h3>  Memperkenalkan RoadRunner - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Server Aplikasi PHP Kinerja Tinggi</a> </h3><br>  Tugas pengujian pertama kami adalah backend API, yang secara berkala menyebabkan ledakan permintaan yang tidak terduga (jauh lebih sering daripada biasanya).  Meskipun dalam kebanyakan kasus terdapat cukup fitur nginx, kami secara teratur menemukan kesalahan 502, karena kami tidak dapat menyeimbangkan sistem dengan cukup cepat untuk peningkatan beban yang diharapkan. <br><br>  Untuk mengganti solusi ini, pada awal 2018, kami menggunakan server aplikasi PHP / Go pertama kami.  Dan langsung mendapat efek luar biasa!  Kami tidak hanya sepenuhnya menghilangkan kesalahan 502, tetapi juga mampu mengurangi jumlah server hingga dua pertiga, menghemat satu ton uang dan pil untuk sakit kepala bagi para insinyur dan manajer produk. <br><br>  Pada pertengahan tahun, kami meningkatkan solusi kami, menerbitkannya di GitHub di bawah lisensi MIT, dan menamainya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RoadRunner</a> , menekankan kecepatan dan efisiensinya yang luar biasa. <br><br><h3>  Bagaimana RoadRunner Dapat Meningkatkan Stack Pengembangan Anda </h3><br>  Penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RoadRunner</a> memungkinkan kami untuk menggunakan Middleware net / http di sisi Go untuk melakukan verifikasi JWT sebelum permintaan masuk ke PHP, serta untuk memproses WebSockets dan status agregat global di Prometheus. <br><br>  Berkat RPC bawaan, Anda dapat membuka API perpustakaan Go untuk PHP tanpa menulis pembungkus ekstensi.  Lebih penting lagi, RoadRunner dapat menggunakan server baru selain HTTP.  Contohnya termasuk menjalankan penangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AWS Lambda</a> di PHP, membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">resolusi</a> antrian yang kuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> dan bahkan menambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gRPC</a> ke aplikasi kami. <br><br>  Dengan bantuan komunitas PHP dan Go, kami meningkatkan stabilitas solusi, dalam beberapa tes kami meningkatkan kinerja aplikasi hingga 40 kali, meningkatkan alat debugging, mengimplementasikan integrasi dengan kerangka kerja Symfony dan menambahkan dukungan untuk HTTPS, HTTP / 2, plug-in dan PSR-17. <br><br><h3>  Kesimpulan </h3><br>  Beberapa masih terpikat oleh gagasan usang tentang PHP sebagai bahasa rumit yang lambat, hanya cocok untuk menulis plugin untuk WordPress.  Orang-orang ini bahkan dapat mengatakan bahwa PHP memiliki batasan seperti itu: ketika aplikasi menjadi cukup besar, Anda harus memilih bahasa yang lebih "dewasa" dan menulis ulang basis kode yang telah terakumulasi selama bertahun-tahun. <br><br>  Saya ingin menjawab semua ini: pikirkan lagi.  Kami percaya bahwa hanya Anda sendiri yang menetapkan batasan untuk PHP.  Anda dapat menghabiskan seluruh hidup Anda beralih dari satu bahasa ke bahasa lain, mencoba menemukan kombinasi sempurna dengan kebutuhan Anda, atau Anda dapat mulai menganggap bahasa sebagai alat.  Kelemahan nyata dari bahasa seperti PHP sebenarnya bisa menjadi alasan keberhasilannya.  Dan jika Anda menggabungkannya dengan bahasa lain seperti Go, maka Anda akan menciptakan produk yang jauh lebih kuat daripada jika Anda terbatas menggunakan satu bahasa saja. <br><br>  Setelah bekerja dengan sekelompok Go dan PHP, kita dapat mengatakan bahwa kita mencintai mereka.  Kami tidak berencana untuk mengorbankan satu demi yang lain - sebaliknya, kami akan mencari cara untuk mendapatkan lebih banyak manfaat dari tumpukan ganda ini. <br><br>  <i>UPD: Selamat datang di pencipta RoadRunner dan penulis bersama artikel asli - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Lachezis</a></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id434272/">https://habr.com/ru/post/id434272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id434260/index.html">Microsoft mengadakan kontes Agen AI di Minecraft</a></li>
<li><a href="../id434262/index.html">Menulis dan menyusun album untuk Linux (Ubuntu 16.04, Ardour, Hydrogen, Kontakt)</a></li>
<li><a href="../id434264/index.html">Intel ❄ 2018. Hasil tahun ini</a></li>
<li><a href="../id434266/index.html">Catatan penyedia IoT: biarkan ada cahaya, atau sejarah urutan negara bagian pertama oleh LoRa</a></li>
<li><a href="../id434268/index.html">Inovator TOP 3 alat pengujian keamanan perangkat lunak seluler</a></li>
<li><a href="../id434274/index.html">Paralel menjadi bagian dari Corel?</a></li>
<li><a href="../id434276/index.html">Slack meminta maaf karena kesalahan penguncian akun</a></li>
<li><a href="../id434278/index.html">Matematikawan amatir menemukan cakupan universal terkecil</a></li>
<li><a href="../id434280/index.html">Bagaimana teknologi pengenalan wajah membantu polisi</a></li>
<li><a href="../id434282/index.html">Bitfury Crystal: cara kerjanya dan di mana alat kami untuk melacak transaksi crypto yang mencurigakan digunakan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>