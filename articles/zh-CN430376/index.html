<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛍️ ⚱️ 🙍🏼 JavaScript指南第6部分：异常，分号，模板文字 ✊🏻 ♉️ 🚵🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript教程翻译的这一部分的主题将是异常处理，自动分号功能和模板文字。 

 → 第1部分：第一个程序，语言功能，标准 
 → 第2部分：代码样式和程序结构 
 → 第3部分：变量，数据类型，表达式，对象 
 → 第4部分：功能 
 → 第5部分：数组和循环 
 → 第6部分：异常，分号...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript指南第6部分：异常，分号，模板文字</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/430376/">  JavaScript教程翻译的这一部分的主题将是异常处理，自动分号功能和模板文字。 <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第1部分：第一个程序，语言功能，标准</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第2部分：代码样式和程序结构</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第3部分：变量，数据类型，表达式，对象</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第4部分：功能</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第5部分：数组和循环</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第6部分：异常，分号，通配符文字</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第7部分：严格模式，此关键字，事件，模块，数学计算</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第8部分：ES6功能概述</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第9部分：ES7，ES8和ES9标准概述</a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/jf/eo/1s/jfeo1s-pygp9g5pazca5kjwvwoa.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">异常处理</font> </h2><br> 在代码执行过程中发生问题时，将其表示为JavaScript中的异常。 如果不采取措施来处理异常，则在异常发生时，程序将停止，并在控制台中显示错误消息。 <br><br> 考虑以下代码片段。 <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'message text'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> notObj <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fn = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.value <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(obj)) <span class="hljs-comment"><span class="hljs-comment">//message text console.log('Before') //Before console.log(fn(notObj)) //,    console.log('After')</span></span></code> </pre> <br> 在这里，我们有一个计划用于处理具有<code>value</code>属性的对象的<code>value</code> 。 她归还了此财产。 如果将此功能用于其预期目的，即，将其设计为可以使用的对象传送给该函数，则在执行该函数时不会产生任何错误。 但是，如果您传递了不适当的内容（在我们的情况下为已声明但未初始化的变量），则当您尝试访问<code>undefined</code>值的<code>value</code>属性时会发生错误。 控制台中将显示一条错误消息，程序执行将停止。 <br><br> 这是在Node.js中运行此代码时的样子。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42d/eec/eaa/42deeceaad05edd38b8581f65b4de563.png"></div><br>  <i><font color="#999999">Node.js中的TypeError异常</font></i> <br><br> 如果网页的JS代码中发生类似情况，类似的消息将发送到浏览器控制台。 如果这是在真实程序中发生的，例如-在Web服务器代码中，则此行为是非常不希望的。 最好有一种机制，允许在不停止程序的情况下捕获错误，然后采取措施纠正错误。 这种机制存在于JavaScript中；它由<code>try...catch</code>构造表示。 <br><br><h3>  <font color="#3AC1EF">try施工尝试〜抓</font> </h3><br>  <code>try...catch</code>构造允许您捕获和处理异常。 即，它包括一个<code>try</code>块和一个<code>catch</code> ，其中<code>try</code>块包括可能导致错误的代码， <code>catch</code>在发生错误时转移控制。  <code>try</code>块并不完全包含所有程序代码。 那些可能导致运行时错误的部分放在此处。 例如，调用必须与从外部源接收到的某些数据一起使用的函数。 如果此类数据的结构与功能预期的结构不同，则可能会发生错误。 这是<code>try...catch</code>设计图的样子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ,     } catch (e) { //  }</span></span></code> </pre> <br> 如果代码执行没有错误，则不执行<code>catch</code> （异常处理程序）。 如果发生错误，则将错误对象转移到那里，并采取一些措施来解决此错误。 <br><br> 我们在示例中应用此构造，并通过其帮助来保护程序的危险部分-调用函数<code>fn()</code>那些部分。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">'message text'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> notObj <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fn = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) =&gt;</span></span> a.value <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(fn(obj)) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.message) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) <span class="hljs-comment"><span class="hljs-comment">//Before try {   console.log(fn(notObj)) } catch (e) {   console.log(e.message) //Cannot read property 'value' of undefined } console.log('After') //After</span></span></code> </pre> <br> 让我们看看在Node.js中执行此代码的结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b8b/5f7/e5e/b8b5f7e5e4745ec45d69bd9f642cef70.png"></div><br>  <i><font color="#999999">Node.js中的错误处理</font></i> <br><br> 如您所见，如果将本示例与上一个示例进行比较，现在将执行所有代码，一个位于问题行之前的代码，以及一个位于问题行之后的代码。 我们只需将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误</a>对象的<code>message</code>属性的值打印到控制台即可“处理” <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">错误</a> 。 实际使用的代码中发生的错误将如何处理取决于该错误。 <br><br> 我们在上面讨论了<code>try...catch</code>块，但实际上，此构造包括另一个块<code>finally</code> 。 <br><br><h3>  <font color="#3AC1EF">▍终于挡</font> </h3><br>  <code>finally</code>块包含无论<code>try</code>块中运行的代码是否发生错误都可以运行的代码。 这是它的外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  } catch (e) { //  } finally { //  }</span></span></code> </pre> <br> 如果<code>try...catch...finally</code>块没有<code>try...catch...finally</code>块，则也可以使用<code>try...catch...finally</code> <code>catch</code> 。 在这种方法中，它的使用方式与使用<code>catch</code>的构造相同，例如，释放<code>try</code>块中占用的资源。 <br><br><h3>  <font color="#3AC1EF">▍嵌套尝试块</font> </h3><br> 尝试块可以嵌套在一起。 在这种情况下，将在最近的<code>catch</code>处理异常。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  try {   //   } finally {   // -  } } catch (e) { }</span></span></code> </pre> <br> 在这种情况下，如果内部<code>try</code>块中发生异常，则将在外部<code>catch</code>对其进行处理。 <br><br><h3>  <font color="#3AC1EF">▍自生异常</font> </h3><br> 您可以使用<code>throw</code>语句自行抛出异常。 这是它的外观。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> value</code> </pre> <br> 执行该指令后，控制权转移到最近的<code>catch</code> ，或者如果找不到该块，则程序停止。 异常值可以是任何值。 例如，用户定义的错误对象。 <br><br><h2>  <font color="#3AC1EF">关于分号</font> </h2><br> 在JavaScript中使用分号是可选的。 一些程序员没有它们，而是依靠自动排列系统，仅将它们放置在绝对必要的地方。 有些人喜欢将它们放置在任何可能的地方。 本材料的作者指的是不使用分号的程序员。 他说，他决定在2017年秋季不设置它们，方法是将Prettier设置为在没有显式插入的情况下可以删除它们。 在他看来，没有分号的代码看起来更自然，更易于阅读。 <br><br> 也许可以说，就分号而言，JS开发人员社区分为两个阵营。 同时，有两种JavaScript样式指南规定了明确的分号放置，并建议不使用这些样式指南。 <br><br> 由于JavaScript具有用于自动分号的系统（自动分号插入，ASI），因此所有这些都是可能的。 但是，在JS代码中，在许多情况下都可以不用这些字符，并且在准备执行代码时自动放置分号这一事实并不意味着程序员不需要了解发生这种情况的规则。 这些规则的无知会导致错误。 <br><br><h3>  <font color="#3AC1EF">automatic自动分号规则</font> </h3><br> 在以下情况下，JavaScript解析器在解析程序文本时会自动添加分号： <br><br><ol><li> 当下一行以中断当前代码的代码开头时（某个命令的代码可能位于多行中）。 </li><li> 当下一行以字符<code>}</code>开头时，它将关闭当前块。 </li><li> 当检测到带有程序代码的文件末尾时。 </li><li> 与<code>return</code>命令一致。 </li><li> 与<code>break</code>命令一致。 </li><li> 与<code>throw</code>命令一致。 </li><li> 与<code>continue</code>命令一致。 </li></ol><br><h3>  <font color="#3AC1EF">▍无法正常运行的代码示例</font> </h3><br> 以下是一些说明上述规则的示例。 例如，您认为以下代码片段的执行结果将显示什么？ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> you = <span class="hljs-string"><span class="hljs-string">'hey'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> heyYou = hey + <span class="hljs-string"><span class="hljs-string">' '</span></span> + you [<span class="hljs-string"><span class="hljs-string">'h'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>].forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">letter</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letter))</code> </pre> <br> 尝试执行此代码时，将<code>Uncaught TypeError: Cannot read property 'forEach' of undefined</code>错误<code>Uncaught TypeError: Cannot read property 'forEach' of undefined</code>系统的<code>Uncaught TypeError: Cannot read property 'forEach' of undefined</code>基于规则1，它尝试按以下方式解释代码。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hey = <span class="hljs-string"><span class="hljs-string">'hey'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> you = <span class="hljs-string"><span class="hljs-string">'hey'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> heyYou = hey + <span class="hljs-string"><span class="hljs-string">' '</span></span> + you[<span class="hljs-string"><span class="hljs-string">'h'</span></span>, <span class="hljs-string"><span class="hljs-string">'e'</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>].forEach(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">letter</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(letter))</code> </pre> <br> 该问题可以通过在第一个示例的倒数第二行之后加上分号来解决。 <br><br> 这是另一段代码。 <br><br><pre> <code class="javascript hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>).toString()</code> </pre> <br> 执行结果将是字符串<code>"3"</code>的输出。 但是，如果下一个代码片段中出现类似的内容，会发生什么呢？ <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a + b (a + b).toString()</code> </pre> <br> 在这种情况下，将出现<code>TypeError: b is not a function</code>错误<code>TypeError: b is not a function</code>因为上述代码将按以下方式解释。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a + b(a + b).toString()</code> </pre> <br> 现在让我们看一个基于规则4的示例。 <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'white'</span></span> } })()</code> </pre> <br> 您可能会认为此IIFE将返回包含<code>color</code>属性的对象，但实际上并非如此。 而是，该函数将返回<code>undefined</code>因为系统在<code>return</code>命令之后添加了分号。 <br><br> 为了解决类似的问题，必须将对象文字的大括号放在与<code>return</code>命令相同的行上。 <br><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">'white'</span></span> } })()</code> </pre> <br> 如果查看下面的代码片段，您可能会认为它将在消息框中显示<code>0</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span> ? alert(<span class="hljs-number"><span class="hljs-number">0</span></span>) : alert(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br> 但它输出2，因为根据规则1，此代码表示如下。 <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span> ? alert(<span class="hljs-number"><span class="hljs-number">0</span></span>) : alert(<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br> 在JavaScript中使用分号时应格外小心。 您可以遇到分号的热心支持者及其对手。 实际上，在确定代码中是否需要分号时，您可以依靠JS支持它们的自动替换这一事实，但是每个人都必须自己决定自己的代码中是否需要分号。 最主要的是一致且合理地应用所选方法。 关于分号的放置和代码的结构，我们可以建议以下规则： <br><br><ul><li> 使用<code>return</code>命令，在命令的同一行上安排应从函数返回的内容。  <code>break</code> ， <code>throw</code> ， <code>continue</code>命令也是如此。 </li><li> 请特别注意新代码行以方括号开头的情况，因为该行可以自动与上一行合并，并由系统呈现为尝试调用函数或尝试访问数组元素的情况。 </li></ul><br> 通常，可以说，无论您是自己放置分号，还是依靠分号的自动放置，都对代码进行测试，以确保其完全按预期工作。 <br><br><h2>  <font color="#3AC1EF">引号和通配符</font> </h2><br> 让我们谈谈在JavaScript中使用引号的功能。 即，我们正在谈论JS程序中允许的以下引号类型： <br><br><ul><li> 单引号。 </li><li> 双引号。 </li><li> 反引号。 </li></ul><br> 通常，单引号和双引号可以认为是相同的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bike = <span class="hljs-string"><span class="hljs-string">"bike"</span></span></code> </pre> <br> 它们之间几乎没有区别。 也许唯一明显的区别是，在用单引号引起来的字符串中，您需要对单引号的字符进行转义，而在用双引号引起来的字符串中，字符是双精度。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'te\'st'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">'te"st'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">"te\"st"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = <span class="hljs-string"><span class="hljs-string">"te'st"</span></span></code> </pre> <br> 在不同的样式指南中，您可以找到使用单引号的建议和使用双引号的建议。 该材料的作者说，他努力在JS代码中仅使用单引号，而仅在HTML代码中使用双引号。 <br><br>  Backticks在2015年发布的ES6标准中出现在JavaScript中。 除了其他新功能外，它们还可以方便地描述多行字符串。 也可以使用常规引号指定此类字符串-使用转义序列<code>\n</code> 。 看起来像这样。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">'A string\non multiple lines'</span></span></code> </pre> <br> 倒逗号（通常用于输入它们的按钮位于键盘上数字键1的左侧）不带<code>\n</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">`A string on multiple lines`</span></span></code> </pre> <br> 但是反引号的可能性不限于此。 因此，如果使用反引号描述字符串，则可以使用构造<code>${}</code>将来自JS表达式计算的值替换为字符串。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> multilineString = <span class="hljs-string"><span class="hljs-string">`A string on </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">+</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> lines`</span></span></code> </pre> <br> 这样的字符串称为模板文字。 <br><br> 模板文字具有以下功能： <br><br><ul><li> 它们支持多行文本。 </li><li> 它们使插值字符串成为可能；可以在其中使用内置表达式。 </li><li> 它们使您可以使用带标签的模板，从而可以创建自己的特定于域的语言（DSL，特定于域的语言）。 </li></ul><br> 让我们谈谈这些功能。 <br><br><h3>  <font color="#3AC1EF">line多行文字</font> </h3><br> 设置带反引号的多行文本时，您需要记住，此类文本中的空格与其他字符一样重要。 例如，考虑以下多行文字。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">`First               Second`</span></span></code> </pre> <br> 他的结论大致如下。 <br><br><pre> <code class="javascript hljs">First               Second</code> </pre> <br> 就是说，事实证明，当在编辑器中输入此文本时，程序员可能希望输出时的<code>First</code>和<code>Second</code>严格地在彼此之下出现，但实际上并非如此。 为了解决此问题，您可以使用换行符开始多行文本，并在关闭反引号之后立即调用<code>trim()</code>方法，该方法将删除行首或结尾的空格。 此类字符尤其包括空格和制表符。 行尾字符也将被删除。 <br><br> 看起来像这样。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">` First Second`</span></span>.trim()</code> </pre> <br><h3>  <font color="#3AC1EF">▍插值</font> </h3><br> 这里的插值是指将变量和表达式转换为字符串。 这是使用<code>${}</code>构造完成的。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> variable = <span class="hljs-string"><span class="hljs-string">'test'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ variable }</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-comment"><span class="hljs-comment">//something test</span></span></code> </pre> <br> 您可以在<code>${}</code>块中添加任何内容，甚至可以是表达式。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string">`</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string2 = <span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${foo() ? </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> : </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'y'</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> }</span></span></span><span class="hljs-string">`</span></span></code> </pre> <br> 文本<code>something 6</code>将进入<code>string</code>常量，或者文本<code>something x</code>或文本<code>something y</code>将被写入常量<code>string2</code> 。 这取决于函数<code>foo()</code>返回true还是false（此处使用三元运算符，如果在问号之前为true，则返回三进制运算符，否则返回在问号之后的内容。冒号之后）。 <br><br><h3>  <font color="#3AC1EF">▍带标签的模板</font> </h3><br> 带标记的模板在许多流行的库中使用。 其中包括<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">样式化组件</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Apollo</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GraphQL</a> 。 <br><br> 这种模式输出的内容取决于该函数定义的某些逻辑。 这是我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">出版物</a>之一中的一个稍作修改的示例，说明了如何使用带标签的模板字符串。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> esth = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">helper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">strs, ...keys</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> str1 = strs[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-comment"><span class="hljs-comment">//ES const str2 = strs[1] //is let additionalPart = '' if (keys[0] == 8) { //8   additionalPart = 'awesome' } else {   additionalPart = 'good' } return `${str1}${keys[0]}${str2}${additionalPart}.` } const es = helper`ES ${esth} is ` console.log(es) //ES 8 is awesome.</span></span></code> </pre> <br> 在这里，如果数字<code>8</code>用<code>esth</code>常数写的，那么<code>ES 8 is awesome</code>行将是<code>es</code> 。 否则，将有另一行。 例如，如果<code>esth</code>数字<code>6</code> ，则看起来<code>ES 6 is good</code> 。 <br><br> 样式化组件使用标记的模板来定义CSS字符串。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = styled.button<span class="hljs-string"><span class="hljs-string">` font-size: 1.5em; background-color: black; color: white; `</span></span>;</code> </pre> <br> 在Apollo，它们用于定义GraphQL查询。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> query = gql<span class="hljs-string"><span class="hljs-string">` query {   ... } `</span></span></code> </pre> <br> 了解了标记模板的工作原理后，可以很容易地理解前面示例中的<code>styled.button</code>和<code>gql</code>只是函数。 <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gql</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">literals, ...expressions</span></span></span><span class="hljs-function">) </span></span>{ }</code> </pre> <br> 例如， <code>gql()</code>函数返回的字符串可能是任何计算的结果。 此函数的<code>literals</code>参数是一个数组，其中包含模板文字的内容，该内容分为多个部分， <code>expresions</code>包含计算表达式的结果。 <br><br> 让我们分析下一行。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = helper<span class="hljs-string"><span class="hljs-string">`something </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> `</span></span></code> </pre> <br>  <code>helper</code>函数获取包含两个元素的<code>literals</code>数组。 在第一个文本后面有一个空格，在第二个文本中有一个空行-即表达式<code>${1 + 2 + 3}</code>与该行的末尾之间是什么。  <code>espressions</code>数组中将只有一个元素<code>6</code> 。 <br> 这是一个更复杂的示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string = helper<span class="hljs-string"><span class="hljs-string">`something another </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'x'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> new line </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">1</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">2</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> + </span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">3</span></span></span></span><span class="hljs-string"><span class="hljs-subst">}</span></span></span><span class="hljs-string"> test`</span></span></code> </pre> <br> 在这里，在<code>helper</code>函数中，下一个数组将作为第一个参数。 <br><br><pre> <code class="javascript hljs">[ <span class="hljs-string"><span class="hljs-string">'something\nanother '</span></span>, <span class="hljs-string"><span class="hljs-string">'\nnew line '</span></span>, <span class="hljs-string"><span class="hljs-string">'\ntest'</span></span> ]</code> </pre> <br> 第二个数组将如下所示。 <br><br><pre> <code class="javascript hljs">[ <span class="hljs-string"><span class="hljs-string">'x'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span> ]</code> </pre> <br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 今天，我们讨论了异常处理，分号自动替换以及JavaScript中的模板文字。 下次，我们将介绍该语言的一些更重要的概念。 特别是-在严格模式下工作，计时器，数学计算。 <br><br>  <b>亲爱的读者们！</b> 您是否在JavaScript中使用标记模板的功能？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN430376/">https://habr.com/ru/post/zh-CN430376/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN430362/index.html">推出具有长期支持的免费OpenJDK Amazon Corretto</a></li>
<li><a href="../zh-CN430364/index.html">“在我看来，我们正在接近每个人都可以进行编码的时代。 代码是自由。”</a></li>
<li><a href="../zh-CN430366/index.html">VR厨房：头盔中看不到的东西</a></li>
<li><a href="../zh-CN430372/index.html">氢气车。 是时候跟汽油说再见了吗？</a></li>
<li><a href="../zh-CN430374/index.html">数据工程及其他：毁录会议录像带和幻灯片</a></li>
<li><a href="../zh-CN430378/index.html">J2CL-迟到总比不到好</a></li>
<li><a href="../zh-CN430380/index.html">JavaScript指南第5部分：数组和循环</a></li>
<li><a href="../zh-CN430382/index.html">JavaScript指南第4部分：功能</a></li>
<li><a href="../zh-CN430384/index.html">根据噪声特征创建地图</a></li>
<li><a href="../zh-CN430386/index.html">印度将建设固态存储电站</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>