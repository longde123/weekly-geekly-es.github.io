<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☄️ 🏕️ 👨🏽‍🚀 讲座课程“数字信号处理基础” 🤸🏽 🥈 ☝🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好！ 

 人们经常向我询问有关数字信号处理（DSP）领域的任务的问题。 我详细介绍了细微差别，提出了必要的信息来源。 但是，正如时间所表明的那样，所有听众在学习这一领域的过程中都缺乏实际的任务和例子。 在这方面，我决定编写有关数字信号处理的简短交互式课程，并将其放在公共领域 。 

 大部分用...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>讲座课程“数字信号处理基础”</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460445/"> 大家好！ <br><br> 人们经常向我询问有关数字信号处理（DSP）领域的任务的问题。 我详细介绍了细微差别，提出了必要的信息来源。 但是，正如时间所表明的那样，所有听众在学习这一领域的过程中都缺乏实际的任务和例子。 在这方面，我决定编写有关数字信号处理的简短交互式课程，并将其放在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">公共领域</a> 。 <br><br> 大部分用于视觉和交互式演示的培训材料都是使用<i>Jupyter Notebook</i>实现的。 假定读者具有高等数学领域的基础知识，并且对Python编程语言有一点了解。 <br><br><img src="https://habrastorage.org/webt/vh/4z/ci/vh4zciifrdxclttqfvmpul0zv5a.png"><br><a name="habracut"></a><br><h2> 讲座清单 </h2><br> 本课程包含有关数字信号处理领域各种主题的演讲形式。 使用Python库（numpy，scipy，matplotlib包等）展示材料。 本课程的基本信息取材自我的演讲，我作为研究生向莫斯科能源学院（NRU MEI）的学生提供了这些演讲。 这些演讲的部分信息在我担任讲师的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">当代电子中心的</a>培训研讨会上使用。 此外，该材料还包括翻译各种科学文章，汇编可靠信息和有关数字信号处理的文献中的信息，以及有关应用程序包和Python scipy和numpy库的内置函数的官方文档。 <br><br> 对于MATLAB（GNU Octave）用户，从程序代码的角度掌握材料并不困难，因为主要功能及其属性在很大程度上与Python库中的方法相同且相似。 <br><br> 所有材料均按数字信号处理的主要主题分组： <br><br><ol><li> 信号：模拟，离散，数字。  Z转换 </li><li> 傅立叶变换：幅度和相位信号，DFT和FFT， </li><li> 卷积和相关。 线性和循环卷积。 快速卷积 </li><li> 随机过程。 白噪声。 概率密度函数 </li><li> 确定性信号。 调制方式：AM，FM，FM，LFM。 操纵 </li><li> 信号滤波：IIR，FIR滤波器 </li><li> 窗口在过滤任务中起作用。 检测弱信号。 </li><li> 重采样：抽取和内插。  CIC滤波器，移动平均滤波器 </li></ol><br><br> 讲座列表足够多， <s>但是</s>对于DSP领域的入门<s>者来说当然是不完整</s>的。 我计划在空闲时间支持和开发该项目。 <br><br><h3> 在哪里找到？ </h3><br> 所有资料都是<b>绝对免费的</b> ，可以作为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的github</a>上的开放源代码作为一个开放源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">项目获得</a> 。 资料以两种格式呈现-用于交互工作，学习和编辑的Jupyter Notebook形式，以及从这些笔记本编译的HTML文件的形式（从github下载后，它们具有非常适合阅读和打印的格式）。 <br><br> 以下是对课程各部分的简短说明，并附有简短的说明，术语和定义。 最初的讲座中提供了基本信息，这里只是简要概述！ <br><br><h3> 信号。  Z转换 </h3><br> 简介部分，其中包含有关信号类型的基本信息。 介绍了离散序列，delta函数和Heaviside函数（单位跳跃）的概念。 <br><br> 根据信号集呈现方法的不同，所有信号可分为四类： <br><ul><li> 模拟-由时间上连续的功能描述， </li><li> 离散-通过采样指定的步骤及时中断， </li><li> 量化-具有一组有限的水平（通常为振幅）， </li><li> 数字-离散信号和量化信号的属性的组合。 </li></ul><br><br><img src="https://habrastorage.org/webt/1f/l4/te/1fl4te_9ataaovtla-4morc9uwa.png" alt="讯号"><br><br> 为了从数字信号正确重建模拟信号而没有失真和损失，使用了称为<b>Kotelnikov（奈奎斯特-香农）</b>定理的采样定理。 <br><blockquote> 具有有限频谱的任何连续信号都可以唯一地恢复，而不会因其离散采样而损失，该离散采样的频率严格大于连续信号频谱上限频率的两倍。 </blockquote><br> 只要时间的连续函数占用从0到上限频率的频带，这种解释就是有效的。 如果错误地选择了量化和离散步骤，则信号将从模拟失真变为离散失真。 <br><br> 同样在本节中，描述了<b>Z变换</b>及其属性，并显示了Z形式的离散序列的表示形式。 <br><br> 有限离散序列的示例： <br><pre><code class="python hljs">x(nT) = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre>  。 <br>  Z形式的相同序列的示例： <br><br>  X（z）= 2 + z -1-2z <sup>-2</sup> + 2z <sup>-4</sup> + 3z <sup>-5</sup> + 1z <sup>-6</sup> <br><br><h3> 傅立叶变换。 物产  DFT和FFT </h3><br> 本节介绍信号的时域和频域的概念。 介绍了离散傅里叶变换（DFT）的定义。 考虑了直接和逆DFT及其主要属性。 显示的是从DFT到基数2的快速傅立叶变换（FFT）算法的转换（频率和时间的抽取算法）。 反映了FFT与DFT相比的有效性。 <br><br> 特别是，本节介绍了Python包scipy.ffpack，用于计算各种傅立叶变换（正弦，余弦，正弦，逆向，多维，实数）。 <br><br> 傅立叶变换使您可以将任何函数表示为一组谐波信号！ 傅里叶变换是卷积方法和数字相关器设计的基础，被积极地用于频谱分析中，并在处理长整数时使用。 <br><br> 离散信号频谱的特征： <br>  1.离散信号的频谱密度是周期函数，周期等于采样频率。 <br>  2.如果离散序列为<i>实数</i> ，则该序列的频谱密度模量为<i>偶</i>函数，自变量为<i>奇数</i>频率函数。 <br><br> 谐波信号频谱： <br><br><img src="https://habrastorage.org/webt/if/gy/k4/ifgyk4dlgjakj-zrkd3vpzq8c24.png" alt="余弦的FFT"><br><br><h4>  DFT和FFT的功效比较 </h4><br>  FFT算法的效率和线性执行的操作数取决于序列长度N： <br><br><div class="scrollable-table"><table><thead><tr><th rowspan="2">  ñ </th><th colspan="2">  DFT </th><th colspan="2"> 快速傅立叶变换 </th><th rowspan="2"> 复杂加法数的比例 </th><th rowspan="2"> 复数乘法的比率 </th></tr><tr><th> 乘法运算次数 </th><th> 加法运算次数 </th><th> 乘法运算次数 </th><th> 加法运算次数 </th></tr></thead><tbody><tr><td>  2 </td><td>  4 </td><td>  2 </td><td>  1个 </td><td>  2 </td><td>  4 </td><td>  1个 </td></tr><tr><td>  4 </td><td>  16 </td><td>  12 </td><td>  4 </td><td>  8 </td><td>  4 </td><td>  1.5 </td></tr><tr><td>  8 </td><td>  64 </td><td>  56 </td><td>  12 </td><td>  24 </td><td>  5.3 </td><td>  2.3 </td></tr><tr><td>  16 </td><td>  256 </td><td>  240 </td><td>  32 </td><td>  64 </td><td>  8 </td><td>  3.75 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  992 </td><td>  80 </td><td>  160 </td><td>  12.8 </td><td>  6.2 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  4032 </td><td>  192 </td><td>  384 </td><td>  21.3 </td><td>  10.5 </td></tr><tr><td>  128 </td><td>  16384 </td><td>  16256 </td><td>  448 </td><td>  896 </td><td>  36.6 </td><td>  18.1 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  4096 </td><td>  16777216 </td><td>  16773120 </td><td>  24576 </td><td>  49152 </td><td>  683 </td><td>  341 </td></tr><tr><td>  8192 </td><td>  67108864 </td><td>  67100672 </td><td>  53248 </td><td>  106496 </td><td>  <b>1260</b> </td><td>  <b>630</b> </td></tr></tbody></table></div><br> 如您所见，转换时间越长，在计算资源（就处理速度或硬件单元数量而言）方面的节省就越大！ <br><br> 任何任意波形都可以表示为一组不同频率的谐波信号。 换句话说，时域中形状复杂的信号在频域中具有一组复杂样本，称为*谐波*。 这些样本表示特定频率下谐波效应的幅度和相位。 频域中的谐波组越大，复杂波形出现的越准确。 <br><br><img src="https://habrastorage.org/webt/vj/i1/dg/vji1dgvf4ak0dsvjhlmx7mmhj6q.png" alt="FFT吉布斯"><br><br><h3> 卷积与相关 </h3><br> 本节介绍离散随机和确定性序列的相关和卷积概念。 示出了具有卷积的自相关函数和互相关函数之间的关系。 描述了卷积的性质，特别是考虑了离散信号的线性和循环卷积方法，并以离散序列为例进行了详细分析。 此外，显示了一种使用FFT算法计算“快速”卷积的方法。 <br><br> 在实际问题中，通常会提出一个过程与另一个过程的相似程度或一个过程与另一个过程之间的独立性的问题。 换句话说，需要确定信号之间的关系，即找到<i>相关性</i> 。 相关方法用于各种任务：信号搜索，计算机视觉和图像处理，雷达问题中，以确定目标的特性并确定距物体的距离。 另外，相关性用于搜索噪声中的微弱信号。 <br><br>  <b>卷积</b>描述了信号之间的相互作用。 如果信号之一是滤波器的脉冲响应，则输入序列与脉冲响应的卷积只是电路对输入动作的反应。 换句话说，所得信号反映了信号通过滤波器的通道。 <br><br>  <i>自相关函数</i> （ACF）用于编码信息。 根据长度，频率和形状的参数来选择编码序列很大程度上是由于该序列的相关特性。 最佳代码序列的错误检测或操作（用于检测信号，阈值设备）或错误同步（用于发送和接收代码序列）的可能性最低。 <br><br> 本节提供了一个表格，比较了快速卷积和通过直接公式计算的卷积（通过实数乘法）的有效性。 <br><br> 如您所见，对于FFT长度最大为64的情况，快速卷积<u>会丢失</u>直接方法。 但是，随着FFT长度的增加，结果朝相反的方向变化-快速卷积开始优于直接方法。 显然，FFT越长，频率法的增益就越好。 <br><br><div class="scrollable-table"><table><thead><tr><th>  ñ </th><th> 卷积 </th><th> 快速卷积 </th><th> 态度 </th></tr></thead><tbody><tr><td>  8 </td><td>  64 </td><td>  448 </td><td>  0.14 </td></tr><tr><td>  16 </td><td>  256 </td><td>  1088 </td><td>  0.24 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  2560 </td><td>  0.4 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  5888 </td><td>  0.7 </td></tr><tr><td>  128 </td><td>  16K </td><td>  13312 </td><td>  1.23 </td></tr><tr><td>  ... </td><td>  ... </td><td>  .. </td><td>  ... </td></tr><tr><td>  2048 </td><td>  4M </td><td>  311296 </td><td>  <b>13.5</b> </td></tr></tbody></table></div><br><h3> 随机信号和噪声 </h3><br> 在本节中，介绍了随机信号，概率密度和随机分布定律的概念。 考虑数学矩-均值（数学期望）和方差（或该数量的根是标准偏差）。 同样在本节中，正态分布和<i>白噪声</i>的相关概念也被认为是信号处理过程中的主要噪声源（干扰）。 <br><br>  <i>随机信号</i>是时间的函数，其值事先未知，只能以一定<i>概率</i>预测。 随机信号的主要特征包括： <br><br><ul><li> 分布规律（信号值在一定间隔内的相对停留时间）， </li><li> 信号功率的频谱分布。 </li></ul><br><br><img src="https://habrastorage.org/webt/sh/02/ft/sh02ftx_0_ynupvdlzo7uvgmeds.png" alt="噪音AWGN"><br><br> 在DSP任务中，随机信号分为两类： <br><br><ul><li> 噪声-由一组不同的频率和幅度组成的随机波动， </li><li> 载有信息的信号，对此进行处理必须采用概率方法。 </li></ul><br><br> 使用随机变量，我们可以模拟真实介质对信号从源到数据接收器的传递的影响。 当信号通过一些嘈杂的链路时，所谓的白噪声会添加到信号中。 通常，这种噪声的频谱密度在所有频率上均等（均匀）分布，并且时域中的噪声值呈正态分布（高斯分布定律）。 由于在选定的时间样本中将白噪声物理地添加到信号幅度中，因此将其称为加性高斯白噪声（AWGN）。 <br><br><h3> 信号，调制和操纵 </h3><br> 本节介绍了更改谐波信号的一个或多个参数的基本方法。 介绍了幅度，频率和相位调制的概念。 特别强调了雷达问题中使用的线性频率调制。 显示了信号的主要特征，即取决于调制参数的已调制信号的频谱。 <br><br><img src="https://habrastorage.org/webt/b9/sw/c6/b9swc66eoj37yobhgypvjmwizni.png" alt="频率调制"><br><br> 为了方便起见，已在Python中创建了一组实现上述调制类型的函数。 线性调频信号实现示例： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_chirp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amp=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, freq=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, beta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, period=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Create Chirp signal Parameters ---------- amp : float Signal magnitude beta : float Modulation bandwidth: beta &lt; N for complex, beta &lt; 0.5N for real freq : float or int Linear frequency of signal period : integer Number of points for signal (same as period) kwargs : bool Complex signal if is_complex = True Modulated by half-sine wave if is_modsine = True """</span></span> is_complex = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_complex'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) is_modsine = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_modsine'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) t = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, period) tt = np.pi * (freq * t + beta * t ** <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_complex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = amp * (np.cos(tt) + <span class="hljs-number"><span class="hljs-number">1j</span></span> * np.sin(tt)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = amp * np.cos(tt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_modsine <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res * np.sin(np.pi * t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><img src="https://habrastorage.org/webt/ug/ad/85/ugad85xkc0ml7p2e4kgv5niqnbs.png" alt="线性调频调制"><br><br> 同样在本节中，根据离散消息的传输理论，描述了数字调制的类型-操作。 与模拟信号一样，数字谐波序列可以在幅度，相位和频率（或同时几个参数）上进行操作。 <br><br><img src="https://habrastorage.org/webt/yl/w9/8q/ylw98qsdcnn3kaivfz2cdasrxry.png" alt="频率操纵"><br><br><h3> 数字滤波器-IIR和FIR </h3><br> 足够大的部分专门用于离散序列的数字滤波。 在数字信号处理任务中，数据流经称为<b>滤波器的</b>电路。 数字滤波器与模拟滤波器一样，具有不同的特性-频率：频率响应，相位响应，时间：脉冲响应以及滤波器的传输特性。 数字滤波器主要用于提高信号质量-将信号与数据序列隔离，或降低不需要的信号-抑制输入采样序列中的某些信号。 <br><br><img src="https://habrastorage.org/webt/mp/2m/oy/mp2moyuibf5qgzlb19d8ne_gw-q.png" alt="IIR FIR信号"><br><br> 本节列出了数字滤波器（与模拟滤波器相比）的主要优缺点。 介绍了滤波器的脉冲和传递特性的概念。 考虑了两类滤波器-具有无限脉冲响应（IIR）和有限脉冲响应（FIR）。 显示了一种以<b>规范</b>和<b>直接</b>形式设计过滤器的方法。 对于FIR滤波器，考虑了如何切换到递归形式的问题。 <br><br><img src="https://habrastorage.org/webt/qn/m5/x5/qnm5x5wguwanmzjfst2erf0orsa.png" alt="IIR FIR方案"><br><br> 对于FIR滤波器，从技术规范的开发阶段（标明主要参数）到软件和硬件的实现-滤波器系数的搜索（考虑到数字，位深等的表示形式）显示了滤波器的设计过程。 介绍了对称FIR滤波器的定义，线性相位响应及其与群时延概念的关系。 <br><br><img src="https://habrastorage.org/webt/7d/ng/vy/7dngvygzcdsyc4dacklcae2ddsa.png" alt="FIR全路径"><br><br><h3> 过滤任务中的窗口功能 </h3><br> 在数字信号处理任务中，使用了各种形状的窗函数，当它们在时域中叠加到信号上时，可以定性地改善其频谱特性。 大量的各种窗口主要是由于任何窗口覆盖的主要功能之一。 该特征通过旁瓣的水平与中央瓣的宽度之间的关系来表达。 规则： <br><blockquote> 频谱旁瓣的抑制能力越强，频谱的主瓣越宽，反之亦然。 </blockquote><br><img src="https://habrastorage.org/webt/lc/mx/em/lcmxemylmukc0mf5xtbwrudsbrm.png" alt="获胜（时间）"><br><br> 窗口功能的应用之一：通过抑制旁瓣电平，在较强信号的背景下检测弱信号。  DSP任务中的主要窗口功能是**三角形，正弦曲线，Lanczos，Hann，Hamming，Blackman，Harris，Blackman-Harris窗口，平顶窗口，Natall，Gauss，Kaiser窗口**等。 它们中的大多数通过对具有特定权重的谐波信号求和而通过有限级数表示。 实际上，此类信号可以在任何硬件设备（可编程逻辑电路或信号处理器）上完美实现。 <br><br><img src="https://habrastorage.org/webt/qo/vo/qg/qovoqg__dcfm--hjd0ibos_m-fm.png" alt="获胜（频率）"><br><br><h3> 重采样。 抽取和插值 </h3><br> 本节讨论多速信号处理的问题-采样频率的变化。 信号的多速处理（多速率处理）表明，在数字信号的线性转换过程中，可以沿减少或增加的方向或分数倍的方向更改采样频率。 这将导致更高效的信号处理，因为它开辟了使用最小允许采样频率的可能性，从而大大降低了设计数字系统所需的计算性能。 <br><br>  <i>抽取</i> （抽取）-下采样。  <i>插值</i> -增加采样率。 <br><br> 本节还考虑了同类FIR滤波器的类别，它们称为积分梳状滤波器（CIC，级联积分器-梳状）。 显示了CIC滤波器的实现，基本属性和功能。 由于CIC滤波器中发生的数学运算具有线性关系，因此有可能将多个滤波器连续级联，这会成比例地降低旁瓣电平，但也会增加幅度-频率特性主瓣的“阻塞”。 <br><br><img src="https://habrastorage.org/webt/qg/ef/ye/qgefyerrdczmun9os1vetvxxdsy.png" alt="级联CIC滤波器"><br><br> 取决于抽取系数的滤波器频率响应图： <br><br><img src="https://habrastorage.org/webt/b8/lh/qz/b8lhqzdsk-tcnqxkq9pimvteq4g.png" alt="CIC频率回应"><br><br> 在本节中，我们还将讨论根据CIC滤波器的参数增加数据位深的问题。 这在软件实现任务中尤其重要，特别是在FPGA上。 <br><br> 为了在Python中实际实现CIC过滤器， <b>已经开发</b>了一个单独的类<b>CicFilter</b> ，该类实现了抽取和插值方法。 还显示了使用scipy Python软件包中的内置方法进行的采样率更改。 <br><br><div class="spoiler">  <b class="spoiler_title">用于数字信号处理的Python CicFilter类</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CicFilter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Cascaded Integrator-Comb (CIC) filter is an optimized class of finite impulse response (FIR) filter. CIC filter combines an interpolator or decimator, so it has some parameters: R - decimation or interpolation ratio, N - number of stages in filter (or filter order) M - number of samples per stage (1 or 2)* * for this realisation of CIC filter just leave M = 1. CIC filter is used in multi-rate processing. In hardware applications CIC filter doesn't need multipliers, just only adders / subtractors and delay lines. Equation for 1st order CIC filter: y[n] = x[n] - x[n-RM] + y[n-1]. Parameters ---------- x : np.array input signal """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.x = x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decimator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, r, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" CIC decimator: Integrator + Decimator + Comb Parameters ---------- r : int decimation rate n : int filter order """</span></span> <span class="hljs-comment"><span class="hljs-comment"># integrator y = self.x[:] for i in range(n): y = np.cumsum(y) # decimator y = y[::r] # comb stage return np.diff(y, n=n, prepend=np.zeros(n)) def interpolator(self, r, n, mode=False): """ CIC inteprolator: Comb + Decimator + Integrator Parameters ---------- r : int interpolation rate n : int filter order mode : bool False - zero padding, True - value padding. """ # comb stage y = np.diff(self.x, n=n, prepend=np.zeros(n), append=np.zeros(n)) # interpolation if mode: y = np.repeat(y, r) else: y = np.array([i if j == 0 else 0 for i in y for j in range(r)]) # integrator for i in range(n): y = np.cumsum(y) if mode: return y[1:1 - n * r] else: return y[r - 1:-n * r + r - 1]</span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/webt/mt/ri/b5/mtrib5pqroyzezup5m9ulqsklzg.png" alt="CIC抽取/插值"><br><br> 最后，本节提供一类特殊的过滤器-移动平均线。 展示了三种实现方法：通过使用FIR滤波器和IIR滤波器对信号进行卷积。 <br><br><img src="https://habrastorage.org/webt/0m/b7/rf/0mb7rfvv_e6vuzt9xqsumvgs7eq.png" alt="MAF，移动平均线过滤器"><br><br><h3> 结论 </h3><br> 我希望本讲课课程与我以前有关数字FPGA信号处理的文章结合起来，将带来实际的好处，并帮助读者更好地理解数字信号处理的基础。 该项目将得到改进，并补充新的有用且有趣的材料。 跟随发展！ <br><br> 除了本材料之外，我还在主要的DSP模块（使用Python）上支持和开发<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">我的项目</a> 。 它包含一个用于生成各种信号的程序包，一类用于抽取和插值问题的CIC滤波器，一种用于计算校正FIR滤波器的系数的算法，一个移动平均滤波器，一种用于通过二维转换方法计算超长FFT的算法（后者在与FPGA上的硬件实现一起使用时非常有用） 。 <br><br> 感谢您的关注！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460445/">https://habr.com/ru/post/zh-CN460445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460435/index.html">小小快乐＃8：使用数据库的小快乐</a></li>
<li><a href="../zh-CN460437/index.html">我们如何推出技术支持自行车</a></li>
<li><a href="../zh-CN460439/index.html">P4编程语言</a></li>
<li><a href="../zh-CN460441/index.html">格莱布·尼兹曼（Gleb Nitzman）：“我发现了一个时代的尽头，那时人们还没有追逐无线电元素中所含的黄金”</a></li>
<li><a href="../zh-CN460443/index.html">设计师与开发商：关于“我的智慧城市”应用程序创建的历史</a></li>
<li><a href="../zh-CN460451/index.html">人类为了艺术而用了他的第三只耳朵-为了艺术</a></li>
<li><a href="../zh-CN460453/index.html">智能打印机。 改善八印</a></li>
<li><a href="../zh-CN460457/index.html">DIY太阳能电站200 m2</a></li>
<li><a href="../zh-CN460459/index.html">配置文件htaccess</a></li>
<li><a href="../zh-CN460461/index.html">模拟目标攻击作为安全评估。 红队网络说明</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>