<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÜ üññüèº üç∂ Inventando a biblioteca vusb üë©üèø‚Äçüè´ ‚òëÔ∏è üëãüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 


 Depois de ler o nome, uma pergunta l√≥gica pode surgir: por que hoje em dia estudamos a implementa√ß√£o de software de USB de baixa vel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Inventando a biblioteca vusb</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460815/"><h2 id="vvedenie">  1. Introdu√ß√£o </h2><br><p>  Depois de ler o nome, uma pergunta l√≥gica pode surgir: por que hoje em dia estudamos a implementa√ß√£o de software de USB de baixa velocidade quando existem v√°rios controladores baratos com um m√≥dulo de hardware?  O fato √© que o m√≥dulo de hardware, ocultando o n√≠vel de troca de n√≠veis l√≥gicos, transforma o protocolo USB em uma esp√©cie de m√°gica.  Para sentir como essa ‚Äúm√°gica‚Äù funciona, n√£o h√° nada melhor do que reproduzi-la do zero, come√ßando no n√≠vel mais baixo. </p><br><p>  Para esse fim, tentaremos criar um dispositivo fingindo ser USB-HID com base no controlador ATmega8.  Diferentemente da literatura difundida, n√£o iremos da teoria √† pr√°tica, do n√≠vel mais baixo ao mais alto, das tens√µes l√≥gicas √†s conclus√µes e terminamos com a "inven√ß√£o" do mesmo vusb, ap√≥s cada etapa, verificando se o c√≥digo funciona como esperado.  Separadamente, observo que n√£o invento uma alternativa a essa biblioteca, mas reproduzi consistentemente seu c√≥digo-fonte, preservando a estrutura e os nomes originais o m√°ximo poss√≠vel, explicando por que essa ou aquela se√ß√£o serve.  No entanto, meu estilo usual de escrever c√≥digo √© diferente do estilo dos autores de vusb.  Imediatamente, admito sinceramente que, al√©m do interesse altru√≠sta (contar um t√≥pico dif√≠cil para os outros), tamb√©m tenho um interesse ego√≠sta - estudar o t√≥pico por conta pr√≥pria e captar no m√°ximo um n√∫mero de pontos sutis para mim.  Segue-se tamb√©m que algum ponto importante pode ser esquecido ou algum t√≥pico n√£o √© totalmente divulgado. </p><br><p>  Para uma melhor compreens√£o do c√≥digo, tentei destacar as se√ß√µes alteradas com coment√°rios e remov√™-las das se√ß√µes discutidas anteriormente.  Na verdade, o c√≥digo fonte ser√° a principal fonte de informa√ß√£o, e o texto explicar√° o que foi feito e por que, al√©m de qual resultado √© esperado. </p><br><p>  Tamb√©m observo que apenas o USB de baixa velocidade √© considerado, mesmo sem mencionar, o que distingue mais variedades de alta velocidade. </p><a name="habracut"></a><br><h2 id="shag-0-zhelezo-i-prochaya-podgotovka">  Etapa 0. Ferro e outra prepara√ß√£o </h2><br><p>  Como teste, vamos fazer uma placa de depura√ß√£o caseira baseada no ATmega8 com quartzo de 12 MHz.  N√£o vou dar o esquema, √© bastante padr√£o (consulte o site oficial da vusb), a √∫nica coisa que vale a pena mencionar s√£o as conclus√µes utilizadas.  No meu caso, a sa√≠da D + corresponde ao PD2, a sa√≠da D-PD3 e o suspensor fica no PD4.  Em princ√≠pio, um resistor pull-up pode ser conectado √† energia, mas o controle manual parece um pouco mais consistente com o padr√£o. </p><br><p>  A alimenta√ß√£o de 5 V √© fornecida pelo conector USB; no entanto, n√£o s√£o esperados mais de 3,6 V nas linhas de sinal (por que isso foi um mist√©rio para mim).  Portanto, voc√™ precisa diminuir a pot√™ncia do controlador ou colocar os diodos zener nas linhas de sinal.  Eu escolhi a segunda op√ß√£o, mas em geral isso n√£o importa. </p><br><p>  Como estamos ‚Äúinventando‚Äù a implementa√ß√£o, seria bom ver o que acontece no c√©rebro do controlador, ou seja, pelo menos algum tipo de informa√ß√£o de depura√ß√£o √© necess√°ria.  No meu caso, esses s√£o dois LEDs no PD6, PD7 e, o mais importante, UART no PD0, PD1, configurado no 115200, para que voc√™ possa ouvir a conversa do controlador atrav√©s de uma tela regular ou de outro programa para trabalhar com a porta COM: </p><br><pre><code class="bash hljs">$ screen /dev/ttyUSB0 115200</code> </pre> <br><p>  Al√©m disso, um wireshark com o m√≥dulo apropriado se tornar√° um utilit√°rio √∫til para a depura√ß√£o USB (nem sempre come√ßa da caixa, mas a solu√ß√£o desses problemas est√° localizada com sucesso na Internet e n√£o √© a tarefa deste artigo). </p><br><p>  Aqui seria poss√≠vel gastar outro kilobyte de texto na descri√ß√£o do programador, makefiles e outras coisas, mas isso dificilmente faz sentido.  Da mesma forma, n√£o vou focar nas configura√ß√µes perif√©ricas que n√£o est√£o relacionadas ao USB.  Se algu√©m n√£o consegue entender isso, √© muito cedo para entrar nas entranhas do software USB? </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O c√≥digo fonte de todas as etapas est√° dispon√≠vel no Github.</a> </p><br><h2 id="shag-1-prinimaem-hot-chto-to">  Etapa 1. Aceite pelo menos algo </h2><br><p>  De acordo com a documenta√ß√£o, o USB suporta v√°rias velocidades fixas, das quais o AVR obter√° apenas as mais baixas: 1,5 megabits por segundo.  √â determinado pelo resistor de pull-up e comunica√ß√£o subsequente.  Para a frequ√™ncia escolhida, o resistor deve conectar D- a uma fonte de alimenta√ß√£o de 3,3 V e ter um valor nominal de 1,5 kOhm, mas, na pr√°tica, pode ser conectado com +5 V e o valor nominal pode variar ligeiramente.  Com uma frequ√™ncia de controlador de 12 MHz, apenas 8 ciclos de clock por bit.  √â claro que essa precis√£o e velocidade s√£o alcan√ß√°veis ‚Äã‚Äãapenas no assembler, por isso abriremos o arquivo drvasm.S  Isso tamb√©m implica a necessidade de usar uma interrup√ß√£o para capturar o in√≠cio de um byte.  Fico feliz que o primeiro byte transmitido via USB seja sempre o mesmo, SYNC, por isso, se voc√™ come√ßar, tudo bem.  Como resultado, desde o in√≠cio do byte at√© o final, apenas 64 ciclos do controlador ocorrem (na verdade, a margem √© ainda menor); portanto, voc√™ n√£o deve usar outras interrup√ß√µes que n√£o sejam USB. </p><br><p>  Coloque imediatamente a configura√ß√£o em um arquivo usbconfig.h separado.  √â a√≠ que ser√£o definidos os pinos respons√°veis ‚Äã‚Äãpelo USB, bem como os bits, constantes e registradores utilizados. </p><br><blockquote>  <strong>Inser√ß√£o te√≥rica</strong> <br>  A transfer√™ncia via USB √© realizada em pacotes de v√°rios bytes em cada um.  O primeiro byte √© sempre o byte de sincroniza√ß√£o SYNC, igual a 0b10000000, o segundo √© o identificador de byte do pacote PID.  A transfer√™ncia de cada byte vai do bit menos significativo para o mais significativo (isso n√£o √© inteiramente verdade, mas no vusb essa sutileza √© ignorada, dada em outro lugar) usando a codifica√ß√£o NRZI.  Esse m√©todo consiste no fato de que um zero l√≥gico √© transmitido alterando o n√≠vel l√≥gico para o oposto, e uma unidade l√≥gica √© transmitida por n√£o altera√ß√£o.  Al√©m disso, a prote√ß√£o √© introduzida contra a dessincroniza√ß√£o (que n√£o usaremos, mas deve ser levada em considera√ß√£o) da fonte e do receptor do sinal: se houver seis unidades consecutivas na sequ√™ncia transmitida, ou seja, por seis rel√≥gios consecutivos o estado dos terminais n√£o muda, uma invers√£o for√ßada √© adicionada √† transmiss√£o, como se zero √© transmitido.  Assim, o tamanho do byte pode ser 8 ou 9 bits. <br>  Tamb√©m vale ressaltar que as linhas de dados em USB s√£o diferenciais, ou seja, quando D + √© alto, D- √© baixo (isso √© chamado de estado K) e vice-versa (estado J).  Isso √© feito para melhorar a imunidade a ru√≠dos em alta frequ√™ncia.  √â verdade que h√° uma exce√ß√£o: o sinal no final do pacote (chamado SE0) √© transmitido puxando as duas linhas de sinal para o solo (D + = D- = 0).  H√° mais dois sinais transmitidos mantendo uma baixa tens√£o na linha D + e uma alta tens√£o na linha D + por diferentes momentos.  Se o tempo for pequeno (comprimento de um byte ou um pouco mais), isso ser√° Inativo, uma pausa entre pacotes e, se for grande, um sinal de redefini√ß√£o. </blockquote><p>  Portanto, a transmiss√£o √© feita em um par diferencial, sem contar o caso ex√≥tico do SE0, mas ainda n√£o o consideraremos.  Portanto, para determinar o status do barramento USB, precisamos de apenas uma linha, D + ou D-.  De um modo geral, n√£o h√° diferen√ßa qual escolher, mas por defini√ß√£o deixe D- ser. </p><br><p>  O in√≠cio do pacote pode ser determinado pelo recebimento do byte SYNC ap√≥s um longo tempo inativo.  O estado Idle corresponde ao log.1 na linha D (tamb√©m √© o estado J) e o byte SYNC √© 0b100000, mas √© transmitido do bit menos significativo para o mais significativo, al√©m disso, √© codificado em NRZI, ou seja, cada zero significa invers√£o de sinal e um significa mantendo o mesmo n√≠vel.  Portanto, a sequ√™ncia dos estados D- ser√° a seguinte: </p><br><div class="scrollable-table"><table><thead><tr><th>  byte </th><th>  Inativo </th><th>  SYNC </th><th>  PID </th></tr></thead><tbody><tr><td>  USB </td><td>  1..1 </td><td>  00000001 </td><td>  ???????? </td></tr><tr><td>  D- </td><td>  1..1 </td><td>  01010100 </td><td>  ???????? </td></tr></tbody></table></div><br><p>  O in√≠cio do pacote √© mais f√°cil de detectar em uma borda descendente e configuraremos uma interrup√ß√£o nele.  Mas e se o controlador estiver ocupado durante o in√≠cio da recep√ß√£o e n√£o puder entrar na interrup√ß√£o imediatamente?  Para evitar a perda de contagens de faixa em tal situa√ß√£o, usamos o byte SYNC para a finalidade a que se destina.  Ele consiste inteiramente de frentes nos limites dos bits, para que possamos esperar por um deles, depois outro meio-bit, e ir direto para o meio do pr√≥ximo.  No entanto, esperar por uma frente de "alguns" n√£o √© uma boa id√©ia, porque precisamos n√£o apenas entrar no meio da briga, mas tamb√©m saber que brecha chegamos √† pontua√ß√£o.  E para este SYNC tamb√©m √© adequado: ele tem dois bits zero seguidos no final (s√£o estados K).  Aqui n√≥s vamos peg√°-los.  Portanto, no arquivo drvasm.S, um trecho de c√≥digo aparece na entrada de interrup√ß√£o para foundK.  Al√©m disso, devido ao tempo para verificar o status da porta, para uma transi√ß√£o incondicional e assim por diante, chegamos √† marca n√£o no in√≠cio do bit, mas apenas no meio.  Mas n√£o faz sentido verificar a mesma parte, porque j√° sabemos o seu significado.  Portanto, esperamos 8 ciclos de rel√≥gio (at√© agora nop'ami vazio) e verificamos o pr√≥ximo bit.  Se tamb√©m for zero, encontramos o final de SYNC e podemos prosseguir para a recep√ß√£o de bits significativos. </p><br><p>  Na verdade, todo o c√≥digo adicional destina-se √† leitura de mais dois bytes com sa√≠da subsequente para o UART.  Bem, aguardando o estado de SE0 para n√£o entrar acidentalmente no pr√≥ximo pacote. </p><br><p>  Agora voc√™ pode compilar o c√≥digo resultante e ver quais bytes nosso dispositivo aceita.  Pessoalmente, tenho a seguinte sequ√™ncia: </p><br><pre> <code class="plaintext hljs">4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00 4E 55 00 00</code> </pre> <br><p>  Lembre-se de que estamos produzindo dados brutos, excluindo zeros incrementais e decodifica√ß√£o NRZI.  Vamos tentar decodificar manualmente, come√ßando com o bit baixo: </p><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  4E </td><td></td></tr><tr><td>  NRZI </td><td>  01001110 </td><td>  0 (bit anterior) </td></tr><tr><td>  byte </td><td>  00101101 </td><td></td></tr><tr><td></td><td>  2D </td><td></td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td>  55 </td><td></td></tr><tr><td>  NRZI </td><td>  01010101 </td><td>  0 (bit anterior) </td></tr><tr><td>  byte </td><td>  00000000 </td><td></td></tr><tr><td></td><td>  00 </td><td></td></tr></tbody></table></div><br><p>  N√£o faz sentido decodificar zeros, pois 16 valores id√™nticos em uma linha n√£o podem ser inclu√≠dos em um pacote. </p><br><p>  Assim, conseguimos escrever um firmware que aceita os dois primeiros bytes do pacote, embora at√© agora sem decodifica√ß√£o. </p><br><h2 id="shag-2-demo-versiya-nrzi">  Etapa 2. Vers√£o demo do NRZI </h2><br><p>  Para n√£o recodificar manualmente, voc√™ pode confiar isso no pr√≥prio controlador: a opera√ß√£o XOR faz exatamente o que voc√™ precisa, embora o resultado seja invertido; portanto, adicione outra invers√£o depois: </p><br><pre> <code class="plaintext hljs">mov temp, shift lsl shift eor temp, shift com temp rcall uart_hex</code> </pre> <br><p>  O resultado √© bastante esperado: </p><br><pre> <code class="bash hljs">2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF 2D 00 FF FF</code> </pre> <br><h2 id="shag-3-izbavlyaemsya-ot-cikla-priema-bayta">  Etapa 3. Livre-se do ciclo de recebimento de bytes </h2><br><p>  Vamos dar mais um pequeno passo e expandir o ciclo de recebimento do primeiro byte em um c√≥digo linear.  Assim, acontece muitos nops, necess√°rios apenas para aguardar o in√≠cio do pr√≥ximo bit.  Em vez de alguns deles, voc√™ pode usar o decodificador NRZI, outros ser√£o √∫teis mais tarde. </p><br><p>  O resultado da op√ß√£o anterior n√£o √© diferente. </p><br><h2 id="shag-4-chitaem-v-bufer">  Etapa 4. Leia para o buffer </h2><br><p>  √â claro que ler em registros separados √© r√°pido e bonito, mas quando h√° muitos dados, √© melhor usar uma entrada de buffer localizada em algum lugar da RAM.  Para fazer isso, declararemos uma matriz de tamanho suficiente no main e, na interrup√ß√£o, escreveremos l√°. <br>  Inser√ß√£o te√≥rica </p><br><p>  A estrutura de pacotes no USB √© padronizada e consiste nas seguintes partes: byte SYNC, byte PID + CHECK (2 campos de 4 bits cada), campo de dados (√†s vezes 11 bits, mas mais frequentemente um n√∫mero arbitr√°rio de bytes de 8 bits) e uma soma de verifica√ß√£o CRC de 5 ou 5 ( para um campo de dados de 11 bits) ou 16 (para o restante) bits.  Finalmente, o fim da indica√ß√£o de pacote (EOP) √© ‚Äã‚Äãde dois bits de pausa, mas isso n√£o √© mais dados. </p><br><p>  Antes de trabalhar com a matriz, voc√™ ainda precisa configurar os registradores e liberar nop antes que o primeiro bit n√£o seja suficiente para isso.  Portanto, voc√™ ter√° que colocar a leitura dos dois primeiros bits na se√ß√£o linear do c√≥digo, entre os comandos dos quais inseriremos o c√≥digo de inicializa√ß√£o e, em seguida, pularemos para o meio do ciclo de leitura, no r√≥tulo rxbit2.  Falando no tamanho do buffer.  De acordo com a documenta√ß√£o, em um pacote √© imposs√≠vel transferir mais de 8 bytes de dados.  Adicionamos os bytes de servi√ßo PID e CRC16, obtemos um tamanho de buffer de 11 bytes.  O byte SYNC e o estado EOP n√£o ser√£o gravados.  N√£o poderemos controlar o intervalo de solicita√ß√µes do host, mas tamb√©m n√£o queremos perd√™-las, por isso teremos uma margem dupla para leitura.  Por enquanto, n√£o usaremos o buffer inteiro, mas para n√£o retornar no futuro, √© melhor alocar imediatamente o volume necess√°rio. </p><br><h2 id="shag-5-rabotaem-s-buferom-po-chelovecheski">  Etapa 5. Trabalhando com o Buffer Humanamente </h2><br><p>  Em vez de ler diretamente os primeiros bytes da matriz, escrevemos um peda√ßo de c√≥digo que l√™ exatamente quantos bytes foram realmente gravados na matriz.  E, ao mesmo tempo, adicione um separador entre pacotes. <br>  Agora a sa√≠da fica assim: </p><br><pre> <code class="bash hljs">&gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF &gt;03 2D 00 10 &gt;01 FF</code> </pre> <br><h2 id="shag-6-dobavlyaem-dobavku-dobavochnyh-nuley">  Etapa 6. Adicionando um aditivo zero aditivo </h2><br><p>  Finalmente, √© hora de terminar de ler o fluxo de bits para o padr√£o.  O √∫ltimo item sem o qual gerenciamos com √™xito foi um zero falso, adicionado a cada seis unidades consecutivas.  Como temos a recep√ß√£o de bytes implantada no corpo linear do loop, voc√™ deve verificar ap√≥s cada bit, nos oito locais.  Considere os dois primeiros bits como um exemplo: </p><br><pre> <code class="plaintext hljs">unstuff0: ;1 (  breq) andi x3, ~(1&lt;&lt;0) ;1 [15]  0-  .     mov x1, x2 ;1 [16]      () in x2, USBIN ;1 [17] &lt;-- 1-   .     ori shift, (1&lt;&lt;0) ;1 [18]  0-   .1      rjmp didUnstuff0 ;2 [20] ;&lt;---//---&gt; rxLoop: eor shift, x3 ;1 [0] in x1, USBIN ;1 [1] st y+, shift ;2 [3] ldi x3, 0xFF ;1 [4] nop ;1 [5] eor x2, x1 ;1 [6] bst x2, USBMINUS ;1 [7]     0-   shift bld shift, 0 ;1 [8] in x2, USBIN ;1 [9] &lt;--  1- (, ) andi x2, USBMASK ;1 [10] breq se0 ;1 [11] andi shift, 0xF9 ;1 [12] didUnstuff0: breq unstuff0 ;1 [13] eor x1, x2 ;1 [14]; bst x1, USBMINUS ;1 [15]     1-   shift bld shift, 1 ;1 [16] rxbit2: in x1, USBIN ;1 [17] &lt;--  2-  (, ) andi shift, 0xF3 ;1 [18] breq unstuff1 ;1 [19] didUnstuff1:</code> </pre> <br><p>  Para facilitar a navega√ß√£o, os endere√ßos dos comandos descritos ser√£o contados pelas etiquetas √† direita.  Observe que eles foram introduzidos para contar os ciclos de clock do controlador, portanto n√£o est√£o em ordem.  O pr√≥ximo byte √© lido no r√≥tulo rxLoop, o byte anterior √© invertido e gravado no buffer [0, 3].  Em seguida, no r√≥tulo [1], o status da linha D √© lido, de acordo com XOR com o estado aceito anteriormente, decodificamos NRZI (lembro que o XOR comum adiciona sua invers√£o, para corrigir o que inserimos no registro de m√°scara x3, inicializado com as unidades 0xFF) e escrevemos para 0- com o bit do registro de deslocamento [7,8].  Ent√£o come√ßa a divers√£o - verificamos se o bit recebido foi o sexto inalterado.  O bit constante recebido com D- corresponde a escrever zero (n√£o um! Vamos mudar para um no final, XOR) no registro.  Portanto, voc√™ precisa verificar se os bits 0, 7, 6, 5, 4, 3 s√£o zeros.  Os dois bits restantes n√£o importam, eles permaneceram no byte anterior e foram verificados anteriormente.  Para se livrar deles, cortamos o registro pela m√°scara [12], onde todos os bits de interesse para n√≥s s√£o definidos como 1: 0b11111001 = 0xF9.  Se, ap√≥s aplicar a m√°scara, todos os bits forem zeros, a situa√ß√£o de adicionar um bit ser√° corrigida e haver√° uma transi√ß√£o para o r√≥tulo unstuff0.  Mais um bit [17] √© lido l√°, em vez do que foi lido anteriormente, no intervalo entre outras opera√ß√µes, de um excesso [9].  Tamb√©m trocamos os registros dos valores atuais e anteriores x1, x2.  O fato √© que, em cada bit, o valor √© lido em um registro e, em seguida, o XOR est√° com outro, ap√≥s o qual os registros s√£o trocados.  Portanto, ao ler o registro incremental, essa opera√ß√£o tamb√©m precisa ser realizada.  Mas o mais interessante √© que, no registro de dados de turno, escrevemos n√£o o zero, que recebemos honestamente, mas a unidade que o host tentou transferir [18].  Isso se deve ao fato de que, ao receber os pr√≥ximos bits, o valor de zero tamb√©m precisar√° ser levado em considera√ß√£o e, se registrarmos zero, a verifica√ß√£o da m√°scara n√£o poder√° descobrir que o bit extra j√° foi levado em considera√ß√£o.  Assim, no registro de deslocamento, todos os bits s√£o invertidos (em rela√ß√£o ao transmitido pelo host) e o zero n√£o.  Para evitar tal confus√£o no buffer, realizaremos uma invers√£o reversa de acordo com XOR, n√£o com 0xFF [0], mas com 0xFE, ou seja, um registro no qual o bit correspondente ser√° redefinido para 0 e, consequentemente, n√£o levar√° √† invers√£o.  Para fazer isso, na amostra [15] e redefina o bit zero. </p><br><p>  Uma situa√ß√£o semelhante ocorre com os bits 1 a 5.  Digamos, o 1¬∫ bit corresponde √† verifica√ß√£o 1, 0, 7, 6, 5, 4, enquanto os bits 2, 3 s√£o ignorados.  Isso corresponde √† m√°scara 0xF3. <br>  Mas o processamento de 6 e 7 bits √© diferente: </p><br><pre> <code class="plaintext hljs">didUnstuff5: andi shift, 0x3F ;1 [45]   5-0 breq unstuff5 ;1 [46] ;&lt;---//---&gt; bld shift, 6 ;1 [52] didUnstuff6: cpi shift, 0x02 ;1 [53]   6-1 brlo unstuff6 ;1 [54] ;&lt;---//---&gt; bld shift, 7 ;1 [60] didUnstuff7: cpi shift, 0x04 ;1 [61]   7-2 brsh rxLoop ;3 [63] unstuff7:</code> </pre> <br><p>  A m√°scara do sexto bit √© o n√∫mero 0b01111110 (0x7E), mas voc√™ n√£o pode sobrepor-se ao registrador de deslocamento, pois redefinir√° o 0¬∫ bit, que deve ser gravado no array.  Al√©m disso, na contagem regressiva [45], uma m√°scara j√° estava sobreposta, redefinindo 7 bits.  Portanto, √© necess√°rio processar o bit extra se os bits 1 a 6 forem iguais a zero, e o 0¬∫ n√£o importa.  Ou seja, o valor do registro deve ser 0 ou 1, o que √© perfeitamente verificado pela compara√ß√£o de "menor que 2" [53, 54]. </p><br><p>  O mesmo princ√≠pio foi usado para o 7¬∫ bit: em vez de aplicar a m√°scara 0xFC, uma verifica√ß√£o √© realizada para "menos de 4" [61, 63]. </p><br><h2 id="shag-7-sortiruem-pakety">  Etapa 7. Classifique os pacotes </h2><br><p>  Como podemos receber um pacote com o primeiro byte (PID) igual a 0x2D (SETUP), tentaremos classificar o pacote recebido.  A prop√≥sito, por que chamei o pacote 0x2D SETUP quando parece ser ACK?  O fato √© que a transmiss√£o USB do bit menos significativo para o mais significativo √© realizada em cada campo, e n√£o em byte, enquanto aceitamos byte a byte.  O primeiro campo significativo, PID, ocupa apenas 4 bits, seguidos por mais 4 bits CHECK, representando uma invers√£o bit a bit do campo PID.  Portanto, o primeiro byte recebido n√£o ser√° PID + CHECK, mas sim CHECK + PID.  No entanto, n√£o h√° muita diferen√ßa, pois todos os valores s√£o conhecidos antecipadamente e √© f√°cil reorganizar os petiscos em alguns lugares.  Imediatamente, escreveremos os principais c√≥digos que podem ser √∫teis para n√≥s no arquivo usbconfig.h. </p><br><p>  Ainda n√£o come√ßamos a adicionar o c√≥digo de processamento PID, observe que ele deve ser r√°pido (ou seja, no assembler), mas o alinhamento por rel√≥gios n√£o √© necess√°rio, porque j√° aceitamos o pacote.  Portanto, posteriormente, esta se√ß√£o ser√° transferida para o arquivo asmcommon.inc, que conter√° o c√≥digo do assembler que n√£o est√° vinculado √† frequ√™ncia.  Enquanto isso, apenas destaque o coment√°rio. <br>  Agora, vamos classificar os pacotes recebidos. </p><br><blockquote>  <strong>Inser√ß√£o te√≥rica</strong> <br>  Pacotes de dados no barramento USB s√£o combinados em transa√ß√µes.  Cada transa√ß√£o come√ßa com o envio pelo host de um pacote de marcador especial que carrega informa√ß√µes sobre o que o host deseja fazer com o dispositivo: configurar (SETUP), transmitir dados (OUT) ou receb√™-lo (IN).  Depois que o pacote do marcador √© transmitido, uma pausa de dois bits segue.  Isso √© seguido por um pacote de dados (DATA0 ou DATA1), que pode ser enviado pelo host e pelo dispositivo, dependendo do pacote do marcador.  Em seguida, outra pausa de dois bits de comprimento e a resposta √© HANDSHAKE, um pacote de confirma√ß√£o (ACK, NAK, STALL, n√≥s os consideraremos outra vez). <br><div class="scrollable-table"><table><thead><tr><th>  CONFIGURA√á√ÉO </th><th></th><th>  DATA0 </th><th></th><th>  Aperto de m√£o </th></tr></thead><tbody><tr><td>  host-&gt; dispositivo </td><td>  pausar </td><td>  host-&gt; dispositivo </td><td>  pausar </td><td>  dispositivo-&gt; host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  OUT </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Aperto de m√£o </th></tr></thead><tbody><tr><td>  host-&gt; dispositivo </td><td>  pausar </td><td>  host-&gt; dispositivo </td><td>  pausar </td><td>  dispositivo-&gt; host </td></tr></tbody></table></div><br><div class="scrollable-table"><table><thead><tr><th>  IN </th><th></th><th>  DATA0 / DATA1 </th><th></th><th>  Aperto de m√£o </th></tr></thead><tbody><tr><td>  host-&gt; dispositivo </td><td>  pausar </td><td>  dispositivo-&gt; host </td><td>  pausar </td><td>  host-&gt; dispositivo </td></tr></tbody></table></div><br><br>  Como a troca segue na mesma linha, o host e o dispositivo precisam alternar constantemente entre transmiss√£o e recep√ß√£o.  Obviamente, o atraso de dois bits √© precisamente para esse fim e √© feito para que eles n√£o comecem a tocar push-push, enquanto tentam transferir simultaneamente alguns dados para o barramento. </blockquote><p>  Portanto, conhecemos todos os tipos de pacotes necess√°rios para a troca.  Adicionamos uma verifica√ß√£o do byte PID recebido para conformidade com cada um.  No momento, o dispositivo ainda n√£o consegue gravar pacotes primitivos como ACK no barramento, o que significa que √© incapaz de dizer ao host o que √©.  Portanto, comandos como IN n√£o podem ser esperados.  Portanto, apenas verificaremos a recep√ß√£o dos comandos SETUP e OUT, para os quais indicaremos a inclus√£o dos LEDs correspondentes nos ramos correspondentes. </p><br><p>  Al√©m disso, vale a pena levar o envio de logs al√©m da interrup√ß√£o, em algum lugar principal. </p><br><p>  N√≥s atualizamos o dispositivo com o que aconteceu depois de fazer essas altera√ß√µes e observamos a seguinte sequ√™ncia de bytes recebidos: </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00 2D|80|06|00|01|00|00|40|00 C3|80|06|00|01|00|00|40|00</code> </pre> <br><p>  E al√©m disso - os dois LEDs em chamas.  Ent√£o, pegamos SETUP e OUT. </p><br><h2 id="shag-8-chitaem-adres-na-konverte">  Etapa 8. Leia o endere√ßo no envelope </h2><br><blockquote>  <strong>Inser√ß√£o te√≥rica</strong> <br>  Os pacotes de marcadores (SETUP, IN, OUT) servem n√£o apenas para mostrar ao dispositivo o que eles querem dele, mas tamb√©m para endere√ßar um dispositivo espec√≠fico no barramento e para um ponto de extremidade espec√≠fico dentro dele.  Os pontos de extremidade s√£o necess√°rios para destacar funcionalmente uma subfun√ß√£o espec√≠fica de um dispositivo.  Eles podem variar em frequ√™ncia de pesquisa, taxa de c√¢mbio e outros par√¢metros.  Digamos, se o dispositivo parece ser um adaptador USB-COM, sua principal tarefa √© receber dados do barramento e transferi-los para a porta (primeiro ponto final) e receber dados da porta e envi√°-los para o barramento (segundo).  Em termos de significado, esses pontos destinam-se a um grande fluxo de dados n√£o estruturados.  Al√©m disso, de tempos em tempos, o dispositivo deve trocar com o host o status das linhas de controle (todos os tipos de RTS, DTR, etc.) e trocar configura√ß√µes (velocidade, paridade).  E aqui, grandes quantidades de dados n√£o s√£o esperadas.  Al√©m disso, √© conveniente quando as informa√ß√µes de servi√ßo n√£o s√£o misturadas com os dados.  Portanto, √© conveniente usar pelo menos tr√™s pontos de extremidade para o adaptador USB-COM.  Na pr√°tica, √© claro, isso acontece de maneiras diferentes ... <br>  Uma pergunta igualmente interessante √© por que o dispositivo recebe seu endere√ßo, porque, al√©m disso, voc√™ ainda n√£o pode colocar nada nessa porta em particular.  Isso √© feito para simplificar o desenvolvimento de hubs USB.  Eles podem ser bastante "burros" e simplesmente transmitir sinais do host para todos os dispositivos sem se preocupar com a classifica√ß√£o.  E o pr√≥prio dispositivo descobrir√°, processar√° o pacote ou o ignorar√°. <br>  Portanto, o endere√ßo do dispositivo e o endere√ßo do terminal est√£o contidos nos pacotes de marcadores.  A estrutura desses pacotes √© apresentada abaixo: <br>  o campo <br><div class="scrollable-table"><table><thead><tr><th>  o campo </th><th>  SYNC </th><th>  addr </th><th>  ponto final </th><th>  CRC </th><th>  Eop </th></tr></thead><tbody><tr><td>  Bits USB </td><td>  0-7 </td><td>  0123456 </td><td>  0123 </td><td>  01234 </td><td>  01 </td></tr><tr><td>  bits recebidos </td><td></td><td>  0123456 </td><td>  7012 </td><td>  34567 </td><td></td></tr></tbody></table></div><br><br>      ,    -   ( -  PID = SETUP  OUT)   (IN)  ,     . </blockquote><p>     ,       (-)     (Handshake) : </p><br><ul><li>  :     ,     ,  NAK   </li><li>  -:   SETUP  OUT,  ,  IN ‚Äî ,  </li><li>   .   ,              ,        ,        </li></ul><br><p>       ¬´ ‚Äî  ¬ª    .         PID',      ,     .     ¬´PID¬ª  .       usbCurrentTok.   PID'   (DATA0, DATA1)   ,      .      ,   ?  :    ,    ( 0   usbCurrentTok     ),    ,     .       ( SE0)      ,  -  ,     D+, D- .        ,       SYNC,   . ,             ,          .    ¬´¬ª    ,        .          . </p><br><p>        ,         .       x3,          (,     ,     ,         ). </p><br><p>    ,   USB    ,      ,              .     ,  ,     ,          CRC (      ).      ,      [21].       0-    .      ,    [26]. ,        CRC,        . </p><br><h2 id="shag-9-bezotkaznyy-priem">  9.   </h2><br><p>       ,       ,    ¬´ ¬ª,   ACK.         NAK',     (    cnt ‚Äî         ).   USB     ,   ,            SYNC  PID.       Y,           cnt (         ).     ,        ‚Äî ACK.       x3      ‚Äî    1 ,           .     x3 (  r20)    20. </p><br><p>        (     SETUP,     ),   ACK'  ,    ,        ,      . ,              . </p><br><p>   ,       D+, D- (      ),    ‚Äî .      XOR  ,      , ,  ,    -  . </p><br><p>  ,     ,     ,      ,   . ,    ,        ,           .        .   vusb   :  txBitloop   2    ([00], [08]).    3 ,  6 .       ,             .      1    3    :      171.       (    171,        11 ,    ),    ‚Äî ,    .    cnt=4: </p><br><p> 4 ‚Äî 171 = -167 = (   ) 89 (+ ) <br> 89 ‚Äî 171 = -82 = (   ) 174 (+ ) <br> 174 ‚Äî 171 = 3.     ,     <br>       ,      . </p><br><p>  ,   3 ,      1.      6       ,    ,      x4.        D+, D-   ,     . . <br>          : </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00 69|00|10|00|01|00|00|40|00</code> </pre> <br><p>    C3 .  ,       ,      UART   . ,  ,       IN ,       . ,    . </p><br><h2 id="shag-10-posylaem-hosta-nak">  10.   NAK </h2><br><p>    NAK    ,       .      ,      .       ,  -       . </p><br><p>      ,      .    ,  ,   -    ,     .        usbRxBuf,    .        ,   ‚Äî  ,     USB_BUFSIZE.        usbInputBufOffset,            .        . </p><br><p>   NAK    handleData      ,        [22].            (usbRxLen),     - .       (   ‚Äî    ),       usbRxLen,  ,      ‚Äî  usbRxToken,   SETUP  OUT - .   :        ,     ,   ACK . </p><br><p>                  .   ,     ,     -    ,  -,    .         ?    ,   ,    ,   ,    -    . </p><br><p>  ,     </p><br><pre> <code class="bash hljs">2D|80|06|00|01|00|00|40|00</code> </pre> <br><p>     ,    NAK`,    ,     . </p><br><h2 id="shag-11-obrabatyvaem-zaprosy">  11.   </h2><br><p>     , ,        .       ‚Äî         .     ,      ,     , ,  ,     .            .        .         ,    USB,           usbPoll.  ‚Äî      ,     .    ‚Äî     .      SETUP ,     PID  CRC,    SETUP  5-  ,     16-.      3 ¬´¬ª . ¬´¬ª   PID      usbRxToken,  CRC   ,         ,  .        usbProcessRx,      ,       . </p><br><p>  ,   ,        ‚Äî  ,     SE0.   ,     USB      . </p><br><p>     .        SETUP,           .        .  SETUP    usbRequest_t    8 .      :  (    USB-)  ,     - .         ,     .           . <br>      , ,  ,  . </p><br><h2 id="shag-12-podrobnosti-setupa">  12.  SETUP' </h2><br><p> ,  ,      .     .     usbDriverSetup,         . ,      . ,      (    ,     ,            )   . ,           : ACK  NAK,        . </p><br><h2 id="shag-13-otpravlyaem-otvet">  13.   </h2><br><p>    ,      SETUP + DATAx,    DATAx   8 .        IN      DATAx,     .         ,     .        ,      ACK  NAK.           ,       .   ‚Äî    usbTxBuf,   ,   usbTxLen   .  low-speed USB          8  ( PID,    CRC),    usbTxLen      11.      PID,   ,      . ,     16,   , 0x0F,   .    PID      ,       .        IN,   ,       (handshake    ,    ). </p><br><p>      : <br>   SETUP + DATAx,    ACK  NAK      . , ,  usbPoll,   ,        (       PID=DATA1 (  DATA0  DATA1   ,     ,     DATA1).   CRC  .       ,    ,   -   .           ‚Äî 4 .  ,    3 ,   4.   ,   SYNC       .          ¬´   IN   NAK?¬ª     NAK.      ,     , DATA1   . </p><br><p>      ,     ‚Äî USBRQ_SET_ADDRESS (   ,    ).          .          (drvsdm.S,  make SE0).     ,              ,   ,      DATA1    ,  ,          . ,   ,           ,    ,           ,        .       ,         ,      . </p><br><h2 id="shag-14-sortiruem-standartnye-zaprosy">  14.    </h2><br><p>    ,        .   ,    USBRQ_GET_DESCRIPTOR  USBRQ_SET_ADDRESS, ,    .    usbDriverDescriptor,    .        ,   USBRQ_GET_DESCRIPTOR.  ,    , : </p><br><p> USBDESCR_DEVICE ‚Äî   :   USB (1.1   ),  , ,    . . <br> USBDESCR_CONFIG ‚Äî ,     ,    . . <br> USBDESCR_STRING ‚Äî   ,   . <br> ,   ,       USBDESCR_DEVICE,  ,        . </p><br><h2 id="shag-15-zapolnyaem-anketnye-dannye">  15.    </h2><br><p>       . -,     .      ,   - - , , HID,      ,        .     Vendor ID  Product ID,      USB,     .  ,  vusb            . </p><br><p>     , , - .    ,       ,    ,        (, )      usbMsgPtr,   ‚Äî   len,     usbMsgLen.      (     )  18 ,       8. ,    ,  3 .       - ,  STALL. </p><br><p>           usbDeviceRead.   ,       memcpy_P,             ,  , . </p><br><p>   ,      ,  ,      .    ,      ,        . </p><br><p>       ,     ,  . </p><br><blockquote> <strong> </strong> <br>  PID'  DATA0  DATA1       .  PID'     ,          ,  -       . </blockquote><p>       ,  DATA0 / DATA1    (        ),     , ,   3 ,    .     XOR    PID',   .      ,        ,   XOR'    .     PID  DATA1,   XOR    PID   ,   XOR  DATA0    . </p><br><p>      ,    ,     USBDESCR_CONFIG. </p><br><h2 id="shag-16-nakonec-to-ustroystvo">  16. - ! </h2><br><p>   USBDESCR_CONFIG      USBDESCR_DEVICE.     (   ,        )  .   , -     USB-,     ,   D+, D-. </p><br><p>        ,      : , ,   .    ,        (    ,    ).  ,      UTF-16,       .     USB     UTF-8  . </p><br><p>   vusb       ,     lsusb    .    VID, PID      ,        .         ,        VID, PID,     ‚Äî      . </p><br><p> ,         ,      (    ).       SETUP:   ,        ,     .   0,       ,    ‚Äî      . ,     ,       ,  . <br>        . </p><br><h2 id="shag-17-ustroystvo-stanovitsya-chelovechnee-hid">  17.    (HID) </h2><br><blockquote> <strong> </strong> <br> HID ‚Äî human interface device,   ,       ,     .    HID   ,       .  ,      ,   , , ,       .    ¬´¬ª     .      HID     ( low-speed      800   ),        . </blockquote><p>     HID     ,     USBDESCR_HID_REPORT.          vusb,      . ,   usbDriverSetup ( )   usbFunctionSetup ( ).  ,      SETUP,         OUT.      ,         , ,   usbFunctionWrite. </p><br><p>     ,  usbDeviceRead  usbFunctionRead,           .   ,    ,   usbFunctionSetup  (  ,   )   USB_FLG_USE_USER_RW,   usbDriverSetup   . </p><br><p>    ‚Äî      ‚Äî    usbFunctionWrite  usbFunctionRead.          .   ‚Äî      ,       . </p><br><p>       usbDriverSetup. </p><br><h2 id="shag-18-obschaemsya-s-zhelezkoy">  18.    </h2><br><p>  ,      ,        .     HID,    ,   ,      (        udev  - ).  ,        ,   .        ,   ,   ,     . <br> UPD:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">ramzes2</a> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HIDAPI</a> </p><br><p>           . </p><br><h2 id="shag-19-sravnivaem-s-vusb">  19.   vusb </h2><br><p>     vusb              ,   . </p><br><p> drvasm.S   - usbdrvasm.S  asmcommon.inc,   -,   , usbdrvasm12.inc ‚Äî usbdrvasm20.inc. </p><br><p> main.c    main.c ( )  usbdrv.c (  vusb) <br> usbconfig.h      (     ),   ,  ,   usbconfig.h. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>      vusb,            ,   ,    .  ,    ,      . . ,     ,     ,    USB-HID.   ,   ,  ,            vusb,     ,  , ,      . </p><br><h2 id="ispolzovannaya-literatura-i-poleznye-ssylki">      </h2><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://www.obdev.at/products/vusb/index.html</a> (  vusb) <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://microsin.net/programming/arm-working-with-usb/usb-in-a-nutshell-part1.html</a> <br>  ..  USB:     <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://radiohlam.ru/tag/usb/</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://we.easyelectronics.ru/electro-and-pc/usb-dlya-avr-chast-1-vvodnaya.html</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://usb.fober.net/cat/teoriya/</a> </p><br><p> PS -     (,      )     ,   </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460815/">https://habr.com/ru/post/pt460815/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460803/index.html">Leitura para o ver√£o: livros para t√©cnicos</a></li>
<li><a href="../pt460805/index.html">Como transferir dados entre microcontroladores a 100 Mbps</a></li>
<li><a href="../pt460807/index.html">Me√ßa sete vezes, uma vez que implemente a ferramenta de BI</a></li>
<li><a href="../pt460811/index.html">Componentes comuns por diferentes equipes. Relat√≥rio Yandex</a></li>
<li><a href="../pt460813/index.html">Como usar os diagramas de Voronoi para controlar a IA</a></li>
<li><a href="../pt460819/index.html">WorldSkills: Revis√£o do participante da Olimp√≠ada</a></li>
<li><a href="../pt460821/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel # 307 (15 a 21 de julho)</a></li>
<li><a href="../pt460823/index.html">Eventos digitais em Moscou, de 22 a 28 de julho</a></li>
<li><a href="../pt460825/index.html">Introdu√ß√£o √† API do Screen Capture - Digitalize c√≥digos QR em um navegador</a></li>
<li><a href="../pt460827/index.html">Problema PGP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>