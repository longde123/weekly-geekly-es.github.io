<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏻 📩 🤰🏽 简单三元系统的实现 🔜 🧘🏾 🔮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="三值逻辑 


 成就清单 


- 基本三元逻辑门：T_NOT，T_OR，T_AND，T_NAND，T_NOR，T_XOR等 
- 三元函数的合成，最小化和实现 
- 三元半加法器，三元全加法器，三元波纹进位加法器 
- 三进制全减法器，比较器，乘法器，复用器/解复用器 
- 三元人字拖和闩锁 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>简单三元系统的实现</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431726/"><h1 id="three-valued-logic"> 三值逻辑 </h1><br><p>  <strong>成就清单</strong> </p><br><ul><li> 基本三元逻辑门：T_NOT，T_OR，T_AND，T_NAND，T_NOR，T_XOR等 </li><li> 三元函数的合成，最小化和实现 </li><li> 三元半加法器，三元全加法器，三元波纹进位加法器 </li><li> 三进制全减法器，比较器，乘法器，复用器/解复用器 </li><li> 三元人字拖和闩锁 </li><li> 原始三元算术和逻辑单元（ALU） </li></ul><br><p>  <strong>约定和使用的技术</strong> </p><br><ul><li> 在实施中使用了不平衡的三元（0，1，2） </li><li>  1 Trit由2位表示：0〜00、1〜01、2〜10（11未定义） </li><li>  ModelSim，Quartus prime，Logisim </li></ul><br><h2 id="introduction"> 引言 </h2><br><p> 作为Innopolis大学的一年级学生，我们有机会在整个计算机体系结构课程中实现项目。 我们的团队对三元系统及其功能特别感兴趣，因此我们决定实现一个具有基本组件（门）的简单三元系统。 </p><br><p> 在逻辑中， <em>三值</em>逻辑（也是三元逻辑，三价逻辑，三元逻辑）是几种多值逻辑系统之一，在该系统中，三个真值表示true，false和一些不确定的第三值。 </p><br><p> 三元逻辑符合<strong>MVL</strong> （多值逻辑）。 但是，仅使用三个逻辑状态，即“ <strong>0</strong> ”，“ <strong>1</strong> ”和“ <strong>2</strong> ”。 发现小数的最佳基数（ <strong><em>r</em></strong> ）是自然对数（ <strong><em>e</em></strong> ）。 与使用<em>r = 2的</em>二进制逻辑相比，三元逻辑使用<em>r = 3的</em>数字表示，因此最接近自然对数<em>e</em>的最经济的整数基数是3。这种3的特殊性质启发了早期的计算机设计人员建造三元计算机。 </p><a name="habracut"></a><br><p>  1958年，第一台可运行的三元计算机在俄罗斯莫斯科国立大学制造。该计算机由Nikolay Brusentsov及其同事设计。 他们将其命名为<em>Setun</em> ，就像在大学校园附近流淌的河流一样。 </p><br><h1 id="ternary-logic"> 三元逻辑 </h1><br><p> 三元逻辑函数是映射<em>F：{0,1,2} <sup>n-</sup> &gt; {0,1,2}</em> 。 我们将讨论三元逻辑相对于二进制逻辑的优缺点。 </p><br><p> 在布尔逻辑具有2 <sup>2</sup> = 4个一元运算符的情况下，在三元逻辑中添加第三个值会导致单个输入值上总共有3 <sup>3</sup> = 27个不同的运算符。 类似地，布尔逻辑具有2 <sup>2 <sup>2</sup></sup> = 16个不同的二进制运算符（具有2个输入的运算符），三元逻辑具有3 <sup>3 <sup>2</sup></sup> = 19,683个此类运算符。 在我们可以轻松命名大部分布尔运算符（非，和，或，非，或，异或，等价，隐含）的地方，尝试命名除很小一部分可能的三元运算符之外的其他做法都是不合理的。 </p><br><p>  <strong>三元逻辑的优势</strong> </p><br><p> 与等效的二进制逻辑表示相比，三进制逻辑表示可实现更紧凑和有效的信息编码。 陈述的论据如下：如果我们假设一个数字电路有N个可能的输入组合，那么一个二进制电路需要对数<sub>2</sub> N条输入线，而三进制电路需要对数<sub>3</sub> N条输入线。 </p><br><p><img src="https://habrastorage.org/webt/an/ez/gi/anezgi7mjoqvtub8ut_cknthlm0.png" width="350"><img src="https://habrastorage.org/webt/bm/pf/jo/bmpfjooawomcvxcdibsho4y88hu.png" width="68"><img src="https://habrastorage.org/webt/oj/cy/i2/ojcyi2sbamb19kvqe3byu7emwgm.png" width="68"><img src="https://habrastorage.org/webt/cr/jq/gw/crjqgwm9uc3l_2ka2ysgolq2_am.png" width="80"></p><br><p> 因此，给定二进制逻辑功能的三进制编码实现应比对应的二进制实现需要0.63倍的输入线。 </p><br><p>  <strong>三元逻辑的缺点</strong> </p><br><p> 尽管三元逻辑电路比等效的二元逻辑电路需要更少的输入线，但是三元逻辑电路目前不是实际的选择。 原因是 </p><br><ol><li> 三元硬件实现技术仍处于理论，仿真和实验室测试水平 </li><li> 尚未有效定义使用现有技术的电压电平表示三个三元逻辑电平（0、1和2） </li><li> 没有开发计算模型和编程语言。 但是，使用互补金属氧化物半导体（CMOS），谐振隧道二极管（RTD）和碳纳米管技术模拟三元电路实现的结果，表明三元逻辑可能是未来计算的选择。 </li></ol><br><h3 id="various-possible-representations-for-the-ternary-system"> 三元系统的各种可能表示 </h3><br><ul><li>  <em>三进制数字系统（不平衡三进制）</em> ，每个数字是一个三进制（三进制数字），其值是：0、1或2 </li><li>  <em>平衡三进制</em> ，每个数字具有3个值之一：−1、0或+1； 这些值也可以分别简化为-，0，+（最常用） </li><li>  <em>冗余二进制表示形式</em> ，每个数字可以具有值-1、0、0 / 1（值0/1具有两种不同的表示形式） </li><li>  <em>斜二进制数系统</em> ，只有最高有效的非零数字的值为2，其余数字的值为0或1 </li></ul><br><p>  <strong>有关平衡三进制编号系统的更多信息</strong> </p><br><p> 如今，几乎所有硬件都为二进制计算而设计。 如果我们有一个具有三个稳定状态的稳定电子组件，那么世界可能会转向三元计算。 但是，今天这不是事实。 平衡的三进制基数符号具有一些有益的特性： </p><br><ol><li> 三元反转很容易，只需将-1与1交换，反之亦然。 如果我们使用一个示例，则在平衡三进制表示法中，24表示为1T0，-24表示为T10（T只是-1的表示法）。 这比二进制逻辑中二进制补码的规则更简单。 </li><li> 数字的符号由其最重要的非零“ trit”给出 </li><li> 四舍五入到最接近的整数的操作与截断相同。 </li><li> 加法和减法本质上是相同的操作（即，您仅使用数字加法规则来添加数字） </li></ol><br><p> 范例： <br>  21 <sub>10</sub> = 1T10 <sub>3</sub> ;  296 <sub>10</sub> = 11T00T <sub>3</sub> ; <br>  -24 <sub>10</sub> = T10 <sub>3</sub> ;  -137 <sub>10</sub> = T110T1 <sub>3</sub> </p><br><h1 id="ternary-arithmetics"> 三元算术 </h1><br><p> 三元算术可以提供比二元算术更紧凑的表示法，如果硬件制造商可以找到三元开关，那么三元算术将是一个显而易见的选择。 </p><br><h2 id="balanced-ternary-addition-and-multiplication"> 平衡三元加法和乘法 </h2><br><p><img src="https://habrastorage.org/webt/-h/pd/sv/-hpdsvbvtkll5wyqdncputn77d8.jpeg" width="240"><img src="https://habrastorage.org/webt/je/hw/6h/jehw6hq7g7mvdquoiknjhk1ouqa.jpeg" width="250"></p><br><p> 范例： <br><img src="https://habrastorage.org/webt/km/yf/6i/kmyf6iaam07brnlj5tbudbzdero.jpeg" width="230"><img src="https://habrastorage.org/webt/5b/fp/30/5bfp30zoys2d46y_nutw2sznynk.jpeg" width="210"></p><br><h1 id="ternary-combinational-circuits-ternary-gates"> 三元组合电路（三元门） </h1><br><p> 组合电路由输入变量，三元逻辑门和输出变量组成。 电路的输出仅取决于当前输入。 逻辑门接收来自输入变量的信号并生成输出信号。 此过程将从 <br> 给定的输入数据到所需的三进制输出数据。 </p><br><p> 如上所述，我们可以轻松地命名布尔运算符的很大一部分（不是，和，或，非，或，异或，等价，隐含），但是，尝试命名所有可能的布尔值（除了很小一部分）都是不合理的三元运算符。 我们将考虑以下三元电路： </p><br><p>  <em>And（Min）</em> ：很自然地，通过声明两个输入均为true时结果为true，如果两个输入均为false则为false，否则为unknown，从而将Boolean和function扩展为三元函数。 </p><br><div class="spoiler">  <b class="spoiler_title">和电路/真值表</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/k6/kl/n_/k6kln_sefeoshlbmsizcbrfwu4u.jpeg" width="400"><img src="https://habrastorage.org/webt/n9/cs/ts/n9cstsdmrwqf73lpgxf5b16govc.png" width="200"></p></div></div><br><p>  <em>或（Max）</em> ：通过将布尔值或函数扩展为三进制也很自然，方法是声明任何输入为true时结果为true，仅当两个输入均为false时结果为false，否则为unknown。 </p><br><div class="spoiler">  <b class="spoiler_title">或电路/真值表</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sj/yq/pr/sjyqprtdxabqzygeggarwuo4zay.jpeg" width="400"><img src="https://habrastorage.org/webt/6_/tm/qt/6_tmqt1pqnrcv5frgi2igulrlkm.png" width="200"></p></div></div><br><p>  <em>共识</em> ：在布尔逻辑中，两个输入相同时，exclusive或相反，为true；当两个输入不同时，则为false。 这种想法对三元逻辑有几种自然的延伸。 其中之一是一组变量的逻辑共识，如果全部为真，则为true；如果全部为false，则为false；否则为未知 </p><br><div class="spoiler">  <b class="spoiler_title">共识电路/真相表</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ab/sa/kg/absakgzsohkirdhmslwdvqij08o.jpeg" width="400"><img src="https://habrastorage.org/webt/y_/nj/ig/y_njigvrvorsuiivknbgho_vh0o.png" width="200"></p></div></div><br><p>  <em>任意</em> ：如果共识要求两个输入在断言除未知之前先达成共识，则“接受任何”运算符仅在两个输入均未知或积极不同意时才声明未知结论。 否则，它会从可用的任何未知输入中跳到结论。 </p><br><div class="spoiler">  <b class="spoiler_title">任何电路/真值表</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ls/v6/7f/lsv67fd3h8jdn80esxj7qg7lwhm.jpeg" width="400"><img src="https://habrastorage.org/webt/82/kc/ss/82kcssyfihrdkay-eiwf5bqtpdk.png" width="200"></p></div></div><br><p>  <em>递增和递减</em> ：在布尔逻辑中，可以将逆变器视为将其自变量模2递增或递减。内部逻辑中，模3递增和递减函数与求反完全不同。 </p><br><div class="spoiler">  <b class="spoiler_title">增减电路</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/za/h2/an/zah2an0rcm7e-kbxdtpyhfwtnls.jpeg" width="300"><img src="https://habrastorage.org/webt/xa/la/99/xala99-ou8gwzaentnen23ktsag.jpeg" width="300"></p></div></div><br><h2 id="synthesis-minimization-and-realization-for-ternary-functions"> 三元函数的合成，最小化和实现 </h2><br><p> 三元逻辑系统中相互关联的关系 </p><br><p><img src="https://habrastorage.org/webt/bi/ps/hv/bipshv8jztb6v7s-enuhbt2thhe.png" width="200"><img src="https://habrastorage.org/webt/qz/eh/1p/qzeh1puaizftiy7izk049diii58.png" width="270"><img src="https://habrastorage.org/webt/ba/-z/nd/ba-znddyvfjkbrg2ai_62qosmz4.png" width="300"><img src="https://habrastorage.org/webt/nc/_y/wc/nc_ywcalio72izsdrk1bdqwq8fq.png" width="200"><img src="https://habrastorage.org/webt/gz/ne/i3/gznei3-ti5lvckg3pepv3aaklo0.png" width="160"></p><br><p> 三元逻辑函数可以表示为最大-最小表达式。 三元最大-最小表达式定义如下： <br>  <em>变量</em> ：从集合T∈{0,1,2}中取值的任何符号都是三元变量。 <br>  <em>文字</em> ：文字是变量的转换形式。 它们用于形成最大-最小表达式。 </p><br><p> 在文献中，通常使用两种类型的文字：1-精简后的文字和2-精简后的文字。 变量x的1-归约后Post文字表示为x <sub>i</sub> ，其中i∈{0,1,2}。 当x = i时，则x <sub>i</sub> = 1，否则x <sub>i</sub> =0。变量的1减数Post常量如下所示。 </p><br><p> 变量x的2约简的Post文字表示为x <sub>i</sub> ，其中i∈{0,1,2}。 当x = i时，则x <sub>i</sub> = 2，否则x <sub>i</sub> =0。变量的2化简Post文字如下所示。 如前所述，该示例利用不同的文字集来形成Max-Min表达式。 </p><br><p><img src="https://habrastorage.org/webt/g-/el/8h/g-el8hdxodjaxlkpi2epjh2phqs.png" width="250"><img src="https://habrastorage.org/webt/aw/pb/nx/awpbnxod11cict52_8xtkrwjs8m.png" width="240"><img src="https://habrastorage.org/webt/zc/uy/gt/zcuygt1t0x_6b0gkrkr0qmzui60.png" width="130"></p><br><p>  <strong>Minterm</strong> ：当使用Min运算将函数变量的字面量组合在一起时，该术语称为minterm。 例如，对于三变量三元逻辑函数F（x，y，z），xyz和xz是最小项的两个示例。 </p><br><p>  <strong>Max-Min表达式</strong> ：使用Max运算将两个或多个minterm组合在一起时，该表达式称为max of minterms（Max-Min）表达式。 例如，对于三变量三元逻辑函数F（x，y，z）= xy + yz + xyz是Max-Min表达式的示例。 </p><br><p> 任何函数F（x，y，z）始终可以表示为 </p><br><img src="https://habrastorage.org/webt/k6/ym/oe/k6ymoexzhobo2u2jka3wsvzfcse.png" width="230"><br><p><br> 最小化三元函数的三种基本方法是： </p><br><ol><li> 像布尔代数一样处理代数表达式。 </li><li> 表格方法。 </li><li> 三元K.图法。 <br> 为了实现三元电路，有必要将三元变量转换为一元变量（使用2-Reduced Post Literals表）。 </li></ol><br><h1 id="ternary-half-adder"> 三元半加法器 </h1><br><p> 将两个1 Trit号相加的电路称为半加法器。 该电路不考虑先前加法中产生的进位。 三元逻辑系统中的加法过程如下所示。 这里A和B是两个输入，总和（S）和进位（CARRY） <br> 是两个输出。 </p><br><img src="https://habrastorage.org/webt/1r/0i/9h/1r0i9hfkpbig_jstbggckqg3opg.png" width="400"><br><p><br>  <strong>分析方法</strong> </p><br><p> 卡诺图（K-map）用于表示总和并带有输出。  K映射对于最小化和优化逻辑电路很有用。 这里使用了2个输入的K-map。 由于不可能将2和1'分组，因此输出方程式如下。 </p><br><p><img src="https://habrastorage.org/webt/x9/yn/7s/x9yn7szwuqyscpokre3_s1lmxyo.png" width="300"><img src="https://habrastorage.org/webt/cv/yu/74/cvyu74b0_9pmwtv3zuwk-pnr1fq.png" width="300"></p><br><p>  <strong>实作</strong> </p><br><div class="spoiler">  <b class="spoiler_title">三元半加法器电路/ Verilog</b> <div class="spoiler_text"><pre><code class="plaintext hljs">module half_adder ( input [1:0] A, [1:0] B, output [1:0] sum, [1:0] carry ); wire [1:0] temp = 2'b01; wire [1:0] a0, a1, a2, b0, b1, b2; wire [1:0] i0, i1, i2, i3, i4, i5; wire [1:0] o0, o1, o2, o3, o4; wire [1:0] c0, c1, c2, c3; mask msk_1(A, a0, a1, a2); mask msk_2(B, b0, b1, b2); andgate and_1(a2,b0,i0); andgate and_2(a1,b1,i1); andgate and_3(a0,b2,i2); // partial products orgate or_1(i0, i1, o0); orgate or_2(o0, i2, o1); // f1 andgate and_4(a1,b0,i3); andgate and_5(a0,b1,i4); andgate and_6(a2,b2,i5); // partial products orgate or_3(i3, i4, o2); orgate or_4(o2, i5, o3); // f2 andgate and_7(o3,temp,o4); // 1.f2 andgate andc_0(a2,b1,c0); andgate andc_1(a1,b2,c1); orgate orc_0(c0,c1,c2); orgate orc_1(c2,i5,c3); andgate andc_2(c3,temp,carry); // carry orgate or_5(o1, o4, sum); // sum endmodule</code> </pre> </div></div><br><h1 id="ternary-full-adder"> 三元全加法器 </h1><br><p> 与半加法器一样，三进制全加法器的一级可以通过给出总和<em>SUM</em>的数值表来描述，并根据三个输入<em>A，B</em>以及进位<em>C来</em>执行<em>CARRY</em> ： </p><br><img src="https://habrastorage.org/webt/tb/re/7u/tbre7ug6vxqbc6jkd0syxh1izog.png" width="400"><br><p><br></p><br><p>  <strong>分析方法</strong> </p><br><p> 卡诺图（K-map）用于表示总和并带有输出。  K映射对于最小化和优化逻辑电路很有用。 这里使用了3个输入的K-map。 </p><br><p><img src="https://habrastorage.org/webt/vg/ix/sz/vgixszs7s3zmvtwvqqxm0zstc8y.png" width="350"><img src="https://habrastorage.org/webt/tz/cc/xo/tzccxoy0vcguqtpvtqih9v9r6ie.png" width="300"></p><br><p><img src="https://habrastorage.org/webt/gy/rw/qh/gyrwqhm-qvv8iuscx8mlndyw1qc.png" width="350"><img src="https://habrastorage.org/webt/7d/fk/rf/7dfkrfolvkwzigvgxglbc2t2vty.png" width="300"></p><br><p>  <strong>实作</strong> </p><br><div class="spoiler">  <b class="spoiler_title">三元全加法器电路/ Verilog</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module ternary_full_adder ( input [1:0] A, [1:0] B, [1:0] c_in, output [1:0] sum, [1:0] c_out ); wire [1:0] temp1 = 2'b01; wire [1:0] temp2 = 2'b00; wire [1:0] a0, a1, a2, b0, b1, b2, a20; wire [1:0] i0, i1, i2, i3, i4; wire [1:0] i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17; wire [1:0] o0, o1, o2, o3, o4, o5, o6, o7, o8, o9; wire [1:0] c0, c1, c2; wire [1:0] h0, h1, h2, h3, h4, h5, h6, h7; wire [1:0] t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16; wire [1:0] g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15; mask mk_1(A, a0, a1, a2); mask mk_2(B, b0, b1, b2); mask mk_3(c_in, c0, c1, c2); andgate3 and3_1(a2,b0,c0, i0); andgate3 and3_2(a1,b0,c1, i1); andgate3 and3_3(a0,b0,c2, i2); andgate3 and3_4(a1,b1,c0, i3); andgate3 and3_5(a0,b1,c1, i4); andgate3 and3_6(a2,b1,c2, i5); andgate3 and3_7(a0,b2,c0, i6); andgate3 and3_8(a2,b2,c1, i7); andgate3 and3_9(a1,b2,c2, i8); andgate3 and3_10(a1,b0,c0, i9); andgate3 and3_11(a0,b0,c1, i10); orgate or__(a2, a0, a20); andgate3 and3_12(a20,b0,c2, i11); // note a20 andgate3 and3_13(a0,b1,c0, i12); andgate3 and3_14(a2,b1,c1, i13); andgate3 and3_15(a1,B,c2, i14); andgate3 and3_16(a2,b2,c0, i15); andgate3 and3_17(a1,b2,c1, i16); andgate3 and3_18(temp2,b2,c2, i17); orgate or_1(i9, i10, o0); orgate or_2(o0, i11, o1); orgate or_3(o1, i12, o2); orgate or_4(o2, i13, o3); orgate or_5(o3, i14, o4); orgate or_6(o4, i15, o5); orgate or_7(o5, i16, o6); orgate or_8(o6, i17, o7); andgate and_1(o7, temp1, o8); // 1.f2 orgate or_9(i0, i1, h0); orgate or_10(h0, i2, h1); orgate or_11(h1, i3, h2); orgate or_12(h2, i4, h3); orgate or_13(h3, i5, h4); orgate or_14(h4, i6, h5); orgate or_15(h5, i7, h6); orgate or_16(h6, i8, h7); orgate or_17_(h7, o8, sum); // sum // carry andgate3 and3_19(a2,b2,c2, t0); // f1 andgate3 and3_20(a0,b1,c2, t1); andgate3 and3_21(a0,b2,c2, t2); andgate3 and3_22(a0,b2,c1, t3); andgate3 and3_23(a1,b2,c0, t4); andgate3 and3_24(a2,b2,c0, t5); andgate3 and3_25(a1,b1,c1, t6); andgate3 and3_26(a1,b2,c1, t7); andgate3 and3_27(a1,b0,c2, t8); andgate3 and3_28(a1,b1,c2, t9); andgate3 and3_29(a1,b2,c2, t10); andgate3 and3_25_(a2,b0,c2, t11); andgate3 and3_26_(a2,b1,c2, t12); andgate3 and3_27_(a2,b0,c1, t13); andgate3 and3_28_(a2,b1,c1, t14); andgate3 and3_29_(a2,b2,c1, t15); andgate3 and3_9_(a2,b1,c0, t16); orgate or_17(t1, t2, g0); orgate or_18(g0, t3, g1); orgate or_19(g1, t4, g2); orgate or_20(g2, t5, g3); orgate or_21(g3, t6, g4); orgate or_22(g4, t7, g5); orgate or_23(g5, t8, g6); orgate or_24(g6, t9, g7); orgate or_25(g7, t10, g8); orgate or_21_(g8, t11, g9); orgate or_22_(g9, t12, g10); orgate or_23_(g10, t13, g11); orgate or_24_(g11, t14, g12); orgate or_25_(g12, t15, g13); orgate or_5_(g13, t16, g14); //f2 andgate and_2(g14, temp1, g15); // 1.f2 orgate or_26(g15, t0, c_out); // carry endmodule</code> </pre> </div></div><br><h1 id="ternary-full-subtractor"> 三元全减法器 </h1><br><p> 三元全减法器是一个将两个输入和先前借位相减的电路。 减法器的真值表如下所示 </p><br><img src="https://habrastorage.org/webt/rs/em/yj/rsemyjk_c08-9regakdq8zfl8ve.png" width="350"><br><div class="spoiler">  <b class="spoiler_title">三元全减法器的分析与实现</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/q6/ft/a4/q6fta4jdumlp-a1rkn8ztcd-nok.png" width="300"><img src="https://habrastorage.org/webt/lx/dc/p4/lxdcp4h6fwhybpjqh-piev_szl4.png" width="300"></p><br><img src="https://habrastorage.org/webt/fn/-e/uq/fn-euquomq2xo5p48w9rdckyoxm.png" width="500"><br><img src="https://habrastorage.org/webt/nu/53/te/nu53tesyiintihz2pr3l1cioeng.png" width="500"><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module full_subtractor( input [1:0] P, Q, b_in, output [1:0] diff, b_out ); wire [1:0] temp1 = 2'b01; wire [1:0] temp2 = 2'b10; wire [1:0] a0, a1, a2, b0, b1, b2; wire [1:0] i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i16, i17; wire [1:0] c0, c1, c2, c3; wire [1:0] h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10, h11; wire [1:0] t0, t1, t2, t3, t4, t5, t6, t7, t8, t9; wire [1:0] p0, p1, p2; wire [1:0] q0, q1, q2; mask mk_1(P, p0, p1, p2); mask mk_2(Q, q0, q1, q2); mask mk_3(b_in, b0, b1, b2); andgate and_0(p0, q1, i0); andgate3 and3_0(p2, p1, q2, i1); orgate or_0(i0, i1, i2); andgate and_1(b0, i2, i3); // first expression andgate and_2(p0, q0, i4); andgate and_3(p1, q1, i5); andgate and_4(p2, q2, i6); orgate or_1(i4, i5, i7); orgate or_2(i7, i6, i8); andgate and_5(i8, b1, i9); // second expression andgate and_6(p1, q0, i10); andgate and_7(p0, q2, i11); andgate and_8(p2, q1, i12); orgate or_3(i10, i11, i13); orgate or_4(i13, i12, i14); andgate and_9(i14, b2, i15); // third expression orgate or_5(i3, i9, i16); orgate or_6(i16, i15, c0); //f1 orgate or_7(i10, i12, t0); orgate or_8(t0, i11, t1); andgate and_10(t1, b0, t2); // 1 expression andgate and_11(p1, q2, i17); orgate or_9(i4, i17, t3); andgate and_12(t3, b1, t4); // 1- expression orgate or_10(i4, i5, t5); orgate or_11(t5, i6, t6); andgate and_12_(t6, b2, t7); // 1-- expression orgate or_12(t2, t4, t8); orgate or_13(t8, t7, t9); andgate and_13(t9, temp1, c1); orgate or_14(c0, c1, diff); // difference orgate or_15(q1, q2, h0); andgate and_14(h0, temp2, h1); andgate and_15(h1, b2, h3); // 1 b orgate or_16(i0, i11, h4); andgate and_16(h4, temp2, h5); // 1- b andgate and_17(i17, temp2, h6); // 1-- b andgate3 and3_1(p2, q2, b1, h7); // 1--- b andgate3 and3_2(p1, q0, b2, h8); // 1---- b orgate or_17(h3, h5, h9); orgate or_18(h9, h6, h10); orgate or_19(h10, h7, h11); orgate or_20(h11, h8, b_out); // borrow endmodule</code> </pre> </div></div></div></div><br><h1 id="ternary-ripple-carry-adder"> 三元波纹进位加法器 </h1><br><p> 纹波加法器（RCA）是一种众所周知的电路，用于通过级联三进制全加器来执行两个数字的加法运算。 三元RCA与二元RCA非常相似。 三元半加法器用于添加最低有效的三进制数字。 其余部分由三元完全加法器汇总。 如前所述，三元全加器将三个三元输入变量相加。 </p><br><img src="https://habrastorage.org/webt/ek/na/sr/eknasrimeeonnceutvyzjzfml5w.png"><br><p>  <strong>实作</strong> </p><br><div class="spoiler">  <b class="spoiler_title">verilog代码：三元波纹进位加法器</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module ternary_ripple_adder ( input [15:0] input1 , input [15:0] input2 , output [15:0] out , output [1:0] overflow_trit ); wire [15:0] carry ; reg tem; assign carry[0] = tem; assign carry[1] = tem; always @(input1, input2) begin tem &lt;= 1'b0; end generate genvar i; for (i = 0; i &lt;= 12; i=i+2) begin full_add af({input1[i+1],input1[i]}, {input2[i+1],input2[i]}, {carry[i+1],carry[i]}, {out[i+1], out[i]}, {carry[i+3],carry[i+2]}); end full_add af({input1[15],input1[14]}, {input2[15],input2[14]}, {carry[15],carry[14]}, {out[15], out[14]}, overflow_trit); endgenerate endmodule</code> </pre> </div></div><br><h1 id="ternary-comparators"> 三元比较器 </h1><br><p> 三元比较器电路预占两个输入X <sub>1</sub> ，X <sub>2，</sub>并相应地生成输出X <sub>1</sub> = X <sub>2</sub> ，X <sub>1</sub> &gt; X <sub>2</sub> ，X <sub>1</sub> &lt;X <sub>2</sub> 。 三元比较器的真值表如下所示 </p><br><img src="https://habrastorage.org/webt/lh/0_/r_/lh0_r_dre7sfrm-_-fazrp4jgfq.png" width="300"><br><p><br></p><br><div class="spoiler">  <b class="spoiler_title">分析与实施</b> <div class="spoiler_text"><p>  X <sub>1</sub> = X <sub>2</sub> ，X <sub>1</sub> &gt; X <sub>2</sub> ，X <sub>1</sub> &lt;X <sub>2的</sub>输出方程为： <br><br></p><br><img src="https://habrastorage.org/webt/kr/1b/xl/kr1bxlm7k1uly92ng6vtukbeecc.png" width="250"><br><p><br> 相应的k图如下所示 <br><br><img src="https://habrastorage.org/webt/fw/6g/5f/fw6g5ffpx7svuikxzwnw4pc_xx0.png" width="200"><img src="https://habrastorage.org/webt/lz/bm/dc/lzbmdczv675meisdmlxhd1iteb8.png" width="200"><img src="https://habrastorage.org/webt/1z/lk/zb/1zlkzbrmvhkzms2fjryckhzgrou.png" width="200"></p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module ternary_comparators ( input [1:0] x1, x2, output [1:0] f1, f2, f3 ); wire [1:0] t0, t1, t2, t3, t4, t5, t6, t7; wire [1:0] h0, h1, h2, h3, h4, h5; wire [1:0] x10, x11, x12; wire [1:0] x20, x21, x22; mask mk_1(x1, x10, x11, x12); mask mk_2(x2, x20, x21, x22); andgate and_0(x10, x20, t0); andgate and_1(x22, x22, t1); orgate or_0(t0, t1, h0); orgate or_1(h0, x11, h1); orgate or_2(h1, x21, f1); // x1 == x2 andgate and_2(x11, x20, t2); andgate and_3(x12, x20, t3); andgate and_4(x12, x21, t4); orgate or_3(t2, t3, h3); orgate or_4(h3, t4, f2); // x1&gt;x2 andgate and_5(x10, x21, t5); andgate and_6(x10, x22, t6); andgate and_7(x11, x22, t7); orgate or_5(t5, t6, h4); orgate or_6(h4, t7, f3); // x1&lt;X2 endmodule</code> </pre> </div></div></div></div><br><h1 id="ternary-multiplier"> 三元乘数 </h1><br><p> 三进制乘法器是将两个输入数字相乘并生成相应乘积的电路。 该电路的真值表如下所示： </p><br><img src="https://habrastorage.org/webt/fd/uu/v1/fduuv1gzss5fvup5bmm9tklkrsa.png" width="250"><br><p><br></p><br><div class="spoiler">  <b class="spoiler_title">分析与实施</b> <div class="spoiler_text"><p> 显示乘积和进位的结果表达式： </p><br><img src="https://habrastorage.org/webt/rm/ij/y4/rmijy4wgg9tdy4b5msszkuteeu8.png" width="300"><br><p><br> 显示了相应的K-map： <br><br><img src="https://habrastorage.org/webt/um/ng/5b/umng5byk6oymxo8v0tu7vlqljxk.png" width="250"><img src="https://habrastorage.org/webt/s1/lf/ux/s1lfuxq_vqs720zq4uaypox7ifi.png" width="250"></p><br><div class="spoiler">  <b class="spoiler_title">代号</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module ternary_multiplier ( input [1:0] A, [1:0] B, output [1:0] product, [1:0] carry ); wire [1:0] temp = 2'b01; wire [1:0] a0, a1, a2, b0, b1, b2; wire [1:0] i0, i1, i2, i3, i4, i5; wire [1:0] o0, o1, o2, o3, o4; mask msk_1(A, a0, a1, a2); mask msk_2(B, b0, b1, b2); andgate and_1(a1,b2,i0); andgate and_2(a2,b1,i1); orgate or_1(i0, i1, o0); // f1 andgate and_4(a1,b1,i3); andgate and_5(a2,b2,i4); orgate or_3(i3, i4, o2); andgate and_3(temp,o2,o3); orgate or_4(o3, o0, product); // product andgate andc_0(a2,b2,o4); andgate andc_1(temp,o4,carry); // carry endmodule</code> </pre> </div></div></div></div><br><h1 id="ternary-multiplexers-and-demultiplexers"> 三元复用器和解复用器 </h1><br><p> 多路复用器是具有多个输入和单个输出的电路。 也称为解码器。 多路复用器的输出功能由功能线的数量确定。 因此对于2 Trit <br> 多路复用器的输出将是3 <sup>2</sup> = 9，两个将是函数选择线。 多路复用器即功能 <br> 选择逻辑从9个功能中选择1个作为输出。 使用逻辑门实现功能选择逻辑。 函数选择逻辑的输出方程为： </p><br><img src="https://habrastorage.org/webt/gh/qt/-j/ghqt-jyk-xoc3fth0ejacsotazy.png" width="500"><br><div class="spoiler">  <b class="spoiler_title">分析方法</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sz/x1/sv/szx1svchlgdpchhueqzpkfsr7ua.png" width="300"><img src="https://habrastorage.org/webt/db/bj/4a/dbbj4a4c_esxzsahk_x-wsywvic.png" width="200"></p><br><p> 解复用器也称为编码器。 其功能与多路复用器相反。 它接受单个输入并将其分配到多个输出 </p></div></div><br><h1 id="simple-ternary-d-latch"> 简单的三元D锁存器 </h1><br><p> 尽管实现组合三进制逻辑的电路的设计很简单，但是适合于集成电路（IC）实现的简单而健壮的三元存储元件（即锁存器）的设计却具有挑战性。 然而，可以通过用对应的三进制T_NOR或T_NAND门代替所使用的二进制NOR或NAND门来获得简单的三元锁存器。 </p><br><img src="https://habrastorage.org/webt/2m/x7/fg/2mx7fg6gctsgvxnbbowgrf5tdc0.png" width="550"><br><h1 id="simple-ternary-d-flip-flap-flop"> 简单的三元D触发器 </h1><br><p> 主从（MS）三元D触发器（FFF）是基于三元D锁存器实现的。 这类似于使用二进制D锁存器实现二进制D触发器（FF）的方式。  MS二进制D触发器的逻辑图和操作说明是众所周知的。 为了实现<abbr title="主奴">MS</abbr>三元D <abbr title="翻盖翻牌">FFF</abbr> ，我们用三元D锁存器（通过两个输入的三元求反最小门-NAND实现）替换二进制D锁存器，并用简单的三元反相器（STI）替换二进制反相器。 示出了三进制NAND电路和三进制STI电路的真值表 </p><br><div class="spoiler">  <b class="spoiler_title">Nand和sti电路的真值表</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/6k/11/so/6k11sode99527pwa_juppe2-oh0.png" width="350"><img src="https://habrastorage.org/webt/tu/wi/pz/tuwipzzcpk7atmn8mc2f39rtir4.png" width="200"></p></div></div><br><p> 对于具有二进制时钟的MS三进制D FFF，数据是三进制的（0、1和2逻辑），而时钟是二进制的（低和高-在我们的 <br> 实施，0和2逻辑）。  MS三元D FFF与 <br> 当时钟从低电平变为低电平时，二进制时钟可以读取数据 <br> 高（正边）或从高到低（负边），具体取决于 <br> 性传播感染的数量。 </p><br><p> 三进制D FFF的输入是Data和Clk，输出是Q和Not_Q。 时钟信号是二进制的，逻辑电平分别表示为0和2，以保持与电气实现的一致性 </p><br><div class="spoiler">  <b class="spoiler_title">模拟</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rb/1d/fm/rb1dfmjougqamdhp1wwp4ebuvkm.png" width="350"><img src="https://habrastorage.org/webt/uk/4u/zw/uk4uzwfhqa-lfga625eh01uqpds.png" width="300"></p></div></div><br><hr><br><img src="https://habrastorage.org/webt/j5/sx/0p/j5sx0p1fb2aiqhkdkfelhpipelw.png" width="600"><br><p><br></p><br><h1 id="1-bit-ternary-arithmetic-and-logic-unit-t-alu">  1位三进制算术和逻辑单元（T-ALU） </h1><br><p> 三元算术逻辑单元（ALU）是用于执行算术和逻辑运算的数字电路。 它代表三元计算机的中央处理单元（CPU）的基本构建块。  ALU执行算术运算，例如加法，减法，乘法和逻辑运算比较，NAND，NOR，NOT，AND和OR。 下面显示了1 trit ALU的原始架构 </p><br><img src="https://habrastorage.org/webt/1c/za/nr/1czanrqwlzh-mg4zkbr7pgspjtm.png" width="600"><br><div class="spoiler">  <b class="spoiler_title">T-ALU的真值表和功能</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ke/s4/-q/kes4-qpjjg25fkz8gvrptpxiju4.png" width="300"><img src="https://habrastorage.org/webt/yb/e-/ud/ybe-udn3yfiz63ihwgtniya8epa.png" width="260"></p></div></div><br><p>  ALU的基本构件是解码器，功能选择逻辑（多路复用器），传输门和独立的处理模块。 功能选择逻辑根据功能选择线W和Z上的逻辑状态从列出的9个功能中选择1个。 </p><br><p> 选择逻辑的输出线连接到与每个模块关联的TG（三进制门）。 仅当启用关联的TG时，才选择任何模块，否则它将与数据线隔离。 例如，如果来自选择线W和Z = 0的输入，选择逻辑的输出E <sub>0</sub>为高（2），而E <sub>1</sub>至E <sub>8</sub>为低（0），则与加法器模块关联的TG将允许数据 <br> 线连接到加法器模块，而其他模块与数据线隔离。 </p><br><p> 最后，通过级联<strong>n / 2</strong> trit ALU切片，可以形成<strong>n</strong> trit ALU。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN431726/">https://habr.com/ru/post/zh-CN431726/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN431716/index.html">Robotron BIC A5105-未知人员GDR</a></li>
<li><a href="../zh-CN431718/index.html">RecyclerView树形视图（没有第三方库和子数组）</a></li>
<li><a href="../zh-CN431720/index.html">UX设计器产品组合技巧和窍门</a></li>
<li><a href="../zh-CN431722/index.html">回顾：晶体管时代如何开始以及1940和1950年代的创业文化如何发展</a></li>
<li><a href="../zh-CN431724/index.html">Tableau软件推出自然语言可视化界面</a></li>
<li><a href="../zh-CN431730/index.html">Windows Server 2019</a></li>
<li><a href="../zh-CN431732/index.html">测试人员对软件可维护性的看法</a></li>
<li><a href="../zh-CN431734/index.html">如何将belongs_to升级为两倍的工作速度（database_validations gem）</a></li>
<li><a href="../zh-CN431736/index.html">门关闭。 降低免税购物门槛还剩一个月</a></li>
<li><a href="../zh-CN431740/index.html">直播Microsoft Connect会议（）； 2018年</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>