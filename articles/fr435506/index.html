<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💦 🧚🏻 🍓 Game Boy Supercomputer 👌🏽 ⏺️ 👩🏻‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="À des vitesses de plus d'un milliard d'images par seconde, c'est sans doute le plus rapide des clusters de consoles 8 bits au monde. 


 Distribué Tet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Game Boy Supercomputer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435506/">  À des vitesses de plus d'un milliard d'images par seconde, c'est sans doute le plus rapide des clusters de consoles 8 bits au monde. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e7/0fa/97d/4e70fa97d86589ec00f0a570a3835feb.gif"><br>  <i>Distribué Tetris (1989)</i> <br><br><h2>  Comment construire un tel ordinateur? </h2><br><h3>  Recette </h3><br>  Prenez une poignée de silicium, appliquez une formation renforcée, une expérience avec les superordinateurs, une passion pour l'architecture informatique, ajoutez de la sueur et des larmes, remuez 1000 heures jusqu'à ébullition - et le tour est joué. <br><br><h2>  Pourquoi aurait-on besoin d'un tel ordinateur? </h2><br>  En bref: évoluer vers l'amélioration de l'intelligence artificielle. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/d7f/1bd/3ef/d7f1bd3ef8197d18fc1612235bfbc0df.png"><br>  <i>L'une des 48 cartes IBM Neural Computer utilisées pour les expériences</i> <br><br><h2>  Et voici une version plus détaillée </h2><br>  2016 année.  L'apprentissage en profondeur est omniprésent.  La reconnaissance d'images peut être considérée comme une tâche résolue grâce aux réseaux de neurones convolutifs, et mes intérêts de recherche sont à la recherche de réseaux de neurones avec mémoire et apprentissage renforcé. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/aa6/7e2/2de/aa67e22de1d4c2eb58f415beb61628e9.png"><br><br>  Plus précisément, dans le travail d'auteur de Google Deepmind, il a été montré qu'il est possible d'atteindre le niveau d'une personne ou même de le dépasser dans divers jeux pour l'Atari 2600 (console de jeu à domicile, publiée en 1977), en utilisant un algorithme d'apprentissage simple pris en charge par Deep Q-Neural Network.  Et tout cela se produit simplement lors de la visualisation du gameplay.  Cela a attiré mon attention. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e3e/dd5/f97/e3edd5f97096170a43b775859b539087.gif"><br>  <i>L'un des jeux avec l'Atari 2600, Breakout.</i>  <i>La machine a été formée à l'aide d'un algorithme d'apprentissage par renforcement simple.</i>  <i>Après des millions d'itérations, l'ordinateur a commencé à jouer mieux que les humains.</i> <br><br>  J'ai commencé à expérimenter avec les jeux Atari 2600. Breakout, bien qu'impressionnant, ne peut pas être qualifié de compliqué.  La difficulté peut être déterminée par le degré de difficulté en fonction de vos actions (joystick) et de vos résultats (points).  Le problème apparaît lorsque l'effet doit attendre longtemps. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f41/849/950/f41849950d6af5392b78e51f838ec707.gif"><br>  <i>Illustration d'un problème utilisant des jeux plus complexes comme exemple.</i>  <i>Gauche - Breakout (ATARI 2600) [l'auteur s'est trompé, c'est un jeu de Pong / env.</i>  <i>trans.] avec une réponse très rapide et un retour rapide.</i>  <i>Droite - Mario Land (Nintendo Game Boy) ne fournit pas d'informations instantanées sur les effets de l'action; de longues périodes d'observations non pertinentes peuvent apparaître entre deux événements importants.</i> <br><br>  Pour rendre l'apprentissage plus efficace, on peut imaginer des tentatives de transfert d'une partie des connaissances de jeux plus simples.  Cette tâche n'est toujours pas résolue et constitue un sujet de recherche actif.  Une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tâche</a> récemment publiée par OpenAI tente de mesurer exactement cela. <br><br>  La capacité de transférer des connaissances n'accélérerait pas seulement la formation - je pense que certains problèmes d'apprentissage ne peuvent pas être résolus du tout en l'absence de connaissances de base.  Nous avons besoin de l'efficacité des données.  Prenez le jeu Prince of Persia: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/139/4d7/aa6/1394d7aa679b5a687d07cd97a5c68d4b.gif"><br><br>  Il n'y a pas de points évidents en elle. <br>  Il faut 60 minutes pour terminer le jeu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/c4d/5b7/11bc4d5b76ad0a167c31067edd0d30ea.gif"><br><br>  Est-il possible d'appliquer la même approche que celle utilisée lors de l'écriture du travail sur l'Atari 2600?  Quelle est la probabilité que vous puissiez arriver à la fin en appuyant sur des touches aléatoires? <br><br>  Cette question m'a incité à contribuer à la communauté, qui consiste à tenter de résoudre ce problème.  En fait, nous avons la tâche du poulet et des œufs - nous avons besoin d'un meilleur algorithme qui nous permettra de transmettre un message, cependant, cela nécessite des recherches et les expériences prennent du temps, car nous n'avons pas d'algorithme plus efficace. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc9/009/5f1/fc90095f174e9052dfb677996562ac14.png"><br>  <i>Un exemple de transfert de connaissances: imaginez que nous avons d'abord appris à jouer à un jeu simple, comme celui de gauche.</i>  <i>Ensuite, nous enregistrons des concepts tels que «course», «voiture», «piste», «gagner» et apprendre des couleurs ou des modèles en trois dimensions.</i>  <i>Nous soutenons que des concepts communs peuvent être «reportés» entre les jeux.</i>  <i>La similitude des jeux peut être déterminée par le nombre de connaissances transférées entre eux.</i>  <i>Par exemple, les jeux Tetris et F1 ne seront pas similaires.</i> <br><br>  Par conséquent, j'ai décidé d'utiliser la deuxième approche idéale, en évitant le ralentissement initial, en accélérant considérablement le système.  Mes objectifs étaient: <br>  - environnement accéléré (imaginez que Prince of Persia peut être complété 100 fois plus vite) et lancement simultané de 100 000 jeux. <br>  - un environnement plus adapté à la recherche (nous nous concentrons sur les tâches, mais pas sur les calculs préliminaires, nous avons accès à différents jeux). <br><br>  Au départ, je pensais que le goulot d'étranglement des performances pouvait en quelque sorte dépendre de la complexité du code de l'émulateur (par exemple, la base de code Stella est grande et elle repose sur des abstractions C ++ - pas le meilleur choix pour les émulateurs). <br><br><h2>  Consoles </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/900/dc8/c32/900dc8c322e070709af65b0f89d55146.jpg"><br><br>  Au total, j'ai travaillé sur plusieurs plateformes, à commencer par l'un des tout premiers jeux jamais créés (avec le jeu Pong) - les Arcade Space Invaders, Atari 2600, NES et Game Boy.  Et tout cela a été écrit en C. <br><br>  J'ai réussi à atteindre une fréquence d'images maximale de 2000-3000 par seconde.  Pour commencer à obtenir les résultats des expériences, nous avons besoin de millions ou de milliards d'images, donc l'écart était énorme. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/677/cd2/ebd/677cd2ebda80be7e5eace8380911c084.gif"><br>  <i>Space Invaders travaillant en FPGA - mode de débogage à faible vitesse.</i>  <i>Le compteur FPGA indique le nombre de cycles d'horloge qui se sont écoulés.</i> <br><br>  Et puis j'ai pensé - et si nous pouvions accélérer le bon environnement avec du fer.  Par exemple, les Space Invaders d'origine sont allés au processeur 8080 avec une fréquence de 1 MHz.  J'ai réussi à émuler un processeur 8080 40 MHz sur un processeur Xeon 3 GHz.  Pas mal, mais après avoir mis tout cela à l'intérieur du FPGA, la fréquence est montée à 400 MHz.  Cela signifiait 24 000 FPS à partir d'un seul flux - l'équivalent d'un Xeon à 30 GHz!  Ai-je mentionné que vous pouvez entasser 100 processeurs 8080 dans un FPGA moyen?  Cela donne déjà 2,4 millions de FPS. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/415/82a/dd1/41582add164c44c52b01fdfec7160e20.gif"><br>  <i>Space Invaders avec accélération matérielle de 100 MHz, un quart de la pleine vitesse</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90d/8a8/4e0/90d8a84e0053c30eb4b337b27c15dcfc.png"><br>  <i>Plus d'une centaine de cœurs à l'intérieur du FPGA Xilinx Kintex 7045 (indiqué par des couleurs vives; la tache bleue au milieu est la logique générale de la démonstration).</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c1/dc9/f93/4c1dc9f93c26391a762466a8216053f9.png"><br>  <i>Chemin d'exécution inégal</i> <br><br>  Vous pouvez demander, qu'en est-il du GPU?  En bref, nous avons besoin de la concurrence comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">MIMD</a> , pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SIMD</a> .  En tant qu'étudiant, j'ai travaillé pendant un certain temps sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mise</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">œuvre d'une</a> recherche d'arbre Monte Carlo sur un GPU (une telle recherche a été utilisée dans AlphaGo). <br><br>  À ce moment-là, j'ai passé d'innombrables heures à essayer de faire fonctionner le GPU et d'autres éléments matériels sur le principe de SIMD (IBM Cell, Xeon Phi, CPU AVX) pour exécuter un code similaire, et rien n'en est sorti.  Il y a quelques années, j'ai commencé à penser que ce serait bien de pouvoir développer indépendamment du matériel spécialement conçu pour résoudre les problèmes liés à la formation de renforcement. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/479/730/b57/479730b5758c7bbccecd7be47f8ca310.gif"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d98/4ee/ad9/d984eead9cd837908580a0545210918b.png"><br>  <i>Accès simultané MIMD</i> <br><br><h2>  ATARI 2600, NES ou Game Boy? </h2><br>  À 8080, j'ai implémenté Space Invaders, NES, 2600 et Game Boy.  Et voici quelques faits à leur sujet et les avantages de chacun d'eux. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f26/475/be6/f26475be6707be383030b9e116222a71.png"><br>  <i>NES Pacman</i> <br><br>  Les Space Invaders n'étaient qu'un échauffement.  Nous avons réussi à les faire travailler, mais ce n'était qu'un jeu, donc le résultat n'était pas très utile. <br><br>  L'Atari 2600 est en fait la norme en matière de recherche d'apprentissage par renforcement.  Le processeur MOS 6507 est une version simplifiée du célèbre 6502, son design est plus élégant et plus efficace que celui du 8080. J'ai choisi le 2600 non seulement à cause de certaines restrictions liées aux jeux et à leurs graphismes. <br><br>  J'ai également implémenté NES (Nintendo Entertainment System), il partage le processeur avec 2600. Les jeux sont bien meilleurs que 2600. Mais les deux consoles souffrent d'un pipeline de traitement graphique trop complexe et de plusieurs formats de cartouche qui doivent être pris en charge. <br><br>  Pendant ce temps, j'ai redécouvert le Nintendo Game Boy.  Et c'est ce que je cherchais. <br><br><h2>  Pourquoi le Game Boy est-il si cool? </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/447/518/78d/44751878d5be5df4e754fdee7913d224.jpg" alt="image"><br>  <i>1049 jeux classiques et 576 jeux pour Game Boy Color</i> <br><br>  Au total, plus de 1000 jeux, une très grande variété, de haute qualité, certains d'entre eux sont assez complexes (Prince), les jeux peuvent être regroupés et assignés à la complexité pour la recherche sur le transfert de connaissances et de formation (par exemple, il existe des options pour Tetris, jeux de course, Mario).  Pour résoudre le jeu Prince of Persia, vous devrez peut-être transférer les connaissances d'un autre jeu similaire dans lequel les points sont clairement indiqués (dans Prince, ce n'est pas le cas). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5ff/f8e/9e7/5fff8e9e75b38f13eb5161b316c76030.gif"><br>  <i>Nintendo Game Boy est ma plateforme de recherche de transfert de connaissances préférée.</i>  <i>Sur le graphique, j'ai essayé de regrouper les jeux en fonction de la complexité (subjective) et de la similitude (concepts tels que la course, le saut, le tir, divers jeux comme Tetris; est-ce que quelqu'un a joué à HATRIS?).</i> <br><br>  Le Game Boy classique a un écran très simple (160x144, couleur 2 bits), donc le prétraitement devient simple, et vous pouvez vous concentrer sur des choses importantes.  À 2600, même les jeux simples ont de nombreuses couleurs.  De plus, sur Game Boy les objets sont bien mieux démontrés, sans clignoter et sans avoir besoin de prendre au maximum deux images consécutives. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/740/9ae/843/7409ae843366b71257755bc7701af3c8.gif"><br><br>  Aucune disposition de mémoire folle, comme le NES ou le 2600. La plupart des jeux peuvent être conçus pour fonctionner avec 2-3 cartographes. <br><br>  Code compact - J'ai réussi à adapter l'ensemble de l'émulateur en C dans pas plus de 700 lignes de code, et mon implémentation Verilog tient dans 500 lignes. <br><br>  Il existe la même version simple de Space Invaders que dans l'arcade. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10f/5d0/838/10f5d0838acb88b453ff82b778389265.gif"><br><br>  Et le voici, mon Game Boy à matrice de points de 1989 et la version FPGA qui fonctionne via HDMI sur un écran 4K. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca2/dd5/77d/ca2dd577d1711be2ddb2d3426dc07c39.png"><br><br>  Et voici ce que mon ancien Game Boy ne peut pas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/343/e65/d45/343e65d45de2b5bac8bd31ffccb7be6e.gif"><br>  <i>Tetris accéléré avec du fer - enregistrement de l'écran en temps réel, la vitesse est 1/4 du maximum.</i> <br><br><h2>  Y a-t-il un réel avantage à cela? </h2><br>  Oui.  Jusqu'à présent, j'ai testé le système dans des conditions simples, avec un réseau externe de règles qui interagit avec des Game Boys individuels.  Plus précisément, j'ai utilisé l'algorithme A3C (Advantage Actor Critic), et je prévois de le décrire dans un article séparé.  Mon collègue l'a connecté au réseau convolutionnel sur FPGA, et cela fonctionne. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cb7/202/75a/cb720275a2f42cf3e17fc28167ec55f0.png"><br>  <i>Comment FGPA communique avec un réseau de neurones</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/da4/f65/160/da4f6516036832a572de98a4bec081e4.png"><br>  <i>A3C distribué</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c3c/2b2/607/c3c2b26079064aa7ab6fee6f4a7f373e.gif"><br>  <i>Mario land: état initial.</i>  <i>Une frappe aléatoire ne nous mènera pas loin.</i>  <i>Le coin supérieur droit indique le temps restant.</i>  <i>Si nous avons de la chance, nous mettrons rapidement fin au jeu après avoir touché la gumba.</i>  <i>Sinon, il faudra 400 secondes pour «perdre».</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/088/0a9/618/0880a9618a01a45c6358469604dea92d.gif"><br>  <i>Mario land: après une heure de jeu, Mario a appris à courir, à sauter et a même ouvert une pièce secrète, rampant dans une pipe.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3b/d37/a82/b3bd37a82e9692319784667a7be9c13c.gif"><br>  <i>Pac Man: après environ une heure d'entraînement, le réseau de neurones a même pu terminer le jeu une fois (en mangeant tous les points).</i> <br><br><h2>  Conclusion </h2><br>  J'aimerais penser que la prochaine décennie sera la période où le supercalcul et l'IA se rencontreront.  J'aimerais avoir du matériel qui me permette de me mettre à un certain niveau afin de m'adapter à l'algorithme AI souhaité. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d06/248/162/d062481627eb1e355c5488ead2ca7ef7.png"><br>  <i>Prochaine décennie</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Code pour Game Boy en C.</a> <br><br><h2>  Débogage </h2><br>  Les gens me demandent souvent: qu'est-ce qui a été le plus difficile?  C'est tout - l'ensemble du projet a été assez douloureux.  Pour commencer, il n'y a pas de spécification pour un Game Boy.  Tout ce que nous avons appris, nous l'avons obtenu grâce à la rétro-ingénierie, c'est-à-dire que nous avons lancé une tâche intermédiaire, comme un jeu, et regardé comment il était exécuté.  Ceci est très différent du débogage logiciel standard, car ici nous déboguons le matériel qui exécute les programmes.  J'ai dû trouver différentes façons d'y parvenir.  Et j'ai parlé de la difficulté de surveiller un processus lorsqu'il s'exécute à une fréquence de 100 MHz?  Oh, et il n'y a pas d'impression ici. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9df/173/ab1/9df173ab1b05d831461a16152646be72.png"><br>  <i>Une approche pour implémenter un processeur consiste à regrouper les instructions sur leurs fonctions.</i>  <i>Avec 6502, c'est beaucoup plus facile.</i>  <i>Le LR35092 a rempli beaucoup de bêtises «aléatoires» et il y a de nombreuses exceptions.</i>  <i>J'ai utilisé cette table lorsque je travaillais avec le CPU Game Boy.</i>  <i>J'ai utilisé une stratégie gourmande - j'ai pris le plus gros morceau d'instructions, les ai implémentées et supprimées, puis les ai répétées.</i>  <i>1/4 des instructions est ALU, 1/4 est le chargement du registre, qui peut être implémenté assez rapidement.</i>  <i>De l'autre côté du spectre, il y a toutes sortes de choses distinctes, telles que «le téléchargement de HL vers SP avec un signe», qui devaient être traitées séparément.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/96b/ec9/38b/96bec938bbac5dbab9b8c71f6024d31b.jpg"><br>  <i>Débogage: exécutez le code sur le matériel que vous déboguez, notez le journal de votre implémentation et des informations supplémentaires (cela montre une comparaison du code Verilog à gauche avec mon émulateur C à droite).</i>  <i>Exécutez ensuite diff pour que les journaux détectent les incohérences (bleu).</i>  <i>L'une des raisons de l'utilisation de l'automatisation est que, dans de nombreux cas, j'ai rencontré des problèmes après des millions de cycles d'exécution lorsqu'un seul indicateur de processeur a provoqué un effet boule de neige.</i>  <i>J'ai essayé plusieurs approches, et celle-ci s'est avérée la plus efficace.</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e50/bea/455/e50bea45577d7225024a0aa66174f9bd.png"><br>  <i>Vous aurez besoin de beaucoup de café!</i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/196/d2e/4eb/196d2e4ebf91bda8e1943dc5e7f81a89.png"><br>  <i>Ces livres ont 40 ans.</i>  <i>C'était incroyable de les fouiller et de regarder le monde des ordinateurs à travers les yeux de ces utilisateurs à cette époque - je me sentais comme un invité du futur.</i> <br><br><h2>  Demande de recherche OpenAI </h2><br>  Au début, je voulais travailler avec des jeux en termes de mémoire, comme décrit dans un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> d'OpenAI. <br><br>  Étonnamment, il a été difficile de faire en sorte que Q-learning fonctionne correctement sur des entrées représentant des états de mémoire. <br><br>  Ce projet peut ne pas avoir de solution.  Il serait inattendu de découvrir que Q-learning ne réussira jamais à travailler avec la mémoire dans Atari, mais il y a des chances que cette tâche soit assez difficile. <br><br>  Étant donné que les jeux sur Atari n'utilisaient que 128 milliards de mémoire, il semblait très intéressant de traiter ces 128 milliards au lieu de trames plein écran.  J'ai obtenu des résultats mitigés, alors j'ai commencé à le comprendre. <br><br>  Et bien que je ne puisse pas prouver qu'il est impossible d'apprendre de la mémoire, je peux montrer que l'hypothèse selon laquelle la mémoire reflète l'état complet du jeu est fausse.  Le CPU Atari 2600 (6507) utilise 128 b de mémoire, mais il a toujours accès à des registres supplémentaires vivant sur un circuit séparé (TIA, adaptateur pour un téléviseur, quelque chose comme un GPU).  Ces registres sont utilisés pour stocker et traiter des informations sur des objets (raquette, fusée, balle, collision).  En d'autres termes, ils seront inaccessibles si l'on ne considère que la mémoire.  NES et Game Boy ont également des registres supplémentaires qui sont utilisés pour contrôler l'écran et faire défiler.  Une seule mémoire ne reflète pas l'état complet du jeu. <br><br>  Seul le 8080 stocke directement les données dans la mémoire vidéo, ce qui vous permet d'extraire l'état complet du jeu.  Dans d'autres cas, les registres "GPU" sont connectés entre le CPU et le tampon d'écran, alors qu'ils sont en dehors de la RAM. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b9/d23/019/0b9d2301998c1cc9dcf414c36fe8e1e3.png"><br><br>  Un fait intéressant: si vous effectuez des recherches sur l'histoire du GPU, le 8080 peut être le premier "accélérateur graphique" - il a un registre à décalage externe qui vous permet de déplacer les envahisseurs spatiaux avec une seule commande, ce qui décharge le processeur. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HyzD8pNlpwI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><img src="https://habrastorage.org/getpro/habr/post_images/899/16c/2d0/89916c2d015f8b881ec16411906ab2aa.png"><br>  Eof </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr435506/">https://habr.com/ru/post/fr435506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr435496/index.html">Tesla poursuivi pour un accident dans lequel le conducteur et le passager de la Model S sont morts</a></li>
<li><a href="../fr435498/index.html">vCloud Director Extender: Migration</a></li>
<li><a href="../fr435500/index.html">Gants biométriques en sport automobile</a></li>
<li><a href="../fr435502/index.html">L'étude a révélé les avantages et les inconvénients du perfectionnisme</a></li>
<li><a href="../fr435504/index.html">Des monstres à la main dans la lutte pour la propreté: sélection d'un aspirateur manuel Xiaomi</a></li>
<li><a href="../fr435508/index.html">Comment fabriquer les meilleurs ordinateurs en Russie? Entretien avec Artyom Smirnov de HYPERPC</a></li>
<li><a href="../fr435510/index.html">Microélectronique, neurophysiologie et apprentissage automatique, secouer mais pas mélanger</a></li>
<li><a href="../fr435512/index.html">Les développeurs de Royole présentent un smartphone flexible pliable</a></li>
<li><a href="../fr435514/index.html">En Russie, ils développent un processeur pour accélérer les réseaux de neurones</a></li>
<li><a href="../fr435520/index.html">Nous écrivons notre langage de programmation, partie 3: Architecture du traducteur. Analyse des structures du langage et des expressions mathématiques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>