<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüî¨ ü¶ê üÖøÔ∏è OS1: noyau primitif sur Rust pour x86 üò¨ üë©‚Äçüë¶ üçü</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai d√©cid√© d'√©crire un article, et si possible, puis une s√©rie d'articles pour partager mon exp√©rience de recherche ind√©pendante √† la fois sur le dis...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: noyau primitif sur Rust pour x86</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445506/"><p>  J'ai d√©cid√© d'√©crire un article, et si possible, puis une s√©rie d'articles pour partager mon exp√©rience de recherche ind√©pendante √† la fois sur le dispositif Bare Bone x86 et sur l'organisation des syst√®mes d'exploitation.  Pour le moment, mon hack ne peut m√™me pas √™tre appel√© un syst√®me d'exploitation - c'est un petit noyau qui peut d√©marrer √† partir de Multiboot (GRUB), g√©rer la m√©moire r√©elle et virtuelle, et √©galement effectuer plusieurs fonctions inutiles en mode multit√¢che sur un seul processeur. </p><br><p>  Pendant le d√©veloppement, je ne me suis pas fix√© pour objectif d'√©crire un nouveau Linux (m√™me si, je l'avoue, j'en ai r√™v√© il y a environ 5 ans) ou d'impressionner quelqu'un, je vous demande donc de ne plus avoir l'air particuli√®rement impressionn√©.  Ce que je voulais vraiment faire √©tait de comprendre comment l'architecture i386 fonctionnait au niveau le plus √©l√©mentaire, et comment les syst√®mes d'exploitation faisaient exactement leur magie, et de d√©terrer le battage publicitaire Rust. </p><br><p> Dans mes notes, je vais essayer de partager non seulement les textes sources (ils peuvent √™tre trouv√©s sur GitLab) et la th√©orie nue (on peut la trouver sur de nombreuses ressources), mais aussi le chemin que je suis all√© pour trouver des r√©ponses non √©videntes.  Plus pr√©cis√©ment, dans cet article, je parlerai de la <strong>cr√©ation d'un fichier noyau, de son chargement et de son initialisation</strong> . </p><br><p>  Mes objectifs sont de structurer les informations dans ma t√™te, ainsi que d'aider ceux qui suivent un chemin similaire.  Je comprends que des mat√©riaux et des blogs similaires existent d√©j√† sur le r√©seau, mais pour arriver √† ma situation actuelle, j'ai d√ª les rassembler longtemps.  Toutes les sources (en tout cas, dont je me souviens), je vais les partager d√®s maintenant. </p><a name="habracut"></a><br><h1 id="literatura-i-istochniki">  Litt√©rature et sources </h1><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bien</a> s√ªr, je l'ai en grande partie tir√©e de l'excellente ressource <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OSDev</a> , √† la fois sur le wiki et sur le forum.  Deuxi√®mement, je nommerai Philip Opperman avec son <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blog</a> - beaucoup d'informations sur le tas de rouille et de fer. </p><br><p>  Certains points sont espionn√©s dans le noyau Linux, Minix n‚Äôest pas sans l‚Äôaide de la litt√©rature sp√©ciale, comme le livre de Tanenbaum ¬´ <em>Operating Systems¬ª.</em>  <em>Conception et impl√©mentation</em> ¬ª <em>,</em> livre de Robert Love¬´ <em>Le noyau Linux.</em>  <em>Description du processus de d√©veloppement</em> . "  Des questions difficiles sur l'organisation de l'architecture x86 ont √©t√© r√©solues √† l'aide du manuel ¬´ <em>Intel 64 et IA-32 Architectures Software Developer's Manual Volume 3 (3A, 3B, 3C &amp; 3D): System Programming Guide</em> ¬ª.  Dans la compr√©hension du format des binaires, les dispositions sont des guides pour ld, llvm, nm, nasm, make. <br>  UPD  Merci √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">CoreTeamTech</a> de m'avoir rappel√© le merveilleux syst√®me Redox OS.  Je ne suis pas sorti de sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">source</a> .  Malheureusement, le syst√®me GitLab officiel n'est pas disponible sur IP russe, vous pouvez donc consulter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GitHub</a> . </p><br><h1 id="esche-odno-predislovie">  Une autre pr√©face </h1><br><p>  Je me rends compte que je ne suis pas un bon programmeur √† Rust, d'ailleurs, c'est mon premier projet dans cette langue (pas la meilleure fa√ßon de commencer √† sortir ensemble, non?).  Par cons√©quent, la mise en ≈ìuvre peut vous sembler compl√®tement incorrecte - √† l'avance, je veux demander la cl√©mence √† mon code et je serai heureux de commenter et suggestions.  Si un lecteur respect√© peut me dire o√π et comment aller de l'avant, je lui en serai √©galement tr√®s reconnaissant.  Certains fragments de code peuvent √™tre copi√©s des didacticiels tels quels et l√©g√®rement modifi√©s, mais j'essaierai de donner des explications aussi claires que possible √† ces sections afin que vous n'ayez pas les m√™mes questions que celles que j'ai eues lors de leur analyse.  Je ne pr√©tends pas non plus utiliser les bonnes approches dans la conception, donc si mon gestionnaire de m√©moire vous donne envie d'√©crire des commentaires en col√®re, je comprends pourquoi. </p><br><h1 id="instrumentariy">  Bo√Æte √† outils </h1><br><p>  Je vais donc commencer par plonger dans les outils de d√©veloppement que j'ai utilis√©s.  En tant qu'environnement, j'ai choisi un bon √©diteur VS Code pratique avec des plugins pour Rust et un d√©bogueur GDB.  VS Code n'est parfois pas tr√®s bon avec RLS, surtout quand il est red√©fini dans un r√©pertoire sp√©cifique, donc apr√®s chaque mise √† jour nocturne de Rust, j'ai d√ª r√©installer RLS. </p><br><p>  La rouille a √©t√© choisie pour plusieurs raisons.  Tout d'abord, sa popularit√© croissante et sa philosophie agr√©able.  Deuxi√®mement, sa capacit√© √† travailler avec un faible niveau mais avec une probabilit√© plus faible de ¬´se tirer une balle dans le pied¬ª.  Troisi√®mement, en tant qu'amoureux de Java et de Maven, je suis tr√®s accro √† la cr√©ation de syst√®mes et √† la gestion des d√©pendances, et le cargo est d√©j√† int√©gr√© au langage de la cha√Æne d'outils.  Quatri√®mement, je voulais juste quelque chose de nouveau, pas comme C. </p><br><p>  Pour le code de bas niveau, j'ai pris NASM, comme  Je me sens confiant dans la syntaxe Intel et je suis √©galement √† l'aise de travailler avec ses directives.  J'ai d√©lib√©r√©ment abandonn√© les inserts d'assembleur dans Rust afin de s√©parer explicitement le travail avec le fer et la logique de haut niveau. <br>  La marque et l'√©diteur de liens de l'approvisionnement LLVM LLD (en tant qu'√©diteur de liens plus rapide et meilleur) ont √©t√© utilis√©s comme assemblage g√©n√©ral et mise en page - c'est une question de go√ªt.  Il √©tait possible de faire avec des scripts de construction pour le fret. </p><br><p>  Qemu a √©t√© utilis√© pour le lancement - j'aime sa vitesse, son mode interactif et sa capacit√© √† accrocher GDB.  Pour d√©marrer et avoir imm√©diatement toutes les informations sur le mat√©riel - bien s√ªr GRUB (Legacy est plus facile √† organiser l'en-t√™te, alors prenez-le). </p><br><h1 id="linkovka-i-komponovka">  Liaison et mise en page </h1><br><p>  Curieusement, pour moi, cela s'est av√©r√© √™tre l'un des sujets les plus difficiles.  Il √©tait extr√™mement difficile de r√©aliser apr√®s de longs essais avec des registres de segments x86 que les segments et les sections ne sont pas la m√™me chose.  Dans la programmation pour l'environnement existant, il n'est pas n√©cessaire de r√©fl√©chir √† la fa√ßon de placer le programme en m√©moire - pour chaque plate-forme et format, l'√©diteur de liens a d√©j√† une recette pr√™te √† l'emploi, il n'est donc pas n√©cessaire d'√©crire un script de l'√©diteur de liens. </p><br><p>  Pour le fer nu, au contraire, il est n√©cessaire d'indiquer comment placer et adresser le code du programme en m√©moire.  Ici, je tiens √† souligner que nous parlons d'une adresse lin√©aire (virtuelle) utilisant le m√©canisme de page.  OS1 utilise un m√©canisme de page, mais je m'y attarderai s√©par√©ment dans la section correspondante de l'article. </p><br><div class="spoiler">  <b class="spoiler_title">Logique, lin√©aire, virtuel, physique ...</b> <div class="spoiler_text"><p>  Adresses physiques, logiques, lin√©aires, virtuelles.  Je me suis cass√© la t√™te sur cette question, donc pour les d√©tails je veux adresser √† cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellent article</a> </p></div></div><br><p>  Pour les syst√®mes d'exploitation qui utilisent la pagination, dans un environnement 32 bits, chaque t√¢che dispose de 4 Go d'espace d'adressage m√©moire, m√™me si 128 Mo de RAM sont install√©s.  Cela se produit uniquement en raison de l'organisation de la pagination de la m√©moire; l'absence de pages dans la m√©moire principale est g√©r√©e en cons√©quence. </p><br><p>  Cependant, en r√©alit√©, les applications sont g√©n√©ralement disponibles un peu moins de 4 Go.  En effet, le syst√®me d'exploitation doit g√©rer les interruptions, les appels syst√®me, ce qui signifie qu'au moins leurs gestionnaires doivent se trouver dans cet espace d'adressage.  Nous sommes confront√©s √† la question: o√π exactement dans ces 4 Go les adresses du noyau doivent-elles √™tre plac√©es pour que les programmes puissent fonctionner correctement? </p><br><p>  Dans le monde moderne des programmes, un tel concept est utilis√©: chaque t√¢che croit qu'elle r√®gne en ma√Ætre sur le processeur et est le seul programme en cours d'ex√©cution sur l'ordinateur (√† ce stade, nous ne parlons pas de communication entre les processus).  Si vous regardez exactement comment les compilateurs collectent les programmes √† l'√©tape de liaison, il s'av√®re qu'ils commencent par une adresse lin√©aire de z√©ro ou proche de z√©ro.  Cela signifie que si l'image du noyau occupe un espace m√©moire proche de z√©ro, les programmes ainsi assembl√©s ne peuvent pas √™tre ex√©cut√©s, toute instruction jmp du programme entra√Ænera l'entr√©e dans la m√©moire prot√©g√©e du noyau et une erreur de protection.  Par cons√©quent, si nous voulons utiliser non seulement des programmes auto-√©crits √† l'avenir, il est raisonnable de donner √† l'application autant de m√©moire que possible pr√®s de z√©ro et de placer l'image du noyau plus haut. </p><br><p>  Ce concept est appel√© demi-noyau sup√©rieur (ici, je vous renvoie √† osdev.org, si vous voulez des informations connexes).  La m√©moire √† choisir ne d√©pend que de votre app√©tit.  512 Mo est suffisant pour quelqu'un, mais j'ai d√©cid√© de me procurer 1 Go, donc mon noyau est situ√© √† 3 Go + 1 Mo (+ 1 Mo est n√©cessaire pour se conformer aux limites de m√©moire inf√©rieures et sup√©rieures, GRUB nous charge dans la m√©moire physique apr√®s 1 Mo) . <br>  Il est √©galement important pour nous de sp√©cifier le point d'entr√©e de notre fichier ex√©cutable.  Pour mon ex√©cutable, ce sera la fonction _loader √©crite en assembleur, sur laquelle je m'attarderai plus en d√©tail dans la section suivante. </p><br><div class="spoiler">  <b class="spoiler_title">√Ä propos du point d'entr√©e</b> <div class="spoiler_text"><p>  Saviez-vous que vous avez menti toute votre vie sur le fait que main () est le point d'entr√©e du programme?  En fait, main () est une convention du langage C et des langages qu'il g√©n√®re.  Si vous creusez, il s'av√®re quelque chose comme ce qui suit. </p><br><p>  Tout d'abord, chaque plate-forme a ses propres sp√©cifications et nom de point d'entr√©e: pour Linux, il s'agit g√©n√©ralement de _start, pour Windows, il s'agit de mainCRTStartup.  Deuxi√®mement, ces points peuvent √™tre red√©finis, mais cela ne fonctionnera pas pour utiliser les d√©lices de libc.  Troisi√®mement, le compilateur fournit ces points d'entr√©e par d√©faut et ils se trouvent dans les fichiers crt0..crtN (CRT - C RunTime, N - nombre d'arguments principaux). </p><br><p>  En fait, que font les compilateurs comme gcc ou vc - ils s√©lectionnent un script de lien sp√©cifique √† la plate-forme qui d√©finit un point d'entr√©e standard, s√©lectionnent le fichier objet souhait√© avec la fonction d'initialisation d'initialisation C pr√™te √† l'emploi et appellent la fonction principale et le lien vers la sortie sous la forme d'un fichier du format souhait√© avec un point d'entr√©e standard. </p><br><p>  Donc, pour nos besoins, le point d'entr√©e standard et l'initialisation CRT doivent √™tre d√©sactiv√©s, car nous n'avons rien d'autre que du fer nu. </p></div></div><br><p>  Que devez-vous savoir d'autre pour cr√©er un lien?  Comment seront localis√©es les sections de donn√©es (.rodata, .data), les variables non initialis√©es (.bss, communes), et rappelez-vous √©galement que GRUB n√©cessite l'emplacement des en-t√™tes de d√©marrage multiple dans les 8 premiers Ko du binaire. </p><br><p>  Alors maintenant, nous pouvons √©crire un script de l'√©diteur de liens! </p><br><pre><code class="plaintext hljs">ENTRY(_loader) OUTPUT_FORMAT(elf32-i386) SECTIONS { . = 0xC0100000; .text ALIGN(4K) : AT(ADDR(.text) - 0xC0000000) { *(.multiboot1) *(.multiboot2) *(.text) } .rodata ALIGN(4K) : AT(ADDR(.rodata) - 0xC0000000) { *(.rodata*) } .data ALIGN (4K) : AT(ADDR(.data) - 0xC0000000) { *(.data) } .bss : AT(ADDR(.bss) - 0xC0000000) { _sbss = .; *(COMMON) *(.bss) _ebss = .; } }</code> </pre> <br><h1 id="zagruzka-posle-grub">  T√©l√©charger apr√®s GRUB </h1><br><p>  Comme mentionn√© ci-dessus, la sp√©cification Multiboot n√©cessite que l'en-t√™te se trouve dans les 8 premiers Ko de l'image de d√©marrage.  La sp√©cification compl√®te peut √™tre consult√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> , mais je m'attarderai uniquement sur les d√©tails d'int√©r√™t. </p><br><ul><li>  L'alignement sur 32 bits (4 octets) doit √™tre respect√© </li><li>  Il doit y avoir un nombre magique 0x1BADB002 </li><li>  Il est n√©cessaire de dire au multibooter quelles informations nous voulons obtenir et comment placer les modules (dans mon cas, je veux que le module du noyau soit align√© sur une page de 4 Ko, et √©galement obtenir une carte m√©moire pour gagner du temps et des efforts) </li><li>  Fournir une somme de contr√¥le (somme de contr√¥le + nombre magique + drapeaux devrait donner z√©ro) </li></ul><br><pre> <code class="plaintext hljs">MB1_MODULEALIGN equ 1&lt;&lt;0 MB1_MEMINFO equ 1&lt;&lt;1 MB1_FLAGS equ MB1_MODULEALIGN | MB1_MEMINFO MB1_MAGIC equ 0x1BADB002 MB1_CHECKSUM equ -(MB1_MAGIC + MB1_FLAGS) section .multiboot1 align 4 dd MB1_MAGIC dd MB1_FLAGS dd MB1_CHECKSUM</code> </pre> <br><p>  Apr√®s le d√©marrage, Multiboot garantit certaines conditions que nous devons consid√©rer. </p><br><ul><li>  Le registre EAX contient le nombre magique 0x2BADB002, qui indique que le t√©l√©chargement a r√©ussi </li><li>  Le registre EBX contient l'adresse physique de la structure avec des informations sur les r√©sultats du chargement (nous en reparlerons beaucoup plus tard) </li><li>  Le processeur est en mode prot√©g√©, la m√©moire des pages est d√©sactiv√©e, les registres de segments et la pile sont dans un √©tat ind√©fini (pour nous), GRUB les a utilis√©s pour ses besoins et doit √™tre red√©fini d√®s que possible. </li></ul><br><p>  La premi√®re chose que nous devons faire est d'activer la pagination, de r√©gler la pile et enfin de transf√©rer le contr√¥le au code Rust de haut niveau. <br>  Je ne m'attarderai pas en d√©tail sur l'organisation des pages de la m√©moire, Page Directory et Page Table, car d'excellents articles ont √©t√© √©crits √† ce sujet (l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un d'eux</a> ).  La principale chose que je veux partager est que les pages ne sont pas des segments!  Veuillez ne pas r√©p√©ter mon erreur et ne chargez pas l'adresse de la table des pages dans GDTR!  Car le tableau des pages est CR3!  La page peut avoir une taille diff√©rente dans diff√©rentes architectures, pour plus de simplicit√© de travail (pour n'avoir qu'une seule table de page), j'ai choisi une taille de 4 Mo en raison de l'inclusion de PSE. </p><br><p>  Donc, nous voulons activer la m√©moire de page virtuelle.  Pour ce faire, nous avons besoin d'une table de pages et de son adresse physique, charg√©e dans CR3.  Dans le m√™me temps, notre fichier binaire a √©t√© li√© pour fonctionner dans un espace d'adressage virtuel avec un d√©calage de 3 Go.  Cela signifie que toutes les adresses et √©tiquettes variables ont un d√©calage de 3 Go.  Le tableau des pages n'est qu'un tableau dans lequel l'adresse de la page contient sa v√©ritable adresse, align√©e sur la taille de la page, ainsi que des indicateurs d'acc√®s et d'√©tat.  √âtant donn√© que j'utilise des pages de 4 Mo, je n'ai besoin que d'une table de pages PD avec 1024 entr√©es: </p><br><pre> <code class="plaintext hljs">section .data align 0x1000 BootPageDirectory: dd 0x00000083 times (KERNEL_PAGE_NUMBER - 1) dd 0 dd 0x00000083 times (1024 - KERNEL_PAGE_NUMBER - 1) dd 0</code> </pre> <br><p>  Qu'y a-t-il dans le tableau? </p><br><ol><li>  La toute premi√®re page devrait conduire √† la section actuelle du code (0-4 Mo de m√©moire physique), car toutes les adresses du processeur sont physiques et la traduction en virtuel n'est pas encore effectu√©e.  L'absence de ce descripteur de page entra√Ænera un plantage imm√©diat, car le processeur ne pourra pas prendre l'instruction suivante apr√®s avoir activ√© les pages.  Indicateurs: bit 0 - la table est pr√©sente, bit 1 - la page est √©crite, bit 7 - taille de page 4 Mo.  Apr√®s avoir activ√© les pages, l'enregistrement est r√©initialis√©. </li><li>  Sautez jusqu'√† 3 Go - les z√©ros garantissent que la page n'est pas en m√©moire </li><li>  La marque de 3 Go est notre c≈ìur de m√©moire virtuelle, r√©f√©ren√ßant 0 dans la m√©moire physique.  Apr√®s avoir tourn√© les pages, nous allons travailler ici.  Les drapeaux sont similaires au premier enregistrement. </li><li>  Sautez jusqu'√† 4 Go. </li></ol><br><p>  Donc, nous avons d√©clar√© la table et maintenant nous voulons charger son adresse physique dans CR3.  N'oubliez pas le d√©calage d'adresse de 3 Go lors de la liaison.  Tenter de charger l'adresse telle qu'elle nous enverra √† la vraie adresse de 3 Go + d√©calage variable et entra√Ænera un crash imm√©diat.  Par cons√©quent, nous prenons l'adresse de BootPageDirectory et en soustrayons 3 Go, nous la mettons dans CR3.  Nous activons le PSE dans le registre CR4, activons le travail avec les pages dans le registre CR0: </p><br><pre> <code class="plaintext hljs"> mov ecx, (BootPageDirectory - KERNEL_VIRTUAL_BASE) mov cr3, ecx mov ecx, cr4 or ecx, 0x00000010 mov cr4, ecx mov ecx, cr0 or ecx, 0x80000000 mov cr0, ecx</code> </pre> <br><p>  Jusqu'√† pr√©sent, tout se passe bien, mais d√®s que nous r√©initialisons la premi√®re page pour enfin passer √† la moiti√© sup√©rieure de 3 Go, tout s'effondrera, car le registre EIP a toujours une adresse physique dans la r√©gion du premier m√©gaoctet.  Pour r√©soudre ce probl√®me, nous effectuons une manipulation simple: mettez une marque √† l'endroit le plus proche, chargez son adresse (elle est d√©j√† avec un d√©calage de 3 Go, rappelez-vous cela) et faites un saut inconditionnel √† travers elle.  Apr√®s cela, une page inutile peut √™tre r√©initialis√©e pour de futures applications. </p><br><pre> <code class="plaintext hljs"> lea ecx, [StartInHigherHalf] jmp ecx StartInHigherHalf: mov dword [BootPageDirectory], 0 invlpg [0]</code> </pre> <br><p>  Maintenant, tout est question de tr√®s petit: initialisez la pile, passez la structure GRUB et l'assembleur suffit! </p><br><pre> <code class="plaintext hljs"> mov esp, stack+STACKSIZE push eax push ebx lea ecx, [BootPageDirectory] push ecx call kmain hlt section .bss align 32 stack: resb STACKSIZE</code> </pre> <br><p>  Ce que vous devez savoir sur ce morceau de code: </p><br><ol><li>  Selon la convention C des appels (elle est √©galement applicable √† Rust), les variables sont transf√©r√©es √† la fonction via la pile dans l'ordre inverse.  Toutes les variables sont align√©es sur 4 octets en x86. </li><li>  La pile se d√©veloppe √† partir de la fin, donc le pointeur vers la pile doit conduire √† la fin de la pile (ajoutez STACKSIZE √† l'adresse).  La taille de la pile que j'ai prise √©tait de 16 Ko, devrait suffire. </li><li>  Les √©l√©ments suivants sont transf√©r√©s au noyau: le nombre magique de Multiboot, l'adresse physique de la structure du chargeur de d√©marrage (il y a une pr√©cieuse carte m√©moire pour nous), l'adresse virtuelle de la table des pages (quelque part dans 3 Go d'espace) </li></ol><br><p>  N'oubliez pas non plus de d√©clarer que kmain est externe et que _loader est global. </p><br><h1 id="dalneyshie-shagi">  Etapes suppl√©mentaires </h1><br><p>  Dans les notes suivantes, je vais parler de la configuration des registres de segments, passer bri√®vement en revue la sortie des informations via un tampon VGA, vous expliquer comment j'ai organis√© le travail avec les interruptions, la gestion des pages et la chose la plus douce - le multit√¢che - je partirai pour le dessert. </p><br><p>  Le code de projet complet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">est disponible sur GitLab</a> . </p><br><p>  Merci de votre attention! </p><br><p>  UPD2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 2</a> <br>  UPD2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 3</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr445506/">https://habr.com/ru/post/fr445506/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr445494/index.html">Comment le fragment de balisage CSS a cass√© le compilateur C ++</a></li>
<li><a href="../fr445496/index.html">Comment le fragment de balisage CSS a cass√© le compilateur C ++</a></li>
<li><a href="../fr445500/index.html">√Ä propos d'Open Distros, Open Source et Elastic</a></li>
<li><a href="../fr445502/index.html">Vivaldi 2.4 - D√©placer les boutons √† deux mains</a></li>
<li><a href="../fr445504/index.html">La gestion des services informatiques (ITSM) encore plus efficace gr√¢ce √† l'apprentissage automatique</a></li>
<li><a href="../fr445510/index.html">G√©rer les attentes ou dire non</a></li>
<li><a href="../fr445512/index.html">Comment nous avons rendu PHP 7 deux fois plus rapide que PHP 5. Partie 2: optimisation du bytecode en PHP 7.1</a></li>
<li><a href="../fr445514/index.html">Les plus int√©ressants √† l'exposition Securika Moscou 2019</a></li>
<li><a href="../fr445516/index.html">√âtats neuronaux quantiques - Repr√©sentation d'une fonction d'onde par un r√©seau neuronal</a></li>
<li><a href="../fr445518/index.html">Vieux fer: des outils √©lectroniques qui se perdent dans les profondeurs de l'histoire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>