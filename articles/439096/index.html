<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëéüèø üïç üîó Buildbot: una historia con ejemplos de otro sistema de integraci√≥n continua üìΩÔ∏è üññüèº üîÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(imagen del sitio oficial ) 

 Buildbot, como su nombre lo indica, es un sistema de integraci√≥n continua (ci). Ya hab√≠a varios art√≠culos sobre √©l en e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buildbot: una historia con ejemplos de otro sistema de integraci√≥n continua</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439096/"><img src="https://habrastorage.org/webt/so/qs/u1/soqsu1skae_0xuktzdemfv-n3yq.png"><br>  <i><font color="#aaaaaa">(imagen del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sitio oficial</a> )</font></i> <br><br>  Buildbot, como su nombre lo indica, es un sistema de integraci√≥n continua (ci).  Ya hab√≠a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">varios</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> sobre √©l en el Habr√©, pero, desde mi punto de vista, las ventajas de esta herramienta no est√°n muy claras.  Adem√°s, casi no tienen ejemplos, lo que hace que sea dif√≠cil ver todo el poder del programa.  En mi art√≠culo, intentar√© compensar estas deficiencias, hablar sobre el dispositivo interno Buildbot'a y dar ejemplos de varios scripts no est√°ndar. <br><a name="habracut"></a><br><h3>  Palabras comunes </h3><br>  Actualmente, hay una gran cantidad de sistemas de integraci√≥n continua, y cuando se trata de uno de ellos, surgen preguntas bastante l√≥gicas en el esp√≠ritu de "¬øPor qu√© es necesario si ya tiene un &lt;program_name&gt; y todos lo usan?"  Intentar√© responder una pregunta sobre Buildbot.  Parte de la informaci√≥n se duplicar√° con los art√≠culos existentes, algunos se describen en la documentaci√≥n oficial, pero esto es necesario para la coherencia de la narrativa. <br><br>  La principal diferencia con otros sistemas de integraci√≥n continua es que Buildbot es un marco de Python para escribir ci, no una soluci√≥n lista para usar.  Esto significa que para conectar un proyecto a Buildbot, primero debe escribir un programa de Python separado utilizando el marco Buildbot que implementa la funcionalidad de integraci√≥n continua que su proyecto necesita.  Este enfoque proporciona una tremenda flexibilidad, lo que le permite implementar escenarios de prueba dif√≠ciles que son imposibles para soluciones listas para usar debido a limitaciones arquitect√≥nicas. <br><br>  Adem√°s, Buildbot no es un servicio y, por lo tanto, debe implementarlo honestamente en su infraestructura.  Aqu√≠ noto que el marco es muy fiel a los recursos del sistema.  Esto ciertamente no es C o C ++, pero Python gana contra sus competidores Java.  Aqu√≠, por ejemplo, comparando el consumo de memoria con GoCD (y s√≠, a pesar del nombre, este es un sistema Java): <br><br>  Buildbot: <br><br><img src="https://habrastorage.org/webt/q1/tg/wu/q1tgwuy-ef8bl6au-s7lc07da-c.png"><br><br>  GoCD: <br><br><img src="https://habrastorage.org/webt/lg/ci/bk/lgcibk9si78bjzf_gfqrgktcgug.png"><br><br>  Implementar y escribir un programa de prueba por su cuenta puede entristecerlo con la idea de la configuraci√≥n inicial.  Sin embargo, la secuencia de comandos se simplifica enormemente por la gran cantidad de clases incorporadas.  Estas clases cubren muchas operaciones est√°ndar, ya sea obtener cambios del repositorio de github o construir el proyecto con CMake.  Como resultado, los scripts est√°ndar para proyectos peque√±os no ser√°n m√°s complicados que los archivos YML para algunos travis-ci.  No escribir√© sobre la implementaci√≥n, esto est√° cubierto en detalle en los art√≠culos existentes y tampoco hay nada complicado all√≠. <br><br>  La siguiente caracter√≠stica de Buildbot, noto que por defecto la l√≥gica de prueba se implementa en el lado del servidor ci.  Esto va en contra del ahora popular enfoque de "canalizaci√≥n como c√≥digo", en el que la l√≥gica de prueba se describe en un archivo (como .travis.yml) que se encuentra en el repositorio junto con el c√≥digo fuente del proyecto, y el servidor ci solo lee este archivo y ejecuta lo que dice  Nuevamente, este es solo el comportamiento predeterminado.  Las capacidades del marco Buildbot le permiten implementar el enfoque descrito al almacenar el script de prueba en el repositorio.  Incluso hay una soluci√≥n preparada: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bb-travis</a> , que trata de sacar lo mejor de Buildbot y travis-ci.  Adem√°s, m√°s adelante en este art√≠culo describir√© c√≥mo implementar algo similar a este comportamiento yo mismo. <br><br>  Buildbot por defecto recoge cada confirmaci√≥n al empujar.  Puede parecer una peque√±a caracter√≠stica innecesaria, pero para m√≠, por el contrario, se ha convertido en una de las principales ventajas.  Muchas soluciones populares listas para usar (travis-ci, gitlab-ci) no brindan esa oportunidad en absoluto, ya que solo funcionan con el √∫ltimo commit en la rama.  Imagine que durante el desarrollo a menudo tiene que elegir las confirmaciones.  Ser√° desagradable realizar una confirmaci√≥n que no funcione, que no fue verificada por el sistema de compilaci√≥n debido al hecho de que se lanz√≥ junto con un mont√≥n de confirmaciones desde arriba.  Por supuesto, en Buildbot solo puede compilar la √∫ltima confirmaci√≥n, y esto se hace configurando solo un par√°metro. <br><br>  El marco tiene una documentaci√≥n bastante buena, que describe todo en detalle, desde la arquitectura general hasta las pautas para extender las clases integradas.  Sin embargo, incluso con dicha documentaci√≥n, es posible que tenga que mirar algunas cosas en el c√≥digo fuente.  Est√° completamente abierto bajo la licencia GPL v2 y es f√°cil de leer.  De las desventajas: la documentaci√≥n est√° disponible solo en ingl√©s, en ruso hay muy poca informaci√≥n en la red.  La herramienta no apareci√≥ ayer, con su ayuda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">python</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wireshark</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LLVM</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muchos otros</a> proyectos conocidos est√°n ensamblados.  Saldr√°n actualizaciones, el proyecto cuenta con el respaldo de muchos desarrolladores, por lo que podemos hablar de confiabilidad y estabilidad. <br><br><img src="https://habrastorage.org/webt/22/we/zg/22wezgyvqnccjmk2sl_ehs954bg.png"><br>  <i><font color="#aaaaaa">(P√°gina de inicio de Python Buildbot)</font></i> <br><br><h3>  Teormina </h3><br>  Esta parte es esencialmente una traducci√≥n gratuita del cap√≠tulo de documentaci√≥n oficial sobre la arquitectura del marco.  Muestra la cadena completa de acciones desde la recepci√≥n de cambios por parte del sistema ci hasta el env√≠o de notificaciones del resultado a los usuarios.  Entonces, realiz√≥ cambios en el c√≥digo fuente del proyecto y los envi√≥ al repositorio remoto.  Lo que sucede a continuaci√≥n se muestra esquem√°ticamente en la imagen: <br><br><img src="https://habrastorage.org/webt/hq/ue/na/hquenaedpe7hdlulfnmctiew2b8.png"><br>  <i><font color="#aaaaaa">(imagen de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la documentaci√≥n oficial</a> )</font></i> <br><br>  En primer lugar, Buildbot deber√≠a descubrir de alguna manera que ha habido cambios en el repositorio.  Hay dos formas principales: webhooks y encuestas, aunque nadie proh√≠be proponer algo m√°s sofisticado.  En el primer caso, en Buildbot, las clases descendientes de BaseHookHandler son responsables de esto.  Hay muchas soluciones listas para <i>usar</i> , por ejemplo, <i>GitHubHandler</i> o <i>GitoriusHandler</i> .  El m√©todo clave en estas clases es <b>getChanges ()</b> .  Su l√≥gica es extremadamente simple: debe convertir la solicitud HTTP en una lista de objetos de cambio. <br><br>  Para el segundo caso, necesita <i>clases</i> descendientes <i>PollingChangeSource</i> .  Una vez m√°s, hay soluciones listas para <i>usar</i> , como <i>GitPoller</i> o <i>HgPoller</i> .  El m√©todo clave es <b>poll ()</b> .  Se llama con cierta frecuencia y de alguna manera debe crear una lista de cambios en el repositorio.  En el caso de un git, esto podr√≠a ser una llamada a git fetch y una comparaci√≥n con el estado guardado anterior.  Si las capacidades integradas no son suficientes, simplemente cree su propia clase de heredero y sobrecargue el m√©todo.  Un ejemplo de uso de encuestas: <br><br><pre><code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'change_source'</span></span>] = [changes.GitPoller( repourl = <span class="hljs-string"><span class="hljs-string">'git@git.example.com:project'</span></span>, project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>, branches = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, <span class="hljs-comment"><span class="hljs-comment">#      pollInterval = 60 )]</span></span></code> </pre> <br>  Webhook es a√∫n m√°s f√°cil de usar, lo principal es no olvidar configurarlo en el lado del servidor git.  Esta es solo una l√≠nea en el archivo de configuraci√≥n: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'github'</span></span>: {} }</code> </pre> <br>  El siguiente paso, los objetos de cambio se ingresan a los objetos del planificador ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">planificadores</a> ).  Ejemplos de planificadores <i>integrados</i> : <i>AnyBranchScheduler</i> , <i>NightlyScheduler</i> , <i>ForceScheduler</i> , etc.  Cada programador recibe todos los objetos de cambio como entrada, pero selecciona solo aquellos que pasan el filtro.  El filtro se pasa al planificador en el constructor mediante el argumento <i>change_filter</i> .  En la salida, los planificadores crean solicitudes de compilaci√≥n.  El planificador selecciona los constructores en funci√≥n del argumento de los constructores. <br><br>  Algunos planificadores tienen un argumento complicado llamado <i>treeStableTimer</i> .  Funciona de la siguiente manera: cuando se recibe un cambio, el planificador no crea inmediatamente una nueva solicitud de compilaci√≥n, sino que inicia un temporizador.  Si llegan nuevos cambios y el temporizador no ha expirado, el cambio anterior se reemplaza por uno nuevo y el temporizador se actualiza.  Cuando finaliza el temporizador, el planificador crea solo una solicitud de compilaci√≥n a partir del √∫ltimo cambio guardado. <br><br>  Por lo tanto, se implementa la l√≥gica de ensamblar solo el √∫ltimo compromiso al empujar.  Ejemplo de configuraci√≥n del planificador: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'My Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'My Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>] )]</code> </pre> <br>  Las solicitudes de compilaci√≥n, por extra√±o que parezca, van a la entrada de los constructores.  La tarea del recopilador es ejecutar el ensamblado en un "trabajador" accesible.  Worker es un entorno de compilaci√≥n, como stretch64 o ubuntu1804x64.  La lista de trabajadores se pasa por el argumento de los <i>trabajadores</i> .  Todos los trabajadores de la lista deben ser iguales (es decir, los nombres son naturalmente diferentes, pero el entorno interno es el mismo), ya que el recolector es libre de elegir cualquiera de los disponibles.  Establecer valores m√∫ltiples aqu√≠ sirve para equilibrar la carga y no para construir en diferentes entornos.  Usando el argumento <i>factor</i> y, el recolector recibe una secuencia de pasos para construir el proyecto.  Escribir√© sobre esto en detalle a continuaci√≥n. <br><br>  Un ejemplo de configuraci√≥n del recopilador: <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'My Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = factory )]</code> </pre> <br>  Entonces, el proyecto est√° listo.  El √∫ltimo paso de Buildbot es notificar a la compilaci√≥n.  Las clases de reporteros son responsables de esto.  Un ejemplo cl√°sico es la clase <i>MailNotifier</i> , que env√≠a un correo electr√≥nico con resultados de compilaci√≥n.  <i>Ejemplo de</i> conexi√≥n de <i>MailNotifier</i> : <br><br><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'services'</span></span>] = [reporters.MailNotifier( fromaddr = <span class="hljs-string"><span class="hljs-string">'buildbot@example.com'</span></span>, relayhost = <span class="hljs-string"><span class="hljs-string">'mail.example.com'</span></span>, smtpPort = <span class="hljs-number"><span class="hljs-number">25</span></span>, extraRecipients = [<span class="hljs-string"><span class="hljs-string">'devel@example.com'</span></span>], sendToInterestedUsers = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> )]</code> </pre> <br>  Bueno, es hora de pasar a ejemplos completos.  Noto que Buildbot en s√≠ mismo fue escrito usando el marco Twisted, y por lo tanto, conocerlo facilitar√° enormemente la escritura y comprensi√≥n de los scripts de Buildbot.  Tendremos un ni√±o l√°tigo para un proyecto llamado Pet Project.  Deje que est√© escrito en C ++, ensamblado usando CMake, y el c√≥digo fuente se encuentra en el repositorio de git.  No √©ramos demasiado vagos y escribimos pruebas para √©l dirigidas por el equipo ctest.  M√°s recientemente, le√≠mos este art√≠culo y nos dimos cuenta de que queremos aplicar los conocimientos reci√©n obtenidos a nuestro proyecto. <br><br><h3>  Ejemplo uno: para que funcione </h3><br>  En realidad, el archivo de configuraci√≥n: <br><br><div class="spoiler">  <b class="spoiler_title">100 l√≠neas de c√≥digo python</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> buildbot.plugins <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-comment"><span class="hljs-comment"># shortcut c = BuildmasterConfig = {} # create workers c['workers'] = [worker.Worker('stretch32', 'example_password')] # general settings c['title'] = 'Buildbot: test' c['titleURL'] = 'https://buildbot.example.com/' c['buildbotURL'] = 'https://buildbot.example.com/' # setup database c['db'] = { 'db_url': 'sqlite:///state.sqlite' } # port to communicate with workers c['protocols'] = { 'pb': { 'port': 9989 } } # make buildbot developers a little bit happier c['buildbotNetUsageData'] = 'basic' # webserver setup c['www'] = dict(plugins = dict(waterfall_view={}, console_view={}, grid_view={})) c['www']['authz'] = util.Authz( allowRules = [util.AnyEndpointMatcher(role = 'admins')], roleMatchers = [util.RolesFromUsername(roles = ['admins'], usernames = ['root'])] ) c['www']['auth'] = util.UserPasswordAuth([('root', 'root_password')]) # mail notification c['services'] = [reporters.MailNotifier( fromaddr = 'buildbot@example.com', relayhost = 'mail.example.com', smtpPort = 25, extraRecipients = ['devel@example.com'], sendToInterestedUsers = False )] c['change_source'] = [changes.GitPoller( repourl = 'git@git.example.com:pet-project', project = 'Pet Project', branches = True, pollInterval = 60 )] c['schedulers'] = [schedulers.AnyBranchScheduler( name = 'Pet Project Scheduler', treeStableTimer = None, change_filter = util.ChangeFilter(project = 'Pet Project'), builderNames = ['Pet Project Builder'] )] factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property('repository'), workdir = 'sources', haltOnFailure = True, submodules = True, progress = True) ) factory.addStep(steps.ShellSequence( name = 'create builddir', haltOnFailure = True, hideStepIf = lambda results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = ['rm', '-rf', 'build']), util.ShellArg(command = ['mkdir', 'build']) ]) ) factory.addStep(steps.CMake( workdir = 'build', path = '../sources', haltOnFailure = True) ) factory.addStep(steps.Compile( name = 'build project', workdir = 'build', haltOnFailure = True, warnOnWarnings = True, command = ['make']) ) factory.addStep(steps.ShellCommand( name = 'run tests', workdir = 'build', haltOnFailure = True, command = ['ctest']) ) c['builders'] = [util.BuilderConfig( name = 'Pet Project Builder', workernames = ['stretch32'], factory = factory )]</span></span></code> </pre> <br></div></div><br>  Al escribir estas l√≠neas, obtenemos un ensamblaje autom√°tico al ingresar al repositorio, una hermosa cara web, notificaciones por correo electr√≥nico y otros atributos de cualquier ci que se respete a s√≠ mismo.  La mayor parte de esto debe quedar claro: la configuraci√≥n de los planificadores, los recolectores y otros objetos se hacen similares a los ejemplos dados anteriormente, el valor de la mayor√≠a de los par√°metros es intuitivo.  En detalle, me enfocar√© solo en crear una f√°brica, lo que promet√≠ hacer antes. <br><br>  La f√°brica consta de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pasos</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">compilaci√≥n</a> que Buildbot debe completar para el proyecto.  Al igual que con otras clases, hay muchas soluciones preparadas.  Nuestra f√°brica consta de cinco pasos.  Como regla, el primer paso es obtener el estado actual del repositorio, y aqu√≠ no haremos una excepci√≥n.  Para hacer esto, usamos la clase est√°ndar de <i>Git</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Primer paso</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  A continuaci√≥n, necesitamos crear un directorio en el que se ensamblar√° el proyecto; haremos una compilaci√≥n completa de la fuente.  Antes de esto, debe recordar eliminar el directorio si ya existe.  Por lo tanto, necesitamos ejecutar dos comandos.  La clase <i>ShellSequence</i> nos ayudar√° con esto: <br><br><div class="spoiler">  <b class="spoiler_title">Segundo paso</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellSequence( name = <span class="hljs-string"><span class="hljs-string">'create builddir'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS, commands = [ util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'rm'</span></span>, <span class="hljs-string"><span class="hljs-string">'-rf'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]), util.ShellArg(command = [<span class="hljs-string"><span class="hljs-string">'mkdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'build'</span></span>]) ]) )</code> </pre> <br></div></div><br>  Ahora necesita iniciar CMake.  Para hacer esto, es l√≥gico usar una de las dos clases: <i>ShellCommand</i> o <i>CMake</i> .  Usaremos este √∫ltimo, pero las diferencias son m√≠nimas: es un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedor simple</a> sobre la primera clase, lo que hace que sea un poco m√°s conveniente pasar argumentos espec√≠ficos de CMake. <br><br><div class="spoiler">  <b class="spoiler_title">Tercer paso</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.CMake( workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, path = <span class="hljs-string"><span class="hljs-string">'../sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) )</code> </pre> <br></div></div><br>  Hora de compilar el proyecto.  Como en el caso anterior, puede usar <i>ShellCommand</i> .  Del mismo modo, existe la clase <i>Compile</i> , que es un contenedor sobre <i>ShellCommand</i> .  Sin embargo, este es un contenedor m√°s complicado: la clase <i>Compile</i> supervisa las advertencias durante la compilaci√≥n y las muestra con precisi√≥n en un registro separado.  Por eso usaremos la clase <i>Compile</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Cuarto paso</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.Compile( name = <span class="hljs-string"><span class="hljs-string">'build project'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'make'</span></span>]) )</code> </pre> <br></div></div><br>  Finalmente, ejecuta nuestras pruebas.  Aqu√≠ usaremos la clase <i>ShellCommand</i> mencionada anteriormente: <br><br><div class="spoiler">  <b class="spoiler_title">Quinto paso</b> <div class="spoiler_text"><pre> <code class="python hljs">factory.addStep(steps.ShellCommand( name = <span class="hljs-string"><span class="hljs-string">'run tests'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'build'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, command = [<span class="hljs-string"><span class="hljs-string">'ctest'</span></span>]) )</code> </pre> <br></div></div><br><h3>  Ejemplo dos: canalizaci√≥n como c√≥digo </h3><br>  Aqu√≠ mostrar√© c√≥mo implementar una opci√≥n de presupuesto para almacenar la l√≥gica de prueba junto con el c√≥digo fuente del proyecto, y no en el archivo de configuraci√≥n del servidor ci.  Para hacer esto, coloque el archivo <i>.buildbot</i> en el repositorio con el c√≥digo, en el que cada l√≠nea consta de palabras, la primera de las cuales se interpreta como un directorio para ejecutar el comando y el resto como un comando con sus argumentos.  Para nuestro proyecto de mascotas, el archivo <i>.buildbot</i> se ver√° as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">.Buildbot archivo con comandos</b> <div class="spoiler_text"> <code>. rm -rf build <br> . mkdir build <br> build cmake ../sources <br> build make <br> build ctest</code> <br> </div></div><br>  Ahora necesitamos modificar el archivo de configuraci√≥n de Buildbot.  Para analizar el archivo <i>.buildbot</i> , tendremos que escribir una clase de nuestro propio paso.  Este paso leer√° el archivo <i>.buildbot</i> , despu√©s de lo cual, para cada l√≠nea, agregue el paso <i>ShellCommand</i> con los argumentos necesarios.  Para agregar pasos din√°micamente, utilizaremos el m√©todo <b>build.addStepsAfterCurrentStep ()</b> .  No parece para nada aterrador: <br><br><div class="spoiler">  <b class="spoiler_title">An√°lisis de clase Paso</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.stdio_log = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.addLog(<span class="hljs-string"><span class="hljs-string">'stdio'</span></span>) cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue(util.FAILURE) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cmd.stdout.splitlines(): lst = row.split() dirname = lst.pop(<span class="hljs-number"><span class="hljs-number">0</span></span>) results.append(steps.ShellCommand( name = lst[<span class="hljs-number"><span class="hljs-number">0</span></span>], command = lst, workdir = dirname ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</code> </pre> <br></div></div><br>  Gracias a este enfoque, la f√°brica para el coleccionista se ha vuelto m√°s simple y vers√°til: <br><br><div class="spoiler">  <b class="spoiler_title">F√°brica para analizar el archivo .buildbot</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) )</code> </pre> <br></div></div><br><h3>  Ejemplo tres: trabajador como c√≥digo </h3><br>  Ahora imagine que al lado del c√≥digo del proyecto, necesitamos determinar no la secuencia de comandos, sino el entorno para el ensamblaje.  De hecho, definimos trabajador.  <i>El</i> archivo <i>.buildbot</i> podr√≠a verse as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">.Buildbot archivo de entorno</b> <div class="spoiler_text"> <code>{ <br> "workers": ["stretch32", "wheezy32"] <br> }</code> <br> </div></div><br>  El archivo de configuraci√≥n de Buildbot en este caso se volver√° m√°s complicado, porque queremos que los ensamblajes en diferentes entornos est√©n interconectados (si al menos un entorno falla, todo el commit se considerar√° inoperativo).  Dos niveles nos ayudan a resolver el problema.  Tendremos un trabajador local que analiza el archivo <i>.buildbot</i> y ejecuta las compilaciones en los trabajadores deseados.  Primero, como en el ejemplo anterior, escribiremos nuestro paso para analizar el archivo <i>.buildbot</i> .  Para iniciar el ensamblaje en un trabajador espec√≠fico, se <i>utiliza</i> un paquete del paso <i>Trigger</i> y un tipo especial de planificadores <i>TriggerableScheduler</i> .  Nuestro paso se ha vuelto un poco m√°s complicado, pero bastante comprensible: <br><br><div class="spoiler">  <b class="spoiler_title">An√°lisis de clase Paso</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnalyseStep</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(ShellMixin, BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, workdir, **kwargs)</span></span></span><span class="hljs-function">:</span></span> kwargs = self.setupShellMixin(kwargs, prohibitArgs = [<span class="hljs-string"><span class="hljs-string">'command'</span></span>, <span class="hljs-string"><span class="hljs-string">'workdir'</span></span>, <span class="hljs-string"><span class="hljs-string">'want_stdout'</span></span>]) BuildStep.__init__(self, **kwargs) self.workdir = workdir @defer.inlineCallbacks <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_getWorkerList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> cmd = RemoteShellCommand( command = [<span class="hljs-string"><span class="hljs-string">'cat'</span></span>, <span class="hljs-string"><span class="hljs-string">'.buildbot'</span></span>], workdir = self.workdir, want_stdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, want_stderr = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, collectStdout = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) cmd.useLog(self.stdio_log) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.runCommand(cmd) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cmd.didFail(): defer.returnValue([]) <span class="hljs-comment"><span class="hljs-comment"># parse JSON try: payload = json.loads(cmd.stdout) workers = payload.get('workers', []) except json.decoder.JSONDecodeError as e: raise ValueError('Error loading JSON from .buildbot file: {}' .format(str(e))) defer.returnValue(workers) @defer.inlineCallbacks def run(self): self.stdio_log = yield self.addLog('stdio') try: workers = yield self._getWorkerList() except ValueError as e: yield self.stdio_log.addStdout(str(e)) defer.returnValue(util.FAILURE) results = [] for worker in workers: results.append(steps.Trigger( name = 'check on worker "{}"'.format(worker), schedulerNames = ['Pet Project ({}) Scheduler'.format(worker)], waitForFinish = True, haltOnFailure = True, warnOnWarnings = True, updateSourceStamp = False, alwaysUseLatest = False ) ) self.build.addStepsAfterCurrentStep(results) defer.returnValue(util.SUCCESS)</span></span></code> </pre> <br></div></div><br>  Usaremos este paso en el trabajador local.  Tenga en cuenta que hemos establecido la etiqueta para nuestro recopilador "Pet Project Builder".  Con √©l, podemos filtrar <i>MailNotifier</i> , dici√©ndole que las cartas deben enviarse solo a ciertos recolectores.  Si no se realiza este filtrado, cuando creemos el commit en dos entornos, recibiremos tres letras. <br><br><div class="spoiler">  <b class="spoiler_title">Coleccionista general</b> <div class="spoiler_text"><pre> <code class="python hljs">factory = util.BuildFactory() factory.addStep(steps.Git( repourl = util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, submodules = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, progress = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, mode = <span class="hljs-string"><span class="hljs-string">'incremental'</span></span>) ) factory.addStep(AnalyseStep( name = <span class="hljs-string"><span class="hljs-string">'Analyse .buildbot file'</span></span>, workdir = <span class="hljs-string"><span class="hljs-string">'sources'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'generic_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = factory )]</code> </pre> <br></div></div><br>  Nos queda agregar los recolectores y los mismos Programadores activables para todos nuestros trabajadores reales: <br><br><div class="spoiler">  <b class="spoiler_title">Coleccionistas en el entorno adecuado.</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> worker <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> allWorkers: c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Scheduler'</span></span>.format(worker), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker)]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project ({}) Builder'</span></span>.format(worker), workernames = [worker], factory = specific_factory) )</code> </pre> <br></div></div><br><img src="https://habrastorage.org/webt/iq/_n/n4/iq_nn4nhvj07vcina32c2244o6a.png"><br>  <i><font color="#aaaaaa">(p√°gina de construcci√≥n de nuestro proyecto en dos entornos)</font></i> <br><br><h3>  Ejemplo cuatro: una letra por varias confirmaciones </h3><br>  Si utiliza alguno de los ejemplos anteriores, puede observar una caracter√≠stica desagradable.  Como se crea una letra para cada confirmaci√≥n, cuando empujemos la rama con 20 nuevas confirmaciones, recibiremos 20 letras.  Evitando esto, como en el ejemplo anterior, ayudaremos a dos niveles.  Tambi√©n necesitamos modificar la clase para obtener los cambios.  En lugar de crear muchos objetos de cambio, crearemos solo uno de esos objetos, en cuyas propiedades se transmite una lista de todas las confirmaciones.  A toda prisa, esto se puede hacer as√≠: <br><br><div class="spoiler">  <b class="spoiler_title">Clase MultiGitHubHandler</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MultiGitHubHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(GitHubHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getChanges</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, request)</span></span></span><span class="hljs-function">:</span></span> new_changes = GitHubHandler.getChanges(self, request) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_changes: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) change = new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>] change[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] = <span class="hljs-string"><span class="hljs-string">'{}..{}'</span></span>.format( new_changes[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>], new_changes[<span class="hljs-number"><span class="hljs-number">-1</span></span>][<span class="hljs-string"><span class="hljs-string">'revision'</span></span>]) commits = [c[<span class="hljs-string"><span class="hljs-string">'revision'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_changes] change[<span class="hljs-string"><span class="hljs-string">'properties'</span></span>][<span class="hljs-string"><span class="hljs-string">'commits'</span></span>] = commits <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ([change], <span class="hljs-string"><span class="hljs-string">'git'</span></span>) c[<span class="hljs-string"><span class="hljs-string">'www'</span></span>][<span class="hljs-string"><span class="hljs-string">'change_hook_dialects'</span></span>] = { <span class="hljs-string"><span class="hljs-string">'base'</span></span>: { <span class="hljs-string"><span class="hljs-string">'custom_class'</span></span>: MultiGitHubHandler } }</code> </pre> <br></div></div><br>  Para trabajar con un objeto de cambio tan inusual, necesitamos nuestro propio paso especial, que crea din√°micamente pasos que recopilan una confirmaci√≥n espec√≠fica: <br><br><div class="spoiler">  <b class="spoiler_title">Clase GenerateCommitSteps</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenerateCommitSteps</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BuildStep)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> commits = self.getProperty(<span class="hljs-string"><span class="hljs-string">'commits'</span></span>) results = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> commit <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> commits: results.append(steps.Trigger( name = <span class="hljs-string"><span class="hljs-string">'Checking commit {}'</span></span>.format(commit), schedulerNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>], waitForFinish = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, warnOnWarnings = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, sourceStamp = { <span class="hljs-string"><span class="hljs-string">'branch'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'branch'</span></span>), <span class="hljs-string"><span class="hljs-string">'revision'</span></span>: commit, <span class="hljs-string"><span class="hljs-string">'codebase'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'codebase'</span></span>), <span class="hljs-string"><span class="hljs-string">'repository'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'repository'</span></span>), <span class="hljs-string"><span class="hljs-string">'project'</span></span>: util.Property(<span class="hljs-string"><span class="hljs-string">'project'</span></span>) } ) ) self.build.addStepsAfterCurrentStep(results) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> util.SUCCESS</code> </pre> <br></div></div><br>  Agregue nuestro recopilador com√∫n, que solo participa en la ejecuci√≥n de ensamblados de confirmaciones individuales.  Debe etiquetarse para luego filtrar el env√≠o de cartas por esta etiqueta. <br><br><div class="spoiler">  <b class="spoiler_title">Recolector de correo general</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>] = [schedulers.AnyBranchScheduler( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Scheduler'</span></span>, treeStableTimer = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, change_filter = util.ChangeFilter(project = <span class="hljs-string"><span class="hljs-string">'Pet Project'</span></span>), builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>] )] branches_factory = util.BuildFactory() branches_factory.addStep(GenerateCommitSteps( name = <span class="hljs-string"><span class="hljs-string">'Generate commit steps'</span></span>, haltOnFailure = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, hideStepIf = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> results, s: results == util.SUCCESS) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>] = [util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Branches Builder'</span></span>, tags = [<span class="hljs-string"><span class="hljs-string">'branch_builder'</span></span>], workernames = [<span class="hljs-string"><span class="hljs-string">'local'</span></span>], factory = branches_factory )]</code> </pre> <br></div></div><br>  Queda por agregar solo el recopilador para confirmaciones individuales.  Simplemente no etiquetamos este recopilador con una etiqueta y, por lo tanto, no se crear√°n cartas para √©l. <br><br><div class="spoiler">  <b class="spoiler_title">Recolector de correo general</b> <div class="spoiler_text"><pre> <code class="python hljs">c[<span class="hljs-string"><span class="hljs-string">'schedulers'</span></span>].append(schedulers.Triggerable( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Scheduler'</span></span>, builderNames = [<span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>]) ) c[<span class="hljs-string"><span class="hljs-string">'builders'</span></span>].append(util.BuilderConfig( name = <span class="hljs-string"><span class="hljs-string">'Pet Project Commits Builder'</span></span>, workernames = [<span class="hljs-string"><span class="hljs-string">'stretch32'</span></span>], factory = specific_factory) )</code> </pre> <br></div></div><br><h3>  Palabras finales </h3><br>  Este art√≠culo de ninguna manera reemplaza la lectura de la documentaci√≥n oficial, por lo que si est√° interesado en Buildbot, entonces su pr√≥ximo paso deber√≠a ser leerlo.  Las versiones completas de los archivos de configuraci√≥n de todos los ejemplos est√°n disponibles en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> .  Enlaces relacionados, de los cuales se tomaron la mayor√≠a de los materiales para el art√≠culo: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Documentaci√≥n oficial</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente del proyecto</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/439096/">https://habr.com/ru/post/439096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../439080/index.html">El RabbitMQ no obvio en Yii2 o por qu√© RabbitMQ escribe en todas las colas a la vez</a></li>
<li><a href="../439082/index.html">Wish Factory Walk</a></li>
<li><a href="../439086/index.html">Causas de ANR y c√≥mo evitarlo</a></li>
<li><a href="../439090/index.html">El IBM 5150. Donde comenz√≥ el monopolio</a></li>
<li><a href="../439094/index.html">Los cient√≠ficos han encontrado el vertebrado vivo m√°s antiguo de la Tierra</a></li>
<li><a href="../439098/index.html">Sasha Memus, Chatfuel: C√≥mo desarrollar una carrera en productos despu√©s de consultar, es peligroso meditar y c√≥mo cambiar el comportamiento</a></li>
<li><a href="../439100/index.html">C√≥mo adaptar UX / UI bajo permisos</a></li>
<li><a href="../439102/index.html">Los rusos tienen un 20% m√°s de probabilidades de sufrir insultos en Internet</a></li>
<li><a href="../439104/index.html">Redux Simple como un rastrillo</a></li>
<li><a href="../439108/index.html">Mediciones de radioaficionados: cuando no hay medidor de frecuencia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>