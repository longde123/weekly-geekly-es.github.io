<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüåæ üïû üñï No√ß√µes b√°sicas de programa√ß√£o reativa usando RxJS üßíüèº üåç üîù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 1. Reatividade e fluxos 
 Esta s√©rie de artigos enfoca a reatividade e sua aplica√ß√£o em JS usando uma biblioteca maravilhosa como o RxJS. 

 S√©r...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>No√ß√µes b√°sicas de programa√ß√£o reativa usando RxJS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438642/"><h3>  Parte 1. Reatividade e fluxos </h3><br>  Esta s√©rie de artigos enfoca a reatividade e sua aplica√ß√£o em JS usando uma biblioteca maravilhosa como o RxJS. <br><br>  S√©rie de artigos "Fundamentos da programa√ß√£o reativa usando RxJS": <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2. Operadores e tubula√ß√µes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3. Observ√°veis ‚Äã‚Äãde ordem superior</a> </li></ul><br><br>  <b>Para quem √© este artigo</b> : basicamente, aqui vou explicar o b√°sico, portanto, o artigo √© destinado principalmente para iniciantes nesta tecnologia.  Ao mesmo tempo, espero que desenvolvedores experientes possam aprender algo novo por si mesmos.  O entendimento exigir√° conhecimento de js (es5 / es6). <br><br>  <b>Motiva√ß√£o</b> : Encontrei o RxJS pela primeira vez quando comecei a trabalhar com angular.  Foi ent√£o que tive dificuldade em entender o mecanismo de reatividade.  Dificuldades foram adicionadas pelo fato de que, no in√≠cio do meu trabalho, a maioria dos artigos era dedicada √† vers√£o antiga da biblioteca.  Eu tive que ler muita documenta√ß√£o, v√°rios manuais para pelo menos entender alguma coisa.  E s√≥ depois de algum tempo comecei a perceber como "tudo est√° organizado".  Para facilitar a vida dos outros, decidi colocar tudo nas prateleiras. <br><a name="habracut"></a><br><h4>  O que √© reatividade? </h4><br>  √â dif√≠cil encontrar uma resposta para um termo aparentemente comum.  Em resumo: reatividade √© a capacidade de responder a quaisquer altera√ß√µes.  Mas de que mudan√ßas estamos falando?  Primeiro de tudo, sobre altera√ß√µes de dados.  Considere um exemplo: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 5 -   </span></span></code> </pre> <a name="push"></a><br>  Este exemplo demonstra o paradigma de programa√ß√£o imperativo familiar.  Diferentemente da abordagem imperativa, a abordagem reativa baseia-se em estrat√©gias de propaga√ß√£o de mudan√ßas por push.  A estrat√©gia de envio implica que, no caso de altera√ß√µes de dados, essas mesmas altera√ß√µes ser√£o "enviadas" e os dados dependentes deles ser√£o atualizados automaticamente.  Aqui est√° como nosso exemplo se comportaria se uma estrat√©gia de envio fosse aplicada: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> sum = a + b; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sum); <span class="hljs-comment"><span class="hljs-comment">// 5 a = 3; console.log(sum); // 6 -   sum  </span></span></code> </pre><br>  Este exemplo mostra uma abordagem reativa.  Vale a pena notar que este exemplo n√£o tem nada a ver com a realidade, eu dei apenas para mostrar a diferen√ßa nas abordagens.  O c√≥digo reativo em aplicativos do mundo real parecer√° muito diferente e, antes de prosseguir para a pr√°tica, dever√≠amos falar sobre outro componente importante da reatividade. <br><br><h4>  Fluxo de dados </h4><br>  Se voc√™ olhar para o termo ‚Äúprograma√ß√£o reativa‚Äù na Wikipedia, o site nos dar√° a seguinte defini√ß√£o: ‚ÄúPrograma√ß√£o reativa √© um paradigma de programa√ß√£o focado em fluxos de dados e na propaga√ß√£o de altera√ß√µes‚Äù.  A partir dessa defini√ß√£o, podemos concluir que a reatividade √© baseada em duas ‚Äúbaleias‚Äù principais.  Eu mencionei a distribui√ß√£o das mudan√ßas acima, ent√£o n√£o iremos nos aprofundar nisso.  Mas devemos falar mais sobre fluxos de dados.  Vejamos o seguinte exemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> input = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'input'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     const eventsArray = []; input.addEventListener('keyup', event =&gt; eventsArray.push(event) ); //      eventsArray</span></span></code> </pre><br>  Ouvimos o evento keyup e colocamos o objeto de evento em nossa matriz.  Com o tempo, nossa matriz pode conter milhares de objetos KeyboardEvent.  Vale a pena notar que nossa matriz √© classificada por tempo - o √≠ndice de eventos posteriores √© maior que o √≠ndice de eventos anteriores.  Essa matriz √© um modelo de fluxo de dados simplificado.  Por que simplificado?  Porque a matriz pode armazenar apenas dados.  Tamb√©m podemos iterar a matriz e, de alguma forma, processar seus elementos.  Mas a matriz n√£o pode nos dizer que um novo elemento foi adicionado a ela.  Para descobrir se novos dados foram adicionados √† matriz, teremos que iter√°-los novamente. <br><br>  Mas e se nossa matriz soubesse nos informar que novos dados chegaram nela?  Tal matriz poderia com certeza ser chamada de fluxo.  Ent√£o, chegamos √† defini√ß√£o de fluxo.  Um fluxo √© uma matriz de dados classificados por tempo que pode indicar que os dados foram alterados. <br><br><h4>  Observ√°vel </h4><br>  Agora que sabemos o que s√£o fluxos, vamos trabalhar com eles.  No RxJS, os fluxos s√£o representados pela classe Observable.  Para criar seu pr√≥prio fluxo, chame o construtor dessa classe e passe a fun√ß√£o de inscri√ß√£o como argumento: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(<span class="hljs-number"><span class="hljs-number">1</span></span>); observer.next(<span class="hljs-number"><span class="hljs-number">2</span></span>); observer.complete(); })</code> </pre><br>  Ao chamar o construtor da classe Observable, criamos um novo thread.  Como argumento, passamos a fun√ß√£o de inscri√ß√£o para o construtor.  A fun√ß√£o de assinatura √© uma fun√ß√£o regular que leva um observador como par√¢metro.  O pr√≥prio observador √© um objeto que possui tr√™s m√©todos: <br><br><ul><li>  next - lan√ßa um novo valor no fluxo </li><li>  error - lan√ßa um erro no fluxo, ap√≥s o qual o fluxo termina </li><li>  complete - finaliza o encadeamento </li></ul><br>  Ent√£o, criamos um thread que emite dois valores e termina. <br><br><h4>  Assinatura </h4><br>  Se rodarmos o c√≥digo anterior, nada acontecer√°.  Criaremos apenas um novo fluxo e salvaremos o link na vari√°vel observ√°vel, mas o pr√≥prio fluxo nunca emitir√° um √∫nico valor.  Isso ocorre porque os threads s√£o objetos "pregui√ßosos" e n√£o fazem nada por si mesmos.  Para que nosso fluxo comece a emitir valores e possamos processar esses valores, precisamos come√ßar a "ouvir" o fluxo.  Voc√™ pode fazer isso chamando o m√©todo de inscri√ß√£o no objeto observ√°vel. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer = { <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value), <span class="hljs-comment"><span class="hljs-comment">// 1, 2 error: error =&gt; console.error(error), // complete: () =&gt; console.log("completed") // completed }; observable.subscribe(observer);</span></span></code> </pre><br>  Identificamos nosso observador e descrevemos tr√™s m√©todos para ele: pr√≥ximo, erro, completo.  Os m√©todos simplesmente registram dados que s√£o passados ‚Äã‚Äãcomo par√¢metros.  Em seguida, chamamos o m√©todo de inscri√ß√£o e passamos nosso observador para ele.  No momento da chamada de inscri√ß√£o, a fun√ß√£o de inscri√ß√£o √© chamada, a que passamos para o construtor no est√°gio de declara√ß√£o de nosso fluxo.  Em seguida, o c√≥digo da fun√ß√£o de assinatura ser√° executado, que passa dois valores ao nosso observador e, em seguida, finaliza o fluxo. <br><br>  Certamente, muitos t√™m uma pergunta, o que acontecer√° se assinarmos o fluxo novamente?  Tudo ser√° o mesmo: o fluxo passar√° novamente dois valores para o observador e terminar√°.  Cada vez que o m√©todo de inscri√ß√£o √© chamado, uma fun√ß√£o de inscri√ß√£o ser√° chamada e todo o seu c√≥digo ser√° executado novamente.  A partir disso, podemos concluir: n√£o importa quantas vezes assinemos o fluxo, nossos observadores receber√£o os mesmos dados. <br><br><h4>  Cancelar inscri√ß√£o </h4><a name="timer"></a><br>  Agora vamos tentar implementar um exemplo mais complexo.  Escreveremos um cron√¥metro que contar√° segundos do momento da assinatura e os transmitiremos aos observadores. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  setInterval(() =&gt; { observer.next(counter++); //          }, 1000); }); timer.subscribe({ next: console.log //    });</span></span></code> </pre><br>  O c√≥digo √© bastante simples.  Dentro da fun√ß√£o de assinatura, declaramos uma vari√°vel de contador.  Ent√£o, usando o fechamento, acessamos a vari√°vel a partir da fun√ß√£o de seta em setInterval.  E a cada segundo passamos a vari√°vel para o observador, ap√≥s o que a incrementamos.  Em seguida, assine o fluxo, especifique apenas um m√©todo - a seguir.  N√£o se preocupe, porque n√£o anunciamos outros m√©todos.  Nenhum dos m√©todos de observa√ß√£o √© necess√°rio.  Podemos at√© passar um objeto vazio, mas, neste caso, o thread ser√° desperdi√ßado. <br><br>  Ap√≥s o lan√ßamento, veremos os logs cobi√ßados que aparecer√£o a cada segundo.  Se desejar, voc√™ pode experimentar e se inscrever no fluxo v√°rias vezes.  Voc√™ ver√° que cada um dos threads ser√° executado independentemente dos outros. <br><br>  Se voc√™ pensar bem, nosso encadeamento ser√° executado durante toda a vida √∫til de todo o aplicativo, porque n√£o temos l√≥gica para cancelar o setInterval e, na fun√ß√£o de inscri√ß√£o, n√£o h√° chamada para o m√©todo completo.  Mas e se precisarmos que o segmento termine? <br><br>  De fato, tudo √© muito simples.  Se voc√™ olhar para a documenta√ß√£o, poder√° ver que o m√©todo de inscri√ß√£o retorna um objeto de inscri√ß√£o.  Este objeto tem um m√©todo de cancelamento de inscri√ß√£o.  N√≥s o chamamos, e nosso observador deixar√° de receber valores do fluxo. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscription = timer.subscribe({<span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log}); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> subscription.unsubscribe(), <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   5 </span></span></code> </pre><br>  Ap√≥s o in√≠cio, veremos que o contador para em 4. Mas, embora tenhamos cancelado a inscri√ß√£o no fluxo, nossa fun√ß√£o setInterval continua funcionando.  Ela incrementa nosso contador a cada segundo e o passa para o observador idiota.  Para impedir que isso aconte√ßa, voc√™ deve escrever a l√≥gica para cancelar o intervalo.  Para fazer isso, voc√™ precisa retornar uma nova fun√ß√£o da fun√ß√£o de assinatura na qual a l√≥gica de cancelamento ser√° implementada. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> intervalId = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { observer.next(counter++); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { clearInterval(intervalId); } });</code> </pre><br>  Agora podemos respirar aliviados.  Depois de chamar o m√©todo de cancelamento de assinatura, nossa fun√ß√£o de cancelamento de assinatura ser√° chamada, o que limpar√° o intervalo. <br><br><h4>  Conclus√£o </h4><br>  Este artigo mostra as diferen√ßas entre as abordagens imperativa e reativa, bem como exemplos de cria√ß√£o de seus pr√≥prios fluxos.  Na pr√≥xima parte, falarei sobre outros m√©todos para criar threads e como aplic√°-los. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt438642/">https://habr.com/ru/post/pt438642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt438632/index.html">Hardcore 2D RPG Gamedev Diaries, vol.0 - INTRO, ou "Como eu cheguei aqui"</a></li>
<li><a href="../pt438634/index.html">Nos escrit√≥rios, √© muito quente ou muito frio: existe uma maneira melhor de ajustar a temperatura?</a></li>
<li><a href="../pt438636/index.html">Incorpora√ß√£o defeituosa de fun√ß√µes no Go</a></li>
<li><a href="../pt438638/index.html">Analisamos o protocolo de mensagens de pager POCSAG, parte 2</a></li>
<li><a href="../pt438640/index.html">Moeda eletr√¥nica aberta de alta velocidade</a></li>
<li><a href="../pt438644/index.html">A seguran√ßa dos algoritmos de aprendizado de m√°quina. Protegendo e testando modelos usando Python</a></li>
<li><a href="../pt438646/index.html">Sobre a cria√ß√£o de imagens est√©reo de or√ßamento nos dedos (estereograma, anaglyph, estereosc√≥pio)</a></li>
<li><a href="../pt438648/index.html">Compara√ß√£o de sistemas de BI (Tableau, Power BI, Oracle, Qlik)</a></li>
<li><a href="../pt438650/index.html">Foguete 9M729. Algumas palavras sobre o "violador" do Tratado INF</a></li>
<li><a href="../pt438652/index.html">IDA de Portabeliza√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>