<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèæ üë® ‚òùüèΩ Git por dentro e por fora üï∫üèº ‚òùüèæ üëç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A capacidade de trabalhar dentro de um sistema de controle de vers√£o √© uma habilidade que todo programador precisa. Frequentemente, pode parecer que c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Git por dentro e por fora</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/468177/">  A capacidade de trabalhar dentro de um sistema de controle de vers√£o √© uma habilidade que todo programador precisa.  Frequentemente, pode parecer que cavar no Git e entender seus elementos internos √© um desperd√≠cio de tempo extra e tarefas b√°sicas podem ser resolvidas por meio de um conjunto b√°sico de comandos. <br><br>  A equipe do AppsCast, √© claro, queria aprender mais e, para obter conselhos sobre a aplica√ß√£o pr√°tica de todos os recursos do Git, os caras se voltaram para <b>Yegor Andreyevich,</b> da Square. <br><br><img src="https://habrastorage.org/webt/wx/nd/kg/wxndkg7_giwgsbmreljpv-0h5l4.jpeg"><br><a name="habracut"></a><br>  <b>Daniil Popov</b> : Ol√° pessoal.  Hoje, Yegor Andreyevich, da Square, se juntou a n√≥s. <br><br>  <b>Egor Andreyevich</b> : Ol√° a todos.  Moro no Canad√° e trabalho para a Square, uma empresa de software e hardware para o setor financeiro.  Come√ßamos com terminais para aceitar pagamentos com cart√£o de cr√©dito, agora prestamos servi√ßos para empres√°rios.  Estou trabalhando em um produto Cash App.  Este √© um banco m√≥vel que permite trocar dinheiro com amigos, solicitar um cart√£o de d√©bito para pagamento nas lojas.  A empresa possui muitos escrit√≥rios em todo o mundo e o escrit√≥rio canadense possui cerca de 60 programadores. <br><br>  <b>Daniil Popov</b> : No ambiente de desenvolvedores de Android, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Square √©</a> conhecida por seus projetos de c√≥digo aberto que se tornaram padr√µes da ind√∫stria: OkHttp, Picasso, Retrofit.  √â l√≥gico que, ao desenvolver essas ferramentas abertas a todos, voc√™ trabalha muito com o Git.  Gostar√≠amos de conversar sobre isso. <br><br><h2>  O que √© git </h2><br>  <b>Egor Andreevich</b> : Eu uso o Git h√° muito tempo como ferramenta e, em algum momento, tornou-se interessante para mim aprender mais sobre ele. <br><br><blockquote>  Git √© um sistema de arquivos simplificado, al√©m de um conjunto de opera√ß√µes para trabalhar com controle de vers√£o. <br></blockquote><br>  O Git permite salvar arquivos em um formato espec√≠fico.  Cada vez que voc√™ escreve um arquivo, o Git retorna a chave do seu objeto - <b>hash</b> . <br><br>  <b>Daniil Popov</b> : Muitas pessoas perceberam que o reposit√≥rio tem um diret√≥rio oculto m√°gico <b>.git</b> .  Por que √© necess√°rio?  Posso excluir ou renome√°-lo? <br><br>  <b>Egor Andreevich</b> : √â poss√≠vel criar um reposit√≥rio atrav√©s do comando <b>git init</b> .  Ele cria o diret√≥rio <b>.git</b> que o Git usa para controlar arquivos.  <b>O .Git</b> armazena tudo o que voc√™ faz no seu projeto, apenas em um formato compactado.  Portanto, voc√™ pode restaurar o reposit√≥rio deste diret√≥rio. <br><br>  <b>Alexei Kudryavtsev</b> : Acontece que sua pasta do projeto √© uma das vers√µes da pasta expandida do Git? <br><br>  <b>Egor Andreevich</b> : Dependendo de qual ramo voc√™ est√°, o git restaura um projeto com o qual voc√™ pode trabalhar. <br><br>  <b>Alexei Kudryavtsev</b> : O que h√° dentro da pasta? <br><br>  <b>Egor Andreevich</b> : O Git cria pastas e arquivos espec√≠ficos.  A pasta mais importante √© .git / objects, onde todos os objetos s√£o armazenados.  O objeto mais simples √© o blob, essencialmente o mesmo que um arquivo, mas em um formato que o git entende.  Quando voc√™ deseja salvar um arquivo de texto no reposit√≥rio, o Git o compacta, arquiva, adiciona dados e cria um blob. <br><br>  Existem diret√≥rios - s√£o pastas com subpastas, ou seja,  O Git tem um tipo de objeto de <b>√°rvore</b> que cont√©m refer√™ncias ao blob, a outras √°rvores. <br><br><blockquote>  Basicamente, uma √°rvore √© um instant√¢neo que descreve o estado do seu diret√≥rio em um determinado ponto. </blockquote><br>  Ao criar uma confirma√ß√£o, um link para o diret√≥rio de trabalho √© uma √°rvore fixa. <br><br>  Uma confirma√ß√£o √© um link para uma √°rvore com informa√ß√µes sobre quem a criou: email, nome, hora de cria√ß√£o, link para pai (filial pai) e mensagem.  O Git tamb√©m comprime e grava confirma√ß√µes no diret√≥rio de objetos. <br><br>  Para ver como tudo isso funciona, voc√™ precisa listar os subdiret√≥rios na linha de comando. <br><br><h2>  Benef√≠cios de trabalhar com o Git </h2><br>  <b>Daniil Popov</b> : Como o Git funciona?  Por que o algoritmo de a√ß√£o √© t√£o complicado? <br><br>  <b>Egor Andreevich</b> : Se voc√™ comparar o Git com o Subversion (SVN), no primeiro sistema, existem v√°rias fun√ß√µes que voc√™ precisa entender.  Come√ßarei com a <b>√°rea de prepara√ß√£o</b> , que n√£o deve ser considerada uma limita√ß√£o do Git, mas sim dos recursos. <br><br>  √â sabido que, ao trabalhar com c√≥digo, nem tudo acontece imediatamente: em algum lugar √© necess√°rio alterar o layout, em algum lugar para corrigir bugs.  Como resultado, ap√≥s uma sess√£o de trabalho, s√£o exibidos v√°rios arquivos afetados que n√£o est√£o interconectados.  Se voc√™ fizer todas as altera√ß√µes em uma confirma√ß√£o, ser√° inconveniente, pois as altera√ß√µes s√£o de natureza diferente.  Em seguida, uma s√©rie de confirma√ß√µes chega √† sa√≠da, que pode ser criada apenas gra√ßas √† √°rea de prepara√ß√£o.  Por exemplo, todas as altera√ß√µes no arquivo de layout s√£o enviadas para uma s√©rie, por exemplo, corrija os testes de unidade para outra.  Pegamos v√°rios arquivos, os movemos para a √°rea de prepara√ß√£o e criamos um commit apenas com a participa√ß√£o deles.  Outros arquivos do diret√≥rio de trabalho n√£o se enquadram nele.  Assim, voc√™ divide todo o trabalho realizado no diret√≥rio de trabalho em v√°rias confirma√ß√µes, cada uma representando um trabalho espec√≠fico. <br><br>  <b>Alexei Kudryavtsev</b> : Como o Git √© diferente de outros sistemas de controle de vers√£o? <br><br>  <b>Egor Andreevich</b> : Pessoalmente, comecei com o SVN e depois mudei imediatamente para o Git.  Importante, o Git √© um sistema de controle de vers√£o descentralizado.  Todas as c√≥pias do reposit√≥rio Git s√£o exatamente iguais.  Cada empresa possui um servidor em que a vers√£o principal est√° localizada, mas n√£o √© diferente daquela que o desenvolvedor possui no computador. <br><br>  O SVN possui um reposit√≥rio central e c√≥pias locais.  Isso significa que qualquer desenvolvedor pode interromper o reposit√≥rio central sozinho. <br><br>  No Git, isso n√£o vai acontecer.  Se o servidor central perder os dados do reposit√≥rio, eles poder√£o ser restaurados a partir de qualquer c√≥pia local.  O Git foi projetado de maneira diferente e oferece os benef√≠cios da velocidade. <br><br>  <b>Daniil Popov</b> : O Git √© famoso por sua ramifica√ß√£o, que √© notavelmente mais r√°pida que o SVN.  Como ele faz isso? <br><br>  <b>Egor Andreevich</b> : No SVN, um ramo √© uma c√≥pia completa do ramo anterior.  N√£o h√° representa√ß√£o f√≠sica de ramifica√ß√£o no Git.  Este √© um link para o √∫ltimo commit em uma linha de desenvolvimento espec√≠fica.  Quando o Git salva objetos, ao criar um commit, ele cria um arquivo com informa√ß√µes espec√≠ficas sobre o commit.  O Git cria um arquivo simb√≥lico - link simb√≥lico com um link para outro arquivo.  Quando voc√™ tem muitas ramifica√ß√µes, refere-se a diferentes confirma√ß√µes no reposit√≥rio.  Para rastrear o hist√≥rico de uma ramifica√ß√£o, voc√™ precisa ir de cada confirma√ß√£o usando o link de volta para a confirma√ß√£o pai. <br><br><h2>  Ag√™ncias Merjim </h2><br>  <b>Daniil Popov</b> : Existem duas maneiras de mesclar duas ramifica√ß√µes em uma - isso √© mesclar e refazer.  Como voc√™ os usa? <br><br>  <b>Egor Andreevich</b> : Cada m√©todo tem suas pr√≥prias vantagens e desvantagens.  <b>Mesclar</b> √© a op√ß√£o mais f√°cil.  Por exemplo, existem duas ramifica√ß√µes: mestre e o recurso selecionado. <br><br>  Para mesclar, voc√™ pode usar o avan√ßo r√°pido.  Isso √© poss√≠vel se, a partir do momento em que o trabalho foi iniciado na ramifica√ß√£o de recursos, nenhuma nova confirma√ß√£o foi feita no mestre.  Ou seja, o primeiro commit no recurso √© o √∫ltimo commit no master. <br><br>  Nesse caso, o ponteiro √© fixo na ramifica√ß√£o principal e passa para a confirma√ß√£o mais recente na ramifica√ß√£o do recurso.  Dessa forma, a ramifica√ß√£o √© eliminada conectando a ramifica√ß√£o do recurso ao encadeamento principal principal e removendo a ramifica√ß√£o desnecess√°ria.  Acontece uma hist√≥ria linear em que todos os commits se seguem.  Na pr√°tica, essa op√ß√£o acontece com pouca frequ√™ncia, porque constantemente algu√©m funde as confirma√ß√µes no mestre. <br><br>  Pode ser de outra forma.  O Git cria uma nova confirma√ß√£o de consolida√ß√£o - mesclagem, que possui dois links para consolida√ß√£o de pais: um no mestre e outro no recurso.  Com a nova confirma√ß√£o, duas ramifica√ß√µes s√£o conectadas e o recurso pode ser exclu√≠do novamente. <br><br>  Ap√≥s a consolida√ß√£o da mesclagem, voc√™ pode olhar para a hist√≥ria e ver se ela est√° bifurcada.  Se voc√™ usar uma ferramenta que renderiza graficamente as confirma√ß√µes, visualmente ela parecer√° uma √°rvore de Natal.  Isso n√£o quebra o Git, mas √© dif√≠cil para um desenvolvedor assistir a essa hist√≥ria. <br><br>  Outra ferramenta √© <b>rebase</b> .  Conceitualmente, voc√™ pega todas as altera√ß√µes da ramifica√ß√£o de recursos e as vira sobre a ramifica√ß√£o principal.  A primeira confirma√ß√£o de recurso se torna a nova confirma√ß√£o sobre a confirma√ß√£o principal mais recente. <br><br>  Existe um problema: o Git n√£o pode alterar confirma√ß√µes.  Havia um recurso de confirma√ß√£o e n√£o podemos envolv√™-lo no mestre, pois cada confirma√ß√£o tem um carimbo de data / hora. <br><br>  No caso de rebase, o Git l√™ todos os commits no recurso, o salva temporariamente e o recria na mesma ordem no master.  Ap√≥s a rebase, as confirma√ß√µes iniciais desaparecem e novas confirma√ß√µes com o mesmo conte√∫do aparecem na parte superior do mestre.  H√° problemas  Quando voc√™ tenta refazer uma ramifica√ß√£o com a qual outras pessoas trabalham, voc√™ pode interromper o reposit√≥rio.  Por exemplo, se algu√©m iniciou sua ramifica√ß√£o a partir de uma confirma√ß√£o que estava no recurso, e voc√™ destruiu e recriou essa confirma√ß√£o.  Rebase √© mais adequado para filiais locais. <br><br>  <b>Daniil Popov</b> : Se voc√™ introduzir restri√ß√µes de que apenas uma pessoa trabalha em uma ramifica√ß√£o de recursos, concorda que n√£o pode fazer amizade com uma ramifica√ß√£o de recursos de outra, ent√£o esse problema n√£o ocorre.  Mas que abordagem voc√™ pratica? <br><br>  <b>Egor Andreevich</b> : N√≥s n√£o usamos ramifica√ß√µes de recurso no sentido direto deste termo.  Toda vez que fazemos uma altera√ß√£o, crie um novo ramo, trabalhe nele e coloque-o imediatamente no mestre.  N√£o h√° ramifica√ß√µes de longa dura√ß√£o. <br><br>  Isso resolve um grande n√∫mero de problemas com mesclagem e rebase, especialmente conflitos.  As ramifica√ß√µes existem por uma hora e h√° uma alta probabilidade de avan√ßar rapidamente, pois ningu√©m adicionou nada a ser dominado.  Quando mesclamos na solicita√ß√£o pull, apenas mesclamos com a cria√ß√£o de confirma√ß√£o de mesclagem <br><br>  <b>Daniil Popov</b> : Como voc√™ n√£o tem medo de mesclar um recurso principal ocioso, porque decompor uma tarefa em intervalos de uma hora geralmente n√£o √© realista? <br><br>  <b>Egor Andreevich</b> : Usamos a abordagem de <b>sinalizadores de recursos</b> .  Esses s√£o sinalizadores din√¢micos, um recurso espec√≠fico com diferentes estados.  Por exemplo, a fun√ß√£o de enviar pagamentos um para o outro √© ativada ou desativada.  Temos um servi√ßo que entrega dinamicamente esse estado aos clientes.  Voc√™ do servidor obt√©m o recurso de valor ou n√£o.  Voc√™ pode usar esse valor no c√≥digo - desligue o bot√£o que vai para a tela.  O c√≥digo em si est√° no aplicativo e pode ser liberado, mas n√£o h√° acesso a essa funcionalidade, porque est√° atr√°s do sinalizador de recurso. <br><br>  <b>Daniil Popov</b> : Muitas vezes, os rec√©m-chegados ao Git s√£o informados de que, ap√≥s a reformula√ß√£o, voc√™ precisa pressionar com for√ßa.  De onde √©? <br><br>  <b>Egor Andreevich</b> : Quando voc√™ pressiona, outro reposit√≥rio pode gerar um erro: voc√™ est√° tentando iniciar uma ramifica√ß√£o, mas voc√™ tem confirma√ß√µes completamente diferentes nessa ramifica√ß√£o.  O Git verifica todas as informa√ß√µes para que voc√™ n√£o quebre o reposit√≥rio acidentalmente.  Quando voc√™ diz <b>git push force</b> , desative essa verifica√ß√£o, acreditando que voc√™ conhece melhor que ele, e exija reescrever o ramo. <br><br>  Por que isso √© necess√°rio ap√≥s o rebase?  Rebase recria confirma√ß√µes.  Acontece que o ramo tamb√©m √© chamado, mas confirma com outros hashes, e Git jura com voc√™.  Nessa situa√ß√£o, √© absolutamente normal fazer um empurr√£o for√ßado, pois voc√™ est√° no controle da situa√ß√£o. <br><br>  <b>Daniil Popov</b> : Ainda existe o conceito de <b>rebase interativa</b> , e muitos t√™m medo disso. <br><br>  <b>Egor Andreevich</b> : N√£o h√° nada terr√≠vel.  Devido ao fato de o Git recriar a hist√≥ria durante o rebase, ele a armazena temporariamente antes de lan√ß√°-la.  Quando possui armazenamento tempor√°rio, pode fazer qualquer coisa com confirma√ß√µes. <br><br>  Rebase no modo interativo pressup√µe que o Git before rebase lan√ßa uma janela de um editor de texto na qual voc√™ pode especificar o que precisa ser feito com cada confirma√ß√£o individual.  Parece v√°rias linhas de texto, em que cada linha √© um dos commits que est√£o na ramifica√ß√£o.  Antes de cada confirma√ß√£o, h√° uma indica√ß√£o da opera√ß√£o que vale a pena executar.  A opera√ß√£o padr√£o mais simples √© <b>escolher</b> , ou seja,  tomar e incluir na rebase.  O mais comum √© o <b>squash</b> , ent√£o o Git pegar√° as altera√ß√µes desse commit e o mesclar√° com as altera√ß√µes do anterior. <br><br>  Muitas vezes, existe esse cen√°rio.  Voc√™ trabalhou localmente em sua filial e criou confirma√ß√µes para salvar.  O resultado √© uma longa hist√≥ria de confirma√ß√µes, o que √© interessante para voc√™, mas da mesma forma n√£o deve ser despejada na hist√≥ria principal.  Ent√£o voc√™ d√° squash para renomear para o commit geral. <br><br>  A lista de equipes √© longa.  Voc√™ pode lan√ßar o commit - <b>drop</b> e desaparecer, alterar a mensagem de commit, etc. <br><br>  <b>Alexei Kudryavtsev</b> : Quando voc√™ tem conflitos em rebase interativa, passa por todos os c√≠rculos do inferno. <br><br>  <b>Egor Andreevich</b> : Estou muito longe de compreender toda a sabedoria do rebase interativo, mas √© uma ferramenta poderosa e complexa. <br><br><h2>  Aplica√ß√£o pr√°tica do Git </h2><br>  <b>Daniil Popov</b> : Vamos para a pr√°tica.  Na entrevista, muitas vezes pergunto: ‚ÄúVoc√™ tem mil commits.  No primeiro est√° tudo bem, no mil√©simo teste quebrado.  Como encontrar a mudan√ßa que levou a isso com a ajuda de um gita? <br><br>  <b>Egor Andreevich</b> : Nesta situa√ß√£o, voc√™ precisa usar a <b>bissetriz</b> , embora seja mais f√°cil culpar. <br><br>  Vamos come√ßar com o interessante.  O Git bisect √© aplic√°vel a uma situa√ß√£o em que voc√™ tem regress√£o - foi funcional, funcionou, mas parou subitamente.  Para descobrir quando a funcionalidade foi interrompida, teoricamente, voc√™ pode reverter aleatoriamente para a vers√£o anterior do aplicativo, ver o c√≥digo, mas existe uma ferramenta que permitir√° uma abordagem estruturada do problema. <br><br>  Git bisect √© uma ferramenta interativa.  Existe um comando git bisect bad atrav√©s do qual voc√™ relata a presen√ßa de um commit quebrado e o git bisect good - para um commit em funcionamento.  Cada vez que o aplicativo √© lan√ßado, lembramos do hash do commit a partir do qual o release foi feito.  Esse hash tamb√©m pode ser usado para indicar confirma√ß√µes ruins e boas.  O Bisect recebe informa√ß√µes sobre o intervalo em que um dos commits quebrou a funcionalidade e inicia uma sess√£o de <b>pesquisa bin√°ria</b> , onde gradualmente emite os commit para verificar se eles funcionam ou n√£o. <br><br>  Voc√™ iniciou a sess√£o, o Git muda para uma das confirma√ß√µes no intervalo, informa isso.  No caso de mil confirma√ß√µes, n√£o haver√° muitas itera√ß√µes. <br><br>  A verifica√ß√£o ter√° que ser feita manualmente: atrav√©s de testes de unidade ou execute o aplicativo e clique manualmente.  Git bisect √© convenientemente program√°vel.  Cada vez que ele emite um commit, voc√™ fornece a ele um script para verificar se o c√≥digo est√° funcionando. <br><br>  A culpa √© uma ferramenta mais simples que, com base em seu nome, permite encontrar o "culpado" de uma falha funcional.  Devido a essa defini√ß√£o negativa, muitos membros da comunidade de culpa n√£o gostam disso. <br><br>  O que ele esta fazendo?  Se voc√™ atribuir ao git culpado um arquivo espec√≠fico, ele linearmente neste arquivo mostrar√° qual confirma√ß√£o alterou esta ou aquela linha.  Eu nunca usei a culpa do git na linha de comando.  Como regra, isso √© feito no IDEA ou no Android Studio - clique e veja quem alterou qual linha do arquivo e em que confirma√ß√£o. <br><br>  <b>Daniil Popov</b> : A prop√≥sito, no Android Studio era chamado Annotate.  A conota√ß√£o negativa da culpa foi removida. <br><br>  <b>Alexei Kudryavtsev</b> : Exatamente, no xCode eles o renomearam Autores. <br><br>  <b>Egor Andreevich</b> : Eu tamb√©m li que h√° um elogio ao utilit√°rio git - para encontrar quem escreveu esse excelente c√≥digo. <br><br>  <b>Daniil Popov</b> : Note-se que, sob a culpa, as sugest√µes dos revisores sobre o trabalho de solicita√ß√£o de recebimento.  Ele olha quem tocou em um arquivo espec√≠fico, acima de tudo, e sugere que essa pessoa poder√° revisar bem seu c√≥digo. <br>  No caso do exemplo, cerca de mil confirma√ß√µes, a culpa em 99% dos casos mostrar√° o que deu errado.  Bisect j√° √© o √∫ltimo recurso. <br><br>  <b>Egor Andreevich</b> : Sim, eu uso bissectos muito raramente, mas uso anota√ß√µes regularmente.  Embora, √†s vezes, seja imposs√≠vel entender por que √© nulo verificado na linha de c√≥digo, fica claro em todo o commit o que o autor queria fazer. <br><br><h2>  Como trabalhar com PRs empilhados? </h2><br>  <b>Daniil Popov</b> : Ouvi dizer que o Square usa solicita√ß√µes de recebimento empilhado (PRs). <br><br>  <b>Egor Andreevich</b> : Pelo menos em nossa equipe de Android, costumamos us√°-los. <br>  Dedicamos muito tempo para facilitar a revis√£o de cada solicita√ß√£o pull.  √Äs vezes, h√° uma tenta√ß√£o de alimentar, alimentar rapidamente e deixar os revisores entenderem.  Tentamos criar pequenas solicita√ß√µes pull e uma breve descri√ß√£o - o c√≥digo deve falar por si.  Quando as solicita√ß√µes pull s√£o pequenas, √© f√°cil e r√°pido gritar. <br><br>  √â aqui que o problema surge.  Voc√™ est√° trabalhando em um recurso que exigir√° um grande n√∫mero de altera√ß√µes na base de c√≥digo.  O que voc√™ pode fazer?  Voc√™ pode coloc√°-lo em uma solicita√ß√£o pull, mas ser√° enorme.  Voc√™ pode trabalhar criando gradualmente uma solicita√ß√£o pull, mas o problema ser√° que voc√™ criou uma ramifica√ß√£o, adicionou algumas altera√ß√µes e enviou uma solicita√ß√£o pull, retornou ao mestre e o c√≥digo que voc√™ tinha na solicita√ß√£o pull n√£o estar√° dispon√≠vel no master at√© mesclagem n√£o vai acontecer.  Se voc√™ depende de altera√ß√µes nesses arquivos, √© dif√≠cil continuar trabalhando porque n√£o existe esse c√≥digo. <br><br>  Como contornar isso?  Depois de criarmos a primeira solicita√ß√£o pull, continuamos a trabalhar, crie uma nova ramifica√ß√£o a partir da ramifica√ß√£o existente, que usamos antes da solicita√ß√£o pull.  Cada ramifica√ß√£o n√£o vem do mestre, mas da ramifica√ß√£o anterior.  Quando terminarmos o trabalho nessa parte da funcionalidade, envie outra solicita√ß√£o de recebimento e indique novamente que, com a mesclagem, ela n√£o se mescla no mestre, mas na ramifica√ß√£o anterior.  Acontece uma cadeia de solicita√ß√µes pull - prs empilhados.  Quando uma pessoa revisa, ela v√™ as altera√ß√µes que foram feitas apenas por esse recurso, mas n√£o a anterior. <br><br>  A tarefa √© tornar cada solicita√ß√£o de recebimento o mais pequena e clara poss√≠vel, para que n√£o haja necessidade de altera√ß√£o.  Porque se voc√™ precisar alterar o c√≥digo nos ramos que est√£o no meio da pilha, tudo no topo ser√° interrompido, porque voc√™ precisar√° refazer a recupera√ß√£o.  Se as solicita√ß√µes pull s√£o pequenas, tentamos congel√°-las o mais r√°pido poss√≠vel, e todas as mesclagens empilhadas passo a passo no master. <br><br>  <b>Daniil Popov</b> : Entendo corretamente que, no final, haver√° uma √∫ltima solicita√ß√£o de recebimento que cont√©m todos os pedidos de recebimento pequenos.  Voc√™ derrama esse fio sem olhar? <br><br>  <b>Egor Andreevich</b> : A mesclagem vem da origem empilhada: primeiro, a primeira solicita√ß√£o pull √© mesclada no master, no pr√≥ximo, a base muda do ramo para o master e, consequentemente, o Git calcula que j√° existem algumas altera√ß√µes no master, menos snapshot. <br><br>  <b>Alexei Kudryavtsev</b> : Voc√™ tem condi√ß√µes de corrida quando o primeiro ramo j√° est√° congelado e somente depois o segundo parou no primeiro porque n√£o mudou o alvo para dominar? <br><br>  <b>Egor Andreevich</b> : <b>Seguramos</b> com a m√£o, ent√£o n√£o existem situa√ß√µes assim.  Abro uma solicita√ß√£o de recebimento, anote os colegas dos quais quero obter uma revis√£o e, quando estiverem prontos, vou ao bitbucket, pressione mesclar. <br><br>  <b>Alexei Kudryavtsev</b> : Mas e quanto √† verifica√ß√£o da CI de que nada est√° quebrado? <br><br>  <b>Egor Andreevich</b> : N√≥s n√£o fazemos isso.  O IC √© executado na ramifica√ß√£o, que √© a base para a solicita√ß√£o de recebimento e, ap√≥s a verifica√ß√£o, alteramos a base.  Tecnicamente, isso n√£o muda, pois voc√™ tamb√©m segmenta o n√∫mero de altera√ß√µes. <br><br>  <b>Daniil Popov</b> : Voc√™ vai direto ao mestre ou se desenvolve?  E quando voc√™ libera, indica explicitamente o commit do qual coletar? <br><br>  <b>Egor Andreevich</b> : N√£o temos desenvolvimento, apenas mestre.  Definitivamente lan√ßaremos a cada duas semanas.  Quando come√ßamos a preparar uma libera√ß√£o, abrimos uma ramifica√ß√£o de libera√ß√£o e algumas √∫ltimas corre√ß√µes v√£o para o mestre e para essa ramifica√ß√£o.  Usamos tags - links permanentes para um commit espec√≠fico, opcionalmente com algumas informa√ß√µes.  Se algum tipo de commit for um release, seria bom manter no hist√≥rico que fizemos um release a partir desse commit.  Uma tag √© criada, o Git salva as informa√ß√µes da vers√£o e voc√™ pode retornar posteriormente. <br><br>  <b>Alexei Kudryavtsev</b> : Onde ensinar Git, o que ler? <br><br>  <b>Egor Andreevich</b> : O Git tem um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livro oficial</a> .  Eu gosto do jeito que est√° escrito, h√° bons exemplos.  H√° um cap√≠tulo sobre o interior, voc√™ pode estud√°-lo completamente.  Voc√™ pode encontrar muitas situa√ß√µes e solu√ß√µes esot√©ricas no StackOverflow.  Eles tamb√©m podem ser usados. <br><br><blockquote>  N√£o falaremos sobre o Git no pr√≥ximo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saint AppsConf</a> .  Por outro lado, decidimos fazer um experimento e adicionamos relat√≥rios introdut√≥rios ao programa da confer√™ncia, em que palestrantes de ind√∫strias de desenvolvimento relacionadas compartilham conhecimento para expandir os horizontes de um desenvolvedor m√≥vel.  Aconselhamos que voc√™ preste aten√ß√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na apresenta√ß√£o de Nikolai Golov, da Avito, sobre bancos de dados</a> : como n√£o cometer um erro e escolher o banco de dados certo, como se preparar para o crescimento e o que √© relevante em 2019. <br><br>  O AppsCast √© lan√ßado a cada duas semanas √†s quartas-feiras e, se voc√™ preferir a vers√£o em √°udio √† vers√£o em texto, inscreva-se no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SoundCloud</a> , curta e discuta t√≥picos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em nosso bate-papo</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt468177/">https://habr.com/ru/post/pt468177/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt468163/index.html">Servidor Oracle VM para SPARC for Dummies (Instru√ß√µes)</a></li>
<li><a href="../pt468165/index.html">Como o navegador desenha. Relat√≥rio Yandex</a></li>
<li><a href="../pt468167/index.html">Viva e aprenda. Parte 4. Estudar enquanto trabalha?</a></li>
<li><a href="../pt468169/index.html">Hist√≥ria e heran√ßa do JQuery</a></li>
<li><a href="../pt468175/index.html">Blogs de desenvolvimento de front-end que vale a pena ler</a></li>
<li><a href="../pt468179/index.html">An√°lise: como funciona a infraestrutura do mercado de valores mobili√°rios russo</a></li>
<li><a href="../pt468181/index.html">Silent Trinity: explorando uma nova vers√£o da estrutura p√≥s-explora√ß√£o</a></li>
<li><a href="../pt468185/index.html">Servi√ßo AWS EC2 e trabalhe com ele</a></li>
<li><a href="../pt468189/index.html">Aumente as habilidades de depura√ß√£o de JavaScript usando truques de console</a></li>
<li><a href="../pt468191/index.html">RubyRussia 2019: Nikolay Sverchkov sobre sem servidor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>