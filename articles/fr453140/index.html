<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüè´ üè∞ üê∑ Qui vole le temps CPU virtuel? üë®‚Äçüë©‚Äçüëß üë©üèΩ ü§Ωüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut! Dans cet article, je veux expliquer, en termes simples, comment le vol appara√Æt dans les machines virtuelles et vous parler de certains des art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qui vole le temps CPU virtuel?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/453140/"><img src="https://habrastorage.org/getpro/habr/post_images/9d4/ede/bb8/9d4edebb8a0253cb1b973bd5df46a9a9.jpg"><br><br>  Salut!  Dans cet article, je veux expliquer, en termes simples, comment le <i>vol</i> appara√Æt dans les machines virtuelles et vous parler de certains des artefacts moins √©vidents que nous avons trouv√©s lors de recherches sur le sujet dans lequel j'√©tais impliqu√© en tant que CTO du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mail. com</a> Plateforme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cloud Solutions</a> .  La plateforme ex√©cute KVM. <br><a name="habracut"></a><br>  Le temps de vol du processeur est le temps pendant lequel une machine virtuelle ne re√ßoit pas les ressources n√©cessaires pour fonctionner.  Ce temps ne peut √™tre calcul√© que dans un syst√®me d'exploitation invit√© dans des environnements de virtualisation.  Il est extr√™mement difficile de savoir o√π les ressources allou√©es sont perdues, tout comme dans des situations r√©elles.  Cependant, nous avons d√©cid√© de le comprendre et nous avons m√™me effectu√© une s√©rie de tests pour le faire.  Cela ne veut pas dire que nous savons tout sur le <i>vol,</i> mais il y a des choses fascinantes que nous aimerions partager avec vous. <br><br><h2>  1. Qu'est-ce que <i>voler</i> ? </h2><br>  <i>Steal</i> est une m√©trique qui indique un manque de temps CPU pour les processus VM.  Comme d√©crit dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif du noyau KVM</a> , le <i>vol</i> est le temps qu'un hyperviseur passe √† ex√©cuter d'autres processus dans un syst√®me d'exploitation h√¥te, tandis que le processus VM est dans une file d'attente d'ex√©cution.  En d'autres termes, le <i>vol</i> est calcul√© comme la diff√©rence entre le moment o√π un processus est pr√™t √† s'ex√©cuter et le moment o√π le temps CPU est allou√© au processus. <br><br>  Le noyau VM obtient la m√©trique de <i>vol</i> de l'hyperviseur.  L'hyperviseur ne sp√©cifie pas les processus qu'il ex√©cute.  Il dit simplement: "Je suis occup√© et je ne peux pas vous accorder de temps."  Dans un KVM, le calcul de <i>vol</i> est pris en charge dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctifs</a> .  Il y a deux points principaux √† ce sujet: <br><br><ul><li>  Une machine virtuelle apprend √† <i>voler</i> de l'hyperviseur.  Cela signifie qu'en termes de pertes, le <i>vol</i> est une mesure indirecte qui peut √™tre d√©form√©e de plusieurs mani√®res. <br></li><li>  L'hyperviseur ne partage pas avec la machine virtuelle les informations sur ce qui la pr√©occupe.  Le point le plus crucial est qu'il ne lui accorde pas de temps.  La VM elle-m√™me, par cons√©quent, ne peut pas d√©tecter les distorsions dans la m√©trique de <i>vol</i> <i>,</i> qui pourraient √™tre estim√©es par la nature des processus concurrents. <br></li></ul><br><h2>  2. Qu'est-ce qui affecte le <i>vol</i> ? </h2><br><h4>  2.1.  Calcul du <i>vol</i> </h4><br>  Essentiellement, le <i>vol</i> est calcul√© plus ou moins de la m√™me mani√®re que le temps d'utilisation du processeur.  Il n'y a pas beaucoup d'informations sur la fa√ßon dont l'utilisation est calcul√©e.  C'est probablement parce que la plupart des professionnels pensent que c'est √©vident.  Cependant, il y a quelques pi√®ges.  Le processus est d√©crit dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de Brendann Gregg</a> .  Il discute d'une multitude de nuances concernant la fa√ßon de calculer l'utilisation et les sc√©narios dans lesquels le calcul sera erron√©: <br><br><ul><li>  Surchauffe et limitation du processeur. <br></li><li>  Activer / d√©sactiver Turbo Boost, entra√Ænant une modification de la fr√©quence d'horloge du processeur. </li><li>  Changement de tranche de temps qui se produit lorsque des technologies d'√©conomie d'√©nergie du processeur, par exemple SpeedStep, sont utilis√©es. <br></li><li>  Probl√®mes li√©s au calcul des moyennes: mesurer l'utilisation pendant une minute √† 80% de la puissance pourrait masquer un coup de pouce √† court terme de 100%. <br></li><li>  Un verrou tournant qui se traduit par un sc√©nario dans lequel le processeur est utilis√©, mais le processus utilisateur ne progresse pas.  Par cons√©quent, l'utilisation calcul√©e du processeur sera de 100%, mais le processus ne consommera pas r√©ellement de temps processeur. <br></li></ul><br>  Je n'ai trouv√© aucun article d√©crivant de tels calculs de <i>vol</i> (si vous en connaissez, veuillez les partager dans la section commentaires).  Comme vous pouvez le voir dans le code source, le m√©canisme de calcul est le m√™me que pour l'utilisation.  La seule diff√©rence est qu'un autre compteur est ajout√© sp√©cifiquement pour le processus KVM (processus VM), qui calcule la dur√©e pendant laquelle le processus KVM attend le temps CPU.  Le compteur prend les donn√©es sur le CPU √† partir de ses sp√©cifications et v√©rifie si tous ses ticks sont utilis√©s par le processus VM.  Si tous les ticks sont utilis√©s, alors le CPU n'√©tait occup√© que par le processus VM.  Sinon, nous savons que le CPU faisait autre chose et le <i>vol</i> appara√Æt. <br><br>  Le processus par lequel le <i>vol</i> est calcul√© est soumis aux m√™mes probl√®mes que le calcul r√©gulier de l'utilisation.  Ces probl√®mes ne sont pas si courants, mais ils peuvent sembler assez d√©routants. <br><br><h4>  2.2.  Types de virtualisation KVM </h4><br>  En g√©n√©ral, il existe trois types de virtualisation, et ils sont tous pris en charge par un KVM.  Le m√©canisme par lequel le <i>vol</i> se produit peut d√©pendre du type de virtualisation. <br><br>  La traduction  Dans ce cas, le VM OS fonctionnera avec les p√©riph√©riques d'hyperviseur physique de la mani√®re suivante: <br><br><ol><li>  L'OS invit√© envoie une commande √† son appareil invit√©. <br></li><li>  Le pilote de p√©riph√©rique invit√© accepte la commande, cr√©e une demande de p√©riph√©rique BIOS et envoie la commande √† l'hyperviseur. <br></li><li>  Le processus de l'hyperviseur traduit la commande en une commande de p√©riph√©rique physique, ce qui la rend plus s√©curis√©e, entre autres. <br></li><li>  Le pilote de p√©riph√©rique physique accepte la commande modifi√©e et la transmet au p√©riph√©rique physique lui-m√™me. <br></li><li>  Les r√©sultats d'ex√©cution de la commande retournent en suivant le m√™me chemin. <br></li></ol><br>  L'avantage de la traduction est qu'elle nous permet d'√©muler n'importe quel appareil et ne n√©cessite aucune pr√©paration sp√©ciale du noyau du syst√®me d'exploitation.  Mais cela se fait au d√©triment des performances. <br><br>  Virtualisation mat√©rielle.  Dans ce cas, un appareil re√ßoit des commandes du syst√®me d'exploitation au niveau mat√©riel.  C'est la m√©thode la plus rapide et la meilleure dans l'ensemble.  Malheureusement, tous les appareils physiques, hyperviseurs et syst√®mes d'exploitation invit√©s ne le prennent pas en charge.  Pour l'instant, les principaux appareils prenant en charge la virtualisation mat√©rielle sont les processeurs. <br><br>  Paravirtualisation.  L'option la plus courante pour la virtualisation de p√©riph√©riques sur un KVM et le type de virtualisation le plus r√©pandu pour les syst√®mes d'exploitation invit√©s.  Sa principale caract√©ristique est qu'il fonctionne avec certains sous-syst√®mes d'hyperviseur (par exemple, r√©seau ou pile de lecteurs) et alloue des pages de m√©moire √† l'aide d'une API d'hyperviseur sans traduire les commandes de bas niveau.  L'inconv√©nient de cette m√©thode de virtualisation est la n√©cessit√© de modifier le noyau du syst√®me d'exploitation invit√© pour permettre l'interaction avec l'hyperviseur √† l'aide de la m√™me API.  La solution la plus courante √† ce probl√®me consiste √† installer des pilotes sp√©ciaux dans le syst√®me d'exploitation invit√©.  Dans un KVM, cette API est appel√©e une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API virtio</a> . <br><br>  Lorsque la paravirtualisation est utilis√©e, le chemin vers le p√©riph√©rique physique est beaucoup plus court que dans les cas o√π la traduction est utilis√©e, car les commandes sont envoy√©es directement de la machine virtuelle au processus d'hyperviseur de l'h√¥te.  Cela acc√©l√®re l'ex√©cution de toutes les instructions au sein de la machine virtuelle.  Dans un KVM, une API virtio en est responsable.  Cela ne fonctionne que pour certains appareils comme le r√©seau et les adaptateurs de lecteur.  C'est pourquoi les pilotes virtio sont install√©s sur les machines virtuelles. <br><br>  Le revers d'une telle acc√©l√©ration est que tous les processus ex√©cut√©s dans une machine virtuelle ne restent pas dans la machine virtuelle.  Il en r√©sulte un certain nombre d'effets, qui peuvent provoquer un <i>vol</i> .  Si vous souhaitez en savoir plus, commencez par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une API pour les E / S virtuelles: virtio</a> . <br><br><h4>  2.3.  Planification √©quitable </h4><br>  Une VM sur un hyperviseur est, en fait, un processus r√©gulier, qui est soumis √† des lois d'ordonnancement (r√©partition des ressources entre les processus) dans un noyau Linux.  Examinons cela de plus pr√®s. <br><br>  Linux utilise le soi-disant CFS, Completely Fair Scheduler, qui est devenu la valeur par d√©faut avec le noyau 2.6.23.  Pour vous familiariser avec cet algorithme, lisez Architecture du noyau Linux ou le code source.  L'essence de CFS r√©side dans la r√©partition du temps CPU entre les processus, en fonction de leur temps d'ex√©cution.  Plus un processus n√©cessite de temps CPU, moins il obtient de temps CPU.  Cela garantit l'ex√©cution ¬´√©quitable¬ª de tous les processus et permet d'√©viter qu'un processus ne prenne tout le temps tous les processeurs et permette √† d'autres processus de s'ex√©cuter √©galement. <br><br>  Parfois, ce paradigme se traduit par des artefacts int√©ressants.  Les utilisateurs de longue date de Linux se souviendront sans aucun doute de la fa√ßon dont un √©diteur de texte normal sur le bureau se figerait lors de l'ex√©cution d'applications gourmandes en ressources comme un compilateur.  Cela est d√ª au fait que les t√¢ches all√©g√©es en ressources, telles que les applications de bureau, √©taient en concurrence avec des t√¢ches utilisant de nombreuses ressources, comme un compilateur.  CFS consid√®re que cela est injuste et arr√™te donc l'√©diteur de texte de temps en temps et laisse le processeur traiter les t√¢ches du compilateur.  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me a</a> √©t√© r√©solu √† l'aide du m√©canisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sched_autogroup</a> ;  il existe cependant de nombreuses autres particularit√©s de la distribution du temps CPU.  Cet article ne traite pas vraiment de la gravit√© du SFC.  C'est plut√¥t une tentative pour attirer l'attention sur le fait que la distribution "√©quitable" du temps CPU n'est pas la t√¢che la plus triviale. <br><br>  Un autre aspect important d'un planificateur est la pr√©emption.  Cela est n√©cessaire pour d√©barrasser le processeur de tous les processus exag√©r√©s et permettre aux autres de fonctionner √©galement.  C'est ce qu'on appelle le <i>changement de contexte</i> .  L'ensemble du contexte de t√¢che est conserv√©: √©tat de la pile, registres, etc., apr√®s quoi le processus est laiss√© en attente et est remplac√© par un autre processus.  Il s'agit d'une op√©ration co√ªteuse pour un syst√®me d'exploitation.  Il est rarement utilis√©, mais ce n'est pas mal du tout.  Un changement de contexte fr√©quent peut √™tre un indicateur d'un probl√®me de syst√®me d'exploitation, mais il se produit g√©n√©ralement en continu et n'est pas le signe d'un probl√®me en particulier. <br><br>  Ce long discours √©tait n√©cessaire pour expliquer un fait: dans un ordonnanceur Linux √©quitable, plus le processus consomme de ressources CPU, plus il sera arr√™t√© rapidement pour permettre √† d'autres processus de fonctionner.  Que ce soit correct ou non est une question complexe, et la solution est diff√©rente selon la charge.  Jusqu'√† r√©cemment, le planificateur Windows donnait la priorit√© aux applications de bureau, ce qui ralentissait les processus d'arri√®re-plan.  Dans Sun Solaris, il y avait cinq classes d'ordonnanceur diff√©rentes.  Lorsque la virtualisation a √©t√© introduite, ils en ont ajout√© un autre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fair share scheduler</a> , car les autres ne fonctionnaient pas correctement avec la virtualisation Solaris Zones.  Pour approfondir cela, je recommande de commencer avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solaris Internals: Solaris 10 et OpenSolaris Kernel Architecture</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comprendre le noyau Linux</a> . <br><br><h4>  2.4.  Comment surveiller le <i>vol</i> ? </h4><br>  Comme pour toute autre mesure du processeur, il est facile de surveiller le <i>vol</i> dans une machine virtuelle.  Vous pouvez utiliser n'importe quel outil de mesure m√©trique CPU.  L'essentiel est que la VM doit √™tre sous Linux.  Pour une raison quelconque, Windows ne fournit pas ces informations √† l'utilisateur.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/9f8/5b1/fff9f85b10523ddaecfc176f1fa18f33.png"><br>  <i>sortie sup√©rieure: sp√©cification de la charge du processeur avec vol dans la colonne de droite</i> <br><br>  Les choses se compliquent lorsqu'on essaie d'obtenir ces informations d'un hyperviseur.  Vous pouvez essayer de pr√©voir le <i>vol</i> sur une machine h√¥te, en utilisant Load Average (LA), par exemple.  Il s'agit de la valeur moyenne du nombre de processus dans la file d'attente d'ex√©cution.  La m√©thode de calcul de ce param√®tre n'est pas simple, mais en g√©n√©ral, si un LA normalis√© en fonction du nombre de threads CPU est sup√©rieur √† 1, cela signifie que le serveur Linux est surcharg√©. <br><br>  Alors, qu'attendent tous ces processus?  De toute √©vidence, le CPU.  Cette r√©ponse n'est cependant pas tout √† fait exacte, car parfois le CPU est libre et le LA est beaucoup trop √©lev√©.  N'oubliez pas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">que NFS tombe et LA augmente en m√™me temps</a> .  Une situation similaire peut se produire avec le lecteur et d'autres p√©riph√©riques d'entr√©e / sortie.  En fait, les processus peuvent attendre la fin d'un verrou: physique (li√© aux p√©riph√©riques d'entr√©e / sortie) ou logique (un objet mutex, par exemple).  Il en va de m√™me pour les verrous de niveau mat√©riel (par exemple, la r√©ponse du disque) ou les verrous de niveau logique (appel√©s "primitives de verrouillage", qui comprennent un certain nombre d'entit√©s, mutex adaptatif et spin, s√©maphores, variables de condition, verrous rw, verrous ipc ...). <br><br>  Une autre caract√©ristique de LA est qu'elle est calcul√©e comme une valeur moyenne dans le syst√®me d'exploitation.  Par exemple, si 100 processus sont en concurrence pour un fichier, le LA est 50. Ce grand nombre peut donner l'impression que c'est mauvais pour le syst√®me d'exploitation.  Cependant, pour un code mal √©crit, cela peut √™tre normal.  Seul ce code sp√©cifique serait mauvais et le reste du syst√®me d'exploitation pourrait convenir. <br><br>  En raison de cette moyenne (pendant moins d'une minute), d√©terminer quoi que ce soit √† l'aide d'un LA n'est pas la meilleure id√©e, car cela peut donner des r√©sultats extr√™mement ambigus dans certains cas.  Si vous essayez d'en savoir plus √† ce sujet, vous constaterez que Wikipedia et d'autres ressources disponibles ne d√©crivent que les cas les plus simples, et le processus n'est pas d√©crit en d√©tail.  Si cela vous int√©resse, visitez √† nouveau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Brendann Gregg</a> et suivez les liens. <br><br><h2>  3. Effets sp√©ciaux </h2><br>  Passons maintenant aux principaux cas de <i>vol</i> que nous avons rencontr√©s.  Permettez-moi d'expliquer comment ils r√©sultent de ce qui pr√©c√®de et comment ils sont en corr√©lation avec les mesures de l'hyperviseur. <br><br>  Surutilisation.  Le cas le plus simple et le plus courant: l'hyperviseur est surutilis√©.  En effet, avec de nombreuses machines virtuelles en cours d'ex√©cution et consommant beaucoup de ressources CPU, la concurrence est √©lev√©e et l'utilisation selon la LA est sup√©rieure √† 1 (normalis√©e selon les threads CPU).  Tout est en retard dans toutes les machines virtuelles.  <i>Le vol</i> envoy√© par l'hyperviseur se d√©veloppe √©galement.  Vous devez redistribuer la charge ou √©teindre quelque chose.  Dans l'ensemble, tout cela est logique et simple. <br><br>  Paravirtualisation vs instances uniques.  Il n'y a qu'une seule machine virtuelle sur un hyperviseur.  La machine virtuelle en consomme une petite partie, mais fournit une charge d'entr√©e / sortie √©lev√©e, par exemple, pour un lecteur.  De fa√ßon inattendue, un petit <i>vol</i> de moins de 10% appara√Æt (comme le montrent certains des tests que nous avons effectu√©s). <br><br>  Ceci est un cas curieux.  Ici, le <i>vol</i> appara√Æt √† cause des verrous au niveau des appareils paravirtualis√©s.  √Ä l'int√©rieur de la machine virtuelle, un point d'arr√™t est cr√©√©.  Ceci est trait√© par le pilote et va √† l'hyperviseur.  En raison du traitement des points d'arr√™t sur l'hyperviseur, la machine virtuelle consid√®re cela comme une demande envoy√©e.  Il est pr√™t √† fonctionner et attend le CPU, mais ne re√ßoit pas de temps CPU.  La VM pense que le temps a √©t√© vol√©. <br><br>  Cela se produit lorsque le tampon est envoy√©.  Il va dans l'espace noyau de l'hyperviseur et nous l'attendons.  Du point de vue de la VM, elle devrait revenir imm√©diatement.  Par cons√©quent, selon notre algorithme de calcul de <i>vol</i> , ce temps est consid√©r√© comme vol√©.  Il est probable que d'autres m√©canismes soient impliqu√©s dans cela (par exemple le traitement d'autres <i>appels syst√®me</i> ), mais ils ne devraient pas diff√©rer de mani√®re significative. <br><br>  Planificateur vs machines virtuelles tr√®s charg√©es.  Lorsqu'une machine virtuelle souffre de <i>voler</i> plus que les autres, cela est directement connect√© au planificateur.  Plus la charge qu'un processus met sur un processeur est importante, plus un ordonnanceur le rejettera rapidement, afin de permettre aux autres processus de fonctionner.  Si la machine virtuelle consomme peu, elle ne subira presque aucun <i>vol.</i>  Son processus vient d‚Äô√™tre assis et d‚Äôattendre, et il lui faut plus de temps.  Si la machine virtuelle met une charge maximale sur tous les c≈ìurs, le processus est jet√© plus souvent et la machine virtuelle dispose de moins de temps. <br><br>  C'est encore pire lorsque les processus au sein de la machine virtuelle essaient d'obtenir plus de CPU, car ils ne peuvent pas traiter les donn√©es.  Ensuite, le syst√®me d'exploitation sur l'hyperviseur fournira moins de temps processeur en raison de l'optimisation √©quitable.  Ce processus fait boule de neige et <i>vole des</i> mont√©es en fl√®che, tandis que d'autres machines virtuelles peuvent m√™me ne pas le remarquer.  Plus il y a de c≈ìurs, pire c'est pour la malheureuse VM.  En bref, les machines virtuelles tr√®s charg√©es avec de nombreux c≈ìurs souffrent le plus. <br><br>  Faible LA mais le <i>vol</i> est pr√©sent.  Si la LA est d'environ 0,7 (ce qui signifie que l'hyperviseur semble sous-charg√©), mais il y a du <i>vol</i> dans certaines machines virtuelles: <br><br><ul><li>  L'exemple de paravirtualisation susmentionn√© s'applique.  La machine virtuelle peut recevoir des m√©triques qui indiquent un <i>vol</i> , tandis que l'hyperviseur n'a aucun probl√®me.  Selon les r√©sultats de nos tests, un tel <i>vol</i> ne d√©passe g√©n√©ralement pas 10% et n'a pas d'impact significatif sur les performances des applications au sein de la machine virtuelle. <br></li><li>  Le param√®tre LA a √©t√© calcul√© incorrectement.  Plus pr√©cis√©ment, il a √©t√© calcul√© correctement √† un moment pr√©cis, mais lors de la moyenne, il est inf√©rieur √† ce qu'il devrait √™tre pendant une minute.  Par exemple, si une VM (un tiers de l'hyperviseur) consomme tous les processeurs pendant 30 secondes, la LA pendant une minute sera de 0,15.  Quatre de ces machines virtuelles, fonctionnant en m√™me temps, donneront une valeur de 0,6.  Sur la base du LA, vous ne pourriez pas d√©duire que pendant 30 secondes pour chacun d'eux, le <i>vol</i> √©tait de pr√®s de 25%. <br></li><li>  Encore une fois, cela s'est produit √† cause de l'ordonnanceur, qui a d√©cid√© que quelqu'un ¬´mangeait¬ª trop et les a fait attendre.  Pendant ce temps, il changera de contexte, traitera les points d'arr√™t et s'occupera d'autres questions importantes du syst√®me.  Par cons√©quent, certaines machines virtuelles ne rencontrent aucun probl√®me et d'autres souffrent de pertes de performances importantes. <br></li></ul><br><h2>  4. Autres distorsions </h2><br>  Il existe un million de raisons possibles pour la distorsion de l'allocation √©quitable du temps CPU sur une machine virtuelle.  Par exemple, l'hyperthreading et NUMA ajoutent de la complexit√© aux calculs.  Ils compliquent le choix du c≈ìur utilis√© pour ex√©cuter un processus car un ordonnanceur utilise des coefficients;  c'est-√†-dire les poids, qui compliquent encore plus les calculs lors des changements de contextes. <br><br>  Il existe des distorsions dues √† des technologies telles que Turbo Boost ou son mode d'√©conomie d'√©nergie oppos√©, qui pourraient augmenter ou diminuer artificiellement la vitesse du c≈ìur du processeur et m√™me la tranche de temps.  L'activation de Turbo Boost diminue la productivit√© d'un thread CPU en raison d'une augmentation des performances dans un autre.  √Ä ce moment, les informations concernant la vitesse d'horloge actuelle du processeur ne sont pas envoy√©es √† la machine virtuelle, qui pense que quelqu'un vole son temps (par exemple, il a demand√© 2 GHz et a obtenu la moiti√© du temps). <br><br>  En fait, il peut y avoir plusieurs raisons √† la distorsion.  Vous pouvez trouver autre chose enti√®rement dans un syst√®me donn√©.  Je recommande de commencer par les livres li√©s ci-dessus et d'obtenir des statistiques de l'hyperviseur en utilisant des outils tels que perf, sysdig, systemtap et des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dizaines d'autres</a> . <br><br><h2>  5. Conclusions </h2><br><ol><li>  Certains <i>vols</i> peuvent appara√Ætre en raison de la paravirtualisation et cela peut √™tre consid√©r√© comme normal.  Des sources en ligne affirment que cette valeur peut √™tre de 5 √† 10%.  Cela d√©pend de l'application dans une machine virtuelle et de la charge que la machine virtuelle place sur ses p√©riph√©riques physiques.  Il est important de faire attention √† la fa√ßon dont les applications se sentent √† l'int√©rieur d'une machine virtuelle. <br></li><li>  La corr√©lation entre la charge sur l'hyperviseur et le <i>vol</i> au sein d'une machine virtuelle n'est pas toujours certaine.  Les deux calculs de <i>vol</i> peuvent √™tre erron√©s dans certains cas et avec des charges diff√©rentes. <br></li><li>  Le planificateur ne favorise pas les processus qui demandent beaucoup de ressources.  Il essaie de donner moins √† ceux qui en demandent plus.  Les grandes instances sont m√©chantes. <br></li><li>  Un petit <i>vol</i> peut √©galement √™tre normal sans paravirtualisation (en tenant compte de la charge au sein de la machine virtuelle, des particularit√©s des charges des voisins, de la r√©partition de la charge entre les threads et d'autres facteurs). <br></li><li>  Si vous souhaitez calculer le <i>vol</i> dans un syst√®me particulier, recherchez les diff√©rentes possibilit√©s, rassemblez des m√©triques, analysez-les soigneusement et r√©fl√©chissez √† la fa√ßon de r√©partir la charge √©quitablement.  Quoi qu'il en soit, il peut y avoir des √©carts, qui doivent √™tre v√©rifi√©s √† l'aide de tests ou les afficher dans un d√©bogueur du noyau. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453140/">https://habr.com/ru/post/fr453140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453126/index.html">UIAappearance n'√©tait pas si simple</a></li>
<li><a href="../fr453128/index.html">Telecom digest: 15 documents d'experts sur IPv6, SI, normes et l√©gislation en informatique</a></li>
<li><a href="../fr453130/index.html">Codes correctifs syst√©matiques. Code de groupe lin√©aire</a></li>
<li><a href="../fr453136/index.html">API √©crite - XML ‚Äã‚Äãcass√© (deux)</a></li>
<li><a href="../fr453138/index.html">Art et science: projet VITAE - nombreuses empreintes de palmier sur une fleur de lune</a></li>
<li><a href="../fr453146/index.html">Comment tirer le meilleur parti d'une conf√©rence</a></li>
<li><a href="../fr453154/index.html">Histoire d'Internet: am√©liorer l'interactivit√©</a></li>
<li><a href="../fr453156/index.html">General Motors donnera une √¢me √† toutes ses nouvelles voitures (coque num√©rique)</a></li>
<li><a href="../fr453158/index.html">Je ne savais pas comment fonctionnaient les processeurs, alors j'ai √©crit un simulateur de logiciel</a></li>
<li><a href="../fr453162/index.html">Antiquit√©s: ThinkPad 380E, classe √©conomique des ann√©es 90 et Windows 95</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>