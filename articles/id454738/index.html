<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïò üö∂üèæ üôãüèª Dukungan Visual Studio 2019 dalam PVS-Studio üë©‚Äç‚ù§Ô∏è‚Äçüë© üë®üèª‚Äç‚öñÔ∏è ‚õµÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dukungan untuk Visual Studio 2019 dalam PVS-Studio segera mempengaruhi beberapa komponen yang berbeda: plug-in IDE itu sendiri, aplikasi analisis bari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dukungan Visual Studio 2019 dalam PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/454738/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de3/aea/16e/de3aea16e3b6472a4d5034fd035d8827.png"></div><br>  Dukungan untuk Visual Studio 2019 dalam PVS-Studio segera mempengaruhi beberapa komponen yang berbeda: plug-in IDE itu sendiri, aplikasi analisis baris perintah, C ++ dan C # analisis, serta beberapa utilitas.  Saya akan berbicara secara singkat tentang masalah apa yang kami temui dalam mendukung versi baru IDE dan bagaimana menyelesaikannya. <br><a name="habracut"></a><br>  Sebelum Anda mulai, saya ingin melihat ke belakang sedikit untuk menelusuri sejarah dukungan untuk versi Visual Studio sebelumnya, yang akan memberikan pemahaman yang lebih baik tentang visi tugas dan keputusan yang dibuat dalam situasi tertentu. <br><br>  Dimulai dengan versi pertama PVS-Studio analyzer, di mana plug-in untuk lingkungan Visual Studio muncul (kemudian itu juga versi Visual Studio 2005), mendukung versi baru Visual Studio adalah tugas yang cukup sederhana bagi kami - itu pada dasarnya bermula untuk memperbarui file proyek plug-in dan dependensi dari berbagai API ekstensi Visual Studio.  Kadang-kadang perlu juga mendukung fitur-fitur baru dari bahasa C ++, yang secara bertahap dipelajari oleh kompiler Visual C ++, tetapi ini juga biasanya tidak menimbulkan masalah segera sebelum rilis Visual Studio edisi berikutnya.  Dan hanya ada satu analisa di PVS-Studio saat itu - untuk bahasa C dan C ++. <br><br>  Semuanya berubah untuk rilis Visual Studio 2017. Selain fakta bahwa banyak ekstensi API untuk IDE ini berubah sangat signifikan dalam versi ini, setelah pembaruan kami mengalami masalah memastikan kompatibilitas mundur pekerjaan penganalisis C # baru yang telah muncul pada waktu itu (serta lapisan C ++ baru kami) analyzer untuk proyek MSBuild) dengan versi yang lebih lama dari MSBuild \ Visual Studio. <br><br>  Oleh karena itu, sebelum membaca artikel ini, saya sangat menyarankan Anda membaca artikel terkait tentang dukungan Visual Studio 2017: "dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visual Studio 2017 dan Roslyn 2.0 di PVS-Studio: kadang-kadang menggunakan solusi siap pakai tidak semudah kelihatannya pada pandangan pertama</a> ."  Artikel yang disebutkan di atas menjelaskan masalah yang kami temui terakhir kali, serta skema interaksi berbagai komponen (misalnya, PVS-Studio, MSBuild, Roslyn).  Memahami interaksi ini akan sangat membantu saat membaca artikel ini. <br><br>  Pada akhirnya, solusi untuk masalah ini membawa perubahan signifikan pada penganalisa kami, dan, seperti yang kami harapkan, pendekatan baru yang kami terapkan kemudian akan memungkinkan untuk mendukung versi terbaru dari Visual Studio \ MSBuild jauh lebih mudah dan lebih cepat di masa depan.  Sebagian, asumsi ini telah dikonfirmasi oleh rilis berbagai pembaruan untuk Visual Studio 2017. Apakah pendekatan baru ini membantu dengan dukungan Visual Studio 2019?  Tentang itu di bawah ini. <br><br><h2>  Plugin PVS-Studio untuk Visual Studio 2019 </h2><br>  Semuanya dimulai, sepertinya, tidak buruk.  Cukup mudah untuk port plug-in ke Visual Studio 2019, di mana ia mulai dan bekerja dengan baik.  Meskipun demikian, 2 masalah segera terungkap, yang menjanjikan masalah di masa depan. <br><br>  Yang pertama adalah antarmuka <i>IVsSolutionWorkspaceService</i> , yang digunakan untuk mendukung mode Beban Solusi Ringan, yang, dengan cara, dinonaktifkan di salah satu pembaruan sebelumnya di Visual Studio 2017, dihiasi dengan atribut <i>Deprecated</i> , yang hanya merupakan peringatan selama perakitan, tetapi menjanjikan lebih banyak di masa depan masalah.  Microsoft dengan cepat memperkenalkan mode ini dan mengabaikannya ... Kami menangani masalah ini cukup sederhana - menolak untuk menggunakan antarmuka yang sesuai. <br><br>  Yang kedua - saat memuat Visual Studio dengan plugin, pesan berikut muncul: <i>Visual Studio telah mendeteksi satu atau lebih ekstensi yang berisiko atau tidak berfungsi dalam pembaruan fitur VS.</i> <br><br>  Melihat log startup Visual Studio (file ActivityLog) akhirnya bertitik 'i': <br><br>  <i>Peringatan: Ekstensi 'PVS-Studio' menggunakan fitur 'auto-load sinkron' dari Visual Studio.</i>  <i>Fitur ini tidak lagi didukung dalam pembaruan Visual Studio 2019 di masa depan, di mana ekstensi ini tidak akan berfungsi.</i>  <i>Silakan hubungi vendor ekstensi untuk mendapatkan pembaruan.</i> <br><br>  Bagi kami, ini berarti satu hal - mengubah cara plug-in dimuat ke mode asinkron.  Saya harap Anda tidak akan kecewa jika saya tidak membebani Anda dengan detail tentang berinteraksi dengan antarmuka COM dari Visual Studio, dan saya akan melalui perubahan cukup singkat. <br><br>  Microsoft memiliki artikel tentang cara membuat plugin yang tidak sinkron: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara: Gunakan AsyncPackage untuk memuat VSPackages di latar belakang</a> ".  Pada saat yang sama, jelas bagi semua orang bahwa masalah ini tidak akan terbatas pada perubahan ini. <br><br>  Salah satu perubahan utama adalah metode memuat, atau lebih tepatnya, inisialisasi.  Sebelumnya, inisialisasi yang diperlukan terjadi dalam dua metode - metode <i>inisialisasi inisialisasi</i> kelas <i>inheritance</i> <i>Paket</i> kami <i>,</i> dan metode <i>OnShellPropertyChange</i> .  Kebutuhan untuk mentransfer bagian dari logika ke metode <i>OnShellPropertyChange</i> disebabkan oleh kenyataan bahwa ketika plug-in dimuat secara sinkron, Visual Studio mungkin belum dimuat dan diinisialisasi penuh, dan sebagai akibatnya, tidak semua tindakan yang diperlukan dapat dilakukan pada tahap inisialisasi plug-in.  Pilihan untuk menyelesaikan masalah ini adalah menunggu Visual Studio keluar dari status 'zombie' dan menunda tindakan ini.  Ini adalah logikanya dan telah diterjemahkan di <i>OnShellPropertyChange</i> dengan cek status 'zombie'. <br><br>  Dalam kelas <i>AsyncPackage</i> abstrak, dari mana plugin yang dimuat secara asinkron diwariskan, metode <i>Initialize</i> memiliki pengubah <i>disegel</i> , jadi inisialisasi harus dilakukan dalam metode <i>InitializeAsync yang</i> ditimpa, yang telah dilakukan.  Kami juga harus mengubah logika dengan melacak keadaan 'zombie' dari Visual Studio, karena kami berhenti menerima informasi ini di plugin.  Namun, sejumlah tindakan yang perlu dilakukan setelah plugin diinisialisasi tidak hilang.  <i>Solusinya</i> adalah dengan menggunakan metode <i>OnPackageLoaded</i> dari antarmuka <i>IVsPackageLoadEvents</i> , di mana tindakan yang membutuhkan eksekusi ditangguhkan dilakukan. <br><br>  Masalah lain yang secara logis muncul dari fakta asynchronous loading plugin adalah tidak adanya perintah plugin PVS-Studio pada saat memulai Visual Studio.  Ketika Anda membuka log analyzer dengan mengklik dua kali dari manajer file (jika Anda perlu membukanya melalui Visual Studio), versi devenv.exe yang diperlukan diluncurkan dengan perintah untuk membuka laporan analyzer.  Perintah peluncuran terlihat seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\Common7\IDE\devenv.exe"</span></span> /command <span class="hljs-string"><span class="hljs-string">"PVSStudio.OpenAnalysisReport C:\Users\vasiliev\source\repos\ConsoleApp\ConsoleApp.plog"</span></span></code> </pre> <br>  Bendera "/ command" di sini digunakan untuk menjalankan perintah yang terdaftar di Visual Studio.  Sekarang pendekatan ini tidak berfungsi, karena perintah tidak tersedia sampai plug-in diunduh.  Akibatnya, saya harus berhenti di "kruk" dengan menguraikan garis peluncuran devenv.exe setelah memuat plugin, dan jika ada representasi string dari perintah untuk membuka log - pada kenyataannya, memuat log.  Jadi, dalam hal ini, setelah menolak untuk menggunakan antarmuka "benar" untuk bekerja dengan perintah, dimungkinkan untuk mempertahankan fungsionalitas yang diperlukan dengan menunda pemuatan log hingga plug-in dimuat sepenuhnya. <br><br>  Fuh, tampaknya akan beres dan semuanya berfungsi - semuanya memuat dan terbuka dengan benar, tidak ada peringatan - akhirnya. <br><br>  Dan kemudian hal yang tidak terduga terjadi - Pavel (halo!) Menginstal plug-in, setelah itu dia bertanya mengapa kami tidak melakukan loading asinkron? <br><br>  Untuk mengatakan bahwa kami terkejut - untuk tidak mengatakan apa-apa - bagaimana bisa begitu?  Tidak, sungguh - ini adalah versi baru dari plugin yang diinstal, ini adalah pesan bahwa paket tersebut dapat diunduh secara sinkron.  Kami memasang dengan Alexander (dan menyapa Anda juga) versi plugin yang sama pada mesin kami - semuanya baik-baik saja.  Tidak ada yang jelas - kami memutuskan untuk melihat versi perpustakaan PVS-Studio mana yang dimuat dalam Visual Studio.  Dan tiba-tiba ternyata versi pustaka PVS-Studio untuk Visual Studio 2017 digunakan, meskipun faktanya versi pustaka yang benar ada dalam paket VSIX - untuk Visual Studio 2019. <br><br>  Setelah bermain-main dengan VSIXInstaller, saya berhasil menemukan penyebab masalah - cache paket.  Teori ini juga dikonfirmasi oleh fakta bahwa ketika membatasi hak akses ke paket dalam cache (C: \ ProgramData \ Microsoft \ VisualStudio \ Packages) VSIXInstaller menulis informasi kesalahan ke log.  Anehnya, jika tidak ada kesalahan, tidak ada informasi tentang fakta bahwa paket diinstal dari cache tidak ditulis ke log. <br><br>  <b>Catatan</b>  Mempelajari perilaku VSIXInstaller dan perpustakaan terkait, ia mencatat pada dirinya sendiri bahwa sangat keren bahwa Roslyn dan MSBuild memiliki kode sumber terbuka yang membuatnya mudah untuk membaca, men-debug dan melacak logika kerja. <br><br>  Akibatnya, hal berikut terjadi - ketika menginstal plugin, VSIXInstaller melihat bahwa paket yang sesuai sudah ada dalam cache (ada paket .vsix untuk Visual Studio 2017), dan menggunakannya sebagai pengganti paket yang diinstal sebenarnya saat instalasi.  Mengapa ini tidak memperhitungkan pembatasan / persyaratan yang dijelaskan dalam .vsixmanifest (misalnya, versi Visual Studio yang Anda dapat menginstal ekstensi) adalah pertanyaan terbuka.  Karena itu, ternyata meskipun .vsixmanifest berisi pembatasan yang diperlukan, plugin yang dirancang untuk Visual Studio 2017 diinstal pada Visual Studio 2019. <br><br>  Yang terburuk adalah instalasi seperti itu memecah grafik ketergantungan Visual Studio, dan meskipun secara lahiriah bahkan kelihatannya lingkungan pengembangan berfungsi dengan baik, pada kenyataannya semuanya sangat buruk.  Mustahil untuk menginstal dan menghapus instalan ekstensi, membuat pembaruan, dan sebagainya.  Proses 'pemulihan' juga agak tidak menyenangkan, karena  itu perlu untuk menghapus ekstensi (file yang sesuai), serta secara manual mengedit file konfigurasi yang menyimpan informasi tentang paket yang diinstal.  Secara umum - itu tidak cukup menyenangkan. <br><br>  Untuk mengatasi masalah ini dan menghindari situasi serupa di masa mendatang, diputuskan untuk membuat GUID untuk paket baru untuk memisahkan paket Visual Studio 2017 dan Visual Studio 2019 dengan tepat (tidak ada masalah dengan paket yang lebih lama, dan mereka selalu menggunakan GUID yang sama). <br><br>  Dan karena kami berbicara tentang kejutan yang tidak menyenangkan, saya akan menyebutkan satu hal lagi - setelah memperbarui ke Pratinjau 2, item menu 'dipindahkan' di bawah tab 'Ekstensi'.  Tampaknya tidak apa-apa, tetapi akses ke fungsi plugin menjadi kurang nyaman.  Pada versi Visual Studio 2019 berikutnya, termasuk versi rilis, perilaku ini telah dipertahankan.  Saya tidak menemukan penyebutan 'fitur' ini pada saat rilis di dokumentasi atau blog. <br><br>  Sekarang, tampaknya, semuanya berfungsi, dan dengan dukungan plug-in untuk Visual Studio 2019 selesai.  Sehari setelah rilis PVS-Studio 7.02 dengan dukungan untuk Visual Studio 2019, ternyata tidak demikian - masalah lain dengan plug-in asinkron ditemukan.  Untuk pengguna, ini bisa terlihat seperti ini: ketika membuka jendela dengan hasil analisis (atau memulai analisis), jendela kita kadang-kadang ditampilkan "kosong" - tidak berisi konten: tombol, meja dengan peringatan penganalisa, dll. <br><br>  Bahkan, masalah ini terkadang terulang dalam perjalanan kerja.  Namun, itu hanya diulang pada satu mesin, dan mulai muncul hanya setelah memperbarui Visual Studio di salah satu versi pertama 'Pratinjau' - ada kecurigaan bahwa ada sesuatu yang rusak selama instalasi / pembaruan.  Namun, seiring waktu, masalahnya tidak lagi terulang lagi pada mesin ini, dan kami memutuskan bahwa "diperbaiki dengan sendirinya."  Ternyata tidak - hanya sangat beruntung.  Lebih tepatnya, tidak beruntung. <br><br>  Masalahnya ternyata berada dalam urutan inisialisasi jendela lingkungan itu sendiri (turunan dari kelas <i>ToolWindowPane</i> ) dan isinya (pada kenyataannya, kontrol kami dengan kisi-kisi dan tombol).  Dalam kondisi tertentu, inisialisasi kontrol terjadi sebelum inisialisasi panel, dan terlepas dari kenyataan bahwa semuanya bekerja tanpa kesalahan, metode <i>FindToolWindowAsync</i> (membuat jendela pada panggilan pertama) bekerja dengan benar, tetapi kontrol tetap tidak terlihat.  Kami memperbaiki ini dengan menambahkan inisialisasi malas untuk kontrol kami ke kode isian panel. <br><br><h2>  Dukungan C # 8.0 </h2><br>  Menggunakan Roslyn sebagai dasar untuk penganalisa memiliki keuntungan yang signifikan - tidak perlu secara manual mempertahankan konstruksi bahasa baru.  Semua ini didukung dan diimplementasikan dalam kerangka kerja perpustakaan Microsoft.CodeAnalysis - kami menggunakan hasil yang sudah jadi.  Dengan demikian, dukungan untuk sintaks baru diimplementasikan dengan memperbarui perpustakaan. <br><br>  Tentu saja, sejauh menyangkut analisis statis, di sini Anda harus melakukan semuanya sendiri, khususnya, untuk memproses konstruksi bahasa baru.  Ya, kami mendapatkan pohon sintaksis baru secara otomatis dengan menggunakan versi Roslyn yang lebih baru, tetapi kami perlu mengajari analis bagaimana memahami dan memproses simpul pohon yang baru / diubah. <br><br>  Saya pikir inovasi yang paling banyak dibicarakan di C # 8 adalah jenis referensi nullable.  Saya tidak akan menulis tentang mereka di sini - ini adalah topik yang agak besar yang layak untuk artikel terpisah (yang sudah dalam proses penulisan).  Secara umum, kami sejauh ini memutuskan untuk mengabaikan anotasi yang tidak dapat dibatalkan dalam mekanisme aliran data kami (mis., Kami memahami, menguraikan, dan melewatkannya).  Faktanya adalah bahwa meskipun jenis referensi variabel tidak dapat <i>dibatalkan</i> , Anda masih dapat menulis <i>null</i> secara sederhana (atau karena kesalahan), yang dapat menyebabkan NRE ketika mendereferensi tautan yang sesuai.  Dalam hal ini, penganalisa kami dapat melihat kesalahan yang sama dan memberikan peringatan tentang penggunaan referensi yang berpotensi nol (tentu saja, jika ia melihat penugasan seperti itu dalam kode) meskipun jenis referensi variabel tidak dapat dibatalkan. <br><br>  Saya ingin mencatat bahwa penggunaan tipe referensi yang dapat dibatalkan dan sintaks yang menyertainya membuka kemungkinan untuk menulis kode yang sangat menarik.  Bagi kami sendiri, kami menyebutnya 'sintaksis emosional'.  Kode di bawah ini mengkompilasi dengan cukup baik: <br><br><pre> <code class="cpp hljs">obj.Calculate(); obj?.Calculate(); obj.Calculate(); obj!?.Calculate(); obj!!!.Calculate();</code> </pre> <br>  By the way, selama pekerjaan saya, saya menemukan beberapa cara untuk 'mengisi' Visual Studio menggunakan sintaks baru.  Faktanya adalah bahwa Anda tidak dapat membatasi jumlah karakter menjadi satu ketika Anda menempatkan '!'.  Artinya, Anda tidak hanya dapat menulis kode formulir: <br><br><pre> <code class="cpp hljs">object temp = null!</code> </pre> <br>  tetapi juga: <br><br><pre> <code class="cpp hljs">object temp = null!!!;</code> </pre> <br>  Anda dapat memutarbalikkan, silakan dan menulis seperti ini: <br><br><pre> <code class="cpp hljs">object temp = null!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;</code> </pre> <br>  Kode ini berhasil dikompilasi.  Tetapi jika Anda meminta informasi tentang pohon sintaks menggunakan Syntax Visualizer dari .NET Compiler Platform SDK, Visual Studio akan macet. <br><br>  Anda bisa mendapatkan informasi tentang masalah tersebut dari Peraga Peristiwa: <br><br><pre> <code class="cpp hljs">Faulting application name: devenv.exe, version: <span class="hljs-number"><span class="hljs-number">16.0</span></span><span class="hljs-number"><span class="hljs-number">.28803</span></span><span class="hljs-number"><span class="hljs-number">.352</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5cc37012</span></span> Faulting <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> name: WindowsBase.ni.dll, version: <span class="hljs-number"><span class="hljs-number">4.8</span></span><span class="hljs-number"><span class="hljs-number">.3745</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>, time stamp: <span class="hljs-number"><span class="hljs-number">0x5c5bab63</span></span> Exception code: <span class="hljs-number"><span class="hljs-number">0xc00000fd</span></span> Fault offset: <span class="hljs-number"><span class="hljs-number">0x000c9af4</span></span> Faulting process id: <span class="hljs-number"><span class="hljs-number">0x3274</span></span> Faulting application start time: <span class="hljs-number"><span class="hljs-number">0x01d5095e7259362e</span></span> Faulting application path: C:\<span class="hljs-function"><span class="hljs-function">Program </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Files</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x86)</span></span></span><span class="hljs-function">\ Microsoft Visual Studio\2019\Community\Common7\IDE\devenv.exe Faulting </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">module</span></span></span><span class="hljs-function"> path: C:\WINDOWS\assembly\NativeImages_v4.0.30319_32\ WindowsBase\4480dfedf0d7b4329838f4bbf953027d\WindowsBase.ni.dll Report Id: 66d41eb2-c658-486d-b417-02961d9c3e4f Faulting package full name: Faulting package-relative application ID:</span></span></code> </pre> <br>  Jika Anda melangkah lebih jauh dan meningkatkan jumlah tanda seru beberapa kali, Visual Studio akan jatuh dengan sendirinya - bantuan Syntax Visualizer tidak lagi diperlukan.  Perpustakaan Microsoft.CodeAnalysis dan kompiler csc.exe juga tidak mencerna kode ini. <br><br>  Tentu saja, ini adalah contoh sintetis, tetapi tetap saja fakta ini terasa lucu bagi saya. <br><br><h2>  Toolset </h2><br>  <b>Catatan</b>  Sekali lagi saya dihadapkan dengan masalah menerjemahkan kata 'evaluasi' dalam konteks percakapan tentang proyek MSBuild.  Terjemahan, yang tampaknya paling dekat artinya dan pada saat yang sama terdengar normal, adalah "membangun model proyek".  Jika Anda memiliki opsi terjemahan alternatif - Anda dapat menulis kepada saya, akan menarik untuk dibaca. <br><br>  Jelas bahwa memperbarui toolset akan menjadi tugas yang paling memakan waktu.  Lebih tepatnya, sepertinya sudah dari awal, tapi sekarang saya cenderung percaya bahwa yang paling bermasalah adalah dukungan plugin.  Secara khusus, ini adalah karena toolset yang sudah ada dan mekanisme untuk membangun model proyek MSBuild, yang bekerja dengan sukses sekarang, meskipun itu membutuhkan ekspansi.  Tidak perlu menulis algoritma dari awal sangat menyederhanakan tugas.  Taruhan kami pada toolset "kami", dibuat pada tahap mendukung Visual Studio 2017, dibenarkan sekali lagi. <br><br>  Secara tradisional, semuanya dimulai dengan memperbarui paket NuGet.  Pada tab manajemen paket NuGet untuk solusi, ada tombol 'Perbarui' ... yang tidak berfungsi.  Ketika memperbarui semua paket, beberapa konflik versi muncul, dan menyelesaikannya semua tampaknya tidak terlalu benar.  Cara yang lebih menyakitkan, tetapi, tampaknya, cara yang lebih dapat diandalkan adalah untuk 'sepotong demi sepotong' memperbarui target Microsoft.Build / Microsoft.CodeAnalysis. <br><br>  Salah satu perbedaan segera diidentifikasi oleh tes aturan diagnostik - struktur pohon sintaks untuk node yang sudah ada telah berubah.  Tidak apa-apa, diperbaiki dengan cepat. <br><br>  Biarkan saya mengingatkan Anda bahwa selama pekerjaan kami menguji analisis (C #, C ++, Java) pada proyek open source.  Ini memungkinkan Anda untuk menguji aturan diagnostik dengan baik - temukan, misalnya, positif palsu, atau mendapatkan gagasan tentang kasus lain yang belum dipertimbangkan (kurangi jumlah negatif palsu).  Tes-tes ini juga membantu melacak kemungkinan kemunduran pada tahap awal memperbarui perpustakaan / toolset.  Dan kali ini tidak terkecuali, karena sejumlah masalah muncul. <br><br>  Satu masalah adalah penurunan perilaku dalam perpustakaan CodeAnalysis.  Lebih khusus lagi, pada sejumlah proyek dalam kode perpustakaan, pengecualian terjadi selama berbagai operasi - memperoleh informasi semantik, membuka proyek, dll. <br><br>  Perhatian pembaca artikel tentang dukungan Visual Studio 2017 ingat bahwa kit distribusi kami memiliki rintisan - file MSBuild.exe berukuran 0 byte. <br><br>  Kali ini saya harus melangkah lebih jauh - sekarang kit distribusi juga berisi stub compiler kosong - csc.exe, vbc.exe, VBCSCompiler.exe.  Mengapa  Cara untuk ini dimulai dengan analisis salah satu proyek di basis tes, di mana perbedaan laporan muncul - sejumlah peringatan tidak ada ketika menggunakan versi baru dari penganalisa. <br><br>  Masalahnya ternyata menjadi simbol kompilasi bersyarat - ketika menganalisis proyek menggunakan versi baru dari penganalisa, beberapa simbol diekstraksi secara tidak benar.  Untuk lebih memahami apa yang menyebabkan masalah ini, saya harus menyelami perpustakaan Roslyn. <br><br>  Untuk menguraikan karakter kompilasi bersyarat, gunakan metode <i>GetDefineConstantsSwitch</i> dari kelas <i>Csc</i> dari perpustakaan <i>Microsoft.Build.Tasks.CodeAnalysis</i> .  Parsing dilakukan menggunakan metode <i>String.Split</i> pada sejumlah pembatas: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] allIdentifiers = originalDefineConstants.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">' '</span></span> });</code> </pre> <br>  Metode parsing ini berfungsi dengan baik, semua simbol kompilasi bersyarat yang diperlukan berhasil diekstraksi.  Menggali lebih jauh. <br><br>  Titik kunci berikutnya adalah panggilan ke metode <i>ComputePathToTool</i> dari kelas <i>ToolTask</i> .  Metode ini membangun jalur ke file yang dapat dieksekusi ( <i>csc.exe</i> ) dan memeriksa keberadaannya.  Jika file ada, path ke sana dikembalikan, jika tidak <i>null</i> dikembalikan. <br><br>  Kode Penelepon: <br><br><pre> <code class="cpp hljs">.... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> pathToTool = ComputePathToTool(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pathToTool == null) { <span class="hljs-comment"><span class="hljs-comment">// An appropriate error should have been logged already. return false; } ....</span></span></code> </pre> <br>  Karena tidak ada file <i>csc.exe</i> (akan terlihat - mengapa kita membutuhkannya?), <i>PathToTool</i> pada tahap ini adalah <i>nol</i> , dan metode saat ini ( <i>ToolTask.Execute</i> ) menyelesaikan eksekusi dengan hasil <i>false</i> .  Akibatnya, hasil tugas, termasuk simbol kompilasi bersyarat yang dihasilkan, diabaikan. <br><br>  Baiklah, mari kita lihat apa yang terjadi jika Anda meletakkan file <i>csc.exe</i> di lokasi yang diharapkan. <br><br>  Dalam hal ini, <i>pathToTool</i> menunjukkan lokasi sebenarnya dari file yang ada dan eksekusi metode <i>ToolTask.Execute</i> berlanjut.  Poin kunci berikutnya adalah panggilan ke metode <i>ManagedCompiler.ExecuteTool</i> .  Dan itu dimulai sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> override </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecuteTool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathToTool, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> responseFileCommands, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> commandLineCommands)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProvideCommandLineArgs) { CommandLineArgs = GetArguments(commandLineCommands, responseFileCommands) .Select(arg =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskItem(arg)).ToArray(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SkipCompilerExecution) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } .... }</code> </pre> <br>  Properti <i>SkipCompilerExecution</i> <i>benar</i> (secara logis, kami sebenarnya tidak mengkompilasi).  Akibatnya, metode panggilan ( <i>ToolTask.Execute yang</i> telah disebutkan) memeriksa bahwa kode kembali metode <i>ExecuteTool</i> adalah 0, dan, jika demikian, menyelesaikan eksekusi dengan nilai <i>true</i> .  Apa yang Anda miliki di belakang <i>csc.exe</i> ada di sana - kompiler nyata atau 'Perang dan Damai' Leo Tolstoy dalam bentuk tekstual tidak masalah. <br><br>  Akibatnya, masalah utama berasal dari kenyataan bahwa urutan langkah-langkah didefinisikan dalam urutan berikut: <br><br><ul><li>  periksa keberadaan kompiler; </li><li>  periksa apakah kompiler perlu dimulai; </li></ul><br>  bukan sebaliknya.  Rintisan kompiler berhasil memecahkan masalah ini. <br><br>  Nah, bagaimana karakter kompilasi yang berhasil muncul jika file csc.exe tidak terdeteksi (dan hasil tugas diabaikan)? <br><br>  Ada metode untuk kasus ini - <i>CSharpCommandLineParser.ParseConditionalCompilationSymbols</i> dari perpustakaan <i>Microsoft.CodeAnalysis.CSharp</i> .  Parsing juga dilakukan oleh metode <i>String.Split</i> dengan sejumlah pembatas: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[] values = value.Split(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] { <span class="hljs-string"><span class="hljs-string">';'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span> } <span class="hljs-comment"><span class="hljs-comment">/*, StringSplitOptions.RemoveEmptyEntries*/</span></span>);</code> </pre> <br>  Perhatikan perbedaannya dengan set pembatas dari metode <i>Csc.GetDefineConstantsSwitch</i> ?  Dalam hal ini, spasi putih bukan pemisah.  Dengan demikian, jika karakter kompilasi bersyarat ditulis dengan spasi, metode ini akan menguraikannya dengan tidak benar. <br><br>  Situasi ini muncul pada proyek bermasalah - karakter kompilasi bersyarat ditulis di dalamnya dengan spasi, dan berhasil diurai menggunakan <i>GetDefineConstantsSwitch</i> , tetapi tidak <i>ParseConditionalCompilationSymbols</i> . <br><br>  Masalah lain yang muncul setelah memperbarui perpustakaan adalah memburuknya perilaku dalam sejumlah kasus, khususnya, pada proyek-proyek yang tidak dikumpulkan.  Masalah muncul di perpustakaan Microsoft.CodeAnalysis dan kembali kepada kami dalam bentuk berbagai pengecualian - <i>ArgumentNullException</i> (beberapa logger internal tidak diinisialisasi), <i>NullReferenceException</i> , dan lainnya. <br><br>  Saya ingin berbicara tentang salah satu masalah di bawah ini - menurut saya cukup menarik. <br><br>  Kami mengalami masalah ini ketika memeriksa versi terbaru dari proyek Roslyn - <i>NullReferenceException</i> dilemparkan dari kode salah satu perpustakaan.  Karena informasi yang cukup terperinci tentang lokasi masalah, kami dengan cepat menemukan kode masalah dan, demi kepentingan, memutuskan untuk mencoba melihat apakah masalah tersebut berulang ketika bekerja dari Visual Studio. <br><br>  Yah - itu mungkin untuk mereproduksi di Visual Studio (percobaan dilakukan pada Visual Studio 16.0.3).  Untuk melakukan ini, kita memerlukan definisi kelas dari formulir berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C1</span></span></span><span class="hljs-class">&lt;T1, T2&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ T1 val = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val is null) { } } }</code> </pre> <br>  Kami juga akan memerlukan Sintaks Visualizer (bagian dari .NET Compiler Platform SDK).  Hal ini diperlukan untuk meminta <i>TypeSymbol</i> (item menu "Lihat TypeSymbol (jika ada)") dari node pohon sintaks tipe <i>ConstantPatternSyntax</i> ( <i>null</i> ).  Setelah itu, Visual Studio akan memulai kembali, dan di Peraga Peristiwa Anda dapat melihat informasi tentang masalah, khususnya, menemukan jejak tumpukan: <br><br><pre> <code class="cpp hljs">Application: devenv.exe Framework Version: v4<span class="hljs-number"><span class="hljs-number">.0</span></span><span class="hljs-number"><span class="hljs-number">.30319</span></span> Description: The process was terminated due to an unhandled exception. Exception Info: System.NullReferenceException at Microsoft.CodeAnalysis.CSharp.ConversionsBase. ClassifyImplicitBuiltInConversionSlow( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet<span class="hljs-string"><span class="hljs-string">'1 &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyBuiltInConversion( Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol, System.Collections.Generic.HashSet'</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> &lt;Microsoft.CodeAnalysis.DiagnosticInfo&gt; ByRef) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoForNode( Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode, Microsoft.CodeAnalysis.CSharp.BoundNode) at Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetTypeInfoWorker( Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo( Microsoft.CodeAnalysis.CSharp.Syntax.PatternSyntax, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoFromNode( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) at Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoCore( Microsoft.CodeAnalysis.SyntaxNode, System.Threading.CancellationToken) ....</code> </pre> <br>  Seperti yang Anda lihat, penyebab masalahnya adalah referensi referensi nol. <br><br>  Seperti yang saya sebutkan sebelumnya, kami mengalami masalah yang sama selama pengujian analisa.  Jika Anda menggunakan perpustakaan debug Microsoft.CodeAnalysis untuk membangun analisa, Anda bisa datang ke tempat yang tepat dengan <i>men-</i> debug dengan meminta <i>TypeSymbol</i> dari node yang diinginkan di pohon sintaksis. <br><br>  Akibatnya, kami tiba di metode <i>ClassifyImplicitBuiltInConversionSlow</i> yang disebutkan dalam jejak tumpukan di <i>atas</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Conversion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassifyImplicitBuiltInConversionSlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TypeSymbol source, TypeSymbol destination, ref HashSet&lt;DiagnosticInfo&gt; useSiteDiagnostics)</span></span></span><span class="hljs-function"> </span></span>{ Debug.Assert((object)source != null); Debug.Assert((object)destination != null); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.SpecialType == SpecialType.System_Void || destination.SpecialType == SpecialType.System_Void) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; } Conversion conversion = ClassifyStandardImplicitConversion(source, destination, ref useSiteDiagnostics); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conversion.Exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> conversion; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conversion.NoConversion; }</code> </pre> <br>  Masalahnya adalah bahwa parameter <i>tujuan</i> adalah <i>nol</i> dalam kasus ini.  Dengan demikian, saat memanggil <i>tujuan. Jenis Khusus,</i> <i>NullReferenceException dilemparkan</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ya, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug.Assert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lebih tinggi daripada dereferencing </font><font style="vertical-align: inherit;">, tetapi ini tidak cukup, karena pada kenyataannya itu tidak melindungi terhadap apa pun - itu hanya membantu untuk mengidentifikasi masalah dalam debug versi perpustakaan. </font><font style="vertical-align: inherit;">Atau tidak membantu.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perubahan dalam membangun model proyek C ++ </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada yang sangat menarik terjadi di sini - algoritma lama tidak memerlukan modifikasi yang signifikan, yang akan menarik untuk dibicarakan. </font><font style="vertical-align: inherit;">Ada, mungkin, dua poin yang masuk akal untuk dipikirkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertama, kami harus memodifikasi algoritma yang bergantung pada nilai ToolsVersion yang akan ditulis dalam format numerik. </font><font style="vertical-align: inherit;">Tanpa merinci - ada beberapa kasus ketika Anda perlu membandingkan toolets dan memilih, misalnya, versi baru yang lebih terkini. </font><font style="vertical-align: inherit;">Versi ini, masing-masing, memiliki nilai numerik yang lebih tinggi. </font><font style="vertical-align: inherit;">Ada perhitungan bahwa ToolsVersion, yang sesuai dengan versi baru MSBuild / Visual Studio, akan sama dengan 16.0. </font><font style="vertical-align: inherit;">Apa pun masalahnya ... Demi kepentingan, saya kutip tabel tentang bagaimana nilai berbagai properti berubah dalam versi Visual Studio yang berbeda:</font></font><br><div class="scrollable-table"><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nama produk studio visual </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nomor versi studio visual </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versi Alat </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Versi PlatformToolset </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2010 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.0 </font></font><br></td><td>  100 <br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2012 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 110 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2013 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 120 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2015 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 140 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2017 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 15.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 141 </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visual studio 2019 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16.0 </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saat ini </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 142 </font></font><br></td></tr></tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lelucon itu, tentu saja, sudah ketinggalan zaman, tetapi Anda tidak dapat membantu tetapi ingat tentang mengubah versi Windows dan Xbox untuk memahami bahwa memprediksi nilai masa depan (tidak peduli apa nama dan versi), dalam kasus Microsoft, adalah hal yang goyah. </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusinya cukup sederhana - memperkenalkan penentuan prioritas toolets (alokasi entitas prioritas terpisah). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin kedua adalah masalah ketika bekerja di Visual Studio 2017 atau di lingkungan yang berdekatan (misalnya, kehadiran variabel lingkungan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisualStudioVersion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Faktanya adalah bahwa menghitung parameter yang diperlukan untuk membangun model proyek C ++ jauh lebih rumit daripada membangun model proyek NET. Dalam kasus .NET, kami menggunakan alat kami sendiri dan nilai ToolsVersion yang sesuai. Dalam kasus C ++, kita dapat membangun baik pada toolet kita sendiri maupun yang sudah ada dalam sistem. Dimulai dengan Alat Bangun di Visual Studio 2017, alat terdaftar di file </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSBuild.exe.config</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tidak ada dalam registri. Karenanya, kami tidak dapat memperolehnya dari daftar umum toolet (misalnya, melalui </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Build.Evaluation.ProjectCollection.GlobalProjectCollection.Toolsets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), tidak seperti toolets yang dicatat dalam registri (sesuai dengan &lt;= Visual Studio 2015) . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai konsekuensi dari hal tersebut di atas, tidak akan berhasil membangun model proyek menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToolsVersion 15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena sistem tidak akan melihat toolset yang diperlukan. Toolset </font><i><font style="vertical-align: inherit;">Terkini</font></i><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- itu akan tersedia pada saat yang sama, karena ini adalah perangkat kami sendiri, oleh karena itu, tidak ada masalah untuk Visual Studio 2019. </font><font style="vertical-align: inherit;">Solusinya ternyata sederhana dan diizinkan untuk menyelesaikan masalah tanpa mengubah algoritma yang ada untuk membangun model proyek - menambah daftar set alat Anda sendiri, selain </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Current, yang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lain - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15,0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perubahan dalam membangun model proyek C # .NET Core </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam kerangka tugas ini, 2 masalah diselesaikan sekaligus, karena ternyata terkait: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setelah menambahkan toolset 'Lancar', analisis proyek .NET Core untuk Visual Studio 2017 berhenti bekerja; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Analisis proyek .NET Core pada sistem di mana setidaknya satu versi Visual Studio tidak diinstal tidak berfungsi. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah dalam kedua kasus itu sama - beberapa file .targets / .props dasar dicari dengan cara yang salah. </font><font style="vertical-align: inherit;">Ini mengarah pada fakta bahwa tidak mungkin untuk membangun model proyek menggunakan perangkat kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan tidak adanya Visual Studio, Anda bisa melihat kesalahan seperti itu (dengan toolset'a versi sebelumnya - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15.0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Windows\Microsoft.NET\Framework64\ 15.0\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat membangun C # .NET Core model proyek di Visual Studio 2017, Anda bisa melihat masalah berikut (dengan versi toolset </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat ini</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">Lancar</font></i><font style="vertical-align: inherit;"> ):</font></font><br><br><pre> <code class="cpp hljs">The imported project <span class="hljs-string"><span class="hljs-string">"C:\Program Files (x86)\Microsoft Visual Studio\ 2017\Community\MSBuild\Current\Microsoft.Common.props"</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found. ....</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena masalahnya mirip (tetapi terlihat seperti itu), Anda dapat mencoba membunuh dua burung dengan satu batu. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah ini saya menjelaskan bagaimana masalah ini diselesaikan tanpa masuk ke rincian teknis. Ini sangat detail (tentang membangun model proyek C # .NET Core, serta mengubah konstruksi model di toolset'e kami) sedang menunggu di salah satu artikel kami di masa mendatang. Omong-omong, jika Anda hati-hati membaca teks di atas, Anda mungkin memperhatikan bahwa ini adalah referensi kedua untuk artikel mendatang.</font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi bagaimana kami mengatasi masalah ini? Solusinya adalah memperluas toolset kami sendiri dengan mengorbankan file .targets / .props utama dari .NET Core SDK ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.props</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sdk.targets</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ini memungkinkan kami untuk memiliki kontrol lebih besar terhadap situasi, lebih banyak fleksibilitas dalam mengelola impor, serta dalam membangun model proyek .NET Core secara umum. Ya, toolset kami telah tumbuh sedikit lagi, dan kami juga harus menambahkan logika untuk mengatur proyek lingkungan yang diperlukan untuk membangun model .NET Core, tetapi sepertinya itu sepadan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelumnya, prinsip kerja ketika membangun model proyek .NET Core adalah sebagai berikut: kami hanya meminta konstruksi ini, dan kemudian semuanya bekerja dengan mengorbankan MSBuild. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang, ketika kita telah mengambil kendali lebih banyak ke tangan kita sendiri, itu tampak sedikit berbeda:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> persiapan lingkungan yang diperlukan untuk membangun model proyek .NET Core; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> model bangunan: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mulai konstruksi menggunakan file .targets / .props dari toolset'a kami; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> konstruksi lanjutan menggunakan file eksternal. </font></font></li></ul></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dari langkah-langkah yang dijelaskan di atas, jelas bahwa pengaturan lingkungan yang diperlukan memiliki dua tujuan utama: </font></font><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memulai pembuatan model menggunakan file .targets / .props dari perangkat Anda sendiri; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengarahkan operasi lebih lanjut ke file .targets / .props eksternal. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mencari file .targets / .props yang diperlukan untuk membangun model proyek .NET Core, perpustakaan khusus digunakan - Microsoft.DotNet.MSBuildSdkResolver. Inisiasi membangun menggunakan file dari toolset kami diselesaikan dengan menggunakan variabel lingkungan khusus yang digunakan oleh perpustakaan ini - kami menyarankan tempat untuk mengimpor file yang diperlukan (dari toolset kami). Karena perpustakaan adalah bagian dari distribusi kami, tidak ada kekhawatiran bahwa logika akan tiba-tiba berubah dan berhenti berfungsi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang file Sdk pertama kali diimpor dari toolset kami, dan karena kita dapat dengan mudah mengubahnya, kontrol dari logika selanjutnya untuk membangun model diteruskan ke tangan kita. Oleh karena itu, kita dapat menentukan sendiri file mana yang perlu diimpor dan dari mana. Ini juga berlaku untuk Microsoft.Common.props yang disebutkan di atas. Kami mengimpor ini dan file-file dasar lainnya dari perangkat kami sendiri dengan keyakinan pada ketersediaan dan kontennya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah itu, setelah menyelesaikan impor yang diperlukan dan menetapkan sejumlah properti, kami mentransfer kontrol lebih lanjut dari pembangunan model ke .NET Core SDK yang sebenarnya, tempat tindakan selanjutnya diperlukan.</font></font><br><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, dukungan untuk Visual Studio 2019 berjalan lebih mudah daripada dukungan untuk Visual Studio 2017, yang, seperti yang saya lihat, adalah karena beberapa faktor. Pertama, Microsoft tidak mengubah banyak hal seperti antara Visual Studio 2015 dan Visual Studio 2017. Ya, kami mengubah perangkat utama, mulai mengarahkan plug-in untuk Visual Studio pada asynchrony, tetapi tetap saja. Yang kedua - kami sudah memiliki solusi yang siap dengan toolset kami sendiri dan membangun model proyek - tidak perlu menemukan semuanya lagi, itu sudah cukup hanya untuk memperluas solusi yang ada. Dukungan yang relatif sederhana untuk menganalisis .NET Core proyek untuk kondisi baru (serta untuk kasus analisis pada mesin di mana tidak ada contoh Visual Studio diinstal) karena perluasan sistem bangunan model proyek kami juga memberi harapan bahwa kami membuat pilihan yang tepat.Setelah memutuskan untuk mengendalikan diri sendiri.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tapi tetap saja, saya ingin mengulangi satu pemikiran yang ada di artikel sebelumnya lagi - terkadang menggunakan solusi yang sudah jadi tidak sesederhana seperti yang terlihat pada pandangan pertama. </font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Sergey Vasiliev. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dukungan Visual Studio 2019 di PVS-Studio</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id454738/">https://habr.com/ru/post/id454738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id454728/index.html">Buka Akses Internet: Teknologi LUWRAIN Membantu Pengguna Buta</a></li>
<li><a href="../id454730/index.html">Allure Server meetup: rekaman video dari laporan</a></li>
<li><a href="../id454732/index.html">5 Teknik Prioritas yang Kuat untuk Tim TI</a></li>
<li><a href="../id454734/index.html">Cadangan, Bagian 4: Tinjauan Umum dan Pengujian zbackup, restic, borgbackup</a></li>
<li><a href="../id454736/index.html">Dukungan Visual Studio 2019 di PVS-Studio</a></li>
<li><a href="../id454740/index.html">Mei 2019 Pencernaan Joomla</a></li>
<li><a href="../id454742/index.html">Setidaknya satu trik Vim yang tidak Anda ketahui</a></li>
<li><a href="../id454744/index.html">Tinjauan Java Track Reports dari RigaDevDays Conference</a></li>
<li><a href="../id454748/index.html">Panduan Kelangsungan Hidup MongoDB</a></li>
<li><a href="../id454750/index.html">UI cepat - berlari kencang di seluruh Eropa</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>