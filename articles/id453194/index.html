<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöπ üë®üèΩ‚Äç‚öñÔ∏è üë©üèª‚Äçüåæ Kami memecahkan masalah Reverser Terbaik dengan PHDays 9 üõéÔ∏è üéÑ üõ∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo 

 Nama saya Marat Gayanov, saya ingin berbagi dengan Anda solusi saya untuk masalah dari kontes Best Reverser , untuk menunjukkan cara membuat k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami memecahkan masalah Reverser Terbaik dengan PHDays 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453194/">  Halo <br><br>  Nama saya Marat Gayanov, saya ingin berbagi dengan Anda solusi saya untuk masalah dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kontes Best Reverser</a> , untuk menunjukkan cara membuat keygen untuk kasus ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/ja/bo/rpjabo27x0oemehl_380bdoiyto.png" alt="gambar"></div><br><h2>  Deskripsi </h2><br>  Dalam kompetisi ini, peserta diberikan permainan ROM untuk Sega Mega Drive ( <a href="">best_reverser_phd9_rom_v4.bin</a> ). <br><br>  Tugas: untuk mengambil kunci seperti itu yang bersama-sama dengan alamat email peserta akan diakui valid. <br><br>  Jadi solusinya ... <br><a name="habracut"></a><br><h2>  Alat-alatnya </h2><br><ul><li>  IDA Pro 6.8 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plugin Smd_ida_tools</a> </li></ul><br><h2>  Memeriksa Panjang Kunci </h2><br>  Program tidak menerima setiap kunci: Anda harus mengisi seluruh bidang, ini adalah 16 karakter.  Jika kuncinya lebih pendek, Anda akan melihat pesan: ‚ÄúPanjangnya salah!  Coba lagi ... ". <br><br>  Mari kita coba temukan baris ini di program, yang mana kita akan menggunakan pencarian biner (Alt-B).  Apa yang akan kita temukan? <br><br>  Kami tidak hanya akan menemukan ini, tetapi juga jalur layanan lain di sekitarnya: ‚ÄúKunci salah!  Coba lagi ... "dan" KAMU ADALAH REVERSER TERBAIK! ". <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/-b/ru/fb/-brufb6jqqrejxctfwwvrp8l0xu.png" alt="gambar"></div><br><div style="text-align:center;"><img src="https://hsto.org/webt/6y/6m/jb/6y6mjbg8kod7ys087rlbngrshky.png" alt="gambar"></div><br>  Saya menetapkan <code>WRONG_LENGTH_MSG</code> , <code>WRONG_LENGTH_MSG</code> , dan <code>WRONG_KEY_MSG</code> untuk kenyamanan. <br><br>  Istirahat membaca alamat <code>0x0000FDFA</code> - cari tahu siapa yang bekerja dengan pesan "Panjangnya salah!  Coba lagi ... ".  Dan jalankan debugger (itu akan berhenti beberapa kali sebelum kunci dapat dimasukkan, cukup tekan F9 di setiap perhentian).  Masukkan email Anda, kunci <code>ABCD</code> . <br><br>  Debugger mengarah ke <code>0x00006FF0 tst.b (a1)+</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jq/h5/mf/jqh5mfieh1st-s6fktdghtomemy.png" alt="gambar"></div><br>  Tidak ada yang menarik di blok itu sendiri.  Jauh lebih menarik siapa yang mentransfer kendali di sini.  Kami melihat tumpukan panggilan: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/w4/sa/1p/w4sa1p9_t4czdofd4jjj-tdtg4q.png" alt="gambar"></div><br>  Klik dan dapatkan di sini - ke instruksi <code>0x00001D2A jsr (sub_6FC0).l</code> : <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/1d/bp/xy/1dbpxyojlaks20xlmgivzm0rpdw.png" alt="gambar"></div><br>  Kami melihat bahwa semua pesan yang mungkin ditemukan di satu tempat.  Tetapi mari kita cari tahu di mana kontrol ditransfer ke dalam blok <code>WRONG_KEY_LEN_CASE_1D1C</code> .  Kami tidak akan mengatur jeda, cukup gerakkan kursor di atas panah ke blok.  Pemanggil terletak di <code>0x000017DE loc_17DE</code> (yang akan saya ganti namanya menjadi <code>CHECK_KEY_LEN</code> ): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/bo/c1/tc/boc1tck7dpjuq46sppgq93wghfu.png" alt="gambar"></div><br>  <code>0x000017EC cmpi.b 0x20 (a0, d0.l)</code> alamat <code>0x000017EC cmpi.b 0x20 (a0, d0.l)</code> (instruksi dalam konteks ini terlihat untuk melihat apakah ada karakter kosong di akhir array karakter kunci), restart, masukkan kembali surat dan kunci <code>ABCD</code> .  Debugger berhenti dan menunjukkan bahwa kunci yang dimasukkan terletak di alamat <code>0x00FF01C7</code> (disimpan pada saat itu dalam register <code>a0</code> ): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/qs/l9/k4/qsl9k4apyhz2orh5lz9vphf-gdo.png" alt="gambar"></div><br>  Ini adalah temuan yang bagus, melalui itu kami akan mengambil semuanya.  Tapi pertama-tama, tandai byte kunci untuk kenyamanan: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/on/kw/c8/onkwc8dvpch6ckyjbcl0a-9zx4q.png" alt="gambar"></div><br>  Menggulir ke atas dari tempat ini, kita melihat bahwa surat disimpan di sebelah tombol: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/at/_t/_j/at_t_jhxaruncxgntbn-i5t396o.png" alt="gambar"></div><br>  Kami menyelam lebih dalam dan lebih dalam, dan inilah saatnya untuk menemukan kriteria untuk kebenaran kunci.  Sebaliknya, bagian pertama dari kunci. <br><br><h2>  Kriteria untuk kebenaran bagian pertama dari kunci </h2><br><h3>  Perhitungan awal </h3><br>  Adalah logis untuk mengasumsikan bahwa segera setelah memeriksa panjang, operasi lain dengan kunci akan mengikuti.  Pertimbangkan blok segera setelah cek: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/g4/oy/w6/g4oyw6inctcnokzxmo1r5kbfl9c.png" alt="gambar"></div><br>  Blok ini sedang menjalani pekerjaan pendahuluan.  Fungsi <code>get_hash_2b</code> (dalam aslinya adalah <code>sub_1526</code> ) dipanggil dua kali.  Pertama, alamat byte pertama dari kunci ditransmisikan ke sana (register <code>a0</code> berisi alamat <code>KEY_BYTE_0</code> ), yang kedua - kelima ( <code>KEY_BYTE_4</code> ). <br><br>  Saya menamai fungsi seperti ini karena menganggapnya seperti hash 2-byte.  Ini adalah nama yang paling bisa dimengerti yang saya ambil. <br><br>  Saya tidak akan mempertimbangkan fungsi itu sendiri, tetapi saya akan segera menulisnya dengan python.  Dia melakukan hal-hal sederhana, tetapi deskripsinya dengan tangkapan layar akan memakan banyak ruang. <br><br>  Hal paling penting untuk dikatakan tentang itu: alamat input diberikan ke input, dan pekerjaan sedang dilakukan pada 4 byte dari alamat ini.  Artinya, mereka mengirim byte pertama kunci ke input, dan fungsinya akan bekerja dengan 1,2,3,4.  Diposting kelima, fungsi ini bekerja dengan 5,6,7,8.  Dengan kata lain, di blok ini ada perhitungan selama paruh pertama kunci.  Hasilnya ditulis ke register <code>d0</code> . <br><br>  Jadi fungsi <code>get_hash_2b</code> : <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># key_4s -    def get_hash_2b(key_4s): #    def transform(b): # numbers -. if b &lt;= 0x39: r = b - 0x30 # Letter case and @ else: # @ABCDEF if b &lt;= 0x46: r = b - 0x37 else: # WXYZ if b &gt;= 0x57: r = b - 0x57 # GHIJKLMNOPQRSTUV else: r = 0xff - (0x57 - b) + 1 # a9+b return r #    key_4b = bytearray(key_4s, encoding="ascii") #     codes = [transform(b) for b in key_4b] #      part0 = (codes[0] &amp; 0xff) &lt;&lt; 0xc part1 = (codes[1] &lt;&lt; 0x8) &amp; 0xf00 part2 = (codes[2] &lt;&lt; 0x4) &amp; 0xf0 hash_2b = (part0 | part1) &amp; 0xffff hash_2b = (hash_2b | part2) &amp; 0xffff hash_2b = (hash_2b | (codes[3] &amp; 0xf)) return hash_2b</span></span></code> </pre> <br>  Segera tulis fungsi decoding hash: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#    4-  def decode_hash_4s(hash_2b): #    def transform(b): if b &lt;= 0x9: return b + 0x30 if b &lt;= 0xF: return b + 0x37 if b &gt;= 0x0: return b + 0x57 return b - 0xa9 #         b0 = transform(hash_2b &gt;&gt; 12) b1 = transform((hash_2b &amp; 0xfff) &gt;&gt; 8) b2 = transform((hash_2b &amp; 0xff) &gt;&gt; 4) b3 = transform(hash_2b &amp; 0xf) #  key_4s = [chr(b0), chr(b1), chr(b2), chr(b3)] key_4s = "".join(key_4s) return key_4s</span></span></code> </pre> <br>  Saya tidak membuat fungsi decoding yang lebih baik, dan itu tidak sepenuhnya benar.  Karena itu, saya akan memeriksanya seperti ini (tidak sekarang, tetapi nanti): <br><br><pre> <code class="python hljs">key_4s == decode_hash_4s(get_hash_2b(key_4s))</code> </pre> <br>  Periksa pengoperasian <code>get_hash_2b</code> .  Kami tertarik pada status register <code>d0</code> setelah fungsi dieksekusi.  Kami <code>0x000017FE</code> break pada <code>0x000017FE</code> , <code>0x00001808</code> , kunci yang kami masukkan <code>ABCDEFGHIJKLMNOP</code> . <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/x-/tu/mv/x-tumvz-5akeokp44a-wlclamuu.png" alt="gambar"></div><br><div style="text-align:center;"><img src="https://hsto.org/webt/ft/gy/ke/ftgykerggzjdpvpseel8vm7vaji.png" alt="gambar"></div><br>  Nilai <code>0xABCD</code> , <code>0xEF01</code> dimasukkan dalam register <code>d0</code> .  Dan apa yang akan diberikan <code>get_hash_2b</code> ? <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>first_hash = get_hash_2b(<span class="hljs-string"><span class="hljs-string">"ABCD"</span></span>) &gt;&gt;&gt; hex(first_hash) <span class="hljs-number"><span class="hljs-number">0xabcd</span></span> &gt;&gt;&gt; second_hash = get_hash_2b(<span class="hljs-string"><span class="hljs-string">"EFGH"</span></span>) &gt;&gt;&gt; hex(second_hash) <span class="hljs-number"><span class="hljs-number">0xef01</span></span></code> </pre> <br>  Verifikasi berlalu. <br><br>  Kemudian <code>xor eor.w d0, d5</code> diproduksi, hasilnya dimasukkan dalam <code>d5</code> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>hex(<span class="hljs-number"><span class="hljs-number">0xabcd</span></span> ^ <span class="hljs-number"><span class="hljs-number">0xef01</span></span>) <span class="hljs-number"><span class="hljs-number">0x44cc</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://hsto.org/webt/fa/6l/a0/fa6la0nx5iia9ldl24wgxibdwhy.png" alt="gambar"></div><br>  Memperoleh hash <code>0x44CC</code> adalah <code>0x44CC</code> dan terdiri dari perhitungan awal.  Selanjutnya, semuanya menjadi lebih rumit. <br><br><h3>  Kemana perginya hash </h3><br>  Kami tidak bisa melangkah lebih jauh jika kami tidak tahu bagaimana program bekerja dengan hash.  Tentunya itu bergerak dari <code>d5</code> ke memori, karena  Register berguna di tempat lain.  Kita dapat menemukan peristiwa semacam itu melalui jejak (menonton <code>d5</code> ), tetapi tidak manual, tetapi otomatis.  Script berikut akan membantu: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto d5_val; auto i; for(;;) { StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); d5_val = GetRegValue("d5"); //    d5 if (d5_val != 0xFFFF44CC){ break; } } }</span></span></span></span></code> </pre> <br>  Biarkan saya mengingatkan Anda bahwa kita sekarang pada istirahat terakhir <code>0x00001808 eor.w d0, d5</code> .  Rekatkan skrip ( <code>Shift-F2</code> ), klik <code>Run</code> <br><br>  Script akan berhenti pada instruksi <code>0x00001C94 move.b (a0, a1.l), d5</code> , tetapi pada saat ini <code>d5</code> telah dihapus.  Namun, kita melihat bahwa nilai dari <code>d5</code> digerakkan oleh instruksi <code>0x00001C56 move.w d5,a6</code> : ditulis ke dalam memori di alamat <code>0x00FF0D46</code> (2 byte). <br><br>  <b>Ingat: hash disimpan di <code>0x00FF0D46</code> .</b> <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/wr/ya/gj/wryagjtwp8fvk35qfeyukg9meae.png" alt="gambar"></div><br>  Kami menangkap instruksi yang dibaca dari <code>0x00FF0D46-0x00FF0D47</code> (kami menetapkan jeda untuk membaca).  Tertangkap 4 blok: <br><br><img src="https://hsto.org/webt/m6/8g/ym/m68gymzx3mold0wdl1g0xnab-sw.png" alt="gambar"><img src="https://hsto.org/webt/id/rr/k_/idrrk_tmum_fu409yn21tqygisk.png" alt="gambar"><img src="https://hsto.org/webt/e0/nl/z_/e0nlz_whuvgznlt-efdiuecujqa.png" alt="gambar"><img src="https://hsto.org/webt/i8/tn/kv/i8tnkvhk6mc5nirtlb9hlwj-bui.png" alt="gambar"><br><br>  Bagaimana cara memilih yang benar / benar? <br><br>  Kembali ke awal: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/1d/bp/xy/1dbpxyojlaks20xlmgivzm0rpdw.png" alt="gambar"></div><br>  Blok ini menentukan apakah program akan menuju ke <code>LOSER_CASE</code> atau ke <code>WINNER_CASE</code> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p7/0l/ry/p70lrykx4qd6lof_e5kcnmcjbbk.png" alt="gambar"></div><br>  Kita melihat bahwa dalam register <code>d1</code> harus nol untuk menang. <br><br>  Di mana nol ditetapkan?  Cukup gulir ke atas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_4/u0/tv/_4u0tvhvply85bhmwhjki65l0vu.png" alt="gambar"></div><br>  Jika <code>loc_1EEC</code> terpenuhi di blok <code>loc_1EEC</code> : <br><br><pre> <code class="cpp hljs">*(a6 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) == *(a6 + <span class="hljs-number"><span class="hljs-number">0x22</span></span>)</code> </pre> <br>  maka kita mendapatkan nol di <code>d5</code> . <br><br>  Jika kita menghentikan instruksi <code>0x00001F16 beq.w loc_20EA</code> , kita akan melihat bahwa <code>a6 + 0x24 = 0x00FF0D6A</code> dan nilai <code>0x4840</code> disimpan di sana.  Dan dalam <code>a6 + 0x22 = 0x00FF0D68</code> disimpan. <br><br>  Jika kita memasukkan kunci berbeda, email, kita akan melihat bahwa <code>0xCB4C - </code> .  <b>Paruh pertama kunci hanya akan diterima jika di <code>0x00FF0D6A</code> juga akan ada <code>0xCB4C</code> .</b>  <b>Ini adalah kriteria untuk ketepatan bagian pertama dari kunci.</b> <br><br>  Kami mencari tahu blok mana yang ditulis dalam <code>0x00FF0D6A</code> - <code>0x00FF0D6A</code> istirahat pada catatan, masukkan surat dan kunci lagi. <br><br>  Dan kita akan menemukan blok <code>loc_EAC</code> ini (sebenarnya ada 3, tetapi dua yang pertama hanya nol <code>0x00FF0D6A</code> ): <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/pc/um/u1/pcumu10pkuhgdcfehysc-hzlbk4.png" alt="gambar"></div><br>  Blok ini milik fungsi <code>sub_E3E</code> . <br><br>  Melalui tumpukan panggilan, kami mengetahui bahwa fungsi <code>sub_E3E</code> dipanggil di blok <code>loc_1F94</code> , <code>loc_203E</code> : <br><br><img src="https://habrastorage.org/webt/8p/mt/uh/8pmtuh7u7gigntcmbx7wugc6q5e.png" alt="gambar"><img src="https://hsto.org/webt/lg/_-/2k/lg_-2kw8yl2_klsq5azj1mebnzs.png" alt="gambar"><br><br>  Ingat kami menemukan 4 blok sebelumnya?  <code>loc_1F94</code> kami lihat di sana - ini adalah awal dari algoritma pemrosesan kunci utama. <br><br><h2>  Loc_1 loop penting pertama </h2><br>  Fakta bahwa <code>loc_1F94</code> adalah sebuah siklus terlihat dari kode: ia dieksekusi <code>d4</code> kali (lihat instruksi <code>0x00001FBA d4,loc_1F94</code> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8p/mt/uh/8pmtuh7u7gigntcmbx7wugc6q5e.png" alt="gambar"></div><br>  Apa yang harus dicari: <br><br><ol><li>  Ada fungsi <code>sub_5EC</code> . </li><li>  Instruksi 0x00001FB4 jsr (a0) memanggil fungsi sub_E3E (ini dapat dilihat dengan jejak sederhana). </li></ol><br>  Apa yang terjadi di sini: <br><br><ol><li>  Fungsi <code>sub_5EC</code> menulis hasil eksekusi ke register <code>d0</code> (ini dibahas pada bagian terpisah di bawah). </li><li>  Byte pada address <code>sp+0x33</code> ( <code>0x00FFFF79</code> , debugger memberitahu kita) disimpan dalam register <code>d1</code> , itu sama dengan byte kedua dari alamat hash utama ( <code>0x00FF0D47</code> ).  Ini mudah dibuktikan jika Anda memecahkan rekor pada <code>0x00FFFF79</code> : ini akan bekerja pada instruksi <code>0x00001F94 move.b 1(a2), 0x2F(sp)</code> .  Register <code>a2</code> pada saat ini menyimpan alamat <code>0x00FF0D46</code> - alamat hash, yaitu, <code>0x1(a2) = 0x00FF0D46 + 1</code> - alamat byte kedua dari hash. </li><li>  Register <code>d0</code> ditulis <code>d0^d1</code> . <br></li><li>  Hasil xor'a yang dihasilkan diberikan ke fungsi <code>sub_E3E</code> , perilaku yang tergantung pada perhitungan sebelumnya (ditampilkan di bawah). </li><li>  Ulangi </li></ol><br>  Berapa kali siklus ini berjalan? <br><br>  Temukan ini.  Jalankan skrip berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto pc_val, d4_val, counter=0; while(pc_val != 0x00001F16) { StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); pc_val = GetRegValue("pc"); if (pc_val == 0x00001F92){ counter++; d4_val = GetRegValue("d4"); print(d4_val); } } print(counter); }</span></span></span></span></code> </pre> <br>  <code>0x00001F92 subq.l 0x1,d4</code> - di sini ditentukan apa yang akan terjadi di <code>d4</code> segera sebelum loop: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/xt/p9/ac/xtp9acx13gq3qrtvnisseyt8lfw.png" alt="gambar"></div><br>  Kami berurusan dengan fungsi sub_5EC. <br><br><h3>  sub_5EC </h3><br>  Sepotong kode yang signifikan: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/fd/uv/xk/fduvxkbfaxne_7eratvlhuqdt8w.png" alt="gambar"></div><br>  di mana <code>0x2c(a2)</code> selalu <code>0x00FF1D74</code> . <br>  Bagian ini dapat ditulis ulang seperti ini di pseudo-code: <br><br><pre> <code class="cpp hljs">d0 = a2 + <span class="hljs-number"><span class="hljs-number">0x2C</span></span> *(a2+<span class="hljs-number"><span class="hljs-number">0x2C</span></span>) = *(a2+<span class="hljs-number"><span class="hljs-number">0x2C</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> #*(<span class="hljs-number"><span class="hljs-number">0x00FF1D74</span></span>) = *(<span class="hljs-number"><span class="hljs-number">0x00FF1D74</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span> result = *(d0) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span></code> </pre> <br>  Yaitu, 4 byte dari <code>0x00FF1D74</code> adalah alamatnya, karena  mereka diperlakukan seperti pointer. <br><br>  Bagaimana cara menulis ulang fungsi <code>sub_5EC</code> dengan python? <br><br><ol><li>  Atau membuat memori dump dan bekerja dengannya. </li><li>  Atau cukup tuliskan semua nilai yang dikembalikan. </li></ol><br>  Metode kedua saya lebih suka, tetapi bagaimana jika, dengan data otorisasi yang berbeda, nilai yang dikembalikan berbeda?  Lihat ini. <br><br>  Script akan membantu dalam hal ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;idc.idc&gt; static main() { auto pc_val=0, d0_val; while(pc_val != 0x00001F16){ pc_val = GetRegValue("pc"); if (pc_val == 0x00001F9C) StepInto(); else StepOver(); GetDebuggerEvent(WFNE_SUSP, -1); if (pc_val == 0x00000674){ d0_val = GetRegValue("d0") &amp; 0xFF; print(d0_val); } } }</span></span></span></span></code> </pre> <br>  Saya baru saja membandingkan keluaran ke konsol dengan kunci berbeda, surat. <br><br>  Menjalankan skrip beberapa kali dengan tombol yang berbeda, kita akan melihat bahwa fungsi <code>sub_5EC</code> selalu mengembalikan nilai berikutnya dari array: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_5EC_gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> dump = [<span class="hljs-number"><span class="hljs-number">0x92</span></span>, <span class="hljs-number"><span class="hljs-number">0x8A</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0x94</span></span>, <span class="hljs-number"><span class="hljs-number">0x3B</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xFC</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xEE</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xDC</span></span>, <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFE</span></span>, <span class="hljs-number"><span class="hljs-number">0x68</span></span>, <span class="hljs-number"><span class="hljs-number">0x4A</span></span>, <span class="hljs-number"><span class="hljs-number">0xBD</span></span>, <span class="hljs-number"><span class="hljs-number">0x91</span></span>, <span class="hljs-number"><span class="hljs-number">0xD5</span></span>, <span class="hljs-number"><span class="hljs-number">0x0A</span></span>, <span class="hljs-number"><span class="hljs-number">0x27</span></span>, <span class="hljs-number"><span class="hljs-number">0xED</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xC2</span></span>, <span class="hljs-number"><span class="hljs-number">0xA5</span></span>, <span class="hljs-number"><span class="hljs-number">0xD6</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xDE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xA6</span></span>, <span class="hljs-number"><span class="hljs-number">0x72</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0x1A</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE7</span></span>, <span class="hljs-number"><span class="hljs-number">0xFA</span></span>, <span class="hljs-number"><span class="hljs-number">0xF7</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xD6</span></span>, <span class="hljs-number"><span class="hljs-number">0x91</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0xB4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xA4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0x09</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0x86</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0xE6</span></span>, <span class="hljs-number"><span class="hljs-number">0xF4</span></span>, <span class="hljs-number"><span class="hljs-number">0xE4</span></span>, <span class="hljs-number"><span class="hljs-number">0xC6</span></span>, <span class="hljs-number"><span class="hljs-number">0xFE</span></span>, <span class="hljs-number"><span class="hljs-number">0xF6</span></span>, <span class="hljs-number"><span class="hljs-number">0x9D</span></span>, <span class="hljs-number"><span class="hljs-number">0x11</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x68</span></span>, <span class="hljs-number"><span class="hljs-number">0x4A</span></span>, <span class="hljs-number"><span class="hljs-number">0xB8</span></span>, <span class="hljs-number"><span class="hljs-number">0xD4</span></span>, <span class="hljs-number"><span class="hljs-number">0xF7</span></span>, <span class="hljs-number"><span class="hljs-number">0xAE</span></span>, <span class="hljs-number"><span class="hljs-number">0xFF</span></span>, <span class="hljs-number"><span class="hljs-number">0x1C</span></span>, <span class="hljs-number"><span class="hljs-number">0xB7</span></span>, <span class="hljs-number"><span class="hljs-number">0x4C</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAD</span></span>, <span class="hljs-number"><span class="hljs-number">0x72</span></span>, <span class="hljs-number"><span class="hljs-number">0x4B</span></span>, <span class="hljs-number"><span class="hljs-number">0xBF</span></span>, <span class="hljs-number"><span class="hljs-number">0xAA</span></span>, <span class="hljs-number"><span class="hljs-number">0x3D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB5</span></span>, <span class="hljs-number"><span class="hljs-number">0x3D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB9</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xD9</span></span>, <span class="hljs-number"><span class="hljs-number">0x7D</span></span>, <span class="hljs-number"><span class="hljs-number">0xB1</span></span>, <span class="hljs-number"><span class="hljs-number">0x13</span></span>, <span class="hljs-number"><span class="hljs-number">0xE1</span></span>, <span class="hljs-number"><span class="hljs-number">0xE1</span></span>, <span class="hljs-number"><span class="hljs-number">0x02</span></span>, <span class="hljs-number"><span class="hljs-number">0x15</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0xA3</span></span>, <span class="hljs-number"><span class="hljs-number">0xB3</span></span>, <span class="hljs-number"><span class="hljs-number">0x88</span></span>, <span class="hljs-number"><span class="hljs-number">0x9E</span></span>, <span class="hljs-number"><span class="hljs-number">0x2C</span></span>, <span class="hljs-number"><span class="hljs-number">0xB0</span></span>, <span class="hljs-number"><span class="hljs-number">0x8F</span></span>] l = len(dump) offset = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> offset &lt; l: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> dump[offset] offset += <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Jadi <code>sub_5EC</code> siap. <br><br>  Baris berikutnya adalah <code>sub_E3E</code> . <br><br><h3>  sub_E3E </h3><br>  Sepotong kode yang signifikan: <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/pc/um/u1/pcumu10pkuhgdcfehysc-hzlbk4.png" alt="gambar"></div><br>  Dekripsi: <br><br><pre> <code class="cpp hljs">   ,   d2,     .  a2   <span class="hljs-number"><span class="hljs-number">0xFF0D46</span></span>, a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span> = <span class="hljs-number"><span class="hljs-number">0xFF0D7A</span></span> d0 = *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) = *(a2 + <span class="hljs-number"><span class="hljs-number">0x34</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>   ,   a0    a0 = d0 *(a0) = d2    offset,     d2.  a2   <span class="hljs-number"><span class="hljs-number">0xFF0D46</span></span>, a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span> = <span class="hljs-number"><span class="hljs-number">0xFF0D6A</span></span> -  ,     (. )  <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>,     d0 = *(a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) d2 = d0 ^ d2 d2 = d2 &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span> d2 = d2 + d2  - <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> + d2,   ROM,   <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> + d2  a0 = <span class="hljs-number"><span class="hljs-number">0x00011FC0</span></span> d2 = *(a0 + d2)       <span class="hljs-number"><span class="hljs-number">8</span></span>  d0 = d0 &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>  d2 = d0 ^ d2     *(a2 + <span class="hljs-number"><span class="hljs-number">0x24</span></span>) = d2</code> </pre> <br>  Fungsi <code>sub_E3E</code> turun ke langkah-langkah ini: <br><br><ol><li>  Simpan argumen input ke array. </li><li>  Hitung offset offset. </li><li>  Tarik 2 byte di alamat <code>0x00011FC0 + offset</code> (ROM). </li><li>  Hasil = <code>(  &gt;&gt; 8) ^ (2  0x00011FC0 + offset)</code> . </li></ol><br>  Bayangkan fungsi <code>sub_E3E</code> dalam formulir ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sub_E3E</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prev_sub_E3E_result, d2, d2_storage)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_offset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> * ((prev_sub_E3E_result ^ d2) &amp; <span class="hljs-number"><span class="hljs-number">0xff</span></span>) d2_storage.append(d2) offset = calc_offset() <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"dump_00011FC0"</span></span>, <span class="hljs-string"><span class="hljs-string">'rb'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> f: dump_00011FC0_4096b = f.read() some = dump_00011FC0_4096b[offset:offset + <span class="hljs-number"><span class="hljs-number">2</span></span>] some = int.from_bytes(some, byteorder=<span class="hljs-string"><span class="hljs-string">"big"</span></span>) prev_sub_E3E_result = prev_sub_E3E_result &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev_sub_E3E_result ^ some</code> </pre> <br>  <code>dump_00011FC0</code> hanyalah sebuah file tempat saya menyimpan 4096 byte dari <code>[0x00011FC0:00011FC0+4096]</code> . <br><br><h2>  Aktivitas sekitar 1FC4 </h2><br>  Kami belum melihat alamat <code>0x00001FC4</code> , tetapi mudah ditemukan, karena blok berjalan hampir segera setelah siklus pertama. <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/rq/qu/4d/rqqu4dswxqemcgszszulcrrc8mc.png" alt="gambar"></div><br>  Blok ini mengubah konten di alamat <code>0x00FF0D46</code> (register <code>a2</code> ), dan di situlah hash kunci disimpan, jadi kami sekarang mempelajari blok ini.  Mari kita lihat apa yang terjadi di sini. <br><br><ol><li>  Kondisi yang menentukan apakah cabang kiri atau kanan dipilih adalah: <code>(   ) &amp; 0b1 != 0</code> .  Yaitu, bit pertama dari hash diperiksa. </li><li>  Jika Anda melihat kedua cabang, Anda akan melihat: <ul><li>  Dalam kedua kasus, pergeseran ke kanan dengan 1 bit terjadi. </li><li>  Di cabang kiri operasi hash dilakukan <code> 0x8000</code> . </li><li>  Dalam kedua kasus, nilai hash yang diproses ditulis ke alamat <code>0x00FF0D46</code> , yaitu, hash diganti dengan nilai baru. </li><li>  Perhitungan lebih lanjut tidak kritis, karena, secara kasar, tidak ada operasi tulis di <code>(a2)</code> (tidak ada instruksi di mana operan kedua akan berada <code>(a2)</code> ). <br></li></ul></li></ol><br>  Bayangkan sebuah blok seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hash_2b)</span></span></span><span class="hljs-function">:</span></span> new = hash_2b &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b &amp; <span class="hljs-number"><span class="hljs-number">0b1</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>: new = new | <span class="hljs-number"><span class="hljs-number">0x8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new</code> </pre> <br><h2>  Loop penting kedua adalah loc_203E </h2><br>  <code>loc_203E</code> - loop, karena  <code>0x0000206C bne.s loc_203E</code> . <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/lg/_-/2k/lg_-2kw8yl2_klsq5azj1mebnzs.png" alt="gambar"></div><br>  Siklus ini menghitung hash dan di sini adalah fitur utamanya: <code>jsr (a0)</code> adalah panggilan ke fungsi <code>sub_E3E</code> yang telah kita periksa - ia bergantung pada hasil sebelumnya dari pekerjaannya sendiri dan pada beberapa masukan argumen (dilewatkan melalui register <code>d2</code> atas, dan di sini melalui <code>d0</code> ) <br><br>  Mari cari tahu apa yang diteruskan padanya melalui register <code>d0</code> . <br><br>  Kami telah bertemu dengan konstruksi <code>0x34(a2)</code> - fungsi <code>sub_E3E</code> menyimpan argumen yang diteruskan di sana.  Ini berarti bahwa argumen yang diteruskan sebelumnya digunakan dalam loop ini.  Tapi tidak semua. <br><br>  Dekripsi bagian kode: <br><br><pre> <code class="cpp hljs">  <span class="hljs-number"><span class="hljs-number">2</span></span>    a2+<span class="hljs-number"><span class="hljs-number">0x1C</span></span> move.w <span class="hljs-number"><span class="hljs-number">0x1C</span></span>(a2), d0  neg.l d0   a0       sub_E3E movea.l <span class="hljs-number"><span class="hljs-number">0x34</span></span>(a2), a0 ,  d0  <span class="hljs-number"><span class="hljs-number">2</span></span>    a0-d0(   d0 ) move.b (a0, d0.l), d0</code> </pre><br>  Intinya adalah tindakan sederhana: pada setiap iterasi, ambil <code>d0</code> argumen yang tersimpan dari akhir array.  Artinya, jika 4 disimpan dalam <code>d0</code> , maka kita mengambil elemen keempat dari akhir. <br><br>  Jika demikian, apa tepatnya yang <code>d0</code> ?  Di sini saya melakukannya tanpa skrip, tetapi cukup menuliskannya, membuat istirahat di awal blok ini.  Inilah mereka: <code>0x04, 0x04, 0x04, 0x1C, 0x1A, 0x1A, 0x06, 0x42, 0x02</code> . <br><br>  Sekarang kita memiliki segalanya untuk menulis fungsi perhitungan hash kunci lengkap. <br><br><h2>  Fungsi perhitungan hash penuh </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish_hash</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hash_2b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#    def transform(hash_2b): new = hash_2b &gt;&gt; 1 if hash_2b &amp; 0b1 != 0: new = new | 0x8000 return new main_cycle_counter = [17, 2, 2, 3, 4, 38, 10, 30, 4] second_cycle_counter = [2, 2, 2, 2, 2, 4, 2, 4, 28] counters = list(zip(main_cycle_counter, second_cycle_counter)) d2_storage = [] storage_offsets = [0x04, 0x04, 0x04, 0x1C, 0x1A, 0x1A, 0x06, 0x42, 0x02] prev_sub_E3E_result = 0x0000 sub_5EC = sub_5EC_gen() for i in range(9): c = counters[i] for _ in range(c[0]): d0 = next(sub_5EC) d1 = hash_2b &amp; 0xff d2 = d0 ^ d1 curr_sub_E3E_result = sub_E3E(prev_sub_E3E_result, d2, d2_storage) prev_sub_E3E_result = curr_sub_E3E_result storage_offset = storage_offsets.pop(0) for _ in range(c[1]): d2 = d2_storage[-storage_offset] curr_sub_E3E_result = sub_E3E(prev_sub_E3E_result, d2, d2_storage) prev_sub_E3E_result = curr_sub_E3E_result hash_2b = transform(hash_2b) return curr_sub_E3E_result</span></span></code> </pre> <br><h3>  Pemeriksaan Kesehatan </h3><br><ol><li>  Dalam debugger, kami menetapkan break ke alamat <code>0x0000180A move.l 0x1000,(sp)</code> (segera setelah perhitungan hash). </li><li>  Istirahat ke alamat <code>0x00001F16 beq.w loc_20EA</code> (perbandingan hash akhir dengan <code>0xCB4C</code> konstan). </li><li>  Di program, masukkan kunci <code>ABCDEFGHIJKLMNOP</code> , tekan <code>Enter</code> . </li><li>  Debugger berhenti di <code>0x0000180A</code> , dan kami melihat bahwa nilai <code>0xFFFF44CC</code> <code>0x44CC</code> register <code>d5</code> , <code>0x44CC</code> adalah hash pertama. </li><li>  Kami memulai debugger lebih lanjut. </li><li>  Kami berhenti di <code>0x00001F16</code> dan melihat bahwa pada <code>0x00FF0D6A</code> terletak <code>0x4840</code> - hash terakhir <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lb/zp/bo/lbzpbohzrioqfs-3h_jj7q5v4sy.png" alt="gambar"></div></li><li>  Sekarang periksa fungsi finish_hash (hash_2b) kami: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>r = finish_hash(<span class="hljs-number"><span class="hljs-number">0x44CC</span></span>) &gt;&gt;&gt; print(hex(r)) <span class="hljs-number"><span class="hljs-number">0x4840</span></span></code> </pre> </li></ol><br><h2>  Kami mencari kunci yang tepat 1 </h2><br>  Kunci yang benar adalah kunci ini yang hash terakhirnya adalah <code>0xCB4C</code> (ditemukan di atas).  Maka pertanyaannya: apa yang harus menjadi hash pertama untuk final menjadi <code>0xCB4C</code> ? <br><br>  Sekarang mudah untuk mengetahuinya: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_CB4C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> result = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hash_2b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>): final_hash = finish_hash(hash_2b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> final_hash == <span class="hljs-number"><span class="hljs-number">0xCB4C</span></span>: result.append(hash_2b) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result &gt;&gt;&gt; r = find_CB4C() &gt;&gt;&gt; print(r)</code> </pre> <br>  Output dari program menunjukkan bahwa hanya ada satu opsi: hash pertama harus <code>0xFEDC</code> . <br><br>  Karakter apa yang kita butuhkan sehingga hash pertama mereka adalah <code>0xFEDC</code> ? <br><br>  Karena <code>0xFEDC = __4_ ^ __4_</code> , Anda hanya perlu menemukan <code>__4_</code> , karena <code>__4_ = __4_ ^ 0xFEDC</code> .  Dan kemudian memecahkan kode kedua hash. <br><br>  Algoritma adalah sebagai berikut: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_first_half</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> pairs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>): pair = (i, i ^ <span class="hljs-number"><span class="hljs-number">0xFEDC</span></span>) pairs.append(pair) pairs = deque(pairs) pairs.rotate(randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list(pairs) pairs = get_pairs() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs: key_4s_0 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]) key_4s_1 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]) hash_2b_0 = get_hash_2b(key_4s_0) hash_2b_1 = get_hash_2b(key_4s_1) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b_0 == pair[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hash_2b_1 == pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_4s_0, key_4s_1</code> </pre> <br>  Banyak pilihan, pilih apa saja. <br><br><h2>  Kami mencari kunci yang tepat 2 </h2><br>  Bagian pertama dari kunci sudah siap, bagaimana dengan yang kedua? <br><br>  Ini adalah bagian yang paling mudah. <br><br>  Sepotong kode yang bertanggung jawab terletak di <code>0x00FF2012</code> , saya mendapatkannya dengan penelusuran manual, dimulai dengan alamat <code>0x00001F16 beg.w loc_20EA</code> (validasi pada paruh pertama kunci).  Dalam register <code>a0</code> adalah alamat email, <code>loc_FF2012</code> adalah sebuah siklus, karena  <code>bne.s loc_FF2012</code> .  Ini dieksekusi selama ada <code>*(a0+d0)</code> (byte surat berikutnya). <br><br>  Dan <code>jsr (a3)</code> memanggil fungsi <code>get_hash_2b</code> sudah dikenal, yang sekarang bekerja dengan bagian kedua kunci. <br><br><div style="text-align:center;"><img src="https://hsto.org/webt/wl/ln/5i/wlln5if5bzqcukbxnvpc_osl5lw.png" alt="gambar"></div><br>  Mari kita buat kode lebih jelas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(d1 != <span class="hljs-number"><span class="hljs-number">0x20</span></span>){    d2++ d1 = d1 &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>     d3 = d3 + d1 d0 = <span class="hljs-number"><span class="hljs-number">0</span></span> d0 = d2    d1 = *(a0+d0) } d0 = get_hash_2b(key_byte_8) d3 = d0^d3 d0 = get_hash_2b(key_byte_12) d2 = d2 - <span class="hljs-number"><span class="hljs-number">1</span></span> d2 = d2 &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> d2 = d0^d2 <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d2 == d3) success_branch</code> </pre> <br>  Dalam register <code>d2</code> - <code>( -1) &lt;&lt; 8</code> .  Di <code>d3</code> , jumlah byte karakter surat. <br><br>  Kriteria kebenaran adalah sebagai berikut: <code>__ ^ d2 == ___2 ^ d3</code> . <br><br>  Kami menulis fungsi pemilihan bagian kedua kunci: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_second_half</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> deque <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> randint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_koeff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> k1 = sum([ord(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> email]) k2 = (len(email) - <span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> k1, k2 <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_pairs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(k1, k2)</span></span></span><span class="hljs-function">:</span></span> pairs = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0xFFFF</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>): pair = (a, (a ^ k1) ^ k2) pairs.append(pair) pairs = deque(pairs) pairs.rotate(randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0xFFFF</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> list(pairs) k1, k2 = get_koeff() pairs = get_pairs(k1, k2) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pair <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pairs: key_4s_0 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">0</span></span>]) key_4s_1 = decode_hash_4s(pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]) hash_2b_0 = get_hash_2b(key_4s_0) hash_2b_1 = get_hash_2b(key_4s_1) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hash_2b_0 == pair[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> hash_2b_1 == pair[<span class="hljs-number"><span class="hljs-number">1</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> key_4s_0, key_4s_1</code> </pre> <br><br><h2>  Keygen </h2><br>  Surat harus dalam batas. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keygen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(email)</span></span></span><span class="hljs-function">:</span></span> first_half = get_first_half() second_half = get_second_half(email) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.join(first_half) + <span class="hljs-string"><span class="hljs-string">""</span></span>.join(second_half) &gt;&gt;&gt; email = <span class="hljs-string"><span class="hljs-string">"M.GAYANOV@GMAIL.COM"</span></span> &gt;&gt;&gt; print(keygen(email)) <span class="hljs-number"><span class="hljs-number">2</span></span>A4FD493BA32AD75</code> </pre> <br><div style="text-align:center;"><img src="https://hsto.org/webt/rp/ja/bo/rpjabo27x0oemehl_380bdoiyto.png" alt="gambar"></div><br>  Terima kasih atas perhatian anda!  Semua kode tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453194/">https://habr.com/ru/post/id453194/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453180/index.html">Bagaimana melakukan perencanaan triwulanan Paperless Terdistribusi dan tidak mengacaukannya?</a></li>
<li><a href="../id453182/index.html">Seluruh dunia di saku Anda atau cara membuat kartu seluler dalam beberapa hari</a></li>
<li><a href="../id453188/index.html">Bagaimana menjelaskan kepada manajer non-IT prinsip-prinsip membangun infrastruktur TI yang toleran terhadap kesalahan</a></li>
<li><a href="../id453190/index.html">ANPR menggunakan RoR & React Native</a></li>
<li><a href="../id453192/index.html">Sinkronisasi dan asinkron proses</a></li>
<li><a href="../id453196/index.html">Forrester Research: Perbandingan Sepuluh Vendor Analisis Komposisi Perangkat Lunak Teratas</a></li>
<li><a href="../id453200/index.html">Diskusi: proyek OpenROAD bermaksud untuk menyelesaikan tugas mengotomatisasi desain prosesor</a></li>
<li><a href="../id453204/index.html">Kontainer, Layanan Mikro, dan Jerat Layanan</a></li>
<li><a href="../id453206/index.html">Wawancara dengan Kelsey Moody: Cara Membangun Perusahaan dan Patologi Terkait Usia Akhir</a></li>
<li><a href="../id453212/index.html">Consumer Reports: Autopilot terbaru Tesla masih jauh dari sempurna</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>