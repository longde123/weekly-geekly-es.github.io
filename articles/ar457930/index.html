<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😂 🍇 🧕🏿 ثابت ديناميكي كتابة à la بيثون 🏳️ 👍 ✡️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا يا هبر. 


 في اليوم الآخر ، في أحد مشاريع هوايتي ، نشأت المهمة في كتابة مستودع للمقاييس. 


 تم حل المهمة نفسها ببساطة شديدة ، ولكن مشكلتي في H...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ثابت ديناميكي كتابة à la بيثون</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457930/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  مرحبا يا هبر. </p><br><p style=";text-align:right;direction:rtl">  في اليوم الآخر ، في أحد مشاريع هوايتي ، نشأت المهمة في كتابة مستودع للمقاييس. </p><br><p style=";text-align:right;direction:rtl">  تم حل المهمة نفسها ببساطة شديدة ، ولكن مشكلتي في Haskell (خاصة في مشاريع الترفيه الخاصة بي) هي أنه من المستحيل تحمل المشكلة وحلها.  من الضروري أن تقرر وتوسع وتُجرِز وتُجرِز ثم تتوسع أكثر.  لذلك ، أردت أن اجعل تخزين المقاييس قابلاً للامتداد حتى لا أحدد مسبقًا ما ستكون عليه.  هذا في حد ذاته موضوع لمقال منفصل ، واليوم سننظر في مكون صغير واحد: كتابة غلاف آمن للنوع لأنواع لم تكن معروفة من قبل.  شيء مثل الكتابة الديناميكية ، ولكن مع ضمانات ثابتة بأننا لن نفعل هراء. </p><br><p style=";text-align:right;direction:rtl">  أعتقد أن المقالة لن تفتح أي شيء جديد على Haskellists ذوي الخبرة ، ولكن الآن سنضع على الأقل هذا العنصر خارج الصندوق ولن نلهيه في مقالات لاحقة.  حسنًا ، أو قد لا تكون متواضعًا جدًا وتقول إنني أتيت بالفعل بنمط تصميم كامل. </p><a name="habracut"></a><br><p style=";text-align:right;direction:rtl">  لذلك ، أولا نحن صياغة المشكلة.  يجب أن نكون قادرين على ربط بعض الكائنات بقيم أنواع غير معروفة سابقًا.  أو بمعنى آخر ، من الضروري أن تعمل قيم الأنواع غير المعروفة سابقًا كمفاتيح في نوع من الخريطة. </p><br><p style=";text-align:right;direction:rtl"> بطبيعة الحال ، لسنا مجانين ولن نطلب دعم القيم من أي نوع.  نطلب أن النوع (حتى لو كان غير معروف) يدعم المقارنة بمعنى الطلب.  في مصطلحات Haskell ، هذا يعني أننا ندعم الأنواع التي تنفذ فئة <code>Ord a</code> . </p><br><p style=";text-align:right;direction:rtl">  لاحظ أننا يمكن أن نطلب الدعم لأخذ علامة التجزئة والتحقق من المساواة ، ولكن لعدد من الأسباب سيكون أكثر ملاءمة وضوحا أن نقتصر على المقارنة. </p><br><p style=";text-align:right;direction:rtl">  عندما يتعلق الأمر بتخزين القيم المعروفة بتطبيق نوع ما من الفصل ، عادة ما تستخدم الأنواع الوجودية في Haskell: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkSomeOrd</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeOrd</span></span></span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  لذلك ، إذا حصلنا على كائن من النوع <code>SomeOrd</code> وقمنا بإجراء مطابقة للنمط له: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foo</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bar</span></span> foo (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val) = ... (<span class="hljs-number"><span class="hljs-number">1</span></span>) ...</code> </pre> <br><p style=";text-align:right;direction:rtl">  ثم عند النقطة <code>(1)</code> لا نعرف نوع <code>val</code> ، لكننا نعرف (والأهم من ذلك ، أن جهاز ضبط الوقت يعرف أيضًا) أن <code>val</code> ينفذ فئة <code>Ord</code> الزمنية. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، إذا كانت وظائف الكتابة للفئة تتضمن وسيطين (أو أكثر) ، فإن استخدام مثل هذا السجل يكون ذا فائدة قليلة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">tryCompare</span></span> :: <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeOrd</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> tryCompare (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val1) (<span class="hljs-type"><span class="hljs-type">MkSomeOrd</span></span> val2) = ?</code> </pre> <br><p style=";text-align:right;direction:rtl">  لاستخدام أساليب <code>Ord</code> ، من الضروري أن تكون <code>val</code> و <code>val2</code> نفس النوع ، لكن هذا لا يجب القيام به على الإطلاق!  اتضح أن <code>SomeOrd</code> لدينا <code>SomeOrd</code> طائل منه.  ماذا تفعل؟ </p><br><p style=";text-align:right;direction:rtl">  على الرغم من حقيقة أن Haskell هي لغة مترجمة ذات محو من النوع العدواني (بعد التحويل البرمجي ، فهي ليست موجودة بشكل عام) ، لا يزال بإمكان المترجم إنشاء ممثلين لنوع وقت التشغيل إذا طلب منهم ذلك.  ممثل دور النوع <code>a</code> هو قيمة النوع <code>TypeRep a</code> و <del>  طلب </del>  يتم الرد على إنشاء جيل من <code>Typeable</code> . </p><br><div class="spoiler" style=";text-align:right;direction:rtl">  <b class="spoiler_title">بالمناسبة</b> <div class="spoiler_text" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl">  بالمناسبة ، ليس من الضروري أن يكون نوع ما بالمعنى المعتاد ، أي أنه ينتمي إلى مجموعة متنوعة <code>*</code> .  يمكن أن يكون أي نوع آخر من <code>k</code> ، والذي يسمح لك نظريًا بالقيام ببعض الأشياء الرائعة من خلال تخزين ممثلي وقت التشغيل من الأنواع المستفادة وما شابه ذلك ، لكنني لم أتمكن من معرفة ما هو بالضبط. </p></div></div><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى ذلك ، إذا كان لدينا <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> من <code>rep1 :: TypeRep a, rep2 :: TypeRep b</code> ، فيمكننا مقارنتهما والتحقق مما إذا كانا يمثلان نفس النوع أم لا.  علاوة على ذلك ، إذا كانوا يمثلون بالفعل نفس النوع ، فمن الواضح أنه يتزامن مع <code>b</code> .  والأهم من ذلك ، ترجع وظيفة التحقق من تمثيلات النوع من أجل المساواة نتيجة يمكن أن تقنع مطبوع هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">eqTypeRep</span></span> :: <span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> k1 k2 (a :: k1) (b :: k2). <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">TypeRep</span></span> b -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> (a :~~: b)</code> </pre> <br><p style=";text-align:right;direction:rtl">  ما هذا الهراء المكتوب هنا؟ </p><br><p style=";text-align:right;direction:rtl">  أولاً ، <code>eqTypeRep</code> هي دالة. </p><br><p style=";text-align:right;direction:rtl">  ثانياً ، إنه متعدد الأشكال ، ولكن ليس فقط حسب النوع ، ولكن أيضًا حسب أنواع مختلفة من هذه الأنواع.  يشار إلى ذلك من خلال الجزء <code>forall k1 k2 (a :: k1) (b :: k2)</code> - وهذا يعني أن <code>a</code> و <code>b</code> لا يمكن أن يكونا فقط الأنواع العادية مثل <code>Int</code> أو <code>[String]</code> ، ولكن أيضًا ، على سبيل المثال ، المنشئات سيئة السمعة (انظر DataKinds ومحاولات أخرى لجعل هاسكل مصدقة).  لكننا لسنا بحاجة إلى كل هذا. </p><br><p style=";text-align:right;direction:rtl">  ثالثًا ، يقبل عرضين لوقت التشغيل لأنواع مختلفة محتملة ، <code>TypeRep a</code> و <code>TypeRep b</code> . </p><br><p style=";text-align:right;direction:rtl">  رابعا ، تقوم بإرجاع قيمة نوع <code>Maybe (a :~~: b)</code> .  الشيء الأكثر إثارة للاهتمام يحدث هنا. </p><br><p style=";text-align:right;direction:rtl">  إذا لم تتطابق الأنواع ، فسوف تُرجع الدالة <code>Nothing</code> المعتادة ، وكل شيء على ما يرام.  إذا كانت الأنواع متطابقة ، فسوف تُرجع الدالة <code>Just val</code> ، حيث يكون <code>val</code> من النوع <code>a :~~: b</code> .  دعونا نرى ما هو نوع: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- | Kind heterogeneous propositional equality. Like ':~:', @a :~~: b@ is -- inhabited by a terminating value if and only if @a@ is the same type as @b@. -- -- @since 4.10.0.0 data (a :: k1) :~~: (b :: k2) where HRefl :: a :~~: a</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن دعنا نتحدث.  لنفترض أننا حصلنا على قيمة <code>val</code> من النوع <code>a :~~: b</code> .  كيف يمكن بناءه؟  الطريقة الوحيدة هي مع مُنشئ <code>HRefl</code> ، وهذا المُنشئ يتطلب ذلك على جانبي الرمز <code>:~~:</code> يجب أن يكون هو نفسه.  لذلك ، يتزامن مع <code>b</code> .  علاوة على ذلك ، إذا كنا zapternnom- مباراة على <code>val</code> ، فإن taypcheker سوف تعرف عن ذلك أيضا.  لذلك ، نعم ، تقوم دالة <code>eqTypeRep</code> بإرجاع دليل على أن نوعين مختلفين يحتمل أن <code>eqTypeRep</code> إذا كانا متساويين بالفعل. </p><br><p style=";text-align:right;direction:rtl">  ومع ذلك ، في الفقرة أعلاه ، كذبت.  لا أحد يمنعنا <em>من الكتابة في هاسكل</em> شيء من هذا القبيل </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = wrong <span class="hljs-comment"><span class="hljs-comment">--   </span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  أو </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">wrong</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> :~~: <span class="hljs-type"><span class="hljs-type">String</span></span> wrong = undefined</code> </pre> <br><p style=";text-align:right;direction:rtl">  أو كسر النظام مع مجموعة من الطرق أقل وضوحا قليلا.  هذا هو واحد من مظاهر المعروفة في دوائر ضيقة قائلا أن هاسكل غير متناسق مع المنطق.  في اللغات ذات أنظمة الكتابة الأقوى ، لا يتم ختم هذه التعريفات. </p><br><p style=";text-align:right;direction:rtl">  هذا هو السبب في قطعة من الوثائق المذكورة أعلاه ، <em>يتم</em> ذكر <em>قيمة الإنهاء</em> .  كلا الخيارين لتطبيق <code>wrong</code> أعلاه لا ينتج عن هذه القيمة النهائية للغاية ، مما يعطينا القليل من السبب والثقة: إذا تم <em>إنهاء</em> برنامجنا على Haskell (ولم يتم تشغيله إلى <code>undefined</code> ) ، فإن نتائجه تتوافق مع الأنواع المكتوبة.  ومع ذلك ، هناك بعض التفاصيل المتعلقة بالكسل ، لكننا لن نفتح هذا الموضوع. </p><br><p style=";text-align:right;direction:rtl">  وبالمناسبة ، فإن المظهر الثاني لضعف Haskell في الكود أعلاه هو نوع وظيفة <code>eqTypeRep</code> .  في اللغات الأقوى ، ستُرجع قيمة نوع أقوى ، وهذا لن يثبت فقط المساواة في الأنواع إذا كانت متساوية بالفعل ، ولكن سيثبت أيضًا <em>عدم المساواة</em> إذا كانت غير متساوية بالفعل.  ومع ذلك ، فإن عدم تناسق منطق هاسكل يجعل هذه الوظائف عديمة الجدوى: من الأهمية بمكان أن تستخدم اللغة كدليل على النظريات ، وليس كلغة برمجة ، ولا تستخدم هاسكل كدليل. </p><br><p style=";text-align:right;direction:rtl">  حسنًا ، بما يكفي من نظرية السجل والنوع ، دعنا نعود إلى مقاييسنا. <del>  الآن فقط ارسم بومة </del>  تشير المناقشة أعلاه إلى أنه يكفي تخزين هذا النوع من الوجود أيضًا ، وهذا هو أفضل تمثيل للنوع ، وسيكون كل شيء على ما يرام. </p><br><p style=";text-align:right;direction:rtl">  هذا يقودنا إلى التنفيذ التالي لنوع المجمع: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  نكتب الآن وظيفة تأخذ ما يلي: </p><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  قيمتين من النوع <code>Dyn</code> ؛ </li><li style=";text-align:right;direction:rtl">  وظيفة تنتج شيئا لقيمتين من <em>أي نوع</em> ، <br>  بناءً فقط على الثوابت المذكورة عند إنشاء <code>Dyn</code> ( <code>forall</code> مسؤول عن ذلك) ، <br>  والذي يسمى إذا كانت كل القيم مخزن <code>Dyn</code> من نفس النوع ؛ </li><li style=";text-align:right;direction:rtl">  والدالة الاحتياطية ، والتي تسمى بدلاً من الوظيفة السابقة ، إذا كانت الأنواع لا تزال مختلفة: </li></ol><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">withDyns</span></span> :: (<span class="hljs-keyword"><span class="hljs-keyword">forall</span></span> a. <span class="hljs-type"><span class="hljs-type">Ord</span></span> a =&gt; a -&gt; a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Dyn</span></span> -&gt; b withDyns f def (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty1 v1) (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> ty2 v2) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eqTypeRep ty1 ty2 <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; def (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty1) (<span class="hljs-type"><span class="hljs-type">SomeTypeRep</span></span> ty2) <span class="hljs-type"><span class="hljs-type">Just</span></span> <span class="hljs-type"><span class="hljs-type">HRefl</span></span> -&gt; f v1 v2</code> </pre> <br><p style=";text-align:right;direction:rtl">  <code>SomeTypeRep</code> عبارة عن مجمّع وجودي عبر <code>TypeRep a</code> لأي. </p><br><p style=";text-align:right;direction:rtl">  الآن يمكننا تنفيذ ، على سبيل المثال ، فحص المساواة والمقارنة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> <span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p style=";text-align:right;direction:rtl">  لقد <code>SomeTypeRep</code> هنا من حقيقة أن <code>SomeTypeRep</code> يمكن مقارنتها مع بعضها البعض ، لذلك تتم مقارنة الوظيفة الاحتياطية <code>SomeTypeRep</code> أيضًا. </p><br><p style=";text-align:right;direction:rtl">  القيام به. </p><br><p style=";text-align:right;direction:rtl">  الآن فقط من الخطيئة عدم التعميم: نلاحظ أنه في <code>Dyn</code> و <code>toDyn</code> و <code>withDyns</code> لا نستخدم <code>Ord</code> وجه التحديد ، وقد يكون هذا أي مجموعة أخرى من الثوابت ، لذلك يمكننا تمكين امتداد <code>ConstraintKinds</code> <em>وتعميمه</em> عن طريق تحديد <code>Dyn</code> محددة من القيود التي اللازمة في مهمتنا المحددة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> :: ctx a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TypeRep</span></span></span><span class="hljs-class"> a -&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn :: (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Typeable</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; a -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx toDyn val = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typeOf</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) val withDyns :: (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forall</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> =&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">b</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> ctx -&gt; b withDyns (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">v2</span></span></span><span class="hljs-class">) f def = case eqTypeRep ty1 ty2 of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> -&gt; def (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty1</span></span></span><span class="hljs-class">) (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeTypeRep</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ty2</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">HRefl</span></span></span><span class="hljs-class"> -&gt; f v1 v2</span></span></code> </pre> <br><p style=";text-align:right;direction:rtl">  عندئذٍ سيكون <code>Dyn Ord</code> نوع <code>Dyn Monoid</code> ، على سبيل المثال ، سيتيح لك <code>Dyn Monoid</code> التعسفية والقيام بشيء أحادي. </p><br><p style=";text-align:right;direction:rtl">  دعنا نكتب الحالات التي نحتاجها <code>Dyn</code> جديد: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns compare compare</code> </pre> <br><p style=";text-align:right;direction:rtl">  ... هذا فقط لا يعمل.  لا يعرف typecher أن <code>Dyn Ord</code> ينفذ أيضًا <code>Eq</code> ، <br>  لذلك عليك نسخ التسلسل الهرمي بأكمله: </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Eq</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (==) = withDyns d1 d2 (==) (\_ _ -&gt; <span class="hljs-type"><span class="hljs-type">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span> (<span class="hljs-type"><span class="hljs-type">Dyn</span></span> <span class="hljs-type"><span class="hljs-type">Ord</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> compare = withDyns d1 d2 compare compare</code> </pre> <br><p style=";text-align:right;direction:rtl">  حسنا ، الآن بالتأكيد. </p><br><p style=";text-align:right;direction:rtl">  ... ربما ، في Haskell الحديثة ، يمكنك إجراؤها بحيث يعرض المؤقت نفسه مثيلات النموذج </p><br><pre style=";text-align:right;direction:rtl"> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_i</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Dyn</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_1</span></span></span><span class="hljs-class">, ... </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">C_n</span></span></span><span class="hljs-class">)) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> ...</code> </pre> <br><p style=";text-align:right;direction:rtl">  نظرًا لوجود شيء ما غير منطقي ، لكنني لم أفعل ذلك بعد ، سيتعين علي الجلوس لاختياره.  ترقبوا. </p><br><p style=";text-align:right;direction:rtl">  وأيضًا ، إذا قمت بالتحديق بعناية ، يمكنك أن ترى أن <code>Dyn</code> لدينا تبدو بشكل <code>Dyn</code> للريبة مثل زوج تابع من النوع <code>(ty : Type ** val : ty)</code> من اللغات المشفرة.  ولكن فقط باللغات المعروفة لي ، من المستحيل مطابقة النوع ، لأنه يتم تفسير المعلمة (والتي في هذه الحالة ، IMHO ، على نطاق واسع للغاية) ، ولكن هنا يبدو ممكنًا. </p><br><p style=";text-align:right;direction:rtl">  لكن الشيء الأكثر أهمية - الآن يمكنك الحصول على شيء مثل <code>Map (Dyn Ord) SomeValue</code> واستخدام أي قيم كمفاتيح ، طالما أنها نفسها تدعم المقارنة.  على سبيل المثال ، يمكن استخدام المعرفات ذات الأوصاف المترية كمفاتيح ، ولكن هذا موضوع للمقال التالي. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar457930/">https://habr.com/ru/post/ar457930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar457906/index.html">يعتقد الأطباء أنه في المستقبل القريب ، ستظهر أجهزة صنع اللقاحات في المنازل والصيدليات</a></li>
<li><a href="../ar457910/index.html">WebFPGA - تطوير Verilog في المتصفح</a></li>
<li><a href="../ar457916/index.html">حل WorldSkills مهام وحدة الشبكة في اختصاص "التقييم القطري المشترك". الجزء 2 - الإعداد الأساسي</a></li>
<li><a href="../ar457926/index.html">مقارنة شهادة Agile ، الجزء 1 - ICAgile و Scrum.org و ScrumAlliance و PMI</a></li>
<li><a href="../ar457928/index.html">الترتيب العميق لمقارنة صورتين</a></li>
<li><a href="../ar457932/index.html">تحليل مسابقة IDS Bypass في الايجابية Hack Days 9</a></li>
<li><a href="../ar457936/index.html">نحن ندعوك لحضور مؤتمر Zabbix الأول في روسيا</a></li>
<li><a href="../ar457940/index.html">كيفية النظير في الطرف المقابل</a></li>
<li><a href="../ar457942/index.html">ما تعلمته عن التحسين في بيثون</a></li>
<li><a href="../ar457946/index.html">أفضل 10 مكتبات JavaScript لتصور البيانات على الرسوم البيانية والمخططات</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>