<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüç≥ üë®‚Äçüíª üë®‚Äçüë®‚Äçüëß‚Äçüë¶ Arend - idioma do tipo dependente baseado no HoTT (parte 1) üôÜüèæ üçÇ üö£üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nesta postagem, falaremos sobre o idioma JetBrains rec√©m-lan√ßado com tipos dependentes do Arend (o idioma √© nomeado ap√≥s o Gating Rent ). Este idioma ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arend - idioma do tipo dependente baseado no HoTT (parte 1)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/JetBrains-education/blog/469569/"> Nesta postagem, falaremos sobre o idioma JetBrains rec√©m-lan√ßado com tipos dependentes do Arend (o idioma √© nomeado ap√≥s o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gating Rent</a> ).  Este idioma foi desenvolvido pela <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JetBrains Research</a> nos √∫ltimos anos.  Embora os reposit√≥rios de um ano atr√°s tenham sido disponibilizados publicamente no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github.com/JetBrains</a> , o lan√ßamento completo do Arend aconteceu apenas em julho deste ano. <br><br>  Vamos tentar dizer como o Arend difere dos sistemas existentes de matem√°tica formalizada com base em tipos dependentes e que funcionalidade est√° agora dispon√≠vel para seus usu√°rios.  Supomos que o leitor deste artigo geralmente esteja familiarizado com os tipos dependentes e tenha ouvido pelo menos um dos idiomas com base nos tipos dependentes: Agda, Idris, Coq ou Lean.  No entanto, n√£o esperamos que o leitor tenha tipos dependentes em um n√≠vel avan√ßado. <br><br>  Para simplificar e concretizar, nossa hist√≥ria sobre os tipos Arend e homotopia ser√° acompanhada pela implementa√ß√£o no Arend do algoritmo mais simples de classifica√ß√£o de listas - mesmo com este exemplo, voc√™ pode sentir a diferen√ßa entre Arend e Agda e Coq.  J√° existem v√°rios artigos sobre Habr√© dedicados a tipos dependentes.  Digamos que sobre a implementa√ß√£o de listas de classifica√ß√£o usando o m√©todo QuickSort na Agda, existe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esse artigo</a> .  Implementaremos um algoritmo mais simples para classificar as inser√ß√µes.  Nesse caso, focaremos nas constru√ß√µes da linguagem Arend, e n√£o no pr√≥prio algoritmo de classifica√ß√£o. <br><a name="habracut"></a><br>  Portanto, a principal diferen√ßa entre Arend e outras l√≠nguas com tipos dependentes √© a teoria l√≥gica na qual ela se baseia.  Arend utiliza como tal a teoria do tipo de homotopia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">V. Voevodsky</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">HoTT</a> ), recentemente descoberta.  Mais especificamente, o Arend √© baseado em uma varia√ß√£o do HoTT chamada "teoria dos tipos com espa√ßamento".  Lembre-se de que Coq √© baseado no chamado c√°lculo de constru√ß√µes indutivas (C√°lculo de Constru√ß√µes Indutivas), enquanto Agda e Idris s√£o baseados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">teoria do tipo intensional de Martin-L√∂f</a> .  O fato de o Arend ser baseado no HoTT afeta significativamente suas constru√ß√µes sint√°ticas e a opera√ß√£o do algoritmo de verifica√ß√£o de tipo (typcheker).  Vamos discutir esses recursos neste artigo. <br><br>  Vamos tentar descrever brevemente o estado da infraestrutura de idiomas.  Para o Arend, existe um plug-in para o IntelliJ IDEA, que pode ser instalado diretamente no reposit√≥rio de plug-ins do IDEA.  Em princ√≠pio, instalar o plug-in √© suficiente para funcionar totalmente com o Arend, voc√™ ainda n√£o precisa baixar e instalar nada.  Al√©m da verifica√ß√£o de tipo, o plug-in Arend fornece funcionalidade familiar aos usu√°rios do IDEA: h√° destaque e alinhamento do c√≥digo, v√°rias refatora√ß√µes e dicas.  Tamb√©m h√° a op√ß√£o de usar a vers√£o do console do Arend.  Uma descri√ß√£o mais detalhada do processo de instala√ß√£o pode ser encontrada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  Os exemplos de c√≥digo deste artigo s√£o baseados na biblioteca padr√£o do Arend, portanto, recomendamos o download do c√≥digo-fonte do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reposit√≥rio</a> .  Ap√≥s o download, o diret√≥rio de origem deve ser importado como um projeto da IDEA usando o comando Importar Projeto.  Em Arend, algumas se√ß√µes da teoria dos tipos de homotopia e teoria dos an√©is j√° foram formalizadas.  Por exemplo, na biblioteca padr√£o, h√° uma implementa√ß√£o do anel de n√∫meros racionais Q, juntamente com provas de todas as propriedades te√≥ricas do anel necess√°rias. <br><br>  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> detalhada do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">idioma</a> , na qual muitos dos pontos abordados neste artigo s√£o explicados em mais detalhes, tamb√©m √© de dom√≠nio p√∫blico.  Voc√™ pode fazer perguntas diretamente aos desenvolvedores da Arend no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">canal de telegrama</a> . <br><br><h2>  1. Vis√£o geral do HoTT / Arend </h2><br>  A teoria dos tipos de homotopia (ou, em suma, HoTT) √© um tipo de teoria dos tipos intensional que difere da teoria cl√°ssica de Martin-L√∂f (MLTT, na qual a Agda se baseia) e do c√°lculo de constru√ß√µes indutivas (CIC, na qual a Coq se baseia), em que, juntamente com instru√ß√µes e conjuntos cont√™m os chamados tipos de um n√≠vel mais alto de homotopia. <br><br>  Neste artigo, n√£o estabelecemos o objetivo de explicar em detalhes os fundamentos do HoTT - para uma exposi√ß√£o detalhada dessa teoria, seria necess√°rio recontar todo o livro (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">este post</a> ).  Observamos apenas que uma teoria baseada na axiomatica da HoTT √©, de certa forma, muito mais elegante e interessante do que a teoria cl√°ssica do tipo Martin-L√∂f.  Assim, um n√∫mero de axiomas que anteriormente precisavam ser postulados adicionalmente (por exemplo, extensionalidade funcional) s√£o provados no HoTT como teoremas.  Al√©m disso, no HoTT, √© poss√≠vel definir internamente esferas de homotopia multidimensionais e at√© contar alguns de seus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">grupos de homotopia</a> . <br><br>  No entanto, esses aspectos do HoTT s√£o principalmente interessantes para os matem√°ticos, e o objetivo deste artigo √© explicar como o Arend baseado no HoTT se compara favoravelmente com o Agda / MLTT e o Coq / CIC pelo exemplo de representar t√£o simples e familiar a qualquer entidade programadora como as listas ordenadas.  Ao ler este artigo, basta tratar o HoTT como um tipo de teoria intensional de tipos com uma axiomatica mais desenvolvida, o que oferece comodidade ao trabalhar com universos e igualdades. <br><br><h2>  1.1 Tipos dependentes, correspond√™ncia de Curry - Howard, universos </h2><br>  Lembre-se de que linguagens com tipos dependentes diferem das linguagens de programa√ß√£o funcional comuns, pois al√©m dos tipos de dados comuns, como listas ou n√∫meros naturais, existem tipos dependendo do valor do par√¢metro.  Os exemplos mais simples de tais tipos s√£o vetores de um determinado comprimento n ou √°rvores balanceadas de uma determinada profundidade d.  Alguns exemplos adicionais desses tipos s√£o mencionados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui.</a> <br><br>  Lembre-se de que a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">correspond√™ncia de Curry-Howard</a> permite interpretar afirma√ß√µes da l√≥gica como tipos dependentes.  A id√©ia principal dessa correspond√™ncia √© que um tipo vazio corresponde a uma declara√ß√£o falsa e os tipos preenchidos correspondem a uma declara√ß√£o verdadeira.  Os elementos de tipo podem ser considerados como provas da declara√ß√£o l√≥gica correspondente.  Por exemplo, qualquer elemento como n√∫meros inteiros pode ser considerado uma prova do fato de existirem n√∫meros inteiros (ou seja, o tipo de n√∫meros inteiros √© preenchido). <br><br>  Diferentes constru√ß√µes naturais sobre tipos correspondem a diferentes conectivos l√≥gicos: <br><br><ul><li>  <i>O produto dos tipos A √ó B</i> √†s vezes √© chamado de tipo de par Par A B. Como esse tipo √© preenchido se e somente se ambos os tipos A e B forem preenchidos, essa constru√ß√£o corresponde ao ‚Äúe‚Äù l√≥gico. </li><li>  <i>A soma dos tipos A + B.</i> Em Haskell, esse tipo √© chamado de A B. Como esse tipo √© preenchido se e somente se um dos tipos A ou B for preenchido, essa constru√ß√£o corresponde a um ‚Äúou‚Äù l√≥gico. <br></li><li>  <i>Tipo funcional A ‚Üí B.</i>  Qualquer fun√ß√£o desse tipo converte elementos de A em elementos de B. Portanto, essa fun√ß√£o existe exatamente quando a exist√™ncia de um elemento do tipo A implica na exist√™ncia de um elemento do tipo B. Portanto, essa constru√ß√£o corresponde √† implica√ß√£o. <br></li></ul><br>  Suponha agora que recebemos um certo tipo A e uma fam√≠lia de tipos B parametrizados por um elemento a do tipo A. Vamos dar exemplos de constru√ß√µes mais complexas sobre tipos dependentes. <br><br><ul><li>  <i>Tipo de fun√ß√£o dependente</i> <b>Œ†</b> (a: A) (B a).  Esse tipo coincide com o tipo funcional usual A ‚Üí B se B for independente de A. Uma fun√ß√£o do tipo <b>Œ†</b> (a: A) (B a) converte qualquer elemento a do tipo A em um elemento do tipo B a.  Assim, essa fun√ß√£o existe se, e somente se, <i>para qualquer a</i> : A, existe um elemento B a.  Portanto, essa constru√ß√£o corresponde ao quantificador universal ‚àÄ.  Para o tipo funcional dependente, Arend usa a sintaxe <code><b>\Pi</b> (x : A) -&gt; B a</code> , e o termo que habita esse tipo pode ser constru√≠do usando a express√£o lambda <code><b>\lam</b> (a : A) =&gt; f a.</code> </li><li>  <i>O tipo de pares dependentes √© <b>Œ£</b> (a: A) (B a).</i>  Esse tipo coincide com os tipos usuais de pares A √ó B se B for independente de A. O tipo <b>Œ£</b> (a: A) (B a) √© preenchido exatamente quando <i>existe</i> um elemento a: A e um elemento do tipo B a.  Assim, este tipo corresponde ao quantificador de exist√™ncia <code>‚àÉ</code> .  O tipo de pares dependentes em Arend √© indicado por <code>\Sigma (a : A) (B a)</code> , e os termos que o habitam s√£o constru√≠dos usando o construtor do par <code>(a, b)</code> <i>dependente)</i> <code>(a, b)</code> . <br></li><li>  <i>O tipo de igualdade √©</i> a = a ', onde a e a' s√£o dois elementos de algum tipo A. Esse tipo √© preenchido se a e a 'forem iguais e, caso contr√°rio, estar√° vazio.  Obviamente, esse tipo √© um an√°logo do predicado de igualdade na l√≥gica. </li></ul><br>  Nesse ponto, encaminhamos o leitor a fontes nas quais a correspond√™ncia Curry - Howard √© discutida em mais detalhes (veja, por exemplo, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">curso de palestras</a> ou artigos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> ). <br><br>  Todas as express√µes consideradas na teoria dos tipos devem ter algum tipo.  Como express√µes que denotam tipos tamb√©m s√£o consideradas na estrutura dessa teoria, elas tamb√©m precisam receber um determinado tipo.  A quest√£o √©: que tipo de tipo deve ser? <br><br>  A primeira decis√£o ing√™nua que vem √† mente √© atribuir a todos os tipos um tipo formal <code>\Type</code> , chamado de <i>universo</i> (√© chamado porque cont√©m todos os tipos em geral).  Se usarmos esse universo, as constru√ß√µes de soma e produtos de tipo mencionados acima receber√£o a assinatura <code>\Type ‚Üí \Type ‚Üí \Type</code> , e constru√ß√µes mais complexas do produto dependente e a soma dependente receber√£o a assinatura <code><b>Œ†</b> (A : \Type) ‚Üí ((A ‚Üí \Type) ‚Üí \Type)</code> . <br><br>  Nesse ponto, surge a pergunta: que tipo o pr√≥prio universo <code>\Type</code> deve ter?  Uma tentativa ing√™nua de dizer que o tipo de universo <code>\Type</code> , por defini√ß√£o, √© <code>\Type</code> si leva ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paradoxo de Girard</a> ; portanto, em vez de um √∫nico universo <code>\Type</code> considere uma <i>hierarquia</i> infinita <i>de universos</i> , ou seja,  a cadeia aninhada de universos <code>\Type 1 &lt; \Type 2 &lt; ‚Ä¶</code> , cujos n√≠veis s√£o numerados por n√∫meros naturais, e o tipo de universo <code>\Type i</code> , por defini√ß√£o, √© o universo <code>\Type (i+1)</code> .  Para as constru√ß√µes de tipo mencionadas acima, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">assinaturas</a> mais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">complexas</a> tamb√©m precisam ser introduzidas. <br><br>  Assim, s√£o necess√°rios universos na teoria dos tipos para que qualquer express√£o tenha um determinado tipo.  Em algumas variedades da teoria dos tipos, os universos s√£o usados ‚Äã‚Äãpara outro prop√≥sito: distinguir entre variedades de tipos.  J√° vimos que conjuntos e declara√ß√µes s√£o casos especiais de tipos.  Isso mostra que pode fazer sentido introduzir na teoria um universo Prop separado para declara√ß√µes e uma hierarquia separada de universos Set <sub>i</sub> para conjuntos.  Essa √© exatamente a abordagem usada em C√°lculo de constru√ß√µes indutivas, a teoria na qual o sistema Coq se baseia. <br><br><h2>  1.2 Exemplos de tipos indutivos mais simples e fun√ß√µes recursivas </h2><br>  Considere as defini√ß√µes em Arend dos tipos de dados indutivos mais simples: tipo booleano, tipo de n√∫mero natural e listas polim√≥rficas.  Arend usa a palavra-chave <code>\data</code> para introduzir novos tipos indutivos. <br><br> <code>\data Empty --  ,    <br> <br> \data Bool <br> | true <br> | false <br> <br> \data Nat <br> | zero <br> | suc Nat <br> <br> \data List (A : \Set) <br> | nil <br> | \infixr 5 :-: A (List A)</code> <br> <br>  Como voc√™ pode ver nos exemplos acima, ap√≥s a palavra-chave <code>\data</code> , voc√™ precisa especificar o nome do tipo indutivo e uma lista de seus construtores.  Ao mesmo tempo, o tipo de dados e os construtores podem ter alguns par√¢metros.  Digamos que no exemplo acima o tipo de <code>List</code> tenha um par√¢metro <code>A</code>  O construtor <code>nil</code> list n√£o possui par√¢metros, e o construtor: -: possui dois par√¢metros (um dos quais √© do tipo <code>A</code> e o outro √© do tipo <code>List A</code> ).  O universo <code>\Set</code> consiste em tipos que s√£o conjuntos (a defini√ß√£o de conjuntos ser√° fornecida na pr√≥xima se√ß√£o).  A <code>\infixr</code> permite que voc√™ use a nota√ß√£o infix para o construtor: -: e, al√©m disso, informa ao analisador Arend que o operador: -: √© uma opera√ß√£o associativa correta com prioridade 5. <br><br>  No Arend, todas as palavras-chave come√ßam com um caractere de barra invertida (‚Äú\‚Äù), uma implementa√ß√£o inspirada no LaTeX.  Observe que as regras lexicais no Arend s√£o muito liberais: <code>Circle_HSpace, contrFibers=&gt;Equiv, suc/=0, zro_*-left</code> e even <code>n:Nat</code> - todos esses literais s√£o exemplos de identificadores v√°lidos no Arend.  O exemplo final mostra como √© importante para o usu√°rio do Arend <i>lembrar de colocar espa√ßos entre identificadores e caracteres de dois pontos</i> .  Observe que nos identificadores Arend n√£o √© permitido usar caracteres Unicode (em particular, voc√™ n√£o pode usar cir√≠lico). <br><br>  Arend usa a palavra-chave <code>\func</code> para definir fun√ß√µes.  A sintaxe dessa constru√ß√£o √© a seguinte: ap√≥s a palavra-chave <code>\func</code> , √© necess√°rio especificar o nome da fun√ß√£o, seus par√¢metros e o tipo do valor de retorno.  O elemento final na defini√ß√£o de uma fun√ß√£o √© seu corpo. <br><br>  Se for poss√≠vel especificar explicitamente a express√£o na qual a fun√ß√£o especificada deve ser calculada, para indicar o corpo da fun√ß√£o, o token =&gt; ser√° usado.  Considere, por exemplo, a defini√ß√£o de uma fun√ß√£o de nega√ß√£o de tipo. <br><br><pre> <code class="plaintext hljs">\func Not (A : \Type) : \Type =&gt; A -&gt; Empty</code> </pre> <br>  O tipo de retorno de uma fun√ß√£o nem sempre precisa ser especificado explicitamente.  No exemplo acima, o Arend seria capaz de inferir independentemente o tipo <code>Not</code> , e poder√≠amos omitir a express√£o ‚Äú: <code>\Type</code> ‚Äù ap√≥s os colchetes. <br><br>  Como na maioria dos sistemas matem√°ticos formalizados, o usu√°rio n√£o precisa especificar um n√≠vel preditivo expl√≠cito para o universo <code>\Type</code> , e as defini√ß√µes nas quais os universos s√£o usados ‚Äã‚Äãsem especificar explicitamente um n√≠vel preditivo s√£o consideradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">polim√≥rficas</a> . <br><br>  Agora vamos tentar definir uma fun√ß√£o que calcula o comprimento da lista.  Essa fun√ß√£o √© f√°cil de identificar atrav√©s da correspond√™ncia de padr√µes.  Arend usa a palavra-chave <code>\elim</code> para isso.  Depois disso, voc√™ deve especificar as vari√°veis ‚Äã‚Äãpelas quais a compara√ß√£o √© executada (se houver mais de uma vari√°vel, elas devem ser escritas com v√≠rgula).  Se a compara√ß√£o for realizada para todos os par√¢metros expl√≠citos, <code>\elim</code> junto com as vari√°veis ‚Äã‚Äãpoder√£o ser omitidos.  Isto √© seguido por um bloco de pontos de compara√ß√£o, separados um do outro por uma barra vertical "|".  Cada item deste bloco √© uma express√£o da forma <code>¬´,    ¬ª =&gt; ¬´¬ª</code> . <br><br><pre> <code class="plaintext hljs">\func length {A : \Set} (l : List A) : Nat | nil =&gt; 0 | :-: x xs =&gt; suc (length xs)</code> </pre> <br>  No exemplo acima, o par√¢metro A da fun√ß√£o <code>length</code> √© cercado por chaves.  Esses colchetes no Arend s√£o usados ‚Äã‚Äãpara denotar argumentos impl√≠citos, ou seja,  argumentos que o usu√°rio pode omitir ao chamar uma fun√ß√£o ou usar um tipo.  Observe que no Arend voc√™ n√£o pode usar nota√ß√£o de infixo para designar construtores ao corresponder a um padr√£o, portanto, a nota√ß√£o de prefixo √© usada no exemplo de amostra. <br><br>  Como em Coq / Agda, em Arend, todas as fun√ß√µes devem ter a garantia de conclus√£o (ou seja, a verifica√ß√£o de encerramento est√° presente em Arend).  Na defini√ß√£o da fun√ß√£o length, essa verifica√ß√£o √© bem-sucedida, pois uma chamada recursiva reduz estritamente o primeiro argumento expl√≠cito.  Se essa redu√ß√£o n√£o ocorrer, a Arend enviar√° uma mensagem de erro. <br><br><pre> <code class="plaintext hljs">\func bad : Nat =&gt; bad [ERROR] Termination check failed for function 'bad' In: bad</code> </pre> <br>  O Arend permite depend√™ncias circulares e fun√ß√µes recursivas mutuamente para as quais tamb√©m s√£o realizadas verifica√ß√µes de conclus√£o.  O algoritmo dessa verifica√ß√£o √© implementado com base no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo de</a> A. Abel.  Nele, voc√™ encontrar√° uma descri√ß√£o mais detalhada das condi√ß√µes que as fun√ß√µes recursivas mutuamente devem satisfazer. <br><br><h2>  1.3 Como os conjuntos diferem das declara√ß√µes? </h2><br>  Escrevemos anteriormente que exemplos de tipos s√£o conjuntos e instru√ß√µes.  Al√©m disso, usamos as palavras-chave <code>\Type</code> e <code>\Set</code> para indicar universos em Arend.  Nesta se√ß√£o, tentaremos explicar com mais detalhes como as declara√ß√µes diferem dos conjuntos em termos de variedades da teoria dos tipos intensional (MLTT, CIC, HoTT) e, ao mesmo tempo, explicar em que consiste o significado das palavras-chave <code>\Prop</code> , <code>\Set</code> e <code>\Type</code> in Arend. <br><br>  Lembre-se de que na teoria cl√°ssica de Martin-L√∂f n√£o h√° separa√ß√£o de tipos em conjuntos e declara√ß√µes.  Em particular, em teoria, existe apenas um universo cumulativo (que √© indicado por Set em Agda, ou Type em Idris, ou Sort in Lean).  Essa abordagem √© a mais simples, mas h√° situa√ß√µes em que suas defici√™ncias se manifestam.  Suponha que estamos tentando implementar o tipo "lista ordenada" como um par dependente que consiste em uma lista e prova de sua ordena√ß√£o.  Acontece que, ent√£o, no √¢mbito do MLTT ‚Äúpuro‚Äù, n√£o ser√° poss√≠vel provar a igualdade de listas ordenadas que consistem em elementos id√™nticos, que ao mesmo tempo diferem em termos de prova de pedido.  Ter tal igualdade seria muito natural e desej√°vel, de modo que a impossibilidade de provar isso pode ser considerada uma falha te√≥rica no MLTT. <br><br>  No Agda, esse problema √© parcialmente resolvido com a ajuda das chamadas anota√ß√µes de imaterialidade (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fonte</a> , na qual o exemplo da lista √© discutido em mais detalhes).  Essas anota√ß√µes, no entanto, n√£o s√£o uma constru√ß√£o da teoria do MLTT, nem s√£o constru√ß√µes completas dos tipos (√© imposs√≠vel marcar com uma anota√ß√£o de tipo que n√£o √© usada no argumento da fun√ß√£o). <br><br>  No CIC, com base no CIC, existem dois universos diferentes aninhados um ao outro: <code>Prop</code> (o universo de instru√ß√µes) e <code>Set</code> (o universo de conjuntos), imersos na hierarquia abrangente dos universos de <code>Type</code> .  A principal diferen√ßa entre <code>Prop</code> e <code>Set</code> √© que existem v√°rias restri√ß√µes em vari√°veis ‚Äã‚Äãcujo tipo pertence a <code>Prop</code> na Coq.  Por exemplo, eles n√£o podem ser usados ‚Äã‚Äãem c√°lculos, e a compara√ß√£o com a amostra para eles √© poss√≠vel apenas dentro da evid√™ncia de outras declara√ß√µes.  Por outro lado, todos os elementos do tipo pertencente ao universo <code>Prop</code> s√£o iguais no axioma da evid√™ncia inconseq√ºente, consulte a declara√ß√£o em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Coq.Logic.ProofIrrelevance</a> .  Usando esse axioma, poder√≠amos facilmente provar a igualdade das listas ordenadas mencionadas acima. <br><br>  Por fim, considere a abordagem Arend / HoTT para declara√ß√µes e universos.  A principal diferen√ßa √© que o HoTT dispensa o axioma da evid√™ncia inconseq√ºente.  Ou seja, n√£o existe um axioma especial no HoTT que postule que todos os elementos das declara√ß√µes s√£o iguais.  Mas no HoTT, um tipo, <i>por defini√ß√£o</i> , √© uma afirma√ß√£o se for poss√≠vel provar que todos os seus elementos s√£o iguais entre si.  Podemos definir um predicado em tipos que s√£o verdadeiros se o tipo for uma declara√ß√£o: <br><br><pre> <code class="plaintext hljs">\func isProp (A : \Type) =&gt; \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  Surge a pergunta: que tipos satisfazem esse predicado, isto √©, s√£o declara√ß√µes?  √â f√°cil verificar se isso √© verdade para os tipos vazio e singleton.  Para tipos em que h√° pelo menos dois elementos diferentes, isso n√£o ser√° mais verdadeiro. <br><br>  Obviamente, queremos que todos os conectivos l√≥gicos necess√°rios sejam definidos sobre as instru√ß√µes.  Na Se√ß√£o 1.1, j√° discutimos como eles podem ser determinados usando constru√ß√µes te√≥ricas de tipo.  No entanto, existe o seguinte problema: nem todas as opera√ß√µes inseridas mant√™m a propriedade <code>isProp</code> .  Constru√ß√µes do produto dos tipos e do tipo funcional (dependente) mant√™m essa propriedade, enquanto as constru√ß√µes da soma dos tipos e pares dependentes n√£o.  Assim, n√£o podemos usar a disjun√ß√£o e o quantificador da exist√™ncia. <br><br>  Esse problema pode ser resolvido com a ajuda de uma nova constru√ß√£o, que √© adicionada ao HoTT, o chamado <i>truncamento proposicional</i> .  Esse design permite transformar qualquer tipo em uma instru√ß√£o.  Pode ser considerada uma opera√ß√£o formal, igualando todos os termos que habitam esse tipo.  Essa opera√ß√£o √© um pouco semelhante √†s anota√ß√µes de imaterialidade da Agda, no entanto, ao contr√°rio delas, √© uma opera√ß√£o completa em tipos com assinatura <code>\Type -&gt; \Prop</code> . <br><br>  O √∫ltimo exemplo importante de instru√ß√µes √© a igualdade de dois elementos de algum tipo.  Acontece que, no caso geral, o tipo de igualdade <code>a = a'</code> n√£o precisa ser uma declara√ß√£o.  Os tipos para os quais ele √© um s√£o chamados de conjuntos: <br><br><pre> <code class="plaintext hljs">\func isSet (A : \Type) =&gt; \Pi (aa' : A) -&gt; isProp (a = a')</code> </pre> <br>  Todos os tipos encontrados em linguagens de programa√ß√£o comuns atendem a esse predicado, ou seja, a igualdade entre eles √© uma declara√ß√£o.  Por exemplo, isso √© verdade para n√∫meros naturais, n√∫meros inteiros, produtos de conjuntos, somas de conjuntos, fun√ß√µes sobre conjuntos, listas de conjuntos e outros tipos de dados indutivos constru√≠dos a partir de conjuntos.  Isso significa que, se estamos interessados ‚Äã‚Äãapenas em constru√ß√µes familiares, n√£o podemos pensar em tipos arbitr√°rios que n√£o satisfazem esse predicado.  Todos os tipos encontrados em Coq s√£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjuntos</a> . <br><br>  Tipos que n√£o s√£o conjuntos tornam-se √∫teis se voc√™ deseja lidar com a teoria de tipos de homotopia.  Por enquanto, simplesmente referimos o leitor ao <a href="">m√≥dulo de</a> biblioteca padr√£o que cont√©m a defini√ß√£o de uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esfera n-dimensional</a> , um exemplo de um tipo que n√£o √© um conjunto. <br><br>  Arend possui universos especiais <code>\Prop</code> e <code>\Set</code> , consistindo em instru√ß√µes e conjuntos, respectivamente.  Se j√° sabemos que o tipo A est√° contido no universo <code>\Prop</code> (ou <code>\Set</code> ), a prova da <code>isSet</code> <code>isProp</code> (ou <code>isSet</code> ) correspondente no Arend pode ser obtida usando o axioma <code>Path.inProp</code> incorporado no <a href="">prel√∫dio</a> (damos um exemplo de como usar esse axioma na se√ß√£o 2.3). <br><br><pre> <code class="plaintext hljs">\func inProp {A : \Prop} : \Pi (aa' : A) -&gt; a = a'</code> </pre> <br>  J√° observamos que nem todas as constru√ß√µes naturais nos tipos mant√™m a propriedade <code>isProp</code> .  Por exemplo, tipos de dados indutivos com dois ou mais construtores nunca o satisfazem.  Como observado acima, podemos usar o construto de <i>truncamento proposicional</i> que transforma qualquer tipo em uma declara√ß√£o. <br>  Na biblioteca Arend, a implementa√ß√£o padr√£o do truncamento proposicional √© chamada <code>Logic.TruncP</code> .  Poder√≠amos definir um tipo de "ou" l√≥gico em Arend como truncando a soma dos tipos: <br><br><pre> <code class="plaintext hljs">\data \fixr 2 Or (AB : \Type) -- Sum of types; analogue of Coq's type "sum" | inl A | inr B \func \infixr 2 || (AB : \Type) =&gt; TruncP (sum AB) -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/"</code> </pre> <br>  Em Arend, existe outra maneira, mais simples e mais conveniente de definir um tipo indutivo proposicionalmente truncado.  Para fazer isso, basta adicionar a palavra-chave <code>\truncated</code> antes de definir o tipo de dados.  Por exemplo, a defini√ß√£o de um "ou" l√≥gico na biblioteca padr√£o do Arend √© fornecida da seguinte maneira. <br><br><pre> <code class="plaintext hljs">\truncated \data \infixr 2 || (AB : \Type) : \Prop -- Logical ‚Äúor‚Äù, analogue of Coq's type "\/" | byLeft A | byRight B</code> </pre> <br>  Trabalhos futuros com tipos proposicionalmente truncados se assemelham aos tipos atribu√≠dos ao universo <code>Prop</code> na Coq.  Por exemplo, a correspond√™ncia de padr√µes de uma vari√°vel cujo tipo √© uma instru√ß√£o √© permitida apenas em uma situa√ß√£o em que o tipo da express√£o que est√° sendo definida √© ela pr√≥pria uma instru√ß√£o.  Assim, √© sempre f√°cil definir a fun√ß√£o <code>Or-to-||</code>  atrav√©s da compara√ß√£o com a amostra, mas a fun√ß√£o inversa a ela, apenas se o tipo A <code>`Or`</code> B for uma declara√ß√£o (o que √© raro o suficiente, por exemplo, quando os tipos <code>A</code> e <code>B</code> s√£o declara√ß√µes e se excluem mutuamente). <br><br><pre> <code class="plaintext hljs">\func Or-to-|| {AB : \Prop} (a-or-b : A `Or` B) : A || B | inl a =&gt; byLeft a | inr b =&gt; byRight</code> </pre> <br>  Lembre-se tamb√©m de que a peculiaridade do mecanismo dos universos em Coq √© que, se alguma defini√ß√£o foi atribu√≠da ao universo <code>Prop</code> , de maneira alguma ser√° poss√≠vel us√°-la no c√°lculo.  Por esse motivo, os pr√≥prios desenvolvedores da Coq <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√£o recomendam o</a> uso de constru√ß√µes proposicionais, mas aconselham a substitu√≠-las por an√°logos do universo de conjuntos, se poss√≠vel.  O mecanismo dos universos Arend n√£o tem essa desvantagem, ou seja, em certas situa√ß√µes √© poss√≠vel usar declara√ß√µes nos c√°lculos.  Vamos dar um exemplo dessa situa√ß√£o quando discutirmos a implementa√ß√£o do algoritmo de classifica√ß√£o de lista. <br><br><h2>  1.4 Classes em Arend </h2><br>  Como nosso objetivo √© implementar o algoritmo de classifica√ß√£o mais simples, parece √∫til familiarizar-se com a implementa√ß√£o de conjuntos ordenados dispon√≠veis na biblioteca padr√£o do Arend. <br><br>  No Arend, as classes s√£o usadas para encapsular opera√ß√µes e axiomas que definem estruturas matem√°ticas e tamb√©m para destacar os relacionamentos entre essas estruturas usando heran√ßa.  Classes tamb√©m s√£o espa√ßos de nomes, dentro dos quais √© conveniente colocar constru√ß√µes e teorias que sejam apropriadas em significado. <br><br>  A classe base da qual todas as classes de ordem no Arend s√£o herdadas √© a classe <code>BaseSet</code> , que n√£o cont√©m nenhum membro al√©m da designa√ß√£o <code>E</code> para o conjunto de hosts (ou seja, o conjunto no qual <code>BaseSet</code> descendentes de <code>BaseSet</code> j√° introduzem v√°rias opera√ß√µes).  Considere a defini√ß√£o dessa classe da biblioteca Arend padr√£o. <br><br><pre> <code class="plaintext hljs">\class BaseSet (E : \Set) -- ,    </code> </pre> <br>  Na defini√ß√£o acima, a transportadora <code>E</code> declarada um par√¢metro de classe.  Pode-se perguntar, existe uma diferen√ßa na defini√ß√£o acima de <code>BaseSet</code> da defini√ß√£o a seguir, em qual operadora E √© definida como um campo de classe? <br><br><pre> <code class="plaintext hljs">\class BaseSet' --      | E : \Set</code> </pre> <br>  Uma resposta ligeiramente inesperada √© que em Arend <i>n√£o h√° diferen√ßa</i> entre as duas defini√ß√µes no sentido de que qualquer par√¢metro de classe (mesmo impl√≠cito) em Arend, de fato, <i>√©</i> seu campo.  Portanto, para ambas <code>BaseSet</code> implementa√ß√µes <code>BaseSet</code> , pode-se usar a express√£o <code>xE</code> para acessar o campo E. <code>BaseSet</code> uma diferen√ßa entre as variantes acima da defini√ß√£o <code>BaseSet</code> , mas √© mais sutil, vamos examin√°-la com mais detalhes na pr√≥xima se√ß√£o quando discutirmos as inst√¢ncias de classe ( inst√¢ncias de classe). <br><br>  A opera√ß√£o de classifica√ß√£o de uma lista s√≥ faz sentido se uma ordem linear for especificada no tipo de objetos da lista; portanto, primeiro consideramos as defini√ß√µes de um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto parcialmente ordenado estrito</a> e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conjunto ordenado linearmente.</a> <br><br><pre> <code class="plaintext hljs">\class StrictPoset \extends BaseSet { | \infix 4 &lt; : E -&gt; E -&gt; \Prop | &lt;-irreflexive (x : E) : Not (x &lt; x) | &lt;-transitive (xyz : E) : x &lt; y -&gt; y &lt; z -&gt; x &lt; z } \class LinearOrder \extends StrictPoset { | &lt;-comparison (xyz : E) : x &lt; z -&gt; x &lt; y || y &lt; z | &lt;-connectedness (xy : E) : Not (x &lt; y) -&gt; Not (y &lt; x) -&gt; x = y }</code> </pre> <br>  Do ponto de vista da teoria dos tipos, as classes em Arend podem ser consideradas como an√°logos dos tipos sigma, com uma sintaxe mais conveniente para proje√ß√µes e construtores.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais precisamente, qualquer classe Arend pode ser considerada como um tipo sigma, cujos componentes s√£o todos os campos n√£o realizados da classe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o tipo de campo for uma instru√ß√£o, esse campo ser√° chamado de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . As propriedades diferem dos campos, pois suas implementa√ß√µes nunca s√£o avaliadas. Por exemplo, no campo StrictPoset </font></font><code>&lt;-irreflexive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>&lt;-transitive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o propriedades e campo </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- n√£o. As propriedades proporcionam um aumento not√°vel na produtividade, pois suas implementa√ß√µes (que, em ess√™ncia, s√£o provas dessas propriedades) geralmente s√£o grandes, mas geralmente n√£o faz sentido calcul√°-las. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para implementar o algoritmo de classifica√ß√£o, n√£o basta ter um conjunto ordenado; voc√™ tamb√©m precisa saber que esse pedido √© decid√≠vel. O fato √© que o Arend usa</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matem√°tica construtiva</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o que significa que nem todos os predicados nela s√£o decid√≠veis. </font><font style="vertical-align: inherit;">Em particular, a igualdade de elementos n√£o pode ser resolvida por nenhum tipo. </font><font style="vertical-align: inherit;">Por exemplo, isso √© verdade para n√∫meros inteiros, mas n√£o para muitas fun√ß√µes sobre n√∫meros inteiros, pois √© imposs√≠vel determinar por algoritmo se duas fun√ß√µes s√£o iguais ou n√£o. </font><font style="vertical-align: inherit;">Podemos definir uma classe de conjuntos com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">igualdade decid√≠vel da</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seguinte maneira:</font></font><br><br><pre> <code class="plaintext hljs">\class DecSet \extends BaseSet | decideEq (xy : E) : Dec (x = y)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um predicado √© </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definido sobre as instru√ß√µes de uma maneira que </font></font><code>Dec E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seja verdadeira se e somente se for </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decid√≠vel, ou seja, quando qualquer uma das </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nega√ß√µes </font><font style="vertical-align: inherit;">for verdadeira </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="plaintext hljs">\data Dec (E : \Prop) | yes E | no (Not E)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, considere a classe </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(da palavra decid√≠vel) do m√≥dulo </font></font><code>Order.LinearOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A classe Dec implementa ordens lineares solucion√°veis ‚Äã‚Äãe, em particular, cont√©m o axioma que precisamos </font></font><code>trichotomy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, significando que quaisquer dois elementos do tipo </font></font><code>E</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√£o compar√°veis ‚Äã‚Äãem rela√ß√£o √† ordem &lt;. Assim, </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser considerado como um an√°logo da interface Comparable de Java.</font></font><br><br><pre> <code class="plaintext hljs">\class Dec \extends LinearOrder, DecSet { | trichotomy (xy : E) : (x = y) || (x &lt; y) || (y &lt; x) | &lt;-comparison xyz x&lt;z =&gt; {?} --   | &lt;-connectedness xyx/&lt;yy/&lt;x =&gt; {?} | decideEq xy =&gt; {?} }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O nome da classe </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coincide com o nome do tipo de dados j√° apresentado acima </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no entanto, um aparente conflito de designa√ß√£o n√£o ocorre, pois a biblioteca padr√£o cont√©m essa classe em um espa√ßo para nome diferente. Vamos us√°- </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lo para designar a classe, e n√£o o tipo de dados com o mesmo nome. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Axiomas de ordem linear seguem os axiomas da tricotomia, por isso √© l√≥gico verificar imediatamente esses axiomas dentro da classe </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(na lista acima, omitimos essas evid√™ncias por brevidade). O exemplo </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mostra que em Arend a heran√ßa m√∫ltipla √© permitida ( </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ao mesmo tempo √© descendente de </font><font style="vertical-align: inherit;">) </font></font><code>LinearOrder,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>DecSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, al√©m disso, at√© a heran√ßa de diamante √© permitida.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para heran√ßa romboide, h√° a seguinte restri√ß√£o natural: o mesmo campo pode ser implementado em dois ancestrais diferentes somente se essas implementa√ß√µes coincidirem (ou se o campo for uma propriedade, pois a implementa√ß√£o √© ignorada neste caso). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ selecionar uma classe </font></font><code>Dec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no m√≥dulo </font></font><code>Order.LinearOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e solicitar √† IDEA que mostre a hierarquia da classe (geralmente isso √© feito pressionando [Ctrl] + [H]), voc√™ obter√° uma √°rvore semelhante √† figura abaixo. </font></font><br><br><img src="https://habrastorage.org/webt/zu/sd/p3/zusdp3ojbuxbuhs11ffqppfjm04.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste ponto, sugerimos que voc√™ estude independentemente a hierarquia de classes completa da biblioteca padr√£o da Arend (para isso, basta pedir √† IDEA para mostrar todos os subtipos </font></font><code>BaseSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Como voc√™ pode ver, essa hierarquia j√° √© muito extensa.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1.5 Inst√¢ncias de classe, convers√£o de tipos, campos de classifica√ß√£o e sobrecarga do operador. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora vamos tentar criar uma inst√¢ncia da classe de ordem estrita </font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o tipo de n√∫meros naturais Nat. No Arend, voc√™ s√≥ pode instanciar uma classe para classes que possuem todos os campos implementados. Se seguirmos a analogia entre classes e tipos sigma, a classe cujos campos s√£o todos implementados corresponder√° a um tipo sigma vazio (ou seja, um tipo singleton) e a cria√ß√£o de uma inst√¢ncia da classe corresponder√° ao valor √∫nico desse tipo singleton. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Come√ßamos definindo a ordem e a evid√™ncia de suas propriedades mais simples: antirreflexividade e transitividade. Ambas as propriedades s√£o facilmente comprovadas por indu√ß√£o em compara√ß√£o com a amostra.</font></font><br><br><pre> <code class="plaintext hljs">data \infix 4 &lt; (ab : Nat) \with | zero, suc _ =&gt; zero&lt;suc_ | suc a, suc b =&gt; suc&lt;suc (a &lt; b) \lemma irreflexivity (x : Nat) (p : x &lt; x) : Empty | suc a, suc&lt;suc a&lt;a =&gt; irreflexivity a a&lt;a \lemma transitivity (xyz : Nat) (p : x &lt; y) (q : y &lt; z) : x &lt; z | zero, suc y', suc z', zero&lt;suc_, suc&lt;suc y'&lt;z' =&gt; zero&lt;suc_ | suc x', suc y', suc z', suc&lt;suc x'&lt;y', suc&lt;suc y'&lt;z' =&gt; suc&lt;suc (transitivity x' y' z' x'&lt;y' y'&lt;z')</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nos exemplos acima, em vez da palavra-chave, </font></font><code>\func</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usamos </font></font><code>\lemma</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Os lemas se referem √†s fun√ß√µes da mesma maneira que as propriedades da classe se relacionam aos campos da classe, ou seja, as express√µes para eles nunca s√£o avaliadas, e isso aumenta o desempenho. Como nas propriedades da classe, a palavra-chave </font></font><code>\lemma</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode ser usada apenas se o tipo do resultado da fun√ß√£o pertencer ao universo </font></font><code>\Prop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No exemplo acima </font></font><code>x'&lt;y'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- um nome claro para a vari√°vel de amostra, que √© uma prova de desigualdade </font></font><code>x' &lt; y'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Continuaremos a usar nomes semelhantes para vari√°veis ‚Äã‚Äãde amostra (ou seja, nomes que coincidam com o registro sem espa√ßos de instru√ß√µes, cuja prova s√£o essas vari√°veis). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos criar uma inst√¢ncia da classe</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. O Arend possui v√°rias op√ß√µes de sintaxe diferentes para isso. A primeira maneira de instanciar uma classe √© usar uma palavra-chave </font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro de qualquer express√£o. Nesse caso, uma "inst√¢ncia de classe an√¥nima" ser√° criada.</font></font><br><br><pre> <code class="plaintext hljs">\func NatOrder =&gt; \new StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma express√£o </font></font><code>StrictPoset { ‚Ä¶ }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m faz sentido sem uma palavra </font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">chave </font><font style="vertical-align: inherit;">: nesse caso, denota uma classe de extens√£o an√¥nima </font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. N√£o √© necess√°rio implementar todos os campos em classes de extens√£o an√¥nimas; no entanto, como mencionado acima, a opera√ß√£o </font></font><code>\new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o pode ser </font><font style="vertical-align: inherit;">aplicada a uma classe implementada incompletamente </font><font style="vertical-align: inherit;">. Uma express√£o de exibi√ß√£o </font></font><code>\new C { ‚Ä¶ }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tem um tipo </font></font><code>C { ‚Ä¶ }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Como esse tipo √© descendente de C, tamb√©m possui o tipo C. Portanto, no exemplo acima, √© verdade que </font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© uma inst√¢ncia da classe </font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J√° observamos acima que os campos de classe n√£o s√£o diferentes dos par√¢metros de classe. Em particular, do ponto de vista da representa√ß√£o interna, express√£o </font></font><code>StrictPoset Nat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o √© diferente de express√£o </font></font><code>StrictPoset { | E =&gt; Nat }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Observe que poder√≠amos indicar o tipo de fun√ß√£o </font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e isso n√£o seria considerado um erro devido √†s regras comuns de subtipagem (o descendente da classe pode ser usado em vez do pai). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma maneira alternativa de definir uma inst√¢ncia de uma classe </font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© usar uma palavra-chave </font></font><code>\cowith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no cabe√ßalho da fun√ß√£o (nesse caso, o tipo da fun√ß√£o deve ser especificado e ser algum tipo de classe).</font></font><br><br><pre> <code class="plaintext hljs">\func NatOrder : StrictPoset \cowith { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por fim, vejamos outra maneira de definir uma inst√¢ncia de uma classe usando a palavra-chave </font></font><code>\instance.</code> <br><br><pre> <code class="plaintext hljs">\instance NatOrder : StrictPoset { | E =&gt; Nat | &lt; =&gt; &lt; | &lt;-irreflexive =&gt; irreflexivity | &lt;-transitive =&gt; transitivity }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arend implementa um algoritmo para localizar inst√¢ncias de classe, semelhante ao da linguagem Haskell. A implementa√ß√£o da fun√ß√£o </font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por meio da palavra-chave √© </font></font><code>\instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semelhante √† implementa√ß√£o </font></font><code>\cowith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e difere dela apenas no sentido em que essa fun√ß√£o ser√° usada durante a pesquisa de inst√¢ncias da classe </font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(discutiremos as inst√¢ncias logo abaixo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembre-se de que, na implementa√ß√£o </font></font><code>BaseSet</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">da biblioteca padr√£o, o conjunto de portadoras E √© definido como um par√¢metro de classe (e n√£o como um campo), e dissemos na √∫ltima se√ß√£o que essa implementa√ß√£o tem alguma diferen√ßa em rela√ß√£o √† implementa√ß√£o de E como um campo de classe. Agora, comentaremos essa diferen√ßa com mais detalhes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencionamos que os par√¢metros de classe do ponto de vista da implementa√ß√£o interna de Arend n√£o s√£o diferentes dos campos de classe. </font><font style="vertical-align: inherit;">No entanto, Arend concorda que o primeiro argumento expl√≠cito de classe n√£o √© convertido por padr√£o em um campo de classe, mas em um campo de classificador (esta conven√ß√£o funciona se o " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de classificador</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " n√£o for explicitamente selecionado pelo usu√°rio usando uma palavra-chave </font></font><code>\classifying \field</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, uma classe em Arend pode ter apenas um campo classificador). </font><font style="vertical-align: inherit;">Os campos de classifica√ß√£o da classe t√™m as seguintes propriedades:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arend pode implicitamente converter inst√¢ncias de uma classe para o tipo de seu classificador, referindo-se ao projetor correspondente. </font><font style="vertical-align: inherit;">Por exemplo, se </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiver um tipo </font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a express√£o estar√° </font></font><code>List X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completamente correta e corresponder√° ao valor da express√£o </font></font><code>List XE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br></li><li> Arend          . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos primeiro explicar por que as inst√¢ncias s√£o necess√°rias. Suponha que implementamos, por meio de uma constru√ß√£o com uma palavra-chave, </font></font><code>\instance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v√°rias inst√¢ncias da classe </font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para v√°rios tipos de dados, por exemplo, para n√∫meros naturais </font></font><code>Nat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font><font style="vertical-align: inherit;">n√∫meros </font><font style="vertical-align: inherit;">inteiros </font></font><code>Int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(chamaremos inst√¢ncias constru√≠das </font></font><code>NatOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>IntOrder</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argumenta-se que agora √© poss√≠vel usar a nota√ß√£o </font></font><code>x &lt; y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para indicar a ordem, tanto no caso em que x, y s√£o n√∫meros naturais quanto no caso em que x, y s√£o n√∫meros inteiros. No primeiro caso, o Arend determinar√° automaticamente o que se entende </font></font><code>NatOrder.&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e, no segundo - </font></font><code>IntOrder.&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora, explicamos com mais detalhes como o algoritmo de pesquisa de inst√¢ncia funciona. Arend determina que o campo &lt;seja inserido na classe</font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no qual o campo E. √© declarado como o campo classificador.Em seguida, Arend calcula o tipo de argumento da express√£o </font></font><code>x&lt;y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e tenta encontrar no escopo atual a inst√¢ncia da classe </font></font><code>StrictPoset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou seu descendente) na qual o campo classificador E √© do tipo desejado. Se uma inst√¢ncia desse tipo for encontrada, a implementa√ß√£o do campo </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° obtida dessa inst√¢ncia. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que a convers√£o autom√°tica de uma classe para um tipo de seu campo de classifica√ß√£o √© apenas um caso especial de um mecanismo de convers√£o de tipo mais geral no Arend. Para permitir a convers√£o impl√≠cita de um tipo para outro, √© necess√°rio usar um design especial </font></font><code>\use \coerce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo associado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> desta defini√ß√£o. No Arend, cada defini√ß√£o possui o chamado </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√≥dulo associado.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- algum espa√ßo para nome usado para colocar v√°rias constru√ß√µes auxiliares nele. Para adicionar outras defini√ß√µes ao m√≥dulo de defini√ß√£o associado, a palavra-chave √© usada </font></font><code>\where</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considere o exemplo mais simples de uso de um mecanismo de convers√£o de tipo. A fun√ß√£o </font></font><code>fromNat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ser√° usada para converter implicitamente n√∫meros naturais em n√∫meros inteiros.</font></font><br><br><pre> <code class="plaintext hljs">\data Int | pos Nat | neg Nat \with { zero =&gt; pos zero } \where { \use \coerce fromNat (n : Nat) =&gt; pos n }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A sintaxe da declara√ß√£o √© </font></font><code>\use \coerce</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semelhante </font></font><code>\func</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† diferen√ßa de que essa fun√ß√£o deve ter apenas um argumento expl√≠cito. </font><font style="vertical-align: inherit;">Nesse caso, o tipo do resultado ou o tipo de um √∫nico argumento da fun√ß√£o deve coincidir com a defini√ß√£o √† qual o m√≥dulo fornecido est√° associado (claro, isso √© poss√≠vel apenas para os m√≥dulos associados √†s defini√ß√µes de classes ou tipos de dados indutivos). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postado por </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Sinchuk,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pesquisador S√™nior </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, HoTT Group e Tipos de Dependentes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> da JetBrains Research.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469569/">https://habr.com/ru/post/pt469569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469551/index.html">VDS com uma placa de v√≠deo - sabemos muito sobre pervers√µes</a></li>
<li><a href="../pt469555/index.html">Transmiss√£o: Moscow Kubernetes Meetup # 6</a></li>
<li><a href="../pt469557/index.html">Visualiza√ß√£o do Reciclador Gen√©rico ou como n√£o escrever c√≥digo padr√£o</a></li>
<li><a href="../pt469561/index.html">C√°lculo da raiz quadrada inteira</a></li>
<li><a href="../pt469567/index.html">Hist√≥rico: detalhes sobre o iPhone 11, 11 Pro e o novo Apple Watch ap√≥s duas semanas de testes</a></li>
<li><a href="../pt469573/index.html">Linux Piter 2019: o que aguarda os convidados para uma confer√™ncia Linux em larga escala e por que n√£o deve ser desperdi√ßada</a></li>
<li><a href="../pt469575/index.html">Como reprogramar o modo de suspens√£o: 30 dias todas as manh√£s brilhava uma luz verde nos meus olhos</a></li>
<li><a href="../pt469577/index.html">An√°lise forense de disco, an√°lise forense de mem√≥ria e an√°lise forense de log. Estrutura de volatilidade e aut√≥psia. Solu√ß√£o de problemas com r0ot-mi. Parte 1</a></li>
<li><a href="../pt469581/index.html">An√°lise de Efeito Picabu</a></li>
<li><a href="../pt469583/index.html">OpenVPN e Active Directory (Kerberos sem certificados de usu√°rio)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>