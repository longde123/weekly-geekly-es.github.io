<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏽 🍇 👨🏿‍💼 Grundlegendes zu JavaScript-Versprechen 👨🏽‍🎤 🙌🏼 🚣🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Habr! Ich präsentiere Ihnen die Übersetzung des Artikels „Versprechen in JavaScript verstehen“ von Sukhjinder Arora. 



 Vom Autor der Übe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zu JavaScript-Versprechen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439746/">  Guten Tag, Habr!  Ich präsentiere Ihnen die Übersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">„Versprechen in JavaScript verstehen“</a> von Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>Vom Autor der Übersetzung: Neben dem Autor selbst hoffe ich, dass der Artikel für Sie nützlich war.</i>  <i>Bitte, wenn sie Ihnen wirklich geholfen hat, etwas Neues für sich selbst zu lernen, dann seien Sie nicht zu faul, um zum Originalartikel zu gehen und dem Autor zu danken!</i>  <i>Ich freue mich über Ihr Feedback!</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Übersetzung des Artikels über asynchrones JavaScript desselben Autors</a> .</i> <br><br>  JavaScript ist eine Single-Threaded-Programmiersprache, was bedeutet, dass jeweils eine Aufgabe ausgeführt werden kann.  Vor ES6 haben wir Rückrufe verwendet, um asynchrone Aufgaben wie Netzwerkanforderungen zu verwalten. <br><br>  Mit Versprechungen können wir „Höllenrückrufe“ vermeiden und unseren Code sauberer, lesbarer und verständlicher machen. <br><br>  Angenommen, wir möchten einige Daten asynchron vom Server abrufen und mithilfe von Rückrufen Folgendes tun: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Hier <i>fordere</i> ich einige Daten vom Server mit der Funktion <i>getData () an</i> , die Daten innerhalb der Rückruffunktion empfängt.  Innerhalb der Rückruffunktion <i>fordere</i> ich zusätzliche Daten an, indem <i>ich die</i> Funktion <i>getMoreData () aufrufe</i> , die vorherigen Daten als Argument übergebe und so weiter. <br><br>  Dies ist das, was wir als "Rückrufhölle" bezeichnen, bei der jeder Rückruf in den anderen verschachtelt ist und jeder interne Rückruf von seinem übergeordneten Element abhängt. <br><br>  Wir können das obige Snippet mit Versprechungen umschreiben: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  Sie können sehen, was besser lesbar geworden ist als beim ersten Rückrufbeispiel. <br><br><h2>  Was sind Versprechen? </h2><br>  Ein Versprechen (Promise) ist ein Objekt, das den zukünftigen Wert einer asynchronen Operation enthält.  Wenn Sie beispielsweise einige Daten vom Server anfordern, verspricht Promis, diese Daten zu erhalten, die wir in Zukunft verwenden können. <br><br>  Bevor wir uns mit all diesen technischen Dingen befassen, schauen wir uns die Terminologie der Versprechen an. <br><br><h3>  Versprechen Staaten </h3><br>  Ein Versprechen in JavaScript hat wie ein Versprechen im wirklichen Leben drei Zustände.  Dies kann 1) ungelöst (ausstehend), 2) gelöst / gelöst (abgeschlossen) oder 3) abgelehnt / abgelehnt sein. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>Ungelöst oder ausstehend</b> - Promis wartet, wenn das Ergebnis nicht fertig ist.  Das heißt, es erwartet den Abschluss von etwas (zum Beispiel den Abschluss einer asynchronen Operation). <br>  <b>Gelöst oder abgeschlossen</b> - Promis wurden aufgelöst, wenn das Ergebnis verfügbar ist.  Das heißt, etwas hat seine Ausführung abgeschlossen (zum Beispiel eine asynchrone Operation) und alles ist gut gelaufen. <br>  <b>Abgelehnt</b> - Promis abgelehnt, wenn während der Ausführung ein Fehler aufgetreten ist. <br><br>  Jetzt wissen wir, was Promis und seine Terminologie sind. Kehren wir zum praktischen Teil der Versprechen zurück. <br><br><h3>  Promis erstellen </h3><br>  In den meisten Fällen verwenden Sie einfach Versprechen und erstellen sie nicht. Es ist jedoch wichtig zu wissen, wie sie erstellt werden. <br><br>  Syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  Wir haben mit dem Promises-Konstruktor ein neues Versprechen erstellt. Es wird ein Argument verwendet, ein Rückruf, der auch als ausführende Funktion bezeichnet wird. Dabei werden zwei Rückrufe ausgeführt, aufgelöst und <i>abgelehnt</i> . <br><br>  Die Exekutivfunktion wird unmittelbar nach der Erstellung des Versprechens ausgeführt.  Ein Versprechen wird durch Aufrufen von <i>entschlossen () abgegeben</i> und durch <i>Zurückweisen ()</i> abgelehnt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } });</code> </pre> <br>  <i>lösen ()</i> und <i>ablehnen ()</i> nehmen ein Argument an, das eine Zeichenfolge, eine Zahl, ein logischer Ausdruck, ein Array oder ein Objekt sein kann. <br><br>  Schauen wir uns ein anderes Beispiel an, um zu verstehen, wie Versprechen entstehen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Hier habe ich mit dem Promis-Konstruktor ein neues Versprechen erstellt.  Ein Versprechen wird 2 Sekunden nach seiner Erstellung ausgeführt oder abgelehnt.  Ein Versprechen wird ausgeführt, wenn <i>randomNumber</i> kleiner als .6 ist und in anderen Fällen abgelehnt wird. <br><br>  Wenn ein Versprechen erstellt wurde, steht es noch aus und sein Wert ist nicht <i>definiert</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  Nach 2 Sekunden endet der Timer, das Versprechen wird zufällig entweder ausgeführt oder abgelehnt, und sein Wert ist derjenige, der an die <i>Auflösungs-</i> oder <i>Ablehnungsfunktion übergeben</i> wird.  Unten finden Sie ein Beispiel für zwei Fälle: <br><br>  Erfolgreicher Abschluss: <br><br><img src="https://habrastorage.org/webt/eq/3y/ss/eq3ysskatvuvjnvpoaz9k7zdmvi.png"><br><br>  Versprechen ablehnen: <br><br><img src="https://habrastorage.org/webt/qn/7v/ee/qn7vee1ebi19qgo4zzv72tgpfjg.png"><br><br>  <b>Hinweis:</b> Versprechen können nur einmal ausgeführt oder abgelehnt werden.  Weitere Aufrufe zum <i>Auflösen ()</i> oder <i>Ablehnen ()</i> haben keinerlei Auswirkungen auf den Status des Versprechens.  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   reject('Promise rejected'); //       });</span></span></code> </pre> <br>  Da <i>resolve ()</i> zuerst aufgerufen wurde, hat das Versprechen jetzt den Status "abgeschlossen".  Der nachfolgende Aufruf zur <i>Ablehnung ()</i> hat keinerlei Auswirkungen auf den Status des Versprechens. <br><br><h3>  Promis verwenden </h3><br>  Jetzt wissen wir, wie man Versprechen erstellt. Lassen Sie uns nun herausfinden, wie Sie das bereits erstellte Versprechen anwenden können.  Wir verwenden Versprechen mit den Methoden <i>then ()</i> und <i>catch ()</i> . <br><br>  Beispiel: Abfragen von Daten von einer API mithilfe von <i>Fetch</i> , wodurch ein Versprechen zurückgegeben wird. <br><br>  <i>.then ()</i> <b>Syntax:</b> <i>versprechen.then (successCallback, failedCallback)</i> <br><br>  <i>successCallback</i> wird aufgerufen, wenn das Versprechen erfolgreich ausgeführt wurde.  Es wird ein Argument benötigt, nämlich der Wert, der an <i>resolve () übergeben wird</i> . <br><br>  <i>failCallback</i> wird aufgerufen, wenn das Versprechen abgelehnt wurde.  Es wird ein Argument benötigt, nämlich der Wert, der angegeben wird, <i>um (() abzulehnen</i> . <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">//  '  !' }, (error) =&gt; { console.log(error); //   } );</span></span></code> </pre> <br>  Wenn das Versprechen ausgeführt wurde, wird <i>successCallback</i> mit dem an <i>Auflösung übergebenen</i> Wert <i>aufgerufen</i> <i>()</i> .  Und wenn das Versprechen abgelehnt wurde, wird <i>failCallback</i> mit dem Wert <i>aufgerufen,</i> der an <i>reverse</i> () übergeben wurde. <br><br>  <i>.catch ()</i> <i>-Syntax</i> <b>:</b> <i>Versprechen.Catch (FailureCallback)</i> <br><br>  Wir verwenden <i>catch ()</i> , um Fehler zu behandeln.  Dies ist besser lesbar als die Fehlerbehandlung in <i>failCallback</i> innerhalb des Rückrufs der <i>then ()</i> -Methode. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><h3>  Versprechen Kette </h3><br>  Die Methoden <i>then ()</i> und <i>catch ()</i> können auch ein neues Versprechen zurückgeben, das von einer Kette anderer then () am Ende der vorherigen then () -Methode verarbeitet werden kann. <br><br>  Wir verwenden eine Kette von Versprechungen, wenn wir eine Folge von Versprechungen erfüllen wollen. <br><br>  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  return promise2; }) .then((data) =&gt; { console.log(data); // Promise2  return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3  });</span></span></code> </pre> <br><h4>  Also, was ist hier los? </h4><br>  Wenn <i>Versprechen1</i> erfüllt ist, wird die Methode <i>then ()</i> aufgerufen <i>,</i> die Versprechen2 zurückgibt. <br>  Wenn <i>Versprechen2 erfüllt ist</i> , <i>wird ()</i> erneut aufgerufen und gibt <i>Versprechen3 zurück</i> . <br><br>  Da Versprechen3 abgelehnt wird, wird anstelle des nächsten <i>then ()</i> <i>catch ()</i> aufgerufen, das die Ablehnung von <i>Versprechen3 behandelt</i> . <br><br>  <b>Hinweis:</b> In der Regel reicht eine <i>catch ()</i> -Methode aus, um die Ablehnung von Versprechungen in der Kette zu handhaben, wenn diese Methode am Ende steht. <br><br><h4>  Häufiger Fehler </h4><br>  Viele Newcomer machen einen Fehler, indem sie einige Versprechen in andere investieren.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  promise2.then((data) =&gt; { console.log(data); // Promise2  promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3  }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Obwohl dies gut funktioniert, wird es als schlechter Stil angesehen und macht den Code weniger lesbar.  Wenn Sie eine Reihe von Versprechungen ausführen müssen, ist es besser, sie nacheinander zu platzieren, als sie ineinander zu setzen. <br><br><h3>  Promise.all () </h3><br>  Diese Methode nimmt ein Array von Versprechungen entgegen und gibt ein neues Versprechen zurück, das ausgeführt wird, wenn alle Versprechen innerhalb des Arrays ausgeführt oder abgelehnt werden, sobald ein abgelehntes Versprechen gefunden wird.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Hier ist das Argument in <i>then ()</i> ein Array, das die Werte der Versprechen in derselben Reihenfolge enthält, in der sie an <i>Promise.all () übergeben wurden</i> . (Nur wenn alle Versprechen ausgeführt werden) <br><br>  Das Versprechen wird mit der Ursache für die Ablehnung des ersten Versprechens im übertragenen Array abgelehnt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 </span></span></code> </pre> <br>  Hier haben wir zwei Versprechen, wobei eines nach 2 Sekunden ausgeführt wird und das andere nach 1,5 Sekunden abweicht.  Sobald das zweite Versprechen abgelehnt wird, wird das von <i>Promise.all ()</i> zurückgegebene Versprechen abgelehnt, ohne auf das erste zu warten. <br><br>  Diese Methode kann nützlich sein, wenn Sie mehr als ein Versprechen haben und wissen möchten, wann alle Versprechen erfüllt sind.  Zum Beispiel, wenn Sie Daten von einer Drittanbieter-API anfordern und nur dann etwas mit diesen Daten tun möchten, wenn alle Anforderungen erfolgreich sind. <br><br>  Als Ergebnis haben wir <i>Promise.all ()</i> , das auf die erfolgreiche Ausführung aller Versprechen wartet oder seine Ausführung abschließt, wenn es den ersten Fehler im Array von Versprechen erkennt. <br><br><h3>  Promise.race () </h3><br>  Diese Methode akzeptiert ein Array von Versprechungen und gibt ein neues Versprechen zurück, das ausgeführt wird, sobald das erfüllte Versprechen im Array erfüllt oder abgelehnt wird, wenn das abgelehnte Versprechen früher auftritt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1  .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Hier haben wir zwei Versprechen, wobei eines nach 1 Sekunde ausgeführt wird und das andere nach 1,5 Sekunden abweicht.  Sobald das erste Versprechen erfüllt ist, hat das von Promise.race () zurückgegebene Versprechen den Status erfüllt, ohne auf den Status des zweiten Versprechens zu warten. <br><br>  Hier sind die <i>Daten</i> , die an <i>then () übergeben</i> werden, der Wert des ersten ausgeführten Versprechens. <br><br>  Infolgedessen wartet <i>Promise.race ()</i> auf das erste Versprechen und nimmt seinen Status als Status des zurückgegebenen Versprechens an. <br><br>  <i>Kommentar des Autors der Übersetzung: Daher der Name selbst.</i>  <i>Rennen - Rennen</i> <br><br><h2>  Fazit </h2><br>  Wir haben in JavaScript gelernt, was Versprechen sind und was sie essen.  Versprechen bestehen aus zwei Teilen 1) Erstellen Sie ein Versprechen und 2) Verwenden Sie ein Versprechen.  Meistens verwenden Sie Versprechen, anstatt sie zu erstellen, aber es ist wichtig zu wissen, wie sie erstellt werden. <br><br>  Das ist alles, ich hoffe, dieser Artikel hat Ihnen geholfen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439746/">https://habr.com/ru/post/de439746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439734/index.html">Bereitstellung von Kubernetes auf dem Desktop in wenigen Minuten mit MicroK8s</a></li>
<li><a href="../de439736/index.html">IPSec VPN-Verbindung zwischen MikroTik und Kerio Control</a></li>
<li><a href="../de439738/index.html">Auf der Suche nach der Schaltfläche "Gut machen". Zyxel im Netzwerk kleiner und mittlerer Unternehmen</a></li>
<li><a href="../de439742/index.html">Zulassung zum Masterstudiengang JetBrains an der ITMO University</a></li>
<li><a href="../de439744/index.html">Forscher vom MIT entwickelten eine „Rectenna“, die Wi-Fi-Signale in Elektrizität umwandelt</a></li>
<li><a href="../de439748/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 285 (vom 4. bis 10. Februar)</a></li>
<li><a href="../de439750/index.html">Produktmanagement lernen - wo?</a></li>
<li><a href="../de439752/index.html">Multicore-MRT</a></li>
<li><a href="../de439754/index.html">Google wird mit der Entwicklung intelligenter Uhren beginnen</a></li>
<li><a href="../de439756/index.html">Warum brauche ich einen thermoakustischen Generator?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>