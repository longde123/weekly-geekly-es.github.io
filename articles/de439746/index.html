<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™…ğŸ½ ğŸ‡ ğŸ‘¨ğŸ¿â€ğŸ’¼ Grundlegendes zu JavaScript-Versprechen ğŸ‘¨ğŸ½â€ğŸ¤ ğŸ™ŒğŸ¼ ğŸš£ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Guten Tag, Habr! Ich prÃ¤sentiere Ihnen die Ãœbersetzung des Artikels â€Versprechen in JavaScript verstehenâ€œ von Sukhjinder Arora. 



 Vom Autor der Ãœbe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grundlegendes zu JavaScript-Versprechen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439746/">  Guten Tag, Habr!  Ich prÃ¤sentiere Ihnen die Ãœbersetzung des Artikels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">â€Versprechen in JavaScript verstehenâ€œ</a> von Sukhjinder Arora. <br><br><img src="https://habrastorage.org/webt/ox/6m/oa/ox6moan9gwhmc2oouqbhyfzumtm.png"><br><a name="habracut"></a><br>  <i>Vom Autor der Ãœbersetzung: Neben dem Autor selbst hoffe ich, dass der Artikel fÃ¼r Sie nÃ¼tzlich war.</i>  <i>Bitte, wenn sie Ihnen wirklich geholfen hat, etwas Neues fÃ¼r sich selbst zu lernen, dann seien Sie nicht zu faul, um zum Originalartikel zu gehen und dem Autor zu danken!</i>  <i>Ich freue mich Ã¼ber Ihr Feedback!</i> <i><br><br></i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link zur Ãœbersetzung des Artikels Ã¼ber asynchrones JavaScript desselben Autors</a> .</i> <br><br>  JavaScript ist eine Single-Threaded-Programmiersprache, was bedeutet, dass jeweils eine Aufgabe ausgefÃ¼hrt werden kann.  Vor ES6 haben wir RÃ¼ckrufe verwendet, um asynchrone Aufgaben wie Netzwerkanforderungen zu verwalten. <br><br>  Mit Versprechungen kÃ¶nnen wir â€HÃ¶llenrÃ¼ckrufeâ€œ vermeiden und unseren Code sauberer, lesbarer und verstÃ¤ndlicher machen. <br><br>  Angenommen, wir mÃ¶chten einige Daten asynchron vom Server abrufen und mithilfe von RÃ¼ckrufen Folgendes tun: <br><br><pre><code class="javascript hljs">getData(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); getMoreData(x, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); getSomeMoreData(y, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); }); }); });</code> </pre> <br>  Hier <i>fordere</i> ich einige Daten vom Server mit der Funktion <i>getData () an</i> , die Daten innerhalb der RÃ¼ckruffunktion empfÃ¤ngt.  Innerhalb der RÃ¼ckruffunktion <i>fordere</i> ich zusÃ¤tzliche Daten an, indem <i>ich die</i> Funktion <i>getMoreData () aufrufe</i> , die vorherigen Daten als Argument Ã¼bergebe und so weiter. <br><br>  Dies ist das, was wir als "RÃ¼ckrufhÃ¶lle" bezeichnen, bei der jeder RÃ¼ckruf in den anderen verschachtelt ist und jeder interne RÃ¼ckruf von seinem Ã¼bergeordneten Element abhÃ¤ngt. <br><br>  Wir kÃ¶nnen das obige Snippet mit Versprechungen umschreiben: <br><br><pre> <code class="javascript hljs">getData() .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMoreData(x); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">y</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getSomeMoreData(y); }) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">z</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(z); });</code> </pre> <br>  Sie kÃ¶nnen sehen, was besser lesbar geworden ist als beim ersten RÃ¼ckrufbeispiel. <br><br><h2>  Was sind Versprechen? </h2><br>  Ein Versprechen (Promise) ist ein Objekt, das den zukÃ¼nftigen Wert einer asynchronen Operation enthÃ¤lt.  Wenn Sie beispielsweise einige Daten vom Server anfordern, verspricht Promis, diese Daten zu erhalten, die wir in Zukunft verwenden kÃ¶nnen. <br><br>  Bevor wir uns mit all diesen technischen Dingen befassen, schauen wir uns die Terminologie der Versprechen an. <br><br><h3>  Versprechen Staaten </h3><br>  Ein Versprechen in JavaScript hat wie ein Versprechen im wirklichen Leben drei ZustÃ¤nde.  Dies kann 1) ungelÃ¶st (ausstehend), 2) gelÃ¶st / gelÃ¶st (abgeschlossen) oder 3) abgelehnt / abgelehnt sein. <br><br><img src="https://habrastorage.org/webt/pk/hr/zz/pkhrzzgtdsgqvtptwn26gmtbjhk.png"><br><br>  <b>UngelÃ¶st oder ausstehend</b> - Promis wartet, wenn das Ergebnis nicht fertig ist.  Das heiÃŸt, es erwartet den Abschluss von etwas (zum Beispiel den Abschluss einer asynchronen Operation). <br>  <b>GelÃ¶st oder abgeschlossen</b> - Promis wurden aufgelÃ¶st, wenn das Ergebnis verfÃ¼gbar ist.  Das heiÃŸt, etwas hat seine AusfÃ¼hrung abgeschlossen (zum Beispiel eine asynchrone Operation) und alles ist gut gelaufen. <br>  <b>Abgelehnt</b> - Promis abgelehnt, wenn wÃ¤hrend der AusfÃ¼hrung ein Fehler aufgetreten ist. <br><br>  Jetzt wissen wir, was Promis und seine Terminologie sind. Kehren wir zum praktischen Teil der Versprechen zurÃ¼ck. <br><br><h3>  Promis erstellen </h3><br>  In den meisten FÃ¤llen verwenden Sie einfach Versprechen und erstellen sie nicht. Es ist jedoch wichtig zu wissen, wie sie erstellt werden. <br><br>  Syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { ... });</code> </pre> <br>  Wir haben mit dem Promises-Konstruktor ein neues Versprechen erstellt. Es wird ein Argument verwendet, ein RÃ¼ckruf, der auch als ausfÃ¼hrende Funktion bezeichnet wird. Dabei werden zwei RÃ¼ckrufe ausgefÃ¼hrt, aufgelÃ¶st und <i>abgelehnt</i> . <br><br>  Die Exekutivfunktion wird unmittelbar nach der Erstellung des Versprechens ausgefÃ¼hrt.  Ein Versprechen wird durch Aufrufen von <i>entschlossen () abgegeben</i> und durch <i>ZurÃ¼ckweisen ()</i> abgelehnt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(allWentWell) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } });</code> </pre> <br>  <i>lÃ¶sen ()</i> und <i>ablehnen ()</i> nehmen ein Argument an, das eine Zeichenfolge, eine Zahl, ein logischer Ausdruck, ein Array oder ein Objekt sein kann. <br><br>  Schauen wir uns ein anderes Beispiel an, um zu verstehen, wie Versprechen entstehen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.6</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>); } }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); });</code> </pre> <br>  Hier habe ich mit dem Promis-Konstruktor ein neues Versprechen erstellt.  Ein Versprechen wird 2 Sekunden nach seiner Erstellung ausgefÃ¼hrt oder abgelehnt.  Ein Versprechen wird ausgefÃ¼hrt, wenn <i>randomNumber</i> kleiner als .6 ist und in anderen FÃ¤llen abgelehnt wird. <br><br>  Wenn ein Versprechen erstellt wurde, steht es noch aus und sein Wert ist nicht <i>definiert</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cs/wr/c2/cswrc2jdrixhaguff2w9oijiyf4.png"></div><br>  Nach 2 Sekunden endet der Timer, das Versprechen wird zufÃ¤llig entweder ausgefÃ¼hrt oder abgelehnt, und sein Wert ist derjenige, der an die <i>AuflÃ¶sungs-</i> oder <i>Ablehnungsfunktion Ã¼bergeben</i> wird.  Unten finden Sie ein Beispiel fÃ¼r zwei FÃ¤lle: <br><br>  Erfolgreicher Abschluss: <br><br><img src="https://habrastorage.org/webt/eq/3y/ss/eq3ysskatvuvjnvpoaz9k7zdmvi.png"><br><br>  Versprechen ablehnen: <br><br><img src="https://habrastorage.org/webt/qn/7v/ee/qn7vee1ebi19qgo4zzv72tgpfjg.png"><br><br>  <b>Hinweis:</b> Versprechen kÃ¶nnen nur einmal ausgefÃ¼hrt oder abgelehnt werden.  Weitere Aufrufe zum <i>AuflÃ¶sen ()</i> oder <i>Ablehnen ()</i> haben keinerlei Auswirkungen auf den Status des Versprechens.  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise resolved'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   reject('Promise rejected'); //       });</span></span></code> </pre> <br>  Da <i>resolve ()</i> zuerst aufgerufen wurde, hat das Versprechen jetzt den Status "abgeschlossen".  Der nachfolgende Aufruf zur <i>Ablehnung ()</i> hat keinerlei Auswirkungen auf den Status des Versprechens. <br><br><h3>  Promis verwenden </h3><br>  Jetzt wissen wir, wie man Versprechen erstellt. Lassen Sie uns nun herausfinden, wie Sie das bereits erstellte Versprechen anwenden kÃ¶nnen.  Wir verwenden Versprechen mit den Methoden <i>then ()</i> und <i>catch ()</i> . <br><br>  Beispiel: Abfragen von Daten von einer API mithilfe von <i>Fetch</i> , wodurch ein Versprechen zurÃ¼ckgegeben wird. <br><br>  <i>.then ()</i> <b>Syntax:</b> <i>versprechen.then (successCallback, failedCallback)</i> <br><br>  <i>successCallback</i> wird aufgerufen, wenn das Versprechen erfolgreich ausgefÃ¼hrt wurde.  Es wird ein Argument benÃ¶tigt, nÃ¤mlich der Wert, der an <i>resolve () Ã¼bergeben wird</i> . <br><br>  <i>failCallback</i> wird aufgerufen, wenn das Versprechen abgelehnt wurde.  Es wird ein Argument benÃ¶tigt, nÃ¤mlich der Wert, der angegeben wird, <i>um (() abzulehnen</i> . <br><br>  Ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> randomNumber = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(randomNumber &lt; <span class="hljs-number"><span class="hljs-number">.7</span></span>) { resolve(<span class="hljs-string"><span class="hljs-string">'  !'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); } }); promise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">//  '  !' }, (error) =&gt; { console.log(error); //   } );</span></span></code> </pre> <br>  Wenn das Versprechen ausgefÃ¼hrt wurde, wird <i>successCallback</i> mit dem an <i>AuflÃ¶sung Ã¼bergebenen</i> Wert <i>aufgerufen</i> <i>()</i> .  Und wenn das Versprechen abgelehnt wurde, wird <i>failCallback</i> mit dem Wert <i>aufgerufen,</i> der an <i>reverse</i> () Ã¼bergeben wurde. <br><br>  <i>.catch ()</i> <i>-Syntax</i> <b>:</b> <i>Versprechen.Catch (FailureCallback)</i> <br><br>  Wir verwenden <i>catch ()</i> , um Fehler zu behandeln.  Dies ist besser lesbar als die Fehlerbehandlung in <i>failCallback</i> innerhalb des RÃ¼ckrufs der <i>then ()</i> -Methode. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'-   '</span></span>)); }); promise .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); }) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error); <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><h3>  Versprechen Kette </h3><br>  Die Methoden <i>then ()</i> und <i>catch ()</i> kÃ¶nnen auch ein neues Versprechen zurÃ¼ckgeben, das von einer Kette anderer then () am Ende der vorherigen then () -Methode verarbeitet werden kann. <br><br>  Wir verwenden eine Kette von Versprechungen, wenn wir eine Folge von Versprechungen erfÃ¼llen wollen. <br><br>  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1 .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  return promise2; }) .then((data) =&gt; { console.log(data); // Promise2  return promise3; }) .then((data) =&gt; { console.log(data); }) .catch((error) =&gt; { console.log(error); // Promise3  });</span></span></code> </pre> <br><h4>  Also, was ist hier los? </h4><br>  Wenn <i>Versprechen1</i> erfÃ¼llt ist, wird die Methode <i>then ()</i> aufgerufen <i>,</i> die Versprechen2 zurÃ¼ckgibt. <br>  Wenn <i>Versprechen2 erfÃ¼llt ist</i> , <i>wird ()</i> erneut aufgerufen und gibt <i>Versprechen3 zurÃ¼ck</i> . <br><br>  Da Versprechen3 abgelehnt wird, wird anstelle des nÃ¤chsten <i>then ()</i> <i>catch ()</i> aufgerufen, das die Ablehnung von <i>Versprechen3 behandelt</i> . <br><br>  <b>Hinweis:</b> In der Regel reicht eine <i>catch ()</i> -Methode aus, um die Ablehnung von Versprechungen in der Kette zu handhaben, wenn diese Methode am Ende steht. <br><br><h4>  HÃ¤ufiger Fehler </h4><br>  Viele Newcomer machen einen Fehler, indem sie einige Versprechen in andere investieren.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise3 '</span></span>); }); promise1.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// Promise1  promise2.then((data) =&gt; { console.log(data); // Promise2  promise3.then((data) =&gt; { console.log(data); }).catch((error) =&gt; { console.log(error); // Promise3  }); }).catch((error) =&gt; { console.log(error); }) }).catch((error) =&gt; { console.log(error); });</span></span></code> </pre> <br>  Obwohl dies gut funktioniert, wird es als schlechter Stil angesehen und macht den Code weniger lesbar.  Wenn Sie eine Reihe von Versprechungen ausfÃ¼hren mÃ¼ssen, ist es besser, sie nacheinander zu platzieren, als sie ineinander zu setzen. <br><br><h3>  Promise.all () </h3><br>  Diese Methode nimmt ein Array von Versprechungen entgegen und gibt ein neues Versprechen zurÃ¼ck, das ausgefÃ¼hrt wird, wenn alle Versprechen innerhalb des Arrays ausgefÃ¼hrt oder abgelehnt werden, sobald ein abgelehntes Versprechen gefunden wird.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error));</code> </pre> <br>  Hier ist das Argument in <i>then ()</i> ein Array, das die Werte der Versprechen in derselben Reihenfolge enthÃ¤lt, in der sie an <i>Promise.all () Ã¼bergeben wurden</i> . (Nur wenn alle Versprechen ausgefÃ¼hrt werden) <br><br>  Das Versprechen wird mit der Ursache fÃ¼r die Ablehnung des ersten Versprechens im Ã¼bertragenen Array abgelehnt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">2000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data[<span class="hljs-number"><span class="hljs-number">0</span></span>], data[<span class="hljs-number"><span class="hljs-number">1</span></span>])) .catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)); <span class="hljs-comment"><span class="hljs-comment">// Promise2 </span></span></code> </pre> <br>  Hier haben wir zwei Versprechen, wobei eines nach 2 Sekunden ausgefÃ¼hrt wird und das andere nach 1,5 Sekunden abweicht.  Sobald das zweite Versprechen abgelehnt wird, wird das von <i>Promise.all ()</i> zurÃ¼ckgegebene Versprechen abgelehnt, ohne auf das erste zu warten. <br><br>  Diese Methode kann nÃ¼tzlich sein, wenn Sie mehr als ein Versprechen haben und wissen mÃ¶chten, wann alle Versprechen erfÃ¼llt sind.  Zum Beispiel, wenn Sie Daten von einer Drittanbieter-API anfordern und nur dann etwas mit diesen Daten tun mÃ¶chten, wenn alle Anforderungen erfolgreich sind. <br><br>  Als Ergebnis haben wir <i>Promise.all ()</i> , das auf die erfolgreiche AusfÃ¼hrung aller Versprechen wartet oder seine AusfÃ¼hrung abschlieÃŸt, wenn es den ersten Fehler im Array von Versprechen erkennt. <br><br><h3>  Promise.race () </h3><br>  Diese Methode akzeptiert ein Array von Versprechungen und gibt ein neues Versprechen zurÃ¼ck, das ausgefÃ¼hrt wird, sobald das erfÃ¼llte Versprechen im Array erfÃ¼llt oder abgelehnt wird, wenn das abgelehnte Versprechen frÃ¼her auftritt.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { resolve(<span class="hljs-string"><span class="hljs-string">'Promise1 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Promise2 '</span></span>); }, <span class="hljs-number"><span class="hljs-number">1500</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([promise1, promise2]) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data)) <span class="hljs-comment"><span class="hljs-comment">// Promise1  .catch((error) =&gt; console.log(error));</span></span></code> </pre> <br>  Hier haben wir zwei Versprechen, wobei eines nach 1 Sekunde ausgefÃ¼hrt wird und das andere nach 1,5 Sekunden abweicht.  Sobald das erste Versprechen erfÃ¼llt ist, hat das von Promise.race () zurÃ¼ckgegebene Versprechen den Status erfÃ¼llt, ohne auf den Status des zweiten Versprechens zu warten. <br><br>  Hier sind die <i>Daten</i> , die an <i>then () Ã¼bergeben</i> werden, der Wert des ersten ausgefÃ¼hrten Versprechens. <br><br>  Infolgedessen wartet <i>Promise.race ()</i> auf das erste Versprechen und nimmt seinen Status als Status des zurÃ¼ckgegebenen Versprechens an. <br><br>  <i>Kommentar des Autors der Ãœbersetzung: Daher der Name selbst.</i>  <i>Rennen - Rennen</i> <br><br><h2>  Fazit </h2><br>  Wir haben in JavaScript gelernt, was Versprechen sind und was sie essen.  Versprechen bestehen aus zwei Teilen 1) Erstellen Sie ein Versprechen und 2) Verwenden Sie ein Versprechen.  Meistens verwenden Sie Versprechen, anstatt sie zu erstellen, aber es ist wichtig zu wissen, wie sie erstellt werden. <br><br>  Das ist alles, ich hoffe, dieser Artikel hat Ihnen geholfen! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439746/">https://habr.com/ru/post/de439746/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439734/index.html">Bereitstellung von Kubernetes auf dem Desktop in wenigen Minuten mit MicroK8s</a></li>
<li><a href="../de439736/index.html">IPSec VPN-Verbindung zwischen MikroTik und Kerio Control</a></li>
<li><a href="../de439738/index.html">Auf der Suche nach der SchaltflÃ¤che "Gut machen". Zyxel im Netzwerk kleiner und mittlerer Unternehmen</a></li>
<li><a href="../de439742/index.html">Zulassung zum Masterstudiengang JetBrains an der ITMO University</a></li>
<li><a href="../de439744/index.html">Forscher vom MIT entwickelten eine â€Rectennaâ€œ, die Wi-Fi-Signale in ElektrizitÃ¤t umwandelt</a></li>
<li><a href="../de439748/index.html">Die Zusammenfassung interessanter Materialien fÃ¼r den mobilen Entwickler # 285 (vom 4. bis 10. Februar)</a></li>
<li><a href="../de439750/index.html">Produktmanagement lernen - wo?</a></li>
<li><a href="../de439752/index.html">Multicore-MRT</a></li>
<li><a href="../de439754/index.html">Google wird mit der Entwicklung intelligenter Uhren beginnen</a></li>
<li><a href="../de439756/index.html">Warum brauche ich einen thermoakustischen Generator?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>