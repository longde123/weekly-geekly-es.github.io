<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ”” ğŸ¤˜ğŸ½ ğŸ‘¨ğŸ¿â€ğŸ“ Pengantar proses boot dan boot kernel Linux ğŸ› ğŸ’‡ğŸ¿ â—»ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Jadi kami membuka aliran berikutnya, keempat berturut-turut, kursus Administrator Linux , yang dengan percaya diri menempati ceruknya d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar proses boot dan boot kernel Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/424761/">  Halo semuanya!  Jadi kami membuka aliran berikutnya, keempat berturut-turut, kursus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Administrator Linux</a> , yang dengan percaya diri menempati ceruknya di sebelah kursus devopersky.  Lebih banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">guru</a> , lebih banyak informasi dan kedudukan.  Yah, seperti biasa, lebih banyak informasi menarik yang diambil para guru. <br><br>  Ayo pergi. <br><br>  Pernahkah Anda bertanya-tanya apa yang dibutuhkan agar sistem Anda siap untuk menjalankan aplikasi? <br><br>  Memahami proses memuat kernel dan memulai sistem Linux adalah penting untuk mengkonfigurasi Linux dan memecahkan masalah startup.  Artikel ini memberikan ikhtisar proses boot kernel menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bootloader GRUB2</a> dan startup yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijalankan oleh sistem inisialisasi systemd</a> . <br><br>  Bahkan, ada dua rangkaian acara yang diperlukan untuk membawa komputer Linux ke dalam kondisi kerja: boot kernel (boot) dan startup sistem (startup).  Proses boot kernel dimulai ketika Anda menyalakan komputer dan berakhir dengan kernel menginisialisasi dan memulai sistemd.  Setelah itu, proses memulai sistem dimulai, dan dialah yang membawa komputer Linux ke kondisi kerja. <br><br><img src="https://habrastorage.org/webt/fn/kk/zz/fnkkzz6scajfvnktxj_5hwxavby.png"><a name="habracut"></a><br><br>  Secara umum, proses memuat kernel dan memulai sistem Linux cukup sederhana.  Ini terdiri dari langkah-langkah berikut, yang akan dijelaskan secara lebih rinci di bagian di bawah ini: <br><br><ul><li>  BIOS POST; </li><li>  Pemuatan kernel (GRUB2); </li><li>  Inisialisasi kernel; </li><li>  Menjalankan systemd, induk dari semua proses. </li></ul><br>  Harap dicatat bahwa artikel ini adalah tentang GRUB2 dan systemd, karena mereka adalah pemuat kernel dan program inisialisasi untuk sebagian besar distribusi.  Opsi lain sebelumnya digunakan, dan kadang-kadang masih dapat ditemukan di beberapa distribusi. <br><br>  <b>Proses boot kernel</b> <br><br>  Proses boot kernel dapat dimulai dengan beberapa cara.  Pertama, jika daya dimatikan, menyalakan komputer akan memulai proses boot.  Kedua, jika pengguna lokal sudah berjalan di komputer, termasuk root dan pengguna yang tidak terjangkau, pengguna dapat secara terprogram memulai proses boot kernel menggunakan GUI atau baris perintah untuk reboot.  Reboot pertama-tama akan mematikan komputer dan baru kemudian restart. <br><br>  <b>BIOS POST</b> <b><br></b> <br>  Langkah pertama dalam proses boot kernel Linux tidak ada hubungannya dengan Linux.  Ini adalah bagian perangkat keras dari proses, sama untuk semua sistem operasi.  Ketika daya disuplai ke komputer, hal pertama yang dimulai adalah POST (Power On Self Test), yang merupakan bagian dari BIOS (Sistem I / O Dasar, Sistem Input / Output Dasar). <br><br>  Ketika IBM meluncurkan komputer pribadi pertamanya pada tahun 1981, BIOS dirancang untuk menginisialisasi komponen perangkat keras.  POST adalah bagian dari BIOS, yang tugasnya memastikan operasi peralatan komputer yang benar.  Jika POST gagal, maka komputer mungkin tidak berfungsi dan proses boot tidak akan melanjutkan. <br><br>  BIOS POST memeriksa kinerja dasar perangkat keras, dan kemudian menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">interupsi</a> BIOS - INT 13H, yang menemukan sektor boot kernel pada semua perangkat yang terhubung dengan kemampuan untuk boot.  Sektor pertama yang ditemukan, yang berisi catatan boot yang valid, dimuat ke dalam RAM, setelah itu kontrol ditransfer ke kode dari sektor boot. <br>  Sektor boot hanya tahap pertama.  Sebagian besar distribusi Linux menggunakan salah satu dari tiga opsi bootloader: GRUB, GRUB2, dan LILO.  GRUB2 adalah yang terbaru dan sekarang lebih sering digunakan daripada versi yang lebih lama. <br><br>  <b>GRUB2</b> <br><br>  GRUB2 adalah singkatan dari "GRand Unified Bootloader, versi 2," dan sekarang ini adalah bootloader utama untuk sebagian besar distribusi Linux modern.  GRUB2 adalah program yang membuat komputer cukup pintar sehingga dapat menemukan kernel sistem operasi dan memuatnya ke dalam memori.  Karena berbicara dan menulis hanya GRUB lebih mudah daripada GRUB2, dalam artikel ini saya mungkin akan menggunakan istilah GRUB, tetapi menyiratkan GRUB2 kecuali dinyatakan sebaliknya. <br><br>  GRUB kompatibel dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi multiboot</a> , yang memungkinkannya memuat berbagai versi Linux dan sistem operasi lain;  itu juga dapat memulai catatan boot sistem operasi berpemilik dalam sebuah rantai. <br><br>  GRUB juga memungkinkan pengguna untuk memilih dari beberapa kemungkinan unduhan kernel untuk distribusi Linux yang disediakan.  Ini memungkinkan untuk mengunduh versi kernel sebelumnya jika yang diperbarui tidak dapat boot dengan benar atau tidak kompatibel dengan beberapa bagian penting dari perangkat lunak.  GRUB dapat dikonfigurasi dalam file <code>/boot/grub/grub.conf</code> . <br><br>  GRUB1 sekarang dianggap usang dan di sebagian besar distribusi modern digantikan oleh GRUB2, yang merupakan versi yang ditulis ulang.  Distribusi berbasis Red Hat diupgrade ke GRUB2 sekitar Fedora 15 dan CentOS / RHEL 7. GRUB2 memiliki fungsionalitas boot yang sama dengan GRUB1, tetapi selain itu ia juga menyediakan lingkungan berbasis perintah, seperti pre-OS berbasis mainframe dan lebih fleksibel pada tahap pra-boot.  GRUB2 dikonfigurasi di <code>/boot/grub2/grub.cfg</code> . <br><br>  Tugas utama GRUB adalah untuk memuat kernel Linux ke dalam memori dan menjalankannya.  Kedua versi GRUB bekerja serupa dalam tiga tahap, tetapi dalam artikel ini saya akan menggunakan GRUB2 untuk menjelaskan cara kerja GRUB.  Mengkonfigurasi GRUB dan GRUB2 dan menggunakan perintah GRUB2 berada di luar cakupan artikel ini. <br><br>  Meskipun secara resmi GRUB2 tidak menggunakan penomoran langkah, demi kenyamanan saya akan menggunakannya dalam artikel ini. <br><br>  <b>Tahap 1</b> <br><br>  Seperti yang telah disebutkan di bagian BIOS POST, pada akhir POST, BIOS mencari catatan booting pada disk yang terpasang, biasanya terletak di Master Boot Record (MBR), setelah itu memuat catatan pertama yang ditemukan ke dalam memori dan mulai menjalankannya.  Kode bootstrap, yaitu, tahap pertama GRUB2, membutuhkan ruang yang sangat sedikit, karena harus sesuai dengan sektor 512-byte pertama pada hard disk bersama dengan tabel partisi.  Jumlah total ruang yang dialokasikan untuk kode bootstrap itu sendiri dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MBR standar</a> adalah 446 byte.  File 446-byte untuk tahap 1 disebut boot-img dan tidak berisi tabel partisi - ini ditambahkan ke catatan boot secara terpisah. <br><br>  Karena catatan boot harus sangat kecil, itu tidak terlalu "pintar" dan tidak mengerti struktur sistem file.  Oleh karena itu, satu-satunya tujuan langkah 1 adalah untuk mendeteksi dan memuat langkah 1.5.  Untuk mencapai ini, langkah 1.5 dari GRUB harus terletak di ruang antara catatan boot itu sendiri dan partisi pertama pada disk.  Setelah memuat stage 1.5 GRUB ke dalam RAM, stage 1 mentransfer kontrol ke stage 1.5. <br><br>  <b>Tahap 1.5</b> <br><br>  Seperti disebutkan di atas, langkah 1.5 dari GRUB harus berada di antara catatan boot dan partisi pertama pada disk.  Secara historis, ruang ini tetap tidak digunakan karena alasan teknis.  Partisi pertama pada hard disk dimulai di sektor 63, dan dengan mempertimbangkan MBR di sektor 0, ada 62 sektor byte-311 - 31744 byte - di mana Anda dapat menyimpan file core.img - 1,5 tahap GRUB.  File core.img memiliki berat 25389 byte, yang merupakan ruang yang cukup untuk menyimpannya di antara MBR dan partisi disk pertama. <br><br>  Karena lebih banyak kode dapat digunakan untuk langkah 1.5, mungkin cukup untuk memuat beberapa driver sistem file umum, seperti EXT standar dan sistem file Linux lainnya, FAT, dan NTFS.  core.img di GRUB2 lebih kompleks dan fungsional daripada di langkah 1.5 dari GRUB1.  Ini berarti bahwa tahap 2 GRUB2 dapat berada di sistem file EXT standar, tetapi tidak dalam volume yang logis.  Oleh karena itu, lokasi standar untuk file tahap 2 adalah sistem file <code>/boot</code> , atau lebih tepatnya <code>/boot/grub2</code> . <br><br>  Perhatikan bahwa direktori / boot harus berada di sistem file yang didukung oleh GRUB.  Tidak semua sistem file memiliki dukungan ini.  Tugas tahap 1.5 adalah memulai dengan driver sistem file yang diperlukan untuk mencari file stage 2 di sistem file / boot dan memuat driver yang diperlukan. <br><br>  <b>Tahap 2</b> <br><br>  Semua file GRUB Stage 2 terletak di <code>/boot/grub2</code> dan beberapa subdirektori.  GRUB2 tidak memiliki file gambar seperti pada langkah 1 dan 2. Sebaliknya, sebagian besar terdiri dari modul kernel runtime, yang diambil dari direktori <code>/boot/grub2/i386-pc</code> sesuai kebutuhan. <br><br>  Tugas GRUB2 tahap 2 adalah untuk mendeteksi dan memuat kernel Linux ke dalam RAM dan mentransfer kontrol kontrol komputer ke kernel.  Kernel dan file terkaitnya berada di direktori <code>/boot</code> .  File kernel mudah dikenali, karena namanya dimulai dengan vmlinuz.  Anda dapat mendaftar isi direktori <code>/boot</code> untuk melihat kernel yang saat ini diinstal pada sistem Anda. <br><br>  GRUB2, seperti GRUB1, mendukung memuat salah satu dari beberapa kernel Linux.  Sistem manajemen paket Red Hat mendukung penyimpanan beberapa versi dari kernel sehingga Anda dapat memuat versi lama dari kernel jika ada masalah dengan yang terbaru.  Secara default, GRUB menyediakan menu kernel terinstal yang sudah dimuat, termasuk opsi penyelamatan, dan setelah konfigurasi, opsi pemulihan. <br><br>  Tahap 2 GRUB2 memuat kernel yang dipilih ke dalam memori dan mentransfer kontrol kontrol komputer ke kernel. <br><br>  <b>Intinya</b> <br><br>  Semua core dalam format self-extracting, terkompresi untuk menghemat ruang.  Kernel terletak di direktori <code>/boot</code> , bersama dengan gambar disk RAM asli dan daftar partisi pada hard drive. <br><br>  Setelah kernel yang dipilih dimuat ke dalam memori dan mulai dijalankan, pertama-tama, kernel harus mengekstraksi sendiri dari versi terkompresi dari file sebelum mulai melakukan pekerjaan yang bermanfaat.  Setelah ekstraksi telah terjadi, ia memuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">systemd</a> , yang merupakan pengganti untuk program <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">init SysV</a> lama, dan mentransfer kontrol ke sana. <br><br>  Ini adalah akhir dari proses boot kernel.  Pada titik ini, kernel dan sistem Linux sedang berjalan, tetapi tidak dapat melakukan tugas-tugas yang bermanfaat bagi pengguna akhir, karena tidak ada lagi yang harus dilakukan. <br><br>  <b>Proses startup sistem</b> <br><br>  Proses startup sistem mengikuti proses boot kernel dan menjalankan dan menjalankan komputer Linux. <br><br>  <b>systemd</b> <br><br>  systemd adalah induk dari semua proses yang bertanggung jawab untuk membawa host Linux ke keadaan efisien.  Beberapa fungsinya, lebih luas daripada yang disajikan dalam program inisialisasi lama, harus mengelola banyak aspek dari menjalankan Linux host, termasuk pemasangan sistem file, memulai dan mengelola layanan sistem yang diperlukan untuk host Linux untuk bekerja secara efisien.  Semua tugas systemd yang tidak terkait dengan proses startup sistem berada di luar ruang lingkup diskusi dalam artikel ini. <br><br>  Pertama, systemd me-mount sistem file sebagaimana didefinisikan dalam <code>/etc/fstab</code> , termasuk semua file swap dan partisi.  Pada titik ini, ia dapat mengakses file konfigurasi yang terletak di <code>/etc</code> , termasuk miliknya.  Ia menggunakan file konfigurasinya sendiri <code>/etc/systemd/system/default.target</code> untuk menentukan target yang akan memuat host.  File default.target hanyalah symlink ke file target asli.  Untuk workstation desktop, ini biasanya graphical.target, setara dengan runlevel 5 di initializer SystemV lama.  Untuk server, defaultnya adalah multi-user.target, mirip dengan runlevel 3 di SystemV.  emergency.target mirip dengan mode satu pengguna. <br><br>  Perhatikan bahwa target dan layanan adalah unit systemd. <br><br>  Tabel 1 di bawah ini adalah perbandingan dari semua target systemd dengan runlevel lama di SystemV.  Alias â€‹â€‹target Systemd disediakan oleh systemd untuk kompatibilitas ke belakang.  Alias â€‹â€‹target memungkinkan skrip - dan banyak sysadmin, termasuk saya - untuk menggunakan perintah SystemV seperti init3 untuk mengubah level eksekusi.  Tentu saja, perintah SystemV diarahkan oleh systemd untuk interpretasi dan eksekusi. <br><div class="scrollable-table"><table><tbody><tr><th>  Runlevel systemv </th><th>  <nobr>target systemd</nobr> </th><th>  alias <nobr>target systemd</nobr> </th><th>  Deskripsi </th></tr><tr><td></td><td>  halt.target </td><td></td><td>  Menangguhkan sistem tanpa mematikan daya </td></tr><tr><td>  0 </td><td>  poweroff.target </td><td>  runlevel0.target </td><td>  Menjeda sistem dan mematikan daya </td></tr><tr><td>  S </td><td>  darurat </td><td></td><td>  Mode pengguna tunggal.  Layanan tidak berjalan;  sistem file tidak terpasang.  Ini adalah tingkat operasi paling dasar.  Untuk interaksi pengguna dengan sistem, hanya shell darurat yang diluncurkan di konsol utama. </td></tr><tr><td>  1 </td><td>  rescue.target </td><td>  runlevel1.target </td><td>  Sistem dasar, termasuk memasang sistem file dengan set layanan paling dasar dan shell penyelamat di konsol utama. </td></tr><tr><td>  2 </td><td></td><td>  runlevel2.target </td><td>  Mode multiuser, tanpa NFS, tetapi semua layanan non-GUI berjalan. </td></tr><tr><td>  3 </td><td>  multi-user.target </td><td>  runlevel3.target </td><td>  Semua layanan berjalan, tetapi hanya melalui antarmuka baris perintah (CLI). </td></tr><tr><td>  4 </td><td></td><td>  runlevel4.target </td><td>  Tidak digunakan </td></tr><tr><td>  5 </td><td>  graphical.target </td><td>  runlevel5.target </td><td>  Mode multiuser dengan GUI. </td></tr><tr><td>  6 </td><td>  reboot.target </td><td>  runlevel6.target </td><td>  Mulai ulang </td></tr><tr><td></td><td>  default.target </td><td></td><td>  Target ini selalu memiliki symlink dengan multi-user.target atau graphical.target.  systemd selalu menggunakan default.target untuk memulai sistem.  default.target tidak boleh dikaitkan dengan halt.target, poweroff.target atau reboot.target. </td></tr></tbody></table></div><br>  <i>Tabel 1: Perbandingan level kontrol SystemV dengan target systemd dan beberapa alias target.</i> <br><br>  Setiap target memiliki serangkaian dependensi yang dijelaskan dalam file konfigurasi.  systemd menjalankan yang diperlukan.  Ketergantungan ini adalah layanan yang diperlukan untuk menjalankan host Linux dengan tingkat fungsionalitas tertentu.  Ketika semua dependensi yang tercantum dalam file konfigurasi target dimuat dan dimulai, sistem bekerja pada level target ini. <br><br>  systemd juga memindai direktori inisialisasi SystemV yang sudah usang untuk file startup.  Jika ya, systemd menggunakannya sebagai file konfigurasi untuk menjalankan layanan yang dijelaskan dalam file.  Layanan jaringan yang ketinggalan jaman adalah contoh yang bagus dari yang masih menggunakan file startup SystemV di Fedora. <br><br>  Gambar 1 di bawah ini langsung disalin dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman utama</a> bootup.  Ini menunjukkan urutan umum peristiwa selama awal systemd dan persyaratan dasar untuk memastikan keberhasilannya. <br><br>  Target sysinit.target dan basic.target dapat dianggap sebagai pos pemeriksaan selama startup sistem.  Meskipun salah satu tujuan dari systemd adalah untuk menjalankan layanan sistem secara paralel, ada beberapa layanan dan target fungsional yang harus diluncurkan sebelum yang lain.  Titik kontrol ini tidak dapat dilewati sampai semua layanan dan target yang mereka butuhkan selesai. <br><br>  Dengan demikian, sysinit.target tercapai ketika semua unit yang bergantung padanya selesai.  Semua unit berikut harus dilengkapi: pemasangan sistem file, pengaturan file swap, mulai udev, pengaturan keadaan awal generator angka acak, inisialisasi layanan tingkat rendah, pengaturan layanan kriptografi jika setidaknya satu sistem file dienkripsi.  Di sysinit.target mereka dapat dieksekusi secara paralel. <br>  sysinit.target menjalankan semua layanan dan unit tingkat rendah yang diperlukan untuk fungsionalitas minimum sistem, dan layanan yang diperlukan untuk masuk ke basic.target. <br><br><img src="https://habrastorage.org/webt/gx/k_/yj/gxk_yjpanfeksjnoiyfxob5bqlw.png"><br>  <i>Gambar 1. Peta startup Systemd</i> <br><br>  Setelah menjalankan sysinit.target, systemd meluncurkan basic.target, dimulai dengan semua unit yang diperlukan untuk menjalankannya.  Target dasar menyediakan fungsionalitas tambahan dengan meluncurkan unit yang diperlukan untuk target berikutnya, termasuk menetapkan jalur ke berbagai direktori yang dapat dieksekusi, soket komunikasi, dan timer. <br><br>  Terakhir, Anda dapat mulai menginisialisasi target tingkat pengguna: multi-user.target atau graphical.target.  Perlu dicatat bahwa multi-user.target harus dicapai sebelum dependensi target grafis dieksekusi. <br><br>  Target yang digarisbawahi pada Gambar 1 adalah target startup yang khas.  Startup sistem berakhir ketika salah satunya tercapai.  Jika multi-user.target adalah target default, maka di konsol Anda akan melihat login dalam mode teks.  Jika graphical.target ditentukan secara default, Anda akan melihat login grafis;  GUI layar masuk tergantung pada pengelola layar yang Anda gunakan. <br><br>  <b>Masalahnya</b> <br><br>  Baru-baru ini saya harus mengubah kernel boot default pada komputer Linux yang menggunakan GRUB2.  Saya menemukan bahwa beberapa perintah berhenti berfungsi dengan benar, atau saya salah menggunakannya.  Saya masih tidak tahu apa masalahnya, akan butuh lebih banyak waktu untuk meneliti itu. <br><br>  Perintah grub2-set-default salah mengkonfigurasi indeks kernel default di file <code>/etc/default/grub</code> , sehingga kernel alternatif yang diinginkan tidak dimuat.  Saya mengubah <code>/etc/default/grub GRUB_DEFAULT=saved</code> secara manual <code>/etc/default/grub GRUB_DEFAULT=saved</code> ke <code>GRUB_DEFAULT=2</code> , di mana 2 adalah indeks dari kernel yang diinstal yang ingin saya jalankan.  Kemudian, saya menjalankan perintah <code>grub2-mkconfig &gt; /boot/grub2/grub.cfg</code> untuk membuat file konfigurasi grub baru.  Trik ini berhasil dan kernel alternatif diluncurkan. <br><br>  <b>Kesimpulan</b> <br><br>  GRUB2 dan sistem inisialisasi systemd adalah komponen kunci untuk boot kernel dan fase startup sistem dari sebagian besar distribusi Linux modern.  Terlepas dari kontradiksi, terutama di sekitar systemd, kedua komponen ini bekerja dengan baik bersama untuk memuat kernel dan menjalankan semua layanan sistem yang diperlukan untuk membuat sistem Linux yang fungsional. <br>  Walaupun saya menganggap GRUB2 dan systemd secara keseluruhan lebih kompleks dari pendahulunya, mereka tidak lebih sulit untuk dikuasai dan dikelola.  Manual berisi banyak informasi tentang systemd, dan pada freedesktop.org daftar halaman-halamannya disajikan secara lengkap.  Untuk informasi lebih lanjut, lihat tautan di bawah ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU GRUB</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GNU GRUB Manua</a> l (GNU.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Master Boot Record</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Spesifikasi multiboot</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">systemd</a> (Wikipedia) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proses bootup systemd</a> (Freedesktop.org) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">systemd indeks halaman manual</a> (Freedesktop.org) </li></ul><br><br>  Itu saja.  Kami menunggu pertanyaan dan komentar di sini atau mereka dapat ditanyakan langsung dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pelajaran terbuka</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424761/">https://habr.com/ru/post/id424761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424747/index.html">Tempat di mana suara itu hidup</a></li>
<li><a href="../id424751/index.html">Bagaimana Sistem Biometrik Terpadu Bekerja</a></li>
<li><a href="../id424753/index.html">Apa yang Baru di YouTrack 2018.3</a></li>
<li><a href="../id424755/index.html">Uang suka tagihan: bagaimana mobil menyortir tagihan</a></li>
<li><a href="../id424757/index.html">Intisari acara untuk profesional SDM di bidang TI pada Oktober 2018</a></li>
<li><a href="../id424763/index.html">Editor teks bukan matematika tertinggi Anda, di sini Anda perlu berpikir</a></li>
<li><a href="../id424765/index.html">Manajemen negara dalam aplikasi Flutter</a></li>
<li><a href="../id424767/index.html">Kami membuat kue dari Habr. Lagi</a></li>
<li><a href="../id424771/index.html">Pengalaman pribadi: dari ide dan lembar kosong hingga versi konsep situs</a></li>
<li><a href="../id424773/index.html">Pemodelan biofarma dan numerik: Pengalaman dan praktik Amgen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>