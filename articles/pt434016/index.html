<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñáÔ∏è üë©üèª üÜë Opera√ß√£o de coelhos (RabbitMQ) no modo "Sobreviver a qualquer custo" üñïüèæ üë©‚Äçüç≥ üí•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="" Empresa " - operadora de telecomunica√ß√µes PJSC "Megafon" 
 " Noda " √© o servidor RabbitMQ. 
 Um " cluster " √© uma combina√ß√£o, no nosso caso de tr√™s,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Opera√ß√£o de coelhos (RabbitMQ) no modo "Sobreviver a qualquer custo"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434016/">  " <b>Empresa</b> " - operadora de telecomunica√ß√µes PJSC "Megafon" <br>  " <b>Noda</b> " √© o servidor RabbitMQ. <br>  Um " <b>cluster</b> " √© uma combina√ß√£o, no nosso caso de tr√™s, de n√≥s RabbitMQ que funcionam como um todo. <br>  " <b>Contorno</b> " - um conjunto de clusters RabbitMQ, cujas regras de trabalho s√£o determinadas no balanceador √† sua frente. <br>  " <b>Balancer</b> ", " <b>hap</b> " - Haproxy - balancer que executa a fun√ß√£o de alternar a carga em clusters dentro do loop.  Um par de servidores Haproxy em execu√ß√£o em paralelo √© usado para cada loop. <br>  " <b>Subsistema</b> " - o editor e / ou consumidor de mensagens transmitidas atrav√©s do coelho <br>  " <b>SISTEMA</b> " - um conjunto de subsistemas, uma solu√ß√£o √∫nica de software e hardware usada pela Companhia, caracterizada pela distribui√ß√£o em toda a R√∫ssia, mas com v√°rios centros onde todas as informa√ß√µes fluem e onde ocorrem os principais c√°lculos e c√°lculos. <br>  <b>SYSTEM</b> - um sistema geograficamente distribu√≠do - de Khabarovsk e Vladivostok a S√£o Petersburgo e Krasnodar.  Arquitetonicamente, esses s√£o v√°rios contornos centrais, divididos pelos recursos dos subsistemas conectados a eles. <br><a name="habracut"></a><br><h3>  Qual √© a tarefa do transporte nas realidades das telecomunica√ß√µes? </h3><br>  Em poucas palavras: segue a resposta dos subsistemas √† a√ß√£o de cada assinante, que por sua vez informa os outros subsistemas sobre eventos e altera√ß√µes subseq√ºentes.  As mensagens s√£o geradas por quaisquer a√ß√µes com o SISTEMA, n√£o apenas dos assinantes, mas tamb√©m do lado dos funcion√°rios da Empresa e dos Subsistemas (um n√∫mero muito grande de tarefas √© executado automaticamente). <br><br>  Caracter√≠sticas do transporte em telecomunica√ß√µes: fluxo grande, n√£o errado, GRANDE de dados diversos transmitidos por transporte ass√≠ncrono. <br><br>  Alguns subsistemas vivem em Clusters separados devido ao peso dos fluxos de mensagens - simplesmente n√£o h√° recursos restantes no cluster, por exemplo, com um fluxo de mensagens de 5-6 mil mensagens / segundo, a quantidade de dados transferidos pode atingir 170-190 Megabytes / segundo.  Com esse perfil de carga, uma tentativa de desembarcar qualquer outra pessoa neste cluster levar√° a tristes conseq√º√™ncias: como n√£o h√° recursos suficientes para processar todos os dados ao mesmo tempo, o coelho come√ßar√° a direcionar as conex√µes de entrada - um processo simples de publica√ß√£o come√ßar√°, com todas as conseq√º√™ncias para todos os subsistemas e sistemas em inteiro. <br><br>  Requisitos b√°sicos para o transporte: <br><br><ol><li>  A acessibilidade dos ve√≠culos deve ser de 99,99%.  Na pr√°tica, isso se traduz em um requisito operacional 24 horas por dia, 7 dias por semana e na capacidade de responder automaticamente a qualquer situa√ß√£o de emerg√™ncia. </li><li>  Seguran√ßa dos dados:% de mensagens perdidas no transporte deve tender a 0. </li></ol><br>  Por exemplo, ao fazer uma chamada, v√°rias mensagens diferentes passam pelo transporte ass√≠ncrono.  algumas mensagens destinam-se a subsistemas que vivem no mesmo circuito e outras destinam-se √† transmiss√£o para n√≥s centrais.  A mesma mensagem pode ser reivindicada por v√°rios subsistemas; portanto, na fase de publica√ß√£o da mensagem no coelho, ela √© copiada e enviada para diferentes consumidores.  E, em alguns casos, a c√≥pia de mensagens √© obrigatoriamente implementada em um circuito intermedi√°rio - quando as informa√ß√µes precisam ser fornecidas do circuito em Khabarovsk para o circuito em Krasnodar.  A transmiss√£o √© feita atrav√©s de um dos contornos centrais, onde s√£o feitas c√≥pias das mensagens, para os destinat√°rios centrais. <br><br>  Al√©m dos eventos causados ‚Äã‚Äãpelas a√ß√µes do assinante, as mensagens de servi√ßo que trocam os subsistemas passam pelo transporte.  Assim, v√°rios milhares de rotas de mensagens diferentes s√£o obtidas, algumas se cruzam, outras existem isoladamente.  Basta nomear o n√∫mero de filas envolvidas nas rotas em diferentes contornos para entender a escala aproximada do mapa de transporte: nos circuitos centrais 600, 200, 260, 15 ... e nos circuitos remotos 80-100 ... <br><br>  Com esse envolvimento do transporte, os requisitos para 100% de acessibilidade de todos os n√≥s de transporte n√£o parecem mais excessivos.  Estamos avan√ßando na implementa√ß√£o desses requisitos. <br><br><h3>  Como resolvemos tarefas </h3><br>  Al√©m do <i>RabbitMQ</i> , o <i>Haproxy √©</i> usado para equilibrar a carga e fornecer uma resposta autom√°tica a emerg√™ncias. <br><br>  Algumas palavras sobre o ambiente de hardware e software em que nossos coelhos existem: <br><br><ul><li>  Todos os servidores coelho s√£o virtuais, com par√¢metros de 8 a 12 CPU, 16 Gb Mem, 200 Gb HDD.  Como a experi√™ncia demonstrou, mesmo o uso de servidores n√£o virtuais assustadores com 90 n√∫cleos e um monte de RAM fornece um pequeno aumento no desempenho a custos significativamente mais altos.  Vers√µes usadas: 3.6.6 (na pr√°tica - o mais est√°vel de 3.6) com um erlang de 18.3, 3.7.6 com um erlang de 20.1. </li><li>  Para o Haproxy, os requisitos s√£o muito mais baixos: 2 CPU, 4 Gb Mem, a vers√£o do haproxy √© 1,8 est√°vel.  A carga nos recursos em todos os servidores haproxy n√£o excede 15% da CPU / Mem. </li><li>  Todo o zool√≥gico est√° localizado em 14 data centers em 7 locais em todo o pa√≠s, unidos em uma √∫nica rede.  Em cada um dos datacenters, h√° um cluster de tr√™s n√≥s e um hub. </li><li>  Para circuitos remotos, s√£o utilizados 2 data centers, para cada um dos circuitos centrais - 4. </li><li>  Os circuitos centrais interagem entre si, bem como com os circuitos remotos; por sua vez, os circuitos remotos funcionam apenas com os circuitos centrais; eles n√£o t√™m comunica√ß√£o direta entre si. </li><li>  As configura√ß√µes de Haps e Clusters dentro do mesmo circuito s√£o completamente id√™nticas.  O ponto de entrada para cada circuito √© um alias para v√°rios registros A-DNS.  Assim, para impedir que isso aconte√ßa, pelo menos um hap e pelo menos um dos Clusters (pelo menos um n√≥ no Cluster) em cada Circuito estar√£o dispon√≠veis.  Como o caso de falha de at√© 6 servidores em dois data centers ao mesmo tempo √© extremamente improv√°vel, a aceitabilidade √© assumida como pr√≥xima de 100%. </li></ul><br>  Parece concebido (e implementado) tudo isso assim: <br><br><img src="https://habrastorage.org/webt/f2/rm/9i/f2rm9i0kd5jk1ikaapl2vc63yhc.jpeg" alt="imagem"><br><br><img src="https://habrastorage.org/webt/az/5t/ks/az5tkse8qkz0fl3ml6znbg4pz18.jpeg" alt="imagem"><br><br>  Agora algumas configura√ß√µes. <br><br><div class="spoiler">  <b class="spoiler_title">Configura√ß√£o Haproxy</b> <div class="spoiler_text"><table><tbody><tr><td>  frontend center-rmq_5672 </td><td></td></tr><tr><td></td><td>  amarrar </td><td>  *: 5672 </td></tr><tr><td></td><td>  modo </td><td>  tcp </td></tr><tr><td></td><td>  maxconn </td><td>  10.000 </td></tr><tr><td></td><td>  cliente de tempo limite </td><td>  3h </td></tr><tr><td></td><td>  op√ß√£o </td><td>  tcpka </td></tr><tr><td></td><td>  op√ß√£o </td><td>  tcplog </td></tr><tr><td></td><td>  default_backend </td><td>  center-rmq_5672 </td></tr><tr><td>  frontend center-rmq_5672_lvl_1 </td><td></td></tr><tr><td></td><td>  amarrar </td><td>  localhost: 56721 </td></tr><tr><td></td><td>  modo </td><td>  tcp </td></tr><tr><td></td><td>  maxconn </td><td>  10.000 </td></tr><tr><td></td><td>  cliente de tempo limite </td><td>  3h </td></tr><tr><td></td><td>  op√ß√£o </td><td>  tcpka </td></tr><tr><td></td><td>  op√ß√£o </td><td>  tcplog </td></tr><tr><td></td><td>  default_backend </td><td>  center-rmq_5672_lvl_1 </td></tr><tr><td>  backend center-rmq_5672 </td></tr><tr><td></td><td>  equilibrar </td><td>  lessconn </td></tr><tr><td></td><td>  modo </td><td>  tcp </td></tr><tr><td></td><td>  fullconn </td><td>  10.000 </td></tr><tr><td></td><td>  timeout </td><td>  servidor 3h </td></tr><tr><td></td><td>  servidor </td><td>  srv-rmq01 10/10/10/10/106767 cheque inter 5s aumento 2 queda 3 sess√µes de desligamento-backup-marcadas </td></tr><tr><td></td><td>  servidor </td><td>  srv-rmq03 10/10/10/2011 11672 check inter 5s aumento 2 queda 3 sess√µes de desligamento-backup-marcadas </td></tr><tr><td></td><td>  servidor </td><td>  srv-rmq05 10/10/10/126767 cheque inter 5s aumento 2 queda 3 sess√µes de desligamento-backup-marcadas </td></tr><tr><td></td><td>  servidor </td><td>  localhost 127.0.0.1 6721 check inter 5s aumento 2 queda 3 backup em sess√µes de desligamento marcadas para baixo </td></tr><tr><td>  backend center-rmq_5672_lvl_1 </td></tr><tr><td></td><td>  equilibrar </td><td>  lessconn </td></tr><tr><td></td><td>  modo </td><td>  tcp </td></tr><tr><td></td><td>  fullconn </td><td>  10.000 </td></tr><tr><td></td><td>  timeout </td><td>  servidor 3h </td></tr><tr><td></td><td>  servidor </td><td>  srv-rmq02 10/10/10/136767 cheque inter 5s aumento 2 queda 3 sess√µes de desligamento-backup-marcadas </td></tr><tr><td></td><td>  servidor </td><td>  srv-rmq04 10/10/10/14/1067 cheque inter 5s aumento 2 queda 3 em sess√µes marcadas de desligamento-backup </td></tr><tr><td></td><td>  servidor </td><td>  srv-rmq06 10.10.10.5.0767 cheque inter 5s aumento 2 queda 3 sess√µes de desligamento-backup-marcadas </td></tr></tbody></table><br></div></div><br>  A primeira se√ß√£o da frente descreve o ponto de entrada - levando ao cluster principal, a segunda se√ß√£o √© projetada para equilibrar o n√≠vel de reserva.  Se voc√™ simplesmente descrever todos os servidores de backup de coelho na se√ß√£o de back-end (instru√ß√µes de backup), funcionar√° da mesma maneira - se o cluster principal estiver completamente inacess√≠vel, as conex√µes ir√£o para o backup, no entanto, todas as conex√µes ir√£o para o PRIMEIRO servidor de backup na lista.  Para garantir o balanceamento de carga em todos os n√≥s de backup, apenas apresentamos mais uma frente, que disponibilizamos apenas com o host local e atribu√≠mos a ele o servidor de backup. <br><br>  O exemplo acima descreve o balanceamento do loop remoto - que opera em dois datacenters: o servidor srv-rmq {01,03,05} - vive no datacenter n¬∫ 1, srv-rmq {02,04,06} - no datacenter n¬∫ 2.  Portanto, para implementar a solu√ß√£o de quatro coda, precisamos adicionar apenas mais duas frentes locais e duas se√ß√µes de back-end dos servidores coelho correspondentes. <br><br>  O comportamento do balanceador com esta configura√ß√£o √© o seguinte: Enquanto pelo menos um servidor principal estiver ativo, n√≥s o usamos.  Se os principais servidores n√£o estiverem dispon√≠veis, trabalhamos com uma reserva.  Se pelo menos um servidor principal estiver dispon√≠vel, todas as conex√µes com os servidores de backup ser√£o desconectadas e, quando a conex√£o for restaurada, elas j√° estar√£o no Cluster prim√°rio. <br><br>  A experi√™ncia operacional dessa configura√ß√£o mostra quase 100% de disponibilidade de cada um dos circuitos.  Essa solu√ß√£o exige que os subsistemas sejam completamente legais e simples: sejam capazes de se reconectar com o coelho ap√≥s desconectar. <br><br>  Portanto, fornecemos balanceamento de carga para um n√∫mero arbitr√°rio de clusters e alternamos automaticamente entre eles, √© hora de ir diretamente para os coelhos. <br><br>  Cada cluster √© criado a partir de tr√™s n√≥s, como mostra a pr√°tica - o n√∫mero mais √≥timo de n√≥s, o que garante o equil√≠brio ideal entre disponibilidade / toler√¢ncia a falhas / velocidade.  Como o coelho n√£o √© dimensionado horizontalmente (o desempenho do cluster √© igual ao desempenho do servidor mais lento), criamos todos os n√≥s com os mesmos par√¢metros ideais para CPU / Mem / Hdd.  Posicionamos os servidores o mais pr√≥ximo poss√≠vel - no nosso caso, estamos arquivando m√°quinas virtuais no mesmo farm. <br><br>  Quanto √†s condi√ß√µes pr√©vias, as quais, por parte dos Subsistemas, garantir√£o a opera√ß√£o e o cumprimento mais est√°veis ‚Äã‚Äãdo requisito de salvar as mensagens recebidas: <br><br><ol><li>  O trabalho com o coelho √© somente via protocolo amqp / amqps - atrav√©s do balanceamento.  Autoriza√ß√£o em contas locais - dentro de cada cluster (po√ßo e todo o circuito) </li><li>  Os subsistemas s√£o conectados ao coelho no modo passivo: nenhuma manipula√ß√£o com as entidades dos coelhos (cria√ß√£o de filas / exchendzhe / bind) √© permitida e limitada no n√≠vel de direitos de conta - simplesmente n√£o concedemos direitos de configura√ß√£o. </li><li>  Todas as entidades necess√°rias s√£o criadas centralmente, n√£o por meio de subsistemas, e em todos os Clusters de cluster s√£o feitas da mesma maneira - para garantir a altern√¢ncia autom√°tica para o Cluster de backup e vice-versa.  Caso contr√°rio, podemos obter uma imagem: mudamos para a reserva, mas a fila ou a liga√ß√£o n√£o existe, e podemos escolher um erro de conex√£o ou perda de mensagens. </li></ol><br><h3>  Agora configura√ß√µes diretamente em coelhos: </h3><br><ol><li>  Os hosts locais n√£o t√™m acesso √† interface da web </li><li>  O acesso √† Web √© organizado por meio do LDAP - nos integramos ao AD e registramos quem e onde foi na webcam.  No n√≠vel da configura√ß√£o, restringimos os direitos das contas do AD, n√£o apenas exigimos estar em um determinado grupo, mas tamb√©m concedemos direitos de "ver".  Grupos de monitoramento s√£o mais que suficientes.  E suspendemos os direitos de administrador em outro grupo no AD, portanto, o c√≠rculo de influ√™ncia no transporte √© bastante limitado. </li><li>  Para facilitar a administra√ß√£o e o rastreamento: <br>  Em todos os VHOSTs, desligamos imediatamente uma pol√≠tica de n√≠vel 0 com aplica√ß√£o em todas as filas (padr√£o :. *): <br><br><ul><li>  <b><i>ha-mode: all</i></b> - armazena todos os dados em todos os n√≥s do cluster, a velocidade de processamento das mensagens diminui, mas sua seguran√ßa e disponibilidade s√£o garantidas. </li><li>  <b><i>ha-sync-mode: automatic</i></b> - instrui o rastreador a sincronizar dados automaticamente em todos os n√≥s do cluster: a seguran√ßa e a disponibilidade dos dados tamb√©m aumentam. </li><li>  <b><i>modo de fila: pregui√ßoso</i></b> - talvez uma das op√ß√µes mais √∫teis que apareceram em coelhos desde a vers√£o 3.6 - grava√ß√£o imediata de mensagens no disco r√≠gido.  Essa op√ß√£o reduz drasticamente o consumo de RAM e aumenta a seguran√ßa dos dados durante paradas / quedas de n√≥s ou no cluster como um todo. </li></ul><br></li><li>  Configura√ß√µes no arquivo de configura√ß√£o ( <i>rabbitmq-main / conf / rabbitmq.config</i> ): <br><br><ul><li>  <b>Coelho de</b> se√ß√£o: <i>{vm_memory_high_watermark_paging_ratio, 0.5}</i> - limite para baixar mensagens no disco 50%.  Com o <b>pregui√ßoso ativado, ele</b> serve mais como seguro quando desenhamos uma pol√≠tica, por exemplo, n√≠vel 1, na qual esquecemos de incluir o <b>pregui√ßoso</b> . </li><li>  <i>{vm_memory_high_watermark, 0,95}</i> - limitamos o coelho a 95% da RAM total, uma vez que apenas o coelho vive nos servidores, n√£o faz sentido introduzir restri√ß√µes mais rigorosas.  5% "amplo gesto" assim seja - deixe o sistema operacional, monitoramento e outras pequenas coisas √∫teis.  Como esse valor √© o limite superior, h√° o suficiente para todos. </li><li>  <i>{cluster_partition_handling, pause_minority}</i> - descreve o comportamento do cluster quando a Parti√ß√£o de Rede ocorre, para tr√™s ou mais clusters de n√≥s, esse sinalizador √© recomendado - permite que o cluster se recupere. </li><li>  <i>{disk_free_limit, "500MB"}</i> - tudo √© simples, quando h√° 500 MB de espa√ßo livre em disco - a publica√ß√£o de mensagens ser√° interrompida, apenas subtra√ß√£o estar√° dispon√≠vel. </li><li>  <i>{auth_backends, [rabbit_auth_backend_internal, rabbit_auth_backend_ldap]}</i> - ordem de autoriza√ß√£o para coelhos: Primeiro, a presen√ßa de um ultrassom no banco de dados local √© verificada e, caso contr√°rio, v√° para o servidor LDAP. </li><li>  Se√ß√£o <b>rabbitmq_auth_backend_ldap</b> - configura√ß√£o para intera√ß√£o com o AD: <i>{servers, ["srv_dc1", "srv_dc2"]]}</i> - uma lista de controladores de dom√≠nio nos quais a autentica√ß√£o ocorrer√°. </li><li>  Os par√¢metros que descrevem diretamente o usu√°rio no AD, a porta LDAP e assim por diante s√£o puramente individuais e s√£o descritos em detalhes na documenta√ß√£o. </li><li>  O mais importante para n√≥s √© uma descri√ß√£o dos direitos e restri√ß√µes de administra√ß√£o e acesso √† interface da Web de coelhos: tag_queries: <br>  <i>[{administrator, {in_group ", cn = rabbitmq-admins, ou = GRP, ou = GRP_MAIN, dc = Meu_dom√≠nio, dc = ru"}},</i> <i><br></i>  <i>{monitoramento,</i> <i><br></i>  <i>{in_group ", cn = rabbitmq-web, ou = GRP, ou = GRP_MAIN, dc = Meu_dom√≠nio, dc = ru"}</i> <i><br></i>  <i>}]</i> - esse design fornece privil√©gios administrativos para todos os usu√°rios do grupo rabbitmq-admins e direitos de monitoramento (minimamente suficientes para visualizar o acesso) para o grupo rabbitmq-web. <br></li><li>  <b>resource_access_query</b> : <br>  <i>{para,</i> <i><br></i>  <i>[{permiss√£o, configura√ß√£o, {no_grupo ", cn = rabbitmq-admins, ou = GRP, ou = GRP_MAIN, dc = Meu_dom√≠nio, dc = ru"}},</i> <i><br></i>  <i>{permiss√£o, grava√ß√£o, {no_grupo ", cn = rabbitmq-admins, ou = GRP, ou = GRP_MAIN, dc = Meu_dom√≠nio, dc = ru"}},</i> <i><br></i>  <i>{permiss√£o, leitura, {constante, verdadeiro}}</i> <i><br></i>  <i>]</i> <i><br></i>  <i>}</i> - fornecemos os direitos de configurar e gravar apenas para o grupo de administradores, para todos os que efetuam login com √™xito, os direitos s√£o somente leitura - ele pode ler mensagens atrav√©s da interface da Web. <br></li></ul></li></ol><br>  Obtemos um cluster configurado (no n√≠vel do arquivo de configura√ß√£o e das configura√ß√µes no pr√≥prio coelho) que maximiza a disponibilidade e a seguran√ßa dos dados.  Com isso, implementamos o requisito - garantindo a disponibilidade e a seguran√ßa dos dados ... na maioria dos casos. <br><br>  H√° v√°rios pontos que devem ser considerados ao operar esses sistemas altamente carregados: <br><br><ol><li>  √â melhor organizar todas as propriedades adicionais das filas (TTL, expirar, comprimento m√°ximo etc.) pelos pol√≠ticos, em vez de interromper os par√¢metros ao criar filas.  Acontece uma estrutura flex√≠vel e personaliz√°vel que pode ser personalizada rapidamente para mudar as realidades. </li><li>  Usando TTL.  Quanto maior a fila, maior a carga na CPU.  Para evitar "romper o teto", √© melhor limitar tamb√©m o comprimento da fila via comprimento m√°ximo. </li><li>  Al√©m do pr√≥prio coelho, v√°rios aplicativos utilit√°rios est√£o girando no servidor, o que, curiosamente, tamb√©m requer recursos da CPU.  Um coelho guloso, por padr√£o, ocupa todos os n√∫cleos dispon√≠veis ... Uma situa√ß√£o desagrad√°vel pode acontecer: uma luta por recursos, que pode facilmente levar a freios no coelho.  Para evitar a ocorr√™ncia de tal situa√ß√£o, por exemplo, da seguinte forma: Altere os par√¢metros do lan√ßamento do erlang - introduza um limite obrigat√≥rio no n√∫mero de n√∫cleos usados.  Fazemos o seguinte: localize o arquivo <i>rabbitmq-env</i> , procure o par√¢metro SERVER_ERL_ARGS = e adicione + sct L0-Xc0-X + SY: Y a ele.  Onde X √© o n√∫mero de n√∫cleos-1 (a contagem come√ßa em 0), Y - O n√∫mero de n√∫cleos -1 (contando em 1).  + sct L0-Xc0-X - altera a liga√ß√£o aos kernels, + SY: Y - altera o n√∫mero de shedulers iniciados pelo erlang.  Portanto, para um sistema de 8 n√∫cleos, os par√¢metros adicionados ter√£o a forma: + sct L0-6c0-6 + S 7: 7.  Dessa maneira, damos ao coelho apenas 7 n√∫cleos e esperamos que o sistema operacional, ao lan√ßar outros processos, atue de maneira ideal e os pendure em um kernel descarregado. </li></ol><br><h3>  As nuances da opera√ß√£o do zool√≥gico resultante </h3><br>  O que qualquer configura√ß√£o n√£o pode proteger √© a base colapsada da mn√©sia - infelizmente, isso acontece com uma probabilidade diferente de zero.  Um resultado t√£o desastroso n√£o √© causado por falhas globais (por exemplo, uma falha completa de um data center inteiro - a carga simplesmente mudar√° para outro cluster), mas mais falhas locais - dentro do mesmo segmento de rede. <br><br>  Al√©m disso, s√£o assustadoras as falhas na rede local, porque  o desligamento de emerg√™ncia de um ou dois n√≥s n√£o levar√° a consequ√™ncias fatais - simplesmente todas as solicita√ß√µes v√£o para um n√≥ e, como lembramos, o desempenho depende do desempenho apenas do pr√≥prio n√≥.  Falhas na rede (n√£o levamos em conta pequenas interrup√ß√µes na comunica√ß√£o - elas ocorrem sem dor) levam a uma situa√ß√£o em que os n√≥s iniciam o processo de sincroniza√ß√£o entre si e, em seguida, a conex√£o √© interrompida v√°rias vezes por alguns segundos. <br><br>  Por exemplo, v√°rias piscadas na rede e com uma frequ√™ncia de mais de 5 segundos (exatamente esse tempo limite √© definido nas configura√ß√µes do Hapov, voc√™ certamente pode reproduzi-las, mas para verificar a efic√°cia, ser√° necess√°rio repetir a falha, o que ningu√©m deseja). <br><br>  O cluster ainda pode suportar uma ou duas dessas itera√ß√µes, mas mais - as chances j√° s√£o m√≠nimas.  Em tal situa√ß√£o, a parada de um n√≥ ca√≠do pode ser salva, mas √© quase imposs√≠vel faz√™-lo manualmente.  Mais frequentemente, o resultado n√£o √© apenas a perda de um n√≥ do cluster com a mensagem <b>‚ÄúParti√ß√£o de rede‚Äù</b> , mas tamb√©m a imagem em que os dados da parte das filas viviam apenas nesse n√≥ e n√£o tinham tempo para sincronizar com os demais.  Visualmente - na fila, os dados s√£o <b><i>NaN</i></b> . <br><br>  E agora esse √© um sinal inequ√≠voco - mude para o cluster de backup.  A mudan√ßa fornecer√° um hap, voc√™ s√≥ precisa interromper os coelhos no cluster principal - em quest√£o de alguns minutos.  Como resultado, obtemos a restaura√ß√£o da capacidade de trabalho do transporte e podemos proceder com seguran√ßa √† an√°lise do acidente e sua elimina√ß√£o. <br><br>  Para remover um aglomerado danificado da carga, a fim de evitar mais degrada√ß√£o, a coisa mais simples √© fazer o coelho trabalhar em portas que n√£o sejam 5672. Como estamos monitorando os coelhos pela porta normal, seu deslocamento, por exemplo, 5673 nas configura√ß√µes do coelho, ele permitir√° que voc√™ inicie completamente o cluster sem problemas e tente restaurar sua operacionalidade e as mensagens restantes nele. <br><br>  Fazemos isso em algumas etapas: <br><br><ol><li>  Pare todos os n√≥s do cluster com falha - o hap mudar√° a carga para o cluster de backup </li><li>  RABBITMQ_NODE_PORT=5673   <i>rabbitmq-env</i> ‚Äì       ,   Web  -    15672. </li><li>            . </li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na inicializa√ß√£o, os √≠ndices ser√£o reconstru√≠dos e, na grande maioria dos casos, todos os dados ser√£o restaurados na √≠ntegra. Infelizmente, ocorrem falhas que resultam na exclus√£o f√≠sica de todas as mensagens do disco, deixando apenas a configura√ß√£o - os diret√≥rios </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msg_store_persistent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msg_store_transient</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (para a vers√£o 3.6) ou </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msg_stores</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (para a vers√£o 3.7) </font><font style="vertical-align: inherit;">s√£o exclu√≠dos na pasta do banco de dados </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√≥s essa terapia radical, o cluster √© lan√ßado com a preserva√ß√£o da estrutura interna, mas sem mensagens. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E a op√ß√£o mais desagrad√°vel (observada uma vez): os danos √† base eram de tal ordem que era necess√°rio remover completamente toda a base e reconstruir o cluster do zero.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a conveni√™ncia de gerenciar e atualizar coelhos, n√£o √© usada uma montagem pronta em rpm, mas um coelho desmontado com cpio e reconfigurado (alterado os caminhos nos scripts). A principal diferen√ßa: n√£o requer privil√©gios de root para instalar / configurar, n√£o est√° instalado no sistema (o coelho reconstru√≠do √© perfeitamente compactado em tgz) e √© executado a partir de qualquer usu√°rio. Essa abordagem permite atualizar de forma flex√≠vel as vers√µes (se n√£o exigir uma parada completa do cluster - nesse caso, basta alternar para o cluster de backup e atualizar, sem esquecer de especificar a porta deslocada para opera√ß√£o). √â at√© poss√≠vel executar v√°rias inst√¢ncias do RabbitMQ na mesma m√°quina - a op√ß√£o √© muito conveniente para testes - voc√™ pode implantar uma c√≥pia arquitetural reduzida do zool√≥gico de batalha.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como resultado do xamanismo com cpio e caminhos nos scripts, obtivemos uma op√ß√£o de constru√ß√£o: duas pastas rabbitmq-base (na montagem original - a pasta mnesia) e rabbimq-main - aqui coloquei todos os scripts necess√°rios do rabbit e erlang-se. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em rabbimq-main / bin - links simb√≥licos para scripts rabbit e erlang e um script de rastreamento de coelho (descri√ß√£o abaixo). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em rabbimq-main / init.d - o script rabbitmq-server atrav√©s do qual os logs iniciam / param / giram; em lib, o pr√≥prio coelho; na lib64 - erlang (usando uma vers√£o simplificada, apenas para coelhos, de erlang).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â extremamente f√°cil atualizar o assembly resultante quando novas vers√µes s√£o lan√ßadas - adicione o conte√∫do de rabbimq-main / lib e rabbimq-main / lib64 das novas vers√µes e substitua os links simb√≥licos no bin. Se a atualiza√ß√£o tamb√©m afetar os scripts de controle - basta alterar os caminhos para os nossos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma vantagem significativa dessa abordagem √© a continuidade completa das vers√µes - todos os caminhos, scripts, comandos de controle permanecem inalterados, o que permite o uso de qualquer script de utilit√°rio auto-escrito sem dopagem para cada vers√£o.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desde a queda dos coelhos, embora rara, mas ocorrendo, era necess√°rio implementar um mecanismo para monitorar seu bem-estar - elevar em caso de queda (mantendo os registros das raz√µes da queda). </font><font style="vertical-align: inherit;">A falha de um n√≥ em 99% dos casos √© acompanhada de uma entrada de log, e at√© mata at√© deixa rastros, o que possibilitou implementar o monitoramento do estado do coelho usando um script simples. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para as vers√µes 3.6 e 3.7, o script √© um pouco diferente devido √†s diferen√ßas nas entradas do log.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para a vers√£o 3.6</font></font></b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/python import subprocess import os import datetime import zipfile def LastRow(fileName,MAX_ROW=200): with open(fileName,'rb') as f: f.seek(-min(os.path.getsize(fileName),MAX_ROW),2) return (f.read().splitlines())[-1] if os.path.isfile('/data/logs/rabbitmq/startup_log'): if b'FAILED' in LastRow('/data/logs/rabbitmq/startup_log'): proc = subprocess.Popen("ps x|grep rabbitmq-server|grep -v 'grep'", shell=True, stdout=subprocess.PIPE) out = proc.stdout.readlines() if str(out) == '[]': cur_dt=datetime.datetime.now() try: os.stat('/data/logs/rabbitmq/after_crush') except: os.mkdir('/data/logs/rabbitmq/after_crush') z=zipfile.ZipFile('/data/logs/rabbitmq/after_crush/repair_log'+'-'+str(cur_dt.day).zfill(2)+str(cur_dt.month).zfill(2)+str(cur_dt.year)+'_'+str(cur_dt.hour).zfill(2)+'-'+str(cur_dt.minute).zfill(2)+'-'+str(cur_dt.second).zfill(2)+'.zip','a') z.write('/data/logs/rabbitmq/startup_err','startup_err') proc = subprocess.Popen("~/rabbitmq-main/init.d/rabbitmq-server start", shell=True, stdout=subprocess.PIPE) out = proc.stdout.readlines() z.writestr('res_restart.log',str(out)) z.close() my_file = open("/data/logs/rabbitmq/run.time", "a") my_file.write(str(cur_dt)+"\n") my_file.close()</span></span></code> </pre> <br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Para 3.7, apenas duas linhas s√£o alteradas</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (os.path.isfile(<span class="hljs-string"><span class="hljs-string">'/data/logs/rabbitmq/startup_log'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (os.path.isfile(<span class="hljs-string"><span class="hljs-string">'/data/logs/rabbitmq/startup_err'</span></span>)): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-string"><span class="hljs-string">b' OK '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> LastRow(<span class="hljs-string"><span class="hljs-string">'/data/logs/rabbitmq/startup_log'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (<span class="hljs-string"><span class="hljs-string">b'FAILED'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> LastRow(<span class="hljs-string"><span class="hljs-string">'/data/logs/rabbitmq/startup_log'</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (<span class="hljs-string"><span class="hljs-string">b'Gracefully halting Erlang VM'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> LastRow(<span class="hljs-string"><span class="hljs-string">'/data/logs/rabbitmq/startup_err'</span></span>)):</code> </pre><br></div></div><br><br>  Configuramos uma conta crontab sob a qual o coelho funcionar√° (por padr√£o rabbitmq) executando este script (nome do script: check_and_run) a cada minuto (primeiro, solicitamos ao administrador que d√™ √† conta o direito de usar o crontab, mas se tivermos direitos de root, n√≥s mesmos o faremos): <br>  <b><i>* / 1 * * * * ~ / rabbitmq-main / bin / check_and_run</i></b> <br><br>  O segundo ponto do uso do coelho remontado √© a rota√ß√£o dos toros. <br><br>  Como n√£o estamos vinculados ao sistema de logrotate, usamos a funcionalidade fornecida pelo desenvolvedor: o script <b>rabbitmq-server</b> do init.d (para a vers√£o 3.6) <br>  Fazendo pequenas altera√ß√µes em <i>rotate_logs_rabbitmq ()</i> <br>  Adicionar: <br><br><pre> <code class="bash hljs"> find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/http_api/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.* -maxdepth 0 -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f ! -name <span class="hljs-string"><span class="hljs-string">"*.gz"</span></span> | xargs -i gzip --force {} find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.*.back -maxdepth 0 -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f | xargs -i gzip {} find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/*.gz -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -mtime +30 -delete find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/http_api/*.gz -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -mtime +30 -delete</code> </pre><br>  O resultado da execu√ß√£o do script rabbitmq-server com a chave rotate-logs: logs s√£o compactados pelo gzip e armazenados apenas nos √∫ltimos 30 dias.  <b>http_api</b> - o caminho em que o coelho coloca os logs http - configurado no arquivo de configura√ß√£o: <i>{rabbitmq_management, [{rates_mode, detail}, {http_log_dir, path_to_logs / http_api "}]}</i> <br><br>  Ao mesmo tempo, <i>presto</i> aten√ß√£o a <i>{rates_mode, detail}</i> - a op√ß√£o aumenta um pouco a carga, mas permite que voc√™ veja informa√ß√µes sobre o usu√°rio que publica mensagens no EXCHENGE na interface WEB (e, portanto, acessa a API).  A informa√ß√£o √© extremamente necess√°ria, porque  todas as conex√µes passam pelo balanceador - veremos apenas o IP dos pr√≥prios balanceadores.  E se voc√™ confundir todos os subsistemas que trabalham com o coelho para que eles preencham os par√¢metros de propriedades do cliente nas propriedades de suas conex√µes com os coelhos, ser√° poss√≠vel obter informa√ß√µes detalhadas no n√≠vel da conex√£o sobre quem exatamente, onde e com que intensidade publica as mensagens. <br><br>  Com o lan√ßamento das novas vers√µes 3.7, houve uma rejei√ß√£o completa do script <b>rabbimq-server</b> no init.d.  Para facilitar a opera√ß√£o (a uniformidade dos comandos de controle, independentemente da vers√£o do coelho) e uma transi√ß√£o mais suave entre as vers√µes, no coelho remontado, continuamos a usar esse script.  A verdade √© outra vez: <i>mudaremos um</i> pouco <i>rotate_logs_rabbitmq ()</i> , pois o mecanismo para nomear logs ap√≥s a rota√ß√£o mudou na <i>vers√£o</i> 3.7: <br><br><pre> <code class="bash hljs"> mv <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/<span class="hljs-variable"><span class="hljs-variable">$NODENAME</span></span>.log.0 <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/<span class="hljs-variable"><span class="hljs-variable">$NODENAME</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.$(date +%Y%m%d-%H%M%S).back mv <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$NODENAME</span></span>)_upgrade.log.0 <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$NODENAME</span></span>)_upgrade.log.$(date +%Y%m%d-%H%M%S).back find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/http_api/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.* -maxdepth 0 -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f ! -name <span class="hljs-string"><span class="hljs-string">"*.gz"</span></span> | xargs -i gzip --force {} find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/*.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.* -maxdepth 0 -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f ! -name <span class="hljs-string"><span class="hljs-string">"*.gz"</span></span> | xargs -i gzip --force {} find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/*.gz -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -mtime +30 -delete find <span class="hljs-variable"><span class="hljs-variable">${RABBITMQ_LOG_BASE}</span></span>/http_api/*.gz -<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> f -mtime +30 -delete</code> </pre><br>  Agora, resta apenas adicionar a tarefa de rota√ß√£o de log ao crontab - por exemplo, todos os dias √†s 23h: <br>  <b><i>00 23 * * * ~ / rabbitmq-main / init.d / rabbitmq-server rotate-logs</i></b> <br><br>  Vamos seguir para as tarefas que precisam ser resolvidas no √¢mbito da opera√ß√£o da "fazenda de coelhos": <br><br><ol><li>  Manipula√ß√µes com entidades de coelho - cria√ß√£o / exclus√£o de entidades de coelho: ekschendzhey, filas, liga√ß√µes, p√°s, usu√°rios, pol√≠ticas.  E fazer isso √© absolutamente id√™ntico em todos os Clusters de Cluster. </li><li>  Ap√≥s alternar para / do cluster de backup, √© necess√°rio transferir as mensagens que permaneceram nele para o cluster atual. </li><li>  Criando c√≥pias de backup das configura√ß√µes de todos os Clusters de todos os circuitos </li><li>  Sincroniza√ß√£o completa das configura√ß√µes de Cluster no Contour </li><li>  Parar / iniciar coelhos </li><li>  Para analisar os fluxos de dados atuais: todas as mensagens s√£o enviadas e, se forem, ent√£o para onde devem ir ou ... </li><li>  Encontre e capture mensagens que passam por qualquer crit√©rio </li></ol><br>  A opera√ß√£o do nosso zool√≥gico e a solu√ß√£o de tarefas <i>sonoras</i> por meio do plug-in <i>rabbitmq_management</i> regular fornecido √© poss√≠vel, mas extremamente inconveniente, e √© por isso que um shell foi desenvolvido e implementado para <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">controlar toda a variedade de coelhos</a></b> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt434016/">https://habr.com/ru/post/pt434016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt434004/index.html">Plataforma Wargaming: Ol√° Mundo</a></li>
<li><a href="../pt434006/index.html">Precisamos de cookies na era do RGPD? Discutimos a situa√ß√£o e os requisitos da lei</a></li>
<li><a href="../pt434008/index.html">Como parar de se preocupar e come√ßar a escrever testes baseados em propriedades</a></li>
<li><a href="../pt434010/index.html">Para voc√™ mesmo devops ou configurar proxies Nginx para Apache Tomcat no Ubuntu em 5 minutos com https e firewall</a></li>
<li><a href="../pt434012/index.html">PVS-Studio gratuito para quem desenvolve projetos de c√≥digo aberto</a></li>
<li><a href="../pt434018/index.html">Obter um certificado de desenvolvedor Android associado ao Google</a></li>
<li><a href="../pt434034/index.html">Bons tutoriais no YouTube</a></li>
<li><a href="../pt434036/index.html">Feliz e final - as caixas de correio nos dom√≠nios do portal Qip.ru foram movidas para o Yandex</a></li>
<li><a href="../pt434038/index.html">Vendas de ve√≠culos el√©tricos plug-in na China para novembro de 2018</a></li>
<li><a href="../pt434040/index.html">Resumo da ITMO University: fale sobre projetos universit√°rios, sucessos e realiza√ß√µes de nossos graduados</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>