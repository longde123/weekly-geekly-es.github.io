<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê¨ üíÖüèª üëßüèø Seluruh kebenaran tentang RTOS. Artikel # 20. Semaphores: Layanan Tambahan dan Struktur Data ‚åöÔ∏è „Ä∞Ô∏è üíÜüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini melanjutkan review dari semaphores. 

 Layanan semafor pembantu 
 Nucleus RTOS memiliki empat panggilan API yang menyediakan fungsionalita...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seluruh kebenaran tentang RTOS. Artikel # 20. Semaphores: Layanan Tambahan dan Struktur Data</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429588/"><img src="https://habrastorage.org/webt/jd/m4/f3/jdm4f3ytpbghajx290do1pujcpa.jpeg"><br><br>  Artikel ini melanjutkan review dari semaphores. <br><br><h2>  Layanan semafor pembantu </h2><br>  Nucleus RTOS memiliki empat panggilan API yang menyediakan fungsionalitas terkait semaphore: mengatur ulang semaphore, mengambil informasi semaphore, mengambil jumlah semaphore dalam suatu aplikasi, dan mengambil pointer ke semua semaphore dalam suatu aplikasi.  Tiga yang pertama diimplementasikan dalam Nucleus SE. <br><a name="habracut"></a><br>  Artikel sebelumnya dalam seri: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Semaphores: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Layanan Pembantu dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Grup Bendera Acara: Pengantar dan Layanan Dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sinyal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Partisi Memori: Layanan dan Struktur Data</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian memori: pengantar dan layanan dasar</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Struktur data tugas dan panggilan API yang tidak didukung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan untuk bekerja dengan tugas</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas: konfigurasi dan pengantar API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: fitur canggih dan pelestarian konteks</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal: implementasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Desain dan Penyebaran Internal</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nucleus SE: Pendahuluan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Layanan RTOS lainnya</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Interaksi tugas dan sinkronisasi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas, pengalihan konteks, dan interupsi</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tugas dan Perencanaan</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: Struktur dan mode waktu-nyata</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RTOS: pengantar.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><br></a> <br><h3>  Setel ulang semaphore </h3><br>  Panggilan API ini mengatur ulang semaphore ke kondisi awal, yang tidak digunakan.  Fungsi API ini tidak biasa dibandingkan dengan fungsi-fungsi objek kernel lainnya, karena meskipun faktanya melakukan reset, ia tidak hanya menetapkan penghitung ke nilai awal, tetapi nilai penghitung awal baru diteruskan dalam panggilan.  Tugas apa pun yang telah dijeda pada semaphore dilanjutkan dan mengembalikan kode <b>NUSE_SEMAPHORE_WAS_RESET</b> di Nucleus SE, dan di Nucleus RTOS, <b>NU_SEMAPHORE_RESET</b> . <br><br>  <b><i>Panggilan untuk mengatur ulang semaphore di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Reset_Semaphore (NU_SEMAPHORE * semaphore, UNSIGNED initial_count);</b> <br><br>  Parameter: <br><br>  <b>semaphore</b> - penunjuk ke blok kontrol semaphore yang disediakan oleh pengguna; <br>  <b>initial_count</b> - nilai yang akan ditetapkan semaphore. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_SEMAPHORE</b> - Pointer semaphore <b>tidak valid</b> . <br><br>  <b><i>Panggilan untuk mengatur ulang semafor di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NUSE_Semaphore_Reset (NUSE_SEMAPHORE semaphore, U8 initial_count);</b> <br><br>  Parameter: <br><br>  <b>semaphore</b> - index (ID) dari semaphore yang dibuang; <br>  <b>initial_count</b> - nilai yang akan ditetapkan semaphore. <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_SEMAPHORE</b> - indeks semaphore tidak valid. <br><br>  <b><i>Menerapkan reset semaphore di Nucleus SE</i></b> <br><br>  Tugas utama dari fungsi API <b>NUSE_Semaphore_Reset ()</b> adalah untuk mengatur elemen <b>NUSE_Semaphore_Counter [] yang</b> sesuai ke nilai yang ditentukan (setelah memeriksa parameter). <br><br>  Jika penguncian tugas diaktifkan, kode berikut diperlukan untuk membuka kunci tugas: <br><br><pre><code class="plaintext hljs">while (NUSE_Semaphore_Blocking_Count[semaphore] != 0) { U8 index; /* check whether any tasks are blocked */ /* on this semaphore */ for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_SEMAPHORE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == semaphore)) { NUSE_Task_Blocking_Return[index] = NUSE_SEMAPHORE_WAS_RESET; NUSE_Task_Status[index] = NUSE_READY; break; } } NUSE_Semaphore_Blocking_Count[semaphore]--; } #if NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif</code> </pre> <br>  Setiap tugas yang ditangguhkan pada semafor ditandai sebagai "selesai", dan kode penangguhan tugas mengembalikan <b>NUSE_SEMAPHORE_WAS_RESET</b> .  Setelah proses ini selesai, jika penjadwal Prioritas digunakan, panggilan akan menginisialisasi <b>NUSE_Reschedule ()</b> , karena satu atau lebih tugas dengan prioritas yang lebih tinggi dapat masuk ke status siap dan sedang menunggu untuk melanjutkan. <br><br><h3>  Informasi semaphore </h3><br>  Panggilan utilitas ini mengembalikan informasi semafor.  Implementasi panggilan ini dalam Nucleus SE berbeda dari Nucleus RTOS karena lebih sedikit informasi yang dikembalikan, karena penamaan objek dan urutan jeda tidak didukung, dan penangguhan tugas itu sendiri dapat dinonaktifkan. <br><br>  <b><i>Panggil untuk informasi semaphore di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Semaphore_Information (NU_SEMAPHORE * semaphore, CHAR * name, UNSIGNED * current_count, OPTION * suspend_type, UNSIGNED * task_waiting, NU_TASK ** first_task);</b> <br><br>  Parameter: <br><br>  <b>semaphore</b> - pointer ke blok kontrol semaphore tentang informasi mana yang diperlukan; <br>  <b>name</b> - pointer ke nama 8-karakter semaphore, dengan nol terminasi byte termasuk dalam area ini; <br>  <b>current_count</b> - pointer ke variabel yang akan mengambil nilai saat ini dari penghitung semaphore; <br>  <b>suspend_type</b> - pointer ke variabel yang akan menerima jenis tugas yang ditangguhkan, dapat mengambil nilai <b>NU_FIFO</b> dan <b>NU_PRIORITY</b> ; <br>  <b>task_waiting</b> - pointer ke variabel yang akan mengambil jumlah tugas yang ditangguhkan di semaphore; <br>  <b>first_task</b> - pointer ke variabel tipe <b>NU_TASK</b> , yang akan membawa pointer ke unit kontrol tugas yang ditangguhkan pertama. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_SEMAPHORE</b> - Pointer semaphore <b>tidak valid</b> . <br><br>  <b><i>Panggilan untuk informasi semafor di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NUSE_Semaphore_Information (NUSE_SEMAPHORE semaphore, U8 * current_count, U8 * task_waiting, NUSE_TASK * first_task);</b> <br><br>  Parameter: <br><br>  <b>semaphore</b> - indeks semaphore yang dibutuhkan untuk memberikan informasi; <br>  <b>current_count</b> - pointer ke variabel yang akan mengambil nilai saat ini dari penghitung semaphore; <br>  <b>task_waiting</b> - pointer ke variabel yang akan mengambil jumlah tugas yang ditangguhkan pada semaphore ini (tidak ada yang dikembalikan jika dukungan untuk tugas yang ditangguhkan dinonaktifkan); <br>  <b>first_task</b> - pointer ke variabel tipe <b>NUSE_TASK</b> , yang akan mengambil indeks tugas yang dijeda pertama (tidak ada yang dikembalikan jika dukungan untuk tugas jeda dinonaktifkan). <br><br>  Nilai pengembalian: <br><br>  <b>NUSE_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NUSE_INVALID_SEMAPHORE</b> - indeks semaphore tidak valid; <br>  <b>NUSE_INVALID_POINTER</b> - satu atau beberapa parameter pointer salah. <br><br>  <b><i>Menerapkan informasi semaphore di Nucleus SE</i></b> <br><br>  Menerapkan panggilan API ini cukup sederhana: <br><br><pre> <code class="plaintext hljs">NUSE_CS_Enter(); *current_count = NUSE_Semaphore_Counter[semaphore]; #if NUSE_BLOCKING_ENABLE *tasks_waiting = NUSE_Semaphore_Blocking_Count[semaphore]; if (NUSE_Semaphore_Blocking_Count[semaphore] != 0) { U8 index; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_SEMAPHORE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == semaphore)) { *first_task = index; break; } } } else { *first_task = 0; } #else *tasks_waiting = 0; *first_task = 0; #endif NUSE_CS_Exit(); return NUSE_SUCCESS;</code> </pre><br>  Fungsi mengembalikan status semaphore.  Kemudian, jika fungsionalitas pemblokiran panggilan API diaktifkan, jumlah tugas yang tertunda dan indeks yang pertama dikembalikan (jika tidak, parameter ini diatur ke 0). <br><br><h3>  Mendapatkan jumlah semaphores </h3><br>  Panggilan utilitas ini mengembalikan jumlah semafor dalam aplikasi.  Dalam Nucleus RTOS, nilai ini berubah seiring waktu dan nilai kembali sesuai dengan jumlah semafor saat ini, dan dalam Nucleus SE, nilai kembali diatur pada tahap perakitan dan tidak berubah lagi. <br><br>  <b><i>Memanggil penghitung semafor di Nucleus RTOS</i></b> <br><br>  Prototipe panggilan layanan: <br><br>  <b>NU_Established_Semaphores (VOID) TIDAK DITANDATANGANI;</b> <br><br>  Parameter: <br>  Tidak ada. <br><br>  Nilai pengembalian: <br>  Jumlah semaphore yang dibuat dalam aplikasi. <br><br>  <b><i>Memanggil penghitung semafor di Nucleus SE</i></b> <br>  Panggilan API ini mendukung fungsionalitas inti API Nucleus RTOS. <br><br>  Prototipe panggilan layanan: <br><br>  <b>U8 NUSE_Semaphore_Count (batal);</b> <br><br>  Parameter: <br>  Tidak ada. <br><br>  Nilai pengembalian: <br>  Jumlah semafor yang dikonfigurasi dalam aplikasi. <br><br>  <b><i>Menerapkan penghitung semafor di Nucleus SE</i></b> <br>  Implementasi panggilan API ini cukup sederhana: nilai simbol <b>#define</b> <b>NUSE_SEMAPHORE_NUMBER dikembalikan</b> . <br><br><h2>  Struktur data </h2><br>  Semaphore menggunakan dua atau tiga larik struktur data (dalam RAM dan ROM), yang, seperti semua objek SE Nucleus lainnya, adalah seperangkat tabel yang ukurannya tergantung pada jumlah semaphore dalam aplikasi dan parameter yang dipilih. <br><br>  Saya sangat merekomendasikan bahwa kode aplikasi tidak menggunakan akses langsung ke struktur data ini, tetapi merujuknya melalui fungsi API yang disediakan.  Ini akan menghindari ketidakcocokan dengan versi Nucleus SE di masa depan dan efek samping yang tidak diinginkan, serta menyederhanakan porting aplikasi ke Nucleus RTOS.  Untuk pemahaman yang lebih baik tentang cara kerja kode panggilan layanan dan untuk debugging, gambaran umum terperinci dari struktur data diberikan di bawah ini. <br><br><h3>  Data RAM </h3><br>  Data ini memiliki struktur sebagai berikut: <br>  <b>NUSE_Semaphore_Counter []</b> - larik tipe <b>U8</b> yang memiliki satu entri untuk setiap semafor yang dikonfigurasi, ia menyimpan nilai penghitung. <br>  <b>NUSE_Semaphore_Blocking_Count []</b> - larik tipe <b>U8</b> , berisi penghitung tugas yang diblokir pada setiap semafor.  Array ini hanya ada jika fungsionalitas pemblokiran panggilan API diaktifkan. <br>  <b>NUSE_Semaphore_Counter []</b> diinisialisasi ke nilai awal (lihat "Data dalam ROM" di bawah), dan <b>NUSE_Semaphore_Blocking_Count []</b> <b>diatur ulang</b> menggunakan <b>NUSE_Init_Semaphore ()</b> ketika Nucleus SE dimulai.  Salah satu artikel berikut akan memberikan deskripsi lengkap tentang prosedur startup Nucleus SE. <br><br>  Berikut ini adalah definisi dari struktur data ini dalam file <b>nuse_init.c</b> . <br><br><pre> <code class="plaintext hljs">RAM U8 NUSE_Semaphore_Counter[NUSE_SEMAPHORE_NUMBER]; #if NUSE_BLOCKING_ENABLE RAM U8 NUSE_Semaphore_Blocking_Count[NUSE_SEMAPHORE_NUMBER]; #endif</code> </pre><br><h3>  Data ROM </h3><br>  Struktur data: <br>  <b>NUSE_Semaphore_Initial_Value []</b> - larik tipe <b>U8</b> , memiliki satu catatan untuk setiap semaphore, ini adalah nilai awal dari semaphore. <br><br>  Struktur data ini dideklarasikan dan diinisialisasi (secara statis) di <b>nuse_config.c</b> : <br><br><pre> <code class="plaintext hljs">ROM U8 NUSE_Semaphore_Initial_Value[NUSE_SEMAPHORE_NUMBER] = { /* semaphore initial count values */ };</code> </pre><br><h3>  Jumlah memori untuk semaphores </h3><br>  Seperti semua objek kernel Nucleus SE, jumlah data yang diperlukan untuk semaphores dapat diprediksi. <br><br>  Jumlah memori dalam ROM (dalam byte) untuk semua semafor dalam aplikasi adalah <b>NUSE_SEMAPHORE_NUMBER</b> . <br><br>  Jumlah memori dalam RAM (dalam byte) untuk semua semafor dalam aplikasi dengan panggilan yang diaktifkan ke API kunci dapat dihitung sebagai berikut: <br> <code>NUSE_SEMAPHORE_NUMBER * 2</code> <br> <br>  Kalau tidak, itu adalah <b>NUSE_SEMAPHORE_NUMBER</b> . <br><br><h2>  Panggilan API yang belum direalisasi </h2><br>  Tiga panggilan API untuk semafor yang hadir di Nucleus RTOS tidak diterapkan di Nucleus SE. <br><br><h3>  Membuat semafor </h3><br>  Panggilan API ini menciptakan semafor.  Tidak perlu untuk Nucleus SE karena semaphores dibuat secara statis. <br><br>  Prototipe panggilan layanan: <br>  <b>STATUS NU_Create_Semaphore (NU_SEMAPHORE * semaphore, CHAR * nama, initial_count UNSIGNED, OPTION suspend_type);</b> <br><br>  Parameter: <br><br>  <b>semaphore</b> - pointer ke blok kontrol semaphore yang disediakan oleh pengguna, digunakan untuk mengontrol semaphores dalam panggilan API lainnya; <br>  <b>name</b> - pointer ke nama semaphore 8-karakter, dengan terminasi null byte dihidupkan; <br>  <b>initial_count</b> - nilai awal semaphore; <br>  <b>suspend_type</b> - Menunjukkan prinsip menjeda tugas pada semafor.  Ini dapat mengambil nilai <b>NU_FIFO</b> dan <b>NU_PRIORITY</b> , sesuai dengan prinsip FIFO (First-in-First-Out) dan urutan prioritas penangguhan tugas. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_SEMAPHORE</b> - Mengatakan bahwa penunjuk ke blok kontrol semaphore adalah <b>NULL</b> atau sudah digunakan; <br>  <b>NU_INVALID_SUSPEND</b> - parameter <b>suspend_type</b> tidak valid. <br><br><h3>  Penghapusan semaphore </h3><br>  Panggilan API ini menghapus semafor yang dibuat sebelumnya.  Nucleus SE tidak diperlukan karena semaphore dibuat secara statis dan tidak dapat dihapus. <br><br>  Prototipe panggilan layanan: <br><br>  <b>STATUS NU_Delete_Semaphore (NU_SEMAPHORE * semaphore);</b> <br><br>  Parameter: <br><br>  <b>semaphore</b> - penunjuk ke blok kontrol semaphore. <br><br>  Nilai pengembalian: <br><br>  <b>NU_SUCCESS</b> - panggilan berhasil diselesaikan; <br>  <b>NU_INVALID_SEMAPHORE</b> - Pointer semaphore <b>tidak valid</b> . <br><br><h3>  Pointer ke semaphores </h3><br>  Panggilan API ini membentuk daftar pointer berurutan untuk semua semafor dalam sistem.  Tidak perlu Nucleus SE, karena semaphores diidentifikasi oleh indeks sederhana, bukan pointer. <br><br>  Prototipe panggilan layanan: <br><br>  <b>NU_Semaphore_Pointers TIDAK DITANDATANGANI (NU_SEMAPHORE ** pointer_list, maksimum_pointers UNSIGNED);</b> <br><br>  Parameter: <br><br>  <b>pointer_list</b> - pointer ke array pointer <b>NU_SEMAPHORE</b> , array ini diisi dengan pointer ke semaphores; <br>  <b>maximum_pointers</b> - jumlah maksimum pointer dalam array. <br><br>  Nilai pengembalian: <br>  Jumlah <b>NU_SEMAPHORE</b> pointer dalam array. <br><br><h2>  Kompatibel dengan RTOS Inti </h2><br>  Seperti semua objek Nucleus SE lainnya, tujuannya adalah untuk memaksimalkan kompatibilitas kode aplikasi dengan Nucleus RTOS.  Semaphore tidak terkecuali dan, dari sudut pandang pengguna, mereka diimplementasikan dengan cara yang sama seperti pada Nucleus RTOS.  Ada juga ketidakcocokan tertentu, yang saya anggap dapat diterima mengingat fakta bahwa kode akhir akan menjadi lebih dimengerti dan lebih efisien dalam hal jumlah memori yang diperlukan.  Jika tidak, panggilan Nucleus RTOS API dapat digunakan hampir secara langsung sebagai panggilan Nucleus SE. <br><br><h3>  Pengidentifikasi Objek </h3><br>  Dalam Nucleus RTOS, semua objek dijelaskan oleh struktur data (unit kontrol) dari tipe tertentu.  Penunjuk ke unit kontrol ini berfungsi sebagai pengidentifikasi untuk semaphore.  Saya memutuskan bahwa dalam Nucleus SE, diperlukan pendekatan yang berbeda untuk penggunaan memori yang efisien: semua objek kernel dijelaskan oleh seperangkat tabel dalam RAM dan / atau ROM.  Ukuran tabel ini ditentukan oleh jumlah objek yang dikonfigurasi dari setiap jenis.  Pengidentifikasi objek tertentu adalah indeks dalam tabel ini.  Jadi saya mendefinisikan <b>NUSE_SEMAPHORE</b> sebagai setara dengan <b>U8</b> , variabel (bukan pointer) dari tipe ini berfungsi sebagai pengidentifikasi untuk semaphore.  Ketidakcocokan sedikit ini mudah ditangani jika kode porting dari Nucleus SE ke Nucleus RTOS dan sebaliknya.  Biasanya, tidak ada operasi yang dilakukan pada pengidentifikasi objek selain memindahkan dan menyimpan. <br><br>  Nucleus RTOS juga mendukung penamaan semaphores.  Nama-nama ini hanya digunakan untuk debugging.  Saya mengecualikan mereka dari Nucleus SE untuk menghemat memori. <br><br><h3>  Ukuran penghitung </h3><br>  Pada Nucleus RTOS, penghitung semaphore bertipe <b>unsigned</b> , yang biasanya merupakan variabel 32-bit.  Nucleus SE memiliki penghitung 8-bit, tetapi ini dapat dengan mudah diubah.  Biasanya, Nucleus RTOS tidak memeriksa untuk semaphore overflow.  Memanggil Nucleus SE API tidak akan mengizinkan penghitung untuk diberi nilai di atas 255. <br><br><h3>  Panggilan API yang belum direalisasi </h3><br>  Nucleus RTOS mendukung delapan panggilan utilitas untuk bekerja dengan semaphores.  Dari jumlah tersebut, tiga tidak diimplementasikan dalam Nucleus SE.  Rincian tantangan ini, serta keputusan untuk mengeluarkannya dari Nucleus SE, telah dijelaskan di atas. <br><br>  Artikel berikut akan memeriksa kotak surat. <br><br>  <b>Tentang Pengarang:</b> Colin Walls telah bekerja di industri elektronik selama lebih dari tiga puluh tahun, mencurahkan sebagian besar waktunya untuk firmware.  Dia sekarang adalah seorang insinyur firmware di Mentor Embedded (sebuah divisi dari Mentor Graphics).  Colin Walls sering berbicara di konferensi dan seminar, penulis berbagai artikel teknis dan dua buku tentang firmware.  Tinggal di Inggris.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Colin</a> , email: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id429588/">https://habr.com/ru/post/id429588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id429574/index.html">Gratis Check Point untuk Kursus Pemula di CheckMates</a></li>
<li><a href="../id429578/index.html">Kesalahan apa yang disembunyikan dalam kode Infer.NET?</a></li>
<li><a href="../id429580/index.html">Interaksi mikro di iOS. Kuliah Yandex</a></li>
<li><a href="../id429582/index.html">Indikator analog beban komputer</a></li>
<li><a href="../id429586/index.html">Cara menentukan waktu terbaik untuk berdagang di bursa</a></li>
<li><a href="../id429590/index.html">Analisis suara untuk pusat panggilan berbasis SOLR</a></li>
<li><a href="../id429592/index.html">Bagaimana kartu bank mempengaruhi ekonomi dan mengapa bola cue tidak lepas landas</a></li>
<li><a href="../id429594/index.html">Analisis kecepatan mikromotor molekuler untuk diagnosis HIV</a></li>
<li><a href="../id429596/index.html">Apa yang perlu Anda lakukan di Jawa untuk sepenuhnya mendukung pembelajaran mesin</a></li>
<li><a href="../id429598/index.html">Inventarisasi UHF RFID. Bagaimana cara menemukan semua tag?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>