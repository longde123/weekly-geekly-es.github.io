<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ†” ğŸ‘©ğŸ¾â€ğŸ¤â€ğŸ‘©ğŸ» â™Šï¸ Bagaimana kami melakukan otomatisasi jaringan warisan yang besar âœ¨ ğŸˆ ğŸ‘©ğŸ¿â€ğŸ³</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai Kami memiliki 15.260+ objek dan 38.000 perangkat jaringan yang perlu dikonfigurasi, diperbarui, dan diverifikasi agar operasional. Memelihara arma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami melakukan otomatisasi jaringan warisan yang besar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/X5RetailGroup/blog/468197/">  Hai  Kami memiliki 15.260+ objek dan 38.000 perangkat jaringan yang perlu dikonfigurasi, diperbarui, dan diverifikasi agar operasional.  Memelihara armada peralatan semacam itu cukup sulit dan membutuhkan banyak waktu, tenaga, dan manusia.  Oleh karena itu, kami perlu mengotomatiskan pekerjaan dengan peralatan jaringan dan kami memutuskan untuk mengadaptasi konsep Jaringan sebagai Kode untuk mengelola jaringan di perusahaan kami.  Di bawah potongan, bacalah riwayat otomatisasi kami, kesalahan yang dibuat dan rencana lebih lanjut untuk membangun sistem. <br><br><img src="https://habrastorage.org/webt/tq/6w/po/tq6wposkryjnbyoqfcpv6qgj-q8.png"><br><a name="habracut"></a><br><h2>  Singkat cerita, kami ingin mengotomatiskan jaringan </h2><br>  Hai  Nama saya Alexander Prokhorov, dan bersama-sama dengan tim insinyur jaringan di departemen kami, kami <b>mengerjakan</b> jaringan di <b>#IT</b> <b><font color="#FFA500">X5</font></b> .  Departemen kami mengembangkan infrastruktur jaringan, pemantauan, otomatisasi jaringan, dan arah Jaringan yang trendi sebagai Kode. <br><br>  Awalnya, saya tidak benar-benar percaya pada otomatisasi pada jaringan kami pada prinsipnya.  Ada banyak kesalahan warisan dan konfigurasi - tidak di mana-mana ada otorisasi pusat, tidak semua perangkat keras mendukung SSH, tidak di mana-mana <abbr title="Protokol manajemen jaringan yang sederhana">SNMP</abbr> dikonfigurasi.  Semua ini sangat merusak kepercayaan pada otomatisasi.  Karena itu, pertama-tama, kami mengatur apa yang diperlukan untuk memulai otomatisasi, yaitu: standardisasi koneksi SSH, otorisasi tunggal ( <abbr title="Otentikasi, Otorisasi, Akuntansi">AAA</abbr> ) dan profil SNMP.  Semua fondasi ini memungkinkan Anda untuk menulis alat untuk pengiriman massal konfigurasi ke perangkat, tetapi muncul pertanyaan: bisakah saya mendapatkan lebih banyak?  Jadi kami sampai pada kebutuhan untuk menyusun rencana pengembangan otomatisasi dan konsep Jaringan sebagai Kode, khususnya. <br><br>  Konsep Jaringan sebagai Kode, menurut Cisco, berarti prinsip-prinsip berikut: <br><br><ul><li>  Menyimpan konfigurasi target dalam repositori, Kontrol Sumber </li><li>  Perubahan konfigurasi melalui repositori, Single Source of Truth </li><li>  Menanamkan konfigurasi melalui <abbr title="Antarmuka pemrograman aplikasi">API</abbr> </li></ul><br><img src="https://habrastorage.org/webt/bw/wi/6u/bwwi6us89ipickqukqdgd1zkvk0.jpeg" align="right" width="240"><br><br>  Dua poin pertama memungkinkan Anda untuk menerapkan pendekatan DevOps atau NetDevOps untuk mengelola infrastruktur jaringan Anda.  Dengan paragraf ketiga ada kesulitan, misalnya, apa yang harus dilakukan jika tidak ada API?  Tentu saja, SSH dan CLI, kami adalah penggiat jejaring! <br><br><div class="spoiler">  <b class="spoiler_title">Dan apakah itu yang kita butuhkan?</b> <div class="spoiler_text">  Penerapan prinsip-prinsip ini saja tidak menyelesaikan semua masalah infrastruktur jaringan, seperti halnya penerapannya membutuhkan fondasi tertentu dengan data jaringan. <br><br>  Pertanyaan yang muncul ketika kami memikirkan hal ini: <br><br><ul><li>  OK, saya menyimpan konfigurasi sebagai kode, bagaimana saya harus menerapkannya pada objek tertentu? </li><li>  Oke, saya memiliki template konfigurasi di repositori, tetapi bagaimana saya bisa secara otomatis mengkonfigurasi konfigurasi untuk objek yang didasarkan padanya? </li><li>  Bagaimana cara mengetahui model dan vendor mana yang harus ada pada objek ini?  Bisakah saya melakukannya secara otomatis? </li><li>  Bagaimana saya bisa mengecek apakah pengaturan objek saat ini cocok dengan parameter dalam repositori? </li><li>  Bagaimana cara bekerja dengan perubahan dalam repositori dan mereplikasi mereka di jaringan yang produktif? </li><li>  Perangkat data dan sistem apa yang perlu saya pikirkan tentang Penyediaan Zero Touch? </li><li>  Bagaimana dengan perbedaan dalam vendor, dan bahkan model dari vendor yang sama? </li><li>  Bagaimana cara menyimpan subnet untuk konfigurasi otomatis? </li></ul><br>  Berdasarkan semua pertanyaan di atas, menjadi jelas bahwa kita membutuhkan seperangkat sistem yang menyelesaikan berbagai masalah, bekerja bersama satu sama lain dan memberi kita informasi lengkap tentang infrastruktur jaringan. <br><br><img src="https://habrastorage.org/webt/iz/us/cx/izuscxapcn5-6ync8yexgqlxs0u.jpeg"><br></div></div><br>  Selain mencoba menerapkan pendekatan baru pada manajemen jaringan, kami ingin menyelesaikan beberapa masalah yang lebih akut dalam infrastruktur jaringan, seperti integritas data, pembaruan, dan, tentu saja, otomatisasi.  Maksud kami bukan hanya pengiriman massal konfigurasi ke peralatan, tetapi juga konfigurasi otomatis, pengumpulan otomatis data inventaris peralatan jaringan, integrasi dengan sistem pemantauan.  Tetapi hal pertama yang pertama. <br><br>  Fungsi yang kami tuju adalah: <br><br><ul><li>  Basis data peralatan jaringan (+ penemuan, + pembaruan otomatis) </li><li>  Alamat jaringan dasar (pemeriksaan validasi IPAM +) </li><li>  Integrasi sistem pemantauan dengan data inventaris </li><li>  Penyimpanan standar konfigurasi dalam sistem kontrol versi </li><li>  Pembentukan konfigurasi target secara otomatis untuk suatu objek </li><li>  Pengiriman massal konfigurasi ke peralatan jaringan </li><li>  Menerapkan proses CI / CD untuk mengelola perubahan konfigurasi jaringan </li><li>  Menguji konfigurasi jaringan dengan CI / CD </li><li>  ZTP (Zero Touch Provisioning) - pengaturan otomatis peralatan untuk suatu objek </li></ul><br><div class="spoiler">  <b class="spoiler_title">Ceritanya panjang, kami mencoba otomatisasi</b> <div class="spoiler_text">  Kami mulai mencoba mengotomatiskan pekerjaan pengaturan jaringan 2 tahun yang lalu.  Mengapa sekarang pertanyaan ini muncul lagi dan perlu perhatian? <br><br>  Sangat membosankan dan membosankan untuk mengkonfigurasi lebih dari beberapa lusin perangkat dengan tangan Anda.  Terkadang tangan sang insinyur berkedut, dan ia melakukan kesalahan.  Untuk beberapa lusin, skrip yang ditulis oleh satu insinyur biasanya cukup, yang menggulung pengaturan yang diperbarui ke peralatan jaringan. <br><br>  Kenapa tidak berhenti di situ saja?  Faktanya, banyak insinyur jaringan sudah tahu bagaimana melakukan semua jenis ular sanca, dan mereka yang tidak tahu bagaimana akan dapat melakukannya segera (Natalya Samoilenko, bagaimanapun, telah menerbitkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">karya yang luar biasa tentang Python</a> , terutama untuk penggiat jejaring).  Siapa pun yang bertugas mengkonfigurasi n + 1 router dapat menulis skrip dan menjalankan pengaturan dengan sangat cepat.  Jauh lebih cepat dari itu mampu mengembalikan semuanya.  Menurut pengalaman otomatisasi "setiap orang untuk dirinya sendiri", kesalahan terjadi ketika Anda dapat memulihkan komunikasi hanya dengan tangan Anda, dan hanya dengan penderitaan besar dari seluruh tim. <br><br><img src="https://habrastorage.org/webt/rp/ts/ie/rptsiexeli86bdhhumak_d1z7eo.jpeg"><br><br><h5>  Contoh </h5><br><img src="https://habrastorage.org/webt/ow/q8/tk/owq8tkmg8p5xeorxn0ypbwqudw0.png" align="right" width="240">  Suatu ketika, salah satu insinyur memutuskan untuk melakukan tugas penting - untuk memulihkan ketertiban dalam konfigurasi router.  Sebagai hasil audit pada beberapa objek, <i><font color="#008080">daftar awalan</font></i> usang dengan subnet spesifik ditemukan, yang tidak lagi kami perlukan.  Sebelumnya, ini digunakan untuk memfilter alamat <i><font color="#008080">loopback</font></i> dari situs pusat sehingga hanya melalui satu saluran, dan kami dapat menguji koneksi pada saluran ini.  Tetapi mekanismenya dioptimalkan, dan mereka berhenti menggunakan skema pengujian saluran semacam itu.  Karyawan memutuskan untuk menghapus <i><font color="#008080">daftar awalan</font></i> ini sehingga tidak muncul dalam konfigurasi dan menyebabkan kebingungan di masa depan.  Semua orang setuju untuk menghapus daftar <i><font color="#008080">awalan yang</font></i> tidak digunakan, tugasnya sederhana, mereka langsung lupa.  Tetapi menghapus daftar <i><font color="#008080">awalan yang</font></i> sama dengan tangan Anda pada lusinan objek cukup membosankan dan memakan waktu.  Dan insinyur itu menulis sebuah skrip yang akan dengan cepat melewati peralatan, membuat <i><font color="#008080">"no prefix-list pl-cisco-primer"</font></i> dan dengan sungguh-sungguh menyimpan konfigurasi. <br><br>  Beberapa waktu setelah diskusi, beberapa jam, atau sehari, saya tidak ingat, satu benda jatuh.  Setelah beberapa menit, yang lain, serupa.  Jumlah objek yang tidak dapat diakses terus bertambah, dalam setengah jam menjadi 10, dan setiap 2-3 menit satu yang baru ditambahkan.  Semua insinyur terhubung untuk diagnosis.  40-50 menit setelah dimulainya kecelakaan, semua orang ditanyai tentang perubahan itu, dan karyawan itu menghentikan skripnya.  Saat itu, sudah ada sekitar 20 objek dengan saluran rusak.  Pemulihan penuh memakan waktu 7 insinyur selama beberapa jam. <br><br><h5>  Sisi teknis </h5><br>  <i><font color="#008080">Prefix-list</font></i> digunakan untuk memfilter <i><font color="#008080">loopbacks</font></i> - satu difilter pada satu saluran, yang kedua pada cadangan.  Ini digunakan untuk menguji komunikasi tanpa mengalihkan lalu lintas produktif antara saluran.  Oleh karena itu, aturan pertama dari <i><font color="#008080">rute-peta yang</font></i> masuk pada tetangga <i><font color="#008080">BGP</font></i> adalah <i><font color="#008080">DENY</font></i> dengan <i><font color="#008080">"mencocokkan daftar awalan alamat ip"</font></i> .  Aturan-aturan lainnya dalam <i><font color="#008080">rute-peta</font></i> adalah <i><font color="#008080">IZIN</font></i> . <br><br>  Ada beberapa nuansa yang mungkin perlu diperhatikan: <br><br><ul><li>  Aturan <i><font color="#008080">rute-peta</font></i> di mana tidak ada <i><font color="#008080">kecocokan</font></i> - melewatkan segalanya </li><li>  Pada akhir <i><font color="#008080">awalan-daftar adalah</font></i> <i><font color="#008080">implisit deny</font></i> , tetapi hanya jika tidak kosong </li><li>  <i><font color="#008080">Daftar awalan</font></i> kosong adalah <i><font color="#008080">izin tersirat</font></i> </li></ul><br>  Semua hal di atas berlaku untuk <b>Cisco IOS</b> .  <i><font color="#008080">Daftar awalan</font></i> kosong dapat muncul saat Anda mendeklarasikan <i><font color="#008080">peta rute</font></i> , menjadikannya <i><font color="#008080">"cocok dengan daftar awalan alamat ip pl-test-cisco"</font></i> .  <i><font color="#008080">Daftar awalan</font></i> ini tidak akan secara eksplisit dinyatakan dalam konfigurasi (selain baris dengan <i><font color="#008080">kecocokan</font></i> ), tetapi dapat ditemukan di <i><font color="#008080">show ip prefix-list</font></i> . <br><br><pre><code class="plaintext hljs">2901-NOC-4.2(config)#route-map rm-test-in 2901-NOC-4.2(config-route-map)#match ip address prefix-list pl-test-in 2901-NOC-4.2(config-route-map)#do sh run | i prefix match ip address prefix-list pl-test-in 2901-NOC-4.2(config-route-map)#do sh ip prefix ip prefix-list pl-test-in: 0 entries 2901-NOC-4.2(config-route-map)#</code> </pre> <br>  Kembali ke apa yang terjadi, ketika daftar <i><font color="#008080">awalan</font></i> dihapus oleh skrip, itu menjadi kosong, karena itu masih dalam aturan <i><font color="#008080">DENY</font></i> pertama di <i><font color="#008080">rute-peta</font></i> .  <i><font color="#008080">Daftar awalan</font></i> kosong memungkinkan semua subnet, sehingga segala sesuatu yang diberikan oleh rekan <i><font color="#008080">BGP</font></i> kepada kami termasuk dalam aturan <i><font color="#008080">DENY</font></i> pertama. <br>  Mengapa insinyur itu tidak segera menyadari bahwa ia telah memutuskan koneksi?  Di sini memainkan peran timer <i><font color="#008080">BGP</font></i> di Cisco. <br>  <i><font color="#008080">BGP</font></i> sendiri tidak bertukar rute pada suatu jadwal, dan jika Anda memperbarui kebijakan perutean <i><font color="#008080">BGP</font></i> , Anda perlu mengatur ulang sesi BGP untuk menerapkan perubahan, <i><font color="#008080">"hapus ip bgp &lt;peer-ip&gt;"</font></i> ke Cisco. <br><br>  Agar tidak mengatur ulang sesi, ada dua mekanisme: <br><br><ul><li>  Cisco <b>Soft-Reconfiguration</b> </li><li>  <b>Rute Refresh</b> sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RFC2918</a> </li></ul><br>  <b>Soft-konfigurasi ulang</b> menyimpan informasi yang diterima di <i><font color="#008080">UPDATE</font></i> dari tetangga tentang rute sampai kebijakan diterapkan <i><font color="#008080">dalam</font></i> tabel <i><font color="#008080">adj-RIB-in lokal</font></i> .  Saat memperbarui kebijakan, dimungkinkan untuk meniru <i><font color="#008080">UPDATE</font></i> dari tetangga. <br>  <b>Route Refresh</b> adalah "kemampuan" rekan kerja untuk mengirim <i><font color="#008080">UPDATE</font></i> berdasarkan permintaan.  Ketersediaan kesempatan ini disepakati saat membangun lingkungan.  Pro - Tidak perlu menyimpan salinan <i><font color="#008080">UPDATE</font></i> secara lokal.  Kontra - dalam praktek, setelah permintaan <i><font color="#008080">PEMBARUAN</font></i> dari tetangga, Anda perlu menunggu sampai dia mengirimkannya.  Omong-omong, Anda dapat menonaktifkan fitur di Cisco dengan perintah tersembunyi: <br><br><pre> <code class="plaintext hljs">neighbor &lt;peer-ip&gt; dont-capability-negotiate</code> </pre><br>  Ada fitur Cisco yang tidak berdokumen - pengatur waktu 30 detik, yang dipicu oleh perubahan kebijakan <i><font color="#008080">BGP</font></i> .  Setelah mengubah kebijakan, dalam 30 detik proses memperbarui rute menggunakan salah satu teknologi di atas akan dimulai.  Saya tidak dapat menemukan deskripsi yang terdokumentasi tentang timer ini, tetapi ada disebutkan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BUG CSCvi91270</a> .  Anda dapat mempelajari ketersediaannya dalam praktik, <img src="https://habrastorage.org/webt/mk/tm/7s/mktm7sjydraauxoeajhyzkm9lyc.png" align="right" width="400">  setelah melakukan perubahan di lab dan mencari <i><font color="#008080">debug</font></i> untuk permintaan <i><font color="#008080">UPDATE</font></i> ke tetangga atau <i><font color="#008080">proses konfigurasi ulang lunak</font></i> .  (Jika ada informasi tambahan tentang topik - Anda dapat meninggalkan komentar) <br><br>  Untuk <b>Soft-Reconfiguration</b> , timer berfungsi seperti ini: <br><br><pre> <code class="plaintext hljs">2901-NOC-4.2(config)#no ip prefix-list pl-test seq 10 permit 10.5.5.0/26 2901-NOC-4.2(config)#do sh clock 16:53:31.117 Tue Sep 24 2019 Sep 24 16:53:59.396: BGP(0): start inbound soft reconfiguration for Sep 24 16:53:59.396: BGP(0): process 10.5.5.0/26, next hop 10.0.0.1, metric 0 from 10.0.0.1 Sep 24 16:53:59.396: BGP(0): Prefix 10.5.5.0/26 rejected by inbound route-map. Sep 24 16:53:59.396: BGP(0): update denied, previous used path deleted Sep 24 16:53:59.396: BGP(0): no valid path for 10.5.5.0/26 Sep 24 16:53:59.396: BGP(0): complete inbound soft reconfiguration, ran for 0ms Sep 24 16:53:59.396: BGP: topo global:IPv4 Unicast:base Remove_fwdroute for 10.5.5.0/26 2901-NOC-4.2(config)#</code> </pre><br>  Untuk <b>Route-Refresh</b> dari sisi tetangga seperti ini: <br><br><pre> <code class="plaintext hljs">2801-RTR (config-router)# *Sep 24 20:57:29.847 MSK: BGP: 10.0.0.2 rcv REFRESH_REQ for afi/sfai: 1/1 *Sep 24 20:57:29.847 MSK: BGP: 10.0.0.2 start outbound soft reconfig for afi/safi: 1/1</code> </pre><br>  Jika <i><font color="#008080">Route-Refresh</font></i> tidak didukung oleh salah satu rekan dan <i><font color="#008080">konfigurasi ulang inbound</font></i> tidak diaktifkan, maka memperbarui rute dengan kebijakan baru tidak akan secara otomatis terjadi. <br><br>  Jadi, <i><font color="#008080">daftar awalan</font></i> dihapus, koneksi tetap, setelah 30 detik menghilang.  Script berhasil mengubah konfigurasi, memeriksa koneksi, dan menyimpan konfigurasi.  Jatuhnya naskah tidak langsung terhubung, dengan latar belakang sejumlah besar objek. <br><br>  Semua ini dapat dengan mudah dihindari dengan pengujian, replikasi parsial pengaturan.Ada pemahaman bahwa otomatisasi harus dipusatkan dan dikendalikan. <br><br><img src="https://habrastorage.org/webt/du/ew/zc/duewzcojsasaegoufuir8jymcz0.jpeg"><br></div></div><br><h2>  Sistem yang kami butuhkan dan koneksi mereka </h2><br>  Kesimpulan singkat dari spoiler - lebih baik untuk mensistematisasikan dan mengontrol proses pengiriman massal konfigurasi agar tidak sampai pada pengiriman massal kesalahan dalam konfigurasi. <br><br><pre> <code class="plaintext hljs">- DevOps:    50ms     4    -     : ", !@#$%"</code> </pre><br>  Skema yang kami datangi terdiri dari blok data master "bisnis", blok data master "jaringan", sistem pemantauan infrastruktur jaringan, sistem pengiriman konfigurasi, sistem kontrol versi dengan unit pengujian. <br><br><img src="https://habrastorage.org/webt/ft/sc/wl/ftscwlfa_zs4afvfwkeybwo7et0.jpeg"><br><br><h3>  Yang kita butuhkan hanyalah Data </h3><br>  Pertama kita perlu tahu benda apa yang ada di perusahaan. <br><br>  <b>SAP</b> - sistem perusahaan <abbr title="Perencanaan Sumber Daya Enteprise">ERP</abbr> .  Data tentang hampir semua fasilitas ada di sana, dan lebih tepatnya di semua toko dan pusat distribusi.  Serta ada data tentang peralatan yang melewati gudang TI dengan nomor inventaris, yang juga akan berguna bagi kita di masa depan.  Hanya kantor yang hilang, mereka tidak memulai dalam sistem.  Kami mencoba menyelesaikan masalah ini dalam proses terpisah, mulai dari saat pembukaan, kami memerlukan koneksi pada setiap objek, dan kami memilih pengaturan untuk komunikasi, jadi di suatu tempat pada saat ini kami perlu membuat data master.  Tetapi kekurangan data adalah topik yang terpisah, lebih baik untuk menempatkan deskripsi ini di artikel terpisah jika ada minat dalam hal ini. <br><br>  <b><abbr title="Manajer Layanan HP">HPSM</abbr></b> - sistem yang berisi <abbr title="Konfigurasi DataBase Manajemen">CMDB</abbr> umum untuk TI, manajemen kejadian, manajemen perubahan.  Karena sistem ini umum untuk semua TI, ia harus memiliki semua peralatan TI, termasuk peralatan jaringan.  Ini adalah tempat di mana kami akan menambahkan semua data akhir melalui jaringan.  Dengan manajemen insiden dan perubahan, kami berencana untuk berinteraksi dari sistem pemantauan di masa depan. <br><br>  Kami tahu benda apa yang kami miliki, memperkaya mereka dengan data melalui jaringan.  Untuk tujuan ini, kami memiliki dua sistem - <abbr title="Manajemen Alamat IP">IPAM</abbr> dari <i>SolarWinds</i> dan sistem CMDB.noc kami sendiri. <br><br>  <b>IPAM</b> adalah repositori dari subnet IP, data yang paling benar dan benar tentang kepemilikan alamat IP di perusahaan harus ada di sini. <br><br>  <b>CMDB.noc</b> adalah database dengan antarmuka WEB tempat data statis pada peralatan jaringan disimpan - router, switch, titik akses, serta penyedia dan karakteristiknya.  Di bawah statis berarti bahwa perubahan mereka dilakukan hanya dengan partisipasi manusia.  Dengan kata lain, autodiscovering tidak membuat perubahan pada database ini, kita perlu memahami apa yang "harus" diinstal pada objek.  Basisnya diperlukan sebagai penyangga antara sistem produktif yang bekerja dengan seluruh perusahaan dan alat jaringan internal.  Mempercepat pengembangan, menambahkan bidang yang diperlukan, hubungan baru, menyesuaikan parameter, dll.  Plus, solusi ini tidak hanya dalam kecepatan pengembangan, tetapi juga di hadapan hubungan-hubungan antara data yang kita butuhkan, tanpa kompromi.  Sebagai contoh kecil, kami menggunakan beberapa <abbr title="ID eksternal">exid</abbr> dalam database untuk komunikasi antara IPAM, SAP dan HPSM. <br><br>  Sebagai hasilnya, kami menerima data lengkap tentang semua objek, dengan peralatan jaringan yang terlampir dan alamat IP.  Sekarang kita memerlukan templat konfigurasi, atau layanan jaringan yang kami sediakan di situs-situs ini. <br><br><img src="https://habrastorage.org/webt/uy/qp/7f/uyqp7fxlkyf4rluokbotmtg5wvy.jpeg"><br><br><h3>  Sumber kebenaran tunggal </h3><br>  Di sini, kami baru saja mencapai penerapan prinsip NaaC pertama - menyimpan konfigurasi target dalam repositori.  Dalam kasus kami, ini adalah Gitlab.  Pilihan bagi kami sederhana: <br><br><ul><li>  Pertama, kami sudah memiliki alat ini di perusahaan kami, kami tidak perlu menggunakannya dari awal </li><li>  Kedua, sangat cocok untuk semua tugas kita saat ini dan masa depan pada infrastruktur jaringan </li></ul><br>  Bagian utama yang menarik dari otomatisasi akan terjadi di Gitlab - proses mengubah standar konfigurasi atau, lebih sederhana, template. <br><br><h5>  Contoh Proses Perubahan Standar </h5>  Salah satu jenis objek yang kita miliki adalah toko Pyaterochka.  Di sana, topologi tipikal terdiri dari satu router dan satu / dua sakelar.  File konfigurasi template disimpan di Gitlab, di bagian ini semuanya sederhana.  Tapi ini bukan NaaC. <br><br>  Sekarang katakanlah proyek baru datang kepada kita.  Tugas untuk proyek TI baru adalah membuat pilot di sejumlah toko tertentu.  Menurut hasil uji coba - jika berhasil, buat replikasi untuk semua objek jenis ini;  jika tidak runtuh pilot tanpa melakukan replikasi. <br><br>  Proses ini sangat cocok dengan logika Git: <br><br><ol><li>  Untuk proyek baru, kami membuat Cabang, tempat kami membuat perubahan pada konfigurasi. </li><li>  Di Cabang kami juga menyimpan daftar objek di mana proyek ini sedang diujicobakan </li><li>  Jika berhasil, kami membuat permintaan gabungan di cabang master, yang perlu direplikasi ke jaringan prod </li><li>  Jika gagal, tinggalkan Cabang untuk riwayat, atau cukup hapus </li></ol><br><img src="https://habrastorage.org/webt/lx/o1/hu/lxo1hulupq0mzqe37qcodnutxno.png" align="right" width="240"><br>  Dalam perkiraan pertama - bahkan tanpa otomatisasi, ini adalah alat yang sangat nyaman untuk bekerja bersama dalam konfigurasi jaringan.  Terutama jika Anda membayangkan bahwa tiga proyek atau lebih muncul bersamaan.  Ketika tiba saatnya untuk rilis proyek di prod, Anda harus menyelesaikan semua konflik konfigurasi dalam permintaan gabungan dan memeriksa bahwa perubahan pengaturan tidak saling eksklusif.  Dan ini sangat mudah dilakukan di git. <br><br>  Plus, pendekatan ini menambahkan kita fleksibilitas untuk menggunakan alat Gitlab CI / CD untuk menguji konfigurasi secara virtual, untuk mengotomatiskan pengiriman konfigurasi ke bangku tes atau sekelompok objek pilot.  // Dan bahkan jika kau mau. <br><br><h3>  Menyebarkan konfigurasi ke lingkungan apa pun </h3><br>  Awalnya, tujuan utamanya adalah pengiriman konfigurasi secara massal, sebagai alat yang sangat jelas memungkinkan Anda menghemat waktu para insinyur dan mempercepat pelaksanaan tugas-tugas konfigurasi.  Untuk melakukan ini, bahkan sebelum dimulainya kegiatan besar "Jaringan sebagai Kode", kami menulis solusi <i>python</i> untuk menghubungkan ke peralatan baik untuk mengumpulkan konfigurasi peralatan atau mengkonfigurasinya.  Ini <i>netmiko</i> , ini <i>pysnmp</i> , ini <i>jinja2</i> , dll. <br><br>  Tapi sekarang saatnya bagi kita untuk membagi konfigurasi massal menjadi beberapa subspesies: <br><br><ol><li><div class="spoiler">  <b class="spoiler_title">Pengiriman konfigurasi untuk menguji dan menguji coba zona</b> <div class="spoiler_text">  Item ini didasarkan pada Gitlab CI, yang memungkinkan Anda mengaktifkan pengiriman konfigurasi ke pilot dan zona uji di dalam pipa. <br></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Duplikasi konfigurasi di prod</b> <div class="spoiler_text"><ul><li>  Item terpisah, paling sering replikasi ke perangkat 38k berlangsung dalam beberapa gelombang - meningkatkan volume - untuk memantau situasi di prod.  Plus, pekerjaan sebesar ini membutuhkan koordinasi pekerjaan, oleh karena itu lebih baik memulai proses ini dengan tangan.  Untuk ini, lebih mudah menggunakan Ansible + -AWX dan mempercepat kompilasi dinamis inventaris dari sistem data master kami ke sana. </li><li>  Sebagai tambahan, ini adalah solusi yang mudah ketika Anda perlu memberi baris kedua peluncuran playbook yang telah dikonfigurasi sebelumnya yang melakukan operasi yang kompleks dan penting, seperti mengalihkan lalu lintas antar situs. </li></ul></div></div></li><li><div class="spoiler">  <b class="spoiler_title">Pengumpulan data</b> <div class="spoiler_text"><ul><li>  Autodiscover perangkat jaringan </li><li>  Konfigurasi cadangan </li><li>  Periksa konektivitas </li></ul><br>  Kami mengalokasikan tugas ini di blok yang terpisah, karena ada kalanya seseorang tiba-tiba membongkar sakelar atau memasang perangkat baru, tetapi kami tidak mengetahui hal ini sebelumnya.  Dengan demikian, perangkat ini tidak akan berada dalam data master kami dan akan keluar dari proses pengiriman konfigurasi, pemantauan, dan, secara umum, pekerjaan operasional.  Kebetulan bahwa peralatan itu diinstal secara sah, tetapi konfigurasi "dituangkan" salah di sana dan, untuk beberapa alasan, <i>ssh</i> , <i>snmp</i> , <i>aaa</i> atau kata sandi non-standar untuk akses tidak berfungsi di sana.  Untuk melakukan ini, kita memiliki python untuk mencoba semua metode koneksi <i>warisan yang</i> mungkin kita miliki di perusahaan, membuat brute-force untuk semua kata sandi lama, dan semua untuk mendapatkan potongan besi dan mempersiapkannya untuk bekerja dengan <i>memungkinkan</i> dan memantau . <br><br>  Ada cara sederhana - untuk membuat beberapa file <i>inventaris</i> untuk memungkinkan, di mana untuk menggambarkan semua data yang mungkin untuk koneksi (semua jenis vendor dengan semua pasangan nama pengguna / kata sandi yang mungkin) dan menjalankan <i>buku pedoman</i> untuk setiap varian <i>inventaris</i> .  Kami berharap untuk solusi yang lebih baik, tetapi pada konferensi RedHat, arsitek Ansible menyarankan dengan cara yang sama.  Secara umum diasumsikan bahwa Anda tahu sebelumnya apa yang Anda hubungkan. <br>  Kami menginginkan solusi universal - ketika menghapus cadangan, cari peralatan baru dan, jika ditemukan, tambahkan ke semua sistem yang diperlukan.  Oleh karena itu, kami memilih solusi dengan python - tahu apa yang bisa lebih indah daripada program yang dengan sendirinya dapat mendeteksi perangkat jaringan untuk menghubungkannya, terlepas dari apa yang dikonfigurasi di dalamnya (tentu saja, dalam batas yang wajar), konfigurasikan sesuai kebutuhan, hapus konfigurasi dan, pada saat yang sama, Tambahkan data API ke sistem yang diperlukan. <br></div></div></li></ol><br><h3>  Verifikasi seperti Pemantauan </h3><br>  Salah satu tugas otomatisasi, tentu saja, untuk mengetahui apa yang jatuh dari otomatisasi ini.  Tidak semua 38k dikonfigurasikan dengan sempurna pertama kali, bahkan ada yang mengatur peralatan dengan tangan mereka.  Dan perlu untuk melacak perubahan ini dan mengembalikan <s>keadilan ke</s> konfigurasi target. <br><br>  Ada tiga pendekatan untuk memverifikasi kepatuhan konfigurasi dengan standar: <br><br><ul><li>  Lakukan pemeriksaan sekali periode - bongkar keadaan saat ini, periksa terhadap target dan koreksi kekurangan yang diidentifikasi. </li><li>  Tanpa memeriksa apa pun, satu kali periode - roll out konfigurasi target.  Benar, ada risiko melanggar sesuatu - mungkin tidak ada semuanya dalam konfigurasi target. </li><li>  Pendekatan yang mudah digunakan adalah ketika perbedaan dari konfigurasi target di <i>Single Source of Truth</i> dianggap sebagai peringatan dan dipantau oleh sistem pemantauan.  Ini termasuk: ketidakcocokan dengan standar konfigurasi saat ini, perbedaan antara perangkat keras dan yang ditentukan dalam data master, ketidakcocokan dengan data dalam <i>IPAM</i> . </li></ul><br>  Dalam kasus ketiga, sebuah opsi muncul untuk mentransfer karya ini ke manajemen insiden (OS), sehingga ketidakkonsistenan dihilangkan dalam porsi kecil sepanjang waktu daripada sekali oleh darurat. <br><br>  <b>Zabbix</b> , yang saya tulis sebelumnya dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Bagaimana kami memonitor 14.000 objek",</a> adalah sistem pemantauan objek terdistribusi kami di mana kami dapat membuat pemicu dan peringatan yang dapat kami pikirkan.  Sejak menulis artikel terakhir, kami telah meningkatkan ke Zabbix 4.0 <abbr title="Dukungan jangka panjang">LTS</abbr> . <br><br>  Berdasarkan <i>Web Zabbix,</i> kami membuat pembaruan ke portal dukungan jaringan kami, di mana sekarang Anda dapat menemukan semua informasi tentang suatu objek dari semua sistem kami pada satu layar, serta menjalankan skrip untuk memeriksa masalah yang sering terjadi. <br><br><img src="https://habrastorage.org/webt/o_/65/ha/o_65haiskiyx5jvmofs1wwmy9a8.png"><br><br>  Kami juga memperkenalkan fitur baru - bagi kami, Zabbix telah menjadi, dalam beberapa cara, <i>CRON</i> untuk meluncurkan skrip terjadwal, seperti skrip integrasi sistem, skrip autodiscover.  Ini sangat nyaman ketika Anda perlu melihat skrip saat ini dan kapan dan di mana mereka berjalan tanpa memeriksa semua server.  Benar, untuk skrip yang berjalan lebih dari 30 detik, Anda akan memerlukan <i>peluncur</i> yang meluncurkannya tanpa menunggu akhir.  Untungnya, ini sederhana: <br><br><div class="spoiler">  <b class="spoiler_title">launcher.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash nohup $* &gt; /dev/null 2&gt;/dev/null &amp; echo $(date) Started job for $*</span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/gu/vp/ww/guvpwwbg0scnt8ngqkhuy7keey8.png"><br><br>  <b>Splunk</b> adalah solusi yang memungkinkan Anda untuk mengumpulkan log peristiwa dari peralatan jaringan, dan ini juga dapat digunakan untuk memantau otomatisasi.  Misalnya, mengumpulkan cadangan konfigurasi, skrip <i>python</i> menghasilkan pesan <i>LOG</i> <i>CFG-5-BACKUP</i> , router atau switch mengirim pesan ke Splunk, di mana kami menghitung jumlah pesan jenis ini dari peralatan jaringan.  Ini memungkinkan kami untuk melacak jumlah peralatan yang terdeteksi oleh skrip.  Dan kami melihat berapa banyak potongan besi yang dapat melaporkan ini ke <i>Splunk</i> dan memverifikasi bahwa pesan dari semua potongan besi tiba. <br>  <b>Spectrum</b> adalah sistem komprehensif yang kami gunakan untuk memantau objek kritis, alat yang agak kuat yang banyak membantu kami dalam memecahkan insiden jaringan kritis.  Dalam otomatisasi, kami hanya menggunakannya untuk mengambil data darinya, itu bukan <i>open-source</i> , jadi kemungkinannya agak terbatas. <br><br><h3>  Ceri di atas kue </h3><br><img src="https://habrastorage.org/webt/-a/g_/qk/-ag_qktnw97gq5edbpbswa1h_xa.png" align="right" width="240">  Menggunakan sistem dengan data master pada peralatan, kita dapat berpikir tentang membuat ZTP, atau Zero Touch Provisioning.  Seperti tombol "setel otomatis", tetapi hanya tanpa tombol. <br><br>  Kami memiliki semua data yang diperlukan dari blok sebelumnya - kami tahu objek, jenisnya, peralatan apa yang ada (vendor dan model), apa alamatnya (IPAM), apa standar konfigurasi saat ini (Git).  Dengan menyatukan semuanya, kita setidaknya bisa menyiapkan templat konfigurasi untuk mengunggah ke perangkat, itu akan lebih seperti Penyediaan One Touch, tetapi terkadang lebih banyak tidak diperlukan. <br><br>  True Zero Touch memerlukan cara untuk secara otomatis mengirimkan konfigurasi ke perangkat keras yang tidak dikonfigurasi.  Selain itu, diinginkan terlepas dari vendor.  Ada beberapa opsi kerja - server konsol, jika semua peralatan melewati gudang pusat, solusi konsol seluler, jika peralatan tiba segera.  Kami sedang mengerjakan solusi ini, tetapi begitu ada opsi yang berfungsi, kami dapat membagikannya. <br><br><h3>  Kesimpulan </h3><br>  Secara total, dalam konsep <b>Jaringan kami sebagai Kode</b> , ada 5 tonggak utama: <br><br><ul><li>  Data master (komunikasi sistem dan data satu sama lain, API sistem, kecukupan data untuk dukungan dan peluncuran) </li><li>  Memantau data dan konfigurasi (menemukan perangkat jaringan secara otomatis, memeriksa relevansi konfigurasi di fasilitas) </li><li>  Konfigurasi versi, pengujian dan konfigurasi uji coba (Gitlab CI / CD sebagaimana diterapkan pada jaringan, alat pengujian konfigurasi jaringan) </li><li>  Pengiriman konfigurasi (Anonim, AWX, skrip python untuk disambungkan) </li><li>  Zero Touch Provisioning (Data apa yang dibutuhkan, bagaimana membangun proses sehingga, bagaimana menghubungkan ke perangkat keras yang tidak dikonfigurasi) </li></ul><br>  Itu tidak berhasil memasukkan semuanya ke dalam satu artikel, setiap item layak untuk diskusi terpisah, kita bisa membicarakan sesuatu sekarang, tentang sesuatu ketika kita memeriksa solusi dalam praktek.  Jika Anda tertarik pada salah satu topik - pada akhirnya akan ada survei di mana Anda dapat memilih artikel berikutnya.  Jika topik tidak termasuk dalam daftar, tetapi menarik untuk membacanya, tinggalkan komentar sesegera mungkin, pastikan untuk berbagi pengalaman kami. <br><br><hr><br>  Terima kasih khusus kepada Virilin Alexander ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">xscrew</a> ) dan Sibgatulin Marat ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">eucariot</a> ) untuk kunjungan referensi pada musim gugur tahun 2018 ke cloud Yandex dan kisah tentang otomatisasi dalam infrastruktur jaringan cloud.  Setelahnya, kami mendapat inspirasi dan banyak ide tentang penggunaan otomatisasi dan NetDevOps dalam infrastruktur Grup Ritel X5. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id468197/">https://habr.com/ru/post/id468197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id468185/index.html">Layanan AWS EC2 dan bekerja dengannya</a></li>
<li><a href="../id468189/index.html">Tingkatkan keterampilan debugging JavaScript menggunakan trik konsol</a></li>
<li><a href="../id468191/index.html">RubyRussia 2019: Nikolay Sverchkov tentang serverless</a></li>
<li><a href="../id468193/index.html">JVM Internal, Bagian 1 - Loader Kelas</a></li>
<li><a href="../id468195/index.html">Mengapa keuangan saya bergantung pada Beeline?</a></li>
<li><a href="../id468203/index.html">Teka-teki dalam pencarian kesempatan sempurna</a></li>
<li><a href="../id468205/index.html">GIT dari dalam: pengantar (terjemahan)</a></li>
<li><a href="../id468207/index.html">Bagaimana kami memperbarui Zabbix</a></li>
<li><a href="../id468211/index.html">â€œSaya hanya ingin membuat lelucon, tetapi tidak ada yang mengertiâ€ atau bagaimana tidak mengubur diri saya pada presentasi proyek</a></li>
<li><a href="../id468213/index.html">tinc-boot - jaringan full-mesh tanpa rasa sakit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>