<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêé üôÜüèæ ‚úäüèª Angular sem zone.js: desempenho m√°ximo üíê ü¶á üò±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Desenvolvedores angulares devem muito ao zone.js. Ela, por exemplo, ajuda a obter uma facilidade quase m√°gica ao trabalhar com a Angular. De fato, qua...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Angular sem zone.js: desempenho m√°ximo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476956/">  Desenvolvedores angulares devem muito ao zone.js.  Ela, por exemplo, ajuda a obter uma facilidade quase m√°gica ao trabalhar com a Angular.  De fato, quase sempre, quando voc√™ s√≥ precisa alterar alguma propriedade, e n√≥s a alteramos sem pensar em nada, o Angular renderiza novamente os componentes correspondentes.  Como resultado, o que o usu√°rio v√™ sempre cont√©m as informa√ß√µes mais recentes.  Isso √© √≥timo. <br><br>  Aqui eu gostaria de explorar alguns aspectos de como o uso do novo compilador Ivy (que apareceu no Angular 9) pode facilitar muito a rejei√ß√£o do uso do zone.js. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/476956/"><img src="https://habrastorage.org/webt/9m/ql/xa/9mqlxapag9joinziuleg8frnslm.jpeg"></a> <br><br>  Ao abandonar esta biblioteca, pude aumentar significativamente o desempenho do aplicativo Angular em execu√ß√£o sob carga pesada.  Ao mesmo tempo, consegui implementar os mecanismos necess√°rios usando decoradores TypeScript, o que levou a muito poucos recursos adicionais do sistema. <br><br>  Observe que a abordagem para otimizar aplicativos Angular, apresentada neste artigo, √© poss√≠vel apenas porque Angular Ivy e AOT est√£o ativados por padr√£o.  Este artigo foi escrito para fins educacionais, n√£o tem como objetivo promover a abordagem apresentada ao desenvolvimento de projetos Angular. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Por que voc√™ pode precisar usar o Angular sem zone.js?</font> </h2><br>  Antes de continuarmos, vamos fazer uma pergunta importante: ‚ÄúVale a pena se livrar do zone.js, j√° que essa biblioteca nos ajuda a renderizar novamente os modelos sem muito esfor√ßo?‚Äù  Obviamente, esta biblioteca √© muito √∫til.  Mas, como sempre, voc√™ tem que pagar por tudo. <br><br>  Se seu aplicativo tiver requisitos de desempenho espec√≠ficos, desativar o zone.js pode ajudar a atender a esses requisitos.  Um exemplo de aplica√ß√£o em que o desempenho √© crucial √© um projeto cuja interface √© atualizada com muita frequ√™ncia.  No meu caso, esse projeto acabou sendo um aplicativo de negocia√ß√£o em tempo real.  Sua parte do cliente recebe constantemente mensagens via protocolo WebSocket.  Os dados dessas mensagens devem ser exibidos o mais r√°pido poss√≠vel. <br><br><h2>  <font color="#3AC1EF">Remova o zone.js do Angular</font> </h2><br>  O Angular pode ser facilmente executado sem o zone.js.  Para fazer isso, voc√™ deve primeiro comentar ou excluir o comando de importa√ß√£o correspondente, localizado no arquivo <code>polyfills.ts</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f95/17e/7a4f9517eb4898e51240862c08e4faa9.png"></div><br>  <i><font color="#999999">Comando de importa√ß√£o zone.js comentado</font></i> <br><br>  Em seguida - voc√™ precisa equipar o m√≥dulo raiz com as seguintes op√ß√µes: <br><br><pre> <code class="javascript hljs">platformBrowserDynamic()  .bootstrapModule(AppModule, {    <span class="hljs-attr"><span class="hljs-attr">ngZone</span></span>: <span class="hljs-string"><span class="hljs-string">'noop'</span></span>  })  .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br><h2>  <font color="#3AC1EF">Hera angular: Detectando altera√ß√µes com …µdetectChanges e …µmarkDirty</font> </h2><br>  Antes de come√ßarmos a criar um decorador TypeScript, precisamos aprender sobre como o Ivy permite que voc√™ invoque o processo de detectar altera√ß√µes de componentes, torn√°-las sujas e ignorar zone.js e DI. <br><br>  Duas fun√ß√µes adicionais est√£o agora dispon√≠veis para n√≥s, exportadas de <code>@angular/core</code> .  Esses s√£o <code>…µdetectChanges</code> e <code>…µmarkDirty</code> .  Essas duas fun√ß√µes ainda se destinam ao uso interno e s√£o inst√°veis ‚Äã‚Äã- o s√≠mbolo <code>…µ</code> est√° localizado no in√≠cio de seus nomes. <br><br>  Vamos ver como usar esses recursos. <br><br><h3>  <font color="#3AC1EF">Fun√ß√£o MarkDirty</font> </h3><br>  Esse recurso permite rotular um componente, deixando-o "sujo", ou seja, com necessidade de nova renderiza√ß√£o.  Ela, se o componente n√£o foi marcado como "sujo" antes de ser chamado, planeja iniciar o processo de detec√ß√£o de altera√ß√µes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µmarkDirty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> markDirty } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    markDirty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h3>  <font color="#3AC1EF">Fun√ß√£o DetectChanges</font> </h3><br>  A documenta√ß√£o interna angular diz que, por raz√µes de desempenho, voc√™ n√£o deve usar <code>…µdetectChanges</code> .  Em vez disso, √© recomend√°vel usar a fun√ß√£o <code>…µmarkDirty</code> .  A fun√ß√£o <code>…µdetectChanges</code> invoca de forma s√≠ncrona o processo de detec√ß√£o de altera√ß√µes em um componente e seus subcomponentes. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { …µdetectChanges <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> detectChanges } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    detectChanges(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h2>  <font color="#3AC1EF">Detectar automaticamente altera√ß√µes usando o decorador TypeScript</font> </h2><br>  Embora as fun√ß√µes fornecidas pela Angular aumentem a usabilidade do desenvolvimento, deixando o DI funcionar, o programador ainda pode ficar frustrado pelo fato de precisar importar e chamar essas fun√ß√µes por conta pr√≥pria para iniciar o processo de detec√ß√£o de altera√ß√µes. <br><br>  Para simplificar o in√≠cio autom√°tico da detec√ß√£o de altera√ß√µes, voc√™ pode escrever um decorador TypeScript, que resolver√° esse problema independentemente.  Obviamente, existem algumas limita√ß√µes aqui, as quais discutiremos abaixo, mas no meu caso, essa abordagem acabou sendo exatamente o que eu precisava. <br><br><h3>  <font color="#3AC1EF">‚ñçIntrodu√ß√£o do decorador @observed</font> </h3><br>  Para detectar mudan√ßas, fazendo o m√≠nimo de esfor√ßo poss√≠vel, criaremos um decorador que pode ser aplicado de tr√™s maneiras.  Ou seja, √© aplic√°vel √†s seguintes entidades: <br><br><ul><li>  Para m√©todos s√≠ncronos. </li><li>  Objetos observ√°veis. </li><li>  Para objetos comuns. </li></ul><br>  Considere alguns exemplos pequenos.  No fragmento de c√≥digo a seguir, aplicamos o decorador <code>@observed</code> ao objeto <code>state</code> e ao m√©todo <code>changeTitle</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">''</span></span>;    @observed() state = {        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>    };    @observed()    changeTitle(title: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    }    changeName(name: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name = name;    } }</code> </pre> <br><ul><li>  Para verificar se h√° altera√ß√µes no objeto de <code>state</code> , usamos um objeto proxy que intercepta as altera√ß√µes no objeto e chama o procedimento para detectar altera√ß√µes. </li><li>  Substitu√≠mos o m√©todo <code>changeTitle</code> aplicando uma fun√ß√£o que primeiro chama esse m√©todo e, em seguida, inicia o processo de detec√ß√£o de altera√ß√µes. </li></ul><br>  E aqui est√° um exemplo com <code>BehaviorSubject</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{    @observed() show$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);    toggle() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.next(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.value);    } }</code> </pre> <br>  No caso de objetos observ√°veis, usar um decorador parece um pouco mais complicado.  Ou seja, voc√™ precisa assinar o objeto observado e marcar o componente como "sujo" na assinatura, mas tamb√©m precisa limpar a assinatura.  Para fazer isso, reatribu√≠mos o <code>ngOnInit</code> e o <code>ngOnDestroy</code> para assinar e limp√°-lo mais tarde. <br><br><h3>  <font color="#3AC1EF">‚ñçCriar um decorador</font> </h3><br>  Aqui est√° a assinatura do decorador <code>observed</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  </span></span></span><span class="hljs-function">) </span></span>{} }</code> </pre> <br>  Como voc√™ pode ver, o <code>descriptor</code> √© um par√¢metro opcional.  Isso ocorre porque precisamos que o decorador seja aplicado a m√©todos e propriedades.  Se o par√¢metro existir, isso significa que o decorador √© aplicado ao m√©todo.  Nesse caso, fazemos o seguinte: <br><br><ul><li>  Salve a propriedade do <code>descriptor.</code>  <code>value</code> . </li><li>  Redefinimos o m√©todo da seguinte maneira: chame a fun√ß√£o original e chame <code>markDirty(this)</code> para iniciar o processo de detec√ß√£o de altera√ß√µes.  Aqui est√° o que parece: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor) {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-comment"><span class="hljs-comment">//     descriptor.value = function(...args: any[]) {    original.apply(this, args); //       markDirty(this);  }; } else {  //   }</span></span></code> </pre> </li></ul><br>  Em seguida, voc√™ precisa verificar com que tipo de propriedade estamos lidando.  Pode ser um objeto observ√°vel ou um objeto comum.  Aqui vamos usar outra API Angular interna.  Acredito que ele n√£o se destina ao uso em aplicativos regulares (desculpe!). <br><br>  Estamos falando da propriedade <code>…µcmp</code> , que d√° acesso √†s propriedades processadas pelo Angular ap√≥s serem definidas.  Podemos us√°-los para substituir os m√©todos dos <code>onDestroy</code> e <code>onDestroy</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCmp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> (type).…µcmp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp = getCmp(target.constructor); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onInit = cmp.onInit || noop; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onDestroy = cmp.onDestroy || noop;</code> </pre> <br>  Para marcar uma propriedade como uma a ser monitorada, usamos <code>ReflectMetadata</code> e configuramos seu valor como <code>true</code> .  Como resultado, saberemos que precisamos observar a propriedade quando o componente for inicializado: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, propertyKey, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Agora √© hora de substituir o gancho <code>onInit</code> e verificar as propriedades ao criar a inst√¢ncia do componente: <br><br><pre> <code class="javascript hljs">cmp.onInit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  checkComponentProperties(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  onInit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre> <br>  Definimos a fun√ß√£o <code>checkComponentProperties</code> , que <code>checkComponentProperties</code> as propriedades do componente, filtrando-as de acordo com o valor definido anteriormente usando <code>Reflect.set</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkComponentProperties = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> props = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(ctx);  props.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, prop);  }).filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    checkProperty.call(ctx, propertyKey);  }); };</code> </pre> <br>  A fun√ß√£o <code>checkProperty</code> ser√° respons√°vel por decorar propriedades individuais.  Primeiro, verificamos se a propriedade √© um objeto observ√°vel ou regular.  Se este √© um objeto Observ√°vel, n√≥s o assinamos e adicionamos a assinatura √† lista de assinaturas armazenadas no componente para suas necessidades internas. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkProperty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name: string</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[name] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Observable) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriptions = getSubscriptions(ctx);    subscriptions.add(ctx[name].subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {      markDirty(ctx);    }));  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    } };</span></span></code> </pre> <br>  Se a propriedade for um objeto comum, ent√£o a converteremos em um objeto Proxy e chamaremos <code>markDirty</code> em sua fun√ß√£o de <code>handler</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {  set(obj, prop, value) {    obj[prop] = value;    …µmarkDirty(ctx);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  } }; ctx[name] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(ctx, handler);</code> </pre> <br>  Por fim, voc√™ precisa limpar a assinatura depois de destruir o componente: <br><br><pre> <code class="javascript hljs">cmp.onDestroy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[subscriptionsSymbol]) {    ctx[subscriptionsSymbol].unsubscribe();  }  onDestroy.call(ctx); };</code> </pre> <br>  As possibilidades deste decorador n√£o podem ser consideradas abrangentes.  Eles n√£o cobrem todos os usos poss√≠veis que podem aparecer em um aplicativo grande.  Por exemplo, s√£o chamadas para fun√ß√µes de modelo que retornam objetos Observ√°veis.  Mas estou trabalhando nisso. <br><br>  Apesar disso, o decorador acima √© suficiente para o meu pequeno projeto.  Voc√™ encontrar√° o c√≥digo completo no final do material. <br><br><h2>  <font color="#3AC1EF">An√°lise dos resultados da acelera√ß√£o de aplicativos</font> </h2><br>  Agora que conversamos um pouco sobre os mecanismos internos de Ivy e como criar um decorador usando esses mecanismos, √© hora de testar o que temos em um aplicativo real. <br><br>  Para descobrir o efeito de se livrar do zone.js no desempenho de aplicativos Angular, usei meu projeto de hobby do <a href="https://github.com/gbuomprisco/cryptofolio">Cryptofolio</a> . <br><br>  Apliquei o decorador em todos os links necess√°rios usados ‚Äã‚Äãnos modelos e em zone.js. desativado  Por exemplo, considere o seguinte componente: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetPricerComponent</span></span></span><span class="hljs-class"> </span></span>{  @observed() price$: Observable&lt;string&gt;;  @observed() trend$: Observable&lt;Trend&gt;;   <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Duas vari√°veis ‚Äã‚Äãs√£o usadas no modelo: <code>price</code> (o <code>price</code> do ativo ser√° localizado aqui) e <code>trend</code> (essa vari√°vel pode levar os valores para <code>up</code> , <code>down</code> e <code>down</code> , indicando a dire√ß√£o da mudan√ßa de pre√ßo).  <code>@observed</code> os com <code>@observed</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Tamanho do pacote do projeto</font> </h3><br>  Para come√ßar, vamos dar uma olhada em quanto o tamanho do pacote do projeto diminuiu enquanto se livrava do zone.js.  Abaixo est√° o resultado da cria√ß√£o do projeto com zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/cb3/7e8/a0bcb37e870dfdcafa1c49a80aeaeb04.png"></div><br>  <i><font color="#999999">Resultado da cria√ß√£o de um projeto com zone.js</font></i> <br><br>  E aqui est√° a montagem sem zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/6ae/adc/7d56aeadce675e6953e5e603b3594c2c.png"></div><br>  <i><font color="#999999">O resultado da cria√ß√£o de um projeto sem zone.js</font></i> <br><br>  Preste aten√ß√£o ao <code>polyfills-es2015.xxx.js</code> .  Se o projeto usar zone.js, seu tamanho ser√° de aproximadamente 35 Kb.  Mas sem zone.js - apenas 130 bytes. <br><br><h3>  <font color="#3AC1EF">‚ñçInicializa√ß√£o</font> </h3><br>  Eu pesquisei duas op√ß√µes de aplica√ß√£o usando o Lighthouse.  Os resultados deste estudo s√£o apresentados abaixo.  Note-se que eu n√£o os levaria muito a s√©rio.  O fato √© que, ao tentar encontrar os valores m√©dios, obtive resultados significativamente diferentes executando v√°rias medidas para a mesma vers√£o do aplicativo. <br><br>  Talvez a diferen√ßa na avalia√ß√£o das duas op√ß√µes de aplicativo dependa apenas do tamanho dos pacotes configur√°veis. <br><br>  Ent√£o, aqui est√° o resultado obtido para um aplicativo que usa zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/922/5f3/dfd9225f368de1f7c3e43d47bddbad16.png"></div><br>  <i><font color="#999999">Resultados da an√°lise para um aplicativo que usa zone.js</font></i> <br><br>  E aqui est√° o que aconteceu depois de analisar o aplicativo em que o zone.js n√£o √© usado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/684/9ba/f416849ba2f210d1ed48345e607a3d8f.png"></div><br>  <i><font color="#999999">Resultados da an√°lise para um aplicativo que n√£o usa zone.js</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Desempenho</font> </h3><br>  E agora chegamos ao mais interessante.  Esse √© o desempenho de um aplicativo em execu√ß√£o sob carga.  Queremos saber como o processador se sente quando o aplicativo exibe atualiza√ß√µes de pre√ßos para centenas de ativos v√°rias vezes por segundo. <br><br>  Para carregar o aplicativo, criei 100 entidades que fornecem dados condicionais a pre√ßos que mudam a cada 250 ms.  Se o pre√ßo subir, ele ser√° exibido em verde.  Se reduzido - vermelho.  Tudo isso poderia carregar seriamente o meu MacBook Pro. <br><br>  Deve-se notar que, enquanto trabalhava no setor financeiro em v√°rios aplicativos projetados para a transmiss√£o de alta frequ√™ncia de fragmentos de dados, me deparei com uma situa√ß√£o semelhante muitas vezes. <br><br>  Para analisar como diferentes vers√µes do aplicativo usam os recursos do processador, usei as ferramentas de desenvolvedor do Chrome. <br><br>  Veja como √© o aplicativo que usa o zone.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/11b/56f/fbf11b56ffe060d5bcdc4680a0ddd347.gif"></div><br>  <i><font color="#999999">Carregamento do sistema criado por um aplicativo que usa zone.js</font></i> <br><br>  E aqui est√° como um aplicativo funciona em que zone.js n√£o √© usado. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/657/240/8fb65724082e810619f061cb238c76da.gif"></div><br>  <i><font color="#999999">Carregamento do sistema criado por um aplicativo que n√£o usa zone.js</font></i> <br><br>  Analisamos esses resultados, prestando aten√ß√£o ao gr√°fico de carga do processador (amarelo): <br><br><ul><li>  Como voc√™ pode ver, um aplicativo que usa o zone.js carrega constantemente o processador em 70-100%!  Se voc√™ mantiver a guia do navegador aberta por um longo tempo, criando uma carga no sistema, o aplicativo em execu√ß√£o nela poder√° falhar. </li><li>  E a vers√£o do aplicativo em que o zone.js n√£o √© usado cria uma carga est√°vel no processador na faixa de 30 a 40%.  √ìtimo! </li></ul><br>  Observe que esses resultados foram obtidos com a janela Ferramentas do desenvolvedor do Chrome aberta, o que tamb√©m sobrecarrega o sistema e diminui a velocidade do aplicativo. <br><br><h3>  <font color="#3AC1EF">‚ñç aumento de carga</font> </h3><br>  Tentei garantir que todas as entidades respons√°veis ‚Äã‚Äãpela atualiza√ß√£o do pre√ßo emitissem mais 4 atualiza√ß√µes a cada segundo, al√©m do que j√° produz. <br><br>  Aqui est√° o que conseguimos descobrir sobre o aplicativo em que o zone.js n√£o √© usado: <br><br><ul><li>  Esse aplicativo normalmente lida com a carga, agora usando cerca de 50% dos recursos do processador. </li><li>  Ele conseguiu carregar o processador tanto quanto o aplicativo com zone.js, apenas quando os pre√ßos eram atualizados a cada 10 ms (novos dados, como antes, vinham de 100 entidades). </li></ul><br><h3>  <font color="#3AC1EF">Analysis An√°lise de desempenho com o Angular Benchpress</font> </h3><br>  A an√°lise de desempenho que conduzi acima n√£o pode ser chamada de particularmente cient√≠fica.  Para um estudo mais s√©rio do desempenho de v√°rias estruturas, eu recomendaria o uso <a href="https://krausest.github.io/js-framework-benchmark/current.html">dessa refer√™ncia</a> .  Para pesquisa, o Angular deve escolher a vers√£o usual dessa estrutura e sua vers√£o sem zone.js. <br><br>  Eu, inspirado por algumas id√©ias desse benchmark, criei um <a href="https://github.com/Gbuomprisco/zoneless-angular">projeto</a> que realiza c√°lculos pesados.  Testei seu desempenho com o <a href="https://github.com/angular/angular/tree/master/packages/benchpress">Angular Benchpress</a> . <br><br>  Aqui est√° o c√≥digo do componente testado: <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{  public data = [];  @observed()  run(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  append(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  removeAll() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();  }  @observed()  remove(item) {    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; i &lt; l; i++) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[i].id === item.id) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;      }    }  }  trackById(item) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id;  }  private clear() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [];  }  private buildData(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = start + length;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = start; n &lt;= end; n++) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push({        <span class="hljs-attr"><span class="hljs-attr">id</span></span>: n,        <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()      });    }  } }</code> </pre> <br>  Lancei um pequeno conjunto de benchmarks usando o Transferidor e o Benchpress.  As opera√ß√µes foram executadas um n√∫mero especificado de vezes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/167/a7b/5c2167a7bae21093e5e7cdc9f2482361.gif"></div><br>  <i><font color="#999999">Benchpress em a√ß√£o</font></i> <br><br><h4>  Resultados </h4><br>  Aqui est√° uma amostra dos resultados obtidos usando o Benchpress. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5a/467/0f0/f5a4670f0af5b461a1f0fad2d7f982b3.png"></div><br>  <i><font color="#999999">Resultados de Benchpress</font></i> <br><br>  Aqui est√° uma explica√ß√£o dos indicadores apresentados nesta tabela: <br><br><ul><li>  <code>gcAmount</code> : volume de opera√ß√µes gc (coleta de lixo), Kb. </li><li>  <code>gcTime</code> : tempo de opera√ß√£o do gc, ms. </li><li>  <code>majorGcTime</code> : hora das principais opera√ß√µes gc, ms. </li><li>  <code>pureScriptTime</code> : tempo de execu√ß√£o do script em ms, excluindo opera√ß√µes e renderiza√ß√£o do gc. </li><li>  <code>renderTime</code> : tempo de renderiza√ß√£o, ms. </li><li>  <code>scriptTime</code> : tempo de execu√ß√£o do script, levando em considera√ß√£o as opera√ß√µes e a renderiza√ß√£o do gc. </li></ul><br>  Agora vamos considerar a an√°lise da implementa√ß√£o de algumas opera√ß√µes em v√°rias vers√µes do aplicativo.  Verde mostra os resultados de um aplicativo que usa zone.js, laranja mostra os resultados de um aplicativo sem zone.js.  Observe que apenas o tempo de renderiza√ß√£o √© analisado aqui.  Se voc√™ estiver interessado em todos os resultados dos testes, verifique <a href="https://github.com/Gbuomprisco/zoneless-angular">aqui</a> . <br><br><h4>  Teste: criando 1000 linhas </h4><br>  No primeiro teste, 1000 linhas s√£o criadas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/d48/745/944d48745c79b697bececc092c78c9be.png"></div><br>  <i><font color="#999999">Resultados do teste</font></i> <br><br><h4>  Teste: criando 10.000 linhas </h4><br>  √Ä medida que a carga nos aplicativos aumenta, o mesmo ocorre com a diferen√ßa no desempenho. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/971/8aa/7e19718aadeec04390f1f4b7fa408f89.png"></div><br>  <i><font color="#999999">Resultados do teste</font></i> <br><br><h4>  Teste: junte 1000 linhas </h4><br>  Neste teste, 1000 linhas s√£o anexadas a 10.000 linhas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/682/d30/3f3682d3064b9158ef95146426d2638b.png"></div><br>  <i><font color="#999999">Resultados do teste</font></i> <br><br><h4>  Teste: removendo 10.000 linhas </h4><br>  Aqui, 10.000 linhas s√£o criadas, que s√£o exclu√≠das. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f85/d5d/bb7/f85d5dbb78b094bd9bb9afccbce148e3.png"></div><br>  <i><font color="#999999">Resultados do teste</font></i> <br><br><h2>  <font color="#3AC1EF">C√≥digo-fonte do Decorator TypeScript</font> </h2><br>  Abaixo est√° o c√≥digo-fonte do decorador TypeScript discutido aqui.  Este c√≥digo tamb√©m pode ser encontrado <a href="">aqui</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tslint:disable import { Observable, Subscription } from 'rxjs'; import { Type, …µComponentType as ComponentType, …µmarkDirty as markDirty } from '@angular/core'; interface ComponentDefinition {  onInit(): void;  onDestroy(): void; } const noop = () =&gt; { }; const getCmp = &lt;T&gt;(type: Function) =&gt; (type as any).…µcmp as ComponentDefinition; const subscriptionsSymbol = Symbol('__ng__subscriptions'); export function observed() {  return function(    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  ) {    if (descriptor) {      const original = descriptor.value;      descriptor.value = function(...args: any[]) {        original.apply(this, args);        markDirty(this);      };    } else {      const cmp = getCmp(target.constructor);      if (!cmp) {        throw new Error(`Property …µcmp is undefined`);      }      const onInit = cmp.onInit || noop;      const onDestroy = cmp.onDestroy || noop;      const getSubscriptions = (ctx) =&gt; {        if (ctx[subscriptionsSymbol]) {          return ctx[subscriptionsSymbol];        }        ctx[subscriptionsSymbol] = new Subscription();        return ctx[subscriptionsSymbol];      };      const checkProperty = function(name: string) {        const ctx = this;        if (ctx[name] instanceof Observable) {          const subscriptions = getSubscriptions(ctx);          subscriptions.add(ctx[name].subscribe(() =&gt; markDirty(ctx)));        } else {          const handler = {            set(obj: object, prop: string, value: unknown) {              obj[prop] = value;              markDirty(ctx);              return true;            }          };          ctx[name] = new Proxy(ctx, handler);        }      };      const checkComponentProperties = (ctx) =&gt; {        const props = Object.getOwnPropertyNames(ctx);        props.map((prop) =&gt; {          return Reflect.get(target, prop);        }).filter(Boolean).forEach(() =&gt; {          checkProperty.call(ctx, propertyKey);        });      };      cmp.onInit = function() {        const ctx = this;        onInit.call(ctx);        checkComponentProperties(ctx);      };      cmp.onDestroy = function() {        const ctx = this;        onDestroy.call(ctx);        if (ctx[subscriptionsSymbol]) {          ctx[subscriptionsSymbol].unsubscribe();        }      };      Reflect.set(target, propertyKey, true);    }  }; }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Sum√°rio</font> </h2><br>  Embora eu espere que voc√™ tenha gostado da minha hist√≥ria sobre como otimizar o desempenho de projetos Angular, tamb√©m espero que n√£o incline voc√™ a se apressar para remover o zone.js do seu projeto.  A estrat√©gia descrita aqui deve ser o √∫ltimo recurso para o qual voc√™ pode recorrer, a fim de aumentar o desempenho do seu aplicativo Angular. <br><br>  Primeiro, voc√™ precisa tentar abordagens como usar a estrat√©gia de detec√ß√£o de altera√ß√µes OnPush, aplicar <code>trackBy</code> , desativar componentes, executar c√≥digo fora dos eventos zone.js, blacklisting zone.js (esta lista de m√©todos de otimiza√ß√£o pode ser continuada).  A abordagem mostrada aqui √© bastante cara e n√£o tenho certeza de que todos estejam dispostos a pagar um pre√ßo t√£o alto pelo desempenho. <br><br>  De fato, o desenvolvimento sem o zone.js pode n√£o ser a coisa mais atraente.  Talvez isso n√£o seja apenas para a pessoa que est√° envolvida no projeto, que est√° sob seu controle total.  Ou seja - √© o propriet√°rio das depend√™ncias e tem a capacidade e o tempo para trazer tudo √† sua forma correta. <br><br>  Se voc√™ tentou de tudo e acredita que o gargalo do seu projeto √© precisamente zone.js, talvez tente acelerar o Angular detectando independentemente as altera√ß√µes. <br><br>  Espero que este artigo tenha permitido que voc√™ veja o que o Angular espera no futuro, o que o Ivy √© capaz e o que o zone.js pode fazer para maximizar a velocidade do aplicativo. <br><br>  <b>Caros leitores!</b>  Como voc√™ otimiza seus projetos Angular que precisam de desempenho m√°ximo? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt476956/">https://habr.com/ru/post/pt476956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt476938/index.html">Luxo inacess√≠vel da Intel: Core i9-9990XE com 14 n√∫cleos a uma frequ√™ncia de 5,0 GHz (2 partes)</a></li>
<li><a href="../pt476940/index.html">Sem√°foro em Eventos C ++</a></li>
<li><a href="../pt476944/index.html">O c√©rebro da empresa. Iniciar</a></li>
<li><a href="../pt476948/index.html">Trajet√≥rias qu√¢nticas e o que elas comem</a></li>
<li><a href="../pt476954/index.html">O trabalho n√£o √© um lobo, parte 3. Iniciante - crescer ou sobreviver?</a></li>
<li><a href="../pt476958/index.html">Omega Red + PS1 Emulator = Kojima Genius</a></li>
<li><a href="../pt476970/index.html">EkbDotNet Meeting No. 1 - Yekaterinburg ingressa na comunidade DotNet.Ru</a></li>
<li><a href="../pt476972/index.html">Deno: O tempo do Node.JS est√° se esgotando?</a></li>
<li><a href="../pt476974/index.html">Aprenda Web Design responsivo em 5 minutos</a></li>
<li><a href="../pt476976/index.html">6 erros de falar em p√∫blico em confer√™ncias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>