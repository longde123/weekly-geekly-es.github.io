<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 ⭐️ 🧒🏼 面向Docker用户的Podman和Buildah 🤱🏽 🤴🏽 👨‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="尽管有很多关于Podman和Buildah的优秀博客和教程，但是Docker用户显然缺乏关于如何切换到Podman的清晰明了的解释，为什么在其他此类问题中也需要Buildah。 



 我们将尝试回答这些问题，并告诉您如何从Docker无缝迁移到Podman。 

 Docker如何工作 
 让我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>面向Docker用户的Podman和Buildah</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/467105/"> 尽管有很多关于Podman和Buildah的优秀博客和教程，但是Docker用户显然缺乏关于如何切换到Podman的清晰明了的解释，为什么在其他此类问题中也需要Buildah。 <br><br><img src="https://habrastorage.org/webt/m9/de/um/m9deumkiupstpwlpynelflvucxo.png" width="100%"><br><br> 我们将尝试回答这些问题，并告诉您如何从Docker无缝迁移到Podman。 <br><a name="habracut"></a><br><h3>  Docker如何工作 </h3><br> 让我们首先阐明Docker的工作原理，以了解Podman和Buildah为何诞生。 如您所知，Docker命令仅在Docker守护进程运行时才起作用。 恶魔的想法似乎是在一个地方收集Docker所做的所有很棒的工作，同时组织有用的API以便将来使用。 如下图所示，Docker守护程序包含执行以下任务所需的所有功能： <br><br><ul><li> 使用图像注册表时的推拉操作； </li><li> 在本地容器存储中创建图像副本，并在这些容器中添加图层； </li><li> 提交容器更改并从主机上的本地存储库中删除容器映像； </li><li> 请求OS内核在相应的名称空间，cgroup等中启动容器。 </li></ul><br> 本质上，Docker守护进程负责处理注册表，映像，容器和内核的所有工作。 您只需通过命令行界面（CLI）告诉他该怎么做。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rp/ot/n9/rpotn9q5ovfti-d-jv2m7yyhbta.png"></div><br><br> 当一切都在一个恶魔过程中组装时，这里我们不会权衡这种方法的利弊。 可以提出许多有利于他的论点，并且在Docker出现时，它是非常合理的。 但是，随着Docker的积极使用，他开始出现疑问，例如： <br><br><ul><li> 单一过程意味着单一故障点。 </li><li> 守护进程拥有所有子进程（正在运行的容器）。 </li><li> 当恶魔离开时，子进程仍然是孤儿。 </li><li> 容器组件上有安全孔； </li><li> 要执行任何Docker操作，用户需要完整的root特权。 </li></ul><br> 还有其他投诉。 有人可能不同意这一说法，或者说这些缺点已经消除，但我们不会争论。  Podman开发人员认为他们已经设法解决了许多此类问题，如果您想利用Podman的优势，那么本文非常适合您。 <br><br>  Podman的本质是不通过守护程序而是直接通过负责启动容器的runC进程与映像注册表，容器和映像存储以及Linux内核进行交互。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bf/a8/xo/bfa8xofe89azm6tc_bx71brzhcs.png"></div><br><br> 既然我们已经部分了解了Podman开发人员的动机，那么现在该讨论向Podman过渡对用户意味着什么。 在这里，我们需要了解和阐明（我们将在下面做）以下内容： <br><br><ul><li>  Podman取代了Docker。 同时，不再需要启动某种守护进程，例如Docker守护进程。 </li><li> 熟悉的Docker命令在Podman中的工作方式相同。 </li><li>  Podman不会将容器和映像存储在与Docker相同的位置。 </li><li>  Podman和Docker映像兼容； </li><li> 在Kubernetes环境中，Podman的功能不只是Docker。 </li><li> 我们还将分析Buildah是什么以及为什么需要它。 </li></ul><br><h3>  Podman安装 </h3><br> 如果您使用Docker，则可以在决定进行切换时将其删除。 但是，您可以在尝试Podman时离开Docker。 这里有一些有用的<a href="">课程</a>和出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">演示</a> ，对于初学者来说可能很有用，以帮助您更好地理解过渡过程。 该演示中的一个示例要求Docker显示兼容性。 <br><br> 要在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Red Hat Enterprise Linux</a> 7.6或更高版本上安装Podman，请使用以下命令： 如果您使用的是Fedora，则将yum替换为dnf： <br><br><pre><code class="plaintext hljs"># yum -y install podman</code> </pre> <br><h3>  Podman使用与Docker相同的命令 </h3><br>  Podman的设计易于从Docker切换到。 因此，您从Docker认识的所有团队在Podman中的工作方式都相同。 此外，有人认为，如果您创建适当的别名，则Docker调用脚本应该可以正常工作，例如：alias docker = podman-试试看。 当然，在此之前，您需要停止Docker（systemctl停止docker）。 此外，您可以安装podman-docker软件包，该软件包将为您进行所有必要的转换。 它只是将一个脚本放入/ usr / bin / docker中，该脚本使用与Docker使用相同的参数来运行Podman。 <br><br> 常见的Docker命令（例如pull，push，build，run，commit，tag等）都在Podman中。 有关更多信息，请参见Podman手册。 一个重要的区别是，在Podman中，某些团队添加了方便标记，例如，podman rm和podman rmi命令的--all（-a）标志，很多人会发现它们非常有用。 <br><br> 此外，Podman可以以普通用户身份运行，而无需root特权。 是的，到目前为止，这仅在Fedora和Podman 1.0中有效，并且在RHEL中应该从7.7和8.1版本开始出现。 由于用户空间保护方面的改进，使之成为可能。 以普通用户身份运行意味着默认情况下Podman将图像和容器存储在用户的主目录中，我们将在下一部分中对此进行详细讨论。 要了解有关如何在没有root特权的情况下运行Podman的更多信息，请参阅Dan Walsh的文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">无根Podman如何工作？</a>  。 <br><br><h3>  Podman和容器图片 </h3><br> 当您第一次输入podman images命令时，您很可能会灰心，因为您不会看到之前已经下载到计算机上的任何Docker映像。 事实是，本地Podman存储库位于/ var / lib / docker文件夹中，而不位于/ var / lib / docker目录中。 这样做不仅是这样，而且是满足OCI（开放容器倡议）标准的新存储结构的一部分。 <br><br>  2015年，Docker，Red Hat，CoreOS，SUSE，Google和其他Linux容器趋势创建者创建了Open Container Initiative，这是一个独立的机构，负责管理容器映像格式及其运行时的标准规范。 作为OCI的一部分，在GitHub上创建了容器/映像和容器/存储项目。 <br><br> 由于Podman可以在没有root特权的情况下运行，因此需要一个单独的位置来记录图像。 因此，Podman存储库位于〜/ .local / share / containers用户主目录中。 这有助于避免出现这样的情况：他们可以在/ var / lib /容器中编写所有内容，并且与其他从安全角度来看很危险的做法有关。 另外，现在每个用户都有自己的独立容器集，以便多个用户可以同时在主机上同时工作。 完成工作后，用户可以将其推送到通用注册表，以使其他人可以使用其图像。 <br><br> 从Docker切换到Podman时，在调试时以及要使用rm -rf / var / lib / containers命令清除本地存储库以重新开始时，了解新的容器位置路径将非常有用。 但是，通过切换到Podman，您很可能会开始对podman rm和podman rmi命令而不是此命令使用新的-all选项。 <br><br><h3>  Podman与其他运行时之间的容器兼容性 </h3><br> 尽管本地存储库的位置不同，但Docker和Podman都创建了与OCI标准兼容的容器映像。  Podman可以使用常用的容器注册表，例如Quay.io或Docker Hub，以及双向（推和拉）的私有注册表。 例如，使用Podman，您可以从Docker Hub下载并运行最新的Fedora映像。 如果未指定注册表，默认情况下，Podman将按照该文件中指定的顺序搜索registries.conf。文件中列出的注册表。 最初，此文件中的第一个是Docker Hub注册表。 <br><br><pre> <code class="plaintext hljs">$ podman pull fedora:latest $ podman run -it fedora bash</code> </pre><br> 可以使用Podman下载并运行已使用Docker上传到注册表的图像。 例如，如果我们使用Docker创建了myfedora映像并将其上传到我们的Quay.io（ipbabble）存储库，则可以使用Podman下载它，方法如下： <br><br><pre> <code class="plaintext hljs">$ podman pull quay.io/ipbabble/myfedora:latest $ podman run -it myfedora bash</code> </pre><br>  Podman允许您使用push和pull命令在/ var / lib / docker和/ var / lib / containers目录之间轻松优雅地移动图像，例如： <br><br><pre> <code class="plaintext hljs">$ podman push myfedora docker-daemon:myfedora:latest</code> </pre><br> 显然，如果在此示例中省略了docker-daemon，则推送发送将进入Docker Hub。 如果您指定quay.io/myquayid/myfedora，则图像将上传到Quay.io注册表（此处myquayid是我们在Quay.io上的帐户名称）： <br><br><pre> <code class="plaintext hljs">$ podman push myfedora quay.io/myquayid/myfedora:latest</code> </pre><br> 如果您决定准备放弃Docker，则要卸载它，只需关闭守护程序，然后使用软件包管理器删除Docker软件包。 但是在此之前，请确保使用Docker将所需的所有映像下载到外部（而非本地）注册表，以便以后可以从那里下载它们。 或者，您可以使用Podman将它们从本地Docker存储库下载到本地Podman OCI存储库。 例如，在RHEL中，像下面这样完成一个fedora映像的传输： <br><br><pre> <code class="plaintext hljs"># systemctl stop docker # podman pull docker-daemon:fedora:latest # yum -y remove docker # optional</code> </pre><br><h3> 使用Podman可以轻松切换到Kubernetes </h3><br> 与Docker相比，Podman提供了许多附加功能，这些功能对于使用Kubernetes的开发人员和IT运营商非常有用，特别是Docker根本没有的有用命令。 如果您熟悉Docker并考虑将Kubernetes / OpenShift用作容器平台，那么Podman将派上用场。 <br><br>  Podman可以使用podman generate kube命令基于正在运行的容器生成Kubernetes YAML文件。 在调试运行的Pod时，除了用于处理容器的标准命令外，还可以使用podman pod命令。 有关Podman如何帮助切换到Kubernetes的更多信息，请参见Brent Baude的文章Podman现在可以简化向Kubernetes和CRI-O的过渡。 <br><br><h3>  Buildah-它是什么，为什么 </h3><br>  Buildah的出现早于Podman。 这有时使Docker用户感到沮丧：“为什么Podman辩护者突然谈论Buildah？  Podman不知道如何建造？” <br><br>  Podman可以放心地做到这一点，就像Docker一样。 也就是说，可以使用Dockerfile和podman build命令执行组装，也可以启动容器，进行必要的更改，然后提交（执行提交），在容器映像中创建新标签。 在我们的解释中，Buildah是用于创建和管理容器映像的扩展命令集，因此在处理映像时它提供了更好的控制。  Podman构建命令部分包含Buildah功能，并且使用与Buildah本身相同的程序代码进行构建。 <br><br> 使用Buildah的最有效方法是编写Bash脚本来创建映像，就像您为Dockerfile编写的一样。 <br><br> 至于Buildah和Podman出现的时间顺序，事件大致发生如下。 当Kubernetes学习基于OCI标准的CRI-O进行容器运行时时，不再需要Docker守护程序。 也就是说，不再需要在Kubernetes集群的所有节点上安装Docker来运行Pod和容器。  Kubernetes现在可以调用CRI-O，并且它可以直接运行RunC，从而启动容器进程。 但是，如果同时我们不仅要使用相同的Kubernetes集群进行启动，还希望将其用于容器组装（例如，在OpenShift中），那么我们需要一个不依赖Docker守护进程和，因此不需要安装Docker。 此外，这种基于容器/存储和容器/映像项目创建的工具将消除在组装过程中与Docker守护进程的开放套接字相关的安全风险，许多Docker用户都担心这些风险。 <br><br>  Buildah成为了这样一个新工具（名称读作“ build”，模仿项目经理Dan Walsh在波士顿的口音，但发音为“ builder”）。 可以在buildah.io上找到有关Buildah的更多信息，以及本文末尾的博客和链接指南。 <br><br> 如果要使用Buildah，还需要了解更多详细信息： <br><br><ol><li> 创建图像层时，它提供了更精确的控制。 特别是，它允许您执行许多容器用户长期以来一直想做的事情-仅在一层上一次提交许多更改。 </li><li>  Buildah的运行和Podman的运行是两回事。 由于Buildah旨在构建映像，因此它的run命令与Dockerfile中的RUN命令本质上相同。  Buildah的开发商之一威廉·亨利（William Henry）回忆起这种解决方案是如何产生的：“我有点不高兴地发现某些端口或安装架根本无法按我的预期工作。  Dan Walsh（@rhatdan）权衡了一切，并说Buildah根本不应该以这种方式使用容器。 全部，不再有端口映射，也没有安装卷。 我们删除了这些标志，而是使用buildah run来运行构建容器映像时所需的命令，例如buildah run dnf -y install nginx。 </li><li>  Buildah可以从头开始创建图像（临时图像）。 也就是说，从字面上看什么都没有的图像。 实际上，如果您从头开始查看由于buildah而创建的容器存储，将有一个空目录。 从创建仅包含运行应用程序所需的程序包的超轻量级映像的角度来看，这非常有用。 </li></ol><br> 为什么要从头开始构建？ 让我们将Java应用程序的开发映像与其在生产环境或登台环境中的映像进行比较。 在开发阶段，映像可能包含Java编译器，Maven和开发人员需要的其他工具。 但是当转换为生产时，只有Java运行时和您的程序包应保留在映像中。 顺便说一句，要删除多余的文件，您根本不需要像DNF / YUM这样的软件包管理器，甚至不需要Bash-您可以通过Buildah CLI界面进行所有操作，如下图所示，传统的多层容器在左侧，单层容器在右侧刮擦图像。 有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">更多</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细信息，</a>请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为Kubernetes构建Buildah容器映像</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Buildah简介演示</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qq/kd/w5/qqkdw5dmlj4c5fuyxsi7chc1pew.png"></div><br><br> 回到年代。 因此，Kubernetes学会了与CRI-O和runC一起工作，在构建过程中，我们堆积了Buildah-一切，从Kubernetes主机上的Docker，您可以拒绝吗？ 不，调试仍然存在。 如果主机没有适当的工具，如何解决容器问题？ 不要将Docker放在上面，否则我们将再次回到恶魔手中，所有的努力都是徒劳的。 然后Podman进入现场。 <br><br> 即，Podman同时解决了两个问题。 首先，它允许IT操作人员使用熟悉的命令检查容器和图像。 其次，他将这些工具提供给开发人员。 结果，所有Docker用户（无论是开发人员还是操作员）都可以切换到Podman，从容地执行以前使用Docker的任务，并解决一系列新任务。 <br><br><h3> 所需资源： </h3><br><ul><li>  Podman.io和Buildah.io项目的网站。 </li><li>  github.com/containers上的项目（建立连接，研究源代码并查看开发中的内容： <br><ul><li>  libpod（Podman）； </li><li> 建筑物 </li><li> 图像（用于处理容器OCI图像的代码）； </li><li> 存储（用于本地存储容器映像的代码）。 </li></ul><br></li></ul><br><h3> 有用的链接： </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">没有守护程序的容器：RHEL 7.6和RHEL 8 Beta中可用的Podman和Buildah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Podman：在本地容器运行时中管理容器和容器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用Podman管理容器化的系统服务（使用systemd管理Podman容器）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">为Kubernetes构建Buildah容器映像</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Podman现在可以简化向Kubernetes和CRI-O的过渡</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">容器运行时的安全注意事项（Dan Walsh在KubeCon 2018上的表现的视频录像）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过OpenShift使用容器进行IoT边缘开发和部署：第1部分（使用sing podman，qemu，binfmt_misc和Ansible在OpenShift平台上组装和测试ARM64容器）</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN467105/">https://habr.com/ru/post/zh-CN467105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN467093/index.html">使用Strace监视程序</a></li>
<li><a href="../zh-CN467095/index.html">比听起来容易。 20</a></li>
<li><a href="../zh-CN467097/index.html">在Realm中使用分页库</a></li>
<li><a href="../zh-CN467099/index.html">小孩子的哈皮</a></li>
<li><a href="../zh-CN467101/index.html">用狗的气味创造机器人的史诗</a></li>
<li><a href="../zh-CN467107/index.html">如何使用GitLab CI / CD运行多个管道</a></li>
<li><a href="../zh-CN467109/index.html">质量检查如何组织项目的测试自动化。 一种实用的方法</a></li>
<li><a href="../zh-CN467111/index.html">关于如何在手机上少挂的根本提示</a></li>
<li><a href="../zh-CN467113/index.html">如何使用户留在网站上？ 可用性秘密</a></li>
<li><a href="../zh-CN467115/index.html">非典型“ ls”-哈伯版</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>