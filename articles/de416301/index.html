<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏻 🐖 🧑🏼 Navigation in der Android-Anwendung mit Koordinatoren 👶🏿 🏴󠁧󠁢󠁷󠁬󠁳󠁿 🗽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Jahren haben wir gemeinsame Ansätze für die Erstellung von Android-Anwendungen entwickelt. Reine Architektur, Architekturmuster (MVC, M...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Navigation in der Android-Anwendung mit Koordinatoren</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/416301/">  In den letzten Jahren haben wir gemeinsame Ansätze für die Erstellung von Android-Anwendungen entwickelt.  Reine Architektur, Architekturmuster (MVC, MVP, MVVM, MVI), das Repository-Muster und andere.  Es gibt jedoch noch keine allgemein akzeptierten Ansätze zum Organisieren der Navigation innerhalb der Anwendung.  Heute möchte ich mit Ihnen über die Vorlage „Koordinator“ und die Möglichkeiten ihrer Anwendung bei der Entwicklung von Android-Anwendungen sprechen. <br><blockquote>  Das Koordinatormuster wird häufig in iOS-Anwendungen verwendet und wurde von Soroush Khanlou eingeführt, um die Navigation der Anwendung zu vereinfachen.  Es wird angenommen, dass Sorushs Arbeit auf dem Application Controller-Ansatz basiert, der in den Patterns of Enterprise Application Architecture von Martin Fowler beschrieben ist. <br></blockquote>  Die Vorlage „Koordinator“ dient zur Lösung der folgenden Aufgaben: <br><br><ul><li>  Kampf mit dem Massive View Controller-Problem (das Problem wurde bereits auf dem Hub geschrieben - Anmerkung des Übersetzers), das sich oft mit dem Aufkommen von Gott-Aktivität (Aktivität mit vielen Verantwortlichkeiten) manifestiert. </li><li>  Trennung der Navigationslogik in eine separate Einheit </li><li>  Wiederverwendung von Anwendungsbildschirmen (Aktivität / Fragmente) aufgrund schwacher Verbindung mit der Navigationslogik </li></ul><br>  Bevor Sie sich jedoch mit der Vorlage vertraut machen und versuchen, sie zu implementieren, werfen wir einen Blick auf die in Android-Anwendungen verwendeten Navigationsimplementierungen. <br><a name="habracut"></a><br><h3>  Die Navigationslogik ist in der Aktivität / im Fragment beschrieben </h3><br>  Da das Android SDK erfordert, dass Context eine neue Aktivität öffnet (oder FragmentManager, um der Aktivität ein Fragment hinzuzufügen), wird die Navigationslogik häufig direkt in der Aktivität / dem Fragment beschrieben.  Sogar die Beispiele in der Dokumentation für das Android SDK verwenden diesen Ansatz. <br><br><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = Intent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, CheckoutActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span></span>(intent) } } }</code> </pre> <br>  Im obigen Beispiel ist die Navigation eng mit der Aktivität verbunden.  Ist es bequem, solchen Code zu testen?  Man könnte argumentieren, dass wir die Navigation in eine separate Entität trennen und sie beispielsweise Navigator nennen können, der implementiert werden kann.  Mal sehen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { navigator.showCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Navigator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCheckout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(activity : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Activity</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = Intent(activity, CheckoutActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">activity</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">startActivity</span></span></span></span>(intent) } }</code> </pre><br>  Es stellte sich nicht schlecht heraus, aber ich will mehr. <br><br><h3>  Navigation mit MVVM / MVP </h3><br>  Ich beginne mit der Frage: Wo würden Sie die Navigationslogik platzieren, wenn Sie MVVM / MVP verwenden? <br><br>  In der Ebene unter dem Präsentator (nennen wir es Geschäftslogik)?  Keine gute Idee, da Sie Ihre Geschäftslogik höchstwahrscheinlich in anderen Präsentationsmodellen oder Präsentatoren wiederverwenden werden. <br><br>  In der Ansichtsebene?  Möchten Sie wirklich Ereignisse zwischen die Präsentation und das Präsentations- / Präsentationsmodell werfen?  Schauen wir uns ein Beispiel an: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShoppingCartView</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> presenter : ShoppingCartPresenter <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { presenter.checkoutClicked() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigateToCheckout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartPresenter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Presenter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShoppingCartView</span></span></span><span class="hljs-class">&gt; </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkoutClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ view?.navigateToCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  Wenn Sie MVVM bevorzugen, können Sie SingleLiveEvents oder EventObserver verwenden <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ShoppingCartView</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewModel : ViewModel <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(b) setContentView(R.layout.activity_shopping_cart) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> checkoutButton = findViewById(R.id.checkoutButton) checkoutButton.setOnClickListener { viewModel.checkoutClicked() } viewModel.navigateToCheckout.observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, Observer { navigator.showCheckout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) }) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoppingCartViewModel</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ViewModel</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigateToCheckout = MutableLiveData&lt;Event&lt;<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>&gt;&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkoutClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigateToCheckout.value = Event(<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Trigger the event by setting a new Event as a new value } }</span></span></code> </pre><br>  Oder fügen Sie einen Navigator in ein Ansichtsmodell ein, anstatt EventObserver wie im vorherigen Beispiel gezeigt zu verwenden <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ShoppingCartViewModel @Inject <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val navigator : Navigator)</span></span></span><span class="hljs-function"> :</span></span> ViewModel() <span class="hljs-comment"><span class="hljs-comment">{ fun checkoutClicked(){ navigator.showCheckout() }</span></span> }</code> </pre><br>  Bitte beachten Sie, dass dieser Ansatz auf den Präsentator angewendet werden kann.  Wir ignorieren auch einen möglichen Speicherverlust im Navigator, wenn eine Verbindung zum Aktivator besteht. <br><br><h3>  Koordinator </h3><br>  Wo platzieren wir die Navigationslogik?  Geschäftslogik?  Wir haben diese Option bereits in Betracht gezogen und sind zu dem Schluss gekommen, dass dies nicht die beste Lösung ist.  Das Auslösen von Ereignissen zwischen der Ansicht und dem Ansichtsmodell funktioniert möglicherweise, sieht jedoch nicht nach einer eleganten Lösung aus.  Darüber hinaus ist die Ansicht weiterhin für die Navigationslogik verantwortlich, obwohl wir sie zum Navigator gebracht haben.  Nach der Ausschlussmethode haben wir weiterhin die Möglichkeit, die Navigationslogik in das Präsentationsmodell einzufügen, und diese Option erscheint vielversprechend.  Aber sollte sich das Ansichtsmodell um die Navigation kümmern?  Ist das nicht nur eine Ebene zwischen der Ansicht und dem Modell?  Deshalb sind wir auf die Idee eines Koordinators gekommen. <br><br>  "Warum brauchen wir eine andere Abstraktionsebene?"  - Du fragst.  Lohnt sich die Komplexität des Systems?  In kleinen Projekten kann sich die Abstraktion tatsächlich zum Zwecke der Abstraktion herausstellen. In komplexen Anwendungen oder bei Verwendung von A / B-Tests kann der Koordinator jedoch nützlich sein.  Angenommen, ein Benutzer kann ein Konto erstellen und sich anmelden.  Wir haben bereits eine Logik, in der wir überprüfen müssen, ob sich der Benutzer angemeldet hat, und entweder den Anmeldebildschirm oder den Hauptbildschirm der Anwendung anzeigen müssen.  Der Koordinator kann mit dem gegebenen Beispiel helfen.  Beachten Sie, dass der Koordinator nicht dazu beiträgt, weniger Code zu schreiben, sondern den Code der Navigationslogik aus der Ansicht oder dem Ansichtsmodell abzurufen. <br><br>  Die Idee des Koordinators ist äußerst einfach.  Er weiß nur, welcher Anwendungsbildschirm als nächstes geöffnet werden soll.  Wenn ein Benutzer beispielsweise auf die Zahlungsschaltfläche für eine Bestellung klickt, erhält der Koordinator das entsprechende Ereignis und weiß, dass der nächste Schritt darin besteht, den Zahlungsbildschirm zu öffnen.  In iOS wird der Koordinator als Service-Locator verwendet, um ViewController zu erstellen und den Backstack zu steuern.  Dies ist genug für den Koordinator (denken Sie an das Prinzip der alleinigen Verantwortung).  In Android-Anwendungen erstellt das System Aktivitäten, wir haben viele Tools zum Implementieren von Abhängigkeiten und es gibt einen Backstack für Aktivitäten und Fragmente.  Kehren wir nun zur ursprünglichen Idee des Koordinators zurück: Der Koordinator weiß nur, welcher Bildschirm als nächstes angezeigt wird. <br><br><h3>  Beispiel: Nachrichtenanwendung mit einem Koordinator </h3><br>  Lassen Sie uns zum Schluss direkt über die Vorlage sprechen.  Stellen Sie sich vor, wir müssen eine einfache Nachrichtenanwendung erstellen.  Die Anwendung verfügt über zwei Bildschirme: "Liste der Artikel" und "Artikeltext", die durch Klicken auf ein Listenelement geöffnet werden. <br><br><img src="https://habrastorage.org/webt/yw/oy/cl/ywoycl_vvhclm0s6wlwkzpcgzpk.png"><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsFlowCoordinator</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigator : Navigator) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showNewsList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNewsArticle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ navigator.showNewsArticle(id) } }</code> </pre><br>  Ein Skript (Flow) enthält einen oder mehrere Bildschirme.  In unserem Beispiel besteht das Nachrichtenszenario aus zwei Bildschirmen: "Artikelliste" und "Artikeltext".  Der Koordinator war sehr einfach.  Wenn die Anwendung gestartet wird, rufen wir NewsFlowCoordinator # start () auf, um eine Liste der Artikel anzuzeigen.  Wenn ein Benutzer auf ein Listenelement klickt, wird die NewsFlowCoordinator # readNewsArticle (id) -Methode aufgerufen und ein Bildschirm mit dem vollständigen Text des Artikels angezeigt.  Wir arbeiten immer noch mit dem Navigator (darüber werden wir etwas später sprechen), an den wir das Öffnen des Bildschirms delegieren.  Der Koordinator hat keinen Status, er hängt nicht von der Implementierung des Backends ab und implementiert nur eine Funktion: Er bestimmt, wohin er als nächstes gehen soll. <br><br>  Aber wie kann man den Koordinator mit unserem Präsentationsmodell verbinden?  Wir folgen dem Prinzip der Abhängigkeitsinversion: Wir übergeben das Lambda an das Ansichtsmodell, das aufgerufen wird, wenn der Benutzer auf den Artikel tippt. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsListViewModel</span></span></span></span>( newsRepository : NewsRepository, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onNewsItemClicked: ( (<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )? ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newsArticles = MutableLiveData&lt;List&lt;News&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> disposable = newsRepository.getNewsArticles().subscribe { newsArticles.value = it } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newsArticleClicked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ onNewsItemClicked!!(id) <span class="hljs-comment"><span class="hljs-comment">// call the lambda } override fun onCleared() { disposable.dispose() onNewsItemClicked = null // to avoid memory leaks } }</span></span></code> </pre><br>  onNewsItemClicked: (Int) -&gt; Unit ist ein Lambda, das ein ganzzahliges Argument hat und Unit zurückgibt.  Bitte beachten Sie, dass Lambda möglicherweise null ist. Dadurch können wir den Link löschen, um Speicherverluste zu vermeiden.  Der Ersteller des Ansichtsmodells (z. B. ein Dolch) muss einen Link zur Koordinatormethode übergeben: <br><br><pre> <code class="hljs lisp">return NewsListViewModel( <span class="hljs-name"><span class="hljs-name">newsRepository</span></span> = newsRepository, onNewsItemClicked = newsFlowCoordinator:<span class="hljs-symbol"><span class="hljs-symbol">:readNewsArticle</span></span> )</code> </pre><br>  Zuvor haben wir den Navigator erwähnt, der den Bildschirmwechsel durchführt.  Die Implementierung des Navigators liegt in Ihrem Ermessen, da dies von Ihrem spezifischen Ansatz und Ihren persönlichen Vorlieben abhängt.  In unserem Beispiel verwenden wir eine Aktivität mit mehreren Fragmenten (ein Bildschirm - ein Fragment mit einem eigenen Präsentationsmodell).  Ich gebe eine naive Implementierung eines Navigators: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Navigator</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activity : FragmentActivity? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showNewsList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ activty!!.supportFragmentManager .beginTransaction() .replace(R.id.fragmentContainer, NewsListFragment()) .commit() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showNewsDetails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(newsId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { activty!!.supportFragmentManager .beginTransaction() .replace(R.id.fragmentContainer, NewsDetailFragment.newInstance(newsId)) .addToBackStack(<span class="hljs-string"><span class="hljs-string">"NewsDetail"</span></span>) .commit() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> navigator : Navigator <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContentView(R.layout.activity_main) navigator.activty = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() navigator.activty = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-comment"><span class="hljs-comment">// Avoid memory leaks } }</span></span></code> </pre><br>  Die obige Implementierung des Navigators ist nicht ideal, aber die Hauptidee dieses Beitrags besteht darin, einen Koordinator in das Muster einzuführen.  Da Navigator und Koordinator keinen Status haben, können sie innerhalb der Anwendung deklariert werden (z. B. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Singleton-</a> Bereiche in einem Dolch) und in Anwendung # onCreate () instanziiert werden. <br><br>  Fügen wir unserer Anwendung eine Autorisierung hinzu.  Wir definieren einen neuen Anmeldebildschirm (LoginFragment + LoginViewModel, der Einfachheit halber lassen wir die Wiederherstellung und Registrierung von Passwörtern weg) und LoginFlowCoordinator.  Warum nicht neue Funktionen zu NewsFlowCoordinator hinzufügen?  Wir möchten keinen Gott-Koordinator, der für die gesamte Navigation in der Anwendung verantwortlich ist.  Das Autorisierungsskript gilt auch nicht für das Newsreader-Szenario, oder? <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginFlowCoordinator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigator: Navigator ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showLogin() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerNewUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showRegistration() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">forgotPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showRecoverPassword() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginViewModel</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> usermanager: Usermanager, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onSignUpClicked: ( () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )?, <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onForgotPasswordClicked: ( () -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> )? ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(username : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, password : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ usermanager.login(username, password) ... } ... }</code> </pre><br>  Hier sehen wir, dass es für jedes UI-Ereignis ein entsprechendes Lambda gibt, jedoch kein Lambda für den Rückruf einer erfolgreichen Anmeldung.  Dies ist auch ein Implementierungsdetail und Sie können das entsprechende Lambda hinzufügen, ich habe jedoch eine bessere Idee.  Fügen wir einen RootFlowCoordinator hinzu und abonnieren die Modelländerungen. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RootFlowCoordinator</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> usermanager: Usermanager, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> loginFlowCoordinator: LoginFlowCoordinator, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newsFlowCoordinator: NewsFlowCoordinator, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> onboardingFlowCoordinator: OnboardingFlowCoordinator ) { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { usermanager.currentUser.subscribe { user -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (user){ <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NotAuthenticatedUser -&gt; loginFlowCoordinator.start() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> AuthenticatedUser -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (user.onBoardingCompleted) newsFlowCoordinator.start() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> onboardingFlowCoordinator.start() } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onboardingCompleted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ newsFlowCoordinator.start() } }</code> </pre><br>  Somit ist RootFlowCoordinator anstelle von NewsFlowCoordinator der Einstiegspunkt unserer Navigation.  Konzentrieren wir uns auf den RootFlowCoordinator.  Wenn der Benutzer angemeldet ist, prüfen wir, ob er das Onboarding abgeschlossen hat (dazu später mehr), und beginnen mit dem Skript für Nachrichten oder Onboarding.  Bitte beachten Sie, dass LoginViewModel nicht an dieser Logik beteiligt ist.  Wir beschreiben das Onboarding-Szenario. <br><br><img src="https://habrastorage.org/webt/hm/dg/nq/hmdgnqdu3xrkvkkisqk0xdo5mnw.png"><br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OnboardingFlowCoordinator</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">navigator</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Navigator</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">onboardingFinished</span></span></span><span class="hljs-class">: () -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unit</span></span></span><span class="hljs-class"> // this is </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RootFlowCoordinator</span></span></span><span class="hljs-class">.onboardingCompleted() ) { fun start(){ navigator.showOnboardingWelcome() } fun welcomeShown(){ navigator.showOnboardingPersonalInterestChooser() } fun onboardingCompleted(){ onboardingFinished() } }</span></span></code> </pre><br>  Onboarding wird durch Aufrufen von OnboardingFlowCoordinator # start () gestartet, das WelcomeFragment (WelcomeViewModel) anzeigt.  Nach dem Klicken auf die Schaltfläche "Weiter" wird die OnboardingFlowCoordinator # welcomeShown () -Methode aufgerufen.  Daraufhin wird der folgende Bildschirm PersonalInterestFragment + PersonalInterestViewModel angezeigt, auf dem der Benutzer Kategorien interessanter Nachrichten auswählt.  Nach Auswahl der Kategorien tippt der Benutzer auf die Schaltfläche "Weiter" und die OnboardingFlowCoordinator # onboardingCompleted () -Methode wird aufgerufen, die den Aufruf an RootFlowCoordinator # onboardingCompleted () weiterleitet und NewsFlowCoordinator startet. <br>  Mal sehen, wie der Koordinator die Arbeit mit A / B-Tests vereinfachen kann.  Ich werde einen Bildschirm mit einem Angebot zum Kauf in der Anwendung hinzufügen und es einigen Benutzern anzeigen. <br><br><img src="https://habrastorage.org/webt/e7/ok/a8/e7oka8yuwnttopnufiday2904iw.png"><br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsFlowCoordinator</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> navigator : Navigator, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> abTest : AbTest ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ navigator.showNewsList() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNewsArticle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id : </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ navigator.showNewsArticle(id) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">closeNews</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abTest.isB){ navigator.showInAppPurchases() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { navigator.closeNews() } } }</code> </pre><br>  Auch hier haben wir der Ansicht oder ihrem Modell keine Logik hinzugefügt.  Haben Sie beschlossen, InAppPurchaseFragment zum Onboarding hinzuzufügen?  Dazu müssen Sie nur den Onboarding-Koordinator ändern, da das Einkaufsfragment und sein Ansichtsmodell völlig unabhängig von anderen Fragmenten sind und wir es in anderen Szenarien frei wiederverwenden können.  Der Koordinator hilft auch bei der Implementierung des A / B-Tests, bei dem zwei Onboarding-Szenarien verglichen werden. <br><br>  Vollständige Quellen finden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie auf dem Github</a> , und für die Faulen habe ich eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Videodemo</a> vorbereitet <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PfRLZeRLvTo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Nützlicher Rat: Mit Kotlin können Sie eine bequeme DSL erstellen, um Koordinatoren in Form eines Navigationsdiagramms zu beschreiben. <br><br><pre> <code class="hljs erlang"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newsFlowCoordinator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(navigator, abTest)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">navigator</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showNewsList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readNewsArticle</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">id</span></span></span><span class="hljs-function"> -&gt;</span></span> navigator.showNewsArticle(id) } closeNews { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (abTest.isB){ navigator.showInAppPurchases() } else { navigator.closeNews() } } }</code> </pre><br><h3>  Zusammenfassung: </h3><br>  Der Koordinator hilft dabei, die Navigationslogik auf die getestete lose gekoppelte Komponente zu bringen.  Im Moment gibt es keine produktionsbereite Bibliothek, ich habe nur das Konzept der Problemlösung beschrieben.  Ist der Koordinator auf Ihre Bewerbung anwendbar?  Ich weiß nicht, es hängt von Ihren Anforderungen ab und davon, wie einfach es sein wird, es in die vorhandene Architektur zu integrieren.  Es kann nützlich sein, eine kleine Anwendung mit einem Koordinator zu schreiben. <br><br><h5>  FAQ: </h5><br>  <i>Der Artikel erwähnt nicht die Verwendung eines Koordinators mit einem MVI-Muster.</i>  <i>Ist es möglich, einen Koordinator für diese Architektur zu verwenden?</i>  Ja, ich habe einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">separaten Artikel</a> . <br><br>  <i>Google hat kürzlich den Navigationscontroller als Teil von Android Jetpack eingeführt.</i>  <i>In welcher Beziehung steht der Koordinator zur Google-Navigation?</i>  Sie können den neuen Navigationscontroller anstelle des Navigators in den Koordinatoren oder direkt im Navigator verwenden, anstatt Fragmenttransaktionen manuell zu erstellen. <br><br>  <i>Und wenn ich keine Fragmente / Aktivitäten verwenden und mein eigenes Back-End schreiben möchte, um die Ansichten zu verwalten, kann ich in meinem Fall den Koordinator verwenden?</i>  Ich habe auch darüber nachgedacht und arbeite an einem Prototyp.  Ich werde darüber in meinem Blog schreiben.  Es scheint mir, dass die Zustandsmaschine die Aufgabe erheblich vereinfachen wird. <br><br>  <i>Ist der Koordinator an den Ansatz der Einzelaktivitätsanwendung gebunden?</i>  Nein, Sie können es in verschiedenen Szenarien verwenden.  Die Implementierung des Übergangs zwischen Bildschirmen ist im Navigator ausgeblendet. <br><br>  <i>Mit dem beschriebenen Ansatz erhalten Sie einen riesigen Navigator.</i>  <i>Wir haben irgendwie versucht, von God-Object'a wegzukommen?</i>  Wir müssen den Navigator nicht in einer Klasse beschreiben.  Erstellen Sie mehrere kleine unterstützte Navigatoren, z. B. einen separaten Navigator für jedes Benutzerszenario. <br><br>  <i>Wie arbeite ich mit kontinuierlichen Übergangsanimationen?</i>  <i>Beschreiben Sie Übergangsanimationen im Navigator. Dann weiß die Aktivität / das Fragment nichts über den vorherigen / nächsten Bildschirm.</i>  <i>Woher weiß der Navigator, wann die Animation gestartet werden soll?</i>  Angenommen, wir möchten eine Animation des Übergangs zwischen den Fragmenten A und B anzeigen. Wir können das Ereignis onFragmentViewCreated (v: View) mit FragmentLifecycleCallback abonnieren. Wenn dieses Ereignis auftritt, können wir mit Animationen auf die gleiche Weise arbeiten wie direkt im Fragment: OnPreDrawListener hinzufügen um zu warten, bis es fertig ist, und startPostponedEnterTransition () aufzurufen.  Auf ungefähr die gleiche Weise können Sie einen animierten Übergang zwischen Aktivitäten mit ActivityLifecycleCallbacks oder zwischen ViewGroup mit OnHierarchyChangeListener implementieren.  Vergessen Sie nicht, Ereignisse später abzubestellen, um Speicherverluste zu vermeiden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416301/">https://habr.com/ru/post/de416301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416291/index.html">So erstellen Sie eine IIoT-Architektur zum Selbermachen. Teil 2: "Dinge"</a></li>
<li><a href="../de416293/index.html">Hybride Elektroflugzeuge reduzieren Emissionen und Lärm</a></li>
<li><a href="../de416295/index.html">Das größte Teleskop der Welt kann endlich Sterne ohne Beugungsstrahlen sehen</a></li>
<li><a href="../de416297/index.html">Plug-in ml-Agent für Einheit</a></li>
<li><a href="../de416299/index.html">Die Menschen verfolgen seit Jahrzehnten Gletscher in Island. Jetzt wird die Technik es tun</a></li>
<li><a href="../de416303/index.html">Den ersten Auslöser neu erstellen</a></li>
<li><a href="../de416305/index.html">Standardisierung ist das längste Abenteuer im Internet der Dinge</a></li>
<li><a href="../de416307/index.html">iOS 12: Neu in Benachrichtigungen</a></li>
<li><a href="../de416309/index.html">Verwendung von HDF5-Dateien in Python</a></li>
<li><a href="../de416313/index.html">Checkliste für die Analyse von Sicherheitsereignisprotokollen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>