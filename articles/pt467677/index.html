<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõë üßïüèæ ‚ö∞Ô∏è Testes ou tipos ‚òùüèø üë©‚Äçüëß üéà</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Habr. Outro dia, eu estava procurando como fazer algo em Idris, e me deparei com um bom post, cuja tradu√ß√£o gratuita parece bastante apropriada. Li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Testes ou tipos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467677/"><p>  <em>Oi Habr.</em>  <em>Outro dia, eu estava procurando como fazer algo em Idris, e me deparei com um bom post, cuja tradu√ß√£o gratuita parece bastante apropriada.</em>  <em>Liberdades e amorda√ßas, quando necess√°rio, denotarei "aqui por tais rabiscos no come√ßo e no fim".</em> </p><br><p>  Quando usar testes e quando - tipos?  Quais informa√ß√µes e quais garantias recebemos em troca de nossos esfor√ßos para escrev√™-las? </p><br><p>  Veremos um exemplo simples e um pouco artificial, expresso em Python, C, Haskell e Idris.  Tamb√©m veremos o que pode ser dito sobre a implementa√ß√£o sem nenhum conhecimento adicional sobre ela, em cada caso. </p><br><p> N√£o levaremos em conta as v√°rias backdoors que nos permitem violar explicitamente as garantias de idioma (por exemplo, extens√µes C, <code>unsafePerformIO</code> em Haskell, convers√µes de tipo n√£o seguras); caso contr√°rio, seria imposs√≠vel tirar conclus√µes e essa postagem seria bastante curta.  ‚ü¶Al√©m disso, o mesmo Haskell possui um subconjunto do Safe Haskell que pro√≠be explicitamente e transitivamente o uso desses e de v√°rios outros truques que podem violar a integridade do idioma.‚üß </p><a name="habracut"></a><br><h2>  Especifica√ß√£o </h2><br><blockquote>  Deixe uma lista e algum significado ser dado.  √â necess√°rio retornar o √≠ndice desse valor na lista ou indicar que esse valor n√£o est√° na lista. </blockquote><p>  A implementa√ß√£o desta especifica√ß√£o √© trivial, por isso √© natural perguntar, e aqui est√£o geralmente testes ou tipos.  No entanto, essas propriedades e m√©todos de racioc√≠nio, sobre os quais falaremos hoje, s√£o aplic√°veis ‚Äã‚Äãa um c√≥digo muito mais complexo.  Deixe a implementa√ß√£o levar dez mil linhas de c√≥digo espaguete ileg√≠vel, se isso ajudar a ver sua utilidade. </p><br><h2>  Python </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(y, z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># 10000   </span></span></code> </pre> <br><p>  Percebemos imediatamente que n√£o estamos interessados ‚Äã‚Äãnas propriedades desmarcadas e sem√¢nticas - que n√£o afetam as propriedades de um programa como a nomea√ß√£o de vari√°veis ‚Äã‚Äãe a documenta√ß√£o de texto; portanto, intencionalmente n√£o escrevi c√≥digo que ajude a percep√ß√£o.  Estamos interessados ‚Äã‚Äãapenas no fato de que, sujeito a aprova√ß√£o em testes e verifica√ß√µes de tipo, <em>n√£o pode ser falso</em> . </p><br><p>  No c√≥digo acima, praticamente n√£o h√° informa√ß√µes √∫teis al√©m do fato de termos uma fun√ß√£o que aceita dois argumentos.  Essa fun√ß√£o pode igualmente encontrar o √≠ndice do valor na lista ou pode enviar uma carta ofensiva para sua av√≥. </p><br><p>  <strong>An√°lise</strong> </p><br><p>  N√£o apenas obtemos c√≥digo fr√°gil sem testes e tipos, mas nossa √∫nica maneira de entender o que uma fun√ß√£o faz √© a documenta√ß√£o.  E como a documenta√ß√£o √© verificada por pessoas, n√£o por m√°quinas, pode facilmente ficar desatualizada - ou inicialmente incorreta -. </p><br><ul><li>  <strong>A documenta√ß√£o</strong> <br><ul><li>  Know Conhecemos o comportamento esperado <br>  N√£o temos nada a nos dizer sobre o comportamento dessa fun√ß√£o.  Voc√™ odeia sua av√≥.  Voc√™ √© um monstro. </li></ul></li><li>  <strong>Garantias</strong> <br><ul><li>  ‚úì Seguran√ßa de mem√≥ria <br>  Python √© uma linguagem de coleta de lixo que remove essa preocupa√ß√£o de n√≥s.  No entanto, at√© onde eu sei, nada impede que voc√™ puxe bibliotecas inseguras ou C FFI dentro dessa fun√ß√£o. </li></ul></li></ul><br><h2>  Python com testes </h2><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_happy_path</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>) == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_missing</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> x([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br><p>  Agora sabemos que nossa fun√ß√£o funciona e, se o elemento estiver ausente, o resultado ser√° <code>None</code> ? </p><br><p>  Bem ... n√£o.  Este √© apenas um exemplo.  Infelizmente, o escopo de nossa fun√ß√£o √© infinito, e nenhum n√∫mero de exemplos pode provar o correto funcionamento de nossa fun√ß√£o.  Mais testes - mais confian√ßa, mas nenhum n√∫mero de testes resolver√° todas as d√∫vidas. </p><br><p>  A possibilidade de que essa fun√ß√£o retorne <code>None</code> para <code>4</code> , mas n√£o para <code>5</code> , parece loucura e, nesse caso em particular, isso provavelmente n√£o faz sentido.  Podemos ficar satisfeitos com nosso n√≠vel de f√© e insistir em um certo n√∫mero de exemplos.  Mas, novamente, a postagem ser√° curta, ent√£o vamos imaginar que a implementa√ß√£o n√£o seja t√£o √≥bvia. </p><br><p>  Como os testes n√£o podem provar algo no caso geral, mas apenas mostram o comportamento com exemplos espec√≠ficos, os testes <em>n√£o podem</em> mostrar a aus√™ncia de erros.  Por exemplo, n√£o h√° teste que mostre que nossa fun√ß√£o nunca lan√ßa uma exce√ß√£o ou nunca entra no ciclo eterno ou n√£o cont√©m links inv√°lidos.  Isso pode ser apenas uma an√°lise est√°tica. </p><br><p>  No entanto, mesmo que os exemplos n√£o sejam muito bons no papel de evid√™ncia, eles pelo menos constituem uma boa documenta√ß√£o.  A partir desses dois exemplos, podemos derivar a especifica√ß√£o completa sob algumas premissas a priori adicionais - esses dois exemplos tamb√©m satisfazem, por exemplo, o ‚Äúcounterspec‚Äù ‚Äúencontra o elemento na matriz e retorna o anterior, se houver‚Äù, o que levou dez segundos para inventar . </p><br><p>  <strong>An√°lise</strong> </p><br><p>  Embora os testes possam mostrar como usar nossa fun√ß√£o e tamb√©m dar um pouco de confian√ßa de que essa fun√ß√£o funcione corretamente com pelo menos alguns exemplos, eles n√£o podem <em>provar</em> nada sobre o nosso c√≥digo no caso geral.  Infelizmente, isso significa que os testes ajudam apenas parcialmente a evitar erros. </p><br><ul><li>  <strong>A documenta√ß√£o</strong> <br><ul><li>  ‚úì <strong>Temos um exemplo de uso</strong> </li><li>  ‚úì <strong>Conhecemos algumas classes de valores que ser√£o processados ‚Äã‚Äãcorretamente</strong> </li><li>  ‚úó Conhecemos todos os tipos de valores que ser√£o processados ‚Äã‚Äãcorretamente <br>  N√£o temos restri√ß√µes quanto aos tipos de argumentos; portanto, apesar da exist√™ncia de exemplos do que a fun√ß√£o pode manipular, n√£o sabemos quais tipos n√£o foram testados. </li><li>  Know Conhecemos o comportamento esperado <br>  "O autor do artigo original assinalado aqui, vou me permitir colocar uma cruz, dado o coment√°rio acima" </li></ul></li><li>  <strong>Especifica√ß√£o</strong> <br><ul><li>  ‚úì <strong>Funciona em pelo menos um caso</strong> </li><li>  Index O √≠ndice retornado √© sempre um √≠ndice v√°lido </li><li>  Index O √≠ndice retornado sempre indica um valor adequado </li><li>  Item O item ausente sempre retorna <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Erros comuns</strong> <br><ul><li>  ‚úó Sem erros de digita√ß√£o ou nomes incorretos <br>  A an√°lise est√°tica pode ajudar, mas como o Python √© uma linguagem din√¢mica com a capacidade de substituir v√°rias coisas no tempo de execu√ß√£o, nunca podemos provar que n√£o h√° erros. <br>  Em particular, pode ser muito dif√≠cil ou imposs√≠vel determinar se o nome do m√©todo est√° correto, pois a validade da chamada do m√©todo depende do tipo de tempo de execu√ß√£o do objeto no qual a chamada √© feita. </li><li>  Null Nenhum <code>null</code> inesperado </li><li>  Case Caso de erro √© sempre tratado <br>  Na minha experi√™ncia, esta √© uma das fontes mais comuns de erros: em nosso exemplo, a fun√ß√£o retorna <code>None</code> no caso de um elemento ausente, mas o c√≥digo que usa essa fun√ß√£o pode assumir, por exemplo, que sempre retornar√° um n√∫mero.  Al√©m disso, isso tamb√©m pode levar a uma exce√ß√£o n√£o tratada. </li></ul></li><li>  <strong>Garantias</strong> <br><ul><li>  ‚úì Seguran√ßa de mem√≥ria </li><li>  ‚úó A fun√ß√£o n√£o pode ser chamada com o tipo errado </li><li>  ‚úó Sem efeitos colaterais </li><li>  ‚úó Sem exce√ß√µes </li><li>  ‚úó Sem erros </li><li>  ‚úó Sem ciclos perp√©tuos </li></ul></li></ul><br><h2>  Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">xyz</span></span> = <span class="hljs-comment"><span class="hljs-comment">-- 10000  </span></span></code> </pre> <br><p>  Se voc√™ n√£o estiver familiarizado com a sintaxe: esta √© a defini√ß√£o de uma fun√ß√£o <code>x</code> com os par√¢metros <code>y</code> e <code>z</code> .  No Haskell, voc√™ pode omitir tipos, pois eles ser√£o deduzidos da implementa√ß√£o - a menos que, √© claro, voc√™ use diferentes recursos avan√ßados de extens√µes modernas do sistema de tipos -. </p><br><p>  Pode parecer que isso n√£o √© muito diferente da vers√£o do Python, mas apenas porque escrevemos nossa fun√ß√£o no Haskell e ela √© lado a lado, j√° podemos falar sobre algumas propriedades interessantes. </p><br><p>  <strong>An√°lise</strong> </p><br><p>  Obviamente, n√£o podemos tirar muitas conclus√µes aqui, mas aqui est√£o alguns pontos a serem observados: </p><br><ul><li>  <strong>A documenta√ß√£o</strong> <br><ul><li>  Know Conhecemos o comportamento esperado </li></ul></li><li>  <strong>Erros comuns</strong> <br><ul><li>  ‚úì <strong>Sem erros de digita√ß√£o ou nomes incorretos</strong> <br>  Como Haskell √© uma linguagem compilada, todos os nomes devem ser resolvidos no momento da compila√ß√£o.  O programa simplesmente n√£o ser√° compilado se houver esse erro. </li><li>  ‚úì <strong>Nenhum <code>null</code> inesperado</strong> <br>  Haskell simplesmente n√£o possui <code>null</code> .  O problema est√° resolvido! </li></ul></li><li>  <strong>Garantias</strong> <br><ul><li>  ‚úì Seguran√ßa de mem√≥ria </li><li>  ‚úì <strong>A fun√ß√£o n√£o pode ser chamada com o tipo errado</strong> </li><li>  ‚úì <strong>Sem efeitos colaterais <em>inesperados</em></strong> <br>  ‚ü¶O autor do artigo original n√£o indicou esse item, mas permitirei observar que, se houver efeitos colaterais, o tipo deduzido dessa fun√ß√£o indicar√° sua presen√ßa, para que o c√≥digo de chamada saiba sobre seus recursos.‚üß </li></ul></li></ul><br><h2>  Especifica√ß√£o do tipo Haskell </h2><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> :: <span class="hljs-type"><span class="hljs-type">Eq</span></span> a =&gt; [a] -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> xyz = <span class="hljs-comment"><span class="hljs-comment">-- ...</span></span></code> </pre> <br><p>  Anteriormente, conversamos sobre uma atitude bastante conivente com a seguran√ßa das av√≥s: ficou claro pelos testes que a fun√ß√£o n√£o iria prejudicar ningu√©m, mas <em>a</em> av√≥ <em>estava realmente</em> segura?  Essa fun√ß√£o n√£o envia com precis√£o palavr√µes? </p><br><p>  Haskell √© conhecido por ser uma linguagem funcional pura.  Isso n√£o significa que o c√≥digo n√£o pode ter efeitos colaterais, mas todos os efeitos colaterais devem estar presentes no tipo.  Conhecemos o tipo dessa fun√ß√£o, vemos que ela est√° limpa e, portanto, temos certeza de que essa fun√ß√£o n√£o modifica nenhum estado externo. </p><br><p>  Esta √© uma propriedade muito interessante por outros motivos: como sabemos que n√£o h√° efeitos colaterais, podemos entender o que essa fun√ß√£o faz, com base apenas em sua assinatura!  Basta pesquisar nesta assinatura do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Hoogle</a> e ver o primeiro resultado.  Obviamente, essa n√£o √© a √∫nica fun√ß√£o poss√≠vel que teria esse tipo, mas o tipo nos d√° confian√ßa suficiente para os fins da documenta√ß√£o. </p><br><p>  <strong>An√°lise</strong> </p><br><ul><li>  <strong>A documenta√ß√£o</strong> <br><ul><li>  ‚úì <strong>Conhecemos o comportamento esperado</strong> </li><li>  ‚úó Temos um exemplo de uso </li><li>  ‚úì Conhecemos algumas classes de valores que ser√£o processados ‚Äã‚Äãcorretamente </li><li>  ‚úì <strong>Conhecemos todos os tipos de valores que ser√£o processados ‚Äã‚Äãcorretamente</strong> </li></ul></li><li>  <strong>Especifica√ß√£o</strong> <br><ul><li>  ‚úó Funciona em pelo menos um caso. <br>  Com testes ou evid√™ncias ausentes, n√£o sabemos se nossa fun√ß√£o funciona como esperado! </li><li>  Index O √≠ndice retornado √© sempre um √≠ndice v√°lido. </li><li>  Index O √≠ndice retornado sempre indica um valor adequado. </li><li>  Item Um item ausente sempre retorna <code>None</code> / <code>Nothing</code> . </li></ul></li><li>  <strong>Erros comuns</strong> <br><ul><li>  ‚úì Sem erros de digita√ß√£o ou nomes incorretos </li><li>  ‚úì Nenhum <code>null</code> inesperado </li><li>  ‚úì <strong>Caso de erro √© sempre tratado</strong> <br>  Se nossa fun√ß√£o retornar <code>Nothing</code> , o sistema de tipos garantir√° que este caso seja tratado corretamente pelo c√≥digo de chamada.  Obviamente, esse caso pode ser ignorado, mas isso deve ser feito explicitamente. </li></ul></li><li>  <strong>Garantias</strong> <br><ul><li>  ‚úì Seguran√ßa de mem√≥ria </li><li>  ‚úì A fun√ß√£o n√£o pode ser chamada com o tipo errado </li><li>  ‚úì <strong>Sem efeitos colaterais</strong> </li><li>  ‚úó Sem exce√ß√µes <br>  Compartilho exce√ß√µes e erros, acreditando que ap√≥s as exce√ß√µes √© poss√≠vel recuperar e ap√≥s erros (por exemplo, fun√ß√µes parcialmente definidas) - n√£o. <br>  Na maioria das vezes, as exce√ß√µes s√£o descritas em tipos (por exemplo, na m√¥nada de E / S).  De uma maneira boa, devemos saber que uma fun√ß√£o n√£o gera uma exce√ß√£o, apenas com base em seu tipo.  No entanto, Haskell quebra essa expectativa ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">permitir que exce√ß√µes sejam lan√ßadas do c√≥digo puro</a> . <br>  Addition Al√©m disso, vale a pena notar que, em Haskell, erros como chamar incorretamente fun√ß√µes parcialmente definidas tamb√©m s√£o apresentados como exce√ß√µes que podem ser capturadas e processadas; portanto, a diferen√ßa entre as duas categorias √© um pouco menos √≥bvia. </li><li>  ‚úó Sem erros <br>  Ainda podemos usar fun√ß√µes parcialmente definidas, por exemplo, divis√£o por zero. </li><li>  ‚úó Sem ciclos perp√©tuos </li></ul></li></ul><br><h2>  Haskell com testes </h2><br><p>  Lembre-se, eu disse anteriormente que testes n√£o podem provar a aus√™ncia de erros?  Eu menti.  Quando as estrelas convergem corretamente e se os testes s√£o combinados com tipos, isso se torna poss√≠vel!  A primeira estrela √© a finitude do dom√≠nio de nossa fun√ß√£o.  O segundo - o dom√≠nio da defini√ß√£o deve ser n√£o apenas finito, mas tamb√©m n√£o muito grande; caso contr√°rio, esse teste ser√° dif√≠cil de colocar em pr√°tica. </p><br><p>  Por exemplo: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">not</span></span> :: <span class="hljs-type"><span class="hljs-type">Bool</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> not x = ...</code> </pre> <br><p>  A entrada pode ser <code>True</code> ou <code>False</code> .  Basta testar essas duas op√ß√µes e aqui est√° o Santo Graal!  Sem exce√ß√µes, ciclos perp√©tuos, resultados incorretos, sem erros.  No entanto, para uma fun√ß√£o um pouco mais complexa, pode n√£o estar claro quanto tempo √© dedicado aos testes: se eles levam muito tempo para serem conclu√≠dos, terminamos em um ciclo eterno, ou √© apenas pesado?  O problema de impedi-la. </p><br><p>  De fato, isso tamb√©m n√£o √© inteiramente verdade no caso de Haskell: em cada tipo de Haskell tamb√©m h√° um valor ‚ä• (que pode ser obtido como <code>undefined</code> , <code>error</code> ou <code>error</code> em certo sentido, como recurs√£o infinita), mas os haskellistas tradicionalmente fecham os olhos e acreditam que isso n√£o existe. </p><br><p>  Leitura extracurricular: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Existem apenas quatro bilh√µes de carros aleg√≥ricos - ent√£o teste todos!</a> </p><br><p>  De qualquer forma, em nosso exemplo original, o escopo √© infinito; portanto, os testes podem mostrar apenas que nosso c√≥digo funciona para um conjunto finito de exemplos. </p><br><p>  <strong>An√°lise</strong> <br>  Nesse caso, os testes complementam os tipos e tamponam alguns orif√≠cios no sistema do tipo Haskell.  Temos muito mais confian√ßa em nosso c√≥digo em compara√ß√£o ao uso apenas de testes ou tipos. </p><br><h2>  C </h2><br><pre> <code class="plaintext hljs">/* C    ,    int */ int x(int *y, size_t n, int z) { /* 10000    */ }</code> </pre> <br><p>  Consideramos C fora de interesse em sistemas do tipo mais antigo.  Em C, em particular, os tipos provavelmente n√£o s√£o necess√°rios pelo programador, mas pelo compilador para ajud√°-lo a gerar c√≥digo mais r√°pido. </p><br><p>  Em nosso exemplo, n√£o sabemos o que a fun√ß√£o retornar√° se o elemento n√£o for encontrado.  Teremos que confiar na tradi√ß√£o ou na documenta√ß√£o (por exemplo, neste caso, pode ser <code>-1</code> ). </p><br><p>  Tamb√©m podemos usar argumentos: dessa forma, podemos retornar um erro e armazenar o valor de retorno nesse argumento de sa√≠da.  Essa √© uma op√ß√£o um pouco mais expressiva, mas ainda precisamos confiar na documenta√ß√£o para entender quais par√¢metros s√£o lidos e quais s√£o escritos.  Nos dois casos, √© dif√≠cil entender o comportamento observando os tipos. </p><br><pre> <code class="plaintext hljs">/*   ,   out- */ error_t x(int *y, size_t n, int z, size_t *w) { /* 10000    */ }</code> </pre> <br><p>  <strong>An√°lise</strong> <br>  O sistema de tipos em si n√£o nos oferece tantas garantias.  Obviamente, obtemos algumas informa√ß√µes desses tipos, mas basta compar√°-las com o caso Haskell. </p><br><h2>  Idris </h2><br><pre> <code class="plaintext hljs">x : Eq x =&gt; List x -&gt; x -&gt; Maybe Int xyz = ...</code> </pre> <br><p>  Esta fun√ß√£o √© do mesmo tipo que no caso de Haskell.  No entanto, com um sistema de tipo mais expressivo, podemos obter mais.  A escolha dos tipos pode falar sobre a implementa√ß√£o. </p><br><pre> <code class="plaintext hljs">%default total x : Eq x =&gt; Vect nx -&gt; x -&gt; Maybe (Fin n) xyz = ...</code> </pre> <br><p>  Esse tipo pode ser lido como "me d√™ uma lista de tamanho <code>n</code> e algum valor, e retornarei um n√∫mero menor que <code>n</code> ou <code>Nothing</code> ".  Isso garante que a fun√ß√£o retorne um √≠ndice que obviamente n√£o excede os limites. </p><br><p>  Al√©m disso, esta fun√ß√£o √© total, ou seja, o temporizador verificou se sempre termina.  Isso elimina ciclos e erros perp√©tuos. </p><br><p>  <strong>An√°lise</strong> </p><br><ul><li>  <strong>Especifica√ß√£o</strong> <br><ul><li>  ‚úó Funciona em pelo menos um caso. </li><li>  ‚úì O <strong>√≠ndice retornado √© sempre o √≠ndice correto</strong> </li><li>  Index O √≠ndice retornado sempre indica um valor adequado </li><li>  Item O item ausente sempre retorna <code>None</code> / <code>Nothing</code> </li></ul></li><li>  <strong>Garantias</strong> <br><ul><li>  ‚úì Seguran√ßa de mem√≥ria </li><li>  ‚úì A fun√ß√£o n√£o pode ser chamada com o tipo errado </li><li>  ‚úì Sem efeitos colaterais </li><li>  ‚úó Sem exce√ß√µes </li><li>  ‚úì <strong>Sem erros</strong> </li><li>  ‚úì <strong>Sem ciclos perp√©tuos</strong> </li></ul></li></ul><br><h2>  Idris com testes </h2><br><p>  Como a linguagem de tipo de Idris √© t√£o expressiva quanto a linguagem de seus termos ‚ü¶(ou melhor, sua parte comprovadamente total)‚üß, a distin√ß√£o entre teste e tipo fica emba√ßada: </p><br><pre> <code class="plaintext hljs">ex : x [1, 2, 3] 2 = Just 1 ex = Refl</code> </pre> <br><p>  Essa fun√ß√£o possui um tipo bastante estranho <code>x [1, 2, 3] 2 = Just 1</code> .  Esse tipo significa que, para uma verifica√ß√£o bem-sucedida do tipo, o typer deve provar que <code>x [1, 2, 3] 2</code> estruturalmente igual a <code>Just 1</code> .  ‚ü¶Neste caso, a prova √© trivial, pois basta o basculante normalizar os termos nos dois lados do sinal de igual, o que ser√° feito em tempo finito devido √† totalidade de todas as fun√ß√µes utilizadas e que levar√° a um resultado √∫nico devido a Church-Rosser.  Depois disso, pode-se usar a reflexividade da igualdade, que √© o que <code>Refl</code> . </p><br><p>  De fato, escrevemos um teste de n√≠vel de tipo. </p><br><h2>  Idris com evid√™ncia </h2><br><p>  Para uma an√°lise completa, podemos usar todo o poder dos tipos dependentes e <em>provar</em> nossa implementa√ß√£o (j√° que os tipos dependentes no Idris s√£o equivalentes a um sistema l√≥gico que inclui l√≥gica construtiva de primeira ordem). </p><br><p>  Em particular, podemos provar propriedades que antes eram inating√≠veis para n√≥s: </p><br><pre> <code class="plaintext hljs">--      Eq  DecEq x : DecEq a =&gt; Vect na -&gt; (y : a) -&gt; Maybe (Fin n) xyz = ... --    ,       `x` findIndexOk : DecEq a =&gt; (y : Vect na) -&gt; (z : a) -&gt; case xyz of Just i =&gt; index iy = z Nothing =&gt; Not (Elem zy) findIndexOk yz = ...</code> </pre> <br><p>  O tipo <code>findIndexOk</code> pode ser lido como ‚Äúpara qualquer tipo <code>a</code> que tenha uma compara√ß√£o algoritmicamente decid√≠vel ( <code>DecEq</code> ), para qualquer vetor <code>y</code> elementos do tipo <code>a</code> qualquer comprimento <code>n</code> e qualquer valor <code>z</code> tipo <code>a</code> : se <code>xyz</code> retornar o √≠ndice <code>i</code> , esse √≠ndice est√° <code>z</code> , mas se <code>xyz</code> retorna <code>Nothing</code> , ent√£o n√£o existe esse elemento no vetor. ‚Äù </p><br><p>  Is √â interessante que o autor do artigo original ofere√ßa um tipo um pouco mais fraco que o indicado acima.‚üß </p><br><p>  Agora temos tudo capturado!  Quais s√£o as desvantagens?  Bem, escrever todas essas evid√™ncias pode ser bastante dif√≠cil. </p><br><h2>  Compara√ß√£o </h2><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Python </th><th>  Python <br>  testes </th><th>  Haskell </th><th>  Haskell <br>  tipos </th><th>  Haskell <br>  tipos <br>  testes </th><th>  Idris </th><th>  Idris <br>  testes </th><th>  Idris <br>  provas </th></tr><tr><th>  A documenta√ß√£o </th></tr><tr><td>  Conhecemos o comportamento esperado </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  H√° um exemplo de uso </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Conhecemos alguns tipos de valores adequados. </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Conhecemos todos os tipos de valores adequados. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><th>  Especifica√ß√£o </th></tr><tr><td>  Funciona em pelo menos um caso </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  O √≠ndice retornado √© sempre v√°lido. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  O √≠ndice retornado √© sempre v√°lido. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td></tr><tr><td>  O elemento ausente fornece `None` /` Nothing` </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td></tr><tr><th>  Erros comuns </th></tr><tr><td>  Sem erros de digita√ß√£o ou nomes incorretos </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Nenhum `null` repentino </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  O caso de erro √© sempre tratado. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><th>  Garantias </th></tr><tr><td>  Seguran√ßa de mem√≥ria </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  N√£o pode ser chamado com o tipo errado. </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sem efeitos colaterais </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sem exce√ß√µes </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sem erros </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr><tr><td>  Sem ciclos perp√©tuos </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úó </td><td>  ‚úì </td><td>  ‚úì </td><td>  ‚úì </td></tr></tbody></table></div><br><h2>  Parecer </h2><br><p>  Na minha opini√£o, o uso de um sistema de tipo moderno em si √© mais eficaz em termos de relacionamento das informa√ß√µes recebidas e garantias aos esfor√ßos despendidos.  Se voc√™ deseja escrever um c√≥digo razoavelmente confi√°vel, os tipos podem ser temperados com testes.  Idealmente - no estilo do QuickCheck. </p><br><p>  Com tipos dependentes, a linha entre testes e tipos se torna menos √≥bvia.  Se voc√™ estiver escrevendo um software para a Boeing ou para marca-passos, pode ser √∫til escrever evid√™ncias. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467677/">https://habr.com/ru/post/pt467677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467667/index.html">Planejamento de projeto da organiza√ß√£o (parte 4)</a></li>
<li><a href="../pt467669/index.html">Assista-me na √≠ntegra: tire o m√°ximo proveito do v√≠deo ao vivo em plataformas m√≥veis</a></li>
<li><a href="../pt467671/index.html">Computador retro NLX</a></li>
<li><a href="../pt467673/index.html">Recursos de Go incorporados</a></li>
<li><a href="../pt467675/index.html">Modelando o estado do aplicativo usando objetos Store no SwiftUI</a></li>
<li><a href="../pt467679/index.html">PyCrunch - Execu√ß√£o de teste inteligente e cobertura de c√≥digo visual no IDE</a></li>
<li><a href="../pt467681/index.html">Vulnerabilidade de desvios de roteamento SOAP</a></li>
<li><a href="../pt467683/index.html">Tentando compor os esquemas de encaixe n√£o compos√≠veis:</a></li>
<li><a href="../pt467689/index.html">Uma pequena vis√£o geral do SIMD no .NET / C #</a></li>
<li><a href="../pt467691/index.html">Intel Nervana NNP-T e NNP-I - chips especializados para IA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>