<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶Ä üîÜ üé¶ Trabalhando com imagens em Python üõ¥ üïµüèª ‚ôèÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O t√≥pico da conversa de hoje √© o que o Python aprendeu ao longo de todos os anos de sua exist√™ncia no trabalho com imagens. De fato, al√©m dos antigos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Trabalhando com imagens em Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/425471/">  O t√≥pico da conversa de hoje √© o que o Python aprendeu ao longo de todos os anos de sua exist√™ncia no trabalho com imagens.  De fato, al√©m dos antigos de ImageMagick e GraphicsMagick de 1990, existem modernas bibliotecas eficazes.  Por exemplo, Pillow e Pillow-SIMD mais produtivo.  O desenvolvedor ativo Alexander Karpinsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">homm</a> ) da MoscowPython comparou diferentes bibliotecas para trabalhar com imagens em Python, apresentou benchmarks e falou sobre recursos n√£o √≥bvios que sempre s√£o suficientes.  Neste artigo, uma transcri√ß√£o do relat√≥rio ajudar√° voc√™ a escolher uma biblioteca para o seu aplicativo e a faz√™-lo funcionar da maneira mais eficiente poss√≠vel. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CZ99Q0DQq3Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Sobre o palestrante:</strong> Alexander Karpinsky trabalha na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uploadcare</a> e est√° envolvido no servi√ßo de r√°pida modifica√ß√£o de imagem em tempo real.  Ele est√° envolvido no desenvolvimento do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pillow</a> , uma biblioteca popular para trabalhar com imagens em Python, e est√° desenvolvendo seu pr√≥prio fork dessa biblioteca, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pillow-SIMD</a> , que usa instru√ß√µes modernas do processador para obter o m√°ximo desempenho. <br><a name="habracut"></a><br><h2>  Antecedentes <br></h2><br>  O servi√ßo de modifica√ß√£o de imagem do Uploadcare √© um servidor que recebe uma solicita√ß√£o HTTP com um identificador de imagem e algumas opera√ß√µes que um cliente precisa executar.  O servidor deve concluir as opera√ß√µes e responder o mais r√°pido poss√≠vel.  O cliente costuma atuar como um navegador. <br><br>  Todo o servi√ßo pode ser descrito como um inv√≥lucro em torno da biblioteca de gr√°ficos.  A qualidade de todo o projeto depende da qualidade, desempenho e usabilidade da biblioteca de gr√°ficos.  √â f√°cil adivinhar que o Uploadcare usa Pillow como uma biblioteca de gr√°ficos. <br><br><h2>  Bibliotecas <br></h2><br>  Analisaremos brevemente que tipo de bibliotecas gr√°ficas geralmente existem no Python para entender melhor o que ser√° discutido mais adiante. <br><br><h3>  Travesseiro <br></h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Travesseiro</a> - garfo do PIL (Python Imaging Library).  Este √© um projeto muito antigo, lan√ßado em 1995 para o Python 1.2.  Voc√™ pode imaginar quantos anos ele tem!  Em algum momento, a Python Imaging Library foi abandonada e seu desenvolvimento foi interrompido.  Um garfo do Pillow foi criado para instalar e construir a Python Imaging Library em sistemas modernos.  Gradualmente, o n√∫mero de mudan√ßas necess√°rias para as pessoas na Biblioteca de Imagens Python aumentou e o Pillow 2.0 foi lan√ßado, o que adicionou suporte ao Python 3. Isso pode ser considerado o come√ßo de uma vida separada do projeto Pillow. <br><br>  Pillow √© um m√≥dulo nativo para Python, metade do c√≥digo √© escrito em C, metade em Python.  As vers√µes mais diversas do Python s√£o suportadas: 2.7, 3.3+, PYP, . <br><br><h3>  Travesseiro-SIMD <br></h3><br>  Este √© o meu garfo do Pillow, lan√ßado em maio de 2016.  SIMD significa Instru√ß√£o √önica, V√°rios Dados <strong>&nbsp;</strong>  - Uma abordagem na qual o processador pode executar um n√∫mero maior de a√ß√µes por ciclo usando instru√ß√µes modernas. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pillow-SIMD</a> n√£o √© um garfo no sentido cl√°ssico quando um projeto come√ßa a viver sua pr√≥pria vida.  Esta √© uma substitui√ß√£o do Pillow, ou seja, voc√™ instala uma biblioteca em vez de outra, n√£o altera uma linha no seu c√≥digo-fonte e obt√©m mais desempenho. <br><br>  Pillow-SIMD pode ser montado com instru√ß√µes SSE4 (padr√£o).  Este √© um conjunto de instru√ß√µes encontradas em quase todos os processadores x86 modernos.  O PillD-SIMD tamb√©m pode ser montado com o conjunto de instru√ß√µes AVX2.  Este conjunto de instru√ß√µes √©, come√ßando com a arquitetura Haswell, ou seja, aproximadamente a partir de 2013. <br><br><h3>  Opencv <br></h3><br>  Outra biblioteca para trabalhar com imagens em Python que voc√™ provavelmente j√° ouviu falar √© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenCV</a> (Open Computer Vision).  Trabalha desde 2000.  A liga√ß√£o Python est√° inclu√≠da.  Isso significa que a encaderna√ß√£o √© constantemente relevante, n√£o h√° sincronicidade entre a pr√≥pria biblioteca e a encaderna√ß√£o. <br><br>  Infelizmente, essa biblioteca ainda n√£o √© suportada no PyPy, porque o OpenCV √© baseado em numpy e o numpy s√≥ recentemente come√ßou a trabalhar no PyPy, e o PyC ainda n√£o suporta o OpenCV. <br><br><h3>  VIPS <br></h3><br>  Outra biblioteca que vale a pena prestar aten√ß√£o √© o VIPS.  A id√©ia principal do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VIPS</a> √© que voc√™ n√£o precisa carregar a imagem inteira na mem√≥ria para trabalhar com a imagem.  A biblioteca pode carregar alguns peda√ßos pequenos, process√°-los e salvar.  Portanto, para processar imagens de gigapixel, voc√™ n√£o precisa gastar gigabytes de mem√≥ria. <br><br>  Esta √© uma biblioteca bastante antiga - 1993, mas ultrapassou seu tempo.  Por um longo tempo, pouco se ouviu sobre isso, mas recentemente come√ßaram a aparecer os ligantes do VIPS para v√°rios idiomas, incluindo Go, Node.js e Ruby. <br><br>  Durante muito tempo, quis experimentar esta biblioteca, senti-la, mas n√£o tive sucesso por uma raz√£o muito est√∫pida.  N√£o consegui descobrir como instalar o VIPS, porque a liga√ß√£o era muito complicada.  Mas agora (em 2017) o pyvips binding foi liberado pelo pr√≥prio autor do VIPS, com o qual n√£o h√° mais problemas.  Instalar e usar o VIPS agora √© muito f√°cil.  Suportado: Python 2.7, 3.3+, RuPu, RuPuZ. <br><br><h3>  ImageMagick e Gr√°ficosMagick <br></h3><br>  Se falamos em trabalhar com gr√°ficos, n√£o podemos deixar de mencionar os idosos - bibliotecas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ImageMagick</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GraphicsMagick</a> .  Este √∫ltimo era originalmente um fork do ImageMagick com maior desempenho, mas agora seu desempenho parece ser igual.  At√© onde eu sei, n√£o h√° outras diferen√ßas fundamentais entre eles.  Portanto, voc√™ pode usar qualquer um, mais precisamente, aquele que preferir. <br><br>  Estas s√£o as bibliotecas mais antigas que mencionei hoje (1990).  Durante todo esse tempo, houve v√°rios fich√°rios para o Python, e quase todos eles morreram com seguran√ßa at√© agora.  Daqueles que podem ser usados, existem: <br><br><ul><li>  Associa√ß√£o de varinha, que √© criada em ctypes, mas tamb√©m n√£o √© mais atualizada. </li><li>  A liga√ß√£o pgmagick usa Boost.Python, portanto, compila por um per√≠odo muito longo e n√£o funciona no PyPy.  Mas, no entanto, voc√™ pode us√°-lo, eu diria que √© prefer√≠vel ao Wand. </li></ul><br><h2>  Desempenho <br></h2><br>  Quando falamos em trabalhar com imagens, a primeira coisa que nos interessa (pelo menos para mim) √© o desempenho, porque, caso contr√°rio, poder√≠amos escrever algo em Python com as m√£os. <br><br>  O desempenho n√£o √© uma coisa t√£o simples.  Voc√™ n√£o pode simplesmente dizer que uma biblioteca √© mais r√°pida que outra.  Cada biblioteca possui um conjunto de fun√ß√µes e cada fun√ß√£o funciona em uma velocidade diferente. <br><br>  Portanto, √© correto dizer apenas que o desempenho de uma fun√ß√£o √© maior ou menor em uma biblioteca espec√≠fica.  Ou voc√™ tem um aplicativo que precisa de um certo conjunto de funcionalidades e faz uma refer√™ncia espec√≠fica para essa funcionalidade e diz que essa e essa biblioteca funciona mais r√°pido (mais lentamente) para o seu aplicativo. <br><br><h3>  √â importante verificar o resultado. <br></h3><br>  Quando voc√™ faz benchmarks, √© muito importante observar o resultado obtido.  Mesmo que voc√™ tenha escrito o mesmo c√≥digo √† primeira vista, isso n√£o significa que √© o mesmo. <br><br>  Recentemente, em um artigo comparando o desempenho do Pillow e do OpenCV, deparei-me com este c√≥digo: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFilter.BoxBlur im.filter(ImageFilter.BoxBlur(<span class="hljs-number"><span class="hljs-number">3</span></span>)) ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 cv2.blur(im, ksize=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) ...</code> </pre> <br>  Parece estar l√°, e ali, BoxBlur, e ali, e ali, argumento 3, mas na verdade o resultado √© diferente.  Porque no Pillow (3) esse √© o raio de desfoque e no OpenCV ksize = (3, 3) √© o tamanho do kernel, ou seja, o di√¢metro.  Nesse caso, o valor correto para o OpenCV seria 3 * 2 + 1, ou seja, (7, 7). <br><br><h3>  Qual √© o problema? <br></h3><br>  Por que o desempenho geralmente √© um problema ao trabalhar com gr√°ficos?  Como a complexidade de qualquer opera√ß√£o depende de v√°rios par√¢metros e, na maioria das vezes, a complexidade cresce linearmente com cada um deles.  E se, por exemplo, existem tr√™s desses fatores, e a complexidade depende linearmente de cada um, obtemos complexidade em um cubo. <br><br>  <strong>Exemplo:</strong> Desfoque Gaussiano no OpenCV. <br><br><img src="https://habrastorage.org/webt/q5/ea/ut/q5eaut_epivf3abcoh34rdmjsgg.jpeg"><br><br>  √Ä esquerda, h√° um raio de 3, √† direita, 30. Como voc√™ pode ver, a diferen√ßa de velocidade √© mais de 10 vezes. <br><br>  Quando me deparei com a tarefa de adicionar desfoque gaussiano ao meu aplicativo, n√£o fiquei feliz por, hipoteticamente, 900 ms poderem ser gastos em uma opera√ß√£o.  Existem milhares de opera√ß√µes desse tipo por minuto no aplicativo, e gastar tanto tempo com um deles √© impratic√°vel.  Portanto, estudei a quest√£o e implementei o borr√£o gaussiano no Pillow, que funciona em tempo constante em rela√ß√£o ao raio.  Ou seja, apenas o tamanho da imagem afeta o desempenho do desfoque gaussiano. <br><br>  Mas o principal aqui n√£o √© que algo funcione mais r√°pido ou mais devagar. <br><br><blockquote>  Quero transmitir que, quando voc√™ est√° construindo algum tipo de sistema, √© importante entender de quais par√¢metros depende a complexidade da sa√≠da.  Em seguida, voc√™ pode limitar esses par√¢metros ou de outras maneiras para lidar com essa complexidade. <br></blockquote><br>  Provavelmente, a opera√ß√£o mais comum que fazemos com as imagens depois que elas s√£o abertas √© o redimensionamento. <br><br><img src="https://habrastorage.org/webt/ij/-6/xi/ij-6xiharsev-2a89wlcnvun6b0.jpeg"><br><br>  O gr√°fico mostra o desempenho (mais √© melhor) de diferentes bibliotecas para a opera√ß√£o de reduzir a imagem em 8 e 1,25 vezes. <br><br>  Para PIL, um resultado de 17 Mpx / s significa que a foto de um iPhone (12 Mpx) pode ser reduzida 1,25 vezes um pouco em menos de um segundo.  Esse desempenho n√£o √© suficiente para um aplicativo s√©rio que executa muitas dessas opera√ß√µes. <br><br>  Comecei a otimizar o desempenho do redimensionamento e, no Pillow 2.7, consegui um aumento duplo na produtividade e no Pillow 4.3 - tr√™s vezes (a vers√£o do Pillow 5.3 √© atualmente relevante, mas o desempenho de redimensionamento √© o mesmo). <br><br>  Mas a opera√ß√£o de redimensionamento √© algo que se encaixa muito bem no SIMD.  Ele aborda instru√ß√µes √∫nicas, v√°rios dados e, portanto, na vers√£o atual do Pillow-SIMD, eu fui capaz <strong>de aumentar a velocidade de redimensionamento em 19 vezes em</strong> compara√ß√£o com a Python Imaging Library original, usando os mesmos recursos. <br><br>  Isso √© significativamente maior que o desempenho de redimensionamento do OpenCV.  Mas a compara√ß√£o n√£o est√° totalmente correta, porque o OpenCV usa um m√©todo de redimensionamento um pouco menos de alta qualidade com um filtro de caixa e, no Pillow-SIMD, o redimensionamento √© implementado usando convolu√ß√µes. <br><br>  Esta √© uma lista incompleta daquelas opera√ß√µes que s√£o aceleradas no Pillow-SIMD em compara√ß√£o com o Pillow normal. <br><br><ul><li>  Redimensionar: 4 a 7 vezes. </li><li>  Desfoque: 2,8 vezes. </li><li>  Aplica√ß√£o do n√∫cleo 3 √ó 3 ou 5 √ó 5: 11 vezes. </li><li>  Multiplica√ß√£o e divis√£o por canal alfa: 4 e 10 vezes. </li><li>  Composi√ß√£o alfa: 5 vezes. </li></ul><br>  Eu j√° disse que n√£o se pode dizer que uma biblioteca funciona mais rapidamente que outra, mas voc√™ pode criar um conjunto de opera√ß√µes que seja do seu interesse.  Eu escolhi um conjunto de opera√ß√µes que s√£o interessantes na minha aplica√ß√£o, fiz uma refer√™ncia e obtive esses resultados. <br><br><img src="https://habrastorage.org/webt/it/_h/hq/it_hhqosz-vm69bg_o8tt8ajddm.jpeg"><br><br>  Descobriu-se que o Pillow-SIMD neste conjunto funciona 2 vezes mais r√°pido que o Pillow.  No final est√° Wand (lembre-se de que √© o ImageMagick). <br><br>  Mas eu estava interessado em outra coisa - por que o OpenCV e o VIPS s√£o t√£o pobres em resultados, porque essas s√£o bibliotecas que tamb√©m s√£o projetadas com o objetivo de desempenho?  Verificou-se que, no caso do OpenCV, o assembly bin√°rio do OpenCV instalado usando o pip foi montado com um codec JPEG lento (o autor do assembly foi notificado, esse problema j√° foi resolvido para 2018).  Ele √© constru√≠do com libjpeg, enquanto a maioria dos sistemas, pelo menos com base em debian, usa libjpeg-turbo, que √© v√°rias vezes mais r√°pido.  Se voc√™ mesmo criar o OpenCV a partir da fonte, o desempenho ser√° maior. <br><br>  No caso do VIPS, a situa√ß√£o √© diferente.  Entrei em contato com o autor do VIPS, mostrei a ele essa refer√™ncia e nos correspondemos por muito tempo e proveitosamente.  Depois disso, o autor do VIPS encontrou v√°rios locais no pr√≥prio VIPS, onde a execu√ß√£o n√£o estava na rota ideal, e os corrigiu. <br><br>  √â o que acontecer√° com o desempenho se voc√™ criar o OpenCV a partir das fontes da vers√£o atual e o VIPS do master, que j√° est√° l√°. <br><br><img src="https://habrastorage.org/webt/m2/kg/o8/m2kgo8agnblbu9tsc5nw5fonyfk.jpeg"><br><blockquote>  Mesmo se voc√™ encontrar algum tipo de refer√™ncia, n√£o √© fato que tudo funcionar√° com essa velocidade exatamente na sua m√°quina. <br></blockquote><br><h3>  Conjunto de benchmarks <br></h3><br>  Todos os benchmarks de que falei podem ser encontrados na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√°gina de resultados</a> .  Este √© um mini-projeto separado, onde escrevo benchmarks que eu pr√≥prio preciso desenvolver Pillow-SIMD, execut√°-los e publicar os resultados. <br><br>  O GitHub tem um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto</a> com estruturas de teste onde todos podem oferecer seus pr√≥prios benchmarks ou corrigir os existentes. <br><br><h2>  Trabalho paralelo <br></h2><br>  At√© agora, tenho falado sobre desempenho puro, isto √©, em um √∫nico n√∫cleo de processador.  Mas todos n√≥s h√° muito tempo temos acesso a sistemas com mais n√∫cleos, e eu gostaria de descart√°-los.  Aqui, devo dizer que, de fato, o Pillow √© a √∫nica biblioteca de tudo o que n√£o usa paraleliza√ß√£o de tarefas.  Vou tentar explicar por que isso acontece.  Todas as outras bibliotecas de uma forma ou de outra a usam. <br><br><h3>  M√©tricas de desempenho <br></h3><br>  Em termos de desempenho, estamos interessados ‚Äã‚Äãem 2 par√¢metros: <br><br><ol><li>  <strong>Tempo real de execu√ß√£o de uma opera√ß√£o.</strong>  Existe uma opera√ß√£o (ou uma sequ√™ncia de opera√ß√µes) e voc√™ est√° se perguntando a que tempo (rel√≥gio de parede) essa sequ√™ncia ser√° executada.  Este par√¢metro √© importante na √°rea de trabalho, onde h√° um usu√°rio que deu o comando e est√° aguardando o resultado. <br></li><li>  <strong>Taxa de transfer√™ncia de todo o sistema</strong> (fluxo de trabalho).  Quando voc√™ tem um conjunto de opera√ß√µes em andamento, ou muitas opera√ß√µes independentes, e a velocidade de processamento dessas opera√ß√µes no seu hardware √© importante para voc√™.  Essa m√©trica √© mais importante em um servidor em que existem muitos clientes e voc√™ precisa atend√™-los a todos.  O tempo que leva para atender um cliente √© importante, √© claro, mas um pouco menos que a largura de banda total. <br></li></ol><br>  Com base nessas duas m√©tricas, consideramos diferentes formas de opera√ß√£o paralela. <br><br><h3>  M√©todos de trabalho paralelo <br></h3><br>  1. <strong>No n√≠vel do aplicativo</strong> , quando voc√™ decide no n√≠vel do aplicativo que as opera√ß√µes s√£o processadas em diferentes segmentos.  Ao mesmo tempo, o tempo real de execu√ß√£o de uma opera√ß√£o n√£o muda, porque, como antes, um n√∫cleo est√° envolvido em uma sequ√™ncia de opera√ß√µes.  A taxa de transfer√™ncia do sistema cresce proporcionalmente ao n√∫mero de n√∫cleos, ou seja, muito bom. <br><br>  2. <strong>No n√≠vel das opera√ß√µes gr√°ficas</strong> - √© exatamente isso que ocorre na maioria das bibliotecas gr√°ficas.  Quando uma biblioteca gr√°fica recebe algum tipo de opera√ß√£o, ela cria o n√∫mero necess√°rio de threads em si mesma, divide uma opera√ß√£o em v√°rias menores e as executa.  Ao mesmo tempo, o tempo real de execu√ß√£o √© reduzido - uma opera√ß√£o √© mais r√°pida.  Mas a <strong>taxa de transfer√™ncia n√£o cresce linearmente</strong> com o n√∫mero de n√∫cleos.  Existem opera√ß√µes que n√£o s√£o paralelas, e um exemplo impressionante √© a decodifica√ß√£o de arquivos PNG - ela n√£o pode ser paralelada de forma alguma.  Al√©m disso, existe uma sobrecarga para a cria√ß√£o de threads, dividindo tarefas, que tamb√©m n√£o permitem que a largura de banda cres√ßa linearmente. <br><br>  3. <strong>No n√≠vel dos comandos e dados do processador</strong> .  Preparamos os dados de uma maneira especial e usamos comandos especiais para acelerar o processador com eles.  Essa √© a abordagem SIMD, que, de fato, √© usada no Pillow-SIMD.  O tempo de execu√ß√£o em tempo real est√° diminuindo, o rendimento est√° aumentando - <strong>esta</strong> √© <strong>uma op√ß√£o ganha-ganha</strong> . <br><br><h3>  Como combinar trabalho paralelo <br></h3><br>  Se queremos combinar um trabalho paralelo, o SIMD funciona bem com a paraleliza√ß√£o dentro de uma opera√ß√£o e o SIMD funciona bem com a paraleliza√ß√£o dentro de um aplicativo. <br><img src="https://habrastorage.org/webt/3z/pa/lo/3zpaloqfeh6cczwlz8zlk5s33lc.jpeg"><br>  Mas a paraleliza√ß√£o dentro do aplicativo e dentro da opera√ß√£o n√£o √© compat√≠vel entre si.  Se voc√™ tentar fazer isso, obter√° contras de ambas as abordagens.  O tempo real da opera√ß√£o ser√° o mesmo de um n√∫cleo, e a taxa de transfer√™ncia do sistema aumentar√°, mas n√£o linearmente em rela√ß√£o ao n√∫mero de n√∫cleos. <br><br><h3>  Multithreading <br></h3><br>  Se estamos falando de threads, todos escrevemos em Python e sabemos que ele possui um GIL que impede a execu√ß√£o de dois threads ao mesmo tempo.  Python √© uma linguagem estritamente de thread √∫nico. <br><br>  Obviamente, isso n√£o √© verdade, porque o GIL na verdade impede a execu√ß√£o de dois threads no Python, e se o c√≥digo for escrito em outra linguagem e n√£o usar estruturas internas do Python durante sua opera√ß√£o, esse c√≥digo poder√° liberar o GIL e, assim, liberar o int√©rprete. para outras tarefas. <br><br>  Muitas bibliotecas gr√°ficas lan√ßam o GIL durante seu trabalho, incluindo Pillow, OpenCV, pyvips, Wand.  Apenas um pgmagick n√£o libera.  Ou seja, voc√™ pode criar threads com seguran√ßa para executar algumas opera√ß√µes, e isso funcionar√° em paralelo com o restante do c√≥digo. <br><br>  Mas surge a pergunta: <strong>quantos threads criar?</strong> <br><br>  Se criarmos um n√∫mero infinito de threads para cada tarefa que temos, eles simplesmente ocupar√£o toda a mem√≥ria e todo o processador - n√£o obteremos nenhum trabalho efetivo.  Eu formulei uma regra especial. <br><br><blockquote>  <strong>Regra N + 1</strong> <br><br>  Para um trabalho produtivo, voc√™ precisa criar n√£o mais que N + 1 trabalhadores, em que N √© o n√∫mero de n√∫cleos ou threads de processador na m√°quina e o trabalhador √© o processo ou thread envolvido no processamento. <br></blockquote><br>  Os processos s√£o mais bem utilizados, porque mesmo dentro do mesmo int√©rprete h√° gargalos e sobrecarga. <br><br>  Por exemplo, em nossa aplica√ß√£o, √© usada a inst√¢ncia N + 1 Tornado, cujo equil√≠brio √© realizado pelo ngnix.  Se o Tornado for mencionado, vamos falar sobre opera√ß√£o ass√≠ncrona. <br><br><h2>  Opera√ß√£o ass√≠ncrona <br></h2><br>  O tempo em que a biblioteca gr√°fica realiza um trabalho realmente √∫til - processamento de imagem - pode e deve ser usado para entrada / sa√≠da, se voc√™ os tiver no aplicativo.  Estruturas ass√≠ncronas s√£o muito relevantes aqui. <br><br>  Mas h√° um problema - quando chamamos algum tipo de processamento, ele √© chamado de forma s√≠ncrona.  Mesmo que a biblioteca libere o GIL naquele momento, o loop de eventos ainda est√° bloqueado. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.coroutine def get(self, *args, **kwargs): im = process_image(...) ...</span></span></code> </pre><br>  Felizmente, esse problema √© muito f√°cil de resolver, criando um ThreadPoolExecutor com um √∫nico thread no qual o processamento da imagem √© iniciado.  Essa chamada j√° est√° acontecendo de forma ass√≠ncrona. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@run_on_executor(executor=ThreadPoolExecutor(1)) def process_image(self, ... @gen.coroutine def get(self, *args, **kwargs): im = yield process_image(...) ...</span></span></code> </pre><br>  Essencialmente, aqui √© criada uma fila com um trabalhador que executa opera√ß√µes gr√°ficas, e o Loop de Eventos n√£o √© bloqueado e silenciosamente √© executado em paralelo em outro encadeamento. <br><br><h2>  Entrada / sa√≠da <br></h2><br>  Outro t√≥pico que gostaria de abordar na discuss√£o de opera√ß√µes gr√°ficas √© entrada / sa√≠da.  O fato √© que raramente criamos qualquer tipo de imagem usando uma biblioteca de gr√°ficos.  Na maioria das vezes, abrimos imagens que chegam at√© n√≥s de usu√°rios na forma de arquivos codificados (JPEG, PNG, BMP, TIFF etc.). <br><br>  Assim, a biblioteca de gr√°ficos para criar um bom aplicativo deve ter alguns benef√≠cios para entrada / sa√≠da de arquivos. <br><br><h3>  Carregamento lento <br></h3><br>  O primeiro desses bolos √© o carregamento pregui√ßoso.  Se, por exemplo, no Pillow voc√™ abre uma imagem, nesse momento a decodifica√ß√£o da imagem n√£o ocorre.  Voc√™ retorna com um objeto que parece que a imagem j√° est√° carregada e funcionando.  Voc√™ pode examinar suas propriedades e decidir, com base nas propriedades desta imagem, se est√° pronto para continuar a trabalhar com ela, se o usu√°rio tiver baixado, por exemplo, uma imagem de gigapixel para interromper seu servi√ßo. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>))</code> </pre><br>  Se voc√™ decidir o que fazer em seguida, usando a chamada expl√≠cita ou impl√≠cita para carregar, essa imagem ser√° decodificada.  J√° neste momento a quantidade necess√°ria de mem√≥ria est√° alocada. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>)) &gt;&gt;&gt; %time im.load() Wall time: <span class="hljs-number"><span class="hljs-number">73.6</span></span> ms</code> </pre><br><h3>  Modo de imagem quebrada <br></h3><br>  O segundo item necess√°rio ao trabalhar com conte√∫do gerado pelo usu√°rio √© o modo de imagem interrompida.  Os arquivos que recebemos dos usu√°rios geralmente cont√™m algumas inconsist√™ncias com o formato em que s√£o codificados. <br><br>  Essas discrep√¢ncias ocorrem por v√°rios motivos.  √Äs vezes, esses s√£o erros de transmiss√£o na rede, √†s vezes, s√£o apenas algum tipo de codec torto que codifica a imagem.  Por padr√£o, Pillow, quando v√™ imagens que n√£o se ajustam ao formato at√© o fim, apenas lan√ßa uma exce√ß√£o. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>) IOError: image file <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> truncated (<span class="hljs-number"><span class="hljs-number">143</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> processed)</code> </pre><br>  Mas o usu√°rio n√£o √© o culpado pelo fato de sua imagem estar quebrada, ele ainda deseja obter o resultado.  Felizmente, o Pillow possui um modo de imagem quebrado.  Alteramos uma configura√ß√£o e o Pillow tenta ignorar ao m√°ximo todos os erros de decodifica√ß√£o que est√£o na imagem.  Assim, o usu√°rio v√™ pelo menos alguma coisa. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFile ImageFile.LOAD_TRUNCATED_IMAGES = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/cm/jq/ju/cmjqjuopb_ct8wqinkaaeaw0bbc.jpeg"><br><br>  Mesmo uma imagem cortada ainda √© melhor do que nada - apenas uma p√°gina com erro. <br><br><h3>  Tabela Resumo <br></h3><br><img src="https://habrastorage.org/webt/zn/p3/yp/znp3ypfris3rbtkmok83gcyvup8.jpeg"><br><br>  Na tabela acima, coletei tudo relacionado √† entrada / sa√≠da nas bibliotecas de que estou falando.  Em particular, contei o n√∫mero de codecs de v√°rios formatos que est√£o nas bibliotecas.  Descobriu-se que no OpenCV eles s√£o os menores, no ImageMagick - os mais.  Parece que no ImageMagick voc√™ pode abrir qualquer imagem que encontrar.  O VIPS possui 12 codecs nativos, mas o VIPS pode usar o ImageMagick como intermedi√°rio.  Eu n√£o testei como isso funciona, espero que seja perfeito. <br><br>  Pillow possui 17 codecs.  Agora √© a √∫nica biblioteca na qual n√£o h√° rota√ß√£o autom√°tica EXIF.  Mas agora esse √© um pequeno problema, porque voc√™ pode ler EXIF ‚Äã‚Äãe girar a imagem de acordo com ela.  √â uma quest√£o de um pequeno trecho, que √© facilmente google e leva no m√°ximo 20 linhas. <br><br><h3>  Recursos do OpenCV <br></h3><br>  Se voc√™ olhar atentamente esta tabela, poder√° ver que no OpenCV, de fato, nem tudo √© t√£o bom com entrada / sa√≠da.  Possui o menor n√∫mero de codecs, sem carregamento lento e voc√™ n√£o pode ler EXIF ‚Äã‚Äãe o perfil de cores. <br><br>  Mas isso n√£o √© tudo.  De fato, o OpenCV tem mais recursos.  Quando simplesmente abrimos uma imagem, a <code>cv2.imread(filename)</code> gira os arquivos JPEG de acordo com EXIF ‚Äã‚Äã(consulte a tabela), mas ignora o canal alfa dos arquivos PNG - um comportamento bastante estranho! <br><br>  Felizmente, o OpenCV possui um sinalizador: <code>cv2.imread(filename, flags=cv2.IMREAD_UNCHANGED)</code> . <br><br>  Se voc√™ especificar o sinalizador IMREAD_UNCHANGED, o OpenCV deixar√° o canal alfa para arquivos PNG, mas parar√° de transformar arquivos JPEG de acordo com EXIF.  Ou seja, o mesmo sinalizador afeta duas propriedades completamente diferentes.  Como pode ser visto na tabela, o OpenCV n√£o tem a capacidade de ler EXIF ‚Äã‚Äãe, no caso desse sinalizador, √© imposs√≠vel girar o JPEG. <br><br>  E se voc√™ n√£o souber com anteced√™ncia qual √© o formato da sua imagem e precisar do canal alfa para PNG e da rota√ß√£o autom√°tica para JPEG?  Nada a fazer - o OpenCV n√£o funciona assim. <br><br>  A raz√£o pela qual o OpenCV tem esses problemas est√° no nome desta biblioteca.  Possui muitas funcionalidades para vis√£o de computador e an√°lise de imagens.  De fato, o OpenCV foi projetado para funcionar com fontes verificadas.  Esta √©, por exemplo, uma c√¢mera de vigil√¢ncia externa que tira as imagens uma vez por segundo e faz isso por 5 anos no mesmo formato e na mesma resolu√ß√£o.  N√£o h√° necessidade de variabilidade no problema de E / S. <br><br>  As pessoas que precisam da funcionalidade OpenCV realmente n√£o precisam da funcionalidade de conte√∫do do usu√°rio. <br><br>  Mas e se o seu aplicativo ainda precisar de funcionalidade para trabalhar com o conte√∫do do usu√°rio e, ao mesmo tempo, voc√™ precisar de todo o poder do OpenCV para processamento e estat√≠sticas? <br><br><img src="https://habrastorage.org/webt/2g/2o/mu/2g2omu98a18hv0gzr4387egsj6s.jpeg"><br><br>  A solu√ß√£o √© combinar bibliotecas.  O fato √© que o OpenCV √© constru√≠do com base no numpy, e o Pillow tem todos os meios para exportar imagens do Pillow para um array numpy.  Ou seja, exportamos a matriz numpy, e o OpenCV pode continuar trabalhando com essa imagem, assim como com a sua.  Isso √© feito com muita facilidade: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.open(filename) cv_image = numpy.array(pillow_image)</code> </pre><br>  Al√©m disso, quando fazemos m√°gica usando OpenCV (processamento), chamamos outro m√©todo Pillow e importamos a imagem do OpenCV de volta para o formato Pillow.  Consequentemente, a E / S pode ser usada novamente. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.fromarray(cv_image, <span class="hljs-string"><span class="hljs-string">"RGB"</span></span>) pillow_image.save(filename)</code> </pre><br>  Assim, acontece que usamos entrada / sa√≠da do Pillow e o processamento do OpenCV, ou seja, pegamos o melhor dos dois mundos. <br><br>  Espero que isso ajude a criar um aplicativo gr√°fico carregado. <br><br><blockquote>  Voc√™ pode aprender outros segredos de desenvolvimento em Python, aprender com experi√™ncias inestim√°veis ‚Äã‚Äãe √†s vezes inesperadas e, o mais importante, discutir suas tarefas muito em breve no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Moscow Python Conf ++</a> .  Por exemplo, preste aten√ß√£o a esses nomes e t√≥picos na programa√ß√£o. <br><br><ul><li>  Donald Whyte, com uma hist√≥ria sobre como tornar a matem√°tica 10 vezes mais r√°pida usando bibliotecas populares, truques e esperteza, e o c√≥digo √© compreens√≠vel e suportado. </li><li>  Andrei Popov trata de coletar uma enorme quantidade de dados e analis√°-los em busca de amea√ßas. </li><li>  Ephraim Matosyan em seu relat√≥rio ‚ÄúTorne o Python r√°pido novamente‚Äù mostrar√° como aumentar o desempenho do daemon que processa mensagens do barramento. </li></ul><br>  Uma lista completa do que ser√° discutido para 22 e 23 de outubro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> , tem tempo para participar. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425471/">https://habr.com/ru/post/pt425471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425461/index.html">Devops e seguran√ßa: entrevistas com Seth Wargo e Liz Rice</a></li>
<li><a href="../pt425463/index.html">Mapas do Unity Hexagon: √°gua, pontos de refer√™ncia e muralhas da fortaleza</a></li>
<li><a href="../pt425465/index.html">Como um designer pode ganhar mais, uma ferramenta ideal para trabalhar e procurar id√©ias</a></li>
<li><a href="../pt425467/index.html">Motores Renault D4F> B4D (tamb√©m conhecido como SCe). Mudan√ßa geracional. Olhar do motorista</a></li>
<li><a href="../pt425469/index.html">O autor do Python n√£o lidera mais o desenvolvimento. Isso tornar√° a linguagem melhor ou pior?</a></li>
<li><a href="../pt425473/index.html">Confer√™ncia sobre Python e sobre comunica√ß√£o</a></li>
<li><a href="../pt425475/index.html">Rob√¥s colaborativos da Universal Robots na IMTS 2018 em Chicago</a></li>
<li><a href="../pt425477/index.html">Webinars da Skillbox na sexta-feira: da escolha de um idioma de programa√ß√£o √† localiza√ß√£o da sua empresa</a></li>
<li><a href="../pt425479/index.html">Em breve, metade das liga√ß√µes ser√° de rob√¥s. Dica: n√£o responda (?)</a></li>
<li><a href="../pt425483/index.html">Leitura de fim de semana: 22 artigos sobre a hist√≥ria das empresas de √°udio lend√°rias e como elas ‚Äúproduzem som‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>