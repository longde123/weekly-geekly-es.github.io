<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéã üë®‚Äçüíª üöΩ Criando Defesa de Torre na Unidade: Torres e Inimigos de Tiro üîÅ üë®üèª‚Äç‚öñÔ∏è üïï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ A primeira e a segunda partes do tutorial] 



- Colocamos no campo da torre. 
- Visamos inimigos com a ajuda da f√≠sica. 
- N√≥s os rastreamos enquan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando Defesa de Torre na Unidade: Torres e Inimigos de Tiro</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459070/">  [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A primeira</a> e a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">segunda</a> partes do tutorial] <br><br><ul><li>  Colocamos no campo da torre. </li><li>  Visamos inimigos com a ajuda da f√≠sica. </li><li>  N√≥s os rastreamos enquanto √© poss√≠vel. </li><li>  N√≥s atiramos neles com um raio laser. </li></ul><br>  Esta √© a terceira parte de uma s√©rie de tutoriais sobre como criar um g√™nero simples de defesa de torre.  Descreve a cria√ß√£o de torres, mirando e atirando nos inimigos. <br><br>  O tutorial foi criado no Unity 2018.3.0f2. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/470/ceb/183/470ceb1832b49ee7372fb79b8425b567.jpg" width="512" height="256"></div><br>  <i>Vamos aquecer os inimigos.</i> <br><br><h2>  Cria√ß√£o da torre </h2><br>  As paredes apenas diminuem a velocidade dos inimigos, aumentando o comprimento do caminho que eles precisam seguir.  Mas o objetivo do jogo √© destruir os inimigos antes que eles atinjam o ponto final.  Esse problema √© resolvido colocando torres no campo que dispara contra elas. <br><a name="habracut"></a><br><h3>  Conte√∫do em bloco </h3><br>  Torres s√£o outro tipo de conte√∫do de bloco, ent√£o <code>GameTileContent</code> adicionar uma entrada para eles no <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint, Tower‚Ç¨ }</code> </pre> <br>  Neste tutorial, daremos suporte apenas a um tipo de torre, que pode ser implementado fornecendo √† <code>GameTileContentFactory</code> um link para a pr√©-fabricada da torre, cuja inst√¢ncia tamb√©m pode ser criada via <code>Get</code> . <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Tower‚Ç¨: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(towerPrefab); } ‚Ä¶ }</code> </pre> <br>  Mas as torres devem disparar, portanto, sua condi√ß√£o precisar√° ser atualizada e eles precisam de seu pr√≥prio c√≥digo.  Crie uma classe <code>Tower</code> para esse fim que estende a classe <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Tower</span></span> : <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> {}</code> </pre> <br>  Voc√™ pode fazer com que a pr√©-fabricada da torre tenha seu pr√≥prio componente alterando o tipo de campo de f√°brica para <code>Tower</code> .  Como a classe ainda √© considerada um <code>GameTileContent</code> , nada mais precisa ser alterado. <br><br><pre> <code class="cs hljs"> Tower towerPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><h3>  Prefab </h3><br>  Crie uma casa pr√©-fabricada para a torre.  Voc√™ pode come√ßar duplicando a pr√©-fabricada da parede e substituindo o componente <code>GameTileContent</code> componente <code>Tower</code> e, em seguida, altere seu tipo para <em>Tower</em> .  Para fazer a torre encaixar nas paredes, salve o cubo da parede como base da torre.  Em seguida, coloque outro cubo em cima dele.  Eu dei a ele uma escala de 0,5.  Coloque outro cubo, indicando uma torre, esta parte mirar√° e atirar√° nos inimigos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/392/e5d/633/392e5d63397672627c3b5ec018df0444.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/dec/c33/d92decc33036a1e973a7f20a3df2c00e.png" width="320" height="120"></div><br>  <i>Tr√™s cubos formando uma torre.</i> <br><br>  A torre girar√° e, como possui um colisor, ser√° rastreada por um mecanismo f√≠sico.  Mas n√£o precisamos ser t√£o precisos, porque usamos colisores de torre apenas para selecionar c√©lulas.  Isso pode ser feito aproximadamente.  Remova o colisor do cubo da torre e troque-o para que cubra os dois cubos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/11e/3b7/e0111e3b7221bbbe4e5b0d23373e4b3a.png" width="190" height="260"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/857/09b/a1f85709bd504d176a18930240edea5a.png" width="320" height="152"></div><br>  <i>Torre de cubo Collider.</i> <br><br>  A torre dispara um raio laser.  Ele pode ser visualizado de v√°rias maneiras, mas apenas usamos um cubo transl√∫cido, que iremos esticar para formar um feixe.  Cada torre deve ter seu pr√≥prio feixe, portanto, adicione-o ao pr√©-fabricado da torre.  Coloque-o dentro da torre para que fique oculto por padr√£o e reduza a escala, por exemplo, 0,2.  Vamos torn√°-lo um filho da raiz pr√©-fabricada, n√£o do cubo da torre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19a/1dc/29e/19a1dc29e70adb158e07f29653db2d66.png" width="190" height="260" alt="raio laser"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/273/081/45a273081365aa9e483f1aa97cbe39c8.png" width="226" height="108" alt="hierarquia"></div><br>  <i>Cubo escondido de um raio laser.</i> <br><br>  Crie um material adequado para o raio laser.  Acabei de usar o material preto transl√∫cido padr√£o, desliguei todas as reflex√µes e tamb√©m dei uma cor vermelha emitida. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fb/e49/860/2fbe498604cc4cc4ed6ee60a45eea63d.png" width="320" height="284" alt="cor"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0eb/b46/483/0ebb4648376a7fe68c96b7a16ce27db9.png" width="320" height="56" alt="sem reflex√µes"></div><br>  <i>O material do raio laser.</i> <br><br>  Verifique se o raio laser n√£o possui um colisor e tamb√©m desligue o tom e a sombra. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ecf/f21/0ad/ecff210ad75ef4b12cb0a74102365492.png" width="320" height="162"></div><br>  <i>O raio laser n√£o interage com sombras.</i> <br><br>  Ap√≥s concluir a cria√ß√£o da pr√©-fabricada da torre, a adicionaremos √† f√°brica. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/626/37c/935/62637c9353cf1e20e170e82bbefcdb11.png" width="320" height="114"></div><br>  <i>F√°brica com uma torre.</i> <br><br><h3>  Coloca√ß√£o da torre </h3><br>  Adicionaremos e removeremos torres usando outro m√©todo de comuta√ß√£o.  Voc√™ pode simplesmente duplicar o <code>GameBoard.ToggleWall</code> alterando o nome do m√©todo e o tipo de conte√∫do. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower‚Ç¨) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower‚Ç¨); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FindPaths()) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } }</code> </pre> <br>  No <code>Game.HandleTouch</code> , pressionar a tecla Shift alterna as torres em vez de paredes. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleTower(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleWall(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/926/804/2ac/9268042acc19a28d6ff1a6d74d83144f.png" width="230" height="230"></div><br>  <i>Torres no campo.</i> <br><br><h3>  Bloqueio de caminho </h3><br>  At√© agora, apenas paredes podem bloquear a busca de um caminho, ent√£o os inimigos se movem pelas torres.  Vamos adicionar <code>GameTileContent</code> propriedade auxiliar ao <code>GameTileContent</code> que indica se o conte√∫do bloqueia o caminho.  O caminho √© bloqueado se for uma parede ou uma torre. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> BlocksPath =&gt; Type == GameTileContentType.Wall || Type == GameTileContentType.Tower‚Ç¨;</code> </pre> <br>  Use esta propriedade em <code>GameTile.GrowPathTo</code> em vez de verificar o tipo de conte√∫do. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-comment"><span class="hljs-comment">//neighbor.Content.Type != GameTileContentType.Wall ? neighbor : null; neighbor.Content.BlocksPath ? null : neighbor; }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/93f/eed/6fa93feedb4925ee12decb4233612a4c.png" width="230" height="230"></div><br>  <i>Agora o caminho est√° bloqueado por muros e torres.</i> <br><br><h3>  Substitua as paredes </h3><br>  Muito provavelmente, o jogador geralmente substitui as paredes por torres.  Ser√° inconveniente para ele remover a parede primeiro e, al√©m disso, os inimigos podem penetrar nessa brecha que apareceu temporariamente.  Voc√™ pode implementar uma substitui√ß√£o direta for√ßando o <code>GameBoard.ToggleTower</code> a verificar se a parede est√° atualmente no bloco.  Nesse caso, substitua-o imediatamente por uma torre.  Nesse caso, n√£o precisamos procurar outras maneiras, porque o bloco ainda as bloqueia. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); } }</code> </pre> <br><h2>  Nosso objetivo √© inimigos </h2><br>  Uma torre s√≥ pode cumprir sua tarefa quando encontra um inimigo.  Depois de encontrar o inimigo, ela deve decidir qual parte dele apontar. <br><br><h3>  Ponto de mira </h3><br>  Para detectar alvos, usaremos o mecanismo de f√≠sica.  Como no caso do colisor de torre, n√£o precisamos que o colisor inimigo coincida necessariamente com sua forma.  Voc√™ pode escolher o colisor mais simples, ou seja, uma esfera.  Depois de detectar o inimigo, usaremos a posi√ß√£o do objeto de jogo com o colisor anexado a ele como ponto de mira. <br><br>  N√£o podemos anexar o colisor ao objeto raiz do inimigo, porque ele nem sempre coincide com a posi√ß√£o do modelo e far√° a torre apontar para o ch√£o.  Ou seja, voc√™ precisa colocar o colisor em algum lugar do modelo.  O mecanismo de f√≠sica nos dar√° um link para esse objeto, que podemos usar para apontar, mas ainda precisamos acessar o componente <code>Enemy</code> do objeto raiz.  Para simplificar a tarefa, vamos criar o componente <code>TargetPoint</code> .  Vamos dar uma propriedade para atribui√ß√£o privada e recebimento p√∫blico do componente <code>Enemy</code> , e outra propriedade para obter sua posi√ß√£o no mundo. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TargetPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Enemy Enemy‚Ç¨ { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 Position =&gt; transform.position; }</code> </pre> <br>  Vamos dar a ele um m√©todo <code>Awake</code> que configura um link para seu componente <code>Enemy</code> .  V√° diretamente para o objeto raiz usando <code>transform.root</code> .  Se o componente <code>Enemy</code> n√£o existir, cometemos um erro ao criar o inimigo, ent√£o vamos adicionar uma declara√ß√£o para isso. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy‚Ç¨ = transform.root.GetComponent&lt;Enemy&gt;(); Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Al√©m disso, o colisor deve estar anexado ao mesmo objeto de jogo ao qual o <code>TargetPoint</code> conectado. <br><br><pre> <code class="cs hljs"> Debug.Assert(Enemy‚Ç¨ != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without Enemy root!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); Debug.Assert( GetComponent&lt;SphereCollider&gt;() != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point without sphere collider!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> );</code> </pre> <br>  Adicione um componente e um colisor ao cubo pr√©-fabricado do inimigo.  Isso far√° as torres apontarem para o centro do cubo.  Utilizamos um colisor esf√©rico com um raio de 0,25.  O cubo tem uma escala de 0,5; portanto, o raio real do colisor ser√° 0,125.  Gra√ßas a isso, o inimigo ter√° que cruzar visualmente o c√≠rculo de alcance da torre e somente depois de algum tempo o objetivo real se tornar√°.  O tamanho do colisor tamb√©m √© afetado pela escala aleat√≥ria do inimigo, portanto seu tamanho no jogo tamb√©m varia um pouco. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85e/5ca/5e4/85e5ca5e47b8d59fa4211c78126bd512.png" width="176" height="176"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/a71/aec/7aea71aecbd64d4e045df141ecd1c711.png" width="320" height="176" alt="inspetor"></div><br>  <i>Um inimigo com um ponto de mira e um colisor em um cubo.</i> <br><br><h3>  Camada inimiga </h3><br>  As torres se importam apenas com os inimigos, e elas n√£o apontam para mais nada, ent√£o colocaremos todos os inimigos em uma camada separada.  Usaremos a camada 9. Altere seu nome para <em>Inimigo</em> na janela <em>Camadas e tags</em> , que pode ser aberta atrav√©s da op√ß√£o <em>Editar camadas</em> no menu suspenso <em>Camadas</em> , no canto superior direito do editor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e6/9a5/762/8e69a5762e8eb1856175f9d9dc1ab388.png" width="320" height="308"></div><br>  <i>A camada 9 ser√° usada para inimigos.</i> <br><br>  Essa camada √© necess√°ria apenas para o reconhecimento de inimigos, e n√£o para intera√ß√µes f√≠sicas.  Vamos destacar desabilitando-os na <em>Layer Collision Matrix</em> , localizada no painel <em>Physics</em> dos par√¢metros do projeto. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/06e/e7d/87606ee7dfc4777760d81219517125ce.png" width="200" height="200"></div><br>  <i>Matriz de colis√µes de camadas.</i> <br><br>  Certifique-se de que o objeto de jogo do ponto de mira esteja na camada desejada.  O restante da pr√©-fabricada do inimigo pode estar em outras camadas, mas ser√° mais f√°cil coordenar tudo e colocar toda a pr√©-fabricada na camada <em>Inimiga</em> .  Se voc√™ alterar a camada do objeto raiz, voc√™ ser√° solicitado a alterar a camada para todos os seus objetos filhos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/f75/062/6d1f75062420abadb285e9efca1e1a5e.png" width="320" height="44"></div><br>  <i>Inimigo na camada certa.</i> <br><br>  Vamos adicionar a declara√ß√£o de que o <code>TargetPoint</code> realmente na camada correta. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ Debug.Assert(gameObject.layer == <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-string"><span class="hljs-string">"Target point on wrong layer!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  Al√©m disso, as a√ß√µes do jogador devem ser ignoradas pelos jogadores inimigos.  Isso pode ser conseguido adicionando um argumento de m√°scara de camada ao <code>Physics.Raycast</code> no <code>GameBoard.GetTile</code> .  Esse m√©todo possui uma forma que leva a dist√¢ncia para o feixe e a m√°scara de camada como argumentos adicionais.  Por padr√£o, forneceremos a dist√¢ncia m√°xima e a m√°scara de camada, ou seja, 1. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTile</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Ray ray</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> RaycastHit hit, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { ‚Ä¶ } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">A m√°scara de camada n√£o deve ser 0?</b> <div class="spoiler_text">  O √≠ndice de camada padr√£o √© zero, mas passamos a m√°scara de camada.  A m√°scara altera os bits individuais de um n√∫mero inteiro para 1 se a camada precisar ser ativada.  Nesse caso, voc√™ precisa definir apenas o primeiro bit, ou seja, o menos significativo, o que significa 2 <sup>0</sup> , que √© igual a 1. </div></div><br><h3>  Atualizando o conte√∫do do bloco </h3><br>  As torres podem executar suas tarefas apenas quando seu status √© atualizado.  O mesmo se aplica ao conte√∫do de todos os blocos, embora o restante do conte√∫do n√£o fa√ßa nada at√© agora.  Portanto, adicione um m√©todo virtual <code>GameTileContent</code> ao <code>GameUpdate</code> , que n√£o faz nada por padr√£o. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {}</code> </pre> <br>  Vamos fazer com que o <code>Tower</code> redefina, mesmo que por enquanto ele simplesmente mostre no console que est√° procurando um alvo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Searching for target..."</span></span>); }</code> </pre> <br>  <code>GameBoard</code> lida com blocos e seu conte√∫do, para que ele tamb√©m acompanhe o conte√∫do que precisa ser atualizado.  Para fazer isso, adicione a lista e o m√©todo p√∫blico <code>GameUpdate</code> , que atualiza tudo na lista. <br><br><pre> <code class="cs hljs"> List&lt;GameTileContent&gt; updatingContent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTileContent&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; updatingContent.Count; i++) { updatingContent[i].GameUpdate(); } }</code> </pre> <br>  Em nosso tutorial, voc√™ s√≥ precisa atualizar as torres.  Altere <code>ToggleTower</code> para adicionar e remover conte√∫do, se necess√°rio.  Se tamb√©m for necess√°rio outro conte√∫do, precisaremos de uma abordagem mais geral, mas, por enquanto, isso √© suficiente. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleTower</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Tower) { updatingContent.Remove(tile.Content); tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.Tower); <span class="hljs-comment"><span class="hljs-comment">//if (!FindPaths()) { if (FindPaths()) { updatingContent.Add(tile.Content); } else { tile.Content = contentFactory.Get(GameTileContentType.Empty); FindPaths(); } } else if (tile.Content.Type == GameTileContentType.Wall) { tile.Content = contentFactory.Get(GameTileContentType.Tower); updatingContent.Add(tile.Content); } }</span></span></code> </pre> <br>  Para fazer isso funcionar, basta atualizar o campo em <code>Game.Update</code> .  Vamos atualizar o campo ap√≥s os inimigos.  Gra√ßas a isso, as torres poder√£o apontar exatamente onde est√£o os inimigos.  Se fiz√©ssemos o contr√°rio, as torres mirariam onde os inimigos estavam no √∫ltimo quadro. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); board.GameUpdate(); }</code> </pre> <br><h3>  Visando a faixa </h3><br>  As torres t√™m um raio de mira limitado.  Vamos personaliz√°-lo adicionando um campo √† classe <code>Tower</code> .  A dist√¢ncia √© medida a partir do centro do bloco da torre, portanto, no intervalo de 0,5, ele cobrir√° apenas seu pr√≥prio bloco.  Portanto, um intervalo m√≠nimo e padr√£o razo√°vel seria 1,5, cobrindo a maioria dos ladrilhos vizinhos. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1.5f, 10.5f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> targetingRange = <span class="hljs-number"><span class="hljs-number">1.5f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c38/ae4/ee8/c38ae4ee885cf5d89f24164b9c6bc5fe.png" width="320" height="74"></div><br>  <i>Alcance do objetivo 2.5.</i> <br><br>  Vamos visualizar o intervalo com o gizmo.  N√£o precisamos v√™-lo constantemente; portanto, criaremos o m√©todo <code>OnDrawGizmosSelected</code> chamado apenas para os objetos selecionados.  Desenhamos a moldura amarela da esfera com um raio igual √† dist√¢ncia e centralizado em rela√ß√£o √† torre.  Coloque-o ligeiramente acima do solo, para que fique sempre claramente vis√≠vel. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Gizmos.color = Color.yellow; Vector3 position = transform.localPosition; position.y += <span class="hljs-number"><span class="hljs-number">0.01f</span></span>; Gizmos.DrawWireSphere(position, targetingRange); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/674/6b7/3cd/6746b73cd2e015fd599b770bb89e1c8a.png" width="230" height="230"></div><br>  <i>Gizmo que aponta o alcance.</i> <br><br>  Agora podemos ver qual dos inimigos √© um alvo acess√≠vel para cada uma das torres.  Mas escolher torres na janela de cena √© inconveniente, porque precisamos selecionar um dos cubos filhos e depois mudar para o objeto raiz da torre.  Outros tipos de conte√∫do de bloco tamb√©m sofrem do mesmo problema.  Podemos for√ßar a sele√ß√£o da raiz do conte√∫do do <code>GameTileContent</code> na janela da cena, adicionando o atributo <code>SelectionBase</code> ao <code>GameTileContent</code> . <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SelectionBase</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContent</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { ‚Ä¶ }</code> </pre> <br><h3>  Captura de alvo </h3><br>  Adicione um campo <code>TargetPoint</code> √† classe <code>Tower</code> para que ele possa rastrear seu destino capturado.  Em seguida, <code>GameUpdate</code> para chamar o novo m√©todo <code>AquireTarget</code> , que retorna informa√ß√µes sobre se encontrou o destino.  Ap√≥s a detec√ß√£o, ele exibir√° uma mensagem no console. <br><br><pre> <code class="cs hljs"> TargetPoint target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Acquired target!"</span></span>); } }</code> </pre> <br>  No <code>AcquireTarget</code> obtemos todos os destinos dispon√≠veis chamando <code>Physics.OverlapSphere</code> com uma posi√ß√£o de torre e intervalo como argumentos.  O resultado ser√° uma matriz <code>Collider</code> contendo todos os colliders em contato com a esfera.  Se o comprimento da matriz √© positivo, existe pelo menos um ponto de mira e simplesmente selecionamos o primeiro.  Pegue o componente <code>TargetPoint</code> , que sempre deve existir, atribua-o ao campo de destino e relate o sucesso.  Caso contr√°rio, limpamos o alvo e relatamos a falha. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targets.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targets[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targets[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Temos a garantia de obter os pontos de mira corretos, se levarmos em conta colididores apenas na camada de inimigos.  Essa √© a camada 9, ent√£o passaremos a m√°scara de camada correspondente. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> enemyLayerMask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Collider[] targets = Physics.OverlapSphere( transform.localPosition, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Como esta m√°scara de bits funciona?</b> <div class="spoiler_text">  Como a camada inimiga tem um √≠ndice de 9, o d√©cimo bit da m√°scara de bit deve ter o valor 1. Isso corresponde a um n√∫mero inteiro 2 <sup>9</sup> , ou seja, 512. Mas esse registro de m√°scara de bit n√£o √© intuitivo.  Tamb√©m podemos escrever um literal bin√°rio, por exemplo, <code>0b10_0000_0000</code> , mas precisamos contar zeros.  Nesse caso, a entrada mais conveniente seria usar o operador de deslocamento esquerdo <code>&lt;&lt;</code> , que desloca os bits para a esquerda.  que corresponde a um n√∫mero na pot√™ncia de dois. </div></div><br>  Voc√™ pode visualizar o alvo capturado desenhando uma linha de aparelhos entre as posi√ß√µes da torre e o alvo. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnDrawGizmosSelected</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Gizmos.DrawLine(position, target.Position); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a5/e99/4be/7a5e994be6b7d848c2d4bfe7d627c708.png" width="230" height="230"></div><br>  <i>Visualiza√ß√£o de objetivos.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Por que n√£o usar m√©todos como o OnTriggerEnter?</b> <div class="spoiler_text">  A vantagem de verificar manualmente as metas transversais √© que s√≥ podemos fazer isso quando necess√°rio.  N√£o h√° raz√£o para verificar se h√° alvos na torre.  Al√©m disso, ao obter todos os objetivos em potencial ao mesmo tempo, n√£o precisamos processar uma lista de objetivos em potencial para cada torre, que muda constantemente. </div></div><br><h3>  Target Lock </h3><br>  O alvo escolhido para capturar depende da ordem em que s√£o representados pelo mecanismo f√≠sico, ou seja, √© arbitr√°rio.  Portanto, parece que o alvo capturado est√° mudando sem motivo.  Depois que a torre recebe o alvo, √© mais l√≥gico para ela rastre√°-la e n√£o mudar para outra.  Adicione um m√©todo <code>TrackTarget</code> que implemente esse rastreamento e retorne informa√ß√µes sobre se foi bem-sucedido.  Primeiro, informaremos se o alvo foi capturado. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Chamaremos esse m√©todo no <code>GameUpdate</code> e somente ao retornar false chamaremos <code>AcquireTarget</code> .  Se o m√©todo retornou verdadeiro, temos um objetivo.  Isso pode ser feito colocando as duas chamadas de m√©todo em uma verifica√ß√£o <code>if</code> com o operador OR, porque se o primeiro operando retornar <code>true</code> , o segundo n√£o ser√° verificado e a chamada ser√° perdida.  O operador AND atua de maneira semelhante. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"Locked on target!"</span></span>); } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ec/27c/0a2/8ec27c0a2201434cba3725621b68aaa1.png" width="230" height="230"></div><br>  <i>Acompanhamento de metas.</i> <br><br>  Como resultado, as torres s√£o fixadas no alvo at√© atingir o ponto final e serem destru√≠das.  Se voc√™ usar inimigos repetidamente, precisar√° verificar a exatid√£o do link, como √© feito com os links para as figuras processadas em uma s√©rie de tutoriais sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">gerenciamento</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">objetos</a> . <br><br>  Para rastrear alvos apenas quando est√£o dentro do alcance, o <code>TrackTarget</code> deve rastrear a dist√¢ncia entre a torre e o alvo.  Se exceder o valor do intervalo, o destino dever√° ser redefinido e retornar falso.  Voc√™ pode usar o m√©todo <code>Vector3.Distance</code> para esta verifica√ß√£o. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  No entanto, esse c√≥digo n√£o leva em considera√ß√£o o raio do colisor.  Portanto, como resultado, a torre pode perder o alvo e captur√°-lo novamente, apenas para parar de rastre√°-lo no pr√≥ximo quadro e assim por diante.  Podemos evitar isso adicionando um raio de colis√£o ao intervalo. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span>) { ‚Ä¶ }</code> </pre> <br>  Isso nos d√° os resultados corretos, mas somente se a escala do inimigo n√£o for alterada.  Como atribu√≠mos a cada inimigo uma escala aleat√≥ria, devemos levar isso em considera√ß√£o ao alterar o alcance.  Para fazer isso, precisamos lembrar a escala fornecida pelo <code>Enemy</code> e abri-la usando a propriedade getter. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Scale { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { Scale = scale; ‚Ä¶ }</code> </pre> <br>  Agora podemos verificar o intervalo correto no <code>Tower.TrackTarget</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Vector3.Distance(a, b) &gt; targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale) { ‚Ä¶ }</code> </pre> <br><h3>  Sincronizamos a f√≠sica </h3><br>  Tudo parece estar funcionando bem, mas torres que podem mirar no centro do campo s√£o capazes de capturar alvos que devem estar fora de alcance.  Eles n√£o ser√£o capazes de rastrear essas metas; portanto, elas s√£o fixadas nelas apenas por um quadro. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e91/0a1/836/e910a1836ef729d95ebee121a67c3f2c.png" width="230" height="230"></div><br>  <i>Meta incorreta.</i> <br><br>  Isso acontece porque o estado do mecanismo f√≠sico √© imperfeitamente sincronizado com o estado do jogo.  Inst√¢ncias de todos os inimigos s√£o criados na origem do mundo, que coincide com o centro do campo.  Ent√£o, n√≥s os movemos para o ponto de cria√ß√£o, mas o mecanismo de f√≠sica n√£o sabe sobre isso imediatamente. <br><br>  Voc√™ pode ativar a sincroniza√ß√£o instant√¢nea que ocorre quando voc√™ altera as transforma√ß√µes de objeto, definindo <code>Physics.autoSyncTransforms</code> como <code>true</code> .  Mas, por padr√£o, est√° desativado, porque √© muito mais eficiente sincronizar tudo junto e, se necess√°rio.  No nosso caso, a sincroniza√ß√£o √© necess√°ria apenas ao atualizar o estado das torres.  Podemos execut√°-lo chamando <code>Physics.SyncTransforms</code> entre atualiza√ß√µes de inimigos e de campo em <code>Game.Update</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); Physics.SyncTransforms(); board.GameUpdate(); }</code> </pre> <br><h3>  Ignore a altura </h3><br>  De fato, nossa jogabilidade ocorre em 2D.  Ent√£o, vamos mudar a <code>Tower</code> para que, ao mirar e rastrear, leve em considera√ß√£o apenas as coordenadas X e Z. O mecanismo f√≠sico funciona no espa√ßo 3D, mas, em ess√™ncia, podemos executar o <code>AcquireTarget</code> em 2D: estique a esfera para cima para cobrir todos os colididores, independentemente da posi√ß√£o vertical.  Isso pode ser feito usando uma c√°psula em vez de uma esfera, cujo segundo ponto ser√° v√°rias unidades acima do solo (por exemplo, tr√™s). <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">3f</span></span>; Collider[] targets = Physics.OverlapCapsule( a, b, targetingRange, enemyLayerMask ); ‚Ä¶ }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o √© poss√≠vel usar um mecanismo 2D f√≠sico?</font></font></b> <div class="spoiler_text">   ,       XZ,   2D-    XY.     ,     ,    2D-   .     3D-. </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m √© necess√°rio mudar </font></font><code>TrackTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Obviamente, podemos usar vetores 2D e </font></font><code>Vector2.Distance</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas vamos fazer os c√°lculos n√≥s mesmos e, em vez disso, compararemos os quadrados das dist√¢ncias, isso ser√° suficiente. </font><font style="vertical-align: inherit;">Ent√£o nos livramos da opera√ß√£o de calcular a raiz quadrada.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrackTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } Vector3 a = transform.localPosition; Vector3 b = target.Position; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x = ax - bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = az - bz; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> r = targetingRange + <span class="hljs-number"><span class="hljs-number">0.125f</span></span> * target.Enemy‚Ç¨.Scale; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x * x + z * z &gt; r * r) { target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como esses c√°lculos matem√°ticos funcionam?</font></font></b> <div class="spoiler_text">     2D-   ,     .     ,       .  ,        ,    . </div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evite aloca√ß√£o de mem√≥ria </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A desvantagem de us√°-lo </font></font><code>Physics.OverlapCapsule</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© que, para cada chamada, ele aloca uma nova matriz. </font><font style="vertical-align: inherit;">Isso pode ser evitado alocando a matriz uma vez e chamando um m√©todo alternativo </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com a matriz como argumento adicional. </font><font style="vertical-align: inherit;">O comprimento da matriz transmitida determina o n√∫mero de resultados. </font><font style="vertical-align: inherit;">Todos os destinos em potencial fora da matriz s√£o descartados. </font><font style="vertical-align: inherit;">Mesmo assim, usaremos apenas o primeiro elemento, portanto, uma matriz de comprimento 1. √© suficiente para n√≥s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de uma matriz, ele </font></font><code>OverlapCapsuleNonAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorna o n√∫mero de colis√µes que ocorreram, at√© o m√°ximo permitido, e este √© o n√∫mero que verificaremos em vez do comprimento da matriz.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">1</span></span>]; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 a = transform.localPosition; Vector3 b = a; <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> += <span class="hljs-number"><span class="hljs-number">2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hits = Physics.OverlapCapsuleNonAlloc( a, b, targetingRange, targetsBuffer, enemyLayerMask ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetComponent&lt;TargetPoint&gt;(); Debug.Assert(target != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Targeted non-enemy!"</span></span>, targetsBuffer[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atiramos nos inimigos </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora que temos um objetivo real, √© hora de atingi-lo. </font><font style="vertical-align: inherit;">O disparo inclui apontar, um tiro a laser e causar dano.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Torre de mira </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para direcionar a torre para o alvo, a classe </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precisa ter um link para o componente da </font></font><code>Transform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">torre. </font><font style="vertical-align: inherit;">Adicione um campo de configura√ß√£o para isso e conecte-o ao prefab da torre.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0f/3be/41b/e0f3be41b0936993268316b8f01e1f67.png" width="320" height="90"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A torre anexada. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">houver um alvo real, devemos atirar nele. </font><font style="vertical-align: inherit;">Coloque o c√≥digo de disparo em um m√©todo separado. </font><font style="vertical-align: inherit;">Fa√ßa-o girar a torre em dire√ß√£o ao alvo, chamando seu m√©todo </font></font><code>Transform.LookAt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com o ponto de mira como argumento.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { <span class="hljs-comment"><span class="hljs-comment">//Debug.Log("Locked on target!"); Shoot(); } } void Shoot () { Vector3 point = target.Position; turret.LookAt(point); }</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/5bb/e9d/00e5bbe9d98e739800bf47435ca574af.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apenas apontando.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filmamos um laser </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para posicionar o raio laser, a classe </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m precisa de um link para ele.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform turret = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, laserBeam = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/802/c9c/86e/802c9c86eac24112cb2b4f072fd0f410.png" width="320" height="110"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√≥s conectamos um raio laser. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para transformar um cubo em um raio laser real, voc√™ precisa executar tr√™s etapas. </font><font style="vertical-align: inherit;">Primeiramente, sua orienta√ß√£o deve corresponder √† orienta√ß√£o da torre. </font><font style="vertical-align: inherit;">Isso pode ser feito copiando sua rota√ß√£o.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em segundo lugar, escalamos o feixe de laser para que seu comprimento seja igual √† dist√¢ncia entre o ponto de origem local da torre e o ponto de mira. </font><font style="vertical-align: inherit;">N√≥s escalamos ao longo do eixo Z, ou seja, o eixo local direcionado para o alvo. </font><font style="vertical-align: inherit;">Para preservar a escala XY original, anotamos a escala original quando acordamos a torre Desperta.</font></font><br><br><pre> <code class="cs hljs"> Vector3 laserBeamScale; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { laserBeamScale = laserBeam.localScale; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Vector3 point = target.Position; turret.LookAt(point); laserBeam.localRotation = turret.localRotation; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = Vector3.Distance(turret.position, point); laserBeamScale.z = d; laserBeam.localScale = laserBeamScale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em terceiro lugar, colocamos o raio laser no meio entre a torre e o ponto de mira. </font></font><br><br><pre> <code class="cs hljs"> laserBeam.localScale = laserBeamScale; laserBeam.localPosition = turret.localPosition + <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * d * laserBeam.forward;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/288/d96/438/288d96438354bd732fd7a3bb84ead491.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiro a laser.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o √© poss√≠vel transformar um raio laser em filho de uma torre?</font></font></b> <div class="spoiler_text">     ,         ,       forward.       ,     .     . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isso funciona enquanto a torre est√° fixa no alvo. </font><font style="vertical-align: inherit;">Mas quando n√£o h√° alvo, o laser permanece ativo. </font><font style="vertical-align: inherit;">Podemos desligar a tela do laser </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ajustando </font><font style="vertical-align: inherit;">sua escala para </font><font style="vertical-align: inherit;">0.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TrackTarget() || AcquireTarget()) { Shoot(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { laserBeam.localScale = Vector3.zero; } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/8c8/c23/39b8c8c239e0936137c646f91a4197de.png" width="230" height="230"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Torres inativas n√£o disparam.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sa√∫de do inimigo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At√© agora, nossos raios laser apenas tocam os inimigos e n√£o os afetam mais. </font><font style="vertical-align: inherit;">√â necess√°rio garantir que o laser danifique os inimigos. </font><font style="vertical-align: inherit;">N√£o queremos destruir os inimigos instantaneamente, por isso daremos a </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propriedade da sa√∫de. </font><font style="vertical-align: inherit;">Voc√™ pode escolher qualquer valor como sa√∫de, ent√£o vamos usar 100. Mas ser√° mais l√≥gico que inimigos grandes tenham mais sa√∫de, portanto, apresentaremos um coeficiente para isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Health { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ Health = <span class="hljs-number"><span class="hljs-number">100f</span></span> * scale; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para adicionar suporte para causar dano, adicione um m√©todo p√∫blico </font></font><code>ApplyDamage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que subtraia seu par√¢metro da sa√∫de. </font><font style="vertical-align: inherit;">Assumiremos que o dano n√£o √© negativo; portanto, adicionamos uma declara√ß√£o sobre isso.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ApplyDamage</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> damage</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(damage &gt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-string"><span class="hljs-string">"Negative damage applied."</span></span>); Health -= damage; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o nos livraremos instantaneamente do inimigo assim que sua sa√∫de chegar a zero. </font><font style="vertical-align: inherit;">A verifica√ß√£o de exaust√£o da sa√∫de e destrui√ß√£o do inimigo ser√° realizada no in√≠cio </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Health &lt;= <span class="hljs-number"><span class="hljs-number">0f</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gra√ßas a isso, todas as torres disparar√£o essencialmente simultaneamente, e n√£o por sua vez, o que lhes permitir√° mudar para outros alvos se a torre anterior destruir o inimigo, para o qual tamb√©m miraram. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dano por segundo </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora precisamos determinar quanto dano o laser causar√°. </font><font style="vertical-align: inherit;">Para fazer isso, adicione ao </font></font><code>Tower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">campo de configura√ß√£o. </font><font style="vertical-align: inherit;">Como o raio laser causa dano cont√≠nuo, n√≥s o expressaremos como dano por segundo. </font><font style="vertical-align: inherit;">N√≥s o </font></font><code>Shoot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aplicamos ao componente de </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">destino com multiplica√ß√£o pelo tempo delta.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, Range(1f, 100f)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> damagePerSecond = <span class="hljs-number"><span class="hljs-number">10f</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Shoot</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ target.Enemy.ApplyDamage(damagePerSecond * Time.deltaTime); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/18f/199/88618f199c9c08e7eaeb89b16083f545.png" width="320" height="128" alt="inspetor"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gk/vt/sf/gkvtsfa1ya4igbsjagqhtnzu0wq.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O dano de cada torre √© de 20 unidades por segundo.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meta aleat√≥ria </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como sempre escolhemos o primeiro alvo dispon√≠vel, o comportamento da mira depende da ordem em que o mecanismo f√≠sico verifica os coletores que se cruzam. Essa depend√™ncia n√£o √© muito boa, porque n√£o conhecemos os detalhes, n√£o podemos control√°-la; al√©m disso, parecer√° estranha e inconsistente. Muitas vezes, esse comportamento leva ao fogo concentrado, mas nem sempre √© esse o caso. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de confiar inteiramente no mecanismo de f√≠sica, vamos adicionar alguma aleatoriedade. Isso pode ser feito aumentando o n√∫mero de interse√ß√µes recebidas pelos coletores, por exemplo, at√© 100. Talvez isso n√£o seja suficiente para obter todos os alvos poss√≠veis em um campo densamente cheio de inimigos, mas isso ser√° suficiente para melhorar a pontaria.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Collider[] targetsBuffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Collider[<span class="hljs-number"><span class="hljs-number">100</span></span>];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora, em vez de escolher o primeiro alvo em potencial, selecionaremos um elemento aleat√≥rio da matriz. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcquireTarget</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hits &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { target = targetsBuffer[Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, hits)].GetComponent&lt;TargetPoint&gt;(); ‚Ä¶ } target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/lt/hi/nvlthij_ixh6lsxgwujtoipjwg4.gif"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta aleat√≥ria.</font></font></i> <br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outros crit√©rios para a escolha de metas podem ser usados?</font></font></b> <div class="spoiler_text"> , ,        .  ,      ,     .    .             . </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ent√£o, em nosso jogo de defesa de torre, finalmente surgiram torres. </font><font style="vertical-align: inherit;">Na pr√≥xima parte, o jogo ter√° sua forma final ainda mais.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt459070/">https://habr.com/ru/post/pt459070/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt459052/index.html">Como comparar: ‚Äúcarro incr√≠vel‚Äù e ‚Äúcabana feia‚Äù, em uma pesquisa de marketing e em big data</a></li>
<li><a href="../pt459054/index.html">Mapa de calor dos cliques - como os usu√°rios se comportam no site</a></li>
<li><a href="../pt459062/index.html">O resumo de materiais interessantes para o desenvolvedor m√≥vel 305 (de 1 a 7 de julho)</a></li>
<li><a href="../pt459066/index.html">Balanceamento de grava√ß√£o e leitura de banco de dados</a></li>
<li><a href="../pt459068/index.html">Windows Server 2008 R2 - O rei est√° morto, viva o rei</a></li>
<li><a href="../pt459074/index.html">Petty little joy # 7: tr√™s pelo pre√ßo de um - anima√ß√£o do console, algoritmos e depura√ß√£o</a></li>
<li><a href="../pt459078/index.html">O CERN muda para o software de c√≥digo aberto - por qu√™?</a></li>
<li><a href="../pt459080/index.html">Recursos HttpUrlConnection de java.net</a></li>
<li><a href="../pt459082/index.html">Quem √© eid√©tica, como funcionam as falsas mem√≥rias e tr√™s mitos populares sobre mem√≥ria</a></li>
<li><a href="../pt459084/index.html">Um pouco sobre o Google Home Hub ou como comprei uma moldura por 130 euros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>