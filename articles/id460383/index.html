<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏫 👨🏽‍🔧 🍂 Transisi layar di Legend of Zelda menggunakan fitur NES yang tidak berdokumen 👩🏽‍🚒 🔢 👧🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Untuk efek pengguliran vertikal di bagian pertama "The Legend of Zelda", manipulasi "perangkat keras" grafis NES digunakan, kemungkinan besar tidak di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transisi layar di Legend of Zelda menggunakan fitur NES yang tidak berdokumen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/">  Untuk efek pengguliran vertikal di bagian pertama "The Legend of Zelda", manipulasi "perangkat keras" grafis NES digunakan, kemungkinan besar tidak disediakan oleh pengembang konsol. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  Saya tidak memiliki akses ke dokumentasi resmi dari Unit Pemrosesan Gambar (PPU - chip grafis) konsol NES, sehingga pernyataan saya tentang "perilaku tidak terbatas" lebih cenderung menjadi dugaan.  Saya mengambil spesifikasi perangkat keras grafis dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NesDev Wiki</a> .  PPU dikendalikan dengan menulis ke register dengan pemetaan memori.  Jika Anda menggunakan register ini dengan cara yang (tampaknya) dikandung oleh para desainer, maka tidak mungkin untuk mencapai efek ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  Saat menggulir layar secara vertikal, seluruh layar harus menggulir sekaligus.  GIF sebelumnya menunjukkan contoh pengguliran vertikal parsial.  Sebagian layar tetap stasioner (elemen antarmuka), dan bagian lainnya (area permainan) bergulir secara vertikal.  Pengguliran vertikal sebagian tidak mungkin diterapkan dengan kerja "standar" dengan PPU. <br><br>  Sebaliknya, pengguliran <em>horizontal</em> parsial sepenuhnya ditentukan dan dimungkinkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  Menulis ke register PPU terpisah pada saat bingkai dibuat dapat menyebabkan artefak grafis.  The Legend of Zelda sengaja menyebabkan artefak yang memanifestasikan dirinya sebagai pengguliran vertikal parsial.  Dalam posting ini, saya akan berbicara sedikit tentang perangkat keras grafis NES dan menjelaskan cara kerja trik gulir vertikal. <br><a name="habracut"></a><br><h2>  Jenis grafik </h2><br>  Konsol NES memiliki dua jenis grafis: <br><br><ul><li>  Sprite adalah ubin yang dapat ditempatkan di tempat sewenang-wenang di layar dan dipindahkan secara independen satu sama lain. </li><li>  Latar Belakang - kotak ubin yang dapat digulir dengan lancar sebagai satu gambar. </li></ul><br>  Untuk menunjukkan perbedaan antara keduanya, saya akan menunjukkan adegan yang terdiri dari sprite dan latar belakang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  Dan di sini adalah adegan yang sama di mana hanya sprite yang terlihat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  Dan di sini adalah adegan di mana hanya latar belakang yang terlihat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  Bergulir </h2><br>  Prosesor gambar (NES Picture Processor) mendukung pengguliran gambar latar belakang.  Dalam memori grafis, grafik latar belakang disimpan sebagai kotak ubin dua dimensi yang meliputi area dua kali lebar dan tinggi layar. <br><br>  "Jendela" ditampilkan pada layar dalam ukuran kotak ini, dan posisi jendela ini dapat dikontrol dengan tepat.  Dengan secara bertahap menggerakkan jendela yang terlihat di sepanjang kisi, efek gulir yang halus dibuat. <br><br>  Sinyal video keluaran NES memiliki ukuran 256x240 piksel.  Kotak ubin di dalam memori direpresentasikan sebagai area 512x480 piksel dan dibagi menjadi empat persegi panjang berukuran layar yang disebut "tabel nama".  Game dapat mengonfigurasi Picture Processing Unit (PPU) dengan menunjukkan posisi jendela yang terlihat dengan memilih koordinat piksel dalam kisi tabel nama. <br><br>  Saat Anda memilih koordinat (0, 0), seluruh nama tabel kiri atas akan ditampilkan di layar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Pindah ke (125, 181), kita akan melihat sedikit dari setiap daftar nama: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  Jendela yang terlihat meminimalkan ke bagian belakang kotak ubin di memori.  Pindah ke (342, 290), kami menempatkan sudut kiri atas layar yang terlihat di dalam tabel nama kanan bawah, dan berkat pelipatan, bagian dari masing-masing tabel nama akan terlihat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  Memori tidak cukup! </h3><br>  Setiap tabel nama memiliki ukuran 1 KB, tetapi NES hanya mengalokasikan 2 KB memori videonya ke tabel ini, sehingga hanya dua tabel nama yang dapat masuk ke memori sekaligus. <br><br>  Bagaimana bisa ada empat tabel nama? <br><br><h4>  Tabel Nama Mirroring </h4><br>  Memori video terhubung ke PPU sedemikian rupa sehingga ketika PPU membuat ubin salah satu dari empat tabel nama nyata, sebenarnya salah satu dari dua tabel nyata dipilih, dan bacaan berasal dari sana.  Pada dasarnya, ini berarti bahwa empat tabel nama yang terlihat sebenarnya terdiri dari dua pasang tabel yang identik. <br><br>  Gambar ini menunjukkan snapshot dari isi keempat tabel.  Kiri atas dan kanan atas sama dengan dua yang lebih rendah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  Lalu mengapa tidak menyimpan dua tabel nama? <br><br>  Untungnya, pengikatan yang tepat antara tabel nyata dan nyata dapat dikonfigurasi saat runtime.  Jika permainan ingin melakukan pengguliran horizontal, maka itu menyesuaikan peralatan grafik sehingga tabel kiri atas dan kanan atas berbeda, dan mereka dapat digulir tanpa duplikasi yang nyata.  Dalam konfigurasi ini, tabel kiri atas dan kiri bawah akan merujuk ke tabel nama asli yang sama;  sama untuk dua tabel kanan.  Konfigurasi ini disebut Pencerminan Vertikal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  Ada juga konfigurasi lain yang mungkin - "Horizontal Mirroring", yang digunakan game untuk pengguliran vertikal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  Biasanya, gim tidak menggulir secara diagonal, karena gim ini menciptakan artefak di sekitar tepi layar karena mirroring dari tabel nama. <br><br><h3>  Kartrid </h3><br>  Setiap kartrij permainan memiliki perangkat keras yang memungkinkan Anda mengonfigurasi pencerminan tabel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  Beberapa gim tidak perlu mengganti mirroring sama sekali, jadi mirroring horizontal atau vertikal sulit dikodekan dalam kartrijnya.  Game lain secara dinamis beralih di antara kedua mode ini, jadi mirroring dalam kartrijnya dikonfigurasi secara terprogram.  Legenda Zelda termasuk dalam kategori kedua.  Akhirnya, kartrij dari beberapa gim yang benar-benar kompleks memiliki memori video tambahan, yaitu, gim-gim ini tidak perlu dicerminkan sama sekali: gim-gim tersebut dapat secara simultan bergulir secara vertikal dan horizontal tanpa artefak duplikasi yang terlihat. <br><br><h3>  Contoh nyata </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>Contoh pengguliran vertikal yang ditampilkan di layar.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Ini menunjukkan catatan tabel nama dengan mirroring horizontal.</i>  <i>Jendela yang saat ini terlihat disorot.</i> <br><br>  Ingatlah bahwa pengguliran paling vertikal bukanlah hal yang tidak biasa - yang tidak biasa adalah pengguliran vertikal dengan <em>layar terbagi</em> . <br><br><h2>  Layar terpisah </h2><br>  Setiap bingkai sinyal video yang dihasilkan oleh NES dirender dari atas ke bawah, satu baris piksel setiap kali.  Di setiap baris, piksel digambar satu per satu, dari kiri ke kanan.  Di tengah jalan saat merender bingkai, gim dapat mengkonfigurasi ulang PPU, yang memengaruhi tampilan piksel yang belum dirender.  Salah satu perubahan paling umum di tengah frame adalah memperbarui posisi gulir horizontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  Saat menggulir secara horizontal di antara kamar, The Legend of Zelda selalu dimulai dari posisi menggulir (0, 0) dan merender elemen antarmuka di bagian atas layar.  Setelah menggambar garis terakhir piksel antarmuka pada layar, pengguliran horizontal berubah dengan nilai yang meningkat pada setiap frame, sehingga kamera bergerak dengan lancar. <br><br>  Animasi tampilan tabel nama menunjukkan bagaimana permainan beralih dari mirroring horizontal ke vertikal sebelum menggulir, dan kemudian kembali ke horizontal setelah transisi selesai.  Selain itu, saat pengguliran berlanjut, tabel nama kiri atas (dan kiri bawah) diperbarui, dan salinan ruangan yang dimasukkan pemain dicatat di dalamnya.  Setelah pengguliran selesai, permainan berhenti membagi layar dan sekali lagi sepenuhnya ditampilkan dari tabel kiri atas. <br><br><h3>  Pengukuran Rendering </h3><br>  Untuk membagi layar pada posisi yang diinginkan, gim perlu mencari tahu bagian mana dari frame saat ini yang diambil.  String piksel diberikan pada frekuensi yang diketahui, sehingga jumlah string piksel yang diberikan dapat ditentukan dengan menghitung jumlah siklus prosesor yang telah berlalu sejak awal frame. <br><br>  Ada teknik lain yang lebih akurat yang disebut Sprite Zero Hit. <br><br>  SEN dapat membuat hingga 64 sprite sekaligus.  Sprite pertama dalam memori video disebut Sprite Zero (zero sprite).  Di setiap frame, segera setelah piksel buram dari nol sprite ditumpangkan pada piksel latar buram, acara Sprite Zero Hit terjadi.  Ini menetapkan sedikit di salah satu register PPU dengan pemetaan memori, yang dapat diperiksa oleh prosesor. <br><br>  Untuk menggunakan Sprite Zero Hit untuk membagi layar, permainan letakkan nol sprite dalam posisi vertikal di dekat perbatasan split, dan selama rendering mereka terus-menerus memeriksa untuk melihat apakah acara Sprite Zero Hit telah terjadi.  Jika demikian, gim beralih dari pengguliran horizontal ke penerapan pemisahan. <br><br>  Transisi horizontal antara kamar dengan dan tanpa latar belakang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  Lingkaran cokelat yang muncul di awal transisi dan menghilang pada akhirnya adalah nol sprite.  Kami akan melihat lebih dekat pada antarmuka dengan dan tanpa latar belakang: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  Sprite nol adalah sprite bom yang diputihkan yang sangat cocok dengan sprite bom biasa dari antarmuka game.  Sprite nol dikonfigurasikan untuk muncul di bawah latar belakang, tetapi karena piksel hitam antarmuka dianggap transparan, bom sprite nol akan terlihat jika tidak tersembunyi secara strategis di belakang bom dari antarmuka. <br><br>  Perhatikan bahwa Sprite Zero Hit terjadi beberapa baris piksel sebelum garis bawah antarmuka.  Ini terjadi pada piksel atas sekering bom, yaitu 16 piksel dari bagian bawah antarmuka.  Ketika Sprite Zero Hit terjadi, permainan mulai menghitung siklus prosesor, dan setelah menyelesaikan jumlah siklus yang diperlukan, mengatur pengguliran horizontal. <br><br><h2>  Pengosongan balok </h2><br>  Sebagian besar waktu, PPU konsol menarik piksel ke layar.  Ada waktu henti singkat di antara frame saat rendering tidak dilakukan.  Fenomena ini disebut blanking (Vertical Blank, atau vblank).  Beberapa jenis perubahan konfigurasi PPU hanya dapat dilakukan selama vblank. <br><br><h2>  Daftar gulir </h2><br>  Game mengubah posisi gulir dengan menulis ke register PPU yang disebut <code>PPUSCROLL</code> , yang memetakan ke alamat memori <code>0x2005</code> .  Operasi penulisan pertama dalam <code>PPUSCROLL</code> mendefinisikan komponen X dari posisi gulir, dan operasi kedua mengatur komponen Y. Demikian pula, perekaman alternatif dilakukan lebih lanjut. <br><br>  Berikut ini menunjukkan semua operasi penulisan bukan-nol dalam <code>PPUSCROLL</code> selama pemutaran ini (dalam gerakan lambat) 16 frame layar dengan alur permainan.  Komponen posisi gulir Y bertambah setiap dua frame.  Semua operasi penulisan dalam <code>PPUSCROLL</code> dalam contoh ini dilakukan selama vblank, yang menyebabkan seluruh latar belakang bergeser bersamanya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Scrolling Screen Split </h3><br>  Operasi tulis ke <code>PPUSCROLL</code> selama vblank berlaku pada awal frame yang diambil segera setelah vblank.  Jika posisi gulir berubah selama rendering frame (mis., Tidak selama vblank), maka perubahan ini berlaku ketika gambar mencapai baris piksel berikutnya.  Pengguliran horizontal sebagian diimplementasikan dengan menulis ke <code>PPUSCROLL</code> sementara PPU menggambar baris piksel terakhir sebelum menggulir. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  Saat memperbarui posisi gulir di tengah bingkai, hanya posisi X posisi gulir yang diterapkan.  Yaitu, komponen posisi gulir Y dibuang.  Dengan demikian, jika game ingin membagi layar dan mengubah posisi menggulir bagian dari frame, itu hanya dapat menggulir secara horizontal. <br><br>  Namun demikian: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  Percaya atau tidak, nilai register <code>PPUSCROLL</code> tidak berubah selama transisi ini. <br><br>  Anda dapat melihat artefak grafis satu piksel tinggi di bawah antarmuka.  Ini adalah bug dari emulator saya yang disebabkan oleh kurangnya sinkronisasi siklus jam prosesor dengan rendering piksel-demi-piksel. <br><br><h3>  Intervensi dalam register lain </h3><br>  Register kedua, disebut <code>PPUADDR</code> , dipetakan ke alamat memori <code>0x2006</code> , digunakan untuk mengatur alamat memori video saat ini.  Ketika sebuah game, misalnya, ingin mengubah salah satu ubin di tabel nama, pertama-tama ia menulis alamat memori video <code>PPUADDR</code> ke <code>PPUADDR</code> , dan kemudian menulis nilai baru <code>PPUDATA</code> ke <code>PPUDATA</code> - ini adalah register ketiga yang dipetakan ke alamat <code>0x2007</code> . <br><br>  Menulis ke <code>PPUADDR</code> tidak selama vblank (mis. Saat merender bingkai) dapat menyebabkan artefak grafis.  Ini karena rantai PPU, yang dipengaruhi oleh penulisan ke <code>PPUADDR</code> , juga secara langsung dikendalikan oleh perangkat PPU dalam proses mendapatkan ubin dari memori video untuk menggambar mereka.  Karena proses rendering ke layar dilakukan dari atas ke bawah, dan dari kiri ke kanan dalam garis, PPU pada dasarnya memberikan <code>PPUADDR</code> nilai alamat dari <code>PPUADDR</code> saat ini <code>PPUADDR</code> ditarik.  Saat merender perpindahan dari satu ubin ke ubin lain, <code>PPUADDR</code> bertambah dengan nilai saat ini. <br><br>  Dengan demikian, menulis ke <code>PPUADDR</code> di tengah bingkai dapat mengubah ubin yang diterima oleh PPU dari memori selama bingkai saat ini. <br><br>  Mari kita <code>PPUADDR</code> operasi penulisan ke <code>PPUADDR</code> selama lompatan vertikal.  Karena tabel nama juga diperbarui selama transisi, output dari <em>semua</em> operasi penulisan ke <code>PPUADDR</code> akan terlalu luas.  Dengan transisi horizontal, pengguliran diatur selama rendering deretan piksel 63, oleh karena itu, kami akan mempertimbangkan operasi penulisan dalam <code>PPUADDR</code> hanya selama baris ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  Polanya terlihat jelas.  Setiap dua frame, alamat yang direkam dalam garis piksel 63 dikurangi sebesar 32 (0x20).  Tetapi bagaimana hal ini menyebabkan pembaruan dalam posisi gulir yang sebenarnya? <br><br><h3>  Daftar Scrolling <i>Nyata</i> </h3><br>  Di dalam PPU ada register 15-bit yang tidak dipetakan ke CPU.  Ini digunakan baik sebagai alamat saat ini untuk mengakses memori video, dan sebagai konfigurasi pengguliran latar belakang. <br><br>  Ketika bekerja dengan nilai ini sebagai alamat, bit 14 diabaikan, dan bit 0-13 diperlakukan sebagai alamat dalam memori video. <br><br>  Ketika bekerja dengan nilai ini sebagai konfigurasi pengguliran, bagian-bagiannya yang berbeda memiliki arti yang berbeda: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>Memilih tabel nama</strong> adalah nilai dari 0 hingga 3 yang menentukan tabel nama saat ini dari mana gambar dibuat. <br><br>  <strong>Pengguliran kasar di X</strong> dan <strong>Pengguliran kasar di Y</strong> menentukan koordinat ubin di dalam tabel nama yang dipilih.  Ini adalah ubin saat ini untuk menggambar. <br><br>  <strong>Pengguliran yang tepat di sepanjang Y</strong> berisi nilai dari 0 hingga 7, yang menentukan offset vertikal saat ini dari garis piksel di dalam ubin saat ini.  Ubin adalah bujur sangkar dengan sisi 8 piksel. <br><br>  <strong>Pengguliran yang tepat pada X</strong> tidak ada dalam daftar ini.  Ada register terpisah yang hanya berisi offset horizontal piksel saat ini, tetapi tidak penting untuk menjelaskan bagaimana pengguliran vertikal dilakukan dalam The Legend of Zelda. <br><br>  Apa yang terjadi pada register ini ketika sebuah game menulis ke <code>PPUADDR</code> ?  Berikut adalah tiga operasi penulisan pertama dari demo yang ditunjukkan di atas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  Dengan memecah entri di alamat menjadi komponen gulir, Anda dapat dengan jelas memahami apa yang terjadi di sini.  Setiap dua frame, nilai <strong>scrolling kasar di Y</strong> berkurang, yang mengarah ke scrolling vertikal dengan satu ubin atau 8 piksel. <br><br>  Sepanjang setiap frame, offset gulir awal adalah 0,0, setelah itu perekaman pada garis piksel 63 dilakukan pada alamat.  Ini berarti bahwa 63 garis piksel pertama diambil dari bagian atas tabel nama yang dipilih yang berisi latar belakang antarmuka.  Namun, baris piksel ke-64 lebih lanjut diberikan dengan pengguliran vertikal yang diterapkan dari alamat ini.  Karena pengguliran vertikal berkurang setiap dua frame, itu memberi perasaan pengguliran vertikal dari bagian layar. <br><br><h3>  Gulir ke bawah untuk menggulir ke atas </h3><br>  The Legend of Zelda tidak dapat menyembunyikan trik ini dari pemain sepenuhnya.  Ini menciptakan artefak yang terlihat pada transisi vertikal layar, yang terlihat jika Anda melihat dari dekat.  Saat bergerak di antara kamar, bingkai pertama dari animasi yang bergulir akan bergulir ke bawah.  Inilah animasi dalam gerakan yang sangat lambat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  Dalam daftar nama, Anda dapat melihat apa yang sebenarnya terjadi.  Meskipun tampaknya bagi para pemain bahwa area yang terlihat akan menggulir ke atas dengan lancar, transisi gulir dimulai dengan memindahkan area yang terlihat dari tabel kiri atas nama ke tabel kiri bawah, yang berisi salinan latar belakang ruangan.  Ini diperlukan karena antarmuka di bagian atas layar juga merupakan bagian dari tabel nama, dan jika area yang terlihat digulir ke atas dari posisi aslinya, ia akan melewati antarmuka. <br><br>  Pengguliran vertikal dilakukan dengan menulis ke register <code>PPUADDR</code> di tengah bingkai.  Nilai pertama yang ditulis adalah <code>0x2800</code> .  Dua frame kemudian, <code>0x23A0</code> direkam, dan kemudian nilainya mulai berkurang 32 setiap frame kedua. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  Menulis nilai <code>0x2800</code> ke register <code>0x2800</code> <code>PPUADDR</code> <strong>Tabel</strong> <code>PPUADDR</code> menjadi 2, yang menjadikan tabel nama kiri bawah.  Karena kedua nilai gulir adalah 0, itu akan mulai dari ubin kiri atas tabel nama ini.  Namun, <strong>Penggulungan yang tepat dalam Y</strong> adalah 2, sehingga ada offset vertikal dua-piksel dari bagian atas tabel nama kiri bawah.  Itu sebabnya dalam frame transisi pertama, kita melihat bar hitam 2 piksel tinggi di bagian bawah layar.  Nilai gulir awal untuk animasi transisi digeser 2 piksel ke bawah untuk membuat transisi mulus. <br><br>  Dua frame kemudian, <code>PPUADDR</code> ditulis ke <code>0x23A0</code> .  Ini membawa kita kembali ke tabel kiri atas nama, dan kita membuat dari baris ubin ke 29, yaitu bagian bawah.  <strong>Pengguliran yang tepat di Y</strong> masih berisi 2. <br><br>  Mengapa perlu <strong>mengatur Exact Scrolling di Y</strong> ke 2?  Mengapa permainan tidak menulis <code>0x0800</code> dan <code>0x03A0</code> agar tidak menderita offset dua piksel? <br><br>  Empat tabel nama menempati area 4 KB di ruang alamat PPU, dari <code>0x2000</code> hingga <code>0x2FFF</code> .  Setiap ubin dalam tabel menempati satu byte memori video (pada kenyataannya, mereka hanya indeks di tabel lain), dan urutan ubin dan tabel nama dalam memori video sedemikian rupa sehingga <strong>Memilih tabel nama</strong> , <strong>Pengguliran kasar oleh Y</strong> dan <strong>Pengguliran kasar oleh X</strong> membuat ubin diimbangi di dalam area memori dengan tabel nama.  Artinya, dengan mengambil 12 bit yang lebih rendah dari register PPU internal dan menambahkannya ke <code>0x2000</code> , Anda dapat menemukan alamat <code>0x2000</code> di memori video.  Dan ini bukan kebetulan!  Inilah tepatnya bagaimana register harus ditangani: baik sebagai register alamat maupun sebagai register gulir. <br><br>  Tapi ada satu kekurangan. <br><br>  Saat memproses sebagai register alamat, bit 12 dan 13 dianggap sebagai bagian dari alamat.  Selama rendering, PPU terus-menerus menimpa register dengan alamat ubin yang diberikan saat ini.  Karena <code>0x2FFF</code> terletak di tabel nama, dan tabel terletak di area memori dari <code>0x2000</code> hingga <code>0x2FFF</code> , PPU memberikan nilai dari interval ini ke register. <br><br>  Ketika permainan menulis ke <code>PPUADDR</code> di tengah bingkai, jika tidak menuliskan alamat ubin di tabel nama, maka PPU akan mencoba membaca <em>dari tempat lain</em> di memori video.  Setiap byte yang ia hitung akan dianggap sebagai ubin, yang cenderung mengarah pada hasil yang tidak diinginkan.  Oleh karena itu, semua nilai yang direkam di tengah bingkai di <code>PPUADDR</code> harus berada dalam kisaran <code>0x2000</code> hingga <code>0x2FFF</code> .  Dengan mengambil setiap angka dalam interval ini dan memperhitungkan komponen gulirnya, nilai <strong>Pengguliran yang tepat dalam Y</strong> harus selalu sama dengan 2. <br><br>  Batasan ini berarti bahwa kita tidak dapat mengubah <strong>Pengguliran yang tepat ke</strong> arah <strong>Y</strong> di tengah bingkai, yaitu, ketika menggunakan trik ini untuk menerapkan pengguliran vertikal pemisahan layar, kita dibatasi untuk menggulir 8 piksel sekaligus dan selalu memiliki offset vertikal dua piksel dari batas ubin.  The Legend of Zelda bergerak 4 piksel per bingkai saat menggulir secara horizontal, tetapi 8 piksel per bingkai saat menggulir secara vertikal, dan sekarang kita tahu sebabnya. <br><br>  Artefak ini juga terlihat ketika menggulir di antara ruang-ruang di bawah, tetapi dalam hal ini terjadi pada akhir animasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Bacaan tambahan </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wiki NesDev</a> adalah sumber yang sangat berharga untuk mempelajari perangkat keras NES.  Secara khusus, subjek posting ini adalah halaman tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggulir PPU</a> <br>  dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">register PPU</a> . </li><li>  Emulator NES saya yang masih sangat belum selesai tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </li></ul><br><h2>  Catatan </h2><br>  Sampai saya mengetahui tentang register internal PPU, emulator saya menunjukkan efek menghapus selama transisi vertikal layar The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  Sprite tautan bergerak ke bawah layar, sebagaimana mestinya, tetapi latar belakangnya tidak bergulir.  Penghapusan ini disebabkan oleh kenyataan bahwa permainan secara bertahap memperbarui daftar nama sehingga berisi grafik ruang baru, tetapi tidak memperbarui gulir untuk menjaga pembaruan di luar layar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id460383/">https://habr.com/ru/post/id460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id460367/index.html">Chaos Engineering: seni kehancuran yang disengaja. Bagian 1</a></li>
<li><a href="../id460373/index.html">Di Balik Terpal Halaman Turbo: Arsitektur Teknologi Unduhan Cepat Halaman Web</a></li>
<li><a href="../id460375/index.html">Buku "Pembelajaran Mesin untuk Bisnis dan Pemasaran"</a></li>
<li><a href="../id460377/index.html">Menggunakan Liquibase untuk mengelola struktur database dalam aplikasi Spring Boot. Bagian 1</a></li>
<li><a href="../id460381/index.html">Apa itu ketegasan dan mengapa itu dibutuhkan</a></li>
<li><a href="../id460387/index.html">Panduan SELinux Beginner</a></li>
<li><a href="../id460393/index.html">Latar belakang: apa yang diharapkan dari Fedora Silverblue</a></li>
<li><a href="../id460395/index.html">Analytics sebagai fitur: proses bekerja dengan data di Plesk</a></li>
<li><a href="../id460397/index.html">Mulai cepat dengan WebComponents</a></li>
<li><a href="../id460399/index.html">Indikator pemuatan SVG di Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>