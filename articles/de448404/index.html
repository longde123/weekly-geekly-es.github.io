<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🌾 🔯 🚩 So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Beispiels der Yandex.Direct-API (Teil 2) 🧖🏽 🚶🏻 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel habe ich über Multithreading gesprochen und Beispiele für seine Implementierung in der R-Sprache bei der Arbeit mit der Yandex.Dire...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Beispiels der Yandex.Direct-API (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448404/"><p> Im letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel habe</a> ich über Multithreading gesprochen und Beispiele für seine Implementierung in der R-Sprache bei der Arbeit mit der Yandex.Direct-API unter Verwendung der <code>doParallel</code> <code>doSNOW</code> , <code>doParallel</code> und <code>foreach</code> Konstrukt gegeben. </p><br><p>  Dieser Artikel ist eine Fortsetzung, kann aber als autonomer Leitfaden für Multithreading in R angesehen werden. Ich wurde aufgefordert, ihn durch die im ersten Teil eingegangenen Kommentare (hier ein besonderer Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Alexey_mosc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SatCat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Ananiev_Genrih</a> ) zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">schreiben</a> , in denen mir eine Reihe von Paketen gegeben wurden, die einen moderneren Ansatz darstellen Implementierungen von Multithreading in R, wir werden später darüber sprechen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/302/1a1/570/3021a15709dae984b328e3af5364d1de.png" alt="Multithreading"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herausforderung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorbereitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel für eine serielle Verarbeitungslösung, Sapply-Funktion und Purrr-Paket</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sapply-Funktion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Purrr-Paket</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multithread-Optionen zum Lösen der Aufgabe, Schlüsselwörter von Yandex.Direct zu sammeln</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paralleles Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zukünftiges Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wrapper über die Zukunft</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future.apply-Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Furrr Paket</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geschwindigkeitstest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li><li>  Umfrage </li></ul><br><h1 id="zadacha">  Herausforderung </h1><br><p>  Als Beispiel nehmen wir das in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">früheren Veröffentlichung</a> betrachtete Problem, d.h.  Sammeln Sie im Multithread-Modus eine Liste mit Keywords aus 4 Yandex.Direct-Werbekonten. </p><br><p>  Um mit der Yandex.Direct-API zu arbeiten, verwenden wir das <code>ryandexdirect</code> Paket.  Die offizielle Dokumentation dazu befindet sich auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> , aber für die Implementierung der beschriebenen Aufgabe benötigen wir nur 2 Funktionen: </p><br><ul><li>  <code>yadirAuth</code> - Autorisierung in der Yandex.Direct-API; </li><li>  <code>yadirGetKeyWords</code> - Laden Sie eine Liste mit Keywords von Anzeigenkonten herunter. </li></ul><br><p>  Es ist nicht nur so, dass ich mich für das Herunterladen von Schlüsselwörtern entschieden habe, sondern dass dies eine der langwierigsten Vorgänge in der Yandex.Direct-API ist.  Zweitens ist in allen Konten die Anzahl der Schlüsselwörter unterschiedlich, daher ist die Zeit zum Ausführen dieses Vorgangs für jedes Konto sehr unterschiedlich, in unserem Fall von 1 bis 20 Sekunden. </p><br><h1 id="podgotovka">  Vorbereitung </h1><br><p>  Zunächst müssen Sie alle in diesem Artikel beschriebenen Pakete installieren. Dazu können Sie den folgenden Code verwenden. </p><br><div class="spoiler">  <b class="spoiler_title">Code 1: Installieren von Paketen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    install.packages("ryandexdirect") install.packages("tictoc") install.packages("rbenchmark") install.packages("dplyr") install.packages("purrr") install.packages("future") install.packages("promises") install.packages("furrr") install.packages("future.apply")</code> </pre> </div></div><br><p>  Damit Ihnen Paketfunktionen zur Verfügung stehen, müssen Sie sie mit dem Befehl <code>library</code> .  Der Einfachheit halber werde ich alle erforderlichen Pakete in jedem gegebenen Codebeispiel separat verbinden. </p><br><p>  Wir erstellen einen Vektor, der aus Yandex.Direct-Anmeldungen besteht, von denen wir später Schlüsselwörter anfordern werden: </p><br><div class="spoiler">  <b class="spoiler_title">Code 2: Erstellen eines Anmeldevektors</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">logins &lt;- c("login1", "login2", "login3", "login4")</code> </pre> </div></div><br><p>  Um mit der Yandex.Direct-API arbeiten zu können, müssen Sie zunächst die Autorisierung für jedes Konto durchlaufen. Dazu können Sie das folgende Design verwenden: </p><br><div class="spoiler">  <b class="spoiler_title">Code 3: Autorisierung in der Yandex.Direct-API</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">lapply(logins, function(l) { yadirAuth(Login = l)})</code> </pre> </div></div><br><p>  Nach dem Ausführen des obigen Codes wird unter jedem Konto ein Browser zur Autorisierung geöffnet.  Sie bestätigen die Erlaubnis von <code>ryandexdirect</code> , auf Ihre Werbematerialien zuzugreifen.  Sie werden zu der Seite weitergeleitet, auf der Sie den Bestätigungscode kopieren müssen.  Schließen Sie den Autorisierungsprozess ab, indem Sie es in die R-Konsole eingeben.  Dieser Vorgang wird für jede Anmeldung wiederholt, die Sie beim Erstellen der Vektoranmeldungen angegeben haben. </p><br><p>  Einige Benutzer sind während des Autorisierungsprozesses möglicherweise durch die Umleitung zu einer Ressource eines Drittanbieters verwirrt. Es besteht jedoch keine Gefahr für Ihr Konto. Ich habe dieses Thema im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie sicher es ist, R-Pakete für die Arbeit mit APIs für Werbesysteme zu verwenden"</a> ausführlicher beschrieben. </p><br><p>  Als nächstes werden wir einige Beispiele für die Implementierung der beschriebenen Aufgabe betrachten.  Jedes davon beginnt mit einem Beispielcode und seiner weiteren Erklärung.  Ich denke, diese Option ist für die Wahrnehmung am bequemsten. </p><br><h1 id="primer-resheniya-v-posledovatelnom-rezhime-obrabotki-funkciya-sapply-i-paket-purrr">  Beispiel für eine serielle Verarbeitungslösung, Sapply-Funktion und Purrr-Paket </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/72e/9d8/36972e9d8707c1c508d2e43b8721778c.jpg"><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel habe</a> ich eine Lösung am Beispiel der <code>for</code> Schleife angeführt.  Da wir Multithreading mit dem <code>foreach</code> Paket in Betracht gezogen haben, dessen Syntax Schleifen ähnelt, war dieses Beispiel dort angemessen, obwohl die Verwendung von Schleifen von Benutzern von R nicht begrüßt wird. </p><br><p>  Die Pakete, die wir in diesem Artikel betrachten werden, erinnern eher an die Funktionen der Apply-Familie in der Syntax. Daher werde ich ein Beispiel für eine Lösung im seriellen Modus geben, die sie verwendet. </p><br><h3 id="funkciya-sapply">  <code>sapply</code> Funktion </h3><br><blockquote>  Um die Ausführungszeit von Befehlen abzuschätzen, verwenden wir in jedem der betrachteten Ansätze das <code>tictoc</code> Paket. </blockquote><br><div class="spoiler">  <b class="spoiler_title">Code 4: Beispiellösung im sequentiellen Modus mit Sapply-Funktion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(tictoc) library(dplyr) tic() #   kw.sapply &lt;- sapply( logins, #  ,     function(x) #        #     { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE #     ) toc() #   #       result.sapply &lt;- do.call("rbind", kw.sapply)</code> </pre> </div></div><br><p>  <code>39.36 sec elapsed</code> : <code>39.36 sec elapsed</code> </p><br><p>  Zunächst ist die Syntax der Funktionen der <code>apply</code> Familie nicht so einfach zu lesen wie die Syntax von Schleifen, aber tatsächlich ist alles recht einfach. </p><br><p> <code>sapply(X, FUN)</code> </p> <br><p>  Wo: </p><br><ul><li>  <em>X</em> - Ein Objekt, dessen Elemente wir bei jeder Iteration durchlaufen und nacheinander verwenden werden. In einer <code>for</code> Schleife sah es folgendermaßen aus: <code>for(i in X)</code> ; </li><li>  <em>FUN</em> - Eine Funktion, bei der wir nacheinander jedes Element des Objekts <em>X</em> ersetzen. Wenn wir eine Analogie mit <code>for</code> , ist dies der Körper der Schleife. </li></ul><br><p>  In Codebeispiel <strong>4</strong> wird der zuvor erstellte <em>Anmeldevektor</em> an das <em>X-</em> Argument übergeben.  Jedes Element des <em>Anmeldevektors</em> wird nacheinander als einziges Argument an die anonyme Funktionsfunktion <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> , die an das <em>FUN-</em> Argument übergeben wurde. </p><br><p>  Das heißt,  <code>sapply</code> führt die in <em>FUN</em> angegebene Funktion viermal aus, ersetzt sie nacheinander und gibt das Ergebnis in Form einer Liste (Objekt der Klassenliste) zurück, die aus vier Elementen besteht.  Jedes Element ist eine Tabelle mit einer Liste von Schlüsselwörtern, die bei jeder Iteration vom Konto empfangen werden. </p><br><ol><li> <code>yadirGetKeyWords(Login = "login1") %&gt;% mutate(login = "login1")</code> </li> <li> <code>yadirGetKeyWords(Login = "login2") %&gt;% mutate(login = "login2")</code> </li> <li> <code>yadirGetKeyWords(Login = "login3") %&gt;% mutate(login = "login3")</code> </li> <li> <code>yadirGetKeyWords(Login = "login4") %&gt;% mutate(login = "login4")</code> </li> </ol><br><p>  Das mit <code>sapply</code> erhaltene <code>sapply</code> hat folgende Struktur: </p><br><pre> <code class="plaintext hljs">summary(kw.sapply)</code> </pre> <br><pre> <code class="plaintext hljs"> Length Class Mode login1 19 data.frame list login2 19 data.frame list login3 19 data.frame list login4 19 data.frame list</code> </pre> <br><p>  Am Ende dieses Beispiels <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> der Befehl <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> alle 4 Elemente der <em>kw.sapply-</em> Liste in einem einzigen <em>result.sapply-</em> Frame. </p><br><pre> <code class="plaintext hljs"># A tibble: 6,804 x 1 result.sapply$Id $Keyword $AdGroupId $CampaignId $ServingStatus $State &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; 1 15164230566 ~ 3597453985 39351725 ELIGIBLE ON 2 15164230567  ~ 3597453985 39351725 ELIGIBLE ON 3 15164230568  ~ 3597453985 39351725 ELIGIBLE ON 4 15164230569 ~ 3597453985 39351725 ELIGIBLE ON 5 15164230570 ~ 3597453985 39351725 ELIGIBLE ON 6 15164230571  ~ 3597453985 39351725 ELIGIBLE ON 7 15164230572 ~ 3597453985 39351725 ELIGIBLE ON 8 15164230573  ~ 3597453985 39351725 ELIGIBLE ON 9 15164230574 ~ 3597453985 39351725 ELIGIBLE ON 10 15164230575 ~ 3597453985 39351725 ELIGIBLE ON # ... with 6,794 more rows, and 13 more variables: $Status &lt;fct&gt;, # $StrategyPriority &lt;fct&gt;, $StatisticsSearchImpressions &lt;int&gt;, # $StatisticsSearchClicks &lt;int&gt;, $StatisticsNetworkImpressions &lt;int&gt;, # $StatisticsNetworkClicks &lt;lgl&gt;, $UserParam1 &lt;chr&gt;, $UserParam2 &lt;chr&gt;, # $ProductivityValue &lt;lgl&gt;, $ProductivityReferences &lt;lgl&gt;, $Bid &lt;dbl&gt;, # $ContextBid &lt;dbl&gt;, $login &lt;chr&gt;</code> </pre> <br><p>  Zusätzlich zu <code>sapply</code> umfasst die Funktionsfamilie <code>*apply</code> : <code>apply</code> , <code>lapply</code> , <code>vapply</code> , <code>mapply</code> und andere. </p><br><h3 id="paket-purrr">  <code>purrr</code> Paket </h3><br><div class="spoiler">  <b class="spoiler_title">Code 5: Beispiellösung mit den Funktionen des Purrr-Pakets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) library(dplyr) library(tictoc) tic() #   result.purrr &lt;- map_df( logins, #  ,     ~ #   function(.x) { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) toc() #  </code> </pre> </div></div><br><p>  <code>35.46 sec elapsed</code> : <code>35.46 sec elapsed</code> </p><br><p>  Das <code>purrr</code> Paket ist Teil des Kerns der von Headley Wickham verfassten <code>tidyverse</code> Bibliothek. </p><br><p>  In Bezug auf Bedeutung und Syntax sind die Hauptfunktionen des Pakets <code>sapply</code> sehr ähnlich. <code>sapply</code> Hauptvorteil ist folgender: </p><br><ul><li>  Die Funktionen sind in Familienkarten, <code>map2</code> , <code>pmap</code> , <code>walk</code> usw. unterteilt. Separate Funktionen derselben Familie geben das Ergebnis in verschiedenen Formaten zurück: <em>chr</em> , <em>dbl</em> , <em>int</em> , <em>df</em> usw.; </li><li>  Mit den Funktionen der <code>map2</code> Familie <code>map2</code> Sie Elemente (iterieren) von zwei Objekten gleichzeitig <code>map2</code> . </li><li>  Mit den Funktionen der <code>pmap</code> Familie <code>pmap</code> Sie gleichzeitig Elemente einer beliebigen Anzahl von Objekten <code>pmap</code> .  Sie können eine Tabelle an die Eingabe an das Argument <em>.l übergeben</em> <em>(ein Analogon des X-Arguments in sapply)</em> , dessen jede Spalte die Werte enthält, mit denen Sie iterieren, und die wiederum durch die Argumente derselben Funktion ersetzt werden, die in <em>.f</em> <em>(dem FUN-Analogon von) übergeben wird sapply)</em> . </li></ul><br><p>  In welcher Situation müssen wir Elemente mehrerer Objekte durchlaufen.  Sie arbeiten beispielsweise mit mehreren Agentenkonten, und Werbekonten, von denen Sie eine Liste mit Schlüsselwörtern erhalten möchten, sind zwischen diesen verteilt.  In diesem Fall können Sie aus den Namen der Agentenkonten einen Vektor erstellen und diesen durchlaufen, parallel dazu, wie Sie die Anmeldungen der Werbekonten sortieren. </p><br><div class="spoiler">  <b class="spoiler_title">Code 6: Beispiel für die Arbeit mit mehreren Agentenkonten</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #      agencies &lt;- c("agency1", NA, "agency2", "agency1") #      #         result.pmap2 &lt;- map2_df(.x = logins, .y = agencies, ~ { yadirGetKeyWords(Login = .x, AgencyAccount = .y) %&gt;% mutate(login = .x) })</code> </pre> </div></div><br><p>  Stellen Sie sich nun die Situation vor, dass Sie, wenn Sie sich unter verschiedenen Konten angemeldet haben, die Datei mit den Anmeldeinformationen in verschiedenen Ordnern gespeichert haben und dann sofort drei Objekte durchlaufen müssen: Anmeldungen von Werbekonten, Anmeldungen von Agentenkonten, den Pfad, in dem die Datei mit den Anmeldeinformationen gespeichert ist.  Dies kann mit Hilfe erfolgen.  <code>pmap</code> Familienfunktionen. </p><br><div class="spoiler">  <b class="spoiler_title">Code 7: Beispiel für eine pmap-Funktion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #  ,       #      TokenPath &lt;- c("C:\\proj1\\tokens", "C:\\yandex\\token", "C:\\yandex\\token", "C:\\my_yandex_acoount") #   pmap.result &lt;- pmap_df(list(Login = logins, AgencyAccount = agencies, TokenPath = TokenPath), yadirGetKeyWords)</code> </pre> </div></div><br><p>  Dementsprechend ist das Ergebnis der Ausführung der Funktionen <code>map_df</code> , <code>map2_df</code> und <code>pmap_df</code> der <code>pmap_df</code> , und bei deren Verwendung ist der letzte Schritt aus dem Beispiel mit <code>sapply</code> ( <code>do.call("rbind", kw.sapply)</code> ) nicht erforderlich. </p><br><p>  Der Code ist kompakter geworden und wird etwas schneller ausgeführt. <code>purrr</code> sammeln beide beschriebenen Ansätze, <code>sapply</code> und <code>purrr</code> , nacheinander Schlüsselwörter von jedem Konto.  Daher ist die Gesamtausführungszeit dieser Operation gleich der Summe der Dauer der Datenerfassung von allen vier Konten. </p><br><p>  <strong>Zeit [gesamt]</strong> = <em>Zeit [login1] + Zeit [login2] + Zeit [login3] + Zeit [login4]</em> </p><br><h1 id="mnogopotochnye-varianty-resheniya-zadachi-po-sboru-klyuchevyh-slov-iz-yandeksdirekt">  Multithread-Optionen zum Lösen der Aufgabe, Schlüsselwörter von Yandex.Direct zu sammeln </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/53c/cf5/ab353ccf566421eaaa6ec3d6445399a1.jpg"></p><br><p>  Wenn Sie also bereits den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> gelesen haben, wissen Sie, dass der Multithread-Betriebsmodus mehrere Funktionen hat: </p><br><ul><li>  Jeder Thread startet in einer separaten R-Sitzung mit einer sauberen Arbeitsumgebung. </li><li>  Aus dem gleichen Grund werden in einem separaten laufenden Prozess zuvor verbundene Pakete nicht standardmäßig übertragen. </li></ul><br><p>  Das Exportieren von Objekten, die in einer Arbeitsumgebung erstellt wurden, und das Verbinden von Paketen in jedem Ansatz wird unterschiedlich implementiert. Anschließend werden wir sie genauer betrachten. </p><br><h3 id="paket-parallel">  <code>parallel</code> Paket </h3><br><p>  Dieses Paket wurde erstmals in Version 2.14.0 in das R-Paket aufgenommen und wird bis heute mit R selbst geliefert. </p><br><div class="spoiler">  <b class="spoiler_title">Code 8: Beispiellösung für das Problem durch das Parallelpaket</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictoc) #   cl &lt;- makeCluster(4) #      clusterExport(cl = cl, varlist = "logins") #  ,      #  ,       ryandexdirect clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) tic() #   parallel.kw &lt;- parSapplyLB(cl = cl, #   X = logins, # ,     FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) #    toc() #     #   stopCluster(cl) #      result.parallel &lt;- dplyr::bind_rows(parallel.kw)</code> </pre> </div></div><br><p>  <code>16.75 sec elapsed</code> : <code>16.75 sec elapsed</code> </p><br><p>  Versuchen wir, <strong>Code 8</strong> zu analysieren.  Die Funktion <code>makeCluster</code> erstellt einen Cluster von 4 Prozessen.  Mit der Funktion <code>clusterExport</code> können wir Objekte aus unserer Hauptarbeitsumgebung in den erstellten Cluster <code>clusterExport</code> Dazu müssen wir die folgenden Argumente verwenden: </p><br><ul><li>  <em>cl</em> - Cluster, in den wir Objekte exportieren </li><li>  <em>varlist</em> - Ein <em>Textvektor</em> , der die Namen der Objekte enthält, die in jeden Clusterprozess exportiert werden sollen. </li></ul><br><p>  Eine Möglichkeit, die richtigen Pakete auf jedem Clusterknoten zu verbinden, besteht in der Verwendung der Funktion <code>clusterEvalQ</code> .  In unserem Beispiel verwenden wir es, um Pakete zu verbinden. Sie können jedoch einen beliebigen R-Code in <code>clusterEvalQ</code> schreiben. Der Code wird am Anfang jedes Clusterknotens gestartet.  Die Argumente für diese Funktion sind ziemlich offensichtlich. Sie müssen den Cluster und die Befehle angeben, die darin ausgeführt werden. </p><br><p>  <code>parSapplyLB</code> ist eine parallele Version der <code>sapply</code> Funktion mit Lastausgleich zwischen den Clusterknoten. Sie wird ebenfalls verwendet. Sie müssen den Cluster jedoch mit dem Argument <em>cl</em> angeben. </p><br><p>  <code>parallel</code> gibt es auch andere parallelisierte Versionen der Funktionen der <code>*apply</code> Familie: <code>parLapply</code> , <code>parSapply</code> , <code>parApply</code> usw. </p><br><p>  <code>parSapply</code> unterscheidet sich von <code>parSapplyLB</code> nur dadurch, dass es keinen Lastausgleich auf Clusterknoten gibt. </p><br><p>  Mit der Funktion <code>stopCluster</code> wird der erstellte Cluster gestoppt. </p><br><p>  Mit dem letzten Befehl, <code>dplyr::bind_rows(parallel.kw)</code> kombinieren wir das mit <code>parSapplyLB</code> erhaltene <em>parallel.kw-</em> Objekt in einer Tabelle. </p><br><p>  Für Linux hat <code>parallel</code> separate Funktionen: <code>mclapply</code> , <code>mcmapply</code> , <code>mcMap</code> .  In diesem Betriebssystem werden Befehle häufig schneller ausgeführt und der Code wird kompakter. </p><br><div class="spoiler">  <b class="spoiler_title">Code 9: Lösung mit mclapply für Linux</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictic) library(dplyr) library(ryandexdirect) tic() mclapply.kw &lt;- mclapply(logins, FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, mc.cores = 4) toc()</code> </pre> </div></div><br><p>  Bei Verwendung dieser Funktionen muss der Cluster nicht mit dem <code>makeCluster</code> .  Die Anzahl der Knoten, die Sie mit dem Argument <em>mc.cores angeben</em> .  Es ist auch nicht erforderlich, Pakete zu verbinden und Objekte zu exportieren. Diese Vorgänge werden automatisch ausgeführt. </p><br><h3 id="paket-future">  <code>future</code> Paket </h3><br><p>  Einer der modernsten Ansätze zur asynchronen Programmierung in R. </p><br><p>  Ein Code, der parallel unser Problem mit Hilfe der <code>future</code> lösen wird, ist kompliziert genug, um verstanden zu werden.  Lassen Sie uns daher die Arbeit an einem einfacheren Beispiel analysieren. Wir fordern eine Liste mit Schlüsselwörtern von einem Konto an. </p><br><div class="spoiler">  <b class="spoiler_title">Code 10: Das einfachste Beispiel für die Verwendung des zukünftigen Pakets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) #    plan(multiprocess) #      #    future.kw &lt;- future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins") #     resolved(future.kw) #     future.result.1 &lt;- value(future.kw)</code> </pre> </div></div><br><p>  Versuchen wir, das <strong>Code 10-</strong> Beispiel herauszufinden.  Mit der <code>plan</code> können Sie den Ausführungsmodus der angegebenen Ausdrücke festlegen und ändern. Hier sind die wichtigsten: </p><br><ul><li>  <em>sequentiell</em> - Dies ist die übliche R-Betriebsart. Befehle werden in der aktuellen Sitzung sequentiell ausgeführt. </li><li>  <em>Multisession</em> - Im parallelen Modus werden die Befehle in den laufenden Sitzungen im Hintergrund auf dem aktuellen Computer ausgeführt, während Ihre Arbeitssitzung nicht blockiert wird. </li><li>  <em>Cluster</em> - Paralleler Modus: Die Befehle werden auf dem aktuellen oder Remote-Computer ausgeführt, ähnlich wie sie im <code>parallel</code> Paket implementiert sind. </li></ul><br><p>  Das gesamte <code>future</code> Paket basiert auf der Ausführung von Befehlen in Hintergrundprozessen, ohne die aktuelle Sitzung zu blockieren.  Das Ausführen der Ausführung von Befehlen folgt der gleichnamigen Funktion <code>future</code> . Wenn wir also den Befehl ausführen: </p><br><pre> <code class="plaintext hljs">future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins")</code> </pre> <br><p>  Unsere aktuelle Sitzung in R ist nicht blockiert, und der Befehl wird im Hintergrund ausgeführt, wobei eine weitere R-Sitzung ausgeführt wird. </p><br><p>  Mit der <code>resolved</code> Funktion können Sie den aktuellen Status des Ausführungsprozesses eines bestimmten Ausdrucks überprüfen.  Schließlich wird die <code>value</code> verwendet, um das Ergebnis der <code>future</code> Ausführung zu erhalten.  Wenn Sie die <code>value</code> früher als Ihre <code>future</code> Ausführung in einer parallel laufenden Sitzung ausführen, wird die aktuelle Arbeitssitzung blockiert, bis der Ausdruck für die parallele Sitzung abgeschlossen ist. </p><br><p>  Das fortschrittlichste Arbeitsbeispiel ist die Verwendung von <code>future</code> Verbindung mit <code>promises</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Code 11: Beispiel für das Teilen von Paketen mit "Zukunft" und "Versprechen"</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(promises) #    plan(multiprocess) #      #    future.kw &lt;- future({suppressMessages( yadirGetKeyWords(Login = logins[4]))}, packages = "ryandexdirect", globals = "logins") %...&gt;% #     future, #      nrow() %...&gt;% paste("words loaded") %...&gt;% print()</code> </pre> </div></div><br><p>  Das <code>promises</code> Paket bietet eine Reihe von Pipeline-Betreibern, die die <code>future</code> Funktionalität perfekt ergänzen. </p><br><p>  Im Beispiel von <strong>Code 11</strong> starten wir im Hintergrund den Prozess des Herunterladens von Keywords von einem Werbekonto.  Außerdem wartet der Pipeline-Betreiber <code>%...&gt;%</code> ohne die Arbeitssitzung zu blockieren, auf den Abschluss der <code>future</code> und führt die verbleibenden Vorgänge aus.  Als Ergebnis der Codeausführung wird nach Abschluss <code>future</code> Arbeiten die Anzahl der Schlüsselwörter des angegebenen Kontos in der Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">[1] "1855 words loaded"</code> </pre> <br><blockquote>  Am Ende des Artikels wird ein anschaulicheres Beispiel für eine Reihe von <code>future</code> und <code>promises</code> gezeigt. </blockquote><p>  Standardmäßig exportiert das <code>future</code> Paket selbst den gesamten Arbeitsbereich in jede parallel ausgeführte Sitzung. Sie können jedoch selbst eine Liste der zu exportierenden Objekte mithilfe des <em>globalen</em> Arguments <em>angeben</em> . </p><br><p>  Um Pakete mit der <code>future</code> zu verbinden <code>future</code> sollten <code>future</code> einen Vektor mit ihren Namen an das <em>Paketargument übergeben</em> . </p><br><p>  Zurück zu unserer Aufgabe: Im folgenden Codebeispiel im Parallelmodus wird eine Liste mit Schlüsselwörtern aus 4 Konten geladen: </p><br><div class="spoiler">  <b class="spoiler_title">Code 12: Ein Beispiel für die Lösung eines Problems mit dem zukünftigen Paket</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(tictoc) #   plan("multisession", workers = 4) tic() #   futs &lt;- lapply(logins, #      function(i) #        #   future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) #    kw &lt;- lapply(futs, value) #    toc() #    #     result.future &lt;- dplyr::bind_rows(kw)</code> </pre> </div></div><br><p>  Vorlaufzeit: <code>14.83 sec elapsed</code> </p><br><p>  Um eine Liste von Keywords im Multithread-Modus von allen in den Vektoranmeldungen aufgeführten Werbekonten herunterzuladen <em>, müssen</em> Sie im Hintergrund eine separate <code>future</code> ausführen.  In <code>lapply</code> <strong>12</strong> implementieren wir dies mit der Funktion <code>lapply</code> . </p><br><p>  Das Ergebnis von <code>lapply</code> ist eine Liste der <code>future</code> <code>lapply</code> .  Sie können den Status jedes einzelnen mit dem <code>sapply(futs, resolved)</code> überprüfen, der einen logischen Vektor <code>sapply(futs, resolved)</code> wobei <em>TRUE</em> bedeutet, dass die <code>future</code> erfüllt ist, und <em>FALSE,</em> dass die <code>future</code> gerade ausgeführt wird. </p><br><p>  Um Ergebnisse aus jeder <code>future</code> zu erhalten, verwenden wir nach Abschluss ihrer Arbeit den <code>lapply(futs, value)</code> . </p><br><p>          : <code>result.future &lt;- dplyr::bind_rows(kw)</code> . </p><br><h3 id="obyortki-nad-future">   <code>future</code> </h3><br><p>      ,      (   <br> <code>future</code> ),      . </p><br><h6 id="paket-futureapply">  <code>future.apply</code> </h6><br><p> <code>future.apply</code>     <code>future</code> ,  . </p><br><div class="spoiler"> <b class="spoiler_title"> 13:       future.apply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future.apply) library(tictoc) #    plan("multisession", workers = 4) tic() #   kw.future.apply &lt;- future_sapply(logins, #    ,   function(x) { #     yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, #    #   future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) toc() #   </code> </pre> </div></div><br><p>  : <code>17.28 sec elapsed</code> </p><br><p>   <strong> 13</strong> ,  <code>future.apply</code>         <code>future</code> ,         . </p><br><p>         4 : <code>plan("multisession", workers = 4)</code> . </p><br><p> <code>future_sapply</code>      <em>logins</em>    .  Das heißt,   ,  ,        <code>sapply</code> ,    . </p><br><p>      <code>future_sapply</code>    <em>future.packages</em> .             <em>future.globals</em> .       ,              . </p><br><h4 id="paket-furrr">  <code>furrr</code> </h4><br><p>     <code>future</code> .          <code>purrr</code> ,   <code>furrr</code>     . </p><br><div class="spoiler"> <b class="spoiler_title"> 14:      furrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(tictoc) #   cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) tic() #   furrr.kw &lt;- future_map(logins, ~ #   function(.x) yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) toc() #    #      result.furrr &lt;-dplyr::bind_rows(furrr.kw)</code> </pre> </div></div><br><p>  : <code>15.45 sec elapsed</code> </p><br><p> <code>furrr</code>          <code>purrr</code> .     <code>purrr</code>  ,          . </p><br><p>           <em>.options</em> .     <em>.options</em>  <code>future_options</code>     ,         . </p><br><p>   <strong> 14</strong>    <em>packages</em>  <em>globals</em>    : </p><br><pre> <code class="plaintext hljs">.options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())</code> </pre> <br><h1 id="test-skorosti">   </h1><br><p>           <code>rbenchmark</code> . </p><br><p>    ,          <code>future</code>  <code>promises</code> .                . </p><br><p>   ,     20       4     () . </p><br><p>    = (T[1] * 20) + (T[2] * 20) + (T[N] * 20) </p><br><div class="spoiler"> <b class="spoiler_title"> 15:        future  promises</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(parallel) library(dplyr) library(future) library(ryandexdirect) library(tictoc) library(rbenchmark) #   logins &lt;- c("login1", "login2", "login3", "login4") #        #        par par.furrr &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) furrr.kw &lt;- future_map(logins, ~ yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) result.furrr &lt;-dplyr::bind_rows(furrr.kw) } par.future &lt;- function(logins) { plan("multisession", workers = 4) futs &lt;- lapply(logins, function(i) future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) kw &lt;- lapply(futs, value) result.future &lt;- dplyr::bind_rows(kw) } par.future.apply &lt;- function(logins) { plan("multisession", workers = 4) kw.future.apply &lt;- future_sapply(logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) result.future.apply &lt;- dplyr::bind_rows(kw.future.apply) } par.parallel &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) clusterExport(cl = cl, varlist = "logins") clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) parallel.kw &lt;- parSapplyLB(cl = cl, X = logins, FUN = function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) stopCluster(cl) result.parallel &lt;- dplyr::bind_rows(parallel.kw) } #          seq seq.apply &lt;- function(logins) { kw.sapply &lt;- sapply( logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE ) result.sapply &lt;- do.call("rbind", kw.sapply) } seq.purrr &lt;- function(logins) { kw.purrr &lt;- map_df( logins, ~ { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) result.purrr &lt;- do.call("rbind", kw.purrr) } #       rbenchmark #   future + promises #  ,       #          plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) tic() speed.test &lt;- future({ #          within(benchmark(furrr = par.furrr(logins), future = par.future(logins), future.apply = par.future.apply(logins), parallel = par.parallel(logins), apply = seq.apply(logins), purrr = seq.purrr(logins), replications = c(20), columns = c('test', 'replications', 'elapsed'), order = c('elapsed', 'test')), { average = round(elapsed/replications, 2) }) }, packages = c("dplyr", "ryandexdirect", "rbenchmark", "parallel", "purrr", "future", "promises", "furrr", "future.apply"), globals = c("logins", "par.furrr", "par.future", "par.future.apply", "par.parallel", "seq.apply", "seq.purrr")) %...&gt;% print() %...T&gt;% toc() message("My Session is not blocked")</code> </pre> </div></div><br><p>       3370 , ..   . </p><br><p>           .  ,               <code>future</code>   ,       <code>promises</code>    ,                  . </p><br><p>        ,       .         "My Session is not blocked",       ,       , ..      . </p><br><p>  <code>promises</code>   : </p><br><ul><li> <code>%...&gt;%</code> —     <code>%&gt;%</code> ,     .  Das heißt,   ,       <code>resolved</code> ,     <code>future</code> ,          <code>value</code>          .       ,         <code>print</code> . </li><li> <code>%...T&gt;%</code> —  <code>%T&gt;%</code> ,  ,          .    ,          ,     , ..    ..  <code>print</code>       ,   ,    . </li><li> %...T!% —      . </li></ul><br><p>  <strong> 15</strong>  <code>plan</code>    <code>tweak</code> ( <code>plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4)))</code> ),      ,    2 ,   <code>future</code>       4 . </p><br><p>       : </p><br><pre> <code class="plaintext hljs">My Session is not blocked test replications elapsed average 4 parallel 20 393.02 19.65 1 furrr 20 402.09 20.10 2 future 20 431.19 21.56 3 future.apply 20 432.29 21.61 5 apply 20 847.77 42.39 6 purrr 20 864.19 43.21 3370.55 sec elapsed</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/16e/906/831/16e90683145df442ca830a6758734cbe.png" alt="Bild"></p><br><p>   ,        <code>parallel</code> ,        .    <code>furrr</code> ,     <code>future</code>  <code>future.apply</code> . </p><br><p>     1 ,           ,   .         ,      API .     . </p><br><p>   ,     4        ,          . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>               R,             API. </p><br><p>   ,     API    .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" R    ,  1"</a> . </p><br><p>          : </p><br><ul><li> doSNOW / doParallel + foreach </li><li> future + promises </li><li> future.apply / furrr </li><li> parallel </li></ul><br><p>         ,   ,        . </p><br><p>         ,          R  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448404/">https://habr.com/ru/post/de448404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448392/index.html">Zwei Ansätze zur Strukturierung eines Aktivitätsdiagramms</a></li>
<li><a href="../de448394/index.html">Version 12 startet heute! (Und es ist ein großer Sprung für Wolfram Language und Mathematica)</a></li>
<li><a href="../de448396/index.html">Machen Sie sich bereit für den Hardened Runtime and Notary Service auf macOS Mojave</a></li>
<li><a href="../de448400/index.html">Netplan und wie man es richtig kocht</a></li>
<li><a href="../de448402/index.html">Fehler beim Migrieren der Zertifizierungsstelle (CA) von Windows 2008R zu Windows 2012 R2</a></li>
<li><a href="../de448408/index.html">DCIM - Der Schlüssel zur Verwaltung von Rechenzentren</a></li>
<li><a href="../de448410/index.html">Tracker von Google sind in eine Reihe offizieller russischer elektronischer Ressourcen integriert</a></li>
<li><a href="../de448414/index.html">Heimlabor zur Selbstkontrolle oder was man in einem Geek-Kit kaufen kann</a></li>
<li><a href="../de448416/index.html">Der einfachste Weg, um Chat in iOS-Anwendung zu machen</a></li>
<li><a href="../de448420/index.html">Aus dem Leben mit Kubernetes: Wie sich der spanische HTTP-Server nicht beschwerte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>