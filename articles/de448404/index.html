<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçüåæ üîØ üö© So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Beispiels der Yandex.Direct-API (Teil 2) üßñüèΩ üö∂üèª üòª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im letzten Artikel habe ich √ºber Multithreading gesprochen und Beispiele f√ºr seine Implementierung in der R-Sprache bei der Arbeit mit der Yandex.Dire...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So beschleunigen Sie die Arbeit mit der R-Sprach-API mithilfe von Parallel Computing mithilfe des Beispiels der Yandex.Direct-API (Teil 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448404/"><p> Im letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel habe</a> ich √ºber Multithreading gesprochen und Beispiele f√ºr seine Implementierung in der R-Sprache bei der Arbeit mit der Yandex.Direct-API unter Verwendung der <code>doParallel</code> <code>doSNOW</code> , <code>doParallel</code> und <code>foreach</code> Konstrukt gegeben. </p><br><p>  Dieser Artikel ist eine Fortsetzung, kann aber als autonomer Leitfaden f√ºr Multithreading in R angesehen werden. Ich wurde aufgefordert, ihn durch die im ersten Teil eingegangenen Kommentare (hier ein besonderer Dank an <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Alexey_mosc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">SatCat</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Ananiev_Genrih</a> ) zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">schreiben</a> , in denen mir eine Reihe von Paketen gegeben wurden, die einen moderneren Ansatz darstellen Implementierungen von Multithreading in R, wir werden sp√§ter dar√ºber sprechen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/302/1a1/570/3021a15709dae984b328e3af5364d1de.png" alt="Multithreading"></p><a name="habracut"></a><br><h1 id="soderzhanie">  Inhalt </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Herausforderung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vorbereitung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiel f√ºr eine serielle Verarbeitungsl√∂sung, Sapply-Funktion und Purrr-Paket</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sapply-Funktion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Purrr-Paket</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Multithread-Optionen zum L√∂sen der Aufgabe, Schl√ºsselw√∂rter von Yandex.Direct zu sammeln</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Paralleles Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuk√ºnftiges Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wrapper √ºber die Zukunft</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Future.apply-Paket</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Furrr Paket</a> </li></ul></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Geschwindigkeitstest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li><li>  Umfrage </li></ul><br><h1 id="zadacha">  Herausforderung </h1><br><p>  Als Beispiel nehmen wir das in einer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">fr√ºheren Ver√∂ffentlichung</a> betrachtete Problem, d.h.  Sammeln Sie im Multithread-Modus eine Liste mit Keywords aus 4 Yandex.Direct-Werbekonten. </p><br><p>  Um mit der Yandex.Direct-API zu arbeiten, verwenden wir das <code>ryandexdirect</code> Paket.  Die offizielle Dokumentation dazu befindet sich auf dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Link</a> , aber f√ºr die Implementierung der beschriebenen Aufgabe ben√∂tigen wir nur 2 Funktionen: </p><br><ul><li>  <code>yadirAuth</code> - Autorisierung in der Yandex.Direct-API; </li><li>  <code>yadirGetKeyWords</code> - Laden Sie eine Liste mit Keywords von Anzeigenkonten herunter. </li></ul><br><p>  Es ist nicht nur so, dass ich mich f√ºr das Herunterladen von Schl√ºsselw√∂rtern entschieden habe, sondern dass dies eine der langwierigsten Vorg√§nge in der Yandex.Direct-API ist.  Zweitens ist in allen Konten die Anzahl der Schl√ºsselw√∂rter unterschiedlich, daher ist die Zeit zum Ausf√ºhren dieses Vorgangs f√ºr jedes Konto sehr unterschiedlich, in unserem Fall von 1 bis 20 Sekunden. </p><br><h1 id="podgotovka">  Vorbereitung </h1><br><p>  Zun√§chst m√ºssen Sie alle in diesem Artikel beschriebenen Pakete installieren. Dazu k√∂nnen Sie den folgenden Code verwenden. </p><br><div class="spoiler">  <b class="spoiler_title">Code 1: Installieren von Paketen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#    install.packages("ryandexdirect") install.packages("tictoc") install.packages("rbenchmark") install.packages("dplyr") install.packages("purrr") install.packages("future") install.packages("promises") install.packages("furrr") install.packages("future.apply")</code> </pre> </div></div><br><p>  Damit Ihnen Paketfunktionen zur Verf√ºgung stehen, m√ºssen Sie sie mit dem Befehl <code>library</code> .  Der Einfachheit halber werde ich alle erforderlichen Pakete in jedem gegebenen Codebeispiel separat verbinden. </p><br><p>  Wir erstellen einen Vektor, der aus Yandex.Direct-Anmeldungen besteht, von denen wir sp√§ter Schl√ºsselw√∂rter anfordern werden: </p><br><div class="spoiler">  <b class="spoiler_title">Code 2: Erstellen eines Anmeldevektors</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">logins &lt;- c("login1", "login2", "login3", "login4")</code> </pre> </div></div><br><p>  Um mit der Yandex.Direct-API arbeiten zu k√∂nnen, m√ºssen Sie zun√§chst die Autorisierung f√ºr jedes Konto durchlaufen. Dazu k√∂nnen Sie das folgende Design verwenden: </p><br><div class="spoiler">  <b class="spoiler_title">Code 3: Autorisierung in der Yandex.Direct-API</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">lapply(logins, function(l) { yadirAuth(Login = l)})</code> </pre> </div></div><br><p>  Nach dem Ausf√ºhren des obigen Codes wird unter jedem Konto ein Browser zur Autorisierung ge√∂ffnet.  Sie best√§tigen die Erlaubnis von <code>ryandexdirect</code> , auf Ihre Werbematerialien zuzugreifen.  Sie werden zu der Seite weitergeleitet, auf der Sie den Best√§tigungscode kopieren m√ºssen.  Schlie√üen Sie den Autorisierungsprozess ab, indem Sie es in die R-Konsole eingeben.  Dieser Vorgang wird f√ºr jede Anmeldung wiederholt, die Sie beim Erstellen der Vektoranmeldungen angegeben haben. </p><br><p>  Einige Benutzer sind w√§hrend des Autorisierungsprozesses m√∂glicherweise durch die Umleitung zu einer Ressource eines Drittanbieters verwirrt. Es besteht jedoch keine Gefahr f√ºr Ihr Konto. Ich habe dieses Thema im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Wie sicher es ist, R-Pakete f√ºr die Arbeit mit APIs f√ºr Werbesysteme zu verwenden"</a> ausf√ºhrlicher beschrieben. </p><br><p>  Als n√§chstes werden wir einige Beispiele f√ºr die Implementierung der beschriebenen Aufgabe betrachten.  Jedes davon beginnt mit einem Beispielcode und seiner weiteren Erkl√§rung.  Ich denke, diese Option ist f√ºr die Wahrnehmung am bequemsten. </p><br><h1 id="primer-resheniya-v-posledovatelnom-rezhime-obrabotki-funkciya-sapply-i-paket-purrr">  Beispiel f√ºr eine serielle Verarbeitungsl√∂sung, Sapply-Funktion und Purrr-Paket </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/369/72e/9d8/36972e9d8707c1c508d2e43b8721778c.jpg"><br>  Im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">letzten Artikel habe</a> ich eine L√∂sung am Beispiel der <code>for</code> Schleife angef√ºhrt.  Da wir Multithreading mit dem <code>foreach</code> Paket in Betracht gezogen haben, dessen Syntax Schleifen √§hnelt, war dieses Beispiel dort angemessen, obwohl die Verwendung von Schleifen von Benutzern von R nicht begr√º√üt wird. </p><br><p>  Die Pakete, die wir in diesem Artikel betrachten werden, erinnern eher an die Funktionen der Apply-Familie in der Syntax. Daher werde ich ein Beispiel f√ºr eine L√∂sung im seriellen Modus geben, die sie verwendet. </p><br><h3 id="funkciya-sapply">  <code>sapply</code> Funktion </h3><br><blockquote>  Um die Ausf√ºhrungszeit von Befehlen abzusch√§tzen, verwenden wir in jedem der betrachteten Ans√§tze das <code>tictoc</code> Paket. </blockquote><br><div class="spoiler">  <b class="spoiler_title">Code 4: Beispiell√∂sung im sequentiellen Modus mit Sapply-Funktion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(tictoc) library(dplyr) tic() #   kw.sapply &lt;- sapply( logins, #  ,     function(x) #        #     { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE #     ) toc() #   #       result.sapply &lt;- do.call("rbind", kw.sapply)</code> </pre> </div></div><br><p>  <code>39.36 sec elapsed</code> : <code>39.36 sec elapsed</code> </p><br><p>  Zun√§chst ist die Syntax der Funktionen der <code>apply</code> Familie nicht so einfach zu lesen wie die Syntax von Schleifen, aber tats√§chlich ist alles recht einfach. </p><br><p> <code>sapply(X, FUN)</code> </p> <br><p>  Wo: </p><br><ul><li>  <em>X</em> - Ein Objekt, dessen Elemente wir bei jeder Iteration durchlaufen und nacheinander verwenden werden. In einer <code>for</code> Schleife sah es folgenderma√üen aus: <code>for(i in X)</code> ; </li><li>  <em>FUN</em> - Eine Funktion, bei der wir nacheinander jedes Element des Objekts <em>X</em> ersetzen. Wenn wir eine Analogie mit <code>for</code> , ist dies der K√∂rper der Schleife. </li></ul><br><p>  In Codebeispiel <strong>4</strong> wird der zuvor erstellte <em>Anmeldevektor</em> an das <em>X-</em> Argument √ºbergeben.  Jedes Element des <em>Anmeldevektors</em> wird nacheinander als einziges Argument an die anonyme Funktionsfunktion <code>function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }</code> , die an das <em>FUN-</em> Argument √ºbergeben wurde. </p><br><p>  Das hei√üt,  <code>sapply</code> f√ºhrt die in <em>FUN</em> angegebene Funktion viermal aus, ersetzt sie nacheinander und gibt das Ergebnis in Form einer Liste (Objekt der Klassenliste) zur√ºck, die aus vier Elementen besteht.  Jedes Element ist eine Tabelle mit einer Liste von Schl√ºsselw√∂rtern, die bei jeder Iteration vom Konto empfangen werden. </p><br><ol><li> <code>yadirGetKeyWords(Login = "login1") %&gt;% mutate(login = "login1")</code> </li> <li> <code>yadirGetKeyWords(Login = "login2") %&gt;% mutate(login = "login2")</code> </li> <li> <code>yadirGetKeyWords(Login = "login3") %&gt;% mutate(login = "login3")</code> </li> <li> <code>yadirGetKeyWords(Login = "login4") %&gt;% mutate(login = "login4")</code> </li> </ol><br><p>  Das mit <code>sapply</code> erhaltene <code>sapply</code> hat folgende Struktur: </p><br><pre> <code class="plaintext hljs">summary(kw.sapply)</code> </pre> <br><pre> <code class="plaintext hljs"> Length Class Mode login1 19 data.frame list login2 19 data.frame list login3 19 data.frame list login4 19 data.frame list</code> </pre> <br><p>  Am Ende dieses Beispiels <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> der Befehl <code>result.sapply &lt;- do.call("rbind", kw.sapply)</code> alle 4 Elemente der <em>kw.sapply-</em> Liste in einem einzigen <em>result.sapply-</em> Frame. </p><br><pre> <code class="plaintext hljs"># A tibble: 6,804 x 1 result.sapply$Id $Keyword $AdGroupId $CampaignId $ServingStatus $State &lt;dbl&gt; &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; 1 15164230566 ~ 3597453985 39351725 ELIGIBLE ON 2 15164230567  ~ 3597453985 39351725 ELIGIBLE ON 3 15164230568  ~ 3597453985 39351725 ELIGIBLE ON 4 15164230569 ~ 3597453985 39351725 ELIGIBLE ON 5 15164230570 ~ 3597453985 39351725 ELIGIBLE ON 6 15164230571  ~ 3597453985 39351725 ELIGIBLE ON 7 15164230572 ~ 3597453985 39351725 ELIGIBLE ON 8 15164230573  ~ 3597453985 39351725 ELIGIBLE ON 9 15164230574 ~ 3597453985 39351725 ELIGIBLE ON 10 15164230575 ~ 3597453985 39351725 ELIGIBLE ON # ... with 6,794 more rows, and 13 more variables: $Status &lt;fct&gt;, # $StrategyPriority &lt;fct&gt;, $StatisticsSearchImpressions &lt;int&gt;, # $StatisticsSearchClicks &lt;int&gt;, $StatisticsNetworkImpressions &lt;int&gt;, # $StatisticsNetworkClicks &lt;lgl&gt;, $UserParam1 &lt;chr&gt;, $UserParam2 &lt;chr&gt;, # $ProductivityValue &lt;lgl&gt;, $ProductivityReferences &lt;lgl&gt;, $Bid &lt;dbl&gt;, # $ContextBid &lt;dbl&gt;, $login &lt;chr&gt;</code> </pre> <br><p>  Zus√§tzlich zu <code>sapply</code> umfasst die Funktionsfamilie <code>*apply</code> : <code>apply</code> , <code>lapply</code> , <code>vapply</code> , <code>mapply</code> und andere. </p><br><h3 id="paket-purrr">  <code>purrr</code> Paket </h3><br><div class="spoiler">  <b class="spoiler_title">Code 5: Beispiell√∂sung mit den Funktionen des Purrr-Pakets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) library(dplyr) library(tictoc) tic() #   result.purrr &lt;- map_df( logins, #  ,     ~ #   function(.x) { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) toc() #  </code> </pre> </div></div><br><p>  <code>35.46 sec elapsed</code> : <code>35.46 sec elapsed</code> </p><br><p>  Das <code>purrr</code> Paket ist Teil des Kerns der von Headley Wickham verfassten <code>tidyverse</code> Bibliothek. </p><br><p>  In Bezug auf Bedeutung und Syntax sind die Hauptfunktionen des Pakets <code>sapply</code> sehr √§hnlich. <code>sapply</code> Hauptvorteil ist folgender: </p><br><ul><li>  Die Funktionen sind in Familienkarten, <code>map2</code> , <code>pmap</code> , <code>walk</code> usw. unterteilt. Separate Funktionen derselben Familie geben das Ergebnis in verschiedenen Formaten zur√ºck: <em>chr</em> , <em>dbl</em> , <em>int</em> , <em>df</em> usw.; </li><li>  Mit den Funktionen der <code>map2</code> Familie <code>map2</code> Sie Elemente (iterieren) von zwei Objekten gleichzeitig <code>map2</code> . </li><li>  Mit den Funktionen der <code>pmap</code> Familie <code>pmap</code> Sie gleichzeitig Elemente einer beliebigen Anzahl von Objekten <code>pmap</code> .  Sie k√∂nnen eine Tabelle an die Eingabe an das Argument <em>.l √ºbergeben</em> <em>(ein Analogon des X-Arguments in sapply)</em> , dessen jede Spalte die Werte enth√§lt, mit denen Sie iterieren, und die wiederum durch die Argumente derselben Funktion ersetzt werden, die in <em>.f</em> <em>(dem FUN-Analogon von) √ºbergeben wird sapply)</em> . </li></ul><br><p>  In welcher Situation m√ºssen wir Elemente mehrerer Objekte durchlaufen.  Sie arbeiten beispielsweise mit mehreren Agentenkonten, und Werbekonten, von denen Sie eine Liste mit Schl√ºsselw√∂rtern erhalten m√∂chten, sind zwischen diesen verteilt.  In diesem Fall k√∂nnen Sie aus den Namen der Agentenkonten einen Vektor erstellen und diesen durchlaufen, parallel dazu, wie Sie die Anmeldungen der Werbekonten sortieren. </p><br><div class="spoiler">  <b class="spoiler_title">Code 6: Beispiel f√ºr die Arbeit mit mehreren Agentenkonten</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #      agencies &lt;- c("agency1", NA, "agency2", "agency1") #      #         result.pmap2 &lt;- map2_df(.x = logins, .y = agencies, ~ { yadirGetKeyWords(Login = .x, AgencyAccount = .y) %&gt;% mutate(login = .x) })</code> </pre> </div></div><br><p>  Stellen Sie sich nun die Situation vor, dass Sie, wenn Sie sich unter verschiedenen Konten angemeldet haben, die Datei mit den Anmeldeinformationen in verschiedenen Ordnern gespeichert haben und dann sofort drei Objekte durchlaufen m√ºssen: Anmeldungen von Werbekonten, Anmeldungen von Agentenkonten, den Pfad, in dem die Datei mit den Anmeldeinformationen gespeichert ist.  Dies kann mit Hilfe erfolgen.  <code>pmap</code> Familienfunktionen. </p><br><div class="spoiler">  <b class="spoiler_title">Code 7: Beispiel f√ºr eine pmap-Funktion</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(purrr) #  ,       #      TokenPath &lt;- c("C:\\proj1\\tokens", "C:\\yandex\\token", "C:\\yandex\\token", "C:\\my_yandex_acoount") #   pmap.result &lt;- pmap_df(list(Login = logins, AgencyAccount = agencies, TokenPath = TokenPath), yadirGetKeyWords)</code> </pre> </div></div><br><p>  Dementsprechend ist das Ergebnis der Ausf√ºhrung der Funktionen <code>map_df</code> , <code>map2_df</code> und <code>pmap_df</code> der <code>pmap_df</code> , und bei deren Verwendung ist der letzte Schritt aus dem Beispiel mit <code>sapply</code> ( <code>do.call("rbind", kw.sapply)</code> ) nicht erforderlich. </p><br><p>  Der Code ist kompakter geworden und wird etwas schneller ausgef√ºhrt. <code>purrr</code> sammeln beide beschriebenen Ans√§tze, <code>sapply</code> und <code>purrr</code> , nacheinander Schl√ºsselw√∂rter von jedem Konto.  Daher ist die Gesamtausf√ºhrungszeit dieser Operation gleich der Summe der Dauer der Datenerfassung von allen vier Konten. </p><br><p>  <strong>Zeit [gesamt]</strong> = <em>Zeit [login1] + Zeit [login2] + Zeit [login3] + Zeit [login4]</em> </p><br><h1 id="mnogopotochnye-varianty-resheniya-zadachi-po-sboru-klyuchevyh-slov-iz-yandeksdirekt">  Multithread-Optionen zum L√∂sen der Aufgabe, Schl√ºsselw√∂rter von Yandex.Direct zu sammeln </h1><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/53c/cf5/ab353ccf566421eaaa6ec3d6445399a1.jpg"></p><br><p>  Wenn Sie also bereits den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ersten Artikel</a> gelesen haben, wissen Sie, dass der Multithread-Betriebsmodus mehrere Funktionen hat: </p><br><ul><li>  Jeder Thread startet in einer separaten R-Sitzung mit einer sauberen Arbeitsumgebung. </li><li>  Aus dem gleichen Grund werden in einem separaten laufenden Prozess zuvor verbundene Pakete nicht standardm√§√üig √ºbertragen. </li></ul><br><p>  Das Exportieren von Objekten, die in einer Arbeitsumgebung erstellt wurden, und das Verbinden von Paketen in jedem Ansatz wird unterschiedlich implementiert. Anschlie√üend werden wir sie genauer betrachten. </p><br><h3 id="paket-parallel">  <code>parallel</code> Paket </h3><br><p>  Dieses Paket wurde erstmals in Version 2.14.0 in das R-Paket aufgenommen und wird bis heute mit R selbst geliefert. </p><br><div class="spoiler">  <b class="spoiler_title">Code 8: Beispiell√∂sung f√ºr das Problem durch das Parallelpaket</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictoc) #   cl &lt;- makeCluster(4) #      clusterExport(cl = cl, varlist = "logins") #  ,      #  ,       ryandexdirect clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) tic() #   parallel.kw &lt;- parSapplyLB(cl = cl, #   X = logins, # ,     FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) #    toc() #     #   stopCluster(cl) #      result.parallel &lt;- dplyr::bind_rows(parallel.kw)</code> </pre> </div></div><br><p>  <code>16.75 sec elapsed</code> : <code>16.75 sec elapsed</code> </p><br><p>  Versuchen wir, <strong>Code 8</strong> zu analysieren.  Die Funktion <code>makeCluster</code> erstellt einen Cluster von 4 Prozessen.  Mit der Funktion <code>clusterExport</code> k√∂nnen wir Objekte aus unserer Hauptarbeitsumgebung in den erstellten Cluster <code>clusterExport</code> Dazu m√ºssen wir die folgenden Argumente verwenden: </p><br><ul><li>  <em>cl</em> - Cluster, in den wir Objekte exportieren </li><li>  <em>varlist</em> - Ein <em>Textvektor</em> , der die Namen der Objekte enth√§lt, die in jeden Clusterprozess exportiert werden sollen. </li></ul><br><p>  Eine M√∂glichkeit, die richtigen Pakete auf jedem Clusterknoten zu verbinden, besteht in der Verwendung der Funktion <code>clusterEvalQ</code> .  In unserem Beispiel verwenden wir es, um Pakete zu verbinden. Sie k√∂nnen jedoch einen beliebigen R-Code in <code>clusterEvalQ</code> schreiben. Der Code wird am Anfang jedes Clusterknotens gestartet.  Die Argumente f√ºr diese Funktion sind ziemlich offensichtlich. Sie m√ºssen den Cluster und die Befehle angeben, die darin ausgef√ºhrt werden. </p><br><p>  <code>parSapplyLB</code> ist eine parallele Version der <code>sapply</code> Funktion mit Lastausgleich zwischen den Clusterknoten. Sie wird ebenfalls verwendet. Sie m√ºssen den Cluster jedoch mit dem Argument <em>cl</em> angeben. </p><br><p>  <code>parallel</code> gibt es auch andere parallelisierte Versionen der Funktionen der <code>*apply</code> Familie: <code>parLapply</code> , <code>parSapply</code> , <code>parApply</code> usw. </p><br><p>  <code>parSapply</code> unterscheidet sich von <code>parSapplyLB</code> nur dadurch, dass es keinen Lastausgleich auf Clusterknoten gibt. </p><br><p>  Mit der Funktion <code>stopCluster</code> wird der erstellte Cluster gestoppt. </p><br><p>  Mit dem letzten Befehl, <code>dplyr::bind_rows(parallel.kw)</code> kombinieren wir das mit <code>parSapplyLB</code> erhaltene <em>parallel.kw-</em> Objekt in einer Tabelle. </p><br><p>  F√ºr Linux hat <code>parallel</code> separate Funktionen: <code>mclapply</code> , <code>mcmapply</code> , <code>mcMap</code> .  In diesem Betriebssystem werden Befehle h√§ufig schneller ausgef√ºhrt und der Code wird kompakter. </p><br><div class="spoiler">  <b class="spoiler_title">Code 9: L√∂sung mit mclapply f√ºr Linux</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(parallel) library(tictic) library(dplyr) library(ryandexdirect) tic() mclapply.kw &lt;- mclapply(logins, FUN = function(x) { #      #      X yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, mc.cores = 4) toc()</code> </pre> </div></div><br><p>  Bei Verwendung dieser Funktionen muss der Cluster nicht mit dem <code>makeCluster</code> .  Die Anzahl der Knoten, die Sie mit dem Argument <em>mc.cores angeben</em> .  Es ist auch nicht erforderlich, Pakete zu verbinden und Objekte zu exportieren. Diese Vorg√§nge werden automatisch ausgef√ºhrt. </p><br><h3 id="paket-future">  <code>future</code> Paket </h3><br><p>  Einer der modernsten Ans√§tze zur asynchronen Programmierung in R. </p><br><p>  Ein Code, der parallel unser Problem mit Hilfe der <code>future</code> l√∂sen wird, ist kompliziert genug, um verstanden zu werden.  Lassen Sie uns daher die Arbeit an einem einfacheren Beispiel analysieren. Wir fordern eine Liste mit Schl√ºsselw√∂rtern von einem Konto an. </p><br><div class="spoiler">  <b class="spoiler_title">Code 10: Das einfachste Beispiel f√ºr die Verwendung des zuk√ºnftigen Pakets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) #    plan(multiprocess) #      #    future.kw &lt;- future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins") #     resolved(future.kw) #     future.result.1 &lt;- value(future.kw)</code> </pre> </div></div><br><p>  Versuchen wir, das <strong>Code 10-</strong> Beispiel herauszufinden.  Mit der <code>plan</code> k√∂nnen Sie den Ausf√ºhrungsmodus der angegebenen Ausdr√ºcke festlegen und √§ndern. Hier sind die wichtigsten: </p><br><ul><li>  <em>sequentiell</em> - Dies ist die √ºbliche R-Betriebsart. Befehle werden in der aktuellen Sitzung sequentiell ausgef√ºhrt. </li><li>  <em>Multisession</em> - Im parallelen Modus werden die Befehle in den laufenden Sitzungen im Hintergrund auf dem aktuellen Computer ausgef√ºhrt, w√§hrend Ihre Arbeitssitzung nicht blockiert wird. </li><li>  <em>Cluster</em> - Paralleler Modus: Die Befehle werden auf dem aktuellen oder Remote-Computer ausgef√ºhrt, √§hnlich wie sie im <code>parallel</code> Paket implementiert sind. </li></ul><br><p>  Das gesamte <code>future</code> Paket basiert auf der Ausf√ºhrung von Befehlen in Hintergrundprozessen, ohne die aktuelle Sitzung zu blockieren.  Das Ausf√ºhren der Ausf√ºhrung von Befehlen folgt der gleichnamigen Funktion <code>future</code> . Wenn wir also den Befehl ausf√ºhren: </p><br><pre> <code class="plaintext hljs">future({yadirGetKeyWords(Login = logins[4])}, packages = "ryandexdirect", globals = "logins")</code> </pre> <br><p>  Unsere aktuelle Sitzung in R ist nicht blockiert, und der Befehl wird im Hintergrund ausgef√ºhrt, wobei eine weitere R-Sitzung ausgef√ºhrt wird. </p><br><p>  Mit der <code>resolved</code> Funktion k√∂nnen Sie den aktuellen Status des Ausf√ºhrungsprozesses eines bestimmten Ausdrucks √ºberpr√ºfen.  Schlie√ülich wird die <code>value</code> verwendet, um das Ergebnis der <code>future</code> Ausf√ºhrung zu erhalten.  Wenn Sie die <code>value</code> fr√ºher als Ihre <code>future</code> Ausf√ºhrung in einer parallel laufenden Sitzung ausf√ºhren, wird die aktuelle Arbeitssitzung blockiert, bis der Ausdruck f√ºr die parallele Sitzung abgeschlossen ist. </p><br><p>  Das fortschrittlichste Arbeitsbeispiel ist die Verwendung von <code>future</code> Verbindung mit <code>promises</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Code 11: Beispiel f√ºr das Teilen von Paketen mit "Zukunft" und "Versprechen"</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(promises) #    plan(multiprocess) #      #    future.kw &lt;- future({suppressMessages( yadirGetKeyWords(Login = logins[4]))}, packages = "ryandexdirect", globals = "logins") %...&gt;% #     future, #      nrow() %...&gt;% paste("words loaded") %...&gt;% print()</code> </pre> </div></div><br><p>  Das <code>promises</code> Paket bietet eine Reihe von Pipeline-Betreibern, die die <code>future</code> Funktionalit√§t perfekt erg√§nzen. </p><br><p>  Im Beispiel von <strong>Code 11</strong> starten wir im Hintergrund den Prozess des Herunterladens von Keywords von einem Werbekonto.  Au√üerdem wartet der Pipeline-Betreiber <code>%...&gt;%</code> ohne die Arbeitssitzung zu blockieren, auf den Abschluss der <code>future</code> und f√ºhrt die verbleibenden Vorg√§nge aus.  Als Ergebnis der Codeausf√ºhrung wird nach Abschluss <code>future</code> Arbeiten die Anzahl der Schl√ºsselw√∂rter des angegebenen Kontos in der Konsole angezeigt: </p><br><pre> <code class="plaintext hljs">[1] "1855 words loaded"</code> </pre> <br><blockquote>  Am Ende des Artikels wird ein anschaulicheres Beispiel f√ºr eine Reihe von <code>future</code> und <code>promises</code> gezeigt. </blockquote><p>  Standardm√§√üig exportiert das <code>future</code> Paket selbst den gesamten Arbeitsbereich in jede parallel ausgef√ºhrte Sitzung. Sie k√∂nnen jedoch selbst eine Liste der zu exportierenden Objekte mithilfe des <em>globalen</em> Arguments <em>angeben</em> . </p><br><p>  Um Pakete mit der <code>future</code> zu verbinden <code>future</code> sollten <code>future</code> einen Vektor mit ihren Namen an das <em>Paketargument √ºbergeben</em> . </p><br><p>  Zur√ºck zu unserer Aufgabe: Im folgenden Codebeispiel im Parallelmodus wird eine Liste mit Schl√ºsselw√∂rtern aus 4 Konten geladen: </p><br><div class="spoiler">  <b class="spoiler_title">Code 12: Ein Beispiel f√ºr die L√∂sung eines Problems mit dem zuk√ºnftigen Paket</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future) library(tictoc) #   plan("multisession", workers = 4) tic() #   futs &lt;- lapply(logins, #      function(i) #        #   future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) #    kw &lt;- lapply(futs, value) #    toc() #    #     result.future &lt;- dplyr::bind_rows(kw)</code> </pre> </div></div><br><p>  Vorlaufzeit: <code>14.83 sec elapsed</code> </p><br><p>  Um eine Liste von Keywords im Multithread-Modus von allen in den Vektoranmeldungen aufgef√ºhrten Werbekonten herunterzuladen <em>, m√ºssen</em> Sie im Hintergrund eine separate <code>future</code> ausf√ºhren.  In <code>lapply</code> <strong>12</strong> implementieren wir dies mit der Funktion <code>lapply</code> . </p><br><p>  Das Ergebnis von <code>lapply</code> ist eine Liste der <code>future</code> <code>lapply</code> .  Sie k√∂nnen den Status jedes einzelnen mit dem <code>sapply(futs, resolved)</code> √ºberpr√ºfen, der einen logischen Vektor <code>sapply(futs, resolved)</code> wobei <em>TRUE</em> bedeutet, dass die <code>future</code> erf√ºllt ist, und <em>FALSE,</em> dass die <code>future</code> gerade ausgef√ºhrt wird. </p><br><p>  Um Ergebnisse aus jeder <code>future</code> zu erhalten, verwenden wir nach Abschluss ihrer Arbeit den <code>lapply(futs, value)</code> . </p><br><p>          : <code>result.future &lt;- dplyr::bind_rows(kw)</code> . </p><br><h3 id="obyortki-nad-future">   <code>future</code> </h3><br><p>      ,      (   <br> <code>future</code> ),      . </p><br><h6 id="paket-futureapply">  <code>future.apply</code> </h6><br><p> <code>future.apply</code>     <code>future</code> ,  . </p><br><div class="spoiler"> <b class="spoiler_title"> 13:       future.apply</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(future.apply) library(tictoc) #    plan("multisession", workers = 4) tic() #   kw.future.apply &lt;- future_sapply(logins, #    ,   function(x) { #     yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, #    #   future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) toc() #   </code> </pre> </div></div><br><p>  : <code>17.28 sec elapsed</code> </p><br><p>   <strong> 13</strong> ,  <code>future.apply</code>         <code>future</code> ,         . </p><br><p>         4 : <code>plan("multisession", workers = 4)</code> . </p><br><p> <code>future_sapply</code>      <em>logins</em>    .  Das hei√üt,   ,  ,        <code>sapply</code> ,    . </p><br><p>      <code>future_sapply</code>    <em>future.packages</em> .             <em>future.globals</em> .       ,              . </p><br><h4 id="paket-furrr">  <code>furrr</code> </h4><br><p>     <code>future</code> .          <code>purrr</code> ,   <code>furrr</code>     . </p><br><div class="spoiler"> <b class="spoiler_title"> 14:      furrr</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(tictoc) #   cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) tic() #   furrr.kw &lt;- future_map(logins, ~ #   function(.x) yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) toc() #    #      result.furrr &lt;-dplyr::bind_rows(furrr.kw)</code> </pre> </div></div><br><p>  : <code>15.45 sec elapsed</code> </p><br><p> <code>furrr</code>          <code>purrr</code> .     <code>purrr</code>  ,          . </p><br><p>           <em>.options</em> .     <em>.options</em>  <code>future_options</code>     ,         . </p><br><p>   <strong> 14</strong>    <em>packages</em>  <em>globals</em>    : </p><br><pre> <code class="plaintext hljs">.options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())</code> </pre> <br><h1 id="test-skorosti">   </h1><br><p>           <code>rbenchmark</code> . </p><br><p>    ,          <code>future</code>  <code>promises</code> .                . </p><br><p>   ,     20       4     () . </p><br><p>    = (T[1] * 20) + (T[2] * 20) + (T[N] * 20) </p><br><div class="spoiler"> <b class="spoiler_title"> 15:        future  promises</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">library(furrr) library(parallel) library(dplyr) library(future) library(ryandexdirect) library(tictoc) library(rbenchmark) #   logins &lt;- c("login1", "login2", "login3", "login4") #        #        par par.furrr &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) plan(cluster, workers = cl) furrr.kw &lt;- future_map(logins, ~ yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x), .options = future_options(packages = c("ryandexdirect", "dplyr"), globals = c())) result.furrr &lt;-dplyr::bind_rows(furrr.kw) } par.future &lt;- function(logins) { plan("multisession", workers = 4) futs &lt;- lapply(logins, function(i) future({ yadirGetKeyWords(Login = i) %&gt;% mutate(login = i) }, packages = c("ryandexdirect", "dplyr"))) completed &lt;- sapply(futs, resolved) kw &lt;- lapply(futs, value) result.future &lt;- dplyr::bind_rows(kw) } par.future.apply &lt;- function(logins) { plan("multisession", workers = 4) kw.future.apply &lt;- future_sapply(logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE, future.packages = c("ryandexdirect", "dplyr"), future.globals = TRUE ) result.future.apply &lt;- dplyr::bind_rows(kw.future.apply) } par.parallel &lt;- function(logins) { cl &lt;- parallel::makeCluster(4) clusterExport(cl = cl, varlist = "logins") clusterEvalQ(cl = cl, { library(ryandexdirect) library(dplyr) } ) parallel.kw &lt;- parSapplyLB(cl = cl, X = logins, FUN = function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = F) stopCluster(cl) result.parallel &lt;- dplyr::bind_rows(parallel.kw) } #          seq seq.apply &lt;- function(logins) { kw.sapply &lt;- sapply( logins, function(x) { yadirGetKeyWords(Login = x) %&gt;% mutate(login = x) }, simplify = FALSE ) result.sapply &lt;- do.call("rbind", kw.sapply) } seq.purrr &lt;- function(logins) { kw.purrr &lt;- map_df( logins, ~ { yadirGetKeyWords(Login = .x) %&gt;% mutate(login = .x) } ) result.purrr &lt;- do.call("rbind", kw.purrr) } #       rbenchmark #   future + promises #  ,       #          plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4))) tic() speed.test &lt;- future({ #          within(benchmark(furrr = par.furrr(logins), future = par.future(logins), future.apply = par.future.apply(logins), parallel = par.parallel(logins), apply = seq.apply(logins), purrr = seq.purrr(logins), replications = c(20), columns = c('test', 'replications', 'elapsed'), order = c('elapsed', 'test')), { average = round(elapsed/replications, 2) }) }, packages = c("dplyr", "ryandexdirect", "rbenchmark", "parallel", "purrr", "future", "promises", "furrr", "future.apply"), globals = c("logins", "par.furrr", "par.future", "par.future.apply", "par.parallel", "seq.apply", "seq.purrr")) %...&gt;% print() %...T&gt;% toc() message("My Session is not blocked")</code> </pre> </div></div><br><p>       3370 , ..   . </p><br><p>           .  ,               <code>future</code>   ,       <code>promises</code>    ,                  . </p><br><p>        ,       .         "My Session is not blocked",       ,       , ..      . </p><br><p>  <code>promises</code>   : </p><br><ul><li> <code>%...&gt;%</code> ‚Äî     <code>%&gt;%</code> ,     .  Das hei√üt,   ,       <code>resolved</code> ,     <code>future</code> ,          <code>value</code>          .       ,         <code>print</code> . </li><li> <code>%...T&gt;%</code> ‚Äî  <code>%T&gt;%</code> ,  ,          .    ,          ,     , ..    ..  <code>print</code>       ,   ,    . </li><li> %...T!% ‚Äî      . </li></ul><br><p>  <strong> 15</strong>  <code>plan</code>    <code>tweak</code> ( <code>plan(list(tweak(multisession, workers = 2), tweak(multisession, workers = 4)))</code> ),      ,    2 ,   <code>future</code>       4 . </p><br><p>       : </p><br><pre> <code class="plaintext hljs">My Session is not blocked test replications elapsed average 4 parallel 20 393.02 19.65 1 furrr 20 402.09 20.10 2 future 20 431.19 21.56 3 future.apply 20 432.29 21.61 5 apply 20 847.77 42.39 6 purrr 20 864.19 43.21 3370.55 sec elapsed</code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/16e/906/831/16e90683145df442ca830a6758734cbe.png" alt="Bild"></p><br><p>   ,        <code>parallel</code> ,        .    <code>furrr</code> ,     <code>future</code>  <code>future.apply</code> . </p><br><p>     1 ,           ,   .         ,      API .     . </p><br><p>   ,     4        ,          . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>               R,             API. </p><br><p>   ,     API    .              <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">" R    ,  1"</a> . </p><br><p>          : </p><br><ul><li> doSNOW / doParallel + foreach </li><li> future + promises </li><li> future.apply / furrr </li><li> parallel </li></ul><br><p>         ,   ,        . </p><br><p>         ,          R  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de448404/">https://habr.com/ru/post/de448404/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de448392/index.html">Zwei Ans√§tze zur Strukturierung eines Aktivit√§tsdiagramms</a></li>
<li><a href="../de448394/index.html">Version 12 startet heute! (Und es ist ein gro√üer Sprung f√ºr Wolfram Language und Mathematica)</a></li>
<li><a href="../de448396/index.html">Machen Sie sich bereit f√ºr den Hardened Runtime and Notary Service auf macOS Mojave</a></li>
<li><a href="../de448400/index.html">Netplan und wie man es richtig kocht</a></li>
<li><a href="../de448402/index.html">Fehler beim Migrieren der Zertifizierungsstelle (CA) von Windows 2008R zu Windows 2012 R2</a></li>
<li><a href="../de448408/index.html">DCIM - Der Schl√ºssel zur Verwaltung von Rechenzentren</a></li>
<li><a href="../de448410/index.html">Tracker von Google sind in eine Reihe offizieller russischer elektronischer Ressourcen integriert</a></li>
<li><a href="../de448414/index.html">Heimlabor zur Selbstkontrolle oder was man in einem Geek-Kit kaufen kann</a></li>
<li><a href="../de448416/index.html">Der einfachste Weg, um Chat in iOS-Anwendung zu machen</a></li>
<li><a href="../de448420/index.html">Aus dem Leben mit Kubernetes: Wie sich der spanische HTTP-Server nicht beschwerte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>