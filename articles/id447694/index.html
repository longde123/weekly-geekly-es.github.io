<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎂 🧚🏻 🚎 Konfigurasi Sistem Terdistribusi yang Dikompilasi 🎖️ 💇🏽 ♥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya ingin memberi tahu Anda satu mekanisme menarik untuk bekerja dengan konfigurasi sistem terdistribusi. Konfigurasi disajikan langsung dalam bahasa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konfigurasi Sistem Terdistribusi yang Dikompilasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/primetalk/blog/447694/"><p>  Saya ingin memberi tahu Anda satu mekanisme menarik untuk bekerja dengan konfigurasi sistem terdistribusi.  Konfigurasi disajikan langsung dalam bahasa yang dikompilasi (Scala) menggunakan tipe aman.  Dalam posting ini, contoh konfigurasi seperti itu dianalisis dan berbagai aspek memperkenalkan konfigurasi yang dikompilasi ke dalam proses pengembangan secara keseluruhan dipertimbangkan. </p><br><p><img src="https://habrastorage.org/webt/71/bl/ax/71blaxtldz-ia4yftyebaxbam7c.png" alt="Siklus Hidup Konfigurasi"></p><br><p>  ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahasa inggris</a> ) </p><a name="habracut"></a><br><h3 id="vvedenie">  Pendahuluan </h3><br><p>  Membangun sistem terdistribusi yang andal menyiratkan bahwa semua node menggunakan konfigurasi yang benar, disinkronkan dengan node lain.  Biasanya, teknologi DevOps (terraform, ansible, atau sesuatu seperti itu) digunakan untuk secara otomatis menghasilkan file konfigurasi (seringkali milik mereka sendiri untuk setiap node).  Kami juga ingin memastikan bahwa semua node yang berinteraksi menggunakan protokol yang identik (termasuk versi yang sama).  Jika tidak, ketidakcocokan akan tertanam dalam sistem terdistribusi kami.  Di dunia JVM, salah satu konsekuensi dari persyaratan ini adalah kebutuhan untuk menggunakan versi perpustakaan yang sama yang berisi pesan protokol di mana-mana. </p><br><p>  Bagaimana dengan pengujian sistem terdistribusi?  Tentu saja, kami mengasumsikan bahwa unit test disediakan untuk semua komponen sebelum kami melanjutkan ke pengujian integrasi.  (Agar kami memperkirakan hasil pengujian menjadi runtime, kami juga harus menyediakan kumpulan perpustakaan yang identik pada tahap pengujian dan dalam runtime.) </p><br><p>  Ketika bekerja dengan tes integrasi, seringkali lebih mudah di mana saja untuk menggunakan classpath tunggal pada semua node.  Kami hanya perlu memastikan bahwa classpath yang sama terlibat dalam runtime.  (Terlepas dari kenyataan bahwa sangat mungkin untuk menjalankan node yang berbeda dengan classpath yang berbeda, ini mengarah pada komplikasi dari seluruh konfigurasi dan kesulitan dengan tes penyebaran dan integrasi.) Sebagai bagian dari posting ini, kami mengasumsikan bahwa classpath yang sama akan digunakan pada semua node. </p><br><p>  Konfigurasi berkembang dengan aplikasi.  Untuk mengidentifikasi berbagai tahapan evolusi program, kami menggunakan versi.  Tampaknya logis juga mengidentifikasi berbagai versi konfigurasi.  Dan konfigurasi itu sendiri harus ditempatkan di sistem kontrol versi.  Jika hanya ada satu konfigurasi dalam produksi, maka kita bisa menggunakan nomor versi.  Jika banyak contoh produksi digunakan, maka kita perlu beberapa <br>  cabang konfigurasi dan label tambahan selain versi (misalnya, nama cabang).  Dengan demikian, kita dapat secara unik mengidentifikasi konfigurasi yang tepat.  Setiap pengidentifikasi konfigurasi secara unik sesuai dengan kombinasi tertentu dari node terdistribusi, port, sumber daya eksternal, versi perpustakaan.  Dalam kerangka posting ini, kami akan melanjutkan dari fakta bahwa hanya ada satu cabang, dan kami dapat mengidentifikasi konfigurasi dengan cara biasa menggunakan tiga angka yang dipisahkan oleh titik (1.2.3). </p><br><p>  Dalam lingkungan modern, file konfigurasi secara manual dibuat sangat jarang.  Lebih sering mereka dihasilkan selama penyebaran dan mereka tidak lagi tersentuh (agar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak merusak apa pun</a> ).  Muncul pertanyaan logis, mengapa kita masih menggunakan format teks untuk menyimpan konfigurasi?  Alternatif yang sepenuhnya layak adalah kemampuan untuk menggunakan kode reguler untuk konfigurasi dan mendapatkan manfaat dari cek pada waktu kompilasi. </p><br><p>  Dalam posting ini, kami hanya mengeksplorasi ide mewakili konfigurasi di dalam artefak yang dikompilasi. </p><br><h3 id="kompiliruemaya-konfiguraciya">  Konfigurasi yang dikompilasi </h3><br><p>  Bagian ini menjelaskan contoh konfigurasi terkompilasi statis.  Dua layanan sederhana diterapkan - layanan gema dan layanan gema klien.  Berdasarkan dua layanan ini, dua versi sistem dirakit.  Dalam satu perwujudan, kedua layanan terletak pada node yang sama, dalam perwujudan lain, pada node yang berbeda. </p><br><p> Biasanya, sistem terdistribusi berisi beberapa node.  Node dapat diidentifikasi menggunakan nilai dari beberapa tipe <code>NodeId</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Backend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Frontend</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span></span></code> </pre> <br><p>  atau </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">hostName: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  atau bahkan </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span></code> </pre> <br><p>  Node memainkan berbagai peran, layanan diluncurkan pada mereka dan komunikasi TCP / HTTP dapat dibuat di antara mereka. </p><br><p>  Untuk menggambarkan komunikasi TCP, kita memerlukan setidaknya nomor port.  Kami juga ingin merefleksikan protokol yang didukung pada port ini untuk memastikan bahwa klien dan server menggunakan protokol yang sama.  Kami akan menggambarkan koneksi menggunakan kelas ini: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TcpEndPoint</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">node: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">NodeId</span></span></span></span><span class="hljs-class"><span class="hljs-params">, port: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Port</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Protocol</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  di mana <code>Port</code> hanyalah <code>Int</code> integer dengan rentang nilai yang valid: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortNumber</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Closed</span></span>[_0, <span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-number"><span class="hljs-number">65535</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]]</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jenis Halus</b> <div class="spoiler_text"><p>  Lihat perpustakaan yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disempurnakan</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saya</a> .  Singkatnya, perpustakaan memungkinkan Anda untuk menambahkan kendala yang diperiksa pada waktu kompilasi untuk mengetik.  Dalam hal ini, nilai nomor port yang valid adalah bilangan bulat 16-bit.  Untuk konfigurasi yang dikompilasi, menggunakan perpustakaan yang disempurnakan adalah opsional, tetapi dapat meningkatkan kemampuan kompiler untuk memverifikasi konfigurasi. </p></div></div><br><p>  Untuk protokol HTTP (REST), selain nomor port, kami juga mungkin memerlukan jalur ke layanan: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UrlPathPrefix</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Refined</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">MatchesRegex</span></span>[<span class="hljs-type"><span class="hljs-type">W</span></span>.`<span class="hljs-string"><span class="hljs-string">"[a-zA-Z_0-9/]*"</span></span>`.<span class="hljs-type"><span class="hljs-type">T</span></span>]] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortWithPrefix</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Protocol</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">portNumber: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">PortNumber</span></span></span></span><span class="hljs-class"><span class="hljs-params">, pathPrefix: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">UrlPathPrefix</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Jenis hantu</b> <div class="spoiler_text"><p>  Untuk mengidentifikasi protokol pada tahap kompilasi, kami menggunakan parameter tipe yang tidak digunakan di dalam kelas.  Keputusan ini disebabkan oleh kenyataan bahwa dalam runtime kami tidak menggunakan contoh protokol, tetapi kami ingin kompiler memeriksa kompatibilitas protokol.  Berkat protokol, kami tidak akan dapat mentransfer layanan yang tidak sesuai sebagai ketergantungan. </p></div></div><br><p>  Salah satu protokol yang umum adalah REST API dengan serialisasi Json: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonHttpRestProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  di mana <code>RequestMessage</code> adalah jenis permintaan, <code>ResponseMessage</code> adalah jenis respons. <br>  Tentu saja, Anda dapat menggunakan deskripsi protokol lain yang memberikan akurasi yang kami butuhkan. </p><br><p>  Untuk keperluan posting ini, kami akan menggunakan versi protokol yang disederhanakan: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleHttpGetRest</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RequestMessage</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ResponseMessage</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><p>  Di sini, permintaan adalah string yang ditambahkan ke url, dan responsnya adalah string yang dikembalikan di badan respons HTTP. </p><br><p>  Konfigurasi layanan dijelaskan oleh nama layanan, port, dan dependensi.  Elemen-elemen ini dapat direpresentasikan dalam Scala dalam beberapa cara (misalnya, <code>HList</code> , tipe data aljabar).  Untuk keperluan posting ini, kita akan menggunakan Pola Kue dan mewakili modul menggunakan <code>trait</code> .  (Pola Kue bukan elemen yang diperlukan dari pendekatan yang dijelaskan. Ini hanya salah satu implementasi yang mungkin.) </p><br><p>  Ketergantungan antara layanan dapat direpresentasikan sebagai metode yang mengembalikan port <code>EndPoint</code> dari node lain: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoProtocol</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">SimpleHttpGetRest</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8081</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoPort</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = <span class="hljs-type"><span class="hljs-type">PortWithPrefix</span></span>[<span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]](portNumber, <span class="hljs-string"><span class="hljs-string">"echo"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoService</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] = providedSimpleService(echoPort) }</code> </pre> <br><p>  Untuk membuat layanan gema, hanya nomor port dan indikasi bahwa port ini mendukung protokol gema sudah cukup.  Kami tidak dapat menunjukkan port tertentu, karena  sifat memungkinkan Anda untuk mendeklarasikan metode tanpa implementasi (metode abstrak).  Dalam hal ini, ketika membuat konfigurasi tertentu, kompiler akan meminta kami untuk menyediakan implementasi metode abstrak dan memberikan nomor port.  Karena kami menerapkan metode ini, saat membuat konfigurasi tertentu, kami tidak dapat menentukan port lain.  Nilai default akan digunakan. </p><br><p>  Dalam konfigurasi klien, kami menyatakan ketergantungan pada layanan gema: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testMessage</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">"test"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pollInterval</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">FiniteDuration</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">echoServiceDependency</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">HttpSimpleGetEndPoint</span></span>[_, <span class="hljs-type"><span class="hljs-type">EchoProtocol</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]] }</code> </pre> <br><p>  Ketergantungan dari jenis yang sama dengan layanan yang diekspor <code>echoService</code> .  Secara khusus, di klien gema kami memerlukan protokol yang sama.  Karena itu, ketika menghubungkan kedua layanan, kita dapat yakin bahwa semuanya akan bekerja dengan benar. </p><br><div class="spoiler">  <b class="spoiler_title">Implementasi layanan</b> <div class="spoiler_text"><p>  Untuk memulai dan menghentikan layanan, diperlukan suatu fungsi.  (Kemampuan untuk menghentikan layanan sangat penting untuk pengujian.) Sekali lagi, ada beberapa opsi untuk mengimplementasikan fungsi ini (misalnya, kita bisa menggunakan kelas tipe berdasarkan tipe konfigurasi).  Untuk keperluan posting ini, kami akan menggunakan Pola Kue.  Kami akan mewakili layanan menggunakan kelas <code>cats.Resource</code> , karena  Di kelas ini, sarana pelepasan sumber daya yang dijamin aman jika terjadi masalah sudah disediakan.  Untuk mendapatkan sumber daya kita perlu menyediakan konfigurasi dan konteks runtime yang siap.  Fungsi untuk memulai layanan mungkin terlihat seperti ini: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResourceReader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Resource</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>]] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">resource</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> implicit resolver: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">AddressResolver</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], timer: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Timer</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], contextShift: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ContextShift</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">], ec: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ExecutionContext</span></span></span></span><span class="hljs-class"><span class="hljs-params">, applicative: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Applicative</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">F</span></span></span></span><span class="hljs-class"><span class="hljs-params">] </span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] }</code> </pre> <br><p>  dimana </p><br><ul><li>  <code>Config</code> - jenis konfigurasi untuk layanan ini </li><li>  <code>AddressResolver</code> - objek runtime yang memungkinkan Anda mengetahui alamat node lain (lihat di bawah) </li></ul><br><p>  dan jenis lain dari perpustakaan <code>cats</code> : </p><br><ul><li>  <code>F[_]</code> - jenis efek (dalam kasus paling sederhana, <code>F[A]</code> hanya bisa menjadi fungsi <code>() =&gt; A</code> Dalam posting ini kita akan menggunakan <code>cats.IO</code> ) </li><li>  <code>Reader[A,B]</code> - kurang lebih identik dengan fungsi <code>A =&gt; B</code> </li><li>  <code>cats.Resource</code> - sumber daya yang dapat diperoleh dan dirilis </li><li>  <code>Timer</code> - timer (memungkinkan Anda tertidur sebentar dan mengukur interval waktu) </li><li>  <code>ContextShift</code> - analog dari <code>ExecutionContext</code> </li><li>  <code>Applicative</code> - kelas jenis efek yang memungkinkan Anda untuk menggabungkan efek individual (hampir monad).  Dalam aplikasi yang lebih kompleks, tampaknya lebih baik menggunakan <code>Monad</code> / <code>ConcurrentEffect</code> . </li></ul><br><p>  Dengan menggunakan tanda tangan fungsi ini, kita dapat mengimplementasikan beberapa layanan.  Misalnya, layanan yang tidak melakukan apa pun: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Any</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resource</span></span></span></span>(...): <span class="hljs-type"><span class="hljs-type">ResourceReader</span></span>[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>] = <span class="hljs-type"><span class="hljs-type">Reader</span></span>(_ =&gt; <span class="hljs-type"><span class="hljs-type">Resource</span></span>.pure[<span class="hljs-type"><span class="hljs-type">F</span></span>, <span class="hljs-type"><span class="hljs-type">Unit</span></span>](())) }</code> </pre> </div></div><br><p>  (Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber</a> untuk layanan lain - layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gema</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">klien gema</a> <br>  dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengontrol seumur hidup</a> .) </p><br><p>  Node adalah objek yang dapat memulai beberapa layanan (peluncuran rantai sumber daya dipastikan oleh Pola Kue): </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Harap perhatikan bahwa kami menunjukkan jenis konfigurasi persis yang diperlukan untuk simpul ini.  Jika kita lupa menentukan salah satu tipe konfigurasi yang diperlukan oleh layanan terpisah, akan ada kesalahan kompilasi.  Selain itu, kami tidak akan dapat memulai node jika kami tidak menyediakan beberapa objek dari tipe yang sesuai dengan semua data yang diperlukan. </p><br><div class="spoiler">  <b class="spoiler_title">Resolusi Nama Host</b> <div class="spoiler_text"><p>  Untuk terhubung ke host jarak jauh, kami membutuhkan alamat IP asli.  Ada kemungkinan bahwa alamat tersebut akan diketahui setelah konfigurasi lainnya.  Oleh karena itu, kita memerlukan fungsi yang memetakan pengidentifikasi simpul ke alamat: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeAddress</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NodeId</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">host: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Uri</span></span></span></span><span class="hljs-class"><span class="hljs-params">.</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Host</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AddressResolver</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">F</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>](nodeId: <span class="hljs-type"><span class="hljs-type">NodeId</span></span>): <span class="hljs-type"><span class="hljs-type">F</span></span>[<span class="hljs-type"><span class="hljs-type">NodeAddress</span></span>[<span class="hljs-type"><span class="hljs-type">NodeId</span></span>]] }</code> </pre> <br><p>  Anda dapat menawarkan beberapa cara untuk mengimplementasikan fungsi tersebut: </p><br><ol><li>  Jika alamat diketahui oleh kami sebelum penerapan, maka kami dapat membuat kode Scala <br>  alamat dan kemudian mulai majelis.  Ini akan mengkompilasi dan menjalankan tes. <br>  Dalam hal ini, fungsinya akan diketahui secara statis dan dapat direpresentasikan dalam kode sebagai tampilan peta <code>Map[NodeId, NodeAddress]</code> . </li><li>  Dalam beberapa kasus, alamat yang valid hanya diketahui setelah node dimulai. <br>  Dalam hal ini, kita dapat mengimplementasikan "layanan penemuan" (discovery), yang berjalan sebelum node lain dan semua node akan mendaftar dalam layanan ini dan meminta alamat node lain. </li><li>  Jika kita dapat memodifikasi <code>/etc/hosts</code> , maka kita dapat menggunakan nama host yang telah ditentukan (seperti <code>my-project-main-node</code> dan <code>echo-backend</code> ) dan hanya mengikat nama-nama ini <br>  dengan alamat IP selama penyebaran. </li></ol><br><p>  Dalam kerangka posting ini, kami tidak akan mempertimbangkan kasus ini secara lebih rinci.  Untuk kita <br>  Dalam contoh mainan, semua node akan memiliki satu alamat IP - <code>127.0.0.1</code> . </p></div></div><br><p>  Berikutnya, kami mempertimbangkan dua opsi untuk sistem terdistribusi: </p><br><ol><li>  Penempatan semua layanan pada satu node. </li><li>  Dan penempatan layanan gema dan klien gema pada node yang berbeda. </li></ol><br><p>  Konfigurasi untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu simpul</a> : </p><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi simpul tunggal</b> <div class="spoiler_text"><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleNodeConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Singleton</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">identifier</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">the</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">single</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">node</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">configuration</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">of</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">server</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">Singleton</span></span> <span class="hljs-comment"><span class="hljs-comment">/** Type safe service port specification. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8088</span></span> <span class="hljs-comment"><span class="hljs-comment">// configuration of client /** We'll use the service provided by the same host. */ def echoServiceDependency = echoService override def testMessage: UrlPathElement = "hello" def pollInterval: FiniteDuration = 1.second // lifecycle controller configuration def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 requests, not 9. }</span></span></code> </pre> </div></div><br><p>  Objek mengimplementasikan konfigurasi klien dan server.  Konfigurasi seumur hidup juga digunakan untuk mengakhiri program setelah <code>lifetime</code> .  (Ctrl-C juga berfungsi dan membebaskan semua sumber daya dengan benar.) </p><br><p>  Rangkaian sifat dan implementasi konfigurasi yang sama dapat digunakan untuk membuat sistem yang terdiri dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua node terpisah</a> : </p><br><div class="spoiler">  <b class="spoiler_title">Konfigurasi untuk dua node</b> <div class="spoiler_text"><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeServerConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigTermLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeIdImpl</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nodeId</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-type"><span class="hljs-type">NodeServer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">portNumber</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">PortNumber</span></span> = <span class="hljs-number"><span class="hljs-number">8080</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeClientConfig</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientConfig</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// NB! dependency specification def echoServiceDependency = NodeServerConfig.echoService def pollInterval: FiniteDuration = 1.second def lifetime: FiniteDuration = 10500.milliseconds // additional 0.5 seconds so that there are 10 request, not 9. def testMessage: String = "dolly" }</span></span></code> </pre> </div></div><br><p>  Penting!  Perhatikan bagaimana pengikatan layanan dilakukan.  Kami menunjukkan layanan yang diterapkan oleh satu node sebagai implementasi dari metode dependensi dari node lain.  Jenis ketergantungan diperiksa oleh kompiler, karena  berisi jenis protokol.  Ketika diluncurkan, dependensi akan berisi pengidentifikasi yang benar dari node target.  Berkat skema ini, kami menunjukkan nomor port tepat sekali dan selalu dijamin untuk merujuk ke port yang benar. </p><br><div class="spoiler">  <b class="spoiler_title">Implementasi dua node sistem</b> <div class="spoiler_text"><p>  Untuk konfigurasi ini, kami menggunakan implementasi layanan yang sama tanpa perubahan.  Satu-satunya perbedaan adalah bahwa sekarang kami memiliki dua objek yang mengimplementasikan set layanan yang berbeda: </p><br><pre> <code class="scala hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeServerImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoServiceService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SigIntLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">SigTermLifecycleConfig</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoJvmNodeClientImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ZeroServiceImpl</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EchoClientService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FiniteDurationLifecycleServiceImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">EchoClientConfig</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FiniteDurationLifecycleConfig</span></span> }</code> </pre> <br><p>  Node pertama mengimplementasikan server dan hanya membutuhkan konfigurasi server.  Node kedua diimplementasikan oleh klien dan menggunakan bagian lain dari konfigurasi.  Kedua node juga perlu mengatur waktu hidup.  Node server berjalan tanpa batas hingga dihentikan oleh <code>SIGTERM</code> , dan node klien berakhir setelah beberapa waktu.  Lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi peluncuran</a> . </p></div></div><br><h4 id="obschiy-process-razrabotki">  Proses pengembangan umum </h4><br><p>  Mari kita lihat bagaimana pendekatan konfigurasi ini mempengaruhi keseluruhan proses pengembangan. </p><br><p>  Konfigurasi akan dikompilasi bersama dengan sisa kode dan artefak (.jar) akan dihasilkan.  Tampaknya, masuk akal untuk meletakkan konfigurasi dalam artefak terpisah.  Ini disebabkan oleh kenyataan bahwa kita dapat memiliki banyak konfigurasi berdasarkan kode yang sama.  Sekali lagi, Anda dapat membuat artefak yang sesuai dengan cabang konfigurasi yang berbeda.  Bersama dengan konfigurasi, dependensi pada versi perpustakaan tertentu dipertahankan dan versi ini dipertahankan selamanya, setiap kali kami memutuskan untuk menggunakan versi konfigurasi ini. </p><br><p>  Perubahan konfigurasi apa pun berubah menjadi perubahan kode.  Dan oleh karena itu, masing-masing <br>  Perubahan akan ditanggung oleh proses penjaminan kualitas yang biasa: </p><br><p>  Tiket di bugtracker -&gt; PR -&gt; ulasan -&gt; bergabung dengan cabang terkait -&gt; <br>  integrasi -&gt; penyebaran </p><br><p>  Konsekuensi utama dari penerapan konfigurasi yang dikompilasi: </p><br><ol><li><p>  Konfigurasi akan dikoordinasikan pada semua node dari sistem terdistribusi.  Karena semua node menerima konfigurasi yang sama dari satu sumber. </p><br></li><li><p>  Bermasalah untuk mengubah konfigurasi hanya di salah satu node.  Oleh karena itu, "konfigurasi drift" tidak mungkin. </p><br></li><li><p>  Menjadi lebih sulit untuk membuat perubahan konfigurasi kecil. </p><br></li><li><p>  Sebagian besar perubahan konfigurasi akan terjadi sebagai bagian dari keseluruhan proses pengembangan dan akan ditinjau. </p><br></li></ol><br><p>  Apakah saya memerlukan repositori terpisah untuk menyimpan konfigurasi produksi?  Konfigurasi seperti itu mungkin berisi kata sandi dan informasi rahasia lainnya, akses yang ingin kami batasi.  Berdasarkan hal ini, tampaknya masuk akal untuk menyimpan konfigurasi final dalam repositori terpisah.  Anda dapat membagi konfigurasi menjadi dua bagian - satu berisi pengaturan konfigurasi publik, dan yang lainnya berisi pengaturan akses terbatas.  Ini akan memungkinkan sebagian besar pengembang memiliki akses ke parameter umum.  Pemisahan ini mudah dicapai dengan menggunakan sifat-sifat peralihan yang mengandung nilai-nilai default. </p><br><h3 id="vozmozhnye-variacii">  Kemungkinan variasi </h3><br><p>  Mari kita coba membandingkan konfigurasi yang dikompilasi dengan beberapa alternatif umum: </p><br><ol><li>  File teks pada mesin target. </li><li>  Penyimpanan terpusat nilai kunci ( <code>etcd</code> / <code>zookeeper</code> ). </li><li>  Komponen proses yang dapat dikonfigurasi ulang / dihidupkan ulang tanpa memulai kembali proses. </li><li>  Penyimpanan konfigurasi di luar artefak dan kontrol versi. </li></ol><br><p>  File teks memberikan fleksibilitas signifikan dalam hal perubahan kecil.  Administrator sistem dapat pergi ke node jarak jauh, membuat perubahan pada file yang sesuai dan memulai kembali layanan.  Namun, untuk sistem yang besar, fleksibilitas semacam itu mungkin tidak diinginkan.  Dari perubahan yang dilakukan tidak ada jejak di sistem lain.  Tidak ada yang mengulas perubahan.  Sulit menentukan siapa yang melakukan perubahan dan untuk alasan apa.  Perubahan tidak diuji.  Jika sistem didistribusikan, maka administrator mungkin lupa untuk membuat perubahan yang sesuai pada node lain. </p><br><p>  (Perlu juga dicatat bahwa penggunaan konfigurasi yang dikompilasi tidak memblokir kemungkinan menggunakan file teks di masa depan. Ini akan cukup untuk menambahkan parser dan validator yang memberikan jenis <code>Config</code> sama sebagai output, dan Anda dapat menggunakan file teks. Segera mengikuti kompleksitas sistem dengan konfigurasi yang dikompilasi agak kurang dari kompleksitas sistem yang menggunakan file teks, karena file teks memerlukan kode tambahan.) </p><br><p>  Penyimpanan nilai kunci terpusat adalah mekanisme yang baik untuk mendistribusikan meta-parameter aplikasi terdistribusi.  Kita harus memutuskan parameter konfigurasi apa dan apa itu data.  Misalkan kita memiliki fungsi <code>C =&gt; A =&gt; B</code> , dengan parameter <code>C</code> jarang berubah, dan data <code>A</code> sering.  Dalam hal ini, kita dapat mengatakan bahwa <code>C</code> adalah parameter konfigurasi, dan <code>A</code> adalah datanya.  Tampaknya parameter konfigurasi berbeda dari data di mana mereka umumnya berubah lebih jarang daripada data.  Selain itu, data biasanya berasal dari satu sumber (dari pengguna), dan parameter konfigurasi dari yang lain (dari administrator sistem). </p><br><p>  Jika jarang mengubah parameter perlu diperbarui tanpa me-restart program, maka ini sering dapat menyebabkan komplikasi program, karena kita perlu entah bagaimana memberikan parameter, menyimpan, mengurai dan memeriksa, memproses nilai-nilai yang salah.  Oleh karena itu, dari sudut pandang mengurangi kompleksitas program, masuk akal untuk mengurangi jumlah parameter yang dapat berubah selama program (atau tidak mendukung parameter tersebut sama sekali). </p><br><p>  Dari sudut pandang pos ini, kita akan membedakan antara parameter statis dan dinamis.  Jika logika layanan memerlukan perubahan parameter selama program, maka kami akan memanggil parameter tersebut dinamis.  Jika tidak, parameternya statis dan dapat dikonfigurasi menggunakan konfigurasi yang dikompilasi.  Untuk konfigurasi ulang dinamis, kita mungkin memerlukan mekanisme untuk memulai kembali bagian program dengan parameter baru, mirip dengan bagaimana proses sistem operasi dihidupkan ulang.  (Menurut pendapat kami, disarankan untuk menghindari konfigurasi ulang waktu-nyata, karena kompleksitas sistem meningkat. Jika memungkinkan, lebih baik menggunakan kemampuan OS standar untuk memulai kembali proses.) </p><br><p>  Salah satu aspek penting dari menggunakan konfigurasi statis yang memaksa orang untuk mempertimbangkan konfigurasi ulang dinamis adalah waktu yang diperlukan sistem untuk reboot setelah pembaruan konfigurasi (downtime).  Bahkan, jika kita perlu membuat perubahan pada konfigurasi statis, kita harus me-restart sistem agar nilai-nilai baru berlaku.  Masalah downtime memiliki tingkat keparahan yang berbeda untuk sistem yang berbeda.  Dalam beberapa kasus, Anda dapat menjadwalkan reboot pada saat beban minimal.  Jika Anda ingin memberikan layanan terus menerus, Anda dapat menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"koneksi drainase" (AWS ELB draining)</a> .  Pada saat yang sama, ketika kita perlu me-reboot sistem, kita meluncurkan instance paralel dari sistem ini, alihkan balancer ke sana, dan tunggu sampai koneksi lama selesai.  Setelah semua koneksi lama selesai, kami mematikan instance sistem yang lama. </p><br><p>  Sekarang mari kita pertimbangkan masalah menyimpan konfigurasi di dalam atau di luar artefak.  Jika kita menyimpan konfigurasi di dalam artefak, maka setidaknya kita memiliki kesempatan selama perakitan artefak untuk memastikan konfigurasi itu benar.  Jika konfigurasi di luar artefak yang dikontrol, sulit untuk melacak siapa dan mengapa membuat perubahan pada file ini.  Seberapa pentingkah ini?  Menurut pendapat kami, untuk banyak sistem produksi, penting untuk memiliki konfigurasi yang stabil dan berkualitas tinggi. </p><br><p>  Versi artifact memungkinkan Anda untuk menentukan kapan itu dibuat, nilai-nilai apa yang dikandungnya, fungsi apa yang diaktifkan / dinonaktifkan, siapa yang bertanggung jawab atas setiap perubahan dalam konfigurasi.  Tentu saja, menyimpan konfigurasi di dalam artefak memerlukan beberapa upaya, jadi Anda perlu membuat keputusan. </p><br><h3 id="za-i-protiv">  Pro dan kontra </h3><br><p>  Saya ingin membahas pro dan kontra dari teknologi yang diusulkan. </p><br><h4 id="preimuschestva">  Manfaatnya </h4><br><p>  Berikut ini adalah daftar fitur utama dari konfigurasi sistem terdistribusi yang dikompilasi: </p><br><ol><li>  Pemeriksaan konfigurasi statis.  Memungkinkan Anda untuk memastikannya <br>  . </li><li>   .         .   Scala      ,   . ,    <br> trait'    ,     ,    val',    (DRY)    .        ( <code>Seq</code> , <code>Map</code> ,  ). </li><li> DSL.  Scala    ,   DSL.        ,         , ,           .  , ,     . </li><li>     .    ,           ,       ,    ,   .        ,          .       ,       . </li><li>    .    ,    ,        . </li><li>   .          ,     . </li><li>  .     ,      .     . (  ,     ,     ,     ,     -.)       —    .  , ,    ,       ,    . </li><li>  .          ,         .   , ,        .                .        .       ,       production'. </li><li> .    ,            .  ,           ,    —   .      production- . </li><li>  Pengujian.     mock-,     ,   . </li><li>  .                  .  , , ,     . </li></ol><br><h4 id="nedostatki-i-ogranicheniya">    </h4><br><p>               .    : </p><br><ol><li>  .       production',    .        .          .           . </li><li>  .  ,      ,        . </li><li> .      ,     ,    .    /      . </li><li>   .   DevOps    .             . </li><li>    .               (CI/CD).      . </li></ol><br><p>       ,      : </p><br><ol><li>      ,    ,        .    ,    Cake Pattern'     , , <code>HList</code>     (case class')   . </li><li>     ,     : ( <code>package</code> , <code>import</code> ,  ; <code>override def</code> '  ,    ).    ,    DSL.  ,    (, XML),       . </li><li>            . </li></ol><br><h3 id="zaklyuchenie">  Kesimpulan </h3><br><p>                  Scala.                 xml-   .   ,      Scala,          (  Kotlin, C#, Swift, ...).         , ,  ,    ,    ,   . </p><br><p> ,      .       . </p><br><p>     : </p><br><ol><li>         . </li><li>   DSL        . </li><li>         . ,       ,  (1)      ; (2)       . </li></ol><br><h3 id="blagodarnosti">  </h3><br><p>     ,          . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id447694/">https://habr.com/ru/post/id447694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id447682/index.html">Space Data Center: 24 jam sebelum peluncuran</a></li>
<li><a href="../id447684/index.html">Cara menunjukkan nilai-nilai perusahaan di kantor (tanpa poster dan slogan)</a></li>
<li><a href="../id447686/index.html">Parameter yang sangat penting dari lampu LED, yang hanya sedikit orang ketahui</a></li>
<li><a href="../id447688/index.html">Untuk pertanyaan tentang bitset</a></li>
<li><a href="../id447690/index.html">Konfigurasi yang dapat dikompilasi dari sistem terdistribusi</a></li>
<li><a href="../id447696/index.html">Mengapa kota menentang Amazon Go, toko non-tunai pertama</a></li>
<li><a href="../id447698/index.html">Red Hogwarts: Akademisi tanpa ijazah</a></li>
<li><a href="../id447700/index.html">Fleksibilitas emosional adalah kunci pertumbuhan pribadi.</a></li>
<li><a href="../id447702/index.html">Lingkaran matematika yang ideal tidak ada</a></li>
<li><a href="../id447704/index.html">Climbing Elbrus - Pengintaian dalam pertempuran. Bagian Teknis 1. Register, tumpukan dan detail teknis lainnya</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>