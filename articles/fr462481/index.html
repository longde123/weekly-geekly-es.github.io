<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦ â–ªï¸ ğŸ‘¨ğŸ¿â€ğŸ”¬ FAQ sur le systÃ¨me de type ğŸ’š ğŸŒ€ ğŸ‘¨ğŸ¾â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur de l'article, dont nous publions la traduction aujourd'hui, affirme que ce billet et ses commentaires ont servi de source d'inspiration pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FAQ sur le systÃ¨me de type</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/462481/">  L'auteur de l'article, dont nous publions la traduction aujourd'hui, affirme que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> billet et ses commentaires ont servi de source d'inspiration pour sa rÃ©daction.  Selon lui, les informaticiens ont des idÃ©es fausses sur les types, utilisent une terminologie incorrecte et, discutant des problÃ¨mes liÃ©s aux types, tirent des conclusions erronÃ©es.  Il note qu'il n'est pas un dÃ©fenseur du systÃ¨me de type statique.  La seule chose qui le dÃ©range est l'utilisation correcte des termes.  Cela permet des discussions constructives.  L'auteur dit qu'il a Ã©crit ce matÃ©riel spontanÃ©ment, mais espÃ¨re qu'il ne contient aucune erreur.  S'il a confondu quelque chose, il demande de le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lui</a> faire savoir. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5h/v0/_9/5hv0_9iyqwfr7itow5ihgjdpdio.jpeg"></a> <br><br>  Comprenons une fois pour toutes ce qui cause la confusion lorsque l'on parle de systÃ¨mes de types. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Saisie dynamique et manque de frappe</font> </h2><br>  Certaines personnes pensent qu'un systÃ¨me de type dynamique est identique Ã  un systÃ¨me de type non typÃ©.  L'absence de saisie signifie que dans un certain systÃ¨me de types, il est inutile de distinguer les types.  Cela n'a aucun sens de distinguer les types mÃªme si un seul type est prÃ©sent dans le systÃ¨me de types.  Par exemple: <br><br><ul><li>  Dans l'assembleur, le seul type est une chaÃ®ne de bits. </li><li>  Dans le calcul lambda, le seul type est la fonction. </li></ul><br>  Quelqu'un peut dire ceci Ã  cette occasion: "Mais quelle diffÃ©rence cela fait-il - la frappe dynamique ou le manque de frappe - aussi une question pour moi."  Mais cela, en fait, est un problÃ¨me important et important.  Le fait est que si vous assimilez le typage dynamique au manque de typage, cela signifie l'adoption automatique du fait qu'un systÃ¨me de type dynamique est l'opposÃ© d'un systÃ¨me de type statique.  En consÃ©quence, deux camps opposÃ©s de programmeurs sont formÃ©s - le camp de typage dynamique et le camp de typage statique (et cela, comme nous le verrons dans la section correspondante, est faux). <br><br>  <i><font color="#999999">Les langages qui ne limitent pas la plage de valeurs des variables sont appelÃ©s langages non typÃ©s: ils n'ont pas de types ou, ce qui est la mÃªme chose, ils n'ont qu'un seul type universel qui contient toutes les valeurs.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SystÃ¨mes de types, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">Les langages de programmation ont une fonctionnalitÃ© intÃ©ressante qui vous permet de diviser grossiÃ¨rement leur monde en deux groupes:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  Langues non typÃ©es - les programmes s'exÃ©cutent simplement.  Cela se fait rapidement, sans chercher Ã  vÃ©rifier Â«l'uniformitÃ© des formesÂ». </li><li>  Langages typÃ©s - une tentative est faite pour vÃ©rifier Â«l'uniformitÃ© de la formeÂ» - soit pendant la compilation, soit pendant l'exÃ©cution du programme. </li></ul><br>  <sub>Â«SystÃ¨mes de types pour les langages de programmationÂ», Benjamin Pearce</sub> <br><br><h2>  <font color="#3AC1EF">Typage dynamique et statique</font> </h2><br>  Un systÃ¨me de type dynamique est un systÃ¨me dans lequel les types sont vÃ©rifiÃ©s dynamiquement (pendant l'exÃ©cution du programme).  Un systÃ¨me de type statique est un systÃ¨me dans lequel les types sont vÃ©rifiÃ©s statiquement (lors de la compilation ou de la traduction du code). <br><br>  L'un de ces systÃ¨mes est-il l'opposÃ© de l'autre?  Non, Ã§a ne l'est pas.  Les deux types de systÃ¨mes peuvent Ãªtre utilisÃ©s dans la mÃªme langue.  En fait, la plupart des systÃ¨mes de type statiques ont Ã©galement des vÃ©rifications de type dynamiques.  Ã€ titre d'exemple, considÃ©rons la validation des opÃ©rations d'entrÃ©e-sortie (entrÃ©e-sortie, IO).  Imaginez que vous devez lire les donnÃ©es fournies par un utilisateur qui doit saisir un numÃ©ro.  Vous vÃ©rifierez, pendant l'exÃ©cution du programme, si le nombre est le rÃ©sultat de l'analyse de la ligne correspondante (Ã  la suite de l'analyse, une exception peut Ãªtre levÃ©e ou quelque chose comme <code>NaN</code> sera retournÃ©).  Lorsque vous vÃ©rifiez les donnÃ©es entrÃ©es par l'utilisateur, en dÃ©terminant si elles peuvent Ãªtre considÃ©rÃ©es comme un nombre - vous effectuez une vÃ©rification de type dynamique. <br><br>  En consÃ©quence, nous pouvons noter l'absence de confrontation entre les types statiques et dynamiques.  Vous pouvez utiliser, dans la mÃªme langue, ceux-ci et les autres. <br><br>  De plus, il convient de noter que la vÃ©rification de type statique est un processus complexe.  Parfois, il est trÃ¨s difficile de vÃ©rifier statiquement certaines parties d'un programme.  Par consÃ©quent, au lieu d'appliquer des vÃ©rifications de type statique, vous pouvez recourir Ã  des vÃ©rifications dynamiques. <br><br>  Il est recommandÃ© de considÃ©rer un systÃ¨me de type statique comme des types qui sont vÃ©rifiÃ©s statiquement.  Un systÃ¨me de type dynamique est comme des types qui sont vÃ©rifiÃ©s dynamiquement. <br><br><h2>  <font color="#3AC1EF">L'utilisation de types statiques signifie-t-elle connaÃ®tre les types au moment de la compilation?</font> </h2><br>  La question posÃ©e dans le titre de cette section peut recevoir une rÃ©ponse nÃ©gative.  Si vous ouvrez le code source d'un analyseur (y compris l'analyseur JavaScript), vous pouvez voir que l'analyseur connaÃ®t les types de valeurs pendant l'analyse (cela fait partie du processus de compilation). <br><br><pre> <code class="plaintext hljs">let x = "test";</code> </pre> <br>  Il s'avÃ¨re que l'analyseur sait que <code>"test"</code> est une chaÃ®ne.  Cela fait-il de JavaScript un langage typÃ© statique?  Non, non. <br><br><h2>  <font color="#3AC1EF">Saisie progressive</font> </h2><br>  Un systÃ¨me de type progressif est un systÃ¨me de type statique qui vous permet d'ignorer les vÃ©rifications de type pour certaines parties d'un programme.  Par exemple, dans TypeScript, cela est implÃ©mentÃ© en utilisant <code>any</code> ou <code>@ts-ignore</code> . <br><br>  D'une part, cela rend le systÃ¨me de type moins sÃ»r.  D'un autre cÃ´tÃ©, un systÃ¨me de typage avec typage progressif vous permet d'ajouter progressivement des descriptions de typage aux langues avec typage dynamique. <br><br><h2>  <font color="#3AC1EF">SystÃ¨mes de type fiables et peu fiables</font> </h2><br>  Si vous utilisez un systÃ¨me de type fiable (systÃ¨me de type sonore), le programme ne sera pas Â«approuvÃ©Â» lors de la vÃ©rification de type si ce programme contient des erreurs liÃ©es aux types.  L'utilisation d'un systÃ¨me de type dÃ©fectueux entraÃ®ne la possibilitÃ© d'erreurs de type dans le programme.  Certes, vous ne devriez pas paniquer aprÃ¨s l'avoir dÃ©couvert.  En pratique, cela peut ne pas vous affecter.  La fiabilitÃ© ou la soliditÃ© est une propriÃ©tÃ© mathÃ©matique d'un algorithme de vÃ©rification de type qui nÃ©cessite une preuve.  De nombreux compilateurs existants (en interne, systÃ¨mes de vÃ©rification de type) ne sont pas fiables. <br><br>  Si vous souhaitez travailler avec des systÃ¨mes de type fiables, jetez un Å“il aux langages de programmation de la famille ML, qui utilisent le systÃ¨me de type Hindley-Milner. <br><br>  De plus, il faut comprendre qu'un systÃ¨me de type fiable ne sautera pas le mauvais programme (il ne donne pas de rÃ©sultats de test faussement positifs, considÃ©rant que les mauvais programmes sont corrects), mais il peut ne pas manquer le programme correct (il peut donner des rÃ©sultats de test faussement nÃ©gatifs). <br><br>  Un systÃ¨me de type qui ne rejette jamais le bon programme est appelÃ© complet. <br><br>  Arrive-t-il qu'un systÃ¨me de type soit Ã  la fois fiable et complet?  Pour autant que je sache, de tels systÃ¨mes de types n'existent pas.  Je ne suis pas sÃ»r de cela jusqu'Ã  la fin, mais il me semble que l'existence de tels systÃ¨mes de types, s'ils sont basÃ©s sur le thÃ©orÃ¨me d'incomplÃ©tude de GÃ¶del, est fondamentalement impossible (je peux cependant me tromper Ã  ce sujet). <br><br><h2>  <font color="#3AC1EF">Typage faible et fort</font> </h2><br>  Je trouve inappropriÃ© d'utiliser les termes Â«frappe faibleÂ» et Â«frappe forteÂ».  Ces termes sont ambigus, leur utilisation peut donner plus de confusion que de clartÃ©.  Permettez-moi de vous donner quelques citations. <br><br>  <i><font color="#999999">Ces langues peuvent Ãªtre appelÃ©es, au sens figurÃ©, des langues Ã  vÃ©rification de type faible (ou des langues faiblement typÃ©es, comme elles sont gÃ©nÃ©ralement appelÃ©es dans diverses publications).</font></i>  <i><font color="#999999">L'utilisation d'une vÃ©rification de type faible dans la langue signifie que certaines opÃ©rations dangereuses sont dÃ©tectÃ©es statiquement, et d'autres non.</font></i>  <i><font color="#999999">La Â«faiblesseÂ» des vÃ©rifications de type dans les langues de cette classe varie considÃ©rablement.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SystÃ¨mes de types, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">La faÃ§on la plus courante de classer les systÃ¨mes de types est probablement de les diviser en systÃ¨mes de typage Â«faibleÂ» et Â«fortÂ».</font></i>  <i><font color="#999999">Cela ne peut Ãªtre que regrettÃ©, car ces mots n'ont pratiquement aucun sens en eux-mÃªmes.</font></i>  <i><font color="#999999">Il est possible, dans une mesure limitÃ©e, de comparer deux langues qui ont des systÃ¨mes de types trÃ¨s similaires et de sÃ©lectionner l'une d'entre elles comme ayant un systÃ¨me de types plus fort que la seconde.</font></i>  <i><font color="#999999">Dans d'autres cas, les termes Â«typage fortÂ» et Â«typage faibleÂ» n'ont aucun sens.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999"><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Â«Choses Ã  savoir avant de discuter des systÃ¨mes de typeÂ», Steve Klabnik</a></sub></font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">Les termes Â«typage fortÂ» et Â«typage faibleÂ» sont extrÃªmement ambigus.</font></i>  <i><font color="#999999">Voici quelques exemples de leur utilisation:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  <i><font color="#999999">Parfois, Â«typage fortÂ» signifie Â«typage statiqueÂ».</font></i>  <i><font color="#999999">Il n'est pas difficile de faire une telle Â«substitutionÂ», mais il vaut mieux, en parlant de typage statique, simplement l'appeler Â«statiqueÂ».</font></i>  <i><font color="#999999">Le fait est que la plupart des programmeurs comprennent clairement ce terme.</font></i> </li><li>  <i><font color="#999999">Parfois, quand ils disent Â«typage fortÂ», ils signifient Â«l'absence d'une conversion de type impliciteÂ».</font></i>  <i><font color="#999999">Par exemple, en JavaScript, vous pouvez utiliser des expressions comme <code>"a" - 1</code> .</font></i>  <i><font color="#999999">Cela peut Ãªtre appelÃ© un modÃ¨le de "typage faible".</font></i>  <i><font color="#999999">Mais presque tous les langages offrent au programmeur des opportunitÃ©s de conversion de type implicite, par exemple, en prenant en charge la conversion automatique d'entiers en nombres Ã  virgule flottante dans des expressions comme <code>1 - 1.1</code> .</font></i>  <i><font color="#999999">Dans la pratique, la plupart des professionnels qui utilisent le terme Â«typage fortÂ» de cette maniÃ¨re distinguent les conversions de type Â«acceptableÂ» et Â«inacceptableÂ».</font></i>  <i><font color="#999999">Mais il n'y a pas de frontiÃ¨re gÃ©nÃ©ralement acceptÃ©e entre ces conversions de type.</font></i>  <i><font color="#999999">L 'Â«acceptabilitÃ©Â» et Â«l'inacceptabilitÃ©Â» des transformations est une Ã©valuation subjective, selon l'opinion d'une personne en particulier.</font></i> </li><li>  <i><font color="#999999">Parfois, les langues avec "typage fort" sont appelÃ©es les langues dans lesquelles il est impossible de contourner les rÃ¨gles du systÃ¨me de types qui y existe.</font></i> </li><li>  <i><font color="#999999">Parfois, Â«taper fortÂ» signifie avoir un systÃ¨me de saisie qui vous permet de travailler en toute sÃ©curitÃ© avec la mÃ©moire.</font></i>  <i><font color="#999999">Le langage C est un exemple notable d'un langage qui n'est pas sÃ»r avec la mÃ©moire.</font></i>  <i><font color="#999999">Par exemple, si <code>xs</code> est un tableau de quatre nombres, C approuvera sans problÃ¨me un code qui utilise des constructions comme <code>xs[5]</code> ou <code>xs[1000]</code> .</font></i>  <i><font color="#999999">Ils vous permettront d'accÃ©der Ã  la mÃ©moire situÃ©e aprÃ¨s les adresses allouÃ©es pour stocker le contenu du tableau <code>xs</code> .</font></i> </li></ul><br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les types, Gary Bernard</a></sub> <br><br><h2>  <font color="#3AC1EF">Les langages typÃ©s statiques ont-ils besoin de dÃ©clarations de type?</font> </h2><br>  Les langages typÃ©s statiquement n'ont pas toujours besoin de dÃ©clarations de type.  Parfois, un systÃ¨me de types peut dÃ©duire des types (en faisant des hypothÃ¨ses basÃ©es sur la structure du code).  Voici un exemple (TypeScript): <br><br><pre> <code class="plaintext hljs">const x = "test";</code> </pre> <br>  Le systÃ¨me de type sait que <code>"test"</code> est une chaÃ®ne (cette connaissance est basÃ©e sur les rÃ¨gles d'analyse de code).  Le systÃ¨me de types sait Ã©galement que <code>x</code> est une constante, c'est-Ã -dire que la valeur de <code>x</code> ne peut pas Ãªtre rÃ©affectÃ©e.  Par consÃ©quent, on peut conclure que <code>x</code> est de type chaÃ®ne. <br>  Voici un autre exemple (Flow): <br><br><pre> <code class="plaintext hljs">const add = (x, y) =&gt; x / y //            ^        [1]   . add(1, "2")</code> </pre> <br>  Le systÃ¨me de vÃ©rification de type voit que nous appelons la fonction <code>add</code> , en lui passant un nombre et une chaÃ®ne.  Ceci analyse la dÃ©claration de fonction.  Le systÃ¨me de vÃ©rification de type sait que pour effectuer l'opÃ©ration de division, les numÃ©ros doivent Ãªtre Ã  droite et Ã  gauche de l'opÃ©rateur correspondant.  L'un des opÃ©randes impliquÃ©s dans l'opÃ©ration de division n'est pas un nombre.  En consÃ©quence, nous sommes informÃ©s de l'erreur. <br><br>  Il n'y a pas de dÃ©claration de type ici, mais cela n'empÃªche pas une vÃ©rification de type statique du programme ci-dessus.  Si vous rencontrez des situations similaires dans le monde rÃ©el, alors, tÃ´t ou tard, vous devrez dÃ©clarer certains types.  Le systÃ¨me de types ne peut pas dÃ©duire absolument tous les types.  Mais vous devez comprendre qu'un langage peut Ãªtre appelÃ© Â«statiqueÂ» non pas parce qu'il utilise des dÃ©clarations de type, mais parce que les types sont vÃ©rifiÃ©s avant le dÃ©marrage du programme. <br><br><h2>  <font color="#3AC1EF">TypeScript est-il un langage dangereux car le code qui y est Ã©crit est compilÃ© en code JavaScript?</font> </h2><br>  TypeScript est un langage malsain.  Par consÃ©quent, le code Ã©crit dessus peut se transformer en applications dangereuses.  Mais cela n'a rien Ã  voir avec ce qu'il compile. <br><br>  La plupart des compilateurs de bureau convertissent les programmes en quelque chose qui ressemble Ã  un langage d'assemblage.  Et l'assembleur est un langage encore moins sÃ©curisÃ© que JS. <br><br>  Ici, si vous revenez Ã  l'idÃ©e que TS n'est pas sÃ©curisÃ© en raison de la compilation dans JS, vous pourriez obtenir la pensÃ©e suivante: Â«Le code compilÃ© est exÃ©cutÃ© dans le navigateur, JS est un langage dangereux, et il peut tout Ã  fait substituer <code>null</code> Ã  l'endroit oÃ¹ la ligne est attendue ".  La pensÃ©e est sensÃ©e.  Mais cela, encore une fois, ne donne pas de raison d'appeler TS un langage dangereux.  Afin que TS garantisse la sÃ©curitÃ© au sein de l'application, vous devez placer les Â«mÃ©canismes de dÃ©fenseÂ» aux endroits oÃ¹ le code TS interagit avec le monde extÃ©rieur.  C'est-Ã -dire, par exemple, que vous devez vÃ©rifier l'exactitude des donnÃ©es entrant dans le programme via les mÃ©canismes d'entrÃ©e-sortie.  Disons que cela peut Ãªtre de vÃ©rifier ce que l'utilisateur entre, de vÃ©rifier les rÃ©ponses du serveur, de vÃ©rifier les donnÃ©es lues Ã  partir du stockage du navigateur, etc. <br><br>  Par exemple, le rÃ´le de ces Â«mÃ©canismes de dÃ©fenseÂ» dans Elm est jouÃ© par les Â« <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ports</a> Â».  Dans TS, vous pouvez utiliser quelque chose comme io-ts pour cela. <br><br>  Le Â«mÃ©canisme de protectionÂ» correspondant crÃ©e un pont entre les systÃ¨mes de type statique et dynamique. <br><br>  Voici un exemple simplifiÃ©: <br><br><pre> <code class="plaintext hljs">const makeSureIsNumber = (x: any) =&gt; {  const result = parseFloat(x);  if (isNaN(result)) {    throw Error("Not a number");  }  return result; } const read = (input: any) =&gt; {  try {    const n = makeSureIsNumber(input);    //     n, ,      //              // makeSureIsNumber "" , n    } catch (e) { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Est-il vrai que les types ne sont nÃ©cessaires que pour les compilateurs?</font> </h2><br>  <i><font color="#999999">Les types ne sont que le hack nÃ©cessaire pour donner des indices au compilateur.</font></i> <br>  <sub>Waut Mertens</sub> <br><br>  Les types sont-ils uniquement nÃ©cessaires aux compilateurs?  C'est une question philosophique.  Les types sont nÃ©cessaires pour les gens, pas pour les voitures.  Les compilateurs ont besoin de types car ce sont des programmes Ã©crits par des personnes. <br><br>  Le phÃ©nomÃ¨ne des types existe Ã  cause des gens.  Les types n'existent que lorsqu'une personne perÃ§oit quelque chose sous la forme d'un Â«type de donnÃ©esÂ».  L'esprit humain divise diffÃ©rentes entitÃ©s en diffÃ©rentes catÃ©gories.  Les types n'ont pas de sens sans un observateur. <br><br>  Organisons une expÃ©rience de pensÃ©e.  Pensez au jeu Life.  Vous avez une grille bidimensionnelle composÃ©e de cellules carrÃ©es.  Chacune des cellules peut Ãªtre dans deux Ã©tats possibles.  Il peut Ãªtre "vivant" ou "mort".  Chaque cellule peut interagir avec ses huit voisins.  Ce sont des cellules qui la bordent verticalement, horizontalement ou en diagonale.  Dans le processus de recherche de l'Ã©tat suivant du systÃ¨me, les rÃ¨gles suivantes s'appliquent: <br><br><ul><li>  Une cellule Â«vivanteÂ» avec moins de deux voisins Â«vivantsÂ» Â«meurtÂ», comme dans une faible densitÃ© de population. </li><li>  Une cellule Â«vivanteÂ» avec deux ou trois voisins Â«vivantsÂ» survit et tombe dans la gÃ©nÃ©ration suivante. </li><li>  Une cellule Â«vivanteÂ», avec plus de trois voisins Â«vivantsÂ», Â«meurtÂ», comme en surpopulation. </li><li>  La cellule Â«morteÂ», qui a exactement trois voisins Â«vivantsÂ», devient Â«vivanteÂ», comme dans la reproduction de la population. </li></ul><br>  ExtÃ©rieurement, il ressemble Ã  un champ, divisÃ© en cellules carrÃ©es, qui sont constamment Â«activÃ©esÂ» et Â«dÃ©sactivÃ©esÂ».  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez jeter un Å“il Ã  cela. <br><br>  Si vous observez la vie pendant un certain temps, des structures stables comme des Â«planeursÂ» peuvent apparaÃ®tre sur le terrain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/710/310/04f710310ef2d132545b15df0e19e601.gif"></div><br>  <i><font color="#999999">Planeur</font></i> <br><br>  Tu le vois?  Un planeur se dÃ©place sur l'Ã©cran.  Non?  Maintenant, ralentissons un peu.  Ce planeur existe-t-il vraiment?  Ce ne sont que des carrÃ©s individuels qui apparaissent et disparaissent.  Mais notre cerveau peut percevoir cette structure comme quelque chose qui existe objectivement. <br><br>  De plus, on peut dire que le "planeur" existe parce que les carrÃ©s ne sont pas indÃ©pendants (ils dÃ©pendent des voisins), et mÃªme si le "planeur" lui-mÃªme n'existe pas, alors il y a un "planeur" dans la forme idÃ©es platoniques. <br><br><h2>  <font color="#3AC1EF">RÃ©sumÃ©</font> </h2><br>  ConsidÃ©rez tout programme Ã©crit dans un langage de programmation typÃ©.  On peut observer les types.  Non?  Mais le programme se compile en codes machine.  Dans ces codes, la mÃªme chose est exprimÃ©e que dans le programme d'origine (bien qu'il soit difficile pour une personne de lire les reprÃ©sentations de programmes de la machine).  D'un point de vue informatique, il n'y a pas de types.  Il ne voit que la sÃ©quence de bits - des ensembles de zÃ©ros et de uns (cellules "mortes" et "vivantes").  Les types existent pour les gens, pas pour les voitures. <br><br>  <b>Chers lecteurs!</b>  Quel type de systÃ¨me pourriez-vous considÃ©rer comme idÃ©al pour le dÃ©veloppement Web? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462481/">https://habr.com/ru/post/fr462481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462471/index.html">RÃ©solution de problÃ¨mes avec pwnable.kr 16 - uaf. Utiliser aprÃ¨s une vulnÃ©rabilitÃ© gratuite</a></li>
<li><a href="../fr462473/index.html">Nous dÃ©veloppons un environnement pour travailler avec des microservices. Partie 1 Installer Kubernetes HA sur du mÃ©tal nu (Debian)</a></li>
<li><a href="../fr462475/index.html">Alexey Savvateev: Comment lutter contre la corruption Ã  l'aide des mathÃ©matiques (Prix Nobel d'Ã©conomie pour 2016)</a></li>
<li><a href="../fr462477/index.html">Des scientifiques affirment que l'IA est l'auteur d'un nouveau brevet et tentent de changer la loi sur les brevets</a></li>
<li><a href="../fr462479/index.html">Steam Windows Client Local Privilege Escalation 0day</a></li>
<li><a href="../fr462483/index.html">Programmation fonctionnelle: un jouet farfelu qui tue la productivitÃ© du travail. Partie 1</a></li>
<li><a href="../fr462485/index.html">Programmation fonctionnelle: un jouet farfelu qui tue la productivitÃ© du travail. 2e partie</a></li>
<li><a href="../fr462487/index.html">Cython: accÃ©lÃ©ration de code Python supÃ©rieure Ã  30x</a></li>
<li><a href="../fr462489/index.html">Le condensÃ© de matiÃ¨res fraÃ®ches du monde du front-end de la derniÃ¨re semaine n Â° 374 (29 juillet - 4 aoÃ»t 2019)</a></li>
<li><a href="../fr462493/index.html">SGBD multimodÃ¨le - la base des systÃ¨mes d'information modernes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>