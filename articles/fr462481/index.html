<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧‍👦 ▪️ 👨🏿‍🔬 FAQ sur le système de type 💚 🌀 👨🏾‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'auteur de l'article, dont nous publions la traduction aujourd'hui, affirme que ce billet et ses commentaires ont servi de source d'inspiration pour ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FAQ sur le système de type</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/462481/">  L'auteur de l'article, dont nous publions la traduction aujourd'hui, affirme que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce</a> billet et ses commentaires ont servi de source d'inspiration pour sa rédaction.  Selon lui, les informaticiens ont des idées fausses sur les types, utilisent une terminologie incorrecte et, discutant des problèmes liés aux types, tirent des conclusions erronées.  Il note qu'il n'est pas un défenseur du système de type statique.  La seule chose qui le dérange est l'utilisation correcte des termes.  Cela permet des discussions constructives.  L'auteur dit qu'il a écrit ce matériel spontanément, mais espère qu'il ne contient aucune erreur.  S'il a confondu quelque chose, il demande de le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lui</a> faire savoir. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/5h/v0/_9/5hv0_9iyqwfr7itow5ihgjdpdio.jpeg"></a> <br><br>  Comprenons une fois pour toutes ce qui cause la confusion lorsque l'on parle de systèmes de types. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Saisie dynamique et manque de frappe</font> </h2><br>  Certaines personnes pensent qu'un système de type dynamique est identique à un système de type non typé.  L'absence de saisie signifie que dans un certain système de types, il est inutile de distinguer les types.  Cela n'a aucun sens de distinguer les types même si un seul type est présent dans le système de types.  Par exemple: <br><br><ul><li>  Dans l'assembleur, le seul type est une chaîne de bits. </li><li>  Dans le calcul lambda, le seul type est la fonction. </li></ul><br>  Quelqu'un peut dire ceci à cette occasion: "Mais quelle différence cela fait-il - la frappe dynamique ou le manque de frappe - aussi une question pour moi."  Mais cela, en fait, est un problème important et important.  Le fait est que si vous assimilez le typage dynamique au manque de typage, cela signifie l'adoption automatique du fait qu'un système de type dynamique est l'opposé d'un système de type statique.  En conséquence, deux camps opposés de programmeurs sont formés - le camp de typage dynamique et le camp de typage statique (et cela, comme nous le verrons dans la section correspondante, est faux). <br><br>  <i><font color="#999999">Les langages qui ne limitent pas la plage de valeurs des variables sont appelés langages non typés: ils n'ont pas de types ou, ce qui est la même chose, ils n'ont qu'un seul type universel qui contient toutes les valeurs.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Systèmes de types, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">Les langages de programmation ont une fonctionnalité intéressante qui vous permet de diviser grossièrement leur monde en deux groupes:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  Langues non typées - les programmes s'exécutent simplement.  Cela se fait rapidement, sans chercher à vérifier «l'uniformité des formes». </li><li>  Langages typés - une tentative est faite pour vérifier «l'uniformité de la forme» - soit pendant la compilation, soit pendant l'exécution du programme. </li></ul><br>  <sub>«Systèmes de types pour les langages de programmation», Benjamin Pearce</sub> <br><br><h2>  <font color="#3AC1EF">Typage dynamique et statique</font> </h2><br>  Un système de type dynamique est un système dans lequel les types sont vérifiés dynamiquement (pendant l'exécution du programme).  Un système de type statique est un système dans lequel les types sont vérifiés statiquement (lors de la compilation ou de la traduction du code). <br><br>  L'un de ces systèmes est-il l'opposé de l'autre?  Non, ça ne l'est pas.  Les deux types de systèmes peuvent être utilisés dans la même langue.  En fait, la plupart des systèmes de type statiques ont également des vérifications de type dynamiques.  À titre d'exemple, considérons la validation des opérations d'entrée-sortie (entrée-sortie, IO).  Imaginez que vous devez lire les données fournies par un utilisateur qui doit saisir un numéro.  Vous vérifierez, pendant l'exécution du programme, si le nombre est le résultat de l'analyse de la ligne correspondante (à la suite de l'analyse, une exception peut être levée ou quelque chose comme <code>NaN</code> sera retourné).  Lorsque vous vérifiez les données entrées par l'utilisateur, en déterminant si elles peuvent être considérées comme un nombre - vous effectuez une vérification de type dynamique. <br><br>  En conséquence, nous pouvons noter l'absence de confrontation entre les types statiques et dynamiques.  Vous pouvez utiliser, dans la même langue, ceux-ci et les autres. <br><br>  De plus, il convient de noter que la vérification de type statique est un processus complexe.  Parfois, il est très difficile de vérifier statiquement certaines parties d'un programme.  Par conséquent, au lieu d'appliquer des vérifications de type statique, vous pouvez recourir à des vérifications dynamiques. <br><br>  Il est recommandé de considérer un système de type statique comme des types qui sont vérifiés statiquement.  Un système de type dynamique est comme des types qui sont vérifiés dynamiquement. <br><br><h2>  <font color="#3AC1EF">L'utilisation de types statiques signifie-t-elle connaître les types au moment de la compilation?</font> </h2><br>  La question posée dans le titre de cette section peut recevoir une réponse négative.  Si vous ouvrez le code source d'un analyseur (y compris l'analyseur JavaScript), vous pouvez voir que l'analyseur connaît les types de valeurs pendant l'analyse (cela fait partie du processus de compilation). <br><br><pre> <code class="plaintext hljs">let x = "test";</code> </pre> <br>  Il s'avère que l'analyseur sait que <code>"test"</code> est une chaîne.  Cela fait-il de JavaScript un langage typé statique?  Non, non. <br><br><h2>  <font color="#3AC1EF">Saisie progressive</font> </h2><br>  Un système de type progressif est un système de type statique qui vous permet d'ignorer les vérifications de type pour certaines parties d'un programme.  Par exemple, dans TypeScript, cela est implémenté en utilisant <code>any</code> ou <code>@ts-ignore</code> . <br><br>  D'une part, cela rend le système de type moins sûr.  D'un autre côté, un système de typage avec typage progressif vous permet d'ajouter progressivement des descriptions de typage aux langues avec typage dynamique. <br><br><h2>  <font color="#3AC1EF">Systèmes de type fiables et peu fiables</font> </h2><br>  Si vous utilisez un système de type fiable (système de type sonore), le programme ne sera pas «approuvé» lors de la vérification de type si ce programme contient des erreurs liées aux types.  L'utilisation d'un système de type défectueux entraîne la possibilité d'erreurs de type dans le programme.  Certes, vous ne devriez pas paniquer après l'avoir découvert.  En pratique, cela peut ne pas vous affecter.  La fiabilité ou la solidité est une propriété mathématique d'un algorithme de vérification de type qui nécessite une preuve.  De nombreux compilateurs existants (en interne, systèmes de vérification de type) ne sont pas fiables. <br><br>  Si vous souhaitez travailler avec des systèmes de type fiables, jetez un œil aux langages de programmation de la famille ML, qui utilisent le système de type Hindley-Milner. <br><br>  De plus, il faut comprendre qu'un système de type fiable ne sautera pas le mauvais programme (il ne donne pas de résultats de test faussement positifs, considérant que les mauvais programmes sont corrects), mais il peut ne pas manquer le programme correct (il peut donner des résultats de test faussement négatifs). <br><br>  Un système de type qui ne rejette jamais le bon programme est appelé complet. <br><br>  Arrive-t-il qu'un système de type soit à la fois fiable et complet?  Pour autant que je sache, de tels systèmes de types n'existent pas.  Je ne suis pas sûr de cela jusqu'à la fin, mais il me semble que l'existence de tels systèmes de types, s'ils sont basés sur le théorème d'incomplétude de Gödel, est fondamentalement impossible (je peux cependant me tromper à ce sujet). <br><br><h2>  <font color="#3AC1EF">Typage faible et fort</font> </h2><br>  Je trouve inapproprié d'utiliser les termes «frappe faible» et «frappe forte».  Ces termes sont ambigus, leur utilisation peut donner plus de confusion que de clarté.  Permettez-moi de vous donner quelques citations. <br><br>  <i><font color="#999999">Ces langues peuvent être appelées, au sens figuré, des langues à vérification de type faible (ou des langues faiblement typées, comme elles sont généralement appelées dans diverses publications).</font></i>  <i><font color="#999999">L'utilisation d'une vérification de type faible dans la langue signifie que certaines opérations dangereuses sont détectées statiquement, et d'autres non.</font></i>  <i><font color="#999999">La «faiblesse» des vérifications de type dans les langues de cette classe varie considérablement.</font></i> <br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Systèmes de types, Luca Cardelli</a></sub> <br><br>  <i><font color="#999999">La façon la plus courante de classer les systèmes de types est probablement de les diviser en systèmes de typage «faible» et «fort».</font></i>  <i><font color="#999999">Cela ne peut être que regretté, car ces mots n'ont pratiquement aucun sens en eux-mêmes.</font></i>  <i><font color="#999999">Il est possible, dans une mesure limitée, de comparer deux langues qui ont des systèmes de types très similaires et de sélectionner l'une d'entre elles comme ayant un système de types plus fort que la seconde.</font></i>  <i><font color="#999999">Dans d'autres cas, les termes «typage fort» et «typage faible» n'ont aucun sens.</font></i> <i><font color="#999999"><br></font></i>  <i><font color="#999999"><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">«Choses à savoir avant de discuter des systèmes de type», Steve Klabnik</a></sub></font></i> <i><font color="#999999"><br><br></font></i>  <i><font color="#999999">Les termes «typage fort» et «typage faible» sont extrêmement ambigus.</font></i>  <i><font color="#999999">Voici quelques exemples de leur utilisation:</font></i> <i><font color="#999999"><br><br></font></i> <ul><li>  <i><font color="#999999">Parfois, «typage fort» signifie «typage statique».</font></i>  <i><font color="#999999">Il n'est pas difficile de faire une telle «substitution», mais il vaut mieux, en parlant de typage statique, simplement l'appeler «statique».</font></i>  <i><font color="#999999">Le fait est que la plupart des programmeurs comprennent clairement ce terme.</font></i> </li><li>  <i><font color="#999999">Parfois, quand ils disent «typage fort», ils signifient «l'absence d'une conversion de type implicite».</font></i>  <i><font color="#999999">Par exemple, en JavaScript, vous pouvez utiliser des expressions comme <code>"a" - 1</code> .</font></i>  <i><font color="#999999">Cela peut être appelé un modèle de "typage faible".</font></i>  <i><font color="#999999">Mais presque tous les langages offrent au programmeur des opportunités de conversion de type implicite, par exemple, en prenant en charge la conversion automatique d'entiers en nombres à virgule flottante dans des expressions comme <code>1 - 1.1</code> .</font></i>  <i><font color="#999999">Dans la pratique, la plupart des professionnels qui utilisent le terme «typage fort» de cette manière distinguent les conversions de type «acceptable» et «inacceptable».</font></i>  <i><font color="#999999">Mais il n'y a pas de frontière généralement acceptée entre ces conversions de type.</font></i>  <i><font color="#999999">L '«acceptabilité» et «l'inacceptabilité» des transformations est une évaluation subjective, selon l'opinion d'une personne en particulier.</font></i> </li><li>  <i><font color="#999999">Parfois, les langues avec "typage fort" sont appelées les langues dans lesquelles il est impossible de contourner les règles du système de types qui y existe.</font></i> </li><li>  <i><font color="#999999">Parfois, «taper fort» signifie avoir un système de saisie qui vous permet de travailler en toute sécurité avec la mémoire.</font></i>  <i><font color="#999999">Le langage C est un exemple notable d'un langage qui n'est pas sûr avec la mémoire.</font></i>  <i><font color="#999999">Par exemple, si <code>xs</code> est un tableau de quatre nombres, C approuvera sans problème un code qui utilise des constructions comme <code>xs[5]</code> ou <code>xs[1000]</code> .</font></i>  <i><font color="#999999">Ils vous permettront d'accéder à la mémoire située après les adresses allouées pour stocker le contenu du tableau <code>xs</code> .</font></i> </li></ul><br>  <sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les types, Gary Bernard</a></sub> <br><br><h2>  <font color="#3AC1EF">Les langages typés statiques ont-ils besoin de déclarations de type?</font> </h2><br>  Les langages typés statiquement n'ont pas toujours besoin de déclarations de type.  Parfois, un système de types peut déduire des types (en faisant des hypothèses basées sur la structure du code).  Voici un exemple (TypeScript): <br><br><pre> <code class="plaintext hljs">const x = "test";</code> </pre> <br>  Le système de type sait que <code>"test"</code> est une chaîne (cette connaissance est basée sur les règles d'analyse de code).  Le système de types sait également que <code>x</code> est une constante, c'est-à-dire que la valeur de <code>x</code> ne peut pas être réaffectée.  Par conséquent, on peut conclure que <code>x</code> est de type chaîne. <br>  Voici un autre exemple (Flow): <br><br><pre> <code class="plaintext hljs">const add = (x, y) =&gt; x / y //            ^        [1]   . add(1, "2")</code> </pre> <br>  Le système de vérification de type voit que nous appelons la fonction <code>add</code> , en lui passant un nombre et une chaîne.  Ceci analyse la déclaration de fonction.  Le système de vérification de type sait que pour effectuer l'opération de division, les numéros doivent être à droite et à gauche de l'opérateur correspondant.  L'un des opérandes impliqués dans l'opération de division n'est pas un nombre.  En conséquence, nous sommes informés de l'erreur. <br><br>  Il n'y a pas de déclaration de type ici, mais cela n'empêche pas une vérification de type statique du programme ci-dessus.  Si vous rencontrez des situations similaires dans le monde réel, alors, tôt ou tard, vous devrez déclarer certains types.  Le système de types ne peut pas déduire absolument tous les types.  Mais vous devez comprendre qu'un langage peut être appelé «statique» non pas parce qu'il utilise des déclarations de type, mais parce que les types sont vérifiés avant le démarrage du programme. <br><br><h2>  <font color="#3AC1EF">TypeScript est-il un langage dangereux car le code qui y est écrit est compilé en code JavaScript?</font> </h2><br>  TypeScript est un langage malsain.  Par conséquent, le code écrit dessus peut se transformer en applications dangereuses.  Mais cela n'a rien à voir avec ce qu'il compile. <br><br>  La plupart des compilateurs de bureau convertissent les programmes en quelque chose qui ressemble à un langage d'assemblage.  Et l'assembleur est un langage encore moins sécurisé que JS. <br><br>  Ici, si vous revenez à l'idée que TS n'est pas sécurisé en raison de la compilation dans JS, vous pourriez obtenir la pensée suivante: «Le code compilé est exécuté dans le navigateur, JS est un langage dangereux, et il peut tout à fait substituer <code>null</code> à l'endroit où la ligne est attendue ".  La pensée est sensée.  Mais cela, encore une fois, ne donne pas de raison d'appeler TS un langage dangereux.  Afin que TS garantisse la sécurité au sein de l'application, vous devez placer les «mécanismes de défense» aux endroits où le code TS interagit avec le monde extérieur.  C'est-à-dire, par exemple, que vous devez vérifier l'exactitude des données entrant dans le programme via les mécanismes d'entrée-sortie.  Disons que cela peut être de vérifier ce que l'utilisateur entre, de vérifier les réponses du serveur, de vérifier les données lues à partir du stockage du navigateur, etc. <br><br>  Par exemple, le rôle de ces «mécanismes de défense» dans Elm est joué par les « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ports</a> ».  Dans TS, vous pouvez utiliser quelque chose comme io-ts pour cela. <br><br>  Le «mécanisme de protection» correspondant crée un pont entre les systèmes de type statique et dynamique. <br><br>  Voici un exemple simplifié: <br><br><pre> <code class="plaintext hljs">const makeSureIsNumber = (x: any) =&gt; {  const result = parseFloat(x);  if (isNaN(result)) {    throw Error("Not a number");  }  return result; } const read = (input: any) =&gt; {  try {    const n = makeSureIsNumber(input);    //     n, ,      //              // makeSureIsNumber "" , n    } catch (e) { } }</code> </pre> <br><h2>  <font color="#3AC1EF">Est-il vrai que les types ne sont nécessaires que pour les compilateurs?</font> </h2><br>  <i><font color="#999999">Les types ne sont que le hack nécessaire pour donner des indices au compilateur.</font></i> <br>  <sub>Waut Mertens</sub> <br><br>  Les types sont-ils uniquement nécessaires aux compilateurs?  C'est une question philosophique.  Les types sont nécessaires pour les gens, pas pour les voitures.  Les compilateurs ont besoin de types car ce sont des programmes écrits par des personnes. <br><br>  Le phénomène des types existe à cause des gens.  Les types n'existent que lorsqu'une personne perçoit quelque chose sous la forme d'un «type de données».  L'esprit humain divise différentes entités en différentes catégories.  Les types n'ont pas de sens sans un observateur. <br><br>  Organisons une expérience de pensée.  Pensez au jeu Life.  Vous avez une grille bidimensionnelle composée de cellules carrées.  Chacune des cellules peut être dans deux états possibles.  Il peut être "vivant" ou "mort".  Chaque cellule peut interagir avec ses huit voisins.  Ce sont des cellules qui la bordent verticalement, horizontalement ou en diagonale.  Dans le processus de recherche de l'état suivant du système, les règles suivantes s'appliquent: <br><br><ul><li>  Une cellule «vivante» avec moins de deux voisins «vivants» «meurt», comme dans une faible densité de population. </li><li>  Une cellule «vivante» avec deux ou trois voisins «vivants» survit et tombe dans la génération suivante. </li><li>  Une cellule «vivante», avec plus de trois voisins «vivants», «meurt», comme en surpopulation. </li><li>  La cellule «morte», qui a exactement trois voisins «vivants», devient «vivante», comme dans la reproduction de la population. </li></ul><br>  Extérieurement, il ressemble à un champ, divisé en cellules carrées, qui sont constamment «activées» et «désactivées».  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ici,</a> vous pouvez jeter un œil à cela. <br><br>  Si vous observez la vie pendant un certain temps, des structures stables comme des «planeurs» peuvent apparaître sur le terrain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04f/710/310/04f710310ef2d132545b15df0e19e601.gif"></div><br>  <i><font color="#999999">Planeur</font></i> <br><br>  Tu le vois?  Un planeur se déplace sur l'écran.  Non?  Maintenant, ralentissons un peu.  Ce planeur existe-t-il vraiment?  Ce ne sont que des carrés individuels qui apparaissent et disparaissent.  Mais notre cerveau peut percevoir cette structure comme quelque chose qui existe objectivement. <br><br>  De plus, on peut dire que le "planeur" existe parce que les carrés ne sont pas indépendants (ils dépendent des voisins), et même si le "planeur" lui-même n'existe pas, alors il y a un "planeur" dans la forme idées platoniques. <br><br><h2>  <font color="#3AC1EF">Résumé</font> </h2><br>  Considérez tout programme écrit dans un langage de programmation typé.  On peut observer les types.  Non?  Mais le programme se compile en codes machine.  Dans ces codes, la même chose est exprimée que dans le programme d'origine (bien qu'il soit difficile pour une personne de lire les représentations de programmes de la machine).  D'un point de vue informatique, il n'y a pas de types.  Il ne voit que la séquence de bits - des ensembles de zéros et de uns (cellules "mortes" et "vivantes").  Les types existent pour les gens, pas pour les voitures. <br><br>  <b>Chers lecteurs!</b>  Quel type de système pourriez-vous considérer comme idéal pour le développement Web? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462481/">https://habr.com/ru/post/fr462481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462471/index.html">Résolution de problèmes avec pwnable.kr 16 - uaf. Utiliser après une vulnérabilité gratuite</a></li>
<li><a href="../fr462473/index.html">Nous développons un environnement pour travailler avec des microservices. Partie 1 Installer Kubernetes HA sur du métal nu (Debian)</a></li>
<li><a href="../fr462475/index.html">Alexey Savvateev: Comment lutter contre la corruption à l'aide des mathématiques (Prix Nobel d'économie pour 2016)</a></li>
<li><a href="../fr462477/index.html">Des scientifiques affirment que l'IA est l'auteur d'un nouveau brevet et tentent de changer la loi sur les brevets</a></li>
<li><a href="../fr462479/index.html">Steam Windows Client Local Privilege Escalation 0day</a></li>
<li><a href="../fr462483/index.html">Programmation fonctionnelle: un jouet farfelu qui tue la productivité du travail. Partie 1</a></li>
<li><a href="../fr462485/index.html">Programmation fonctionnelle: un jouet farfelu qui tue la productivité du travail. 2e partie</a></li>
<li><a href="../fr462487/index.html">Cython: accélération de code Python supérieure à 30x</a></li>
<li><a href="../fr462489/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 374 (29 juillet - 4 août 2019)</a></li>
<li><a href="../fr462493/index.html">SGBD multimodèle - la base des systèmes d'information modernes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>