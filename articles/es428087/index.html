<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëç üß¢ üôéüèæ "Sin cerradura, o sin cerradura, esa es la pregunta" o "Un sue√±o saludable es peor que el r√°bano amargo" ü§öüèª üê∫ üë®üèº‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Los comentarios sobre el art√≠culo " C√≥mo dormir correcta e incorrectamente " me inspiraron a escribir este art√≠culo. 


 Este art√≠culo se centrar√° en ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Sin cerradura, o sin cerradura, esa es la pregunta" o "Un sue√±o saludable es peor que el r√°bano amargo"</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428087/"><p>  Los comentarios sobre el art√≠culo " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo dormir correcta e incorrectamente</a> " me inspiraron a escribir este art√≠culo. </p><br><p>  Este art√≠culo se centrar√° en el desarrollo de aplicaciones de subprocesos m√∫ltiples, la aplicabilidad de sin bloqueo en algunos casos que surgieron durante el trabajo en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LAppS</a> , en la funci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">nano sue√±o</a> y la violencia en el programador de tareas. </p><br><pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">NB</span></span>:      <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>++  <span class="hljs-selector-tag"><span class="hljs-selector-tag">Linux</span></span>,       <span class="hljs-selector-tag"><span class="hljs-selector-tag">POSIX</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1-2008</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> (    ).</code> </pre> <br><p>  En general, todo es bastante desordenado, espero que el tren de pensamiento en la presentaci√≥n sea claro.  Si est√° interesado, entonces pido un gato. </p><a name="habracut"></a><br><p>  El software orientado a eventos siempre est√° esperando algo.  Ya sea una GUI o un servidor de red, est√°n esperando cualquier evento: entrada del teclado, eventos del mouse, paquete de datos que llegue a trav√©s de la red.  Pero todo el software espera de manera diferente.  Los sistemas sin bloqueo no tienen que esperar en absoluto.  Al menos el uso de algoritmos sin bloqueo debe ocurrir donde no es necesario esperar, e incluso perjudicial.  Pero estamos hablando de sistemas competitivos (multiproceso) y, curiosamente, los algoritmos sin bloqueo tambi√©n est√°n esperando.  S√≠, no bloquean la ejecuci√≥n de subprocesos paralelos, pero ellos mismos esperan la oportunidad de hacer algo sin bloquear. </p><br><p>  LAppS usa mutexes y sem√°foros de manera muy activa.  Al mismo tiempo, no hay sem√°foros en el est√°ndar C ++.  El mecanismo es muy importante y conveniente, pero C ++ deber√≠a funcionar en sistemas que no tienen soporte de sem√°foros y, por lo tanto, los sem√°foros no est√°n incluidos en el est√°ndar.  Adem√°s, si uso sem√°foros porque son convenientes, mutexes porque tengo que hacerlo. </p><br><p>  El comportamiento del mutex en el caso del bloqueo competitivo (), como sem_wait () en Linux, coloca el hilo de espera al final de la cola del programador de tareas, y cuando est√° en la parte superior, la verificaci√≥n se repite sin volver al usuario, el hilo se vuelve a poner en la cola si el evento esperado a√∫n no ha ocurrido.  Este es un punto muy importante. </p><br><p>  Y decid√≠ verificar si puedo rechazar los sem√°foros std :: mutex y POSIX, emul√°ndolos con std :: atomic, transfiriendo la carga principalmente a tierra de usuario.  En realidad fall√≥, pero lo primero es lo primero. </p><br><p>  En primer lugar, tengo varias secciones en las que estos experimentos podr√≠an ser √∫tiles: </p><br><ul><li>  se bloquea en LibreSSL (caso 1); </li><li>  bloqueo al transferir paquetes de carga recibida a aplicaciones Lua (caso 2); </li><li>  Esperando eventos de carga √∫til listos para ser procesados ‚Äã‚Äãpor aplicaciones Lua (caso 3). </li></ul><br><p>  Comencemos con bloqueos sin bloqueo.  Escribamos nuestro mutex usando at√≥micos, como se muestra en algunos discursos de H. Sutter (por lo tanto, no hay c√≥digo original de la memoria y, por lo tanto, el c√≥digo no coincide con el 100% original, y en Satter este c√≥digo estaba relacionado con el progreso de C ++ 20, por lo tanto hay diferencias).  Y a pesar de la simplicidad de este c√≥digo, hay dificultades en √©l. </p><br><pre> <code class="hljs kotlin">#include &lt;atomic&gt; #include &lt;pthread.h&gt; namespace test { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mutex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;pthread_t&gt; mLock; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: explicit mutex():mLock{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } mutex(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mutex&amp;)=delete; mutex(mutex&amp;)=delete; void lock() { pthread_t locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  C++20     , .. compare_exchange_strong          while(!mLock.compare_exchange_strong(locked_by,pthread_self())) { locked_by=0; //      } } void unlock() { pthread_t current=pthread_self(); if(!mLock.compare_exchange_strong(current,0)) { throw std::system_error(EACCES, std::system_category(), "An attempt to unlock the mutex owned by other thread"); } } const bool try_lock() { pthread_t unused=0; return mLock.compare_exchange_strong(unused,pthread_self()); } }; }</span></span></code> </pre> <br><p>  A diferencia de std :: mutex :: unlock (), el comportamiento de test :: mutex: unlock () cuando se intenta desbloquear desde otro hilo es determinista.  Se lanzar√° una excepci√≥n.  Esto es bueno, aunque no es consistente con el comportamiento est√°ndar.  ¬øY qu√© hay de malo en esta clase?  La mala noticia es que el m√©todo test :: mutex: lock () consumir√° descaradamente los recursos de la CPU en las cuotas de tiempo asignadas al subproceso, en un intento de asumir el mutex que otro subproceso ya posee.  Es decir  un bucle en test :: mutex: lock () ser√° un desperdicio de recursos de la CPU.  ¬øCu√°les son nuestras opciones para superar esta situaci√≥n? </p><br><p>  Podemos usar sched_yield () (como se sugiere en uno de los comentarios en el art√≠culo anterior).  ¬øEs as√≠ de simple?  En primer lugar, para usar sched_yield (), es necesario que los subprocesos de ejecuci√≥n usen las pol√≠ticas SCHED_RR, SCHED_FIFO para su priorizaci√≥n en el programador de tareas.  De lo contrario, llamar a sched_yield () ser√≠a un desperdicio de recursos de la CPU.  En segundo lugar, una llamada muy frecuente a sched_yield () seguir√° aumentando el consumo de CPU.  Adem√°s, el uso de pol√≠ticas en tiempo real en su aplicaci√≥n, y siempre que no haya otras aplicaciones en tiempo real en el sistema, limitar√° la cola del planificador con la pol√≠tica seleccionada solo a sus hilos.  Parece que esto es bueno!  No, no esta bien.  Todo el sistema ser√° menos receptivo, porque  ocupado con tarea prioritaria.  CFQ estar√° en la pluma.  Pero hay otros hilos en la aplicaci√≥n, y muy a menudo surge una situaci√≥n cuando el hilo que ha capturado el mutex se coloca al final de la cola (la cuota ha expirado), y el hilo que est√° esperando que se libere el mutex justo en frente de √©l.  En mis experimentos (caso 2), este m√©todo arroj√≥ aproximadamente los mismos resultados (3.8% peores) que std :: mutex, pero el sistema responde menos y el consumo de CPU aumenta en un 5% -7%. </p><br><p>  Puede intentar cambiar test :: mutex :: lock () de esta manera (tambi√©n est√° mal): </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> locked_by=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!mLock.compare_exchange_strong(locked_by,pthread_self())) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">thread_local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">timespec</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pause</span></span></span><span class="hljs-class">{</span></span><span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; <span class="hljs-comment"><span class="hljs-comment">// -      nanosleep(&amp;pause,nullptr); locked_by=0; } }</span></span></code> </pre> <br><p>  Aqu√≠ puede experimentar con la duraci√≥n del sue√±o en nanosegundos, los retrasos de 4ns fueron √≥ptimos para mi CPU y la ca√≠da del rendimiento en relaci√≥n con std :: mutex en el mismo caso 2 fue del 1.2%.  No es el hecho de que nanosleep durmi√≥ 4ns.  De hecho, o m√°s (en el caso general) o menos (si se interrumpe).  La ca√≠da (!) En el consumo de CPU fue del 12% -20%.  Es decir  Fue un sue√±o tan saludable. </p><br><p>  OpenSSL y LibreSSL tienen dos funciones que configuran devoluciones de llamada para bloquear cuando se usan estas bibliotecas en un entorno multiproceso.  Se ve as√≠: </p><br><pre> <code class="hljs pgsql">//  callback <span class="hljs-type"><span class="hljs-type">void</span></span> openssl_crypt_locking_function_callback(<span class="hljs-type"><span class="hljs-type">int</span></span> mode, <span class="hljs-type"><span class="hljs-type">int</span></span> n, const <span class="hljs-type"><span class="hljs-type">char</span></span>* file, const <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">line</span></span>) { static std::vector&lt;std::mutex&gt; locks(CRYPTO_num_locks()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n&gt;=static_cast&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(locks.size())) { <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mode &amp; CRYPTO_LOCK) locks[n].<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> locks[n].unlock(); } //  callback-a CRYPTO_set_locking_callback(openssl_crypt_locking_function_callback); //  id CRYPTO_set_id_callback(pthread_self);</code> </pre> <br><p>  Y ahora lo peor es que el uso de la prueba anterior :: mutex mutex en LibreSSL reduce el rendimiento de LAppS en casi 2 veces.  Adem√°s, independientemente de la opci√≥n (ciclo de espera vac√≠o, sched_yield (), nanosleep ()). </p><br><p>  En general, eliminamos el caso 2 y el caso 1, y nos quedamos con std :: mutex. </p><br><p>  Pasemos a los sem√°foros.  Hay muchos ejemplos de c√≥mo implementar sem√°foros usando std :: condition_variable.  Todos usan std :: mutex tambi√©n.  Y tales simuladores de sem√°foros son m√°s lentos (seg√∫n mis pruebas) que los sem√°foros del sistema POSIX. </p><br><p>  Por lo tanto, haremos un sem√°foro en los √°tomos: </p><br><pre> <code class="hljs java"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">semaphore</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::atomic&lt;bool&gt; mayRun; mutable std::atomic&lt;int64_t&gt; counter; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">explicit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">semaphore</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : mayRun</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>},counter{<span class="hljs-number"><span class="hljs-number">0</span></span>} { } semaphore(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> semaphore&amp;)=delete; semaphore(semaphore&amp;)=delete; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">post</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mayRun.load(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">try_wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(counter.fetch_sub(<span class="hljs-number"><span class="hljs-number">1</span></span>)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wait</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!try_wait()) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> thread_local <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> struct timespec pause{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>}; nanosleep(&amp;pause,nullptr); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mayRun.store(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> int64_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrimentOn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size_t value)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(mayRun.load()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter.fetch_sub(value); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::system_error(ENOENT,std::system_category(),<span class="hljs-string"><span class="hljs-string">"Semaphore is destroyed"</span></span>); } } ~semaphore() { destroy(); } };</code> </pre> <br><p>  Oh, este sem√°foro es muchas veces m√°s r√°pido que el sem√°foro del sistema.  El resultado de una prueba separada de este sem√°foro con un proveedor y 20 consumidores: </p><br><pre> <code class="hljs bash">OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(OS): wakes: 500321 Thread(OS): wakes: 500473 Thread(OS): wakes: 501504 Thread(OS): wakes: 502337 Thread(OS): wakes: 498324 Thread(OS): wakes: 502755 Thread(OS): wakes: 500212 Thread(OS): wakes: 498579 Thread(OS): wakes: 499504 Thread(OS): wakes: 500228 Thread(OS): wakes: 499696 Thread(OS): wakes: 501978 Thread(OS): wakes: 498617 Thread(OS): wakes: 502238 Thread(OS): wakes: 497797 Thread(OS): wakes: 498089 Thread(OS): wakes: 499292 Thread(OS): wakes: 498011 Thread(OS): wakes: 498749 Thread(OS): wakes: 501296 OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 9924 milliseconds OS semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.9924ns ======================================= AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Started 20 threads waiting on a semaphore Thread(EmuAtomic) wakes: 492748 Thread(EmuAtomic) wakes: 546860 Thread(EmuAtomic) wakes: 479375 Thread(EmuAtomic) wakes: 534676 Thread(EmuAtomic) wakes: 501014 Thread(EmuAtomic) wakes: 528220 Thread(EmuAtomic) wakes: 496783 Thread(EmuAtomic) wakes: 467563 Thread(EmuAtomic) wakes: 608086 Thread(EmuAtomic) wakes: 489825 Thread(EmuAtomic) wakes: 479799 Thread(EmuAtomic) wakes: 539634 Thread(EmuAtomic) wakes: 479559 Thread(EmuAtomic) wakes: 495377 Thread(EmuAtomic) wakes: 454759 Thread(EmuAtomic) wakes: 482375 Thread(EmuAtomic) wakes: 512442 Thread(EmuAtomic) wakes: 453303 Thread(EmuAtomic) wakes: 480227 Thread(EmuAtomic) wakes: 477375 AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. 10000000 of posts <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> 20 waiting threads have taken 341 milliseconds AtomicEmu semaphores <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>. Post latency: 0.0341ns</code> </pre><br><p>  Este sem√°foro con publicaci√≥n casi gratuita (), que es 29 veces m√°s r√°pido que el sistema, tambi√©n es muy r√°pido al despertar los hilos que lo esperan: 29325 activaciones por milisegundo, frente a 1007 activaciones por milisegundo del sistema.  Tiene un comportamiento determinista con un sem√°foro destruido o un sem√°foro destructible.  Y, naturalmente, segfault cuando intentas usar uno ya destruido. </p><br><p>  (¬π) En realidad, el programador no puede retrasar ni despertar tantas veces en un milisegundo una secuencia.  Porque  post () no est√° bloqueando, en esta prueba sint√©tica, wait () a menudo se encuentra en una situaci√≥n en la que no necesita dormir.  Al mismo tiempo, al menos 7 hilos en paralelo leen el valor del sem√°foro. </p><br><p>  Pero usarlo en el caso 3 en LAppS conduce a p√©rdidas de rendimiento independientemente del tiempo de sue√±o.  Se despierta con demasiada frecuencia para verificar, y los eventos en LAppS llegan mucho m√°s lento (latencia de red, latencia del lado del cliente que genera la carga, etc.).  Y comprobar con menos frecuencia tambi√©n significa perder rendimiento. </p><br><p>  Adem√°s, el uso del sue√±o en tales casos y de manera similar es completamente da√±ino, porque  en otro hardware, los resultados pueden ser completamente diferentes (como en el caso de la pausa de instrucciones del ensamblador), y para cada modelo de CPU, tambi√©n debe seleccionar el tiempo de retraso. </p><br><p>  La ventaja de un mutex y un sem√°foro del sistema es que el hilo de ejecuci√≥n no se activa hasta que ocurre un evento (desbloqueo del mutex o incremento del sem√°foro).  Los ciclos de CPU adicionales no se desperdician: ganancias. </p><br><p>  En general, todo, desde este malvado, deshabilitar iptables en mi sistema da del 12% (con TLS) al 30% (sin TLS) una ganancia de rendimiento ... </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428087/">https://habr.com/ru/post/es428087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428077/index.html">React.js: una gu√≠a para principiantes</a></li>
<li><a href="../es428079/index.html">Aplicaci√≥n de principios S√ìLIDOS para reaccionar al desarrollo de aplicaciones</a></li>
<li><a href="../es428081/index.html">Uso de RxJS en React Development para administrar el estado de la aplicaci√≥n</a></li>
<li><a href="../es428083/index.html">Matriz de influencia de an√°lisis web: el sistema estrat√©gico de Avinash Koshik</a></li>
<li><a href="../es428085/index.html">Frontend contraataca: top 10 (?) HolyJS 2018 Piter informa</a></li>
<li><a href="../es428089/index.html">"Calendario de prueba" para octubre. Comentarios: c√≥mo sucede</a></li>
<li><a href="../es428091/index.html">C√≥mo un estudiante interno cre√≥ el videojuego m√°s popular del mundo o el historial de juegos de Windows</a></li>
<li><a href="../es428095/index.html">Estudio de mercado para estudios web y agencias digitales.</a></li>
<li><a href="../es428097/index.html">Enrutamiento recursivo en MikroTik a trav√©s de puertas de enlace asignadas por DHCP</a></li>
<li><a href="../es428099/index.html">¬øQu√© tienen en com√∫n los vestidos comunes y la pr√≥xima era 5G?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>