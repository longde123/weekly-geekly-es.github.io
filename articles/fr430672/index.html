<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèæ üèûÔ∏è üè© Version texte du rapport ¬´Acteurs vs CSP vs T√¢ches ...¬ª avec C ++ CoreHard Automne 2018 üßôüèæ üç≥ üöÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="D√©but novembre, Minsk a accueilli la prochaine conf√©rence C ++ Conf√©rence C ++ CoreHard automne 2018. Elle a livr√© un rapport du capitaine ¬´Acteurs vs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Version texte du rapport ¬´Acteurs vs CSP vs T√¢ches ...¬ª avec C ++ CoreHard Automne 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430672/">  D√©but novembre, Minsk a accueilli la prochaine conf√©rence C ++ Conf√©rence C ++ CoreHard automne 2018. Elle a livr√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapport du capitaine ¬´Acteurs vs CSP vs T√¢ches ...¬ª</a> , qui parlait de la fa√ßon dont les applications de niveau sup√©rieur √† ¬´peuvent regarder en C ++¬ª nus multithreading ¬ª, des mod√®les de programmation comp√©titifs.  Sous la version coup√©e de ce rapport, transform√© en article.  Peign√©, par√© par endroits, compl√©t√© par endroits. <br><br>  Je profite de cette occasion pour remercier la communaut√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CoreHard</a> pour l'organisation de la prochaine grande conf√©rence √† Minsk et pour l'occasion de prendre la parole.  Et aussi pour la publication rapide de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rapports vid√©o de rapports sur YouTube</a> . <br><br>  Passons donc au sujet principal de la conversation.  √Ä savoir, quelles approches nous pouvons utiliser pour simplifier la programmation multithread en C ++, √† quoi ressembleront certaines de ces approches dans le code, quelles fonctionnalit√©s sont inh√©rentes √† des approches sp√©cifiques, ce qui est commun entre elles, etc. <br><br>  Remarque: des erreurs et des fautes de frappe ont √©t√© d√©tect√©es dans la pr√©sentation d'origine du rapport, de sorte que l'article utilisera des diapositives de la version mise √† jour et modifi√©e, qui peuvent √™tre trouv√©es dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Google Slides</a> ou sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SlideShare</a> . <br><br><h1>  Le multithreading nu est mal! </h1><br>  Il faut commencer par la banalit√© r√©p√©t√©e, qui reste cependant toujours d'actualit√©: <br><blockquote>  La programmation C ++ multithread via des threads nus, des mutex et des variables de condition est la <b>sueur</b> , la <b>douleur</b> et le <b>sang</b> . </blockquote><a name="habracut"></a><br>  Un bon exemple a √©t√© r√©cemment d√©crit ici dans cet article ici sur Habr√©: "L' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">architecture du m√©ta-serveur du jeu de tir mobile en ligne Tacticool.</a> "  Dans ce document, les gars ont expliqu√© comment ils avaient r√©ussi √† collecter, apparemment, une gamme compl√®te de r√¢teaux li√©s au d√©veloppement de code multi-thread en C et C ++.  Il y a eu des ¬´passages de m√©moire¬ª √† la suite de courses et de faibles performances en raison d'une √©chec de la parall√©lisation. <br><br>  Du coup, tout s'est termin√© tout naturellement: <br><blockquote>  Apr√®s quelques semaines pass√©es √† rechercher et √† corriger les bogues les plus critiques, nous avons d√©cid√© qu'il √©tait <u>plus facile de tout r√©√©crire √† partir de z√©ro</u> que d'essayer de corriger tous les d√©fauts de la solution actuelle. </blockquote><br>  Les gens ont mang√© du C / C ++ en travaillant sur la premi√®re version de leur serveur et ont r√©√©crit le serveur dans une autre langue. <br><br>  Une excellente d√©monstration de la fa√ßon dont, dans le monde r√©el, en dehors de notre communaut√© C ++ confortable, les d√©veloppeurs refusent d'utiliser C ++ m√™me lorsque l'utilisation de C ++ est toujours appropri√©e et justifi√©e. <br><br><h2>  Mais pourquoi? </h2><br>  Mais pourquoi, s'il est dit √† plusieurs reprises que le ¬´multithread nu¬ª en C ++ est mauvais, les gens continuent √† l'utiliser avec une pers√©v√©rance digne d'une meilleure application?  Ce qui est √† bl√¢mer: <br><br><ul><li>  l'ignorance? </li><li>  la paresse? </li><li>  Syndrome NIH? </li></ul><br>  Apr√®s tout, il y a loin d'une approche test√©e par le temps et de nombreux projets.  En particulier: <br><br><ul><li>  acteurs </li><li>  communication des processus s√©quentiels (CSP) </li><li>  t√¢ches (asynchrones, promesses, futurs, ...) </li><li>  flux de donn√©es </li><li>  programmation r√©active </li><li>  ... </li></ul><br>  On esp√®re que la raison principale est encore l'ignorance.  Il est peu probable que cela soit enseign√© dans les universit√©s.  Ainsi, les jeunes professionnels, entrant dans la profession, utilisent le peu qu'ils connaissent d√©j√†.  Et si le magasin de connaissances n'est alors pas r√©approvisionn√©, alors les gens continuent √† utiliser des threads nus, des mutex et des variables de condition. <br><br>  Aujourd'hui, nous allons parler des trois premi√®res approches de cette liste.  Et nous ne parlerons pas de mani√®re abstraite, mais sur l'exemple d'une t√¢che simple.  Essayons de montrer √† quoi ressemblera le code qui r√©sout ce probl√®me en utilisant Actor, les processus et canaux CSP, ainsi qu'en utilisant Task. <br><br><h1>  D√©fi pour les exp√©riences </h1><br>  Il est n√©cessaire d'impl√©menter un serveur HTTP qui: <br><br><ul><li>  accepte la demande (ID photo, ID utilisateur); </li><li>  donne une image avec des "filigranes" uniques √† cet utilisateur. </li></ul><br>  Par exemple, un tel serveur peut √™tre requis par un service payant qui distribue du contenu par abonnement.  Si l'image de ce service "appara√Æt" quelque part, alors par les "filigranes" dessus, il sera possible de comprendre qui a besoin de "bloquer l'oxyg√®ne". <br><br>  La t√¢che est abstraite, elle a √©t√© formul√©e sp√©cifiquement pour ce rapport sous l'influence de notre projet de d√©monstration Shrimp (nous en avons d√©j√† parl√©: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n ¬∞ 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n ¬∞ 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">n ¬∞ 3</a> ). <br><br>  Ce notre serveur HTTP fonctionnera comme suit: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/bq/qo/zk/bqqozkulonydk1ccnzog-kzv610.jpeg"></td></tr></tbody></table><br>  Apr√®s avoir re√ßu une demande d'un client, nous nous tournons vers deux services externes: <br><br><ul><li>  le premier nous renvoie des informations utilisateur.  Y compris √† partir de l√†, nous obtenons une image avec des "filigranes"; </li><li>  la seconde nous renvoie l'image d'origine </li></ul><br>  Ces deux services fonctionnent ind√©pendamment et nous pouvons y acc√©der simultan√©ment. <br><br>  Comme le traitement des demandes peut se faire ind√©pendamment les unes des autres, et m√™me certaines actions lors du traitement d'une seule demande peuvent se faire en parall√®le, l'utilisation de la comp√©titivit√© se sugg√®re.  La chose la plus simple qui vous vient √† l'esprit est de cr√©er un thread distinct pour chaque demande entrante: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/g0/f9/ps/g0f9ps3vmq-osh-hy0i71ut_kfw.jpeg"></td></tr></tbody></table><br>  Mais le mod√®le one-request = one-workflow est trop cher et ne s'adapte pas bien.  Nous n'en avons pas besoin. <br><br>  M√™me si nous approchons le nombre de workflows de mani√®re inutile, nous en avons encore besoin d'un petit nombre: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/ve/yl/vv/veylvvoaisqxod1-0nsp4vhh80e.jpeg"></td></tr></tbody></table><br>  Ici, nous avons besoin d'un flux s√©par√© pour recevoir les requ√™tes HTTP entrantes, d'un flux s√©par√© pour nos propres requ√™tes HTTP sortantes, d'un flux s√©par√© pour coordonner le traitement des requ√™tes HTTP re√ßues.  Ainsi qu'un pool de workflows pour effectuer des op√©rations sur les images (puisque les manipulations sur les images sont bien parall√®les, le traitement d'une image par plusieurs flux √† la fois r√©duira son temps de traitement). <br><br>  Par cons√©quent, notre objectif est de g√©rer un grand nombre de demandes entrantes simultan√©es sur un petit nombre de threads de travail.  Voyons comment nous y parvenons √† travers diff√©rentes approches. <br><br><h2>  Quelques avertissements importants </h2><br>  Avant de passer √† l'histoire principale et aux exemples de code d'analyse, quelques notes doivent √™tre prises. <br><br>  Premi√®rement, tous les exemples suivants ne sont li√©s √† aucun framework ou biblioth√®que particulier.  Toutes les correspondances dans les noms des appels API sont al√©atoires et involontaires. <br><br>  Deuxi√®mement, il n'y a pas de gestion d'erreur dans les exemples ci-dessous.  Cela se fait d√©lib√©r√©ment, afin que les diapositives soient compactes et visibles.  Et aussi pour que le mat√©riel rentre dans le temps allou√© au rapport. <br><br>  Troisi√®mement, les exemples utilisent une certaine entit√© execution_context, qui contient des informations sur ce qui existe d'autre √† l'int√©rieur du programme.  Remplir cette entit√© d√©pend de l'approche.  Dans le cas des acteurs, execution_context aura des liens vers d'autres acteurs.  Dans le cas de CSP, dans execution_context, il y aura des canaux CSP pour la communication avec d'autres processus CSP.  Etc. <br><br><h1>  Approche n ¬∞ 1: acteurs </h1><br><h2>  Mod√®le d'acteurs en bref </h2><br>  Lors de l'utilisation du mod√®le d'acteurs, la solution sera construite √† partir d'objets-acteurs s√©par√©s, chacun ayant son propre √©tat priv√© et cet √©tat est inaccessible √† quiconque sauf √† l'acteur lui-m√™me. <br><br>  Les acteurs interagissent entre eux via des messages asynchrones.  Chaque acteur a sa propre bo√Æte aux lettres unique (file d'attente de messages), dans laquelle les messages envoy√©s √† l'acteur sont enregistr√©s et d'o√π ils sont r√©cup√©r√©s pour un traitement ult√©rieur. <br><br>  Les acteurs travaillent sur des principes tr√®s simples: <br><br><ul><li>  un acteur est une entit√© avec un comportement; </li><li>  les acteurs r√©pondent aux messages entrants; </li><li>  Apr√®s avoir re√ßu le message, l'acteur peut: <br><ul><li>  envoyer un certain nombre (final) de messages √† d'autres acteurs; </li><li>  cr√©er un certain nombre (final) de nouveaux acteurs; </li><li>  D√©finissez un nouveau comportement pour le traitement des messages suivants. </li></ul></li></ul><br>  Au sein d'une application, les acteurs peuvent √™tre impl√©ment√©s de diff√©rentes mani√®res: <br><br><ul><li>  chaque acteur peut √™tre repr√©sent√© comme un flux de syst√®me d'exploitation distinct (cela se produit, par exemple, dans la biblioth√®que C :: Just :: Thread Pro Actor Edition); </li><li>  chaque acteur peut √™tre repr√©sent√© comme une coroutine empil√©e; </li><li>  chaque acteur peut √™tre repr√©sent√© comme un objet dans lequel quelqu'un appelle des m√©thodes de rappel. </li></ul><br>  Dans notre d√©cision, nous allons utiliser des acteurs sous forme d'objets avec des rappels, et laisser des coroutines pour l'approche CSP. <br><br><h2>  Sch√©ma de d√©cision bas√© sur le mod√®le des acteurs </h2><br>  Sur la base des acteurs, le sch√©ma g√©n√©ral de r√©solution de notre probl√®me ressemblera √† ceci: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/di/f7/pn/dif7pngijjde8aizja_skqy58oo.jpeg"></td></tr></tbody></table><br>  Nous aurons des acteurs qui sont cr√©√©s au d√©but du serveur HTTP et qui existent tout le temps pendant que le serveur HTTP fonctionne.  Ce sont des acteurs tels que: HttpSrv, UserChecker, ImageDownloader, ImageMixer. <br><br>  √Ä la r√©ception d'une nouvelle demande HTTP entrante, nous cr√©ons une nouvelle instance de l'acteur RequestHandler, qui sera d√©truite apr√®s l'√©mission d'une r√©ponse √† la demande HTTP entrante. <br><br><h2>  Code d'acteur RequestHandler </h2><br>  L'impl√©mentation de l'acteur request_handler, qui coordonne le traitement d'une requ√™te HTTP entrante, peut ressembler √† ceci: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> some_basic_type { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execution_context context_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request request_; optional&lt;user_info&gt; user_info_; optional&lt;image_loaded&gt; image_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_user_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_info info)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_image_loaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_loaded image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_mixed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mixed_image image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mix_images_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//     . }; void request_handler::on_start() { send(context_.user_checker(), check_user{request_.user_id(), self()}); send(context_.image_downloader(), download_image{request_.image_id(), self()}); } void request_handler::on_user_info(user_info info) { user_info_ = std::move(info); if(image_) send_mix_images_request(); } void request_handler::on_image_loaded(image_loaded image) { image_ = std::move(image); if(user_info_) send_mix_images_request(); } void request_handler::send_mix_images_request() { send(context_.image_mixer(), mix_images{user_info-&gt;watermark_image(), *image_, self()}); } void request_handler::on_mixed_image(mixed_image image) { send(context_.http_srv(), reply{..., std::move(image), ...}); }</span></span></code> </pre> <br>  Analysons ce code. <br><br>  Nous avons une classe dans les attributs dont nous stockons ou allons stocker ce dont nous avons besoin pour traiter la demande.  Dans cette classe, il existe √©galement un ensemble de rappels qui seront appel√©s √† un moment ou √† un autre. <br><br>  Tout d'abord, lorsqu'un acteur vient d'√™tre cr√©√©, le rappel on_start () est appel√©.  Dans ce document, nous envoyons deux messages √† d'autres acteurs.  Tout d'abord, il s'agit d'un message check_user pour v√©rifier l'ID client.  Deuxi√®mement, il s'agit d'un message download_image pour t√©l√©charger l'image d'origine. <br><br>  Dans chacun des messages envoy√©s, nous nous transmettons un lien (un appel √† la m√©thode self () renvoie un lien vers l'acteur pour lequel self () a √©t√© appel√©).  Cela est n√©cessaire pour que notre acteur puisse envoyer un message en r√©ponse.  Si nous n'envoyons pas de lien √† notre acteur, par exemple, dans le message check_user, alors l'acteur UserChecker ne saura pas √† qui envoyer les informations utilisateur. <br><br>  Lorsqu'un message user_info avec des informations utilisateur nous est envoy√© en r√©ponse, le rappel on_user_info () est appel√©.  Et lorsque le message image_loaded nous est envoy√©, le rappel on_image_loaded () est appel√© sur notre acteur.  Et maintenant, √† l'int√©rieur de ces deux rappels, nous voyons une caract√©ristique inh√©rente au mod√®le des acteurs: nous ne savons pas exactement dans quel ordre nous recevrons les messages de r√©ponse.  Par cons√©quent, nous devons √©crire notre code afin qu'il ne d√©pende pas de l'ordre dans lequel les messages arrivent.  Par cons√©quent, dans chacun des processeurs, nous stockons d'abord les informations re√ßues dans l'attribut correspondant, puis v√©rifions si nous avons d√©j√† collect√© toutes les informations dont nous avons besoin?  Si c'est le cas, nous pouvons continuer.  Sinon, nous attendrons plus loin. <br><br>  C'est pourquoi nous avons des ifs on_user_info () et on_image_loaded () qui sont ex√©cut√©s lors de l'appel de send_mix_images_request (). <br><br><blockquote>  En principe, dans les impl√©mentations du mod√®le d'acteurs, il peut y avoir des m√©canismes comme la r√©ception s√©lective d'Erlang ou le masquage d'Akka, √† travers lesquels vous pouvez manipuler l'ordre de traitement des messages entrants, mais nous n'en parlerons pas aujourd'hui, afin de ne pas plonger dans la jungle des d√©tails des diff√©rentes impl√©mentations du mod√®le. Acteurs. </blockquote><br>  Donc, si toutes les informations dont nous avons besoin de UserChecker et ImageDownloader sont re√ßues, la m√©thode send_mix_images_request () est appel√©e, dans laquelle le message mix_images est envoy√© √† l'acteur ImageMixer.  Le rappel on_mixed_image () est appel√© lorsque nous recevons un message de r√©ponse avec l'image r√©sultante.  Ici, nous envoyons cette image √† l'acteur HttpSrv et attendons que HttpSrv forme une r√©ponse HTTP et d√©truise le RequestHandler qui est devenu inutile (bien que, en principe, rien n'emp√™che l'acteur RequestHandler de s'autod√©truire dans le rappel on_mixed_image ()). <br><br>  C'est tout. <br><br>  La mise en ≈ìuvre de l'acteur RequestHandler s'est av√©r√©e assez volumineuse.  Mais cela est d√ª au fait que nous devions d√©crire une classe avec des attributs et des rappels, puis impl√©menter √©galement des rappels.  Mais la logique du travail de RequestHandler est tr√®s triviale, et sa compr√©hension, malgr√© la quantit√© de code dans la classe request_handler, n'est pas difficile. <br><br><h2>  Caract√©ristiques inh√©rentes aux acteurs </h2><br>  Nous pouvons maintenant dire quelques mots sur les caract√©ristiques du mod√®le d'acteurs. <br><br><h3>  R√©acteurs </h3><br>  En r√®gle g√©n√©rale, les acteurs ne r√©pondent qu'aux messages entrants.  Il y a des messages - l'acteur les traite.  Aucun message - l'acteur ne fait rien. <br><br>  Cela est particuli√®rement vrai pour les impl√©mentations du mod√®le d'acteurs dans lesquelles les acteurs sont repr√©sent√©s comme des objets avec des rappels.  Le cadre tire le rappel de l'acteur et si l'acteur ne rend pas le contr√¥le du rappel, le cadre ne peut pas servir d'autres acteurs dans le m√™me contexte. <br><br><h3>  Les acteurs sont surcharg√©s </h3><br>  Sur les acteurs, nous pouvons tr√®s facilement faire en sorte qu'un acteur-producteur g√©n√®re des messages pour un acteur-consommateur √† un rythme beaucoup plus rapide qu'un acteur-consommateur ne pourra traiter. <br><br>  Cela conduira au fait que la file d'attente des messages entrants pour l'acteur-consommateur augmentera constamment.  Croissance de la file d'attente, c.-√†-d.  une consommation de m√©moire accrue dans l'application r√©duira la vitesse de l'application.  Cela entra√Ænera une croissance encore plus rapide de la file d'attente et, par cons√©quent, l'application peut se d√©grader pour devenir inop√©rante. <br><br>  Tout cela est une cons√©quence directe de l'interaction asynchrone des acteurs.  Parce que l'op√©ration d'envoi est g√©n√©ralement non bloquante.  Et pour le faire bloquer n'est pas facile, car  un acteur peut s'envoyer √† lui-m√™me.  Et si la file d'attente pour l'acteur est pleine, alors lors de l'envoi, l'acteur sera bloqu√© et cela arr√™tera son travail. <br><br>  Ainsi, lorsque vous travaillez avec des acteurs, une attention particuli√®re doit √™tre port√©e au probl√®me de la surcharge. <br><br><h3>  De nombreux acteurs ne sont pas toujours la solution. </h3><br>  En r√®gle g√©n√©rale, les acteurs sont des entit√©s l√©g√®res et il y a une tentation de les cr√©er dans leur application en grand nombre.  Vous pouvez cr√©er dix mille acteurs, cent mille et un million.  Et m√™me une centaine de millions d'acteurs, si le fer vous le permet. <br><br>  Mais le probl√®me est que le comportement d'un tr√®s grand nombre d'acteurs est difficile √† suivre.  C'est-√†-dire  vous pouvez avoir certains acteurs qui fonctionnent clairement correctement.  Certains acteurs qui, de toute √©vidence, ne fonctionnent pas correctement ou ne fonctionnent pas du tout, et vous en √™tes s√ªr.  Mais il peut y avoir un grand nombre d'acteurs dont vous ne savez rien: fonctionnent-ils du tout, fonctionnent-ils correctement ou incorrectement?  Et tout cela parce que lorsque vous avez une centaine de millions d'entit√©s autonomes avec votre propre logique de comportement dans votre programme, le suivi est tr√®s difficile pour tout le monde. <br><br>  Par cons√©quent, il peut s'av√©rer que lors de la cr√©ation d'un grand nombre d'acteurs dans l'application, nous ne r√©solvons pas notre probl√®me appliqu√©, mais obtenons un autre probl√®me.  Et, par cons√©quent, il peut √™tre avantageux pour nous d'abandonner des acteurs simples qui r√©solvent une seule t√¢che, au profit d'acteurs plus complexes et plus lourds qui effectuent plusieurs t√¢ches.  Mais il y aura alors moins d'acteurs "lourds" dans l'application et il nous sera plus facile de les suivre. <br><br><h2>  O√π chercher, que prendre? </h2><br>  Si quelqu'un veut essayer de travailler avec des acteurs en C ++, alors inutile de construire ses propres v√©los, il existe plusieurs solutions toutes faites, notamment: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> (supporte le fabricant national!) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cadre d'acteur C ++ (CAF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">QP / C ++</a> </li></ul><br>  Ces trois options sont anim√©es, √©volutives, multiplateformes, document√©es.  Vous pouvez √©galement les essayer gratuitement.  De plus, plusieurs options de degr√©s de fra√Æcheur [pas] diff√©rents peuvent √™tre trouv√©es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans la liste sur Wikipedia</a> . <br><br>  SObjectizer et CAF sont con√ßus pour √™tre utilis√©s dans des t√¢ches de haut niveau o√π des exceptions et de la m√©moire dynamique peuvent √™tre appliqu√©es.  Et le cadre QP / C ++ peut int√©resser ceux qui sont impliqu√©s dans le d√©veloppement embarqu√©, comme  c'est sous cette niche qu'il est ¬´emprisonn√©¬ª. <br><br><h1>  Approche n ¬∞ 2: CSP (communication de processus s√©quentiels) </h1><br><h2>  CSP sur les doigts et sans matan </h2><br>  Le mod√®le CSP est tr√®s similaire au mod√®le Actors.  Nous construisons √©galement notre solution √† partir d'un ensemble d'entit√©s autonomes, chacune ayant son propre √©tat priv√© et n'interagissant avec d'autres entit√©s que via des messages asynchrones. <br><br>  Seules ces entit√©s dans le mod√®le CSP sont appel√©es ¬´processus¬ª. <br><br>  Les processus dans CSP sont l√©gers, sans aucune parall√©lisation de leur travail √† l'int√©rieur.  Si nous devons parall√©liser quelque chose, nous d√©marrons simplement plusieurs processus CSP, √† l'int√©rieur desquels il n'y a plus de parall√©lisation. <br><br>  Les processus CSP interagissent les uns avec les autres via des messages asynchrones, mais les messages ne sont pas envoy√©s aux bo√Ætes aux lettres, comme dans le mod√®le des acteurs, mais aux canaux.  Les canaux peuvent √™tre consid√©r√©s comme des files d'attente de messages, g√©n√©ralement de taille fixe. <br><br>  Contrairement au mod√®le Acteurs, o√π une bo√Æte aux lettres est automatiquement cr√©√©e pour chaque acteur, les canaux dans le CSP doivent √™tre cr√©√©s explicitement.  Et si nous avons besoin que les deux processus interagissent, alors nous devons cr√©er le canal nous-m√™mes, puis dire au premier processus "vous √©crirez ici", et le deuxi√®me processus devrait dire: "vous lirez ici d'ici". <br><br>  Dans le m√™me temps, les canaux ont au moins deux op√©rations qui doivent √™tre appel√©es explicitement.  La premi√®re est l'op√©ration d'√©criture (envoi) pour √©crire un message sur le canal. <br><br>  Deuxi√®mement, il s'agit d'une op√©ration de lecture (r√©ception) pour lire un message √† partir d'un canal.  Et la n√©cessit√© d'appeler explicitement lecture / r√©ception distingue CSP du mod√®le Acteurs, car  dans le cas des acteurs, l'op√©ration de lecture / r√©ception peut g√©n√©ralement √™tre cach√©e √† l'acteur.  C'est-√†-dire  La structure d'acteur peut r√©cup√©rer des messages de la file d'attente des acteurs et appeler un gestionnaire (rappel) pour le message r√©cup√©r√©. <br><br>  Alors que le processus CSP lui-m√™me doit choisir le moment de l'appel de lecture / r√©ception, alors le processus CSP doit d√©terminer le message qu'il a re√ßu et traiter le message extrait. <br><br>  Au sein de notre ¬´grande¬ª application, les processus CSP peuvent √™tre impl√©ment√©s de diff√©rentes mani√®res: <br><br><ul><li>  Le processus CSP-shny peut √™tre impl√©ment√© comme un OS de thread s√©par√©.  Cela s'av√®re une solution co√ªteuse, mais avec un multit√¢che pr√©emptif; </li><li>  Le processus CSP peut √™tre impl√©ment√© par coroutine (coroutine empil√©e, fibre, fil vert, ...).  C'est beaucoup moins cher, mais le multit√¢che n'est que coop√©ratif. </li></ul><br>  De plus, nous supposons que les processus CSP sont pr√©sent√©s sous la forme de coroutines empilables (bien que le code montr√© ci-dessous puisse tr√®s bien √™tre impl√©ment√© sur les threads OS). <br><br><h2>  Diagramme de solution bas√©e sur CSP </h2><br>  Le sch√©ma de solution bas√© sur le mod√®le CSP ressemblera beaucoup √† un sch√©ma similaire pour le mod√®le des acteurs (et ce n'est pas un hasard): <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/96/oy/uu/96oyuu6mwhj4ot6fqpsiiv-f1h8.jpeg"></td></tr></tbody></table><br>  Il y aura √©galement des entit√©s qui d√©marreront au d√©marrage du serveur HTTP et fonctionneront tout le temps - ce sont les processus CSP HttpSrv, UserChecker, ImageDownloader et ImageMixer.  Pour chaque nouvelle demande entrante, un nouveau processus CSP RequestHandler sera cr√©√©.  Ce processus envoie et re√ßoit les m√™mes messages que lors de l'utilisation du mod√®le d'acteurs. <br><br><h2>  Code de processus RequestHandler CSP </h2><br>  Cela peut ressembler au code d'une fonction qui impl√©mente le processus timide CSP de RequestHandler: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ch = make_chain&lt;user_info&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_loaded_ch = make_chain&lt;image_loaded&gt;(); ctx.user_checker_ch().write(check_user{req.user_id(), user_info_ch}); ctx.image_downloader_ch().write(download_image{req.image_id(), image_loaded_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); ctx.image_mixer_ch().write( mix_image{user.watermark_image(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(original_image), image_mix_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result_image = image_mix_ch.read(); ctx.http_srv_ch().write(reply{..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result_image), ...}); }</code> </pre> <br>  Ici, tout est assez banal et r√©p√®te r√©guli√®rement le m√™me sch√©ma: <br><br><ul><li>  Tout d'abord, nous cr√©ons un canal pour recevoir des messages de r√©ponse.  Ceci est n√©cessaire car  le processus CSP n'a pas sa propre bo√Æte aux lettres par d√©faut, comme les acteurs.  Par cons√©quent, si le processus CSP-shny veut recevoir quelque chose, alors il devrait √™tre intrigu√© par la cr√©ation du canal o√π ce "quelque chose" sera √©crit; </li><li>  puis nous envoyons notre message au processus ma√Ætre CSP.  Et dans ce message, nous indiquons le canal pour le message de r√©ponse; </li><li>  puis nous effectuons l'op√©ration de lecture √† partir du canal o√π nous devrions recevoir un message de r√©ponse. </li></ul><br>  Ceci est tr√®s clairement vu dans l'exemple de communication avec le processus ImageSPixer CSP: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  . ctx.image_mixer_ch().write( //  . mix_image{..., image_mix_ch}); //     . auto result_image = image_mix_ch.read(); //  .</span></span></code> </pre> <br>  Mais s√©par√©ment, il convient de se concentrer sur ce fragment: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read();</code> </pre> <br>  Ici, nous voyons une autre diff√©rence s√©rieuse par rapport au mod√®le des acteurs.  Dans le cas du CSP, nous pouvons recevoir des messages de r√©ponse dans l'ordre qui nous convient. <br><br>  Vous voulez d'abord attendre user_info?  Pas de probl√®me, allez dormir en lecture jusqu'√† ce que user_info apparaisse.  Si image_loaded nous a d√©j√† √©t√© envoy√© √† ce moment-l√†, il attendra simplement dans son canal jusqu'√† ce que nous le lisions. <br><br>  En fait, c'est tout ce qui peut accompagner le code ci-dessus.  Le code bas√© sur CSP √©tait plus compact que son homologue bas√© sur un acteur.  Ce qui n'est pas surprenant puisque  ici, nous n'avons pas eu √† d√©crire une classe distincte avec des m√©thodes de rappel.  Et une partie de l'√©tat de notre processus CSP-timide RequestHandler est pr√©sent implicitement sous la forme d'arguments ctx et req. <br><br><h2>  Fonctionnalit√©s CSP </h2><br><h3>  R√©activit√© et proactivit√© des processus CSP </h3><br>  Contrairement aux acteurs, les processus CSP peuvent √™tre r√©actifs, proactifs ou les deux.  Disons que le processus CSP a v√©rifi√© ses messages entrants; s'il y en avait, il les a trait√©s.  Et puis, voyant qu'il n'y avait pas de messages entrants, il s'est engag√© √† multiplier les matrices. <br><br>  Apr√®s un certain temps, le processus CSP de la matrice √©tait fatigu√© de se multiplier et il a de nouveau v√©rifi√© les messages entrants.  Pas de nouveaux?  Eh bien, allons multiplier les matrices plus loin. <br><br>  Et cette capacit√© des processus CSP √† effectuer certains travaux m√™me en l'absence de messages entrants rend le mod√®le CSP tr√®s diff√©rent du mod√®le Actors. <br><br><h3>  M√©canismes natifs de protection contre les surcharges </h3><br>  Puisque, en r√®gle g√©n√©rale, les canaux sont des files d'attente de messages d'une taille limit√©e et qu'une tentative d'√©crire un message sur un canal rempli arr√™te l'exp√©diteur, alors dans CSP, nous avons un m√©canisme int√©gr√© de protection contre la surcharge. <br><br>  En effet, si nous avons un processus producteur agile et un processus consommateur lent, alors le processus producteur remplira rapidement le canal et il sera suspendu pour la prochaine op√©ration d'envoi.  Et le processus producteur dormira jusqu'√† ce que le processus consommateur lib√®re de l'espace dans le canal pour de nouveaux messages.  D√®s que l'endroit appara√Æt, le processus producteur se r√©veille et lance de nouveaux messages dans la cha√Æne. <br><br>  Ainsi, lors de l'utilisation de CSP, on peut moins se soucier du probl√®me de surcharge que dans le cas du Mod√®le d'Acteurs.  Certes, il y a un pi√®ge ici, dont nous parlerons un peu plus tard. <br><br><h3>  Comment les processus CSP sont-ils mis en ≈ìuvre </h3><br>  Nous devons d√©cider comment nos processus CSP seront mis en ≈ìuvre. <br><br>  Cela peut √™tre fait pour que chaque processus CSP-shny soit repr√©sent√© par un thread OS s√©par√©.  Cela s'av√®re une solution co√ªteuse et non √©volutive.  Mais d'un autre c√¥t√©, nous obtenons un multit√¢che pr√©emptif: si notre processus CSP commence √† multiplier les matrices ou effectue une sorte d'appel de blocage, le syst√®me d'exploitation le poussera finalement hors du noyau de calcul et permettra aux autres processus CSP de fonctionner. <br><br>  Il est possible de faire repr√©senter chaque processus CSP par une coroutine (coroutine empil√©e).  Il s'agit d'une solution beaucoup moins ch√®re et √©volutive.  Mais ici, nous n'aurons que du multit√¢che coop√©ratif.  Par cons√©quent, si soudainement le processus CSP prend la multiplication de matrice, le thread de travail avec ce processus CSP et les autres processus CSP qui lui sont associ√©s seront bloqu√©s. <br><br>  Il peut y avoir une autre astuce.  Supposons que nous utilisons une biblioth√®que tierce, √† l'int√©rieur de laquelle nous ne pouvons pas influencer.  Et √† l'int√©rieur de la biblioth√®que, des variables TLS sont utilis√©es (c'est-√†-dire thread-local-stockage).  Nous appelons la fonction biblioth√®que et la biblioth√®que d√©finit la valeur d'une variable TLS.  Ensuite, notre coroutine "se d√©place" vers un autre thread de travail, et cela est possible, car  en principe, les coroutines peuvent migrer d'un fil de travail √† un autre.  Nous effectuons l'appel suivant √† la fonction de biblioth√®que et la biblioth√®que essaie de lire la valeur de la variable TLS.  Mais il y a peut-√™tre d√©j√† un sens diff√©rent!  Et la recherche d'un tel bug sera tr√®s difficile. <br><br>  Par cons√©quent, vous devez soigneusement consid√©rer le choix de la m√©thode pour impl√©menter les processus CSP-shnyh.  Chacune des options a ses propres forces et faiblesses. <br><br><h3>  De nombreux processus ne sont pas toujours la solution. </h3><br>  Comme pour les acteurs, la possibilit√© de cr√©er de nombreux processus CSP dans votre programme n'est pas toujours une solution √† un probl√®me appliqu√©, mais vous cr√©e des probl√®mes suppl√©mentaires. <br><br>  De plus, la mauvaise visibilit√© de ce qui se passe √† l'int√©rieur du programme n'est qu'une partie du probl√®me.  Je voudrais me concentrer sur un autre √©cueil. <br><br>  Le fait est que sur les canaux CSP-shnyh, vous pouvez facilement obtenir un analogue de blocage.  Le processus A tente d'√©crire un message sur le canal C1 complet et le processus A est suspendu.  √Ä partir du canal C1, le processus B, qui a tent√© d'√©crire sur le canal C2, qui est plein, doit √™tre lu, et par cons√©quent, le processus B a √©t√© suspendu.  Et √† partir du canal C2, le processus A devait √™tre lu. C'est tout, nous avons eu une impasse. <br><br>  Si nous n'avons que deux processus CSP, nous pouvons trouver un tel blocage pendant le d√©bogage ou m√™me avec la proc√©dure de r√©vision du code.  Mais si nous avons des millions de processus dans le programme, ils communiquent activement entre eux, alors la probabilit√© de tels blocages augmente consid√©rablement. <br><br><h2>  O√π chercher, que prendre? </h2><br>  Si quelqu'un veut travailler avec CSP en C ++, alors le choix ici, malheureusement, n'est pas aussi grand que pour les acteurs.  Eh bien, ou je ne sais pas o√π regarder et comment regarder.  Dans ce cas, j'esp√®re que les commentaires partageront d'autres liens. <br><br>  Mais, si nous voulons utiliser CSP, nous devons d'abord regarder vers <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Boost.Fiber</a> .  Il existe des fibres (c'est-√†-dire des coroutines) et des canaux, et m√™me des primitives de bas niveau telles que mutex, condition_variable, barri√®re.  Tout cela peut √™tre pris et utilis√©. <br><br>  Si vous √™tes satisfait des processus CSP sous forme de threads, vous pouvez regarder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> .  Il existe √©galement des analogues de canaux CSP et des applications multithread complexes sur SObjectizer peuvent √™tre √©crites sans aucun acteur. <br><br><h1>  Acteurs vs CSP </h1><br>  Les acteurs et les CSP sont tr√®s similaires les uns aux autres.  √Ä plusieurs reprises, je suis tomb√© sur l'affirmation selon laquelle ces deux mod√®les sont √©quivalents l'un √† l'autre.  C'est-√†-dire  ce qui peut √™tre fait sur les acteurs peut √™tre r√©p√©t√© presque 1 en 1 sur les processus CSP et vice versa.  Ils disent que c'est m√™me prouv√© math√©matiquement.  Mais ici, je ne comprends rien, donc je ne peux rien dire.  Mais d'apr√®s mes propres pens√©es quelque part au niveau du bon sens quotidien, tout cela semble tout √† fait plausible.  Dans certains cas, en effet, les acteurs peuvent √™tre remplac√©s par des processus CSP et les processus CSP par des acteurs. <br><br>  Cependant, il existe plusieurs diff√©rences entre les acteurs et les DSP qui peuvent aider √† d√©terminer o√π chacun de ces mod√®les est b√©n√©fique ou d√©savantageux. <br><br><h2>  Canaux vs bo√Æte aux lettres </h2><br>  Un acteur a un seul ¬´canal¬ª pour recevoir les messages entrants - c'est sa bo√Æte aux lettres, qui est automatiquement cr√©√©e pour chaque acteur.  Et l'acteur en r√©cup√®re les messages s√©quentiellement, exactement dans l'ordre dans lequel les messages √©taient dans la bo√Æte aux lettres. <br><br>  Et c'est une question assez s√©rieuse.  Disons qu'il y a trois messages dans la bo√Æte aux lettres de l'acteur: M1, M2 et M3.  L'acteur ne s'int√©resse actuellement qu'√† M3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais avant d'arriver √† M3, l'acteur va d'abord extraire M1, puis M2. </font><font style="vertical-align: inherit;">Et que va-t-il en faire?</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Encore une fois, dans le cadre de cette conversation, nous n'aborderons pas les m√©canismes de r√©ception s√©lective d'Erlang et la dissimulation d'Akka. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors que le processus CSP-shny a la possibilit√© de s√©lectionner le canal √† partir duquel il souhaite actuellement lire les messages. </font><font style="vertical-align: inherit;">Ainsi, un processus CSP peut avoir trois canaux: C1, C2 et C3. </font><font style="vertical-align: inherit;">Actuellement, le processus CSP ne s'int√©resse qu'aux messages de C3. </font><font style="vertical-align: inherit;">C'est ce canal que lit le processus. </font><font style="vertical-align: inherit;">Et il reviendra au contenu des canaux C1 et C2 quand cela l'int√©ressera.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> R√©activit√© et proactivit√© </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, les acteurs sont r√©actifs et ne fonctionnent que lorsqu'ils ont des messages entrants. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alors que les processus CSP peuvent faire du travail m√™me en l'absence de messages entrants. </font><font style="vertical-align: inherit;">Dans certains sc√©narios, cette diff√©rence peut jouer un r√¥le important.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Machines d'√©tat </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En fait, les acteurs sont des machines √† √©tats finis (KA). </font><font style="vertical-align: inherit;">Par cons√©quent, s'il existe de nombreuses machines √† √©tats finis dans votre domaine, et m√™me s'il s'agit de machines √† √©tats finis hi√©rarchiques complexes, il peut √™tre beaucoup plus facile pour vous de les impl√©menter sur la base du mod√®le d'acteur qu'en ajoutant une impl√©mentation de vaisseau spatial √† un processus CSP.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En C ++, il n'y a pas encore de support CSP natif. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'exp√©rience du langage Go montre √† quel point il est facile et pratique d'utiliser le mod√®le CSP lorsque son support est impl√©ment√© au niveau d'un langage de programmation et de sa biblioth√®que standard. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans Go, il est facile de cr√©er des ¬´processus CSP¬ª (alias goroutines), il est facile de cr√©er et de travailler avec des canaux, il existe une syntaxe int√©gr√©e pour travailler avec plusieurs canaux √† la fois (Go-shny select, qui fonctionne non seulement pour la lecture mais aussi pour l'√©criture), la biblioth√®que standard conna√Æt les goroutins et peut les changer lorsque goroutin fait un appel de blocage depuis stdlib. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En C ++, jusqu'√† pr√©sent, il n'y a pas de support pour les coroutines empil√©es (au niveau du langage). </font><font style="vertical-align: inherit;">Par cons√©quent, travailler avec CSP en C ++ peut sembler, par endroits, sinon une b√©quille, alors ... Cela n√©cessite certainement beaucoup plus d'attention √† lui-m√™me que dans le cas du m√™me Go.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Approche n ¬∞ 3: t√¢ches (asynchrones, futures, wait_all, ...) </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √Ä propos de l'approche bas√©e sur les t√¢ches dans les mots les plus courants </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le sens de l'approche bas√©e sur les t√¢ches est que si nous avons une op√©ration complexe, nous divisons cette op√©ration en √©tapes de t√¢che distinctes, o√π chaque t√¢che (c'est une t√¢che) effectue une seule sous-op√©ration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous commen√ßons ces t√¢ches avec l'op√©ration sp√©ciale async. </font><font style="vertical-align: inherit;">L'op√©ration asynchrone renvoie un futur objet dans lequel, une fois la t√¢che termin√©e, la valeur renvoy√©e par la t√¢che sera plac√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apr√®s avoir lanc√© N t√¢ches et re√ßu N objets-futur, nous devons en quelque sorte tricoter tout cela en cha√Æne. </font><font style="vertical-align: inherit;">Il semble que lorsque les t√¢ches n ¬∞ 1 et n ¬∞ 2 sont termin√©es, les valeurs renvoy√©es par celles-ci devraient tomber dans la t√¢che n ¬∞ 3. </font><font style="vertical-align: inherit;">Et lorsque la t√¢che n ¬∞ 3 est termin√©e, la valeur renvoy√©e doit √™tre transf√©r√©e aux t√¢ches n ¬∞ 4, n ¬∞ 5 et n ¬∞ 6. </font><font style="vertical-align: inherit;">Etc., etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour une telle ¬´cravate¬ª, des moyens sp√©ciaux sont utilis√©s. </font><font style="vertical-align: inherit;">Tels que, par exemple, la m√©thode .then () d'un futur objet, ainsi que les fonctions wait_all (), wait_any (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une telle explication ¬´sur les doigts¬ª n'est peut-√™tre pas tr√®s claire, alors passons au code. </font><font style="vertical-align: inherit;">Peut-√™tre que dans une conversation sur un code sp√©cifique, la situation deviendra plus claire (mais pas un fait).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code Request_handler pour l'approche bas√©e sur les t√¢ches </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le code de traitement d'une requ√™te HTTP entrante bas√©e sur des t√¢ches peut ressembler √† ceci: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context &amp; ctx, request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); }); when_all(user_info_ft, original_image_ft).then( [&amp;ctx, req](tuple&lt;future&lt;user_info&gt;, future&lt;image_loaded&gt;&gt; data) { async(ctx.image_mixer_ctx(), [&amp;ctx, req, d=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix_image(get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(d).get().watermark_image(), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(d).get()); }) .then([req](future&lt;mixed_image&gt; mixed) { async(ctx.http_srv_ctx(), [req, im=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mixed)] { make_reply(...); }); }); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essayons de comprendre ce qui se passe ici. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous cr√©ons une t√¢che qui doit √™tre lanc√©e dans le contexte de notre propre client HTTP et qui demande des informations sur l'utilisateur. L'objet futur renvoy√© est stock√© dans la variable user_info_ft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous cr√©ons une t√¢che similaire, qui devrait √©galement s'ex√©cuter dans le contexte de notre propre client HTTP et qui charge l'image d'origine. L'objet futur renvoy√© est stock√© dans la variable original_image_ft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, nous devons attendre que les deux premi√®res t√¢ches soient termin√©es. </font><font style="vertical-align: inherit;">Ce que nous √©crivons directement: when_all (user_info_ft, original_image_ft). </font><font style="vertical-align: inherit;">Lorsque les deux futurs objets obtiendront leurs valeurs, nous ex√©cuterons une autre t√¢che. </font><font style="vertical-align: inherit;">Cette t√¢che prendra le bitmap avec le filigrane et l'image d'origine et ex√©cutera une autre t√¢che dans le contexte d'ImageMixer. </font><font style="vertical-align: inherit;">Cette t√¢che m√©langera des images et lorsqu'elle sera termin√©e, une autre t√¢che sera lanc√©e sur le contexte du serveur HTTP, ce qui g√©n√©rera une r√©ponse HTTP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peut-√™tre qu'une telle explication de ce qui se passe dans le code n'est pas beaucoup clarifi√©e. </font><font style="vertical-align: inherit;">Par cons√©quent, num√©rotons nos t√¢ches:</font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/5k/c0/mr/5kc0mrvqnxdf6lp4-p0wgn1nj7w.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et regardons les d√©pendances entre elles (d'o√π d√©coule l'ordre des t√¢ches): </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zu/j4/g4/zuj4g4wwg0wxmhazj5k5rdb8pgu.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et si nous superposons maintenant cette image sur notre code source, j'esp√®re que cela deviendra plus clair: </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/sw/at/uz/swatuzio1z33-ei16gquj-ss5mg.jpeg"></td></tr></tbody></table><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Caract√©ristiques de l'approche bas√©e sur les t√¢ches </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilit√© </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La premi√®re fonctionnalit√© qui devrait d√©j√† √™tre √©vidente est la visibilit√© du code sur Task. </font><font style="vertical-align: inherit;">Tout ne va pas bien avec elle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, vous pouvez mentionner une chose comme l'enfer de rappel. </font><font style="vertical-align: inherit;">Les programmeurs Node.js le connaissent tr√®s bien. </font><font style="vertical-align: inherit;">Mais les surnoms C ++ qui travaillent en √©troite collaboration avec Task plongent √©galement dans cet enfer de rappel.</font></font><br><br><h3>  Gestion des erreurs </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre caract√©ristique int√©ressante est la gestion des erreurs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'une part, dans le cas de l'utilisation asynchrone et future avec la livraison d'informations d'erreur √† l'int√©ress√©, cela peut √™tre encore plus facile que dans le cas des acteurs ou du CSP. </font><font style="vertical-align: inherit;">Apr√®s tout, si dans le processus CSP A envoie une demande au processus B et attend un message de r√©ponse, alors lorsque B rencontre une erreur lors de l'ex√©cution de la demande, nous devons d√©cider comment remettre l'erreur au processus A:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou nous cr√©erons un type de message s√©par√© et un canal pour le recevoir; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou nous renvoyons le r√©sultat avec un seul message, qui sera std :: variant pour un r√©sultat normal et erron√©. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et dans le cas du futur, tout est plus simple: on extrait du futur soit un r√©sultat normal, soit une exception nous est lanc√©e. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais, d'un autre c√¥t√©, nous pouvons facilement rencontrer une cascade d'erreurs. </font><font style="vertical-align: inherit;">Par exemple, une exception s'est produite dans la t√¢che n ¬∞ 1, cette exception est tomb√©e dans le futur objet, qui a √©t√© transmis √† la t√¢che n ¬∞ 2. </font><font style="vertical-align: inherit;">Dans la t√¢che n ¬∞ 2, nous avons essay√© de prendre la valeur de l'avenir, mais nous avons re√ßu une exception. </font><font style="vertical-align: inherit;">Et, tr√®s probablement, nous l√®verons la m√™me exception. </font><font style="vertical-align: inherit;">En cons√©quence, il tombera dans le futur futur, qui ira √† la t√¢che n ¬∞ 3. </font><font style="vertical-align: inherit;">Il y aura √©galement une exception qui, tr√®s probablement, sera √©galement publi√©e.</font></font> Etc. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Si nos exceptions sont enregistr√©es, alors dans le journal, nous pouvons voir la r√©p√©tition r√©p√©t√©e de la m√™me exception, qui va d'une t√¢che de la cha√Æne √† une autre t√¢che. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Annuler les t√¢ches et les minuteries / d√©lais d'expiration </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et une autre caract√©ristique tr√®s int√©ressante de la campagne bas√©e sur les t√¢ches est l'annulation des t√¢ches en cas de probl√®me. </font><font style="vertical-align: inherit;">En fait, disons que nous avons cr√©√© 150 t√¢ches, termin√© les 10 premi√®res et r√©alis√© qu'il √©tait inutile de poursuivre le travail. </font><font style="vertical-align: inherit;">Comment annuler les 140 restants? </font><font style="vertical-align: inherit;">C'est une tr√®s, tr√®s bonne question :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre question similaire est de savoir comment se faire des amis avec des minuteries et des temps morts. </font><font style="vertical-align: inherit;">Supposons que nous acc√©dions √† un syst√®me externe et que nous voulons limiter le temps d'attente √† 50 millisecondes. </font><font style="vertical-align: inherit;">Comment r√©gler la minuterie, comment r√©agir √† l'expiration du d√©lai, comment interrompre la cha√Æne de t√¢ches si le d√©lai a expir√©? </font><font style="vertical-align: inherit;">Encore une fois, demander est plus facile que de r√©pondre :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tricherie </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, et pour parler des caract√©ristiques de l'approche bas√©e sur les t√¢ches. </font><font style="vertical-align: inherit;">Dans l'exemple illustr√©, un peu de triche a √©t√© appliqu√©:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, j'ai envoy√© deux t√¢ches au contexte de notre propre serveur HTTP, chacune effectuant une op√©ration de blocage √† l'int√©rieur. </font><font style="vertical-align: inherit;">En effet, pour pouvoir traiter en parall√®le deux requ√™tes vers des services tiers, il fallait ici cr√©er ses propres cha√Ænes de t√¢ches asynchrones. </font><font style="vertical-align: inherit;">Mais je ne l'ai pas fait pour rendre la solution plus ou moins visible et tenir sur la diapositive de pr√©sentation.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Acteurs / CSP vs t√¢ches </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons examin√© trois approches et constat√© que si les acteurs et les processus CSP sont similaires, l'approche bas√©e sur les t√¢ches ne ressemble √† aucune d'entre elles. Et il peut sembler que Actors / CSP devrait √™tre mis en contraste avec Task. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais personnellement, j'aime un point de vue diff√©rent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous parlons du mod√®le des acteurs et du CSP, nous parlons alors de la d√©composition de notre t√¢che. Dans notre t√¢che, nous distinguons des entit√©s ind√©pendantes distinctes et d√©crivons les interfaces de ces entit√©s: quels messages ils envoient, lesquels ils re√ßoivent, par quels canaux les messages passent.</font></font><br><br>  C'est-√†-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en travaillant avec les acteurs et le CSP, nous parlons d'interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais supposons que nous divisions la t√¢che en acteurs et processus CSP s√©par√©s. Comment font-ils exactement leur travail? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque nous adoptons l'approche bas√©e sur les t√¢ches, nous commen√ßons √† parler de mise en ≈ìuvre. A propos de la fa√ßon dont un travail sp√©cifique est effectu√©, quelles sous-op√©rations sont effectu√©es, dans quel ordre, comment ces sous-op√©rations sont connect√©es en fonction des donn√©es, etc.</font></font><br><br>  C'est-√†-dire<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travailler avec Task, nous parlons de mise en ≈ìuvre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par cons√©quent, les acteurs / CSP et les t√¢ches ne sont pas tellement oppos√©s les uns aux autres, mais se compl√®tent. </font><font style="vertical-align: inherit;">Les acteurs / CSP peuvent √™tre utilis√©s pour d√©composer les t√¢ches et d√©finir les interfaces entre les composants. </font><font style="vertical-align: inherit;">Et les t√¢ches peuvent ensuite √™tre utilis√©es pour impl√©menter des composants sp√©cifiques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par exemple, lorsque vous utilisez Actor, nous avons une entit√© telle que ImageMixer, qui doit √™tre manipul√©e avec des images sur le pool de threads. </font><font style="vertical-align: inherit;">En g√©n√©ral, rien ne nous emp√™che d'utiliser l'acteur ImageMixer pour utiliser l'approche bas√©e sur les t√¢ches.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O√π chercher, que prendre? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous souhaitez travailler avec des t√¢ches en C ++, vous pouvez regarder vers la biblioth√®que standard du prochain C ++ 20. Ils ont d√©j√† ajout√© la m√©thode .then () √† l'avenir, ainsi que les fonctions libres wait_all () et wait_any. Voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference pour plus de d√©tails</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a aussi d√©j√† loin d'une nouvelle </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioth√®que async ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dans lequel, en principe, il y a tout ce dont vous avez besoin, juste un peu avec une sauce diff√©rente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et il existe une biblioth√®que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PPL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encore plus ancienne </font><font style="vertical-align: inherit;">. Ce qui donne aussi tout ce dont vous avez besoin, mais avec votre propre sauce.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajout s√©par√© sur la biblioth√®que Intel TBB. </font><font style="vertical-align: inherit;">Cela n'a pas √©t√© mentionn√© dans l'histoire de l'approche bas√©e sur les t√¢ches car, √† mon avis, les graphiques de t√¢ches de TBB sont d√©j√† une approche de flux de donn√©es. </font><font style="vertical-align: inherit;">Et, si ce rapport continue, le discours sur Intel TBB viendra certainement, mais dans le contexte de l'histoire du flux de donn√©es.</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus int√©ressant </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©cemment ici, sur Habr√©, il y avait un article d'Anton Polukhin: "Nous nous </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√©parons pour C ++ 20. Coroutines TS en utilisant un exemple r√©el</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ." </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il parle de combiner une approche bas√©e sur les t√¢ches avec des coroutines sans pile de C ++ 20. </font><font style="vertical-align: inherit;">Et il s'est av√©r√© que le code sur la base de la lisibilit√© des t√¢ches se rapprochait de la lisibilit√© du code sur les processus CSP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Donc, si quelqu'un s'int√©resse √† l'approche bas√©e sur les t√¢ches, il est logique de lire cet article.</font></font><br><br><h1>  Conclusion </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, il est temps de passer aux r√©sultats, car ils ne sont pas si nombreux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La principale chose que je veux dire est que dans le monde moderne, vous pouvez avoir besoin du multithread nu uniquement si vous d√©veloppez une sorte de cadre ou r√©solvez une t√¢che sp√©cifique et de bas niveau. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et si vous √©crivez du code d'application, vous n'avez gu√®re besoin de threads nus, de primitives de synchronisation de bas niveau ou d'une sorte d'algorithmes sans verrouillage avec des conteneurs sans verrouillage. </font><font style="vertical-align: inherit;">Il existe depuis longtemps des approches √©prouv√©es et √©prouv√©es:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acteurs </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> communication des processus s√©quentiels (CSP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t√¢ches (asynchrones, promesses, futurs, ...) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flux de donn√©es </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programmation r√©active </font></font></li><li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et surtout, il existe des outils pr√™ts √† l'emploi pour eux en C ++. </font><font style="vertical-align: inherit;">Vous n'avez pas besoin de faire quoi que ce soit, vous pouvez prendre, essayer et, si vous le souhaitez, mettre en service. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si simple: prenez, essayez et mettez en service.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430672/">https://habr.com/ru/post/fr430672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430662/index.html">Surveillance des serveurs Windows sur MS SQL pur et comment je l'ai impl√©ment√© secr√®tement</a></li>
<li><a href="../fr430664/index.html">Le r√¥le du chef d'√©quipe dans le recrutement</a></li>
<li><a href="../fr430666/index.html">Comment √©valuer les performances d'une √©quipe</a></li>
<li><a href="../fr430668/index.html">Seul sur le terrain n'est pas un guerrier. La voie vers un travail d'√©quipe efficace</a></li>
<li><a href="../fr430670/index.html">Gestion des arrangements</a></li>
<li><a href="../fr430674/index.html">La logique de construction d'horaires de travail universels</a></li>
<li><a href="../fr430676/index.html">Antiquit√©s: shshshsh, sssssss, VOIP, BBS et autres amis du modem</a></li>
<li><a href="../fr430678/index.html">Test de dix gradateurs avec lampes LED</a></li>
<li><a href="../fr430680/index.html">√âcrire un processeur et un environnement simples pour cela</a></li>
<li><a href="../fr430682/index.html">Trois ans du projet de microsatellites lunaires: √©tapes de la croissance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>