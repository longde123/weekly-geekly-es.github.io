<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ•Ô∏è „ÄΩÔ∏è üå•Ô∏è Drei Arten von Speicherlecks üçª üòõ ‚è≤Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Kollegen. 

 Unsere lange Suche nach zeitlos meistverkauften B√ºchern zur Codeoptimierung hat nur zu ersten Ergebnissen gef√ºhrt. Wir sind jedoch ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Drei Arten von Speicherlecks</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/432072/"> Hallo Kollegen. <br><br>  Unsere lange Suche nach zeitlos meistverkauften B√ºchern zur Codeoptimierung hat nur zu ersten Ergebnissen gef√ºhrt. Wir sind jedoch bereit, Ihnen zu gefallen, dass die √úbersetzung von Ben Watsons legend√§rem Buch " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Writing High Performance .NET Code</a> " buchst√§blich gerade abgeschlossen wurde.  In den L√§den - vorl√§ufig im April, achten Sie auf Werbung. <br><br>  Und heute bieten wir Ihnen an, einen rein praktischen Artikel √ºber die dringendsten Arten von Speicherlecks zu lesen, der von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nelson Ilheidzhe</a> (Strike) geschrieben wurde. <br><a name="habracut"></a><br>  Sie haben also ein Programm, dessen Fertigstellung umso l√§nger dauert, je l√§nger es dauert.  Wahrscheinlich wird es f√ºr Sie nicht schwer zu verstehen sein, dass dies ein sicheres Zeichen f√ºr einen Speicherverlust ist. <br>  Was genau meinen wir jedoch mit ‚ÄûSpeicherverlust‚Äú?  Nach meiner Erfahrung werden explizite Speicherverluste in drei Hauptkategorien unterteilt, von denen jede durch ein spezielles Verhalten gekennzeichnet ist. Zum Debuggen jeder Kategorie werden spezielle Tools und Techniken ben√∂tigt.  In diesem Artikel m√∂chte ich alle drei Klassen beschreiben und vorschlagen, wie man mit richtig erkennt <br>  mit welcher Klasse Sie es zu tun haben und wie Sie ein Leck finden. <br><br>  Typ (1): Nicht erreichbares Speicherfragment zugewiesen <br><br>  Dies ist ein klassischer Speicherverlust in C / C ++.  Jemand hat Speicher mit <code>new</code> oder <code>malloc</code> zugewiesen und nicht <code>free</code> oder <code>delete</code> aufgerufen, <code>free</code> Speicher <code>malloc</code> , nachdem die Arbeit damit beendet wurde. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">leak_memory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *leaked = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">4096</span></span>); use_a_buffer(leaked); <span class="hljs-comment"><span class="hljs-comment">/* ,   free() */</span></span> }</code> </pre> <br>  <i>So stellen Sie fest, ob ein Leck zu dieser Kategorie geh√∂rt</i> <br><br><ul><li>  Wenn Sie in C oder C ++ schreiben, insbesondere in C ++, ohne dass h√§ufig intelligente Zeiger zur Steuerung der Lebensdauer von Speichersegmenten verwendet werden, ist dies die Option, die wir zuerst in Betracht ziehen. </li><li>  Wenn das Programm in einer Umgebung mit Garbage Collection ausgef√ºhrt wird, ist es m√∂glich, dass ein Leck dieses Typs durch eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">native Code-Erweiterung hervorgerufen</a> wird. Leckagen der Typen (2) und (3) m√ºssen jedoch zuerst beseitigt werden. </li></ul><br>  <i>Wie man ein solches Leck findet</i> <br><br><ul><li>  Verwenden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ASAN</a> .  Verwenden Sie ASAN.  Verwenden Sie ASAN. </li><li>  Verwenden Sie einen anderen Detektor.  Ich habe Valgrind- oder tcmalloc-Tools f√ºr die Arbeit mit einer Reihe von Tools ausprobiert. Es gibt auch andere Tools in anderen Umgebungen. </li><li>  Einige Speicherzuordnungen erm√∂glichen das Speichern des Heap-Profils, in dem alle nicht zugewiesenen Speicherbereiche angezeigt werden.  Wenn Sie ein Leck haben, flie√üen nach einiger Zeit fast alle aktiven Entladungen daraus, sodass es wahrscheinlich nicht schwierig ist, es zu finden. </li><li>  Wenn alles andere fehlschl√§gt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sichern Sie einen Speicherauszug und √ºberpr√ºfen Sie ihn so sorgf√§ltig wie m√∂glich</a> .  Aber sollte auf keinen Fall damit beginnen. </li></ul><br>  <b>Typ (2): ungeplante langlebige Speicherzuordnungen</b> <br><br>  Solche Situationen sind keine ‚ÄûLecks‚Äú im klassischen Sinne des Wortes, da eine Verbindung von irgendwo zu diesem Speicherst√ºck immer noch erhalten bleibt, sodass sie am Ende freigegeben werden kann (wenn das Programm es schafft, dorthin zu gelangen, ohne den gesamten Speicher zu verbrauchen). <br>  Situationen in dieser Kategorie k√∂nnen aus vielen spezifischen Gr√ºnden auftreten.  Die h√§ufigsten sind: <br><br><ul><li>  Unbeabsichtigte Anh√§ufung von Staat in einer globalen Struktur;  Beispielsweise schreibt der HTTP-Server jedes empfangene <code>Request</code> in die globale Liste. </li><li>  Caches ohne durchdachte Veralterungspolitik.  Beispiel: Ein ORM-Cache, der jedes einzelne geladene Objekt zwischenspeichert, das w√§hrend der Migration aktiv ist und in dem alle in der Tabelle vorhandenen Datens√§tze ausnahmslos geladen werden. </li><li>  Ein zu volumin√∂ser Zustand wird in der Schaltung erfasst.  Dieser Fall tritt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">besonders h√§ufig</a> in Java Script auf, kann aber auch in anderen Umgebungen auftreten. </li><li>  Im weiteren Sinne die unbeabsichtigte Beibehaltung jedes Elements eines Arrays oder Streams, w√§hrend angenommen wurde, dass diese Elemente beim Online-Streaming verarbeitet werden. </li></ul><br>  <i>So stellen Sie fest, ob ein Leck zu dieser Kategorie geh√∂rt</i> <br><br><ul><li>  Wenn das Programm in einer Umgebung mit Garbage Collection ausgef√ºhrt wird, ist dies die Option, die wir zuerst in Betracht ziehen. </li><li>  Vergleichen Sie die in der Garbage Collector-Statistik angezeigte Heap-Gr√∂√üe mit der Gr√∂√üe des vom Betriebssystem generierten freien Speichers.  Wenn ein Leck in diese Kategorie f√§llt, sind die Zahlen vergleichbar und folgen vor allem im Laufe der Zeit aufeinander. </li></ul><br>  <i>Wie man ein solches Leck findet</i> <br><br>  Verwenden Sie die in Ihrer Umgebung verf√ºgbaren Profiler oder Heap-Dump-Tools.  Ich wei√ü, dass es in Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Guppy</a> oder in Ruby <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">memory_profiler gibt</a> , und ich habe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ObjectSpace auch</a> direkt in Ruby geschrieben. <br><br>  <b>Typ (3): freier, aber nicht verwendeter oder unbrauchbarer Speicher</b> <br><br>  Diese Kategorie ist am schwierigsten zu charakterisieren, aber es ist genau am wichtigsten, sie zu verstehen und zu ber√ºcksichtigen. <br><br>  Leckagen dieses Typs treten in der Grauzone zwischen dem Speicher, der aus Sicht des Allokators in der VM oder der Laufzeitumgebung als "frei" betrachtet wird, und dem Speicher auf, der aus Sicht des Betriebssystems "frei" ist.  Der h√§ufigste (aber nicht der einzige) Grund f√ºr dieses Ph√§nomen ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Haufenfragmentierung</a> .  Einige Allokatoren nehmen einfach Speicher und geben ihn nicht an das Betriebssystem zur√ºck, nachdem er zugewiesen wurde. <br><br>  Ein Fall dieser Art kann anhand eines Beispiels eines in Python geschriebenen Kurzprogramms betrachtet werden: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> guppy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> hpy hp = hpy() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rss</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4096</span></span> * int(open(<span class="hljs-string"><span class="hljs-string">'/proc/self/stat'</span></span>).read().split(<span class="hljs-string"><span class="hljs-string">' '</span></span>)[<span class="hljs-number"><span class="hljs-number">23</span></span>]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcsize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hp.heap().size rss0, gc0 = (rss(), gcsize()) buf = [bytearray(<span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>*<span class="hljs-number"><span class="hljs-number">1024</span></span>)] print(<span class="hljs-string"><span class="hljs-string">"start rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0)) buf = buf[::<span class="hljs-number"><span class="hljs-number">2</span></span>] print(<span class="hljs-string"><span class="hljs-string">"end rss={} gcsize={}"</span></span>.format(rss()-rss0, gcsize()-gc0))</code> </pre> <br>  Wir weisen 200.000 1-kb-Puffer zu und speichern dann jeden weiteren.  Jede Sekunde zeigen wir den Speicherstatus aus Sicht des Betriebssystems und aus Sicht unseres eigenen Python-Garbage-Collectors an. <br><br>  Auf meinem Laptop bekomme ich so etwas: <br><br> <code>start rss=232222720 gcsize=11667592 <br> end rss=232222720 gcsize=5769520</code> <br> <br>  Wir k√∂nnen sicherstellen, dass Python tats√§chlich die H√§lfte der Puffer freigegeben hat, da der gcsize-Pegel fast um die H√§lfte vom Spitzenwert abfiel, aber kein Byte dieses Speichers an das Betriebssystem zur√ºckgeben konnte.  Der freigegebene Speicher bleibt f√ºr denselben Python-Prozess zug√§nglich, jedoch nicht f√ºr andere Prozesse auf diesem Computer. <br><br>  Solche freien, aber nicht verwendeten Erinnerungsfragmente k√∂nnen sowohl problematisch als auch harmlos sein.  Wenn ein Python-Programm so handelt und dann eine Handvoll 1-KB-Fragmente zuweist, wird dieser Speicherplatz einfach wiederverwendet, und alles ist in Ordnung. <br><br>  Wenn wir dies jedoch w√§hrend der Ersteinrichtung tun und anschlie√üend den Speicher auf ein Minimum beschr√§nken oder wenn alle anschlie√üend zugewiesenen Fragmente jeweils 1,5 KB gro√ü sind und nicht in diese im Voraus verbleibenden Puffer passen, bleibt der gesamte auf diese Weise zugewiesene Speicher immer inaktiv w√§re verschwendet. <br><br>  Probleme dieser Art sind besonders relevant in einer bestimmten Umgebung, n√§mlich in Multiprozess-Serversystemen f√ºr die Arbeit mit Sprachen wie Ruby oder Python. <br><br>  Nehmen wir an, wir richten ein System ein, in dem: <br><br><ul><li>  Auf jedem Server werden N Single-Threaded-Worker verwendet, um Anforderungen kompetent zu bearbeiten.  Nehmen wir zur Genauigkeit N = 10. </li><li>  In der Regel verf√ºgt jeder Mitarbeiter √ºber eine nahezu konstante Speicherkapazit√§t.  Nehmen wir f√ºr die Genauigkeit 500 MB. </li><li>  Mit einer geringen H√§ufigkeit erhalten wir Anforderungen, die viel mehr Speicher ben√∂tigen als die mittlere Anforderung.  Nehmen wir aus Gr√ºnden der Genauigkeit an, dass wir einmal pro Minute eine Anforderung erhalten, deren Ausf√ºhrungszeit zus√§tzlich 1 GB zus√§tzlichen Speicher erfordert. Wenn die Anforderung verarbeitet wird, wird dieser Speicher freigegeben. </li></ul><br>  Einmal pro Minute kommt eine solche "Cetacean" -Anforderung an, deren Verarbeitung wir einem der 10 Arbeiter anvertrauen, zum Beispiel zuf√§llig: <code>~random</code> .  Idealerweise sollte dieser Mitarbeiter w√§hrend der Verarbeitung dieser Anforderung 1 GB RAM zuweisen und diesen Speicher nach Beendigung der Arbeit an das Betriebssystem zur√ºckgeben, damit er sp√§ter wiederverwendet werden kann.  Um Anfragen nach diesem Prinzip unbegrenzt zu verarbeiten, ben√∂tigt der Server nur 10 * 500 MB + 1 GB = 6 GB RAM. <br><br>  Nehmen wir jedoch an, dass die virtuelle Maschine aufgrund von Fragmentierung oder aus einem anderen Grund diesen Speicher niemals an das Betriebssystem zur√ºckgeben kann.  Das hei√üt, die vom Betriebssystem ben√∂tigte RAM-Gr√∂√üe entspricht der gr√∂√üten Speichermenge, die Sie jemals gleichzeitig zuweisen m√ºssen.  In diesem Fall schwillt der Bereich, der von einem solchen Prozess im Speicher belegt wird, f√ºr immer um ein ganzes Gigabyte an, wenn ein bestimmter Mitarbeiter eine solche ressourcenintensive Anforderung bearbeitet. <br><br>  Wenn Sie den Server starten, sehen Sie, dass 10 * 500 MB = 5 GB verwendet werden.  Sobald die erste gro√üe Anfrage eintrifft, belegt der erste Mitarbeiter 1 GB Speicher und gibt ihn nicht zur√ºck.  Die Gesamtspeichermenge springt auf 6 GB.  Die folgenden eingehenden Anforderungen werden gelegentlich an den Prozess weitergeleitet, der zuvor den ‚ÄûWal‚Äú verarbeitet hat. In diesem Fall √§ndert sich die verwendete Speichermenge nicht.  Aber manchmal wird eine so gro√üe Anfrage an einen anderen Mitarbeiter gesendet, wodurch der Speicher um weitere 1 GB aufgeblasen wird, und so weiter, bis jeder Mitarbeiter eine so gro√üe Anfrage mindestens einmal bearbeiten kann.  In diesem Fall ben√∂tigen Sie mit diesen Vorg√§ngen bis zu 10 * (500 MB + 1 GB) = 15 GB RAM, was viel mehr als die idealen 6 GB ist!  Wenn Sie sich au√üerdem ansehen, wie die Serverflotte im Laufe der Zeit verwendet wird, k√∂nnen Sie sehen, wie die Menge des verwendeten Speichers allm√§hlich von 5 GB auf 15 GB ansteigt, was sehr an ein "echtes" Leck erinnert. <br><br>  <i>So stellen Sie fest, ob ein Leck zu dieser Kategorie geh√∂rt</i> <br><br><ul><li>  Vergleichen Sie die in der Garbage Collector-Statistik angezeigte Heap-Gr√∂√üe mit der Gr√∂√üe des vom Betriebssystem generierten freien Speichers.  Wenn das Leck zu dieser (dritten) Kategorie geh√∂rt, weichen die Zahlen mit der Zeit voneinander ab. </li><li>  Ich m√∂chte meine Anwendungsserver so konfigurieren, dass diese beiden Zahlen in meiner Zeitreiheninfrastruktur regelm√§√üig abwehren, sodass es bequem ist, Diagramme darauf anzuzeigen. </li><li>  Zeigen Sie unter Linux den Betriebssystemstatus in Feld 24 von <code>/proc/self/stat</code> an und zeigen Sie den Speicherzuweiser √ºber eine sprach- oder virtuelle Maschinenspezifische API an. </li></ul><br>  <i>Wie man ein solches Leck findet</i> <br><br>  Wie bereits erw√§hnt, ist diese Kategorie etwas heimt√ºckischer als die vorherigen, da das Problem h√§ufig auftritt, selbst wenn alle Komponenten ‚Äûwie beabsichtigt‚Äú funktionieren.  Es gibt jedoch eine Reihe n√ºtzlicher Tricks, mit denen die Auswirkungen solcher ‚Äûvirtuellen Lecks‚Äú gemindert oder verringert werden k√∂nnen: <br><br><ul><li>  Starten Sie Ihre Prozesse h√§ufiger neu.  Wenn das Problem langsam auftritt, ist es m√∂glicherweise nicht schwierig, alle Anwendungsprozesse alle 15 Minuten oder einmal pro Stunde neu zu starten. </li><li>  Noch radikaler: Sie k√∂nnen allen Prozessen beibringen, unabh√§ngig voneinander neu zu starten, sobald der Speicherplatz im Speicher einen bestimmten Schwellenwert √ºberschreitet oder um einen vorgegebenen Wert w√§chst.  Versuchen Sie jedoch vorauszusehen, dass Ihre gesamte Serverflotte keinen spontanen synchronen Neustart starten kann. </li><li>  √Ñndern Sie die Speicherzuordnung.  Auf lange Sicht handhaben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tcmalloc</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">jemalloc</a> die Fragmentierung normalerweise viel besser als der Standardzuweiser, und das Experimentieren mit ihnen ist mit der Variablen <code>LD_PRELOAD</code> sehr praktisch. </li><li>  Finden Sie heraus, ob Sie einzelne Abfragen haben, die viel mehr Speicher belegen als die anderen.  Bei Stripe messen unsere API-Server RSS (konstanter Speicherverbrauch) vor und nach der Bearbeitung jeder API-Anforderung und protokollieren das Delta.  Anschlie√üend fragen wir unsere Protokollaggregationssysteme einfach ab, um festzustellen, ob es solche Terminals und Benutzer (und Muster) gibt, mit denen Bursts des Speicherverbrauchs abgeschrieben werden k√∂nnen. </li><li>  Passen Sie den Garbage Collector / Memory Allokator an.  Viele von ihnen verf√ºgen √ºber anpassbare Parameter, mit denen Sie festlegen k√∂nnen, wie aktiv ein solcher Mechanismus Speicher an das Betriebssystem zur√ºckgibt und wie optimiert er ist, um Fragmentierung zu beseitigen.  Es gibt andere n√ºtzliche Optionen.  Alles hier ist auch ziemlich kompliziert: Stellen Sie sicher, dass Sie genau verstehen, was Sie messen und optimieren, und versuchen Sie auch, einen Experten f√ºr die entsprechende virtuelle Maschine zu finden und ihn zu konsultieren. </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432072/">https://habr.com/ru/post/de432072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432060/index.html">Die besten M√∂glichkeiten, sich englische W√∂rter zu merken</a></li>
<li><a href="../de432062/index.html">KI-Entwicklung am Beispiel des Dicey Dungeons-Spiels</a></li>
<li><a href="../de432064/index.html">Wie man den "Hasen" entkommt. UV-Anweisung</a></li>
<li><a href="../de432068/index.html">So erleichtern Sie das Englischlernen: 5 n√ºtzliche Dienste</a></li>
<li><a href="../de432070/index.html">Kurz √ºber Redux-Saga-Kan√§le</a></li>
<li><a href="../de432074/index.html">Wie Spieler Spelunky Reality-Stoff mit Schrotflinten zerrei√üen</a></li>
<li><a href="../de432076/index.html">Eine nicht erkannte Funktion verlangsamt das Programm f√ºnfmal</a></li>
<li><a href="../de432078/index.html">Verkehr am Ende des Tunnels oder DNS im Pentest</a></li>
<li><a href="../de432080/index.html">Missverst√§ndnisse der Spieler bei der Bewertung von Risiken. Steuerung des Zufallszahlengenerators in Entwicklung</a></li>
<li><a href="../de432082/index.html">Microsoft AI Chatbot startet China Clothing Collection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>