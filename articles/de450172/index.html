<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∑Ô∏è üçç ü§ôüèæ IOS Timer ü§Æ ü•´ üç©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stellen Sie sich vor, Sie arbeiten an einer Anwendung, in der Sie regelm√§√üig einige Aktionen ausf√ºhren m√ºssen. Genau daf√ºr verwendet Swift die Timer- ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>IOS Timer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450172/"> Stellen Sie sich vor, Sie arbeiten an einer Anwendung, in der Sie regelm√§√üig einige Aktionen ausf√ºhren m√ºssen.  Genau daf√ºr verwendet Swift die <b>Timer-</b> Klasse. <br><br>  Der Timer wird verwendet, um Aktionen in der Anwendung zu planen.  Dies kann eine einmalige Aktion oder ein sich wiederholender Vorgang sein. <br><br>  In diesem Handbuch erfahren Sie, wie der Timer in iOS funktioniert, wie er die Reaktionsf√§higkeit der Benutzeroberfl√§che beeinflusst, wie der Batterieverbrauch bei Verwendung eines Timers optimiert wird und wie <b>CADisplayLink</b> f√ºr Animationen verwendet wird. <br><br>  Als Teststandort verwenden wir die Anwendung - einen primitiven Taskplaner. <br><a name="habracut"></a><br><h2>  Erste Schritte </h2><br>  Laden Sie das <a href="">Quellprojekt</a> herunter <a href="">.</a>  √ñffnen Sie es in Xcode, sehen Sie sich seine Struktur an, kompilieren Sie es und f√ºhren Sie es aus.  Sie sehen den einfachsten Taskplaner: <br><br><img src="https://habrastorage.org/webt/9v/iw/xg/9viwxg_qjy7oyvwfsss09ec813c.png"><br><br>  F√ºgen Sie eine neue Aufgabe hinzu.  Tippen Sie auf das Symbol +, geben Sie den Namen der Aufgabe ein und tippen Sie auf OK. <br><br>  Hinzugef√ºgte Aufgaben haben einen Zeitstempel.  Die neue Aufgabe, die Sie gerade erstellt haben, wird mit null Sekunden markiert.  Wie Sie sehen k√∂nnen, steigt dieser Wert nicht an. <br><br>  Jede Aufgabe kann als erledigt markiert werden.  Tippen Sie auf die Aufgabe.  Der Aufgabenname wird durchgestrichen und als erledigt markiert. <br><br><h2>  Erstellen Sie unseren ersten Timer </h2><br>  Lassen Sie uns den Haupttimer unserer Anwendung erstellen.  Die <b>Timer-</b> Klasse, auch als <b>NSTimer bekannt,</b> ist eine bequeme M√∂glichkeit, eine Aktion f√ºr einen bestimmten Moment zu planen, sowohl einzeln als auch periodisch. <br><br>  √ñffnen Sie <b>TaskListViewController.swift</b> und f√ºgen Sie diese Variable zu <b>TaskListViewController hinzu</b> : <br><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span></code> </pre> <br>  F√ºgen Sie dort die Erweiterung hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// MARK: - Timer extension TaskListViewController { }</span></span></code> </pre> <br>  Und f√ºgen Sie diesen Code in die Erweiterung ein: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@objc</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 guard let visibleRowsIndexPaths = tableView.indexPathsForVisibleRows else { return } for indexPath in visibleRowsIndexPaths { // 2 if let cell = tableView.cellForRow(at: indexPath) as? TaskTableViewCell { cell.updateTime() } } }</span></span></code> </pre> <br>  Bei dieser Methode haben wir: <br><br><ol><li>  √úberpr√ºfen Sie, ob die Aufgabentabelle sichtbare Zeilen enth√§lt. </li><li>  Rufen Sie <b>updateTime</b> f√ºr jede sichtbare Zelle auf.  Diese Methode aktualisiert den Zeitstempel in der Zelle (siehe <b>TaskTableViewCell.swift</b> ). </li></ol><br>  F√ºgen Sie dann diesen Code zur Erweiterung hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 if timer == nil { // 2 timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(updateTimer), userInfo: nil, repeats: true) } }</span></span></code> </pre> <br>  Hier sind wir: <br><br><ol><li>  √úberpr√ºfen Sie, ob der Timer eine Instanz der <b>Timer-</b> Klasse enth√§lt. </li><li>  Wenn nicht, erstellen Sie einen Timer, der <b>updateTimer ()</b> jede Sekunde aufruft. </li></ol><br>  Dann m√ºssen wir einen Timer erstellen, sobald der Benutzer die erste Aufgabe hinzuf√ºgt.  F√ºgen Sie <b>createTimer () ganz</b> am Anfang der Methode <b>presentAlertController (_ :) hinzu</b> . <br><br>  Starten Sie die Anwendung und erstellen Sie einige neue Aufgaben.  Sie werden sehen, dass sich der Zeitstempel f√ºr jede Aufgabe jede Sekunde √§ndert. <br><br><img src="https://habrastorage.org/webt/nw/ze/nn/nwzenn61635ppptgcdsule6ywsk.gif" width="281" height="500"><br><br><h2>  Timer-Toleranz hinzuf√ºgen </h2><br>  Das Erh√∂hen der Anzahl der Timer f√ºhrt zu einer schlechteren Reaktionsf√§higkeit der Benutzeroberfl√§che und einem h√∂heren Batterieverbrauch.  Jeder Timer versucht, genau zu dem ihm zugewiesenen Zeitpunkt auszuf√ºhren, da seine Toleranz standardm√§√üig Null ist. <br><br>  Das Hinzuf√ºgen einer Timertoleranz ist eine einfache M√∂glichkeit, den Energieverbrauch zu senken.  Auf diese Weise kann das System eine Timer-Aktion zwischen der zugewiesenen Zeit und der zugewiesenen Zeit <b>plus der Toleranzzeit</b> ausf√ºhren - jedoch niemals vor dem zugewiesenen Intervall. <br><br>  Bei Timern, die nur einmal ausgef√ºhrt werden, wird der Toleranzwert ignoriert. <br><br>  <b>F√ºgen Sie in der</b> Methode <b>createTimer ()</b> unmittelbar nach der <b>Timerzuweisung</b> die <b>folgende</b> Zeile hinzu: <br><br><pre> <code class="swift hljs">timer?.tolerance = <span class="hljs-number"><span class="hljs-number">0.1</span></span></code> </pre> <br>  Starten Sie die App.  In diesem speziellen Fall ist der Effekt nicht offensichtlich (wir haben nur einen Timer). In der realen Situation mehrerer Timer erhalten Ihre Benutzer jedoch eine reaktionsschnellere Benutzeroberfl√§che und die Anwendung ist energieeffizienter. <br><br><img src="https://habrastorage.org/webt/nw/ze/nn/nwzenn61635ppptgcdsule6ywsk.gif" width="281" height="500"><br><br><h2>  Timer im Hintergrund </h2><br>  Interessanterweise, was passiert mit Timern, wenn eine Anwendung in den Hintergrund tritt?  <b>F√ºgen</b> Sie dazu den Code ganz am Anfang der <b>updateTimer ()</b> -Methode hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> fireDateDescription = timer?.fireDate.description { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(fireDateDescription) }</code> </pre> <br>  Auf diese Weise k√∂nnen wir Timer-Ereignisse in der Konsole verfolgen. <br><br>  F√ºhren Sie die Anwendung aus und f√ºgen Sie die Aufgabe hinzu.  Dr√ºcken Sie nun die Home-Taste auf Ihrem Ger√§t und kehren Sie zu unserer Anwendung zur√ºck. <br><br>  In der Konsole sehen Sie ungef√§hr Folgendes: <br><br><img src="https://habrastorage.org/webt/qb/ry/dd/qbryddhdojzhiq5jp0eol00axf4.png"><br><br>  Wie Sie sehen k√∂nnen, h√§lt iOS alle laufenden Anwendungszeitgeber an, wenn die Anwendung in den Hintergrund tritt.  Wenn die Anwendung aktiv wird, setzt iOS die Timer fort. <br><br><h2>  Grundlegendes zu <b>Run Loops</b> </h2><br>  Eine Ausf√ºhrungsschleife ist eine Ereignisschleife, die die Arbeit plant und eingehende Ereignisse verarbeitet.  Der Zyklus h√§lt den Thread besch√§ftigt, w√§hrend er ausgef√ºhrt wird, und versetzt ihn in einen "Ruhezustand", wenn keine Arbeit daf√ºr vorhanden ist. <br><br>  Jedes Mal, wenn Sie die Anwendung starten, erstellt das System den Hauptthread der Anwendung. F√ºr jeden Thread wird eine automatisch erstellte Ausf√ºhrungsschleife erstellt. <br><br>  Aber warum sind Ihnen all diese Informationen jetzt wichtig?  Jetzt startet jeder Timer im Hauptthread und tritt der Ausf√ºhrungsschleife bei.  Sie wissen wahrscheinlich, dass der Hauptthread mit dem Rendern der Benutzeroberfl√§che, dem Verarbeiten von Ber√ºhrungen usw. besch√§ftigt ist.  Wenn der Haupt-Thread mit etwas besch√§ftigt ist, reagiert die Benutzeroberfl√§che Ihrer Anwendung m√∂glicherweise nicht mehr (h√§ngt). <br><br>  Haben Sie bemerkt, dass der Zeitstempel in der Zelle beim Ziehen der Tabellenansicht nicht aktualisiert wird? <br><br><img src="https://habrastorage.org/webt/og/jg/l6/ogjgl6z6livbu-shmvtszh3movq.gif" width="281" height="500"><br><br>  Sie k√∂nnen dieses Problem l√∂sen, indem Sie dem Laufzyklus mitteilen, dass Timer in einem anderen Modus gestartet werden sollen. <br><br><h2>  Grundlegendes zu Laufzyklusmodi </h2><br>  Der Ausf√ºhrungszyklusmodus besteht aus einer Reihe von Eingabequellen, z. B. Ber√ºhren des Bildschirms oder Klicken mit der Maus, die zur √úberwachung eingestellt werden k√∂nnen, und einer Reihe von "Beobachtern", die Benachrichtigungen erhalten. <br><br>  In iOS gibt es drei Laufzeitmodi: <br><br>  <b>Standard</b> : Eingabequellen, die keine NSConnectionObjects sind, werden verarbeitet. <br>  <b>h√§ufig</b> : Es wird eine Reihe von Eingabezyklen verarbeitet, f√ºr die Sie eine Reihe von Eingabequellen, Timern und "Beobachtern" definieren k√∂nnen. <br>  <b>Tracking</b> : Die Benutzeroberfl√§che der Anwendung wird verarbeitet. <br><br>  F√ºr unsere Anwendung ist der am besten geeignete Modus <b>√ºblich</b> .  Um es zu verwenden, ersetzen Sie den Inhalt der Methode <b>createTimer () durch</b> Folgendes: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> timer == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timer = <span class="hljs-type"><span class="hljs-type">Timer</span></span>(timeInterval: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, target: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector: #selector(updateTimer), userInfo: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, repeats: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-type"><span class="hljs-type">RunLoop</span></span>.current.add(timer, forMode: .common) timer.tolerance = <span class="hljs-number"><span class="hljs-number">0.1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.timer = timer }</code> </pre> <br>  Der Hauptunterschied zum vorherigen Code besteht darin, dass wir diesen Timer vor dem Zuweisen des Timers zum TaskListViewController im <b>allgemeinen</b> Modus zur Ausf√ºhrungsschleife hinzuf√ºgen. <br><br>  Kompilieren Sie die Anwendung und f√ºhren Sie sie aus. <br><br><img src="https://habrastorage.org/webt/ya/up/xy/yaupxyslxeqpej-7kwxadnlrtzk.gif" width="281" height="500"><br><br>  Jetzt werden die Zeitstempel der Zellen aktualisiert, auch wenn die Tabelle gescrollt wird. <br><br><h2>  F√ºgen Sie eine Animation hinzu, um alle Aufgaben zu erledigen </h2><br>  Jetzt f√ºgen wir dem Benutzer eine Gl√ºckwunschanimation hinzu, um alle Aufgaben zu erledigen - der Ball steigt vom unteren Bildschirmrand nach ganz oben. <br><br>  F√ºgen Sie diese Variablen am Anfang des TaskListViewController hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 var animationTimer: Timer? // 2 var startTime: TimeInterval?, endTime: TimeInterval? // 3 let animationDuration = 3.0 // 4 var height: CGFloat = 0</span></span></code> </pre> <br>  Der Zweck dieser Variablen ist: <br><br><ol><li>  Animation Timer Speicher. </li><li>  Speicherung der Zeit f√ºr den Beginn und das Ende der Animation. </li><li>  Animationsdauer. </li><li>  Animationsh√∂he. </li></ol><br>  F√ºgen Sie nun am Ende der Datei <b>TaskListViewController.swift</b> die folgende TaskListViewController- <b>Erweiterung</b> <b>hinzu</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// MARK: - Animation extension TaskListViewController { func showCongratulationAnimation() { // 1 height = UIScreen.main.bounds.height + balloon.frame.size.height // 2 balloon.center = CGPoint(x: UIScreen.main.bounds.width / 2, y: height + balloon.frame.size.height / 2) balloon.isHidden = false // 3 startTime = Date().timeIntervalSince1970 endTime = animationDuration + startTime! // 4 animationTimer = Timer.scheduledTimer(withTimeInterval: 1 / 60, repeats: true) { timer in // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Animation here } } }</span></span></code> </pre> <br>  Hier machen wir folgendes: <br><br><ul><li>  Berechnen Sie die H√∂he der Animation und ermitteln Sie die H√∂he des Ger√§tebildschirms </li><li>  Zentrieren Sie den Ball au√üerhalb des Bildschirms und stellen Sie seine Sichtbarkeit ein </li><li>  Weisen Sie die Start- und Endzeit der Animation zu </li><li>  Wir starten den Animations-Timer und aktualisieren die Animation 60 Mal pro Sekunde </li></ul><br>  Jetzt m√ºssen wir die eigentliche Logik f√ºr die Aktualisierung der Gl√ºckwunschanimation erstellen.  F√ºgen Sie diesen Code nach <b>showCongratulationAnimation () hinzu</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateAnimation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 guard let endTime = endTime, let startTime = startTime else { return } // 2 let now = Date().timeIntervalSince1970 // 3 if now &gt;= endTime { animationTimer?.invalidate() balloon.isHidden = true } // 4 let percentage = (now - startTime) * 100 / animationDuration let y = height - ((height + balloon.frame.height / 2) / 100 * CGFloat(percentage)) // 5 balloon.center = CGPoint(x: balloon.center.x + CGFloat.random(in: -0.5...0.5), y: y) }</span></span></code> </pre> <br>  Was machen wir: <br><br><ol><li>  √úberpr√ºfen Sie, ob endTime und startTime zugewiesen sind </li><li>  Aktuelle Zeit konstant speichern </li><li>  Wir stellen sicher, dass die letzte Zeit noch nicht gekommen ist.  Wenn es bereits angekommen ist, aktualisieren Sie den Timer und verstecken Sie unseren Ball </li><li>  Berechnen Sie die neue y-Koordinate des Balls </li><li>  Die horizontale Position des Balls wird relativ zur vorherigen Position berechnet </li></ol><br>  Ersetzen Sie nun <b>// TODO: Animation hier</b> in <b>showCongratulationAnimation () durch</b> diesen Code: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.updateAnimation()</code> </pre> <br>  Jetzt wird <b>updateAnimation ()</b> aufgerufen, wenn ein Timer-Ereignis auftritt. <br><br>  Hurra, wir haben gerade eine Animation erstellt.  Wenn die Anwendung gestartet wird, passiert jedoch nichts Neues ... <br><br><h2>  Animation anzeigen </h2><br>  Wie Sie wahrscheinlich vermutet haben, gibt es nichts, was unsere neue Animation ‚Äûstarten‚Äú k√∂nnte.  Dazu ben√∂tigen wir eine andere Methode.  F√ºgen Sie diesen Code der Animationserweiterung TaskListViewController hinzu: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCongratulationsIfNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> taskList.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>({ !$<span class="hljs-number"><span class="hljs-number">0</span></span>.completed }).<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { showCongratulationAnimation() } }</code> </pre> <br>  Wir werden diese Methode immer dann aufrufen, wenn der Benutzer die Aufgabe als erledigt markiert und pr√ºft, ob alle Aufgaben erledigt sind.  In diesem <b>Fall</b> wird <b>showCongratulationAnimation () aufgerufen</b> . <br><br>  <b>F√ºgen Sie</b> dieser Methode abschlie√üend am Ende von <b>tableView</b> einen Aufruf <b>hinzu (_: didSelectRowAt :)</b> : <br><br><pre> <code class="swift hljs">showCongratulationsIfNeeded()</code> </pre> <br>  Starten Sie die Anwendung, erstellen Sie einige Aufgaben, markieren Sie sie als erledigt - und Sie werden unsere Animation sehen! <br><br><img src="https://habrastorage.org/webt/zz/xs/2m/zzxs2mcciespvyjwaudma_rytyi.gif" width="281" height="500"><br><br><h2>  Wir stoppen den Timer </h2><br>  Wenn Sie sich die Konsole ansehen, werden Sie feststellen, dass der Timer weiterhin funktioniert, obwohl der Benutzer alle erledigten Aufgaben markiert hat.  Dies ist v√∂llig sinnlos, daher ist es sinnvoll, den Timer anzuhalten, wenn er nicht ben√∂tigt wird. <br><br>  Erstellen Sie zun√§chst eine neue Methode, um den Timer zu stoppen: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancelTimer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { timer?.invalidate() timer = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Dadurch wird der Timer aktualisiert und auf Null zur√ºckgesetzt, damit wir ihn sp√§ter wieder korrekt erstellen k√∂nnen.  <b>invalidate ()</b> ist die einzige M√∂glichkeit, Timer aus der Ausf√ºhrungsschleife zu entfernen.  Die Ausf√ºhrungsschleife entfernt die starke Timer-Referenz entweder unmittelbar nach dem Aufruf von <b>invalidate ()</b> oder etwas sp√§ter. <br><br>  Ersetzen Sie nun die Methode showCongratulationsIfNeeded () wie folgt: <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCongratulationsIfNeeded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> taskList.<span class="hljs-built_in"><span class="hljs-built_in">filter</span></span>({ !$<span class="hljs-number"><span class="hljs-number">0</span></span>.completed }).<span class="hljs-built_in"><span class="hljs-built_in">count</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> { cancelTimer() showCongratulationAnimation() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { createTimer() } }</code> </pre> <br>  Wenn der Benutzer nun alle Aufgaben erledigt hat, setzt die Anwendung zuerst den Timer zur√ºck und zeigt dann die Animation an. Andernfalls wird versucht, einen neuen Timer zu erstellen, falls dieser noch nicht vorhanden ist. <br><br>  Starten Sie die App. <br><br><img src="https://habrastorage.org/webt/62/l9/4-/62l94-n0gtjlg2sfpjoffjqvaom.gif" width="281" height="500"><br><br>  Jetzt stoppt der Timer und startet neu, wie es sollte. <br><br><h2>  CADisplayLink f√ºr reibungslose Animation </h2><br>  <b>Der Timer</b> ist keine ideale Wahl f√ºr die Steuerung von Animationen.  M√∂glicherweise haben Sie einige Frames bemerkt, die Animationen √ºberspringen, insbesondere wenn Sie die Anwendung im Simulator ausf√ºhren. <br><br>  Wir stellen den Timer auf 60Hz ein.  Somit aktualisiert der Timer die Animation alle 16 ms.  Betrachten Sie die Situation genauer: <br><br><img src="https://habrastorage.org/webt/ar/df/ec/ardfecmgf7bizt8ggcqa01jdbju.png"><br><br>  Bei Verwendung von <b>Timer</b> wissen wir nicht genau, wann die Aktion gestartet wurde.  Dies kann entweder am Anfang oder am Ende des Frames geschehen.  Angenommen, der Timer l√§uft in der Mitte jedes Frames (blaue Punkte im Bild).  Das einzige, was wir sicher wissen, ist, dass der Anruf alle 16 ms erfolgt. <br><br>  Jetzt haben wir nur noch 8 ms Zeit, um die Animation auszuf√ºhren, und dies reicht m√∂glicherweise nicht f√ºr unsere Animation aus.  Schauen wir uns den zweiten Frame in der Abbildung an.  Das zweite Bild kann nicht in der vorgegebenen Zeit fertiggestellt werden, daher setzt die Anwendung das zweite Bild der Animation zur√ºck. <br><br><h2>  CADisplayLink wird uns helfen </h2><br>  <b>CADisplayLink</b> wird einmal pro Frame aufgerufen und versucht, echte Animationsframes so weit wie m√∂glich zu synchronisieren.  Jetzt stehen Ihnen alle 16 ms zur Verf√ºgung und iOS l√§sst keinen einzigen Frame fallen. <br><br>  Um <b>CADisplayLink</b> verwenden zu <b>k√∂nnen</b> , m√ºssen Sie <b>animationTimer</b> durch einen neuen Typ ersetzen. <br><br>  Ersetzen Sie diesen Code <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> animationTimer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span></code> </pre> <br>  zu diesem: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> displayLink: <span class="hljs-type"><span class="hljs-type">CADisplayLink?</span></span></code> </pre> <br>  Sie haben <b>Timer</b> durch <b>CADisplayLink ersetzt</b> .  <b>CADisplayLink</b> ist eine Timer-Ansicht, die an den vertikalen Scan der Anzeige gebunden ist.  Dies bedeutet, dass die GPU des Ger√§ts angehalten wird, bis der Bildschirm weiterhin GPU-Befehle verarbeiten kann.  Auf diese Weise erhalten wir eine reibungslose Animation. <br><br>  Ersetzen Sie diesen Code <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startTime: <span class="hljs-type"><span class="hljs-type">TimeInterval?</span></span>, endTime: <span class="hljs-type"><span class="hljs-type">TimeInterval?</span></span></code> </pre> <br>  zu diesem: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startTime: <span class="hljs-type"><span class="hljs-type">CFTimeInterval?</span></span>, endTime: <span class="hljs-type"><span class="hljs-type">CFTimeInterval?</span></span></code> </pre> <br><br>  Sie haben <b>TimeInterval</b> durch <b>CFTimeInterval ersetzt</b> , was f√ºr die Arbeit mit CADisplayLink erforderlich ist. <br><br>  Ersetzen Sie den Text der <b>showCongratulationAnimation ()</b> -Methode durch <b>Folgendes</b> : <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showCongratulationAnimation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// 1 height = UIScreen.main.bounds.height + balloon.frame.size.height balloon.center = CGPoint(x: UIScreen.main.bounds.width / 2, y: height + balloon.frame.size.height / 2) balloon.isHidden = false // 2 startTime = CACurrentMediaTime() endTime = animationDuration + startTime! // 3 displayLink = CADisplayLink(target: self, selector: #selector(updateAnimation)) displayLink?.add(to: RunLoop.main, forMode: .common) }</span></span></code> </pre> <br>  Was machen wir hier: <br><br><ol><li>  Stellen Sie die H√∂he der Animation, die Koordinaten des Balls und die Sichtbarkeit ein - ungef√§hr so ‚Äã‚Äãwie zuvor. </li><li>  Initialisieren Sie <b>startTime</b> mit <b>CACurrentMediaTime ()</b> (anstelle von Date ()). </li><li>  Wir erstellen eine Instanz der <b>CADisplayLink-</b> Klasse und f√ºgen sie im <b>allgemeinen</b> Modus der Ausf√ºhrungsschleife hinzu. </li></ol><br>  Ersetzen <b>Sie</b> nun <b>updateAnimation () durch den</b> folgenden Code: <br><br><pre> <code class="swift hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 @objc func updateAnimation() { guard let endTime = endTime, let startTime = startTime else { return } // 2 let now = CACurrentMediaTime() if now &gt;= endTime { // 3 displayLink?.isPaused = true displayLink?.invalidate() balloon.isHidden = true } let percentage = (now - startTime) * 100 / animationDuration let y = height - ((height + balloon.frame.height / 2) / 100 * CGFloat(percentage)) balloon.center = CGPoint(x: balloon.center.x + CGFloat.random(in: -0.5...0.5), y: y) }</span></span></code> </pre> <br><ol><li>  F√ºgen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Sie</a> der Methodensignatur objc hinzu (f√ºr CADisplayLink erfordert der Selektorparameter eine solche Signatur). </li><li>  Ersetzen Sie die Initialisierung durch <b>Date ()</b> , um das Datum von <b>CoreAnimation</b> zu initialisieren. </li><li>  Ersetzen Sie den Aufruf von <b>animationTimer.invalidate ()</b> durch eine Pause von CADisplayLink und machen Sie ihn ung√ºltig.  Dadurch wird auch CADisplayLink aus der Ausf√ºhrungsschleife entfernt. </li></ol><br>  Starten Sie die App! <br><br><img src="https://habrastorage.org/webt/01/ct/jf/01ctjfswyhfhc6dogl8wavqv8-a.gif" width="281" height="500"><br>  Gro√üartig!  Wir haben die <b>Timer-</b> basierte Animation erfolgreich durch einen geeigneteren <b>CADisplayLink ersetzt</b> - und die Animation fl√ºssiger gemacht, ohne zu ruckeln. <br><br><h2>  Fazit </h2><br>  In diesem Handbuch haben Sie herausgefunden, wie die <b>Timer-</b> Klasse in iOS funktioniert, wie der Ausf√ºhrungszyklus <b>abl√§uft</b> und wie Ihre Anwendung in Bezug auf die Benutzeroberfl√§che <b>reaktionsf√§higer</b> wird und wie Sie <b>CADisplayLink</b> anstelle von Timer f√ºr eine reibungslose Animation verwenden. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450172/">https://habr.com/ru/post/de450172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450160/index.html">Windows 10 Version 1903 - mindestens 32 GB Speicherplatz</a></li>
<li><a href="../de450164/index.html">Wie kann man einem Team helfen, das bei der Arbeit ausbrennt, wenn Sie selbst ausgebrannt sind?</a></li>
<li><a href="../de450166/index.html">Wir laden Entwickler zum Think Developers Workshop ein</a></li>
<li><a href="../de450168/index.html">Internet-Geschichte: Backbone</a></li>
<li><a href="../de450170/index.html">AR, Robotik und Katarakt: Wie wir zur russisch-deutschen Programmierschule gingen</a></li>
<li><a href="../de450176/index.html">Zur Frage der Mengen</a></li>
<li><a href="../de450178/index.html">Qualit√§t als Verantwortung des Teams. Unsere QS-Erfahrung</a></li>
<li><a href="../de450180/index.html">6 n√ºtzliche Tools, um ein Startup in den USA zu starten</a></li>
<li><a href="../de450182/index.html">Cloud-basierte Abrechnungsmodellierung</a></li>
<li><a href="../de450186/index.html">Ein bisschen Kryptographie: das mysteri√∂se und legend√§re R√§tsel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>