<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😩 👩🏾‍🎤 👨🏼‍🔬 探索Python中类型注释的深度。 第二部分 🛸 👩🏽‍🎤 🆎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们将发布材料翻译的第二部分，该部分专门用于Python中的类型注释。 

  

 → 第一部分 

 Python如何支持数据类型？ 
 Python是一种动态类型化的语言。 这意味着仅在程序执行期间检查使用的变量类型。 在本文上半部分给出的示例中，可以看到用Python编写的程序员无需计...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>探索Python中类型注释的深度。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/463931/"> 今天，我们将发布材料翻译的第二部分，该部分专门用于Python中的类型注释。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/wr/lw/bq/wrlwbqu0zinltnd22qtfjqnhsb4.jpeg"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Python如何支持数据类型？</font> </h2><br>  Python是一种动态类型化的语言。 这意味着仅在程序执行期间检查使用的变量类型。 在本文上半部分给出的示例中，可以看到用Python编写的程序员无需计划变量的类型，也无需考虑需要多少内存来存储其数据。 <br><br> 当您准备要执行的Python代码时，将发生以下情况：“在Python中，使用CPython将源代码转换为一种更简单的形式，称为字节码。 字节码由本质上类似于处理器指令的指令组成。 但是它们不是由处理器执行的，而是由称为虚拟机的软件系统执行的。  （这不是关于虚拟机，其功能允许您在其上运行整个操作系统。在我们的情况下，这是一种环境，是处理器上运行的程序可用的环境的简化版本）。” <br><br>  CPython在准备要执行的程序时如何知道应该是什么变量类型？ 毕竟，我们没有指出这些类型。  CPython对此一无所知。 他只知道变量是对象。  Python中的所有东西都是一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象</a> ，至少直到发现某些东西具有更特定的类型为止。 <br><br> 例如，Python将用单引号或双引号引起来的所有内容都视为字符串。 如果Python遇到数字，则认为相应的值是数字类型。 如果我们尝试对某个实体进行某种类型的实体无法完成的工作，Python将在稍后通知我们。 <br><br> 考虑当您尝试添加字符串和数字时出现的以下错误消息： <br><br><pre><code class="python hljs">name = <span class="hljs-string"><span class="hljs-string">'Vicki'</span></span> seconds = <span class="hljs-number"><span class="hljs-number">4.71</span></span>; --------------------------------------------------------------------------- TypeError                 Traceback (most recent call last) &lt;ipython-input<span class="hljs-number"><span class="hljs-number">-9</span></span><span class="hljs-number"><span class="hljs-number">-71805</span></span>d305c0b&gt; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt;       <span class="hljs-number"><span class="hljs-number">3</span></span>       <span class="hljs-number"><span class="hljs-number">4</span></span> ----&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> name + seconds TypeError: must be str, <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> float</code> </pre> <br> 该系统告诉我们无法添加字符串和浮点数。 而且， <code>name</code>是字符串， <code>seconds</code>是数字，这一事实直到尝试添加<code>name</code>和<code>seconds</code>才使系统不感兴趣。 <br><br> 换句话说，可以描述<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">如下</a> ：“执行加法时使用鸭子类型。  Python对特定对象具有哪种类型不感兴趣。 系统感兴趣的只是它是否返回对加法的有意义的调用。 如果不是这样，则会发出错误。 <br><br> 那是什么意思？ 这意味着，如果我们使用Python编写程序，则在CPython解释器执行错误所在的同一行之前，我们不会收到错误消息。 <br><br> 这种方法在大型项目团队中使用时很不方便。 事实是，在此类项目中，它们不是使用单独的变量，而是使用复杂的数据结构。 在此类项目中，某些功能被其他功能调用，而这些功能又被其他功能调用。 团队成员应该能够快速检查其项目的代码。 如果他们无法编写好的测试来检测项目中的错误，然后再投入生产，则意味着此类项目可能会遇到很大的问题。 <br><br> 严格来说，我们来谈谈Python中的类型注释。 <br><br> 可以说，一般而言，使用类型注释具有许多<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优点</a> 。 如果您使用需要很多输入值的复杂数据结构或函数，则使用批注可大大简化使用相似结构和函数的过程。 特别是-创建后的一段时间。 如果只有一个带有一个参数的函数（如此处给出的示例），那么使用这种函数在任何情况下都是非常简单的。 <br><br> 如果我们需要使用复杂的函数，而这些函数需要许多与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyTorch</a>文档中的输入值相似的输入值，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">怎么办</a> ： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args, model, device, train_loader, optimizer, epoch)</span></span></span><span class="hljs-function">:</span></span>    model.train()    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> batch_idx, (data, target) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(train_loader):        data, target = data.to(device), target.to(device)        optimizer.zero_grad()        output = model(data)        loss = F.nll_loss(output, target)        loss.backward()        optimizer.step()        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> batch_idx % args.log_interval == <span class="hljs-number"><span class="hljs-number">0</span></span>:            print(<span class="hljs-string"><span class="hljs-string">'Train Epoch: {} [{}/{} ({:.0f}%)]\tLoss: {:.6f}'</span></span>.format(                epoch, batch_idx * len(data), len(train_loader.dataset), <span class="hljs-number"><span class="hljs-number">100.</span></span> * batch_idx / len(train_loader), loss.item()))</code> </pre> <br> 什么是<code>model</code> ？ 当然，我们可以深入研究代码库并找出： <br><br><pre> <code class="python hljs">model = Net().to(device)</code> </pre> <br> 但是，如果您只需在函数签名中指定<code>model</code>类型并避免不必要的代码分析，那就太好了。 也许看起来像这样： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args, model </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(type Net)</span></span></span></span><span class="hljs-function"><span class="hljs-params">, device, train_loader, optimizer, epoch)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br> 那<code>device</code>呢？ 如果遍历代码，可以发现以下内容： <br><br><pre> <code class="python hljs">device = torch.device(<span class="hljs-string"><span class="hljs-string">"cuda"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> use_cuda <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"cpu"</span></span>)</code> </pre> <br> 现在我们面临着什么是<code>torch.device</code>的问题。 这是PyTorch的一种特殊类型。 可以在PyTorch文档的<a href="">相应部分</a>找到其描述。 <br><br> 如果我们可以在函数的参数列表中指定类型<code>device</code> ，那就太好了。 因此，我们为那些不得不分析此代码的人节省了大量时间。 <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">train</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args, model </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(type Net)</span></span></span></span><span class="hljs-function"><span class="hljs-params">, device </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(type torch.Device)</span></span></span></span><span class="hljs-function"><span class="hljs-params">, train_loader, optimizer, epoch)</span></span></span><span class="hljs-function">:</span></span></code> </pre> <br> 这些考虑可以持续很长时间。 <br><br> 结果，事实证明类型注释对于编写代码的人非常有用。 但是，它们也使阅读其他人代码的人受益。 阅读类型化的代码比代码要理解要处理的实体要容易得多。 类型注释提高了代码的可读性。 <br><br> 那么，在Python中做了什么使代码达到与以静态类型的语言区分的代码相同的可读性呢？ <br><br><h2>  <font color="#3AC1EF">Python中的类型注释</font> </h2><br> 现在，我们准备好认真讨论Python中的类型注释。 当阅读用Python 2编写的程序时，可能会看到程序员为他们的代码提供了提示，告诉代码的读者这些函数返回的变量或值的类型。 <br><br> 类似的代码最初看起来像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这样</a> ： <br><br><pre> <code class="python hljs">users = [] <span class="hljs-comment"><span class="hljs-comment"># type: List[UserID] examples = {} # type: Dict[str, Any]</span></span></code> </pre> <br> 类型注释曾经是简单的注释。 但是碰巧的是，Python开始逐渐转向一种更加统一的注释处理方式。 特别是，我们正在谈论致力于功能注释的文档<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEP 3107</a>的出现。 <br><br> 接下来， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PEP 484的</a>工作开始了。 该文档专门用于类型注释，是与mypy（DropBox项目）紧密联系而开发的，该项目旨在在运行脚本之前验证类型。 使用mypy，值得记住的是在脚本执行过程中未执行类型检查。 例如，如果您尝试制作某种这种类型不支持的类型，则在运行时可能会收到错误消息。 说-如果您尝试对词典进行切片或为字符串调用<code>.pop()</code>方法。 <br><br> 您可以从PEP 484中了解有关注释实现的详细信息：“尽管这些注释可在运行时通过常规<code>annotations</code>属性使用，但在运行时不会执行类型检查。 相反，该建议提供了单独的独立类型检查工具的存在，用户可以根据需要使用该工具检查其程序的源代码。 通常，类似的类型检查工具的工作原理非常强大。  “当然，尽管个别用户可以使用类似的工具在运行时检查类型，无论是用于实施按合同设计的方法还是用于实施JIT优化。但是应该指出，此类工具尚未达到足够的成熟度。” <br><br> 在实践中如何使用类型注释？ <br><br> 例如，它们的使用意味着可以促进各种IDE的工作。 因此， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PyCharm</a>基于类型信息提供代码完成和验证。  VS Code中提供了类似的功能。 <br><br> 类型注释之所以有用，还有另一个原因：它们可以保护开发人员免受愚蠢的错误的影响。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这是</a>这种保护的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一个</a>很好的例子。 <br><br> 假设我们将人物姓名添加到字典中： <br><br><pre> <code class="python hljs">names = {<span class="hljs-string"><span class="hljs-string">'Vicki'</span></span>: <span class="hljs-string"><span class="hljs-string">'Boykis'</span></span>,         <span class="hljs-string"><span class="hljs-string">'Kim'</span></span>: <span class="hljs-string"><span class="hljs-string">'Kardashian'</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dict, first_name, last_name)</span></span></span><span class="hljs-function">:</span></span>    dict[first_name] = last_name   append_name(names,<span class="hljs-string"><span class="hljs-string">'Kanye'</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br> 如果我们允许这样做，词典中将有许多格式错误的条目。 <br> 让我们解决这个问题： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dict names_new: Dict[str, str] = {<span class="hljs-string"><span class="hljs-string">'Vicki'</span></span>: <span class="hljs-string"><span class="hljs-string">'Boykis'</span></span>,                             <span class="hljs-string"><span class="hljs-string">'Kim'</span></span>: <span class="hljs-string"><span class="hljs-string">'Kardashian'</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dic: Dict[str, str] , first_name: str, last_name: str)</span></span></span><span class="hljs-function">:</span></span>    dic[first_name] = last_name append_name(names_new,<span class="hljs-string"><span class="hljs-string">'Kanye'</span></span>,<span class="hljs-number"><span class="hljs-number">9.7</span></span>) names_new</code> </pre> <br> 现在与mypy一起检查此代码，并获得以下信息： <br><br><pre> <code class="python hljs">(kanye) mbp-vboykis:types vboykis$ mypy kanye.py kanye.py:<span class="hljs-number"><span class="hljs-number">9</span></span>: error: Argument <span class="hljs-number"><span class="hljs-number">3</span></span> to <span class="hljs-string"><span class="hljs-string">"append_name"</span></span> has incompatible type <span class="hljs-string"><span class="hljs-string">"float"</span></span>; expected <span class="hljs-string"><span class="hljs-string">"str"</span></span></code> </pre> <br> 可以看出，mypy不允许您使用需要字符串的数字。 建议那些希望定期使用此类测试的人将mypy包括在其持续集成系统中进行代码测试的地方。 <br><br><h2>  <font color="#3AC1EF">在各种IDE中键入提示</font> </h2><br> 使用类型注释的最重要的好处之一是，它们允许Python程序员在可用于静态类型语言的各种IDE中使用相同的代码完成功能。 <br><br> 例如，假设您有一段类似于以下内容的代码。 这是包装在类中的先前示例中的几个函数。 <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typing <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Dict <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rainfallRate</span></span></span><span class="hljs-class">:</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, hours, inches)</span></span></span><span class="hljs-function">:</span></span>        self.hours= hours        self.inches = inches    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, inches:int, hours:int)</span></span></span><span class="hljs-function"> -&gt; float:</span></span>        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inches/hours rainfallRate.calculateRate() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">addNametoDict</span></span></span><span class="hljs-class">:</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, first_name, last_name)</span></span></span><span class="hljs-function">:</span></span>        self.first_name = first_name        self.last_name = last_name        self.dict = dict    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">append_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dict:Dict[str, str], first_name:str, last_name:str)</span></span></span><span class="hljs-function">:</span></span>        dict[first_name] = last_name addNametoDict.append_name()</code> </pre> <br> 令人高兴的是，我们主动在代码中添加了类型描述，当调用类方法时，我们可以观察程序中发生了什么： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/b42/ded/8ddb42ded904ffe516a90d990a7ff856.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/731/336/a7a/731336a7aa97c55b1e60930ada747ac0.png"></div><br>  <i><font color="#999999">IDE类型提示</font></i> <br><br><h2>  <font color="#3AC1EF">类型注释入门</font> </h2><br> 您可以在mypy的文档中找到有关开始键入代码库时的入门的良好建议： <br><br><ol><li> 从小处开始-确保使用mypy验证包含多个批注的某些文件。 </li><li> 编写脚本以运行mypy。 这将有助于获得一致的测试结果。 </li><li> 在CI管道中运行mypy以防止类型错误。 </li><li> 逐步注释项目中最常用的模块。 </li><li> 将类型注释添加到您正在修改的现有代码中； 为他们提供您编写的新代码。 </li><li> 使用MonkeyType或PyAnnotate自动注释旧代码。 </li></ol><br> 在开始注释自己的代码之前，对您进行一些处理将很有用。 <br><br> 首先，如果您使用字符串，整数，布尔值和其他基本Python类型的值以外的其他内容，则需要将<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">类型输入</a>模块导入代码中。 <br><br> 其次，该模块可以处理多种复杂类型。 其中包括<code>Dict</code> ， <code>Tuple</code> ， <code>List</code>和<code>Set</code> 。  <code>Dict[str, float]</code>形式的构造意味着您想使用一个字典，该字典的元素使用字符串作为键，并使用浮点数作为值。 也有称为<code>Optional</code>和<code>Union</code>类型。 <br><br> 第三，您需要熟悉类型注释的格式： <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> typing <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(variable: type)</span></span></span><span class="hljs-function"> -&gt; return_type:</span></span>  do_something</code> </pre> <br> 如果您想了解更多有关如何在项目中开始应用类型注释的信息，我想指出很多专门针对此的教程。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这</a>是其中之一。 我认为这是最好的。 掌握了它之后，您将了解代码注释及其验证。 <br><br><h2>  <font color="#3AC1EF">结果。</font>  <font color="#3AC1EF">在Python中使用类型注释是否值得？</font> </h2><br> 现在，让我们问问自己是否应该在Python中使用类型注释。 实际上，这取决于项目的功能。 这是Guido van Rossum在mypy文档中关于此内容的说法：“ mypy的目的不是要说服所有人编写静态类型的Python代码。 静态类型现在和将来都是完全可选的。  Mypy的目标是为Python程序员提供更多选择。 这是为了使Python成为大型项目中使用的其他静态类型语言的更具竞争力的替代方案。 这是为了提高程序员的生产力并提高软件的质量。” <br><br> 在小型项目和实验期间（例如，在Jupyter中进行的那些实验），配置mypy和计划某个程序所需的类型所需的时间并不能证明其合理性。 哪个项目应该算小？ 根据仔细的估计，它的数量可能不超过1000行。 <br><br> 类型注释在较大的项目中有意义。 在那里，它们尤其可以节省大量时间。 我们正在谈论的是由一群程序员开发的项目，关于程序包，关于代码，这些都用于版本控制系统和CI管道的开发中。 <br><br> 我相信，在未来几年中，类型注释将比现在更加普遍，更不用说它们很可能会变成常规的日常工具。 我相信，一个在其他人之前开始与他们合作的人不会损失任何东西。 <br><br>  <b>亲爱的读者们！</b> 您是否在Python项目中使用类型注释？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN463931/">https://habr.com/ru/post/zh-CN463931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN463921/index.html">（不是非常）iOS和Android通用代码库的隐藏成本</a></li>
<li><a href="../zh-CN463923/index.html">不再需要.container</a></li>
<li><a href="../zh-CN463925/index.html">Vivaldi：我们如何计算用户数量？</a></li>
<li><a href="../zh-CN463927/index.html">安全和审查制度：5种适用于Google Chrome的VPN和代理</a></li>
<li><a href="../zh-CN463929/index.html">探索Python中类型注释的深度。 第一部分</a></li>
<li><a href="../zh-CN463933/index.html">20行Python脚本，每天通过WhatsApp祝父母早安</a></li>
<li><a href="../zh-CN463937/index.html">我没什么好隐瞒的</a></li>
<li><a href="../zh-CN463939/index.html">SimbirSoft为保险公司发布了移动解决方案</a></li>
<li><a href="../zh-CN463943/index.html">黑色独角兽的不幸经历</a></li>
<li><a href="../zh-CN463951/index.html">c.tech：Cassandra聚会＃2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>