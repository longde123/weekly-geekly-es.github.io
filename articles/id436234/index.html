<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“‹ ğŸ ğŸ¤˜ğŸ¿ Parsers Aplikatif Haskell ğŸš½ ğŸ“’ ğŸ¤¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Motivasi 


 Ketika saya pertama kali mulai mempelajari Haskell, saya sangat terganggu dengan meluasnya penggunaan abstraksi kompleks daripada solusi ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parsers Aplikatif Haskell</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/436234/"><p><img src="https://habrastorage.org/webt/tq/9u/iw/tq9uiw8d_nbb1bbwrfdg1euyvci.png"></p><br><h1 id="motivaciya">  Motivasi </h1><br><p>  Ketika saya pertama kali mulai mempelajari Haskell, saya sangat terganggu dengan meluasnya penggunaan abstraksi kompleks daripada solusi spesifik apa pun.  Tampak bagi saya bahwa jauh lebih baik untuk selalu mengikuti prinsip KISS dan menulis sepeda menggunakan konstruksi bahasa dasar daripada memahami semua kelas jenis ini untuk menulis satu konstruksi yang seharusnya nyaman di suatu tempat. </p><br><p>  Saya tidak memiliki contoh yang baik di mana upaya yang dihabiskan untuk pengembangan "material" akan membuahkan hasil.  Bagi saya, salah satu contoh yang paling sukses adalah parser.  Sekarang saya sering berbicara tentang mereka ketika mereka bertanya kepada saya tentang tugas umum apa yang dapat Anda gunakan dengan indah dari Haskell. </p><br><p> Saya ingin menawarkan pemula juga dengan cara ini dan membuat basis kecil fungsi dari awal untuk implementasi parser yang nyaman, dan kemudian menggunakannya untuk menulis parser mereka sendiri, kode yang secara harfiah akan mengulangi tata bahasa yang digunakan untuk parsing. </p><br><p>  Saya harap ini membantu seseorang untuk mengatasi ketakutan akan abstraksi dan mengajari mereka cara menggunakannya secara <em>tepat</em> (ya, saya masih berpikir bahwa kadang-kadang lebih efisien untuk menulis sepeda). </p><a name="habracut"></a><br><p>  Saya tidak memiliki tujuan dan keinginan untuk membuat kursus Haskell dari awal dari sebuah artikel, jadi saya berasumsi bahwa pembaca sudah terbiasa dengan sintaksis dan secara mandiri mengembangkan program-program sederhana.  Untuk berjaga-jaga, saya akan secara singkat berbicara tentang kelas tipe sebelum beralih ke deskripsi implementasi. </p><br><p>  Bagi mereka yang belum pernah menulis ke Haskell, tetapi ingin memahami apa yang terjadi di sini, saya sarankan Anda melihat halaman yang sesuai pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Learn X dalam Y menit</a> .  Sebagai buku berbahasa Rusia yang sangat baik untuk pemula, saya menyarankan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Tentang Haskell sebagai Manusia" oleh</a> Denis Shevchenko. </p><br><p>  Saya akan mencoba menggunakan konstruksi bahasa yang paling sederhana yang bisa dipahami oleh pemula.  Di akhir artikel, tautan diberikan ke repositori sumber, di mana di beberapa bagian kode digunakan entri yang lebih nyaman dan lebih pendek, yang mungkin kurang jelas pada pandangan pertama. </p><br><p>  Dan ya, tuan-tuan Haskellists, banyak hal dijelaskan dengan sangat sederhana dan canggung, untuk kasus-kasus khusus, tidak terlalu abstrak, tanpa menggunakan istilah dari teori kategori dan kata-kata menakutkan lainnya.  Saya senang Anda mengenal mereka dan tentu saja mereka dengan mudah menguasainya.  Saya juga mengenal mereka, tetapi saya rasa tidak perlu membuang informasi sebanyak itu dalam konteks ini pada pembaca yang tidak siap. </p><br><h1 id="klassy-tipov">  Ketik kelas </h1><br><p>  Kelas tipe Haskell tidak ada hubungannya dengan kelas di C ++ dan bahasa berorientasi objek lainnya.  Jika kita menggambar analogi dengan OOP, maka kelas tipe lebih seperti kelebihan metode dan fungsi. </p><br><p> Kelas menentukan tindakan apa yang dapat dilakukan dengan objek dari tipe yang membentuk kelas.  Misalnya, semua angka dapat dibandingkan untuk kesetaraan, tetapi semuanya dapat dipesan kecuali untuk yang kompleks, dan secara umum, fungsi tidak dapat dibandingkan sama sekali.  Kelas jenis yang dapat dibandingkan disebut <code>Eq</code> , dipesan - <code>Ord</code> (jenis tidak harus numerik).  Apa yang dapat dicetak dengan menerjemahkan ke dalam string milik kelas <code>Show</code> , ia memiliki kelas <code>Read</code> "berlawanan", yang menentukan bagaimana mengkonversi string ke objek dari tipe yang diinginkan. </p><br><p>  Untuk sekumpulan kelas tipe standar (seperti <code>Eq</code> , <code>Show</code> , <code>Read</code> ...), Anda dapat meminta kompiler untuk mengimplementasikan fungsionalitas yang diinginkan dengan cara standar, menggunakan kata kunci <code>deriving</code> setelah menentukan jenisnya: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">yCoord</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Anda dapat mendefinisikan kelas tipe Anda sendiri: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint :: a -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span></code> </pre> <br><p>  Di sini <code>PrettyPrint</code> adalah nama kelas, <code>a</code> adalah variabel tipe.  Kata kunci <code>where</code> diikuti oleh daftar yang disebut metode kelas, yaitu  fungsi yang dapat diterapkan ke objek tipe dari kelas ini. </p><br><p>  Untuk menunjukkan kepemilikan tipe data ke kelas, konstruksi berikut digunakan: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrettyPrint</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pPrint (<span class="hljs-type"><span class="hljs-type">Point</span></span> xy) = <span class="hljs-string"><span class="hljs-string">"("</span></span> ++ show x ++ <span class="hljs-string"><span class="hljs-string">", "</span></span> ++ show y ++ <span class="hljs-string"><span class="hljs-string">")"</span></span></code> </pre> <br><p>  Bahasa ini memungkinkan Anda menentukan batasan pada kelas tipe yang harus dikaitkan dengan argumen fungsi: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">showVsPretty</span></span> :: (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> a) =&gt; a -&gt; (<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) showVsPretty x = (show x, pPrint x)</code> </pre> <br><p>  Untuk setiap panggilan fungsi, kompilator memeriksa apakah persyaratan jenis ini dipenuhi, dan jika terjadi kegagalan, menampilkan kesalahan (tentu saja, ini terjadi pada tahap kompilasi). </p><br><pre> <code class="haskell hljs">&gt;&gt;&gt; showVsPretty (<span class="hljs-type"><span class="hljs-type">Point</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>) (<span class="hljs-string"><span class="hljs-string">"Point {xCoord = 2.0, yCoord = 3.0}"</span></span>,<span class="hljs-string"><span class="hljs-string">"(2.0, 3.0)"</span></span>) &gt;&gt;&gt; showVsPretty <span class="hljs-string"><span class="hljs-string">"str"</span></span> error: <span class="hljs-type"><span class="hljs-type">No</span></span> <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> for (<span class="hljs-type"><span class="hljs-type">PrettyPrint</span></span> [<span class="hljs-type"><span class="hljs-type">Char</span></span>]) arising from a use <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> 'showVsPretty'</code> </pre> <br><h1 id="realizaciya">  Implementasi </h1><br><p>  Parser menerima string input yang harus diurai sesuai dengan aturan yang telah ditentukan dan mendapatkan nilai dari jenis yang kita butuhkan (misalnya, integer).  Dalam hal ini, jalur input mungkin tidak berakhir, dan sisanya akan berfungsi sebagai input untuk analisis lebih lanjut.  Selain itu, parser kami pada umumnya akan bersifat non-deterministik, mis.  akan mengembalikan beberapa kemungkinan hasil parsing sebagai daftar. </p><br><p>  Sebuah tupel dari dua elemen <code>(String, a)</code> cocok untuk menggambarkan satu hasil operasi parser, di mana <code>a</code> adalah variabel tipe yang dapat menunjukkan tipe pengguna apa pun. </p><br><p>  Karena parser mem-parsing string berdasarkan beberapa aturan, kami menggambarkannya sebagai fungsi yang mengambil string sebagai input dan mengembalikan daftar hasil: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unParser</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> -&gt; [(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)] }</span></span></code> </pre> <br><p>  Kami akan menganggap parsing berhasil jika daftar hasil terdiri dari satu elemen dan string input telah sepenuhnya diproses.  Kami menerapkan fungsi pembantu yang mencoba mengurai seluruh string secara unik: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parseString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a parseString s (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (ps) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> [(<span class="hljs-string"><span class="hljs-string">""</span></span>, val)] -&gt; <span class="hljs-type"><span class="hljs-type">Just</span></span> val _ -&gt; <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><h2 id="prosteyshie-parsery">  Parser sederhana </h2><br><p>  Kami menerapkan beberapa parser sederhana, yang kemudian akan berguna dalam membangun kombinasi yang lebih kompleks. </p><br><p>  Kita mulai dengan mem-parsing satu karakter yang harus memenuhi predikat.  Jika string input kosong, maka hasil pekerjaan adalah daftar kosong.  Jika tidak, kami memeriksa nilai predikat pada karakter pertama dari string.  Jika <code>True</code> dikembalikan, hasil parsing adalah karakter ini;  kembalikan dengan sisa string.  Jika tidak, penguraian juga gagal. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">predP</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> predP p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f <span class="hljs-string"><span class="hljs-string">""</span></span> = [] f (c : cs) | pc = [(cs, c)] | otherwise = []</code> </pre> <br><p>  Sekarang kita bisa menulis parser yang mengambil karakter tertentu di awal baris.  Untuk melakukan ini, gunakan <code>predP</code> baru saja ditulis dan berikan sebagai argumen fungsi yang membandingkan argumennya dengan karakter yang kita butuhkan: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">charP</span></span> :: <span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Char</span></span> charP char = predP (\c -&gt; c == char)</code> </pre> <br><p>  Kasus paling sederhana berikut: parser yang hanya menerima string tertentu secara keseluruhan.  <code>stringP</code> saja <code>stringP</code> .  Fungsi di dalam parser membandingkan garis input dengan yang diinginkan dan, jika garis-garisnya sama, mengembalikan daftar satu elemen: sepasang garis kosong (tidak ada yang tersisa di input) dan yang asli.  Jika tidak, penguraian gagal, dan daftar hasil kosong dikembalikan. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">stringP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> stringP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs' | s == s' = [(<span class="hljs-string"><span class="hljs-string">""</span></span>, s)] | otherwise = []</code> </pre> <br><p>  Cukup sering, Anda perlu melewati karakter yang memiliki properti tertentu ketika mereka pergi ke awal baris (misalnya, karakter spasi putih).  Selain itu, hasil analisis tidak penting bagi kami dan tidak akan berguna di masa depan.  Kami menulis fungsi lewati yang melewatkan karakter awal string sementara nilai sebenarnya dari predikat dipertahankan.  Sebagai hasil analisis, kami menggunakan tuple kosong. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skip</span></span> :: (<span class="hljs-type"><span class="hljs-type">Char</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skip p = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(dropWhile ps, ())])</code> </pre> <br><p>  Dua parser berikutnya sangat mirip satu sama lain.  Keduanya memeriksa awalan jalur input, hanya yang pertama jika berhasil mengembalikan awalan ini, dan yang kedua mengembalikan tuple kosong, mis.  memungkinkan Anda untuk melewati garis arbitrer di awal input.  Implementasi menggunakan fungsi <code>isPrefixOf</code> didefinisikan dalam modul <code>Data.List</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">prefixP</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> prefixP s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, s)] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> [] skipString :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> f input = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> s `isPrefixOf` input <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> [(drop (length s) input, ())] <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> []</code> </pre> <br><p>  Beberapa saat kemudian kami akan mempertimbangkan implementasi yang lebih sederhana dari fungsi yang terakhir dan menyingkirkan duplikasi kode. </p><br><h2 id="parser-kak-funktor">  Parser sebagai functor </h2><br><p>  Kami dapat membedakan seluruh kelas jenis wadah yang benar berikut ini: jika Anda tahu cara mengubah objek di dalam wadah, maka Anda dapat mengubah wadah itu sendiri.  Contoh paling sederhana adalah daftar sebagai wadah dan fungsi <code>map</code> , yang tersedia di hampir semua bahasa tingkat tinggi.  Memang, Anda dapat menelusuri semua elemen daftar tipe <code>[a]</code> , menerapkan fungsi <code>a -&gt; b</code> untuk masing-masing, dan mendapatkan daftar tipe <code>[b]</code> . </p><br><p>  Tipe kelas ini disebut <code>Functor</code> ; kelas ini memiliki satu metode <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  Misalkan kita sudah tahu bagaimana cara mem-parsing string ke objek tipe tertentu <code>a</code> , dan, di samping itu, kita tahu cara mengubah objek tipe <code>a</code> ke objek tipe <code>b</code> .  Apakah mungkin untuk mengatakan bahwa kemudian ada parser untuk objek bertipe <code>b</code> ? </p><br><p>  Jika dinyatakan dalam bentuk fungsi, maka akan memiliki jenis berikut: </p><br><pre> <code class="haskell hljs">(a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Tipe ini bertepatan dengan tipe fungsi <code>fmap</code> , jadi mari kita coba menjadikan parser sebagai functor.  Mari kita membuat parser nilai tipe <code>b</code> dari awal, yang akan memanggil parser pertama (kita sudah memilikinya), dan kemudian menerapkan fungsi ke hasil parsingnya. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Parser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b fmap f (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> p2 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p2 :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] p2 s = convert (p1 s) convert :: [(<span class="hljs-type"><span class="hljs-type">String</span></span>, a)] -&gt; [(<span class="hljs-type"><span class="hljs-type">String</span></span>, b)] convert results = map (\(s, val) -&gt; (s, f val)) results</code> </pre> <br><p>  Fungsi <code>fmap</code> memiliki sinonim infiks yang nyaman: <code>fmap fx == f &lt;$&gt; x</code> . </p><br><p>  Jika kita menggunakan fungsi sebagai argumen ke <code>fmap</code> yang hanya menggantikan argumen pertamanya dengan nilai baru, kita mendapatkan operasi lain yang bermanfaat yang sudah diterapkan untuk semua fungsi bahkan dalam dua salinan (mereka berbeda hanya dalam urutan argumen): </p><br><pre> <code class="plaintext hljs">(&lt;$) :: Functor f =&gt; a -&gt; fb -&gt; fa ($&gt;) :: Functor f =&gt; fa -&gt; b -&gt; fb</code> </pre> <br><p>  Ingat parser yang melewatkan garis tertentu ( <code>skipString</code> )?  Sekarang Anda dapat menerapkannya sebagai berikut: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">skipString</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> () skipString s = () &lt;$ prefixP s</code> </pre> <br><h2 id="kombinacii-parserov">  Kombinasi Parser </h2><br><p>  Di Haskell, semua fungsi dijalankan secara default dan sebagian dapat digunakan.  Ini berarti bahwa fungsi argumen <code>n</code> sebenarnya adalah fungsi dari satu argumen, mengembalikan fungsi argumen <code>n-1</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">cons</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons = (:) cons1 :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] cons1 = cons <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--  cons  </span></span></code> </pre> <br><p>  Kami menerapkan fungsi dari tiga argumen ke beberapa nilai di dalam parser menggunakan <code>fmap</code> .  Jenisnya adalah sebagai berikut: </p><br><pre> <code class="plaintext hljs">f :: c -&gt; a -&gt; b p :: Parser c (fmap fp) :: Parser (a -&gt; b)</code> </pre> <br><p>  Fungsi parser ternyata ?!  Tentu saja, sebuah situasi dimungkinkan ketika representasi fungsi benar-benar ada di baris input, tetapi saya ingin dapat menggunakan fungsi ini, atau lebih tepatnya menggabungkan <code>Parser (a -&gt; b)</code> dan <code>Parser a</code> parser untuk mendapatkan <code>Parser b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b</code> </pre> <br><p>  Jenis fungsi ini sangat mirip dengan tipe <code>fmap</code> , hanya fungsi itu sendiri yang perlu diterapkan juga dalam wadah.  Ini memberikan pemahaman intuitif tentang bagaimana penerapan fungsi <code>applyP</code> akan terlihat seperti: dapatkan fungsi dari wadah (sebagai hasil dari penerapan parser pertama), dapatkan nilai-nilai yang harus diterapkan fungsi (hasil penerapan parser kedua), dan "bungkus" nilai-nilai yang dikonversi menggunakan fungsi ini kembali ke dalam wadah (buat parser baru).  Dalam implementasinya, kami akan menggunakan daftar pemahaman: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">applyP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> b applyP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> fs = [ (sx, fx) | (sf, f) &lt;- p1 s, <span class="hljs-comment"><span class="hljs-comment">-- p1     (sx, x) &lt;- p2 sf] -- p2   ,    </span></span></code> </pre> <br><p>  Ada kelas <code>Applicative</code> yang memiliki metode dengan prototipe yang sama.  Metode kedua dari kelas ini disebut <code>pure</code> dan digunakan untuk "membungkus" atau "mengangkat" nilai, termasuk nilai fungsional.  Dalam kasus implementasi untuk parser, fungsi <code>pure</code> menambahkan argumennya ke hasil parser, tanpa mengubah string input. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> pure :: a -&gt; fa (&lt;*&gt;) :: f (a -&gt; b) -&gt; fa -&gt; fb <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Applicative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> pure x = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [(s, x)]) pf &lt;*&gt; px = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; [ (sx, fx) | (sf, f) &lt;- unParser pf $ s, (sx, x) &lt;- unParser px $ sf])</code> </pre> <br><p>  Fungsi <code>applyP</code> adalah <code>&lt;*&gt;</code> dari kelas <code>Applicative</code> .  Jenis yang termasuk dalam kelas ini disebut sebagai aplikator fungsi. </p><br><p>  Untuk fungsi aplikatif, dua fungsi tambahan diterapkan yang akan berguna bagi kami: </p><br><pre> <code class="haskell hljs">(*&gt;) :: fa -&gt; fb -&gt; fb (&lt;*) :: fa -&gt; fb -&gt; fa</code> </pre> <br><p>  Fungsi-fungsi ini melakukan dua tindakan berurutan dan mengembalikan hasil hanya dari salah satunya.  Untuk parser, mereka dapat digunakan, misalnya, untuk melewati spasi sebelum mengurai bagian dari string yang membawa beban semantik. </p><br><p>  Dengan menggabungkan <code>&lt;$&gt;</code> dan <code>&lt;*&gt;</code> , Anda dapat membuat desain yang sangat nyaman.  Pertimbangkan tipe data berikut: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStructType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MyStruct</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type1</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type2</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">field3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type3</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  Konstruktor nilai <code>MyStruct</code> juga merupakan fungsi, dalam hal ini adalah tipe <code>Type1 -&gt; Type2 -&gt; Type3 -&gt; MyStructType</code> .  Anda dapat bekerja dengan konstruktor seperti halnya dengan fungsi lainnya.  Misalkan parser sudah ditulis untuk jenis bidang struktur: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parser1</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type1</span></span> parser2 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type2</span></span> parser3 :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Type3</span></span></code> </pre> <br><p>  Menggunakan fungsi <code>fmap</code> , Anda dapat menerapkan sebagian <code>MyStruct</code> ke yang pertama dari parser ini: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct'</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type2</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct' = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1</code> </pre> <br><p>  Mari kita coba terapkan fungsi yang sekarang "di dalam" parser.  Untuk melakukan ini, Anda perlu menggunakan <code>&lt;*&gt;</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct''</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> (<span class="hljs-type"><span class="hljs-type">Type3</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">MyStructType</span></span>) parserStruct'' = parserStruct' &lt;*&gt; parser2 parserStruct :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = parserStruct'' &lt;*&gt; parser3</code> </pre> <br><p>  Sebagai hasilnya, kami mendapatkan parser untuk seluruh struktur (tentu saja, di sini kami menggunakan asumsi bahwa dalam baris asli representasi bidangnya berturut-turut).  Hal yang sama dapat dilakukan dalam satu baris: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserStruct</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">MyStructType</span></span> parserStruct = <span class="hljs-type"><span class="hljs-type">MyStruct</span></span> &lt;$&gt; parser1 &lt;*&gt; parser2 &lt;*&gt; parser3</code> </pre> <br><p>  Konstruksi seperti itu akan sering ditemui dalam kasus penggunaan. </p><br><p>  Sekarang anggaplah kita sedang mencoba untuk menulis parser yang mem-parsing ekspresi aritmatika sederhana di mana bilangan bulat dan pengidentifikasi dapat hadir sebagai operan.  Mari kita buat jenis <code>Operand</code> terpisah untuk mereka: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operand</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IntOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IdentOp</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span></span></code> </pre> <br><p>  Jika kita sudah tahu cara mem-parsing bilangan bulat dan pengidentifikasi (misalnya, seperti dalam C), maka kita memerlukan <em>satu</em> pengurai untuk operan yang dapat menguraikan satu atau yang lain.  Parser ini merupakan alternatif dari dua parser lainnya, sehingga diperlukan suatu fungsi yang dapat menggabungkan parser sehingga hasil kerja mereka digabungkan.  Hasil pengurai adalah daftar, dan menggabungkan daftar adalah gabungannya.  Kami mengimplementasikan fungsi <code>altP</code> menggabungkan dua parser: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">altP</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Parser</span></span> a altP (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p1) (<span class="hljs-type"><span class="hljs-type">Parser</span></span> p2) = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; p1 s ++ p2 s)</code> </pre> <br><p>  Kemudian operan parser dapat diimplementasikan menggunakan fungsi ini (di sini diasumsikan bahwa <code>parserInt</code> dan <code>parserIdent</code> sudah dijelaskan di suatu tempat: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">parserOperand</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Operand</span></span> parserOperand = altP parserIntOp parserIdentOp <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> parserIntOp = <span class="hljs-type"><span class="hljs-type">IntOp</span></span> &lt;$&gt; parserInt parserIdentOp = <span class="hljs-type"><span class="hljs-type">IdentOp</span></span> &lt;$&gt; parserIdent</code> </pre> <br><p>  Tentu saja, untuk alternatif kami telah datang dengan kelas yang terpisah, yang disebut <code>Alternative</code> .  Ini memiliki metode lain, <code>empty</code> , yang menggambarkan elemen netral untuk operasi alternatif.  Dalam kasus kami, itu adalah parser yang tidak pernah mem-parsing apa pun, yaitu.  selalu mengembalikan daftar hasil yang kosong.  Untuk parser, implementasi metode kelas <code>Alternative</code> terlihat seperti ini: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Applicative</span></span></span><span class="hljs-class"> f =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Alternative</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> empty :: fa (&lt;|&gt;) :: fa -&gt; fa -&gt; fa <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> <span class="hljs-type"><span class="hljs-type">Alternative</span></span> <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> empty = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (const []) px &lt;|&gt; py = <span class="hljs-type"><span class="hljs-type">Parser</span></span> (\s -&gt; unParser px s ++ unParser py s)</code> </pre> <br><p>  Operasi <code>&lt;|&gt;</code> adalah fungsi <code>altP</code> hanya dalam notasi infiks, yang lebih nyaman digunakan dengan menggabungkan beberapa parser dalam satu baris. </p><br><p>  Untuk semua tipe dalam kelas ini, dua fungsi diimplementasikan, <code>some</code> dan <code>many</code> tipe <code>fa -&gt; f [a]</code> .  Masing-masing dapat diekspresikan melalui yang lain: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">some</span></span> v = (:) &lt;$&gt; v &lt;*&gt; many v many v = some v &lt;|&gt; pure []</code> </pre> <br><p>  Dalam hal parser, fungsi-fungsi ini memungkinkan Anda untuk mengurai urutan data jika Anda tahu cara mengurai elemen data tunggal.  Dalam hal menggunakan <code>some</code> urutannya harus kosong. </p><br><h1 id="primer-ispolzovaniya">  Contoh penggunaan </h1><br><p>  Sekarang kita siap untuk menulis parser Anda sendiri, misalnya, untuk ekspresi aritmatika sederhana dengan tata bahasa berikut: </p><br><pre> <code class="plaintext hljs"> expr ::= constExpr | binOpExpr | negExpr const ::= int int ::= digit{digit} digit ::= '0' | ... | '9' binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binOp ::= '+' | '*' negExpr ::= '-' expr</code> </pre> <br><p>  Ekspresi terdiri dari konstanta integer, minus unary, dan dua operasi biner infiks: penambahan dan perkalian.  Kurung diperlukan di sekitar ekspresi dengan operasi biner, simbol operasi dipisahkan dari operan dengan tepat satu ruang, ruang terdepan dan gantung tidak diperbolehkan. </p><br><p>  Contoh penulisan ekspresi yang benar: </p><br><pre> <code class="plaintext hljs">"123" "-(10 + 42)" "(1 + ((2 + 3) * (4 + 5)))"</code> </pre> <br><p>  Contoh entri yang salah: </p><br><pre> <code class="plaintext hljs">" 666 " "2 + 3" "(10 * 10)"</code> </pre> <br><p>  Kami mendeklarasikan tipe data yang diperlukan (ekspresi itu sendiri dan operasi biner): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ConstExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BinaryExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NegateExpr</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Expr</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Operator</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Add</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Mul</span></span></span></span></code> </pre> <br><p>  Anda bisa mulai parsing!  Ungkapan itu sendiri terdiri dari tiga alternatif.  Jadi kami menulis: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- expr ::= constExpr | binOpExpr | negExpr exprParser :: Parser Expr exprParser = constParser &lt;|&gt; binParser &lt;|&gt; negParser</span></span></code> </pre> <br><p>  Konstanta adalah bilangan bulat positif.  Dalam tipe data kami, "dibungkus" dalam konstruktor, jadi kami tidak dapat menggunakan parser untuk integer secara langsung, tetapi kami dapat menggunakan <code>fmap</code> untuk mendapatkan nilai dari tipe yang diinginkan. </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- const ::= int constParser :: Parser Expr constParser = ConstExpr &lt;$&gt; intParser</span></span></code> </pre> <br><p>  Bilangan bulat, menurut tata bahasa, direpresentasikan sebagai urutan angka yang tidak kosong.  Untuk mem-parse satu digit, kita menggunakan <code>predP</code> fungsi bantu dan predikat <code>isDigit</code> dari modul <code>Data.Char</code> .  Sekarang, untuk membangun parser untuk parsing urutan angka, kita menggunakan fungsi <code>some</code> (tidak <code>many</code> , karena harus ada setidaknya satu digit).  Hasil parser seperti itu mengembalikan daftar semua opsi parsing yang mungkin, dimulai dengan catatan terpanjang.  Misalnya, jika string input adalah "123ab", daftar hasilnya adalah sebagai berikut: <code>[("ab", "123"), ("3ab", "12"), ("23ab", "1")]</code> .  Kita perlu menguraikan urutan angka terpanjang dan mengubahnya menjadi tipe <code>Int</code> .  Seluruh implementasi adalah sebagai berikut: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- int ::= digit{digit} -- digit ::= '0' | ... | '9' intParser :: Parser Int intParser = Parser $ \s -&gt; let res = unParser (some digitParser) s in case res of [] -&gt; [] ((rest, i) : xs) -&gt; [(rest, read i)] where digitParser = predP isDigit</span></span></code> </pre> <br><p>  Cara selanjutnya untuk menulis ekspresi adalah dengan menggunakan operasi biner.  Menurut tata bahasa, braket pembuka harus terlebih dahulu menyertakan braket pembuka, operan pertama, spasi, simbol operasi, spasi lain, operan kedua, dan braket penutup.  Untuk mem-parsing karakter individu (tanda kurung dan spasi) kami menggunakan fungsi <code>charP</code> .  Operand adalah ekspresi, dan sudah ada parser ( <code>exprParser</code> ) untuk menguraikannya.  Untuk mengurai simbol operasi biner, kami menjelaskan parser tambahan tepat di bawah.  Masih untuk menggabungkan parser ini dengan rapi.  Harus ada tanda kurung di awal dan di akhir ekspresi: Anda perlu memeriksa ini, tetapi buang hasilnya sendiri.  Untuk melakukan ini, gunakan <code>*&gt;</code> dan <code>&lt;*</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">binParser</span></span> :: <span class="hljs-type"><span class="hljs-type">Parser</span></span> <span class="hljs-type"><span class="hljs-type">Expr</span></span> binParser = charP '(' *&gt; ??? &lt;* charP ')'</code> </pre> <br><p>  Di antara parser ini untuk tanda kurung, ekspresi harus dibangun menggunakan konstruktor <code>BinaryExpr</code> dan parser untuk ekspresi dan operasi.  Jangan lupa tentang spasi di sekitar simbol operasi, menggunakan metode yang sama seperti untuk tanda kurung.  Bagian ini adalah sebagai berikut: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">BinaryExpr</span></span> &lt;$&gt; exprParser <span class="hljs-comment"><span class="hljs-comment">--   &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') -- ,   &lt;*&gt; exprParser --  </span></span></code> </pre> <br><p>  Kami mengganti ungkapan ini alih-alih tanda tanya: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOpExpr ::= '(' expr ' ' binOp ' ' expr ')' binParser :: Parser Expr binParser = charP '(' *&gt; (BinaryExpr &lt;$&gt; exprParser &lt;*&gt; (charP ' ' *&gt; binOpParser &lt;* charP ' ') &lt;*&gt; exprParser ) &lt;* charP ')'</span></span></code> </pre> <br><p>  Operasi biner adalah karakter <code>+</code> yang mem-parsing nilai <code>Add</code> , atau <code>*</code> yang mem-parsing <code>Mul</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- binOp ::= '+' | '*' binOpParser :: Parser Operator binOpParser = plusParser &lt;|&gt; multParser where plusParser = charP '+' $&gt; Add multParser = charP '*' $&gt; Mul</span></span></code> </pre> <br><p>  Bagian paling sederhana dari tata bahasa tetap, negasi dari ekspresi.  Dengan simbol <code>-</code> melakukan hal yang sama seperti dengan tanda kurung dan spasi.  Selanjutnya, terapkan konstruktor <code>NegateExpr</code> ke hasil parsing rekursif: </p><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- negExpr ::= '-' expr negParser = charP '-' *&gt; (NegateExpr &lt;$&gt; exprParser)</span></span></code> </pre> <br><p>  Jadi, semua bagian pengurai diimplementasikan.  Kode mirip dengan tata bahasa dan benar-benar bertepatan dengan strukturnya. </p><br><p>  Kode sumber tersedia di GitLab: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://gitlab.com/fierce-katie/applicative-parsers-demo</a> . </p><br><p>  Ada lebih mudah untuk mengevaluasi volume dan tingkat ekspresifnya, karena ada jauh lebih sedikit komentar.  Anda dapat mengkompilasi proyek dengan utilitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stack</a> dan menjalankan interpreter primitif menggunakan parser yang kami tulis: </p><br><pre> <code class="plaintext hljs">$ stack build $ stack exec demo-parser</code> </pre> <br><p>  Bagi mereka yang ingin berlatih lebih lanjut sendiri, saya dapat menyarankan yang berikut: </p><br><ul><li>  Tata bahasa dapat ditingkatkan dengan segala cara, misalnya, untuk memungkinkan ruang terkemuka dan menggantung, menambah operasi baru, dll. </li><li>  Parser menerjemahkan string ke representasi internal ekspresi.  Ungkapan ini dapat dihitung dan interpreter dikonversi sehingga ia mencetak bukan hasil dari penguraian, tetapi hasil dari perhitungan. </li><li>  Jelajahi kemungkinan <code>parsec</code> , <code>attoparsec</code> , <code>applicative-parsec</code> dan <code>optparse-applicative</code> <code>applicative-parsec</code> dan cobalah untuk menggunakannya. </li></ul><br><p>  Terima kasih atas perhatian anda! </p><br><h1 id="poleznye-materialy">  Bahan yang berguna </h1><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pelajari Haskell dalam Y menit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Denis Shevchenko.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Tentang Haskell sebagai manusia"</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Attoparsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan aplikatif-parsec</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan optparse-aplikatif</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436234/">https://habr.com/ru/post/id436234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436224/index.html">Kami menulis bahasa pemrograman kami, bagian 4: Representasi struktur dan kelas, generasi pengalokasi</a></li>
<li><a href="../id436226/index.html">Panduan dan lembar contekan untuk Wireshark</a></li>
<li><a href="../id436228/index.html">Pengembangan perintah untuk meminta data dari database</a></li>
<li><a href="../id436230/index.html">Bagaimana mengendalikan infrastruktur jaringan Anda. Bab Tiga Keamanan jaringan. Bagian dua</a></li>
<li><a href="../id436232/index.html">Strategi Telepati</a></li>
<li><a href="../id436236/index.html">Kami menggunakan ilmu data untuk menentukan siklus hidup klien</a></li>
<li><a href="../id436238/index.html">Otentikasi di Kubernetes dengan GitHub OAuth dan Dex</a></li>
<li><a href="../id436240/index.html">Otomatisasi VS Kekacauan</a></li>
<li><a href="../id436242/index.html">YOLO dan metodologi longgar lainnya</a></li>
<li><a href="../id436244/index.html">Otak Baru Profesor Lawrence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>