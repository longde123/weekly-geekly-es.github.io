<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™ï¸ ğŸ•œ ğŸ¤²ğŸ¼ Pengalaman dalam mengembangkan layanan Alat Pengembalian Uang dengan API asinkron di Kafka ğŸ•Œ ğŸ‘©ğŸ¿â€ğŸ”§ ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang dapat membuat perusahaan besar seperti Lamoda dengan proses yang efisien dan puluhan layanan yang saling berhubungan secara signifikan mengub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengalaman dalam mengembangkan layanan Alat Pengembalian Uang dengan API asinkron di Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/445424/"> Apa yang dapat membuat perusahaan besar seperti Lamoda dengan proses yang efisien dan puluhan layanan yang saling berhubungan secara signifikan mengubah pendekatan?  Motivasinya bisa sangat berbeda: dari legislatif ke keinginan yang melekat dalam semua programmer untuk percobaan. <br><br>  Tetapi ini tidak berarti bahwa seseorang tidak dapat mengandalkan manfaat tambahan.  Apa sebenarnya yang bisa dimenangkan jika Anda mengimplementasikan API berbasis-acara di Kafka, Sergey Zaika ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">fewald</a> ) akan memberi tahu.  Tentang boneka benjolan dan penemuan menarik, juga, pasti akan ada - percobaan tidak dapat dilakukan tanpa mereka. <br><br><img src="https://habrastorage.org/webt/kq/o2/ye/kqo2yemmmu-wiqi9vtpcrbolroq.png"><br><br>  <em>Penafian: Artikel ini didasarkan pada bahan-bahan mitap yang diadakan Sergey pada November 2018 pada HighLoad ++.</em>  <em>Pengalaman langsung Lamoda dengan Kafka menarik perhatian pendengar tidak kurang dari laporan jadwal lainnya.</em>  <em>Tampaknya bagi kami bahwa ini adalah contoh yang bagus dari fakta bahwa selalu mungkin dan perlu untuk menemukan orang yang berpikiran sama, dan penyelenggara HighLoad ++ akan terus berusaha menciptakan suasana yang kondusif untuk ini.</em> <br><a name="habracut"></a><br><h2>  Tentang prosesnya </h2><br>  Lamoda adalah platform e-commerce besar yang memiliki pusat kontak sendiri, layanan pengiriman (dan banyak yang afiliasi), studio foto, gudang besar dan semuanya bekerja pada perangkat lunaknya.  Ada puluhan metode pembayaran, mitra B2B yang dapat menggunakan sebagian atau semua layanan ini dan ingin mengetahui informasi terbaru tentang produk mereka.  Selain itu, Lamoda beroperasi di tiga negara selain Federasi Rusia dan semuanya sedikit berbeda di sana.  Secara total, mungkin ada lebih dari seratus cara untuk mengonfigurasi pesanan baru, yang harus diproses dengan caranya sendiri.  Semua ini bekerja dengan bantuan puluhan layanan yang terkadang berkomunikasi dengan cara yang tidak terlihat.  Ada juga sistem pusat yang tanggung jawab utamanya adalah status pesanan.  Kami memanggilnya BOB, saya bekerja dengannya. <br><br><h2>  Alat Pengembalian Uang dengan API yang digerakkan oleh peristiwa </h2><br>  Kata yang digerakkan oleh peristiwa cukup basi, sedikit lebih jauh kita akan mendefinisikan secara lebih rinci apa yang dimaksud dengan ini.  Saya akan mulai dengan konteks di mana kami memutuskan untuk mencoba pendekatan API berbasis-event Kafka. <br><br><img src="https://habrastorage.org/webt/8y/0i/kp/8y0ikp8ebxzglwhw1s-dhrubivw.png"><br><br>  Di toko mana pun, selain pesanan yang dibayar pelanggan, ada saatnya toko diharuskan mengembalikan uang, karena produk itu tidak sesuai dengan pelanggan.  Proses yang relatif singkat ini: kami mengklarifikasi informasi, jika ada kebutuhan seperti itu, dan mentransfer uang. <br><br>  Tetapi pengembaliannya rumit karena perubahan dalam undang-undang, dan kami harus menerapkan layanan mikro terpisah untuk itu. <br><br><img src="https://habrastorage.org/webt/nn/_x/xr/nn_xxr2xlqfpn-kmgc5y4rzj9a8.png"><br><br>  Motivasi kami: <br><br><ol><li>  <strong>Hukum FZ-54</strong> - secara singkat, hukum mengharuskan Anda untuk melaporkan ke kantor pajak tentang setiap transaksi moneter, apakah itu pengembalian uang atau tanda terima, dalam SLA yang agak singkat dalam beberapa menit.  Kami, sebagai e-commerce, melakukan beberapa operasi.  Secara teknis, ini berarti tanggung jawab baru (dan karena itu layanan baru) dan peningkatan dalam semua sistem yang terlibat. </li><li>  <strong>BOB split</strong> - proyek internal perusahaan untuk menyingkirkan BOB dari sejumlah besar tanggung jawab non-inti dan mengurangi kompleksitas keseluruhannya. </li></ol><br><img src="https://habrastorage.org/webt/u7/k8/7x/u7k87xo4jzxcjmoeanxdzhy_yag.png"><br><br>  Diagram ini menggambarkan sistem Lamoda utama.  Sekarang kebanyakan dari mereka lebih seperti <strong>konstelasi 5-10 layanan mikro di sekitar monolit yang menurun</strong> .  Mereka tumbuh lambat, tetapi kami mencoba untuk membuatnya lebih kecil, karena menakutkan untuk menyebarkan fragmen yang disorot di tengah - itu tidak dapat dibiarkan jatuh.  Semua pertukaran (panah) yang kami terpaksa pesan dan berbaring pada kenyataan bahwa salah satu dari mereka mungkin tidak tersedia. <br><br>  Ada juga banyak pertukaran di BOB: pembayaran, pengiriman, sistem pemberitahuan, dll. <br><br>  Secara teknis, BOB adalah: <br><br><ul><li>  ~ 150 ribu baris kode + ~ 100 ribu baris tes; </li><li>  php7.2 + Zend 1 &amp; Komponen Symfony 3; </li><li>  &gt; 100 API &amp; ~ 50 integrasi keluar; </li><li>  4 negara dengan logika bisnis mereka sendiri. </li></ul><br>  Menyebarkan BOB itu mahal dan menyakitkan, jumlah kode dan tugas-tugas yang diselesaikan sedemikian rupa sehingga tidak ada yang bisa memasukkannya ke dalam kepala mereka.  Secara umum, ada banyak alasan untuk menyederhanakannya. <br><br><h2>  Proses pengembalian </h2><br>  Awalnya, dua sistem terlibat dalam proses: BOB dan Pembayaran.  Sekarang dua lagi yang muncul: <br><br><ul><li>  Layanan Fiskalisasi, yang akan menangani masalah fiskalisasi dan komunikasi dengan layanan eksternal. </li><li>  Alat Pengembalian Uang, di mana pertukaran baru dilakukan begitu saja agar tidak mengembang BOB. </li></ul><br>  Sekarang prosesnya terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/pe/e6/0q/pee60qj1tdefewqgdaw22bww-ag.png"><br><br><ol><li>  BOB menerima permintaan pengembalian dana. </li><li>  BOB berbicara tentang Alat Pengembalian Uang ini. </li><li>  Alat Pengembalian Uang mengatakan Pembayaran: "Dapatkan uang kembali." </li><li>  Pembayaran mengembalikan uang. </li><li>  Alat Pengembalian Dana dan BOB menyinkronkan status satu sama lain, karena untuk saat ini keduanya memerlukannya.  Kami belum siap untuk sepenuhnya beralih ke Alat Pengembalian Uang, karena BOB memiliki UI, laporan akuntansi, dan umumnya banyak data yang tidak dapat Anda transfer dengan mudah.  Kita harus duduk di dua kursi. </li><li>  Permintaan fiskalisasi pergi. </li></ol><br>  Sebagai hasilnya, kami membuat semacam bis acara di Kafka - sebuah bis acara, tempat semuanya dimulai.  Hore, sekarang kita memiliki satu titik kegagalan (sarkasme). <br><br><img src="https://habrastorage.org/webt/8k/zg/qc/8kzgqcfju7ybv8imzajjjykpz10.png"><br><br>  Pro dan kontra cukup jelas.  Kami membuat bus, jadi sekarang semua layanan bergantung padanya.  Ini menyederhanakan desain, tetapi memperkenalkan satu titik kegagalan ke dalam sistem.  Kafka akan jatuh, prosesnya akan naik. <br><br><h2>  Apa itu API yang didorong oleh peristiwa </h2><br>  Jawaban yang bagus untuk pertanyaan ini ada dalam laporan oleh Martin Fowler (GOTO 2017) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"The Many Arti of Event-Driven Architecture"</a> . <br><br>  Secara singkat, apa yang kami lakukan: <br><br><ol><li>  Membungkus semua pertukaran asinkron melalui <strong>penyimpanan acara</strong> .  Alih-alih memberi tahu setiap konsumen yang tertarik tentang perubahan status melalui jaringan, kami menulis acara perubahan status ke repositori terpusat, dan konsumen yang tertarik dengan topik membaca semua yang muncul dari sana. </li><li>  Suatu peristiwa dalam hal ini adalah pemberitahuan ( <strong>notifikasi</strong> ) bahwa ada sesuatu yang berubah di suatu tempat.  Misalnya, status pesanan telah berubah.  Seorang konsumen yang tertarik pada beberapa jenis data yang menyertai perubahan status dan yang tidak ada dalam pemberitahuan dapat mengetahui status mereka sendiri. </li><li>  Opsi maksimum adalah sumber acara lengkap, <strong>transfer negara</strong> , di mana acara berisi semua informasi yang diperlukan untuk diproses: dari mana dan ke status apa Anda beralih, bagaimana tepatnya data berubah, dll. Satu-satunya pertanyaan adalah apakah dan berapa banyak informasi yang Anda mampu untuk simpan. </li></ol><br>  Sebagai bagian dari peluncuran Alat Pengembalian Uang, kami menggunakan opsi ketiga.  Ini menyederhanakan pemrosesan peristiwa, karena itu tidak perlu untuk mendapatkan informasi rinci, ditambah itu mengecualikan skenario ketika setiap peristiwa baru menghasilkan lonjakan klarifikasi permintaan-mendapatkan dari konsumen. <br><br>  Layanan Alat Pengembalian Uang <strong>tidak dimuat</strong> , jadi Kafka lebih mirip tes pena daripada keharusan.  Saya tidak berpikir bahwa jika layanan pengembalian dana menjadi proyek yang banyak, bisnis akan bahagia. <br><br><h4>  Async exchange SEBAGAIMANA ADANYA </h4><br>  Untuk pertukaran asinkron, departemen PHP biasanya menggunakan RabbitMQ.  Kami mengumpulkan data untuk permintaan, memasukkannya ke dalam antrian, dan konsumen dari layanan yang sama membacanya dan mengirimnya (atau tidak mengirimnya).  Untuk API itu sendiri, Lamoda aktif menggunakan Swagger.  Kami merancang API, mendeskripsikannya dalam Swagger, menghasilkan kode klien dan server.  Kami juga menggunakan JSON RPC 2.0 yang sedikit canggih. <br><br>  Di sana-sini, esb bus digunakan, seseorang tinggal di activeMQ, tetapi, secara umum, <strong>RabbitMQ adalah standarnya</strong> . <br><br><h4>  Pertukaran Async MENJADI </h4><br>  Ketika merancang pertukaran melalui bus peristiwa, analogi dilacak.  Kami juga menggambarkan pertukaran data di masa mendatang melalui deskripsi struktur acara.  Format yaml, pembuatan kode harus dilakukan sendiri, generator membuat DTO sesuai dengan spesifikasi dan mengajari klien dan server cara bekerja dengannya.  Generasi masuk ke dua bahasa - <strong>golang dan php</strong> .  Ini membuat perpustakaan konsisten.  Generator ditulis dalam golang, yang menerima nama gogi. <br><br>  Pengadaan-acara di Kafka adalah hal yang biasa.  Ada solusi dari versi perusahaan utama Kafka Confluent, ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">nakadi</a> , solusi dari "saudara" kami di wilayah domain Zalando.  <strong>Motivasi</strong> kami <strong>untuk memulai dengan vanilla Kafka</strong> adalah membiarkan solusinya gratis sampai kami akhirnya memutuskan apakah akan menggunakannya di mana-mana, dan juga meninggalkan ruang untuk manuver dan perbaikan: kami ingin dukungan untuk <strong>JSON RPC 2.0 kami</strong> , generator untuk dua bahasa, dan melihat apa lagi. <br><br>  Sungguh ironis bahwa bahkan dalam kasus bahagia seperti itu, ketika ada bisnis serupa dengan Zalando, yang membuat keputusan serupa, kita tidak dapat menggunakannya secara efektif. <br><br>  Secara arsitektur, pada saat startup, polanya adalah sebagai berikut: membaca langsung dari Kafka, tetapi menulis hanya melalui peristiwa-bus.  Ada banyak yang siap dibaca di Kafka: broker, penyeimbang dan lebih atau kurang siap untuk penskalaan horizontal, saya ingin menyimpannya.  Catatannya, kami ingin membungkus satu Gateway alias Events-bus, dan itulah sebabnya. <br><br><h3>  Acara-bus </h3><br>  Atau bis acara.  Ini hanya gateway http stateless yang mengambil beberapa peran penting: <br><br><ul><li>  <strong>Validasi produksi</strong> - kami memverifikasi bahwa acara memenuhi spesifikasi kami. </li><li>  <strong>Suatu sistem master peristiwa</strong> , yaitu, itu adalah sistem utama dan satu-satunya di perusahaan yang menjawab pertanyaan peristiwa mana dengan struktur mana yang dianggap sah.  Validasi hanya mencakup tipe data dan enums untuk spesifikasi konten yang ketat. </li><li>  <strong>Fungsi</strong> hash untuk sharding - struktur pesan Kafka adalah nilai-kunci, dan di sini dihitung oleh hash dari kunci tempat meletakkannya. </li></ul><br><h3>  Mengapa </h3><br>  Kami bekerja di perusahaan besar dengan proses yang efisien.  Mengapa mengubah sesuatu?  <strong>Ini adalah eksperimen</strong> , dan kami berharap mendapatkan beberapa manfaat. <br><br><h4>  Pertukaran 1: n + 1 (satu ke banyak) </h4><br>  Dengan Kafka, sangat mudah untuk menghubungkan konsumen baru ke API. <br><br>  Misalkan Anda memiliki direktori yang perlu selalu diperbarui di beberapa sistem sekaligus (dan di beberapa yang baru).  Sebelumnya, kami menemukan bundel yang mengimplementasikan set-API, dan alamat konsumen dilaporkan ke sistem master.  Sekarang sistem master mengirimkan pembaruan ke topik, dan semua orang yang tertarik membaca.  Sebuah sistem baru telah muncul - mereka menandatanganinya pada topik.  Ya, juga bundel, tetapi lebih sederhana. <br><br>  Dalam hal alat pengembalian uang, yang merupakan bagian dari BOB, kami merasa nyaman untuk menyinkronkannya melalui Kafka.  Pembayaran mengatakan bahwa mereka mengembalikan uang itu: BOB, RT mengetahuinya, mengubah status mereka, Layanan Fiskalisasi mengetahuinya dan mengeluarkan cek. <br><br><img src="https://habrastorage.org/webt/x1/rs/gx/x1rsgx9mbceqzstdmcsg_hapnbs.png"><br><br>  Kami memiliki rencana untuk membuat Layanan Pemberitahuan tunggal, yang akan memberi tahu klien tentang berita tentang pesanan / pengembaliannya.  Sekarang tanggung jawab ini tersebar di antara sistem.  Cukup bagi kami untuk mengajarkan Layanan Notifikasi untuk menangkap dan menanggapi informasi yang relevan dari Kafka (dan menonaktifkan notifikasi ini di sistem lain).  Tidak diperlukan pertukaran langsung baru. <br><br><h4>  Didorong data </h4><br>  Informasi antar sistem menjadi transparan - tidak peduli seberapa berdarah perusahaan yang Anda miliki dan seberapa bengkaknya jaminan simpanan Anda.  Lamoda memiliki departemen Analisis Data yang mengumpulkan data pada sistem dan menempatkannya dalam bentuk yang dapat digunakan kembali, baik untuk bisnis maupun untuk sistem cerdas.  Kafka memungkinkan Anda memberi mereka banyak data dengan cepat dan terus memperbarui informasi ini. <br><br><h4>  Log replikasi </h4><br>  Pesan tidak hilang setelah membaca, seperti pada RabbitMQ.  Saat acara berisi informasi yang cukup untuk diproses, kami memiliki riwayat perubahan terbaru pada objek, dan, jika diinginkan, kemampuan untuk menerapkan perubahan ini. <br><br>  Periode penyimpanan log replikasi tergantung pada intensitas penulisan topik ini. Kafka memungkinkan Anda untuk secara fleksibel menetapkan batas waktu penyimpanan dan volume data.  Untuk topik intensif, penting bahwa semua konsumen punya waktu untuk membaca informasi sebelum menghilang, bahkan dalam kasus ketidakmampuan operasi jangka pendek.  Biasanya ternyata untuk menyimpan data selama <strong>satuan hari</strong> , yang cukup untuk mendukung. <br><br><img src="https://habrastorage.org/webt/xz/6-/59/xz6-59a1z7vrszrmoowvswxauqc.png"><br><br>  Kemudian sedikit menceritakan kembali dokumentasi, untuk mereka yang tidak terbiasa dengan Kafka (gambar juga dari dokumentasi) <br><br>  Ada antrian di AMQP: kami menulis pesan ke antrian untuk konsumen.  Sebagai aturan, satu antrian diproses oleh satu sistem dengan logika bisnis yang sama.  Jika Anda perlu memberi tahu beberapa sistem, Anda dapat mengajarkan aplikasi untuk menulis dalam beberapa antrian atau mengkonfigurasi pertukaran dengan mekanisme fanout, yang dengan sendirinya mengkloningnya. <br><br>  Kafka memiliki abstraksi <em>topik</em> serupa di mana Anda menulis pesan, tetapi mereka tidak hilang setelah membaca.  Secara default, ketika Anda terhubung ke Kafka, Anda menerima semua pesan, dan pada saat yang sama ada kesempatan untuk menyimpan tempat di mana Anda tinggalkan.  Artinya, Anda membaca secara berurutan, Anda tidak dapat menandai pesan sebagai sudah dibaca, tetapi simpan id, yang kemudian dilanjutkan membaca.  Id yang Anda hentikan disebut offset, dan mekanisme komit offset. <br><br>  Dengan demikian, logika yang berbeda dapat diimplementasikan.  Misalnya, kami memiliki BOB dalam 4 contoh untuk berbagai negara - Lamoda ada di Rusia, Kazakhstan, Ukraina, Belarus.  Karena mereka dikerahkan secara terpisah, mereka memiliki sedikit konfigurasi sendiri dan logika bisnis mereka sendiri.  Dalam pesan tersebut kami menunjukkan negara mana yang dimaksud.  Setiap konsumen BOB di masing-masing negara membaca dengan groupId yang berbeda, dan jika pesan itu tidak berlaku untuknya, lewati saja, mis.  segera lakukan offset +1.  Jika topik yang sama dibaca oleh Layanan Pembayaran kami, maka topik ini dilakukan dengan grup terpisah, dan oleh karena itu offset tidak tumpang tindih. <br><br>  <b>Persyaratan Acara:</b> <br><br><ul><li>  <strong>Kelengkapan data.</strong>  Saya berharap ada cukup data di acara tersebut sehingga bisa diproses. </li></ul><br><ul><li>  <strong>Integritas</strong>  Kami mendelegasikan bus Acara untuk memverifikasi bahwa acara tersebut konsisten dan dapat menanganinya. </li><li>  <strong>Ketertiban itu penting.</strong>  Dalam kasus pengembalian, kami dipaksa untuk bekerja dengan sejarah.  Dengan notifikasi, pesanan tidak penting, jika notifikasi homogen, email akan tetap sama, tidak peduli order mana yang lebih dulu.  Dalam kasus pengembalian, ada proses yang jelas, jika Anda mengubah pesanan, maka akan ada pengecualian, pengembalian dana tidak akan dibuat atau diproses - kami akan berakhir dalam status yang berbeda. </li><li>  <strong>Koherensi</strong>  Kami memiliki repositori, dan sekarang alih-alih API kami membuat acara.  Kami membutuhkan cara untuk dengan cepat dan murah mentransfer informasi tentang acara baru dan perubahan yang sudah ada ke layanan kami.  Ini dicapai dengan menggunakan spesifikasi umum dalam repositori git dan generator kode terpisah.  Oleh karena itu, klien dan server di berbagai layanan dikoordinasikan dengan kami. </li></ul><br><h2>  Kafka di Lamoda </h2><br>  Kami memiliki tiga instalasi Kafka: <br><br><ol><li>  Log </li><li>  R&amp;D; </li><li>  Acara-bus. </li></ol><br>  Hari ini kita hanya berbicara tentang poin terakhir.  Di event-bus, kami tidak memiliki instalasi yang sangat besar - 3 broker (server) dan total 27 topik.  Sebagai aturan, satu topik adalah satu proses.  Tetapi ini adalah saat yang sulit, dan sekarang kita akan menyentuhnya. <br><br><img src="https://habrastorage.org/webt/1v/5s/nj/1v5snjoqmrg2sb1grok5snkzowu.png"><br><br>  Di atas adalah grafik rps.  Proses pengembalian dana ditandai dengan garis pirus (ya, yang terletak di sumbu X), dan merah muda adalah proses pembaruan konten. <br><br>  Katalog Lamoda berisi jutaan produk, dengan data yang diperbarui setiap saat.  Beberapa koleksi keluar dari mode, yang baru dirilis bukan mereka, model baru terus muncul dalam katalog.  Kami mencoba memprediksi apa yang akan menarik bagi pelanggan kami besok, jadi kami terus membeli barang baru, memotretnya, dan memperbarui jendela. <br><br>  Puncak merah muda adalah pembaruan produk, yaitu perubahan dalam produk.  Dapat dilihat bahwa orang-orang itu mengambil gambar, mengambil gambar, dan sekali lagi!  - mengunduh paket acara. <br><br><h2>  Lamoda Events menggunakan case </h2><br>  Kami menggunakan arsitektur yang dibangun untuk operasi tersebut: <br><br><ul><li>  <strong>Pelacakan status pengembalian</strong> : ajakan untuk bertindak dan pelacakan status dari semua sistem yang terlibat.  Pembayaran, status, fiskalisasi, notifikasi.  Di sini kami mencoba pendekatannya, membuat alat, mengumpulkan semua bug, menulis dokumentasi dan memberi tahu kolega bagaimana cara menggunakannya. </li><li>  <strong>Memperbarui kartu produk:</strong> konfigurasi, meta-data, karakteristik.  Satu sistem membaca (yang menampilkan), dan beberapa menulis. </li><li>  <strong>Email, push dan sms</strong> : pesanan dikumpulkan, pesanan telah tiba, pengembalian telah diterima, dll., Banyak dari mereka. </li><li>  <strong>Stok, pembaruan gudang</strong> - <strong>pembaruan</strong> kuantitatif barang, hanya nomor: tanda terima di gudang, kembalikan.  Semua sistem yang terkait dengan reservasi barang harus beroperasi dengan data yang paling relevan.  Sekarang sistem upgrade saluran cukup rumit, Kafka akan menyederhanakannya. </li><li>  <strong>Analisis Data</strong> (departemen R&amp;D), alat-ML, analitik, statistik.  Kami ingin informasinya transparan - untuk Kafka ini sangat cocok. </li></ul><br>  Sekarang, bagian yang lebih menarik adalah tentang kerucut yang diisi dan penemuan menarik yang terjadi selama enam bulan. <br><br><h2>  Masalah desain </h2><br>  Misalkan kita ingin membuat hal baru - misalnya, mentransfer seluruh proses pengiriman ke Kafka.  Bagian dari proses sekarang sedang dilaksanakan dalam Pemrosesan Pesanan di BOB.  Di belakang transfer pesanan ke layanan pengiriman, transfer ke gudang perantara, dll. Ada model status.  Ada satu keseluruhan monolit, bahkan dua, ditambah banyak API pengiriman.  Mereka tahu lebih banyak tentang pengiriman. <br><br>  Ini tampaknya area yang serupa, tetapi untuk Pemrosesan Pesanan di BOB dan untuk sistem pengiriman, statusnya berbeda.  Misalnya, beberapa layanan kurir tidak mengirim status perantara, tetapi hanya yang terakhir: "dikirim" atau "hilang".  Yang lain, sebaliknya, melaporkan pergerakan barang dengan sangat rinci.  Setiap orang memiliki aturan validasi sendiri: untuk seseorang, email valid, sehingga akan diproses;  untuk orang lain, ini tidak valid, tetapi pesanan masih akan diproses, karena ada telepon untuk komunikasi, dan seseorang akan mengatakan bahwa pesanan seperti itu tidak akan diproses sama sekali. <br><br><h3>  Aliran data </h3><br>  Dalam kasus Kafka, muncul pertanyaan untuk mengatur aliran data.  Tugas ini terhubung dengan pilihan strategi untuk beberapa poin, kita akan membahas semuanya. <br><br><h4>  Dalam satu topik atau berbeda? </h4><br>  Kami memiliki spesifikasi acara.  Di BOB, kami menulis bahwa pesanan seperti itu harus dikirimkan, dan menunjukkan: nomor pesanan, komposisinya, beberapa SKU dan kode batang, dll.  Ketika barang tiba di gudang, pengiriman akan dapat menerima status, stempel waktu, dan semua yang diperlukan.  Tetapi selanjutnya kami ingin menerima pembaruan tentang data ini dalam BOB.  Kami dihadapkan dengan proses sebaliknya untuk mendapatkan data dari pengiriman.  Apakah ini acara yang sama?  Atau apakah ini merupakan pertukaran terpisah yang layak mendapatkan topik terpisah? <br><br>  Kemungkinan besar, mereka akan sangat mirip, dan godaan untuk membuat satu topik tidak masuk akal, karena topik yang terpisah adalah konsumen yang terpisah, konfigurasi yang terpisah, generasi yang terpisah dari semua ini.  Tapi bukan fakta. <br><br><h4>  Bidang baru atau acara baru? </h4><br>  Tetapi jika Anda menggunakan acara yang sama, maka masalah lain muncul.  Misalnya, tidak semua sistem pengiriman dapat menghasilkan DTO yang dapat menghasilkan BOB.  Kami mengirimi mereka id, tetapi mereka tidak menyimpannya, karena mereka tidak membutuhkannya, dan dari sudut pandang memulai proses event-bus, bidang ini diperlukan. <br><br>  Jika kami memperkenalkan aturan untuk bus peristiwa bahwa bidang ini wajib diisi, maka kami terpaksa menetapkan aturan validasi tambahan di BOB atau di pengendali kejadian awal.  Validasi mulai merayap di layanan - tidak nyaman. <br><br>    â€”    .  ,   -   , ,  ,   ,      .       â€”   .   â€”    ,    .        JSON      . <br><br>   refunds        .     -,   refund update,     type, ,     update .      Â«Â»   ,  ,        type. <br><br><h4>   </h4><br>     Kafka   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Avro</a> ,          Confluent.        .        replication log,    Â«Â».  ,    ,     : ,    .    ,     ,   ,    . <br><br><h4>    partitions </h4><br>   Kafka   partitions.          ,  ,  ,     . <br><br>       Kafka  .     partition,        .       . , ,    ,      .  , ,  ,    Kafka   partition,  Kafka       â€”  ,  . <br><br>  Kafka  ?      (    JSON)   key.      -,   ,   partition  . <br><br>     refunds  ,     partition,   ,           . - ,            partition. <br><br><h4> Events vs commands </h4><br>    ,    . Event â€”   :  ,  - -  (something_happened), , item    refund.    - ,   Â«item Â»  refund  ,  Â« refundÂ»  -  . <br><br>  ,    ,        â€”    ,   -  .     something_happened (item_canceled, refund_refunded),  something_should_be_done. , item   . <br><br>   ,  ,    .   ,        .   ,      do_something.     ,    - ;   ,   ;    ,   -,   -  .   ,    do_something,    ,   . <br><br><img src="https://habrastorage.org/webt/gy/xo/vm/gyxovmgvxv3wbwkv_k7mzluobls.png"><br><br>     RabbitMQ,    ,   http,    response â€”  ,    .     Kafka,  ,     Kafka,   ,   ,    . <br><br>             ,    - ,  -       .    ,  , -   . ,     Â«item_ready_to_refundÂ»,  ,  refund ,   ,    Â«money_refundedÂ».    ,   . <br><br><h3>  Nuansa </h3><br>    :      ,    -  ,  ,     .   <strong>  </strong> ,  offset ,   . <br><br>    ,   ,     .    ,        events-bus,        ,         PostgreSQL,        MySQL  UNSIGNED INT,      PostgreSQL   INT.     ,  Id  . Symfony   . , ,  ,     ,     offset,       ,     .        ,  Symfony     ,          offset. <br><br> -    â€”  ,  Kafka    ,    .       .  . <br><br>  Kafka    tooling   offset.    ,     â€”      ,     , redeployments.   Kafka  tooling   offset,   . <br><br>   â€” <strong>replication log vs rdkafka.so</strong> â€”     .   PHP,   PHP,  ,  ,   Kafka   rdkafka.so,    - .  ,    ,  ,        - .  ,   . <br><br>      partitions,     <strong>consumers &gt;= topic partitions</strong> .       ,   .        ,      partitions.  ,      partition,    20  ,    ,     . ,     ,    partitions. <br><br><h2>  Pemantauan </h2><br> ,  ,   ,   ,      . <br><br> , ,       , , ,       ,        .   Kafka    ,       . ,         . <br><br><img src="https://habrastorage.org/webt/il/on/va/ilonvaqqf3tkfcv9reuyezxpgoq.png"><br><br>  ,  ,    ,   events-bus ,     . ,     Refund Tool  ,   BOB  -  ( ). <br><br><img src="https://habrastorage.org/webt/i4/9b/jf/i49bjfsr_lrypwz0_1qfkhhmcjq.png"><br><br>    consumer-group lag.  ,    .       ,     0,      . Kafka    ,     . <br><br>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Burrow</a> ,       Kafka.    API  consumer-group  ,     .    Failed   warning,    ,         â€”    ,  .   ,   . <br><br><img src="https://habrastorage.org/webt/4j/ht/go/4jhtgoqjn_0kdgvagxkg3flceng.png"><br><br>     API.   bob-live-fifa, partition refund.update.v1,  , lag 0 â€”   offset -. <br><br><img src="https://habrastorage.org/webt/mh/gn/aq/mhgnaq2qcxamaejf1fkdkkkqnwu.png"><br><br>  <strong>updated_at SLA (stuck)</strong>   . ,    ,     .   Cron,  ,    5       refund (       ),  -    ,      .    Cron,    ,     0,   . <br><br> <b> ,   , </b> : <br><br><ul><li>    ; </li><li>    ; </li><li>     . </li></ul><blockquote>  ,      â€”  API  Kafka,          . <br> -,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad++</a>     ,       ,         . <br> -,               <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">KnowledgeConf</a> .  ,  26 ,      . <br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP Russia</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">++</a> ( DevOpsConf  ) â€”      ,          . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445424/">https://habr.com/ru/post/id445424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445414/index.html">Bagaimana buku sains Soviet menjadi artefak di antara fisikawan dan insinyur di India</a></li>
<li><a href="../id445416/index.html">Mengapa Rekaman Vinyl Bertahan dari Zaman Digital</a></li>
<li><a href="../id445418/index.html">Homo sapiens? Tidak lagi</a></li>
<li><a href="../id445420/index.html">Ada 17 miliar komputer di korteks otak Anda</a></li>
<li><a href="../id445422/index.html">Bahasa pemrograman mana yang paling tidak aman?</a></li>
<li><a href="../id445426/index.html">Optimalisasi untuk aplikasi Rails yang melayani PostgreSQL</a></li>
<li><a href="../id445428/index.html">Wi-Fi berkualitas tinggi - dasar keramahtamahan modern dan mesin bisnis</a></li>
<li><a href="../id445432/index.html">Manajer Paket Persatuan</a></li>
<li><a href="../id445434/index.html">Pekerjaan Terburuk Terbaik di Dunia: Mencari Habraautor</a></li>
<li><a href="../id445436/index.html">Pelatihan ulang di DevOps - untuk apa Anda mempersiapkan diri</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>