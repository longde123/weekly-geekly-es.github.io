<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≤ ‚ùáÔ∏è ü¶å Wie man das Spiel mit 60fps zum Laufen bringt üïå üòõ üôçüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stellen Sie sich das Problem vor: Sie haben ein Spiel und es muss mit 60 fps auf einem 60-Hz-Monitor funktionieren. Ihr Computer ist schnell genug zum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man das Spiel mit 60fps zum Laufen bringt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442528/">  Stellen Sie sich das Problem vor: Sie haben ein Spiel und es muss mit 60 fps auf einem 60-Hz-Monitor funktionieren.  Ihr Computer ist schnell genug zum Rendern und Aktualisieren, um eine unbedeutende Zeit in Anspruch zu nehmen. Schalten Sie also vsync ein und schreiben Sie diese Spieleschleife: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Sehr einfach!  Jetzt arbeitet das Spiel mit 60 fps und alles l√§uft wie am Schn√ºrchen.  Fertig.  Vielen Dank f√ºr das Lesen dieses Beitrags. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Nun, offensichtlich ist nicht alles so gut.  Was ist, wenn jemand einen schwachen Computer hat, der das Spiel nicht mit einer Geschwindigkeit rendern kann, die ausreicht, um 60 fps bereitzustellen?  Was w√§re, wenn jemand einen dieser coolen neuen 144-Hertz-Monitore kaufen w√ºrde?  Was ist, wenn er vsync in den Treibereinstellungen deaktiviert hat? <br><a name="habracut"></a><br>  Sie k√∂nnten denken: Ich muss die Zeit irgendwo messen und ein Update mit der richtigen H√§ufigkeit bereitstellen.  Dies ist ganz einfach: Sammeln Sie einfach die Zeit in jedem Zyklus und aktualisieren Sie sie jedes Mal, wenn sie den Schwellenwert um 1/60 Sekunde √ºberschreitet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Fertig, nirgendwo einfacher.  Tats√§chlich gibt es eine Reihe von Spielen, bei denen der Code im Wesentlichen so aussieht.  Das ist aber falsch.  Dies ist zum Einstellen des Timings geeignet, f√ºhrt jedoch zu Problemen mit Ruckeln (Stottern) und anderen Fehlanpassungen.  Ein solches Problem ist sehr h√§ufig: Frames werden nicht genau 1/60 Sekunde angezeigt;  Selbst wenn vsync aktiviert ist, gibt es in der Zeit, in der sie angezeigt werden (und in der Genauigkeit des Betriebssystem-Timers), immer ein kleines Rauschen.  Daher wird es Situationen geben, in denen Sie einen Frame rendern und das Spiel glaubt, dass die Zeit f√ºr die erneute Aktualisierung noch nicht gekommen ist (da der Akku nur einen winzigen Bruchteil hinterherhinkt). Daher wird derselbe Frame nur noch einmal wiederholt, aber jetzt ist das Spiel zu sp√§t f√ºr den Frame und verdoppelt sich Update.  Hier ist das Zucken! <br><br>  Beim Googeln finden Sie mehrere vorgefertigte L√∂sungen, um dieses Zucken zu beseitigen.  Zum Beispiel kann ein Spiel eine Variable anstelle eines konstanten Zeitschritts verwenden und die Batterien im Zeitcode einfach ganz aufgeben.  Oder Sie k√∂nnen einen konstanten Zeitschritt mit einem interpolierenden Renderer implementieren, der in einem ziemlich bekannten Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " von Glenn Fielder beschrieben wird.  Oder Sie k√∂nnen den Timer-Code neu erstellen, damit er etwas flexibler ist, wie im Beitrag zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">Frame-Timing-Problemen von</a> Slick Entertainment beschrieben (dieser Blog ist leider nicht mehr vorhanden). <br><br><hr><br><h3>  Fuzzy Timings </h3><br>  Die Slick Entertainment-Methode mit ‚ÄûFuzzy Timings‚Äú in meiner Engine war am einfachsten zu implementieren, da keine √Ñnderungen in der Spielelogik und im Rendering erforderlich waren.  Also in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">The End is Nigh habe</a> ich es benutzt.  Es war genug, um es nur in den Motor einzusetzen.  Tats√§chlich kann das Spiel einfach ‚Äûetwas fr√ºher‚Äú aktualisiert werden, um Probleme mit Timing-Fehlanpassungen zu vermeiden.  Wenn das Spiel vsync enth√§lt, k√∂nnen Sie vsync nur als Haupttimer des Spiels verwenden und erhalten ein fl√ºssiges Bild. <br><br>  So sieht der Update-Code jetzt aus (das Spiel kann mit 62 fps "funktionieren", verarbeitet aber immer noch jeden Zeitschritt so, als ob es mit 60 fps funktioniert. Ich verstehe nicht ganz, warum ich ihn einschr√§nken soll, damit die Batteriewerte nicht unter 0 fallen, aber ohne Dieser Code funktioniert nicht.  Sie k√∂nnen es folgenderma√üen interpretieren: ‚ÄûDas Spiel wird mit einem festen Schritt aktualisiert, wenn es im Intervall von 60 fps bis 62 fps gerendert wird.‚Äú <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Wenn vsync aktiviert ist, kann das Spiel im Wesentlichen mit einer festen Tonh√∂he arbeiten, die der Bildwiederholfrequenz des Monitors entspricht und ein fl√ºssiges Bild liefert.  Das Hauptproblem hierbei ist, dass das Spiel bei deaktivierter vsync-Funktion <i>etwas</i> schneller funktioniert, der Unterschied jedoch so <i>gering</i> ist, dass niemand ihn bemerkt. <br><br>  Speedrunner.  Speedrunner werden es bemerken.  Kurz nach der Ver√∂ffentlichung des Spiels stellten sie fest, dass einige Leute auf den Speedran-Highscore-Listen schlechtere Reisezeiten hatten, aber es stellte sich heraus, dass es besser war als andere.  Der unmittelbare Grund daf√ºr war das unklare Timing und die Unterbrechung von vsync im Spiel (oder 144-Hz-Monitoren).  Daher wurde klar, dass Sie diese Unsch√§rfe deaktivieren m√ºssen, wenn Sie vsync trennen. <br><br>  Oh, aber wir k√∂nnen immer noch nicht √ºberpr√ºfen, ob vsync deaktiviert ist.  Im Betriebssystem gibt es keine Aufrufe daf√ºr, und obwohl wir von der Anwendung anfordern k√∂nnen, vsync zu aktivieren oder zu deaktivieren, h√§ngt dies tats√§chlich vollst√§ndig vom Betriebssystem und dem Grafiktreiber ab.  Das einzige, was getan werden kann, ist, eine Reihe von Frames zu rendern, die Ausf√ºhrungszeit dieser Aufgabe zu messen und dann zu vergleichen, ob sie ungef√§hr dieselbe Zeit in Anspruch nehmen.  Genau das habe ich f√ºr <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">The End is Nigh</a> getan.  Wenn das Spiel kein vsync mit einer Frequenz von 60 Hz enth√§lt, wird mit ‚Äûstrengen 60 fps‚Äú auf den urspr√ºnglichen Frame-Timer zur√ºckgesetzt.  Au√üerdem habe ich der Konfigurationsdatei einen Parameter hinzugef√ºgt, der das Spiel dazu zwingt, keine Unsch√§rfe zu verwenden (haupts√§chlich f√ºr Speedrunner, die eine genaue Zeit ben√∂tigen), und einen genauen Timer-Handler im Spiel hinzugef√ºgt, der die Verwendung von Autosplitter erm√∂glicht (dies ist ein Skript, das mit einem Atomzeit-Timer arbeitet). <br><br>  Einige Benutzer beschwerten sich immer noch √ºber das gelegentliche Ruckeln einzelner Frames, aber sie schienen so selten zu sein, dass sie durch Betriebssystemereignisse oder andere externe Gr√ºnde erkl√§rt werden konnten.  Keine gro√üe Sache.  Richtig? <br><br>  Als ich k√ºrzlich meinen Timer-Code durchgesehen habe, ist mir etwas Seltsames aufgefallen.  Die Batterie wurde verschoben, jeder Frame dauerte etwas l√§nger als 1/60 Sekunde, so dass das Spiel von Zeit zu Zeit dachte, es sei zu sp√§t f√ºr den Frame, und f√ºhrte ein doppeltes Update durch.  Es stellte sich heraus, dass mein Monitor mit einer Frequenz von 59,94 Hz und nicht mit 60 Hz arbeitet.  Dies bedeutete, dass er alle 1000 Frames ein doppeltes Update durchf√ºhren musste, um ‚Äûaufzuholen‚Äú.  Dies ist jedoch sehr einfach zu beheben - √§ndern Sie einfach das Intervall der zul√§ssigen Bildfrequenzen (nicht von 60 auf 62, sondern von 59 auf 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Das oben beschriebene Problem mit getrennten vsync- und Hochfrequenzmonitoren besteht weiterhin, und es gilt dieselbe L√∂sung (Rollback auf strengen Timer, wenn der Monitor <i>nicht</i> um 60 vsync synchronisiert ist). <br><br>  Aber woher wissen Sie, ob dies die richtige L√∂sung ist?  Wie kann sichergestellt werden, dass es auf allen Computerkombinationen mit verschiedenen Monitortypen mit und ohne aktiviertem vsync usw. ordnungsgem√§√ü funktioniert?  Es ist sehr schwierig, all diese Timerprobleme im Kopf im Auge zu behalten und zu verstehen, was die Desynchronisation, seltsame Schleifen und dergleichen verursacht. <br><br><h3>  Simulator √ºberwachen </h3><br>  Beim Versuch, eine zuverl√§ssige L√∂sung f√ºr das ‚ÄûProblem des 59,94-Hertz-Monitors‚Äú zu finden, wurde mir klar, dass ich nicht nur Versuche und Fehlerpr√ºfungen durchf√ºhren konnte, in der Hoffnung, eine zuverl√§ssige L√∂sung zu finden.  Ich brauchte eine bequeme M√∂glichkeit, verschiedene Versuche zu testen, einen hochwertigen Timer zu schreiben, und eine einfache M√∂glichkeit, um zu √ºberpr√ºfen, ob es in verschiedenen Monitorkonfigurationen zu einem Ruckeln oder einer Zeitverschiebung kommt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Der Monitorsimulator wird</a> in der Szene angezeigt.  Dies ist der ‚Äûschmutzige und schnelle‚Äú Code, den ich geschrieben habe, der den ‚ÄûMonitorbetrieb‚Äú simuliert und mir im Wesentlichen eine Reihe von Zahlen zeigt, die eine Vorstellung von der Stabilit√§t jedes getesteten Timers geben. <br><br>  F√ºr den einfachsten Timer werden beispielsweise die folgenden Werte ab dem Anfang des Artikels angezeigt: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  Zun√§chst zeigt der Code f√ºr jedes emulierte vsync die Anzahl der "Aktualisierungen" des Spielzyklus nach dem vorherigen vsync an.  Alle anderen Werte als durchgehend 1 f√ºhren zu einem zuckenden Bild.  Am Ende zeigt der Code die akkumulierten Statistiken an. <br><br>  Bei Verwendung des ‚ÄûFuzzy-Timers‚Äú (mit einem Intervall von 60 bis 62 fps) auf einem 59,94-Hertz-Monitor zeigt der Code Folgendes an: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  Das Ruckeln des Rahmens ist sehr selten, so dass es bei einer solchen Zahl von 1 schwierig sein kann, es zu bemerken. Die angezeigten Statistiken zeigen jedoch deutlich, dass das Spiel hier mehrere doppelte Aktualisierungen durchgef√ºhrt hat, was zu Ruckeln f√ºhrt.  In der festen Version (mit einem Intervall von 59 bis 61 fps) werden 0 √ºbersprungen oder doppelt aktualisiert. <br><br>  Sie k√∂nnen vsync auch deaktivieren.  Der Rest der Statistikdaten wird unwichtig, aber dies zeigt mir deutlich die Gr√∂√üe der ‚ÄûZeitverschiebung‚Äú (die Systemzeitverschiebung relativ zu dem Ort, an dem die Spielzeit sein sollte). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  Wenn vsync deaktiviert ist, m√ºssen Sie daher zu einem strengen Timer wechseln, da sich diese Diskrepanzen sonst im Laufe der Zeit ansammeln. <br><br>  Wenn ich die Renderzeit auf .02 setze (dh zum Rendern wird ‚Äûmehr als ein Frame‚Äú ben√∂tigt), bekomme ich ein Zucken.  Idealerweise sollte das Spielmuster wie 202020202020 aussehen, ist aber etwas ungleichm√§√üig. <br><br>  In dieser Situation verh√§lt sich dieser Timer etwas besser als der vorherige, aber es wird verwirrender und schwieriger herauszufinden, wie und warum er funktioniert.  Aber ich kann die Tests einfach in diesen Simulator einf√ºgen und √ºberpr√ºfen, wie sie sich verhalten, und Sie k√∂nnen die Gr√ºnde sp√§ter herausfinden.  Versuch und Irrtum, Baby! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>‚Äì<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">einen Monitorsimulator</a> herunterladen und verschiedene Zeitberechnungsmethoden unabh√§ngig voneinander √ºberpr√ºfen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Mailen Sie mir,</a> wenn Sie etwas Besseres finden. <br><br>  Ich bin nicht 100% zufrieden mit meiner Entscheidung (es erfordert immer noch einen Hack mit "vsync-Erkennung" und gelegentliches Ruckeln kann w√§hrend der Desynchronisation auftreten), aber ich glaube, dass dies fast so gut ist wie der Versuch, einen Spielzyklus mit einem festen Schritt zu implementieren.  Ein Teil dieses Problems entsteht, weil es sehr schwierig ist, die Parameter dessen zu bestimmen, was hier als "akzeptabel" angesehen wird.  Die Hauptschwierigkeit liegt im Kompromiss zwischen Zeitverschiebung und doppelt / √ºbersprungenen Frames.  Wenn Sie ein 60-Hz-Spiel auf einem 50-Hz-PAL-Monitor ausf√ºhren ... was ist dann die richtige Entscheidung?  M√∂chten Sie wildes Ruckeln oder ein merklich langsameres Spiel?  Beide Optionen scheinen schlecht zu sein. <br><br><h3>  Separates Rendern </h3><br>  In fr√ºheren Methoden habe ich beschrieben, was ich als "Lockstep-Rendering" bezeichne.  Das Spiel aktualisiert seinen Status, rendert dann und zeigt beim Rendern immer den neuesten Status des Spiels an.  Rendern und Aktualisieren sind miteinander verbunden. <br><br>  Aber Sie k√∂nnen sie trennen.  Dies ist genau das, was die im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Beitrag</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " beschriebene Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">bewirkt</a> .  Ich werde mich nicht wiederholen, du solltest diesen Beitrag unbedingt lesen.  Dies ist (wie ich es verstehe) der ‚ÄûIndustriestandard‚Äú, der in AAA-Spielen und Engines wie Unity und Unreal verwendet wird (in intensiven aktiven 2D-Spielen bevorzugen sie jedoch normalerweise die Verwendung eines festen Schritts (Lockstep), da manchmal die Genauigkeit, die Sie erhalten diese Methode). <br><br>  Wenn wir jedoch Glenns Beitrag kurz beschreiben, beschreibt er einfach die Aktualisierungsmethode mit einer festen Bildrate. Beim Rendern wird jedoch eine Interpolation zwischen dem aktuellen und dem vorherigen Status des Spiels durchgef√ºhrt und der aktuelle Batteriewert als Interpolationswert verwendet.  Mit dieser Methode k√∂nnen Sie mit jeder Bildrate rendern und das Spiel mit jeder Frequenz aktualisieren, und das Bild ist immer glatt.  Kein Ruckeln, funktioniert universell. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  Also elementar.  Das Problem ist gel√∂st. <br><br>  Jetzt m√ºssen Sie nur noch sicherstellen, dass das Spiel die interpolierten Zust√§nde wiedergeben kann ... aber Moment mal, es ist wirklich gar nicht so einfach.  In Glenns Beitrag wird einfach angenommen, dass dies m√∂glich ist.  Es ist leicht genug, die vorherige Position des Spielobjekts zwischenzuspeichern und seine Bewegungen zu interpolieren, aber der Spielstatus ist viel mehr als das.  Es ist notwendig, den Zustand der Animation, die Schaffung und Zerst√∂rung von Objekten und eine Reihe von Dingen zu ber√ºcksichtigen. <br><br>  Au√üerdem m√ºssen Sie in der Logik des Spiels ber√ºcksichtigen, ob das Objekt teleportiert wird oder ob es reibungslos bewegt werden muss, damit der Interpolator keine falschen Annahmen √ºber den Pfad des Spielobjekts zu seiner aktuellen Position macht.  Bei Drehungen kann echtes Chaos auftreten, insbesondere wenn sich die Drehung eines Objekts in einem Frame um mehr als 180 Grad √§ndern kann.  Und wie werden erstellte und zerst√∂rte Objekte richtig verarbeitet? <br><br>  Im Moment arbeite ich gerade an dieser Aufgabe in meinem Motor.  Tats√§chlich interpoliere ich nur die Bewegungen und lasse alles andere so wie es ist.  Sie werden kein Ruckeln bemerken, wenn sich das Objekt nicht reibungslos bewegt. Daher wird das √úberspringen von Animationsframes und das Synchronisieren der Erstellung / Zerst√∂rung des Objekts bis zu einem Frame kein Problem, wenn alles andere reibungslos ausgef√ºhrt wird. <br><br>  Es ist jedoch seltsam, dass diese Methode das Spiel tats√§chlich in einen Zustand versetzt, der um 1 Zustand des Spiels versp√§tet ist, von dem aus sich die Simulation jetzt befindet.  Dies ist unauff√§llig, kann jedoch mit anderen Verz√∂gerungsquellen in Verbindung gebracht werden, z. B. Eingangsverz√∂gerungen und Aktualisierungsraten. Daher werden diejenigen, die das reaktionsschnellste Gameplay ben√∂tigen (ich spreche von Ihnen, Speedrunner), h√∂chstwahrscheinlich die Verwendung von Lockstep im Spiel bevorzugen. <br><br>  In meinem Motor gebe ich nur eine Wahl.  Wenn Sie einen 60-Hertz-Monitor und einen schnellen Computer haben, ist es am besten, Lockstep mit aktiviertem vsync zu verwenden.  Wenn der Monitor eine nicht standardm√§√üige Bildwiederholfrequenz aufweist oder Ihr schwacher Computer nicht st√§ndig 60 Bilder pro Sekunde rendern kann, aktivieren Sie die Bildinterpolation.  Ich m√∂chte diese Option "Framerate entsperren" nennen, aber die Leute denken vielleicht, dass dies einfach "diese Option aktivieren, wenn Sie einen guten Computer haben" bedeutet.  Dieses Problem kann jedoch sp√§ter gel√∂st werden. <br><br>  Tats√§chlich gibt <i>es eine</i> Methode, um dieses Problem zu umgehen. <br><br><h3>  Variable Zeitschrittaktualisierungen </h3><br>  Viele Leute fragten mich, warum man das Spiel nicht einfach mit einem variablen Zeitschritt aktualisiert, und theoretische Programmierer sagen oft: "Wenn das Spiel RICHTIG geschrieben ist, kann man es einfach mit einem beliebigen Zeitschritt aktualisieren." <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  Keine Kuriosit√§ten mit Timings.  Kein seltsames Interpolations-Rendering.  Alles ist einfach, alles funktioniert. <br><br>  Also elementar.  Das Problem ist gel√∂st.  Und jetzt f√ºr immer!  Es ist unm√∂glich, ein besseres Ergebnis zu erzielen! <br><br>  Jetzt ist es einfach genug, die Spiellogik mit einem beliebigen Zeitschritt zum Laufen zu bringen.  Es ist ganz einfach, ersetzen Sie einfach den gesamten Code: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  dazu: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  und ersetzen Sie den folgenden Code: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  dazu: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  und ersetzen Sie den folgenden Code: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  dazu: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... also warte <br><br>  Woher kam das alles? <br><br>  Der letzte Teil wird buchst√§blich aus dem Hilfscode meines Motors kopiert, der "wirklich korrekte, bildratenunabh√§ngige Bewegung mit reibungsbegrenzender Geschwindigkeit" ausf√ºhrt.  Es ist ein bisschen M√ºll drin (diese Multiplikationen und Divisionen durch 60).  Dies ist jedoch die ‚Äûrichtige‚Äú Version des Codes mit einem variablen Zeitschritt f√ºr das vorherige Fragment.  Ich habe es √ºber eine Stunde lang mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Wolfram Alpha herausgefunden</a> . <br><br>  Jetzt fragen sie mich vielleicht, warum sie es nicht so machen: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  Und obwohl es zu funktionieren scheint, ist es tats√§chlich falsch, dies zu tun.  Sie k√∂nnen es selbst √ºberpr√ºfen.  F√ºhren Sie zwei Aktualisierungen mit deltaTime = 1 und anschlie√üend eine Aktualisierung mit deltaTime = 2 durch. Die Ergebnisse sind unterschiedlich.  Normalerweise bem√ºhen wir uns, dass das Spiel zusammenarbeitet, daher sind solche Diskrepanzen nicht erw√ºnscht.  Dies ist wahrscheinlich eine ausreichend gute L√∂sung, wenn Sie sicher sind, dass deltaTime immer ungef√§hr einem Wert entspricht, Sie dann jedoch Code schreiben m√ºssen, um sicherzustellen, dass Aktualisierungen mit einer konstanten H√§ufigkeit durchgef√ºhrt werden und ... ja.  Das ist richtig, jetzt versuchen wir alles "RICHTIG" zu machen. <br><br>  Wenn sich solch ein winziger Code zu monstr√∂sen mathematischen Berechnungen entfaltet, stellen Sie sich komplexere Bewegungsmuster vor, an denen viele interagierende Objekte beteiligt sind, und dergleichen.  Jetzt k√∂nnen Sie deutlich sehen, dass die ‚Äûrichtige‚Äú L√∂sung nicht realisierbar ist.  Das Maximum, das wir erreichen k√∂nnen, ist eine ‚Äûgrobe Ann√§herung‚Äú.  Vergessen wir es jetzt und nehmen wir an, dass wir tats√§chlich eine ‚Äûwirklich korrekte‚Äú Version der Bewegungsfunktionen haben.  Gro√üartig, richtig? <br><br>  Nein eigentlich.  Hier ist ein reales Beispiel f√ºr das Problem, das ich damit in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Bombernauts hatte</a> .  Ein Spieler kann ungef√§hr 1 Pl√§ttchen abprallen lassen, und das Spiel findet in einem Blockraster auf 1 Pl√§ttchen statt.  Um auf einem Block zu landen, m√ºssen sich die Beine des Charakters √ºber die Oberseite des Blocks erheben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  Da die Erkennung von Kollisionen hier jedoch mit einem diskreten Schritt erfolgt, erreichen die Beine bei einer niedrigen Bildrate manchmal nicht die Oberfl√§che des Pl√§ttchens, obwohl sie der gleichen Bewegungskurve folgen, und anstatt den Spieler anzuheben, rutschen sie von der Wand. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  Offensichtlich ist dieses Problem l√∂sbar.  Es zeigt jedoch die Arten von Problemen, auf die wir sto√üen, wenn wir versuchen, die Arbeit des Spielzyklus mit einem variablen Zeitschritt korrekt umzusetzen.  Wir verlieren Koh√§renz und Determinismus, daher m√ºssen wir die Wiedergabefunktionen des Spiels beseitigen, indem wir die Eingaben des Spielers, den deterministischen Mehrspielermodus und dergleichen aufzeichnen.  F√ºr reflexbasierte schnelle 2D-Spiele ist Konsistenz √§u√üerst wichtig (und nochmals Hallo, um L√§ufer zu beschleunigen). <br><br>  Wenn Sie versuchen, die Zeitschritte so anzupassen, dass sie weder zu gro√ü noch zu klein sind, verlieren Sie den Hauptvorteil des variablen Zeitschritts und k√∂nnen die beiden anderen hier beschriebenen Methoden sicher anwenden.  Das Spiel ist die Kerze nicht wert.  Die Spiellogik (die Implementierung der korrekten Bewegungsmathematik) erfordert zu viel zus√§tzlichen Aufwand, und im Bereich des Determinismus und der Konsistenz werden zu viele Opfer ben√∂tigt.  Ich w√ºrde diese Methode nur f√ºr ein musikalisches Rhythmus-Spiel verwenden (bei dem die Bewegungsgleichungen einfach sind und maximale Reaktionsf√§higkeit und Geschmeidigkeit erfordern).  In allen anderen F√§llen werde ich ein festes Update w√§hlen. <br><br><hr><br><h3>  Fazit </h3><br>  Jetzt wissen Sie, wie Sie das Spiel mit einer konstanten Frequenz von 60 fps zum Laufen bringen.  Dies ist trivial einfach und niemand sollte ein Problem damit haben.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine weiteren Probleme,</a> die diese Aufgabe erschweren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442528/">https://habr.com/ru/post/de442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442518/index.html">Top 10 Web-Hacking-Techniken 2018</a></li>
<li><a href="../de442520/index.html">Fall. Einsparung von 300 000 p. pro Monat auf kontextbezogene Werbung</a></li>
<li><a href="../de442522/index.html">Intuitives RL (Reinforcement Learning): Einf√ºhrung in Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../de442524/index.html">So erh√∂hen Sie die Sicherheit von Personalidentifikations- und Zugangskontrollsystemen</a></li>
<li><a href="../de442526/index.html">Die Geschichte der sowjetischen Kassettenrekorder (Teil 2): ‚Äã‚Äãder Boom von Walkmen, ein Ger√§t f√ºr den KGB und Tonbandger√§te</a></li>
<li><a href="../de442530/index.html">Wireshark 3.0.0: √úberpr√ºfung von Innovationen</a></li>
<li><a href="../de442532/index.html">Videorecorder f√ºr die Video√ºberwachung - kostenlos</a></li>
<li><a href="../de442534/index.html">Sprint Review: Schei√üe bis gro√üartig</a></li>
<li><a href="../de442536/index.html">Anschlie√üen externer Postf√§cher an Zimbra</a></li>
<li><a href="../de442542/index.html">SmartMail Conf: Erste Mail.ru Mail-Konferenz zum maschinellen Lernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>