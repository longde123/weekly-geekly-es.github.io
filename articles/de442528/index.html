<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💲 ❇️ 🦌 Wie man das Spiel mit 60fps zum Laufen bringt 🕌 😛 🙍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stellen Sie sich das Problem vor: Sie haben ein Spiel und es muss mit 60 fps auf einem 60-Hz-Monitor funktionieren. Ihr Computer ist schnell genug zum...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie man das Spiel mit 60fps zum Laufen bringt</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442528/">  Stellen Sie sich das Problem vor: Sie haben ein Spiel und es muss mit 60 fps auf einem 60-Hz-Monitor funktionieren.  Ihr Computer ist schnell genug zum Rendern und Aktualisieren, um eine unbedeutende Zeit in Anspruch zu nehmen. Schalten Sie also vsync ein und schreiben Sie diese Spieleschleife: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { update(); render(); display(); }</code> </pre> <br>  Sehr einfach!  Jetzt arbeitet das Spiel mit 60 fps und alles läuft wie am Schnürchen.  Fertig.  Vielen Dank für das Lesen dieses Beitrags. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ae/57e/bf1/0ae57ebf1f1695e4ecbcafddcb4255bb.jpg"></div><br>  Nun, offensichtlich ist nicht alles so gut.  Was ist, wenn jemand einen schwachen Computer hat, der das Spiel nicht mit einer Geschwindigkeit rendern kann, die ausreicht, um 60 fps bereitzustellen?  Was wäre, wenn jemand einen dieser coolen neuen 144-Hertz-Monitore kaufen würde?  Was ist, wenn er vsync in den Treibereinstellungen deaktiviert hat? <br><a name="habracut"></a><br>  Sie könnten denken: Ich muss die Zeit irgendwo messen und ein Update mit der richtigen Häufigkeit bereitstellen.  Dies ist ganz einfach: Sammeln Sie einfach die Zeit in jedem Zyklus und aktualisieren Sie sie jedes Mal, wenn sie den Schwellenwert um 1/60 Sekunde überschreitet. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render(); display(); }</code> </pre> <br>  Fertig, nirgendwo einfacher.  Tatsächlich gibt es eine Reihe von Spielen, bei denen der Code im Wesentlichen so aussieht.  Das ist aber falsch.  Dies ist zum Einstellen des Timings geeignet, führt jedoch zu Problemen mit Ruckeln (Stottern) und anderen Fehlanpassungen.  Ein solches Problem ist sehr häufig: Frames werden nicht genau 1/60 Sekunde angezeigt;  Selbst wenn vsync aktiviert ist, gibt es in der Zeit, in der sie angezeigt werden (und in der Genauigkeit des Betriebssystem-Timers), immer ein kleines Rauschen.  Daher wird es Situationen geben, in denen Sie einen Frame rendern und das Spiel glaubt, dass die Zeit für die erneute Aktualisierung noch nicht gekommen ist (da der Akku nur einen winzigen Bruchteil hinterherhinkt). Daher wird derselbe Frame nur noch einmal wiederholt, aber jetzt ist das Spiel zu spät für den Frame und verdoppelt sich Update.  Hier ist das Zucken! <br><br>  Beim Googeln finden Sie mehrere vorgefertigte Lösungen, um dieses Zucken zu beseitigen.  Zum Beispiel kann ein Spiel eine Variable anstelle eines konstanten Zeitschritts verwenden und die Batterien im Zeitcode einfach ganz aufgeben.  Oder Sie können einen konstanten Zeitschritt mit einem interpolierenden Renderer implementieren, der in einem ziemlich bekannten Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " von Glenn Fielder beschrieben wird.  Oder Sie können den Timer-Code neu erstellen, damit er etwas flexibler ist, wie im Beitrag zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://web.archive.org/web/20171206005813/" rel="nofollow noopener">Frame-Timing-Problemen von</a> Slick Entertainment beschrieben (dieser Blog ist leider nicht mehr vorhanden). <br><br><hr><br><h3>  Fuzzy Timings </h3><br>  Die Slick Entertainment-Methode mit „Fuzzy Timings“ in meiner Engine war am einfachsten zu implementieren, da keine Änderungen in der Spielelogik und im Rendering erforderlich waren.  Also in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">The End is Nigh habe</a> ich es benutzt.  Es war genug, um es nur in den Motor einzusetzen.  Tatsächlich kann das Spiel einfach „etwas früher“ aktualisiert werden, um Probleme mit Timing-Fehlanpassungen zu vermeiden.  Wenn das Spiel vsync enthält, können Sie vsync nur als Haupttimer des Spiels verwenden und erhalten ein flüssiges Bild. <br><br>  So sieht der Update-Code jetzt aus (das Spiel kann mit 62 fps "funktionieren", verarbeitet aber immer noch jeden Zeitschritt so, als ob es mit 60 fps funktioniert. Ich verstehe nicht ganz, warum ich ihn einschränken soll, damit die Batteriewerte nicht unter 0 fallen, aber ohne Dieser Code funktioniert nicht.  Sie können es folgendermaßen interpretieren: „Das Spiel wird mit einem festen Schritt aktualisiert, wenn es im Intervall von 60 fps bis 62 fps gerendert wird.“ <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">62.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Wenn vsync aktiviert ist, kann das Spiel im Wesentlichen mit einer festen Tonhöhe arbeiten, die der Bildwiederholfrequenz des Monitors entspricht und ein flüssiges Bild liefert.  Das Hauptproblem hierbei ist, dass das Spiel bei deaktivierter vsync-Funktion <i>etwas</i> schneller funktioniert, der Unterschied jedoch so <i>gering</i> ist, dass niemand ihn bemerkt. <br><br>  Speedrunner.  Speedrunner werden es bemerken.  Kurz nach der Veröffentlichung des Spiels stellten sie fest, dass einige Leute auf den Speedran-Highscore-Listen schlechtere Reisezeiten hatten, aber es stellte sich heraus, dass es besser war als andere.  Der unmittelbare Grund dafür war das unklare Timing und die Unterbrechung von vsync im Spiel (oder 144-Hz-Monitoren).  Daher wurde klar, dass Sie diese Unschärfe deaktivieren müssen, wenn Sie vsync trennen. <br><br>  Oh, aber wir können immer noch nicht überprüfen, ob vsync deaktiviert ist.  Im Betriebssystem gibt es keine Aufrufe dafür, und obwohl wir von der Anwendung anfordern können, vsync zu aktivieren oder zu deaktivieren, hängt dies tatsächlich vollständig vom Betriebssystem und dem Grafiktreiber ab.  Das einzige, was getan werden kann, ist, eine Reihe von Frames zu rendern, die Ausführungszeit dieser Aufgabe zu messen und dann zu vergleichen, ob sie ungefähr dieselbe Zeit in Anspruch nehmen.  Genau das habe ich für <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">The End is Nigh</a> getan.  Wenn das Spiel kein vsync mit einer Frequenz von 60 Hz enthält, wird mit „strengen 60 fps“ auf den ursprünglichen Frame-Timer zurückgesetzt.  Außerdem habe ich der Konfigurationsdatei einen Parameter hinzugefügt, der das Spiel dazu zwingt, keine Unschärfe zu verwenden (hauptsächlich für Speedrunner, die eine genaue Zeit benötigen), und einen genauen Timer-Handler im Spiel hinzugefügt, der die Verwendung von Autosplitter ermöglicht (dies ist ein Skript, das mit einem Atomzeit-Timer arbeitet). <br><br>  Einige Benutzer beschwerten sich immer noch über das gelegentliche Ruckeln einzelner Frames, aber sie schienen so selten zu sein, dass sie durch Betriebssystemereignisse oder andere externe Gründe erklärt werden konnten.  Keine große Sache.  Richtig? <br><br>  Als ich kürzlich meinen Timer-Code durchgesehen habe, ist mir etwas Seltsames aufgefallen.  Die Batterie wurde verschoben, jeder Frame dauerte etwas länger als 1/60 Sekunde, so dass das Spiel von Zeit zu Zeit dachte, es sei zu spät für den Frame, und führte ein doppeltes Update durch.  Es stellte sich heraus, dass mein Monitor mit einer Frequenz von 59,94 Hz und nicht mit 60 Hz arbeitet.  Dies bedeutete, dass er alle 1000 Frames ein doppeltes Update durchführen musste, um „aufzuholen“.  Dies ist jedoch sehr einfach zu beheben - ändern Sie einfach das Intervall der zulässigen Bildfrequenzen (nicht von 60 auf 62, sondern von 59 auf 61). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Das oben beschriebene Problem mit getrennten vsync- und Hochfrequenzmonitoren besteht weiterhin, und es gilt dieselbe Lösung (Rollback auf strengen Timer, wenn der Monitor <i>nicht</i> um 60 vsync synchronisiert ist). <br><br>  Aber woher wissen Sie, ob dies die richtige Lösung ist?  Wie kann sichergestellt werden, dass es auf allen Computerkombinationen mit verschiedenen Monitortypen mit und ohne aktiviertem vsync usw. ordnungsgemäß funktioniert?  Es ist sehr schwierig, all diese Timerprobleme im Kopf im Auge zu behalten und zu verstehen, was die Desynchronisation, seltsame Schleifen und dergleichen verursacht. <br><br><h3>  Simulator überwachen </h3><br>  Beim Versuch, eine zuverlässige Lösung für das „Problem des 59,94-Hertz-Monitors“ zu finden, wurde mir klar, dass ich nicht nur Versuche und Fehlerprüfungen durchführen konnte, in der Hoffnung, eine zuverlässige Lösung zu finden.  Ich brauchte eine bequeme Möglichkeit, verschiedene Versuche zu testen, einen hochwertigen Timer zu schreiben, und eine einfache Möglichkeit, um zu überprüfen, ob es in verschiedenen Monitorkonfigurationen zu einem Ruckeln oder einer Zeitverschiebung kommt. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Der Monitorsimulator wird</a> in der Szene angezeigt.  Dies ist der „schmutzige und schnelle“ Code, den ich geschrieben habe, der den „Monitorbetrieb“ simuliert und mir im Wesentlichen eine Reihe von Zahlen zeigt, die eine Vorstellung von der Stabilität jedes getesteten Timers geben. <br><br>  Für den einfachsten Timer werden beispielsweise die folgenden Werte ab dem Anfang des Artikels angezeigt: <br><br> <code>20211012021011202111020211102012012102012[...] <br> TOTAL UPDATES: 10001 <br> TOTAL VSYNCS: 10002 <br> TOTAL DOUBLE UPDATES: 2535 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.683 <br> SYSTEM TIME: 166.7</code> <br> <br>  Zunächst zeigt der Code für jedes emulierte vsync die Anzahl der "Aktualisierungen" des Spielzyklus nach dem vorherigen vsync an.  Alle anderen Werte als durchgehend 1 führen zu einem zuckenden Bild.  Am Ende zeigt der Code die akkumulierten Statistiken an. <br><br>  Bei Verwendung des „Fuzzy-Timers“ (mit einem Intervall von 60 bis 62 fps) auf einem 59,94-Hertz-Monitor zeigt der Code Folgendes an: <br><br> <code>111111111111111111111111111111111111111111111[...] <br> TOTAL UPDATES: 10000 <br> TOTAL VSYNCS: 9991 <br> TOTAL DOUBLE UPDATES: 10 <br> TOTAL SKIPPED RENDERS: 0 <br> GAME TIME: 166.667 <br> SYSTEM TIME: 166.683</code> <br> <br>  Das Ruckeln des Rahmens ist sehr selten, so dass es bei einer solchen Zahl von 1 schwierig sein kann, es zu bemerken. Die angezeigten Statistiken zeigen jedoch deutlich, dass das Spiel hier mehrere doppelte Aktualisierungen durchgeführt hat, was zu Ruckeln führt.  In der festen Version (mit einem Intervall von 59 bis 61 fps) werden 0 übersprungen oder doppelt aktualisiert. <br><br>  Sie können vsync auch deaktivieren.  Der Rest der Statistikdaten wird unwichtig, aber dies zeigt mir deutlich die Größe der „Zeitverschiebung“ (die Systemzeitverschiebung relativ zu dem Ort, an dem die Spielzeit sein sollte). <br><br> <code>GAME TIME: 166.667 <br> SYSTEM TIME: 169.102</code> <br> <br>  Wenn vsync deaktiviert ist, müssen Sie daher zu einem strengen Timer wechseln, da sich diese Diskrepanzen sonst im Laufe der Zeit ansammeln. <br><br>  Wenn ich die Renderzeit auf .02 setze (dh zum Rendern wird „mehr als ein Frame“ benötigt), bekomme ich ein Zucken.  Idealerweise sollte das Spielmuster wie 202020202020 aussehen, ist aber etwas ungleichmäßig. <br><br>  In dieser Situation verhält sich dieser Timer etwas besser als der vorherige, aber es wird verwirrender und schwieriger herauszufinden, wie und warum er funktioniert.  Aber ich kann die Tests einfach in diesen Simulator einfügen und überprüfen, wie sie sich verhalten, und Sie können die Gründe später herausfinden.  Versuch und Irrtum, Baby! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">61.0</span></span>){ simulate_update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(accumulator &lt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">59.0</span></span>–<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>) accumulator = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Sie können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">einen Monitorsimulator</a> herunterladen und verschiedene Zeitberechnungsmethoden unabhängig voneinander überprüfen.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Mailen Sie mir,</a> wenn Sie etwas Besseres finden. <br><br>  Ich bin nicht 100% zufrieden mit meiner Entscheidung (es erfordert immer noch einen Hack mit "vsync-Erkennung" und gelegentliches Ruckeln kann während der Desynchronisation auftreten), aber ich glaube, dass dies fast so gut ist wie der Versuch, einen Spielzyklus mit einem festen Schritt zu implementieren.  Ein Teil dieses Problems entsteht, weil es sehr schwierig ist, die Parameter dessen zu bestimmen, was hier als "akzeptabel" angesehen wird.  Die Hauptschwierigkeit liegt im Kompromiss zwischen Zeitverschiebung und doppelt / übersprungenen Frames.  Wenn Sie ein 60-Hz-Spiel auf einem 50-Hz-PAL-Monitor ausführen ... was ist dann die richtige Entscheidung?  Möchten Sie wildes Ruckeln oder ein merklich langsameres Spiel?  Beide Optionen scheinen schlecht zu sein. <br><br><h3>  Separates Rendern </h3><br>  In früheren Methoden habe ich beschrieben, was ich als "Lockstep-Rendering" bezeichne.  Das Spiel aktualisiert seinen Status, rendert dann und zeigt beim Rendern immer den neuesten Status des Spiels an.  Rendern und Aktualisieren sind miteinander verbunden. <br><br>  Aber Sie können sie trennen.  Dies ist genau das, was die im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Beitrag</a> " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Fix Your Timestep</a> " beschriebene Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">bewirkt</a> .  Ich werde mich nicht wiederholen, du solltest diesen Beitrag unbedingt lesen.  Dies ist (wie ich es verstehe) der „Industriestandard“, der in AAA-Spielen und Engines wie Unity und Unreal verwendet wird (in intensiven aktiven 2D-Spielen bevorzugen sie jedoch normalerweise die Verwendung eines festen Schritts (Lockstep), da manchmal die Genauigkeit, die Sie erhalten diese Methode). <br><br>  Wenn wir jedoch Glenns Beitrag kurz beschreiben, beschreibt er einfach die Aktualisierungsmethode mit einer festen Bildrate. Beim Rendern wird jedoch eine Interpolation zwischen dem aktuellen und dem vorherigen Status des Spiels durchgeführt und der aktuelle Batteriewert als Interpolationswert verwendet.  Mit dieser Methode können Sie mit jeder Bildrate rendern und das Spiel mit jeder Frequenz aktualisieren, und das Bild ist immer glatt.  Kein Ruckeln, funktioniert universell. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running){ computeDeltaTimeSomehow(); accumulator += deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(accumulator &gt;= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>){ previous_state = current_state; current_state = update(); accumulator -= <span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>; } render_interpolated_somehow(previous_state, current_state, accumulator/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>)); display(); }</code> </pre> <br>  Also elementar.  Das Problem ist gelöst. <br><br>  Jetzt müssen Sie nur noch sicherstellen, dass das Spiel die interpolierten Zustände wiedergeben kann ... aber Moment mal, es ist wirklich gar nicht so einfach.  In Glenns Beitrag wird einfach angenommen, dass dies möglich ist.  Es ist leicht genug, die vorherige Position des Spielobjekts zwischenzuspeichern und seine Bewegungen zu interpolieren, aber der Spielstatus ist viel mehr als das.  Es ist notwendig, den Zustand der Animation, die Schaffung und Zerstörung von Objekten und eine Reihe von Dingen zu berücksichtigen. <br><br>  Außerdem müssen Sie in der Logik des Spiels berücksichtigen, ob das Objekt teleportiert wird oder ob es reibungslos bewegt werden muss, damit der Interpolator keine falschen Annahmen über den Pfad des Spielobjekts zu seiner aktuellen Position macht.  Bei Drehungen kann echtes Chaos auftreten, insbesondere wenn sich die Drehung eines Objekts in einem Frame um mehr als 180 Grad ändern kann.  Und wie werden erstellte und zerstörte Objekte richtig verarbeitet? <br><br>  Im Moment arbeite ich gerade an dieser Aufgabe in meinem Motor.  Tatsächlich interpoliere ich nur die Bewegungen und lasse alles andere so wie es ist.  Sie werden kein Ruckeln bemerken, wenn sich das Objekt nicht reibungslos bewegt. Daher wird das Überspringen von Animationsframes und das Synchronisieren der Erstellung / Zerstörung des Objekts bis zu einem Frame kein Problem, wenn alles andere reibungslos ausgeführt wird. <br><br>  Es ist jedoch seltsam, dass diese Methode das Spiel tatsächlich in einen Zustand versetzt, der um 1 Zustand des Spiels verspätet ist, von dem aus sich die Simulation jetzt befindet.  Dies ist unauffällig, kann jedoch mit anderen Verzögerungsquellen in Verbindung gebracht werden, z. B. Eingangsverzögerungen und Aktualisierungsraten. Daher werden diejenigen, die das reaktionsschnellste Gameplay benötigen (ich spreche von Ihnen, Speedrunner), höchstwahrscheinlich die Verwendung von Lockstep im Spiel bevorzugen. <br><br>  In meinem Motor gebe ich nur eine Wahl.  Wenn Sie einen 60-Hertz-Monitor und einen schnellen Computer haben, ist es am besten, Lockstep mit aktiviertem vsync zu verwenden.  Wenn der Monitor eine nicht standardmäßige Bildwiederholfrequenz aufweist oder Ihr schwacher Computer nicht ständig 60 Bilder pro Sekunde rendern kann, aktivieren Sie die Bildinterpolation.  Ich möchte diese Option "Framerate entsperren" nennen, aber die Leute denken vielleicht, dass dies einfach "diese Option aktivieren, wenn Sie einen guten Computer haben" bedeutet.  Dieses Problem kann jedoch später gelöst werden. <br><br>  Tatsächlich gibt <i>es eine</i> Methode, um dieses Problem zu umgehen. <br><br><h3>  Variable Zeitschrittaktualisierungen </h3><br>  Viele Leute fragten mich, warum man das Spiel nicht einfach mit einem variablen Zeitschritt aktualisiert, und theoretische Programmierer sagen oft: "Wenn das Spiel RICHTIG geschrieben ist, kann man es einfach mit einem beliebigen Zeitschritt aktualisieren." <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(running) { deltaTime = CurrentTime()-OldTime; oldTime = CurrentTime(); update(deltaTime); render(); display(); }</code> </pre> <br>  Keine Kuriositäten mit Timings.  Kein seltsames Interpolations-Rendering.  Alles ist einfach, alles funktioniert. <br><br>  Also elementar.  Das Problem ist gelöst.  Und jetzt für immer!  Es ist unmöglich, ein besseres Ergebnis zu erzielen! <br><br>  Jetzt ist es einfach genug, die Spiellogik mit einem beliebigen Zeitschritt zum Laufen zu bringen.  Es ist ganz einfach, ersetzen Sie einfach den gesamten Code: <br><br><pre> <code class="cpp hljs">position += speed;</code> </pre> <br>  dazu: <br><br><pre> <code class="cpp hljs">position += speed * deltaTime;</code> </pre> <br>  und ersetzen Sie den folgenden Code: <br><br><pre> <code class="cpp hljs">speed += acceleration; position += speed;</code> </pre> <br>  dazu: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; position += speed * deltaTime;</code> </pre> <br>  und ersetzen Sie den folgenden Code: <br><br><pre> <code class="cpp hljs">speed += acceleration; speed *= friction; position += speed;</code> </pre> <br>  dazu: <br><br><pre> <code class="cpp hljs">Vec3D p0 = position; Vec3D v0 = velocity; Vec3D a = acceleration*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> f = friction; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> n = dt*<span class="hljs-number"><span class="hljs-number">60</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> fN = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, n); position = p0 + ((f*(a*(f*fN-f*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>)+n)+(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*v0*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)))/((f<span class="hljs-number"><span class="hljs-number">-1</span></span>)*(f<span class="hljs-number"><span class="hljs-number">-1</span></span>)))*(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">60.0</span></span>); velocity = v0*fN+a*(f*(fN<span class="hljs-number"><span class="hljs-number">-1</span></span>)/(f<span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br>  ... also warte <br><br>  Woher kam das alles? <br><br>  Der letzte Teil wird buchstäblich aus dem Hilfscode meines Motors kopiert, der "wirklich korrekte, bildratenunabhängige Bewegung mit reibungsbegrenzender Geschwindigkeit" ausführt.  Es ist ein bisschen Müll drin (diese Multiplikationen und Divisionen durch 60).  Dies ist jedoch die „richtige“ Version des Codes mit einem variablen Zeitschritt für das vorherige Fragment.  Ich habe es über eine Stunde lang mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Wolfram Alpha herausgefunden</a> . <br><br>  Jetzt fragen sie mich vielleicht, warum sie es nicht so machen: <br><br><pre> <code class="cpp hljs">speed += acceleration * deltaTime; speed *= <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(friction, deltaTime); position += speed * deltaTime;</code> </pre> <br>  Und obwohl es zu funktionieren scheint, ist es tatsächlich falsch, dies zu tun.  Sie können es selbst überprüfen.  Führen Sie zwei Aktualisierungen mit deltaTime = 1 und anschließend eine Aktualisierung mit deltaTime = 2 durch. Die Ergebnisse sind unterschiedlich.  Normalerweise bemühen wir uns, dass das Spiel zusammenarbeitet, daher sind solche Diskrepanzen nicht erwünscht.  Dies ist wahrscheinlich eine ausreichend gute Lösung, wenn Sie sicher sind, dass deltaTime immer ungefähr einem Wert entspricht, Sie dann jedoch Code schreiben müssen, um sicherzustellen, dass Aktualisierungen mit einer konstanten Häufigkeit durchgeführt werden und ... ja.  Das ist richtig, jetzt versuchen wir alles "RICHTIG" zu machen. <br><br>  Wenn sich solch ein winziger Code zu monströsen mathematischen Berechnungen entfaltet, stellen Sie sich komplexere Bewegungsmuster vor, an denen viele interagierende Objekte beteiligt sind, und dergleichen.  Jetzt können Sie deutlich sehen, dass die „richtige“ Lösung nicht realisierbar ist.  Das Maximum, das wir erreichen können, ist eine „grobe Annäherung“.  Vergessen wir es jetzt und nehmen wir an, dass wir tatsächlich eine „wirklich korrekte“ Version der Bewegungsfunktionen haben.  Großartig, richtig? <br><br>  Nein eigentlich.  Hier ist ein reales Beispiel für das Problem, das ich damit in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener">Bombernauts hatte</a> .  Ein Spieler kann ungefähr 1 Plättchen abprallen lassen, und das Spiel findet in einem Blockraster auf 1 Plättchen statt.  Um auf einem Block zu landen, müssen sich die Beine des Charakters über die Oberseite des Blocks erheben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/956/eff/806/956eff806c65598bd694f6bc81713c1c.png"></div><br>  Da die Erkennung von Kollisionen hier jedoch mit einem diskreten Schritt erfolgt, erreichen die Beine bei einer niedrigen Bildrate manchmal nicht die Oberfläche des Plättchens, obwohl sie der gleichen Bewegungskurve folgen, und anstatt den Spieler anzuheben, rutschen sie von der Wand. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5ad/ab7/cfc/5adab7cfc0abca780385cb3da53d63e5.png"></div><br>  Offensichtlich ist dieses Problem lösbar.  Es zeigt jedoch die Arten von Problemen, auf die wir stoßen, wenn wir versuchen, die Arbeit des Spielzyklus mit einem variablen Zeitschritt korrekt umzusetzen.  Wir verlieren Kohärenz und Determinismus, daher müssen wir die Wiedergabefunktionen des Spiels beseitigen, indem wir die Eingaben des Spielers, den deterministischen Mehrspielermodus und dergleichen aufzeichnen.  Für reflexbasierte schnelle 2D-Spiele ist Konsistenz äußerst wichtig (und nochmals Hallo, um Läufer zu beschleunigen). <br><br>  Wenn Sie versuchen, die Zeitschritte so anzupassen, dass sie weder zu groß noch zu klein sind, verlieren Sie den Hauptvorteil des variablen Zeitschritts und können die beiden anderen hier beschriebenen Methoden sicher anwenden.  Das Spiel ist die Kerze nicht wert.  Die Spiellogik (die Implementierung der korrekten Bewegungsmathematik) erfordert zu viel zusätzlichen Aufwand, und im Bereich des Determinismus und der Konsistenz werden zu viele Opfer benötigt.  Ich würde diese Methode nur für ein musikalisches Rhythmus-Spiel verwenden (bei dem die Bewegungsgleichungen einfach sind und maximale Reaktionsfähigkeit und Geschmeidigkeit erfordern).  In allen anderen Fällen werde ich ein festes Update wählen. <br><br><hr><br><h3>  Fazit </h3><br>  Jetzt wissen Sie, wie Sie das Spiel mit einer konstanten Frequenz von 60 fps zum Laufen bringen.  Dies ist trivial einfach und niemand sollte ein Problem damit haben.  Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine weiteren Probleme,</a> die diese Aufgabe erschweren. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de442528/">https://habr.com/ru/post/de442528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de442518/index.html">Top 10 Web-Hacking-Techniken 2018</a></li>
<li><a href="../de442520/index.html">Fall. Einsparung von 300 000 p. pro Monat auf kontextbezogene Werbung</a></li>
<li><a href="../de442522/index.html">Intuitives RL (Reinforcement Learning): Einführung in Advantage-Actor-Critic (A2C)</a></li>
<li><a href="../de442524/index.html">So erhöhen Sie die Sicherheit von Personalidentifikations- und Zugangskontrollsystemen</a></li>
<li><a href="../de442526/index.html">Die Geschichte der sowjetischen Kassettenrekorder (Teil 2): ​​der Boom von Walkmen, ein Gerät für den KGB und Tonbandgeräte</a></li>
<li><a href="../de442530/index.html">Wireshark 3.0.0: Überprüfung von Innovationen</a></li>
<li><a href="../de442532/index.html">Videorecorder für die Videoüberwachung - kostenlos</a></li>
<li><a href="../de442534/index.html">Sprint Review: Scheiße bis großartig</a></li>
<li><a href="../de442536/index.html">Anschließen externer Postfächer an Zimbra</a></li>
<li><a href="../de442542/index.html">SmartMail Conf: Erste Mail.ru Mail-Konferenz zum maschinellen Lernen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>