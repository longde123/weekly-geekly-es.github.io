<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧠 🤥 👘 Solución numérica de modelos matemáticos de objetos dados por sistemas de ecuaciones diferenciales. 🙏🏿 🧦 💑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introducción 
 En el modelado matemático de varios dispositivos técnicos, se utilizan sistemas de ecuaciones diferenciales no lineales. Dichos modelos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solución numérica de modelos matemáticos de objetos dados por sistemas de ecuaciones diferenciales.</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418139/"><h3>  Introducción </h3><br>  En el modelado matemático de varios dispositivos técnicos, se utilizan sistemas de ecuaciones diferenciales no lineales.  Dichos modelos se utilizan no solo en tecnología, sino también en economía, química, biología, medicina y gestión. <br><br>  El estudio del funcionamiento de tales dispositivos requiere la solución de estos sistemas de ecuaciones.  Dado que la mayor parte de tales ecuaciones son no lineales y no estacionarias, a menudo es imposible obtener su solución analítica. <br><br>  Es necesario utilizar métodos numéricos, el más famoso de los cuales es el método Runge - Kutta [1].  En cuanto a Python, en publicaciones sobre métodos numéricos, por ejemplo [2,3], hay muy pocos datos sobre el uso de Runge - Kutta, y no hay datos sobre su modificación al método Runge - Kutta - Felberg. <br><br>  Actualmente, gracias a su interfaz simple, la función odeint del módulo scipy.integrate tiene la mayor distribución en Python.  La segunda función oda de este módulo implementa varios métodos, incluido el método Runge-Kutta-Felberg de cinco rangos mencionado, pero, debido a su universalidad, tiene un rendimiento limitado. <br><br>  El propósito de esta publicación es un análisis comparativo de los medios listados para resolver numéricamente sistemas de ecuaciones diferenciales con un autor modificado bajo Python usando el método Runge-Kutta-Felberg.  La publicación también proporciona soluciones a problemas de valor límite para sistemas de ecuaciones diferenciales (SDE). <br><a name="habracut"></a><br><h3>  Breves datos teóricos y reales sobre los métodos y software considerados para la solución numérica de CDS </h3><br>  <b>El problema de Cauchy</b> <br><br>  Para una ecuación diferencial del enésimo orden, el problema de Cauchy consiste en encontrar una función que satisfaga la igualdad: <br><br><img src="https://habrastorage.org/webt/lt/b1/2t/ltb12ttbaok7cykpov2wr1ll2d8.png"><br><br>  y condiciones iniciales <br><br><img src="https://habrastorage.org/webt/wu/hv/h6/wuhvh6vc6lvhbtjv9cpdt2ngwpk.png"><br><br>  Antes de resolver este problema debe reescribirse en la forma de los siguientes CDS <br><br><img src="https://habrastorage.org/webt/of/ae/6d/ofae6da97foimjlsgplerdbgmw4.png">  (1) <br><br>  con condiciones iniciales <br><br><img src="https://habrastorage.org/webt/5h/yr/dx/5hyrdxv0rgrvdlb_wfqcx-xu8yc.png"><br><br>  <b>Scipy.integrate module</b> <br><br>  El módulo tiene dos funciones ode () y odeint (), diseñadas para resolver sistemas de ecuaciones diferenciales ordinarias (ODE) de primer orden con condiciones iniciales en un punto (problema de Cauchy).  La función ode () es más universal, y la función odeint () (integrador ODE) tiene una interfaz más simple y resuelve bien la mayoría de los problemas. <br><br>  <b>Función Odeint ()</b> <br><br>  La función odeint () tiene tres argumentos obligatorios y muchas opciones.  Tiene el siguiente formato odeint (func, y0, t [, args = (), ...]) El argumento func es el nombre Python de la función de dos variables, la primera de las cuales es la lista y = [y1, y2, ..., yn ], y el segundo es el nombre de la variable independiente. <br><br>  La función Func debería devolver una lista de n valores de función <img src="https://habrastorage.org/webt/px/uq/ut/pxuqutrevt661xvfc3wxjldgvem.png">  para un valor dado del argumento independiente t.  De hecho, la función func (y, t) implementa el cálculo de los lados derechos del sistema (1). <br><br>  El segundo argumento y0 de odeint () es una matriz (o lista) de valores iniciales <img src="https://habrastorage.org/webt/el/kx/j9/elkxj9mf1tffldehq2mqdvbl0mi.png">  en t = t0. <br><br>  El tercer argumento es una serie de puntos de tiempo en los que desea obtener una solución al problema.  En este caso, el primer elemento de esta matriz se considera t0. <br><br>  La función odeint () devuelve una matriz de tamaño len (t) x len (y0).  La función odeint () tiene muchas opciones que controlan su funcionamiento.  Las opciones rtol (error relativo) y atol (error absoluto) determinan el error de cálculo ei para cada valor de yi de acuerdo con la fórmula <br><br><img src="https://habrastorage.org/webt/qq/3a/pp/qq3appk_s2ck4bvifmd7mozxqyi.png"><br><br>  Pueden ser vectores o escalares.  Por defecto <br><br><img src="https://habrastorage.org/webt/ha/lb/jo/halbjokez-c-a9ur0xeyp8pifew.png"><br><br>  <b>Función Ode ()</b> <br><br>  La segunda función del módulo scipy.integrate, que está diseñado para resolver ecuaciones y sistemas diferenciales, se llama ode ().  Crea un objeto ODE (tipo scipy.integrate._ode.ode).  Al tener un enlace a dicho objeto, uno debería usar sus métodos para resolver ecuaciones diferenciales.  De manera similar a la función odeint (), la función ode (func) implica reducir el problema a un sistema de ecuaciones diferenciales de la forma (1) y usar su función de los lados derechos. <br><br>  La única diferencia es que la función del lado derecho func (t, y) acepta una variable independiente como primer argumento, y la lista de valores de las funciones deseadas como segundo.  Por ejemplo, la siguiente secuencia de instrucciones crea un ODE que representa una tarea Cauchy. <br><br>  <b>Runge - Método Kutta</b> <br><br>  Al construir algoritmos numéricos, asumimos que existe una solución a este problema diferencial, que es única y tiene las propiedades de suavidad necesarias. <br><br>  En la solución numérica del problema de Cauchy <br><br><img src="https://habrastorage.org/webt/z6/sc/ag/z6scagau6_z8yjjazels3cibdlc.png">  (2) <br><br><img src="https://habrastorage.org/webt/cf/hp/p4/cfhpp4rxk8vhqnexgl3bgsaapeg.png">  (3) <br><br>  de acuerdo con la solución conocida en el punto t = 0, es necesario encontrar una solución de la ecuación (3) para otra t.  En la solución numérica del problema (2), (3), usaremos una cuadrícula uniforme, por simplicidad, en la variable t con un paso t&gt; 0. <br><br>  Una solución aproximada al problema (2), (3) en el punto <img src="https://habrastorage.org/webt/j-/lc/cf/j-lccfwyp5vjoipcxlykp3dgbik.png">  denotar <img src="https://habrastorage.org/webt/8s/g0/sj/8sg0sjhebyokeq5wuc7a8if2bqm.png">  .  El método converge en un punto <img src="https://habrastorage.org/webt/b-/x8/0p/b-x80p4onflflxhl2lk1vadl3sg.png">  si <img src="https://habrastorage.org/webt/ia/vi/8k/iavi8k482dcl150a2yxsd0gq-d0.png">  a las <img src="https://habrastorage.org/webt/6b/sp/hq/6bsphqn74wsy9wdcniq4nibexfg.png">  .  El método tiene un orden de precisión pth si <img src="https://habrastorage.org/webt/jv/xz/j1/jvxzj1hz0rgs3key_wcinzror84.png">  , p&gt; 0 para <img src="https://habrastorage.org/webt/6b/sp/hq/6bsphqn74wsy9wdcniq4nibexfg.png">  .  El esquema de diferencia más simple para una solución aproximada al problema (2), (3) es <br><br><img src="https://habrastorage.org/webt/ao/-x/nx/ao-xnxhl01dfeg2znuupnwjqci8.png">  (4) <br><br>  En <img src="https://habrastorage.org/webt/wn/xq/qq/wnxqqqiwt6jm375mk9jf2v0c_zs.png">  tenemos un método explícito y en este caso el esquema de diferencia se aproxima a la ecuación (2) con el primer orden.  Diseño simétrico <img src="https://habrastorage.org/webt/-t/sm/4h/-tsm4hzq9-agctksj5eahivdimq.png">  en (4) tiene un segundo orden de aproximación.  Este esquema pertenece a la clase de implícito: para determinar la solución aproximada en una nueva capa, es necesario resolver el problema no lineal. <br><br>  Es conveniente construir esquemas de aproximación explícitos de segundo y mayor orden basados ​​en el método predictor-corrector.  En la etapa del predictor (predicción), se utiliza un esquema explícito. <br><br><img src="https://habrastorage.org/webt/yw/lf/an/ywlfancnmqu4smvvqozydtuw6qw.png">  (5) <br><br>  y en la etapa correctora (refinamiento), un diagrama <br><br><img src="https://habrastorage.org/webt/vk/kx/sg/vkkxsg0mkht41hmefqo3krhkohw.png"><br><br>  En los métodos Runge - Kutta de un solo paso, las ideas del predictor-corrector se realizan más plenamente.  Este método está escrito en forma general: <br><br><img src="https://habrastorage.org/webt/ou/dj/vf/oudjvfblha8fbsfvflq3qucylb0.png">  (6) <br><br>  donde <br><br><img src="https://habrastorage.org/webt/of/gn/qh/ofgnqhxv2vlykcughxkzvvnzfm0.png"><br><br>  La fórmula (6) se basa en los cálculos de s de la función f y se llama s-stage.  Si <img src="https://habrastorage.org/webt/5b/3e/om/5b3eomem0-kklkzcgc2_hy5ibyu.png">  a las <img src="https://habrastorage.org/webt/ya/jx/d7/yajxd73qu-icfbj3_qte0sxoamk.png">  tenemos el método explícito Runge - Kutta.  Si <img src="https://habrastorage.org/webt/5b/3e/om/5b3eomem0-kklkzcgc2_hy5ibyu.png">  para j&gt; 1 y <img src="https://habrastorage.org/webt/sp/y9/l3/spy9l3eri4ug3bf4ec31kcqgjca.png">  entonces <img src="https://habrastorage.org/webt/m7/lj/ar/m7ljarovrnbr8ntzgbeekovygko.png">  determinado implícitamente a partir de la ecuación: <br><br><img src="https://habrastorage.org/webt/md/2l/xs/md2lxstmkruwswxkb4hwqk3ejrm.png">  (7) <br><br>  Se habla de este método Runge - Kutta como implícito en diagonal.  Parámetros <img src="https://habrastorage.org/webt/yo/ud/im/youdimr4t898rol5a4naafrjbrk.png">  determinar una variante del método Runge - Kutta.  Se utiliza la siguiente representación del método (tabla de carnicero) <br><br><img src="https://habrastorage.org/webt/qc/es/cx/qcescxh_lpjsra_3jqxghis4hz0.png"><br><br>  Uno de los más comunes es el método explícito de cuarto orden Runge - Kutta. <br><br><img src="https://habrastorage.org/webt/b_/xb/6b/b_xb6bte_wppykllazhykapnppu.png">  (8) <br><br>  <b>Runge - Kutta - Método Felberg</b> <br><br>  Doy el valor de los coeficientes calculados <img src="https://habrastorage.org/webt/m7/lj/ar/m7ljarovrnbr8ntzgbeekovygko.png">  método <br><br><img src="https://habrastorage.org/webt/y6/v7/yk/y6v7yk2b6dabo8cfcz86kcbys2o.png">  (9) <br><br>  En vista de (9), la solución general tiene la forma: <br><br><img src="https://habrastorage.org/webt/8w/dk/av/8wdkavmydgbm1e94gfcjnm_kavm.png">  (10) <br><br>  Esta solución proporciona el quinto orden de precisión, queda por adaptarlo a Python. <br><br><h4>  Experimento computacional para determinar el error absoluto de la solución numérica de una ecuación diferencial no lineal <img src="https://habrastorage.org/webt/ws/sh/r4/wsshr4edsklounxpocg4hd_mf70.png">  utilizando las funciones def odein (), def oden () del módulo scipy.integrate y los métodos Runge - Kutta y Runge - Kutta - Felberg adaptados a Python </h4><br><br><div class="spoiler">  <b class="spoiler_title">Listado de programa</b> <div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.integrate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">odein</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#dy1/dt=y2 #dy2/dt=y1**2+1: def f(y,t): return y**2+1 t =arange(0,1,0.01) y0 =0.0 y=odeint(f, y0,t) y = array(y).flatten() return y,t def oden(): f = lambda t, y: y**2+1 ODE=ode(f) ODE.set_integrator('dopri5') ODE.set_initial_value(0, 0) t=arange(0,1,0.01) z=[] t=arange(0,1,0.01) for i in arange(0,1,0.01): ODE.integrate(i) q=ODE.y z.append(q[0]) return z,t def rungeKutta(f, to, yo, tEnd, tau): def increment(f, t, y, tau): if z==1: k0 =tau* f(t,y) k1 =tau* f(t+tau/2.,y+k0/2.) k2 =tau* f(t+tau/2.,y+k1/2.) k3 =tau* f(t+tau, y + k2) return (k0 + 2.*k1 + 2.*k2 + k3) / 6. elif z==0: k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = [] y= [] t.append(to) y.append(yo) while to &lt; tEnd: tau = min(tau, tEnd - to) yo = yo + increment(f, to, yo, tau) to = to + tau t.append(to) y.append(yo) return array(t), array(y) def f(t, y): f = zeros([1]) f[0] = y[0]**2+1 return f to = 0. tEnd = 1 yo = array([0.]) tau = 0.01 z=1 t, yn = rungeKutta(f, to, yo, tEnd, tau) y1n=[i[0] for i in yn] plt.figure() plt.title("   (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") plt.plot(t,abs(array(y1n)-array(tan(t))),label=' — \n\   -   ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) z=0 t, ym = rungeKutta(f, to, yo, tEnd, tau) y1m=[i[0] for i in ym] plt.figure() plt.title("   (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") plt.plot(t,abs(array(y1m)-array(tan(t))),label=' ——  \n\   -   ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.figure() plt.title("    (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") y,t=odein() plt.plot(t,abs(array(tan(t))-array(y)),label=' odein') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.figure() plt.title("    (..- u(t)=tan(t)) \n\ du/dt=u**2+1 cu(0)=0  t&gt;0") z,t=oden() plt.plot(t,abs(tan(t)-z),label=' ode  ——  \n\  ') plt.xlabel('') plt.ylabel(' .') plt.legend(loc='best') plt.grid(True) plt.show()</span></span></code> </pre> <br></div></div><br>  Obtenemos: <br><br><img src="https://habrastorage.org/webt/rb/l6/-2/rbl6-2ookhhbihd9xnftqqknrc4.png"><br><br><img src="https://habrastorage.org/webt/od/pn/mp/odpnmp3qsgjttpzjikbu4ry34bk.png"><br><br><img src="https://habrastorage.org/webt/nt/vw/dv/ntvwdvd0hnwbgnfdgoox71in9pk.png"><br><br><img src="https://habrastorage.org/webt/-a/gl/os/-agloshtg1bvovezwdjex4ri2ac.png"><br><br>  <b>Conclusión</b> <br><br>  Los métodos Runge - Kutta y Runge - Kutta - Felberg adaptados a Python tienen un absoluto más bajo que una solución que usa la función odeint, pero más que una solución que usa la función edu.  Es necesario realizar un estudio de rendimiento. <br><br><h4>  Un experimento numérico que compara la velocidad de la solución numérica de la SDE cuando se usa la función oda con el atributo dopri5 (método Runge - Kutta de quinto orden) y se usa el método Runge - Kutta - Felberg adaptado a Python </h4><br><br>  Se realiza un análisis comparativo utilizando el problema modelo dado en [2] como ejemplo.  Para no repetir la fuente, presentaré la formulación y solución del problema modelo de [2]. <br><br>  Resolvamos el problema de Cauchy, que describe el movimiento de un cuerpo arrojado con una velocidad inicial v0 en un ángulo α con respecto al horizonte bajo el supuesto de que la resistencia del aire es proporcional al cuadrado de la velocidad.  En forma vectorial, la ecuación de movimiento tiene la forma <br><br><img src="https://habrastorage.org/webt/2a/9w/f5/2a9wf5a2_ckuhlu2mypbya1euow.png"><br><br>  donde <img src="https://habrastorage.org/webt/zi/gy/z5/zigyz50cgbqvfeos6rozby0xais.png">  Es el radio del vector del cuerpo en movimiento, <img src="https://habrastorage.org/webt/v_/7w/rm/v_7wrmvexfdj_3j7kfyobvy0omi.png">  Es el vector de velocidad del cuerpo, <img src="https://habrastorage.org/webt/_-/jq/rq/_-jqrqt-dvbznpe_4l8htdsfybw.png">  - coeficiente de arrastre, vector <img src="https://habrastorage.org/webt/px/au/zt/pxauztg_p8ldqkk3vuuzxgkzzhe.png">  fuerzas de peso corporal de masa m, g - aceleración de la gravedad. <br><br><img src="https://habrastorage.org/webt/ux/fy/xy/uxfyxyowu7xnhy-fvigwoeh436m.png"><br><br>  La peculiaridad de esta tarea es que el movimiento termina en un punto desconocido en el tiempo cuando el cuerpo cae al suelo.  Si designado <img src="https://habrastorage.org/webt/ud/6h/hh/ud6hhhzd7lyf71noe8hpdlyrexi.png">  , luego en forma de coordenadas tenemos un sistema de ecuaciones: <br><br><img src="https://habrastorage.org/webt/jh/dd/rr/jhddrrguuy07d9hw9x5gvcylo2u.png"><br><br>  Las condiciones iniciales deben agregarse al sistema: <img src="https://habrastorage.org/webt/tr/de/l-/trdel-vxwgw3oy1ryv0k1nafch0.png">  (h altura inicial) <img src="https://habrastorage.org/webt/-g/zd/ft/-gzdft1d38m6x4f6vryof4jlwuu.png">  .  Poner <img src="https://habrastorage.org/webt/l0/1r/cm/l01rcm17euagfjzj8gcet4xfhge.png">  .  Luego, el sistema ODE de primer orden correspondiente toma la forma: <br><br><img src="https://habrastorage.org/webt/nh/zg/r5/nhzgr5att8_fao3l-majsjgcm7k.png"><br><br>  Para el problema modelo ponemos <img src="https://habrastorage.org/webt/2s/20/ov/2s20ovmvcahufaxyhihjev7rm8g.png">  .  Omitiendo una descripción bastante extensa del programa, solo daré una lista de los comentarios para los cuales, creo, el principio de su funcionamiento será claro.  El programa ha agregado una cuenta regresiva para el análisis comparativo. <br><br><div class="spoiler">  <b class="spoiler_title">Listado de programa</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> scipy.integrate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ode ts = [ ] ys = [ ] FlightTime, Distance, Height =<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span> y4old=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t, y)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-comment"><span class="hljs-comment">#   global FlightTime, Distance, Height,y4old ts.append(t) ys.append(list(y.copy())) y1, y2, y3, y4 = y if y4*y4old&lt;=0: #    Height=y3 if y4&lt;0 and y3&lt;=0.0: #    FlightTime=t Distance=y1 return -1 y4old=y4 #      def f(t, y, k): #    k g=9.81 y1, y2, y3, y4 = y return [y2,-k*y2*np.sqrt(y2**2+y4**2), y4,-k*y4*np.sqrt(y2**2+y4**2)-g] tmax=1.41 #     alph=np.pi/4 #    v0=10.0 #   K=[0.1,0.2,0.3,0.5] #    y0,t0=[0, v0*np.cos(alph), 0, v0*np.sin(alph)], 0 #   ODE=ode(f) ODE.set_integrator('dopri5', max_step=0.01) ODE.set_solout(fout) fig, ax = plt.subplots() fig.set_facecolor('white') for k in K: #     ts, ys = [ ],[ ] ODE.set_initial_value(y0, t0) #    ODE.set_f_params(k) #    k #   f(t,y,k)     ODE.integrate(tmax) #   print('Flight time = %.4f Distance = %.4f Height =%.4f '% (FlightTime,Distance,Height)) Y=np.array(ys) plt.plot(Y[:,0],Y[:,2],linewidth=3,label='k=%.1f'% k) stop = time.time() plt.title("      \n    ode   dopri5 ") print ("   : %f"%(stop-start)) plt.grid(True) plt.xlim(0,8) plt.ylim(-0.1,2) plt.legend(loc='best') plt.show()</span></span></code> </pre> <br></div></div><br><br>  Obtenemos: <br><br>  Tiempo de vuelo = 1.2316 Distancia = 5.9829 Altura = 1.8542 <br>  Tiempo de vuelo = 1.1016 Distancia = 4.3830 Altura = 1.5088 <br>  Tiempo de vuelo = 1.0197 Distancia = 3.5265 Altura = 1.2912 <br>  Tiempo de vuelo = 0.9068 Distancia = 2.5842 Altura = 1.0240 <br>  Tiempo para el problema del modelo: 0.454787 <br><br><img src="https://habrastorage.org/webt/z5/u5/xc/z5u5xc04tbd-_2idovqqosevlwi.png"><br><br>  Para implementar una solución numérica del CDS usando herramientas de Python sin usar módulos especiales, propuse e investigué la siguiente función: <br><br> <code>def increment(f, t, y, tau <br> k1=tau*f(t,y) <br> k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) <br> k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) <br> k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) <br> k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) <br> k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) <br> return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6</code> <br> <br>  La función de incremento (f, t, y, tau) proporciona el quinto orden del método de solución numérica.  Otras características del programa se pueden encontrar en la siguiente lista: <br><br><div class="spoiler">  <b class="spoiler_title">Listado de programa</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time start = time.time() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rungeKutta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, to, yo, tEnd, tau)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f, t, y, tau)</span></span></span><span class="hljs-function">:</span></span><span class="hljs-comment"><span class="hljs-comment">#     ——. k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = []#   t y= []#   y t.append(to)#   t   to y.append(yo)#   y   yo while to &lt; tEnd:#     t,y tau = min(tau, tEnd - to)#   tau yo = yo + increment(f, to, yo, tau) #     t0,y0    to = to + tau #   t.append(to) #   t y.append(yo) #   y return array(t), array(y) def f(t, y): #      f = zeros([4]) f[0]=y[1] f[1]=-k*y[1]*sqrt(y[1]**2+y[3]**2) f[2]=y[3] f[3]=-k*y[3]*sqrt(y[1]**2+y[3]**2) -g if y[3]&lt;0 and y[2]&lt;=0.0: #    return -1 return f to = 0#     tEnd = 1.41#     alph=pi/4#    v0=10.0 #   K=[0.1,0.2,0.3,0.5]#     g=9.81 yo = array([0.,v0*cos(alph),0.,v0*sin(alph)]) #   tau =0.01#  for i in K: #      k=i t, y = rungeKutta(f, to, yo, tEnd, tau) y1=array([i[0] for i in y]) #     y y3=array([i[2] for i in y]) #    ""     s,h,t plt.plot(y1,y3,linewidth=2,label='k=%.1f h=%.3f s=%.2f t=%s' % (k,max(y3),max(y1),round(t[list(y1).index(max(y1))],3))) stop = time.time() plt.title("      \n     Python\n  —— ") print ("   : %f"%(stop-start)) plt.xlabel(' h') plt.ylabel(' s') plt.legend(loc='best') plt.xlim(0,8) plt.ylim(-0.1,2) plt.grid(True) plt.show()</span></span></code> </pre> <br></div></div><br>  Obtenemos: <br><br>  Tiempo para el problema del modelo: 0.259927 <br><br><img src="https://habrastorage.org/webt/_i/c1/ta/_ic1ta5623kjqb1qazfpt3ut1ns.png"><br><br>  <b>Conclusión</b> <br><br>  La implementación de software propuesta para el problema del modelo sin el uso de módulos especiales tiene un rendimiento casi dos veces más rápido que con la función ode, pero no debemos olvidar que ode tiene una mayor precisión de la solución numérica y la posibilidad de elegir un método de solución. <br><br><h3>  Resolver un problema de valor límite con condiciones de límite separadas por hilos </h3><br>  Damos un ejemplo de un problema específico de valor límite con condiciones de límite separadas por hilos: <br><br><img src="https://habrastorage.org/webt/i4/x0/jt/i4x0jtfxfy57053vvu31tpyyvo4.png">  (11) <br><br>  Para resolver el problema (11), utilizamos el siguiente algoritmo: <br><br>  1. Resolvemos las tres primeras ecuaciones no homogéneas del sistema (11) con las condiciones iniciales <br><img src="https://habrastorage.org/webt/0w/b-/qj/0wb-qjfvaodszu5xyov9mqgddmi.png"><br>  Introducimos la notación para resolver el problema de Cauchy: <br><img src="https://habrastorage.org/webt/h1/am/zo/h1amzogvuzkyz3a6wpp95gd9rua.png"><br><br>  2. Resolvemos las tres primeras ecuaciones homogéneas del sistema (11) con las condiciones iniciales <br><img src="https://habrastorage.org/webt/ia/d6/yn/iad6ynerbilksk3kcjwudksg4ta.png"><br>  Introducimos la notación para resolver el problema de Cauchy: <br><img src="https://habrastorage.org/webt/3t/ib/ze/3tibzeyvnv-bsodoaivbfnycscc.png"><br><br>  3. Resolvemos las tres primeras ecuaciones homogéneas del sistema (11) con las condiciones iniciales <br><br><img src="https://habrastorage.org/webt/rl/vd/pc/rlvdpcnayrhhfasr9s4jpjpffja.png"><br><br>  Introducimos la notación para resolver el problema de Cauchy: <br><br><img src="https://habrastorage.org/webt/pq/dl/os/pqdlosn5xi7yxhoeg0yafuybtdy.png"><br><br>  4. La solución general del problema del valor límite (11) usando las soluciones de los problemas de Cauchy se escribe como una combinación lineal de soluciones: <br><img src="https://habrastorage.org/webt/8n/_t/17/8n_t1751ck0jmg6oiv3cgaluskm.png"><br>  donde p2, p3 son algunos parámetros desconocidos. <br><br>  5. Para determinar los parámetros p2, p3, utilizamos las condiciones de contorno de las dos últimas ecuaciones (11), es decir, las condiciones para x = b.  Sustituyendo, obtenemos un sistema de ecuaciones lineales con respecto a p2, p3 desconocido: <br><img src="https://habrastorage.org/webt/0_/xe/_p/0_xe_pgiynf0ufquqah-k7llh18.png">  (12) <br>  Resolviendo (12), obtenemos las relaciones para p2, p3. <br><br>  Usando el algoritmo anterior usando el método Runge - Kutta - Felberg, obtenemos el siguiente programa: <br><br><div class="spoiler">  <b class="spoiler_title">Listado de programa</b> <div class="spoiler_text"><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">#   from numpy import* import matplotlib.pyplot as plt import matplotlib.font_manager as fm,os import matplotlib.patches as mpatches import matplotlib.lines as mlines from scipy.integrate import odeint from scipy import linalg import time start = time.time() c1 = 1.0 c2 = 0.8 c3 = 0.5 a =0.0 b = 1.0 nn =100 initial_state_0 =array( [a, c1, 0.0, 0.0]) initial_state_I =array( [a, 0.0, 1.0, 0.0]) initial_state_II =array( [a, 0.0, 0.0, 1.0]) to = a tEnd =b N = int(nn) tau=(ba)/N def rungeKutta(f, to, yo, tEnd, tau): def increment(f, t, y, tau): k1=tau*f(t,y) k2=tau*f(t+(1/4)*tau,y+(1/4)*k1) k3 =tau *f(t+(3/8)*tau,y+(3/32)*k1+(9/32)*k2) k4=tau*f(t+(12/13)*tau,y+(1932/2197)*k1-(7200/2197)*k2+(7296/2197)*k3) k5=tau*f(t+tau,y+(439/216)*k1-8*k2+(3680/513)*k3 -(845/4104)*k4) k6=tau*f(t+(1/2)*tau,y-(8/27)*k1+2*k2-(3544/2565)*k3 +(1859/4104)*k4-(11/40)*k5) return (16/135)*k1+(6656/12825)*k3+(28561/56430)*k4-(9/50)*k5+(2/55)*k6 t = [] y= [] t.append(to) y.append(yo) while to &lt; tEnd: tau = min(tau, tEnd - to) yo = yo + increment(f, to, yo, tau) to = to + tau t.append(to) y.append(yo) return array(t), array(y) def f(t, y): global theta f = zeros([4]) f[0] = 1 f[1] = -y [1]-y[2] +theta* sin(y[0]) f[2] = -y[2]+y[3] f[3] = -y[2] return f #    -- theta = 1 theta = 1.0 yo =initial_state_0 t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y20 = Y2(b), Y30 = Y3(b) Y20 = y2[N-1] Y30 = y3[N-1] #    -- theta = 0,  I theta = 0.0 yo= initial_state_I t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y21= Y2(b), Y31 = Y3(b) Y21= y2[N-1] Y31 = y3[N-1] #    -- theta = 0,  II theta = 0.0 yo =initial_state_II t, y = rungeKutta(f, to, yo, tEnd, tau) y2=[i[2] for i in y] y3=[i[3] for i in y] #       # Y211= Y2(b), Y311 = Y3(b) Y211= y2[N-1] Y311 = y3[N-1] #    #     p2, p3 b1 = c2 - Y20 b2 = c3 - Y30 A = array([[Y21, Y211], [Y31, Y311]]) bb = array([[b1], [b2]]) #   p2, p3 = linalg.solve(A, bb) #    #  , theta = 1 theta = 1.0 yo = array([a, c1, p2, p3]) t, y = rungeKutta(f, to, yo, tEnd, tau) y0=[i[0] for i in y] y1=[i[1] for i in y] y2=[i[2] for i in y] y3=[i[3] for i in y] #  print('y0[0]=', y0[0]) print('y1[0]=', y1[0]) print('y2[0]=', y2[0]) print('y3[0]=', y3[0]) print('y0[N-1]=', y0[N-1]) print('y1[N-1]=', y1[N-1]) print('y2[N-1]=', y2[N-1]) print('y3[N-1]=', y3[N-1]) j = N xx = y0[:j] yy1 = y1[:j] yy2 = y2[:j] yy3 = y3[:j] stop = time.time() print ("   : %f"%(stop-start)) plt.subplot(2, 1, 1) plt.plot([a], [c1], 'ro') plt.plot([b], [c2], 'go') plt.plot([b], [c3], 'bo') plt.plot(xx, yy1, color='r') #  plt.plot(xx, yy2, color='g') #  plt.plot(xx, yy3, color='b') #  plt.xlabel(r'$x$') #   x   TeX plt.ylabel(r'$y_k(x)$') #   y   TeX plt.title(r'  ', color='blue') plt.grid(True) # patch_y1 = mpatches.Patch(color='red', label='$y_1$') patch_y2 = mpatches.Patch(color='green', label='$y_2$') patch_y3 = mpatches.Patch(color='blue', label='$y_3$') plt.legend(handles=[patch_y1, patch_y2, patch_y3]) ymin, ymax = plt.ylim() xmin, xmax = plt.xlim() plt.subplot(2, 1, 2) font = {'family': 'serif', 'color': 'blue', 'weight': 'normal', 'size': 12, } plt.text(0.2, 0.8, r'$\frac{dy_1}{dx}= - y_1 - y_2 + \sin(x),$', fontdict=font) plt.text(0.2, 0.6,r'$\frac{dy_2}{dx}= - y_1 + y_3,$', fontdict=font) plt.text(0.2, 0.4, r'$\frac{dy_3}{dx}= - y_2 - y_2,$', fontdict=font) plt.text(0.2, 0.2, r'$y_1(a)=c_1, ' r'\quad y_2(b)=c_2, \quad y_3(b)=c_3.$', fontdict=font) plt.subplots_adjust(left=0.15) plt.show()</span></span></code> </pre><br></div></div><br>  Obtenemos: <br><br>  y0 [0] = 0.0 <br>  y1 [0] = 1.0 <br>  y2 [0] = 0.7156448588231397 <br>  y3 [0] = 1.324566562303714 <br>  y0 [N-1] = 0.9900000000000007 <br>  y1 [N-1] = 0.1747719838716767 <br>  y2 [N-1] = 0.8 <br>  y3 [N-1] = 0.5000000000000001 <br>  Tiempo para el problema del modelo: 0.070878 <br><br><img src="https://habrastorage.org/webt/kj/g1/0c/kjg10co-rqc-pwbedzo56s4b3wy.png"><br><br><h3>  Conclusión </h3><br><br>  El programa desarrollado por mí difiere del error dado en [3], que confirma el análisis comparativo de la función odeint dada al comienzo del artículo con el método Runge - Kutta - Felberg implementado en Python. <br><br>  Referencias <br><br>  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solución numérica de modelos matemáticos de objetos definidos por sistemas compuestos de ecuaciones diferenciales.</a> <br><br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introducción a Python científico.</a> <br><br>  3. N.M.  Polyakova, E.V.  Shiryaeva Python 3. Creación de una interfaz gráfica de usuario (utilizando el ejemplo de resolución del problema del valor límite para ecuaciones diferenciales lineales ordinarias mediante el método de disparo).  Rostov del Don 2017. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418139/">https://habr.com/ru/post/es418139/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418127/index.html">La verdad y la falsedad de los sistemas de reconocimiento facial.</a></li>
<li><a href="../es418131/index.html">Programación Cross-Cloud con Go Cloud</a></li>
<li><a href="../es418133/index.html">En defensa de la OLP. 7 argumentos insostenibles de sus oponentes</a></li>
<li><a href="../es418135/index.html">Cómo organizar su propio repositorio de módulos Node.js con blackjack y versiones</a></li>
<li><a href="../es418137/index.html">Sed de sangre: entrevista con el fundador de DonorSearch</a></li>
<li><a href="../es418141/index.html">RE: Ghat / AFR Principiante Skipper Race</a></li>
<li><a href="../es418143/index.html">PVS-Studio como una solución SAST</a></li>
<li><a href="../es418145/index.html">La primera demanda contra Roskomnadzor de una compañía que sufrió cuando Telegram fue bloqueado</a></li>
<li><a href="../es418147/index.html">Silencio de las ejecuciones de Ruby: Transactional Rails / PostgreSQL Thriller</a></li>
<li><a href="../es418149/index.html">Phishing con etiqueta de título</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>