<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 👨🏿‍🔧 🧓🏽 我们正在开发一个使用微服务的环境。 第1部分在裸机上安装Kubernetes HA（Debian） 👵🏽 😫 🕺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="您好，Habr亲爱的读者们！ 


 在本出版物中，我想开始撰写一系列有关使用Kubernetes容器部署功能完善的编排环境的文章，以准备进行操作和启动应用程序。 
 我不仅要讲述如何部署Kubernetes集群，还想讲述安装后如何配置集群，如何向其添加便捷的工具和附加组件以使用微服务架构。 
 此...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>我们正在开发一个使用微服务的环境。 第1部分在裸机上安装Kubernetes HA（Debian）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462473/"><p><img src="https://habrastorage.org/webt/aq/dx/l3/aqdxl3a5akxfl3rh9b7bzc_kqji.jpeg"></p><br><h4> 您好，Habr亲爱的读者们！ </h4><br><p> 在本出版物中，我想开始撰写一系列有关使用Kubernetes容器部署功能完善的编排环境的文章，以准备进行操作和启动应用程序。 <br> 我不仅要讲述如何部署Kubernetes集群，还想讲述安装后如何配置集群，如何向其添加便捷的工具和附加组件以使用微服务架构。 </p><br><h2> 此周期至少包含四篇文章： </h2><br><ol><li> 在它们的第一篇中，我将告诉您如何在裸铁上安装故障安全kubernetes集群，如何安装标准仪表板并配置对其的访问权限，如何安装入口控制器。 </li><li> 在第二篇文章中，我将向您展示如何部署Ceph故障转移群集以及如何在Kubernetes群集中开始使用RBD卷。 我还将介绍其他类型的存储（存储），并更详细地考虑本地存储。 此外，我将告诉您如何根据创建的CEPH集群组织S3容错存储 </li><li> 在第三篇文章中，我将介绍如何在Kubernetes集群（即Kubernetes上的Percona XtraDB集群）中部署故障转移集群MySql。 另外，我还将描述当我们决定将数据库转移到kubernetes时遇到的所有问题。 </li><li> 在第四篇文章中，我将尝试将所有内容放在一起，并告诉您如何部署和运行将使用数据库和ceph卷的应用程序。 我将告诉您如何配置入口控制器以从外部访问我们的应用程序以及来自Let's Encrypt的自动证书订购服务。 另一个是如何自动维护这些证书的最新状态。 在访问控制面板的上下文中，我们还涉及RBAC。 我将简要介绍Helm及其安装。 <br> 如果您对这些出版物中的信息感兴趣，欢迎您！ <a name="habracut"></a></li></ol><br><h2> 参赛作品： </h2><br><p> 这些文章适用于谁？ 首先，对于那些刚刚开始研究Kubernetes的人。 而且，对于正考虑从整体式服务转向微服务的工程师来说，该周期将非常有用。 所描述的一切都是我的经验，包括将多个项目从整体翻译为Kubernetes时获得的经验。 有经验的工程师可能会对出版物的某些部分感兴趣。 </p><br><h4> 在本系列出版物中，我将不作详细介绍的内容： </h4><br><ul><li> 详细解释什么是kubernetes原语，例如：pod，部署，服务，入口等。 </li><li> 我将非常肤浅地考虑CNI（容器网络接口），因此我们使用callico，因此仅列出其他解决方案。 </li><li>  docker映像构建过程。 </li><li>  CI \ CD进程。  （也许是单独的出版物，但在整个周期之后） </li><li> 掌舵 关于他的文章很多，我只涉及在群集中安装它和设置客户端的过程。 </li></ul><br><h4> 我想详细考虑的是： </h4><br><ul><li>  Kubernetes集群部署的分步过程。 我将使用kubeadm。 但是同时，我将逐步详细地介绍在裸机上安装集群，各种类型的ETCD安装以及为kube admina配置文件的过程。 我将尝试阐明Ingress控制器的所有平衡选项以及工作节点对服务器api的各种访问方案的差异。 <br> 我知道今天有很多很棒的工具来部署kubernetes，例如kubespray或同一个牧场主。 也许有人使用它们会更方便。 但是，我认为，有很多工程师想更详细地考虑这个问题。 </li><li>  CEPH术语和CEPH群集的逐步安装，以及将ceph存储连接到Kubernetes创建的群集的逐步说明。 </li><li> 本地存储，与kubernetes集群的连接以及与hostpath等连接的区别 </li><li>  kubernetes操作员和Percona XtraDB Cluster的部署在操作员的帮助下，并在六个月的生产经验后尝试谈论这种解决方案的优缺点。 我还将分享一些最终确定percona操作员的计划。 </li></ul><br><h2> 目录： </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">主机，主机资源，操作系统和软件版本的列表</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kubernetes集群HA图</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始之前或开始之前</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">填写create-config.sh文件</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">操作系统内核更新</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">准备节点安装Kubelet，Kubectl，Kubeadm和Docker</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装ETCD（各种选件）</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启动第一个Kubernetes向导</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CNI Callico安装</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">启动第二个和第三个kubernetes向导</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">将工作节点添加到集群</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在用于HA的工作程序节点上安装haproxy</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装入口控制器</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装Web UI（仪表板）</a> </li></ol><br><a name="vm"></a><br><h2> 主机列表和目的地 </h2><br><p> 我集群中的所有节点都将位于虚拟机上，该虚拟机上预装有Debian 9 Stretch系统，内核为4.19.0-0.bpo.5-amd64。 对于虚拟化，我使用Proxmox VE。 </p><br><h4> 表VM及其性能特征： </h4><br><div class="scrollable-table"><table><tbody><tr><th>  <b>名称</b> </th><th>  <b>IP地址</b> </th><th>  <b>留言</b> </th><th>  <b>中央处理器</b> </th><th>  <b>m</b> </th><th>  <b>磁盘1</b> </th><th>  <b>碟2</b> </th></tr><tr><td>  master01 </td><td>  10.73.71.25 </td><td> 主节点 </td><td>  4vcpu </td><td>  4GB </td><td> 硬碟 </td><td>  --- </td></tr><tr><td>  master02 </td><td>  10.73.71.26 </td><td> 主节点 </td><td>  4vcpu </td><td>  4GB </td><td> 硬碟 </td><td>  --- </td></tr><tr><td> 大师03 </td><td>  10.73.71.27 </td><td> 主节点 </td><td>  4vcpu </td><td>  4GB </td><td> 硬碟 </td><td>  --- </td></tr><tr><td>  worknode01 </td><td>  10.73.75.241 </td><td> 工作节点 </td><td>  4vcpu </td><td>  4GB </td><td> 硬碟 </td><td> 固态硬盘 </td></tr><tr><td>  worknode02 </td><td>  10.73.75.242 </td><td> 工作节点 </td><td>  4vcpu </td><td>  4GB </td><td> 硬碟 </td><td> 固态硬盘 </td></tr><tr><td>  worknode03 </td><td>  10.73.75.243 </td><td> 工作节点 </td><td>  4vcpu </td><td>  4GB </td><td> 硬碟 </td><td> 固态硬盘 </td></tr></tbody></table></div><br><p> 不必只具有这样的机器配置，但是我仍然建议您遵守<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档</a>的建议，对于主服务器，请将RAM的容量增加到至少4GB。 展望未来，我想说的是，在CNI Callico的工作中，我遇到了一些小问题 <br> 在内存和磁盘性能方面，Ceph也非常贪婪。 <br> 我们的生产安装无需使用裸机虚拟化即可工作，但我知道许多示例，其中具有相当适度资源的虚拟机就足够了。 这完全取决于您的需求和工作量。 </p><br><h2> 清单和软件版本 </h2><br><div class="scrollable-table"><table><tbody><tr><th>  <b>名称</b> </th><th>  <b>版本号</b> </th></tr><tr><td>  Kubernetes </td><td>  1.15.1 </td></tr><tr><td> 码头工人 </td><td>  19.3.1 </td></tr></tbody></table></div><br><p> 从1.14版开始，Kubeadm不再支持v1alpha3 API版本，并完全切换到了v1beta1 API版本，它将在不久的将来支持该版本，因此在本文中，我将仅讨论v1beta1。 <br> 因此，我们相信您已经为kubernetes集群准备了机器。 它们都可以通过网络相互访问，并具有与Internet的“ Internet连接”，并且已安装“干净”操作系统。 <br> 对于每个安装步骤，我将阐明命令或命令块在哪些机器上执行。 除非另有说明，否则以root用户身份执行所有命令。 <br> 所有配置文件以及准备脚本均可以在我的<a href="">github中</a>下载 <br> 因此，让我们开始吧。 </p><br><a name="ha-image"></a><br><h2>  Kubernetes集群HA图 </h2><br><p><img src="https://habrastorage.org/webt/ch/mx/pg/chmxpgzdyk0bvxwx7-6lawqfmvo.jpeg"><br>  HA群集的近似图。 老实说，我的画家很一般，但我会尝试简单地进行简单地解释，而无需特别研究理论。 <br> 因此，我们的集群将由三个主节点和三个工作节点组成。 在每个kubernetes主节点上，etcd（图中的绿色箭头）和kubernetes服务部件将为我们工作。 让我们通称它们-kubeapi。 <br> 通过etcd主群集，节点交换kubernetes群集的状态。 我将指示与用于外部流量的入口控制器入口点相同的地址（图中的红色箭头） <br> 在工作程序节点上，kubelet为我们工作，它通过在每个工作程序节点上本地安装的haproxy与kubernetes api服务器通信。 作为kubelet的服务器api地址，我将使用localhost 127.0.0.1:6443，而roundrobin上的haproxy会将请求分散到三个主节点上，它还将检查主节点的可用性。 该方案将允许我们创建HA，并且在主节点之一发生故障的情况下，工作节点将悄悄地向其余两个主节点发送请求。 </p><br><a name="begin"></a><br><h2> 开始之前 </h2><br><p> 在集群的每个节点上开始工作之前，我们将提供需要工作的软件包： </p><br><pre><code class="plaintext hljs">apt-get update &amp;&amp; apt-get install -y curl apt-transport-https git</code> </pre> <br><p> 在主节点上，使用配置模板复制存储库 </p><br><pre> <code class="plaintext hljs">sudo -i git clone https://github.com/rjeka/kubernetes-ceph-percona.git</code> </pre> <br><p> 检查向导上主机的ip地址是否与kubernetes服务器将在其上侦听的IP地址匹配 </p><br><pre> <code class="plaintext hljs">hostname &amp;&amp; hostname -i master01 10.73.71.25</code> </pre> <br><p> 对于所有主节点也是如此。 </p><br><p> 确保禁用SWAP，否则kubeadm将引发错误 </p><br><pre> <code class="plaintext hljs">[ERROR Swap]: running with swap on is not supported. Please disable swap</code> </pre> <br><p> 您可以禁用命令 </p><br><pre> <code class="plaintext hljs">swapoff -a</code> </pre> <br><p> 记得在/ etc / fstab中发表评论 </p><br><a name="create-config"></a><br><h2> 填写create-config.sh文件 </h2><br><p> 为了自动填写安装kubernetes集群所需的配置，我上传了一个小脚本create-config.sh。 您实际上需要填写8行。 指示主机的IP地址和主机名。 并且还指定etcd tocken，您不能更改它。 我将在脚本的下面提供您需要进行更改的部分。 </p><br><pre> <code class="plaintext hljs">#!/bin/bash ####################################### # all masters settings below must be same ####################################### # master01 ip address export K8SHA_IP1=10.73.71.25 # master02 ip address export K8SHA_IP2=10.73.71.26 # master03 ip address export K8SHA_IP3=10.73.71.27 # master01 hostname export K8SHA_HOSTNAME1=master01 # master02 hostname export K8SHA_HOSTNAME2=master02 # master03 hostname export K8SHA_HOSTNAME3=master03 #etcd tocken: export ETCD_TOKEN=9489bf67bdfe1b3ae077d6fd9e7efefd #etcd version export ETCD_VERSION="v3.3.10"</code> </pre><br><a name="kernel"></a><br><h2> 操作系统内核更新 </h2><br><p> 此步骤是可选的，因为需要从后端口更新内核，而这样做的风险和风险由您自己承担。 也许您永远不会遇到这个问题，而且如果这样做，即使部署了kubernetes，也可以更新内核。 通常，由您决定。 <br> 需要内核更新才能修复旧的Docker错误，该错误仅在Linux内核版本4.18中得到修复。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关此错误的更多信息。 在kubernetes节点上网络接口的定期挂起中表达了一个错误，错误为： </p><br><pre> <code class="plaintext hljs">waiting for eth0 to become free. Usage count = 1</code> </pre> <br><p> 安装操作系统后，我的内核版本为4.9 </p><br><pre> <code class="bash hljs">uname -a Linux master01 4.9.0-7-amd64 <span class="hljs-comment"><span class="hljs-comment">#1 SMP Debian 4.9.110-3+deb9u2 (2018-08-13) x86_64 GNU/Linux</span></span></code> </pre> <br><p> 在每台机器上执行kubernetes <br> 步骤1 <br> 将端口添加回源列表 </p><br><pre> <code class="plaintext hljs">echo deb http://ftp.debian.org/debian stretch-backports main &gt; /etc/apt/sources.list apt-get update apt-cache policy linux-compiler-gcc-6-x86</code> </pre> <br><p> 步骤2 <br> 套件安装 </p><br><pre> <code class="plaintext hljs">apt install -y -t stretch-backports linux-image-amd64 linux-headers-amd64</code> </pre> <br><p> 步骤3 <br> 重新开机 </p><br><pre> <code class="plaintext hljs">reboot</code> </pre> <br><p> 检查一切正常 </p><br><pre> <code class="plaintext hljs">uname -a Linux master01 4.19.0-0.bpo.5-amd64 #1 SMP Debian 4.19.37-4~bpo9+1 (2019-06-19) x86_64 GNU/Linux</code> </pre><br><a name="kubelet"></a><br><h2> 准备节点安装Kubelet，Kubectl，Kubeadm和Docker </h2><br><h4> 安装Kubelet，Kubectl，Kubeadm </h4><br><p> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubernetes</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档，</a>我们放置了集群的所有节点 </p><br><pre> <code class="plaintext hljs">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF apt-get update apt-get install -y kubelet kubeadm kubectl apt-mark hold kubelet kubeadm kubectl</code> </pre> <br><h4> 安装Docker </h4><br><p> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a>安装docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </p><br><pre> <code class="plaintext hljs">apt-get remove docker docker-engine docker.io containerd runc apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</code> </pre> <br><pre> <code class="plaintext hljs">curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add - apt-key fingerprint 0EBFCD88</code> </pre> <br><pre> <code class="plaintext hljs">add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/debian \ $(lsb_release -cs) \ stable"</code> </pre> <br><pre> <code class="plaintext hljs">apt-get update apt-get install docker-ce docker-ce-cli containerd.io</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">安装使用Ansible安装Kubelet，Kubectl，Kubeadm和docker</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">git clone https://github.com/rjeka/kubernetes-ceph-percona.git cd kubernetes-ceph-percona/playbooks vim masters.ini</code> </pre> <br><p> 在masters组中，注册ip master。 <br> 在worker组中，编写工作节点的ip。 </p><br><pre> <code class="plaintext hljs"># sudo c  ansible-playbook -i hosts.ini kubelet.yaml -K ansible-playbook -i hosts.ini docker.yaml -K # sudo  ansible-playbook -i hosts.ini kubelet.yaml ansible-playbook -i hosts.ini docker.yaml</code> </pre> </div></div><br><p> 如果出于某种原因您不想使用docker，则可以使用任何CRI。 例如，您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关内容，但是该主题不在本文讨论范围之内。 </p><br><a name="etcd"></a><br><h2>  ETCD安装 </h2><br><p> 简而言之，我不会深入到理论上：etcd是一种开源的分布式键值存储。  etcd实际上是用GO编写的，并在kubernetes中用作存储集群状态的数据库。 有关更详细的评论，请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubernetes文档</a> 。 <br>  etcd可以通过多种方式安装。 您可以在本地安装它并作为守护程序运行，可以在docker容器中运行它，甚至可以将其安装为kubernetes pod。 您可以手动安装它，也可以使用kubeadm安装它（我没有尝试过这种方法）。 可以安装在群集计算机或单个服务器上。 <br> 我将在主节点上本地安装etcd并通过systemd作为守护程序运行，以及考虑在docker中安装。 我使用没有TLS的etcd，如果您需要TLS，请参考etcd或<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubernetes本身</a>的文档 <br> 同样在我的github中将有一个ansible-playbook，用于通过systemd启动安装etcd。 </p><br><h4> 选件编号1 <br> 本地安装，通过systemd运行 </h4><br><p> 在所有主服务器上：（在集群的工作节点上，无需执行此步骤） <br> 步骤1 <br> 使用etcd下载档案并解压缩： </p><br><pre> <code class="plaintext hljs">mkdir archives cd archives export etcdVersion=v3.3.10 wget https://github.com/coreos/etcd/releases/download/$etcdVersion/etcd-$etcdVersion-linux-amd64.tar.gz tar -xvf etcd-$etcdVersion-linux-amd64.tar.gz -C /usr/local/bin/ --strip-components=1</code> </pre> <br><p> 步骤2 <br> 为ETCD创建配置文件 </p><br><pre> <code class="plaintext hljs">cd .. ./create-config.sh etcd</code> </pre> <br><p> 该脚本接受etcd的值作为输入，并在etcd目录中生成一个配置文件。 脚本运行后，完成的配置文件将位于etcd目录中。 <br> 对于所有其他配置，脚本按相同原理工作。 它需要一些输入并在特定目录中创建配置。 </p><br><p> 步骤3 <br> 我们启动etcd集群并检查其性能 </p><br><pre> <code class="plaintext hljs">systemctl start etcd</code> </pre> <br><p> 检查守护程序的性能 </p><br><pre> <code class="plaintext hljs">systemctl status etcd ● etcd.service - etcd Loaded: loaded (/etc/systemd/system/etcd.service; disabled; vendor preset: enabled) Active: active (running) since Sun 2019-07-07 02:34:28 MSK; 4min 46s ago Docs: https://github.com/coreos/etcd Main PID: 7471 (etcd) Tasks: 14 (limit: 4915) CGroup: /system.slice/etcd.service └─7471 /usr/local/bin/etcd --name master01 --data-dir /var/lib/etcd --listen-client-urls http://0.0.0.0:2379,http://0.0.0.0:4001 --advertise-client-urls http://10.73.71.25:2379,http://10.73.71. Jul 07 02:34:28 master01 etcd[7471]: b11e73358a31b109 [logterm: 1, index: 3, vote: 0] cast MsgVote for f67dd9aaa8a44ab9 [logterm: 2, index: 5] at term 554 Jul 07 02:34:28 master01 etcd[7471]: raft.node: b11e73358a31b109 elected leader f67dd9aaa8a44ab9 at term 554 Jul 07 02:34:28 master01 etcd[7471]: published {Name:master01 ClientURLs:[http://10.73.71.25:2379 http://10.73.71.25:4001]} to cluster d0979b2e7159c1e6 Jul 07 02:34:28 master01 etcd[7471]: ready to serve client requests Jul 07 02:34:28 master01 etcd[7471]: serving insecure client requests on [::]:4001, this is strongly discouraged! Jul 07 02:34:28 master01 systemd[1]: Started etcd. Jul 07 02:34:28 master01 etcd[7471]: ready to serve client requests Jul 07 02:34:28 master01 etcd[7471]: serving insecure client requests on [::]:2379, this is strongly discouraged! Jul 07 02:34:28 master01 etcd[7471]: set the initial cluster version to 3.3 Jul 07 02:34:28 master01 etcd[7471]: enabled capabilities for version 3.3 lines 1-19</code> </pre> <br><p> 集群本身的健康状况： </p><br><pre> <code class="plaintext hljs">etcdctl cluster-health member 61db137992290fc is healthy: got healthy result from http://10.73.71.27:2379 member b11e73358a31b109 is healthy: got healthy result from http://10.73.71.25:2379 member f67dd9aaa8a44ab9 is healthy: got healthy result from http://10.73.71.26:2379 cluster is healthy etcdctl member list 61db137992290fc: name=master03 peerURLs=http://10.73.71.27:2380 clientURLs=http://10.73.71.27:2379,http://10.73.71.27:4001 isLeader=false b11e73358a31b109: name=master01 peerURLs=http://10.73.71.25:2380 clientURLs=http://10.73.71.25:2379,http://10.73.71.25:4001 isLeader=false f67dd9aaa8a44ab9: name=master02 peerURLs=http://10.73.71.26:2380 clientURLs=http://10.73.71.26:2379,http://10.73.71.26:4001 isLeader=true</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">使用Ansible在本地安装etcd，并通过systemd运行</b> <div class="spoiler_text"><p> 使用github，我们将使用代码将存储库克隆到将要从其运行剧本的机器上。 这台机器应该对将来的集群的主服务器具有ssh访问权限。 </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/rjeka/kubernetes-ceph-percona.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> kubernetes-ceph-percona/playbooks vim masters.ini</code> </pre> <br><p> 在masters组中，注册ip master。 <br>  etcd_version是etcd的版本。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在github</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">etcd页面</a>上看到它。 在撰写本文时，我正在使用v3.3.10版本。 <br>  etcdToken-您可以保留原样，也可以自己生成。 <br> 经营剧本团队 </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># sudo c  ansible-playbook -i hosts.ini -l masters etcd.yaml -K BECOME password: &lt;sudo &gt; # sudo  ansible-playbook -i hosts.ini -l masters etcd.yaml</span></span></code> </pre> </div></div><br><p> 如果要在docker中运行etcd，则扰流板下面有一条指令。 </p><br><div class="spoiler">  <b class="spoiler_title">使用docker-compose安装etcd，在docker中启动</b> <div class="spoiler_text"><p> 这些命令必须在所有群集主节点上执行。 <br> 使用github，我们使用代码克隆存储库 </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/rjeka/kubernetes-ceph-percona.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> kubernetes-ceph-percona</code> </pre> <br><p>  etcd_version是etcd的版本。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在github</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">etcd页面</a>上看到它。 在撰写本文时，我正在使用v3.3.10版本。 <br>  etcdToken-您可以保留原样，也可以自己生成。 </p><br><p> 我们把docker-compose </p><br><pre> <code class="plaintext hljs">apt-get install -y docker-compose</code> </pre> <br><p> 我们生成一个配置 </p><br><pre> <code class="plaintext hljs">./create-config.sh docker</code> </pre> <br><p> 在Docker中运行etcd集群的安装 </p><br><pre> <code class="plaintext hljs">docker-compose --file etcd-docker/docker-compose.yaml up -d</code> </pre> <br><p> 检查容器是否已装好 </p><br><pre> <code class="plaintext hljs">docker ps</code> </pre> <br><p> 和集群状态等 </p><br><pre> <code class="plaintext hljs">root@master01:~/kubernetes-ceph-percona# docker exec -ti etcd etcdctl cluster-health member 61db137992290fc is healthy: got healthy result from http://10.73.71.27:2379 member b11e73358a31b109 is healthy: got healthy result from http://10.73.71.25:2379 member f67dd9aaa8a44ab9 is healthy: got healthy result from http://10.73.71.26:2379 cluster is healthy root@master01:~/kubernetes-ceph-percona# docker exec -ti etcd etcdctl member list 61db137992290fc: name=etcd3 peerURLs=http://10.73.71.27:2380 clientURLs=http://10.73.71.27:2379,http://10.73.71.27:4001 isLeader=false b11e73358a31b109: name=etcd1 peerURLs=http://10.73.71.25:2380 clientURLs=http://10.73.71.25:2379,http://10.73.71.25:4001 isLeader=true f67dd9aaa8a44ab9: name=etcd2 peerURLs=http://10.73.71.26:2380 clientURLs=http://10.73.71.26:2379,http://10.73.71.26:4001 isLeader=false</code> </pre> <br><p> 如果出了什么问题 </p><br><pre> <code class="plaintext hljs">docker logs etcd</code> </pre> </div></div><br><a name="master-one"></a><br><h2> 启动第一个Kubernetes向导 </h2><br><p> 首先，我们需要为kubeadmin生成一个配置 </p><br><pre> <code class="plaintext hljs">./create-config.sh kubeadm</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">我们反汇编kubeadm的配置</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">apiVersion: kubeadm.k8s.io/v1beta1 kind: InitConfiguration localAPIEndpoint: advertiseAddress: 10.73.71.25 #    API- --- apiVersion: kubeadm.k8s.io/v1beta1 kind: ClusterConfiguration kubernetesVersion: stable #      apiServer: #    kubeadm   certSANs: - 127.0.0.1 - 10.73.71.25 - 10.73.71.26 - 10.73.71.27 controlPlaneEndpoint: 10.73.71.25 #     etcd: #  etc external: endpoints: - http://10.73.71.25:2379 - http://10.73.71.26:2379 - http://10.73.71.27:2379 networking: podSubnet: 192.168.0.0/16 #   ,   CNI  .</code> </pre> <br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubernetes文档中阅读</a>有关CNI子网的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息。</a> <br> 这是最低限度的配置。 对于具有三个向导的群集，可以将其更改为群集的配置。 例如，如果要使用2个向导，则只需在certSAN中指定两个地址。 <br> 所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">配置</a>参数都可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">kubeadm API说明中找到</a> 。 </p></div></div><br><p> 我们发起第一个大师 </p><br><pre> <code class="plaintext hljs">kubeadm init --config=kubeadmin/kubeadm-init.yaml</code> </pre> <br><p> 如果kubeadm正常运行，那么在输出处，我们将获得大约以下输出： </p><br><pre> <code class="plaintext hljs">You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join 10.73.71.25:6443 --token ivwoap.259retezqf34amx8 \ --discovery-token-ca-cert-hash sha256:b5c93e32457c8e6478782ff62e8ef77acf72738dda59cd603cdf4821abe12ca3 \ --control-plane Then you can join any number of worker nodes by running the following on each as root: kubeadm join 10.73.71.25:6443 --token ivwoap.259retezqf34amx8 \ --discovery-token-ca-cert-hash sha256:b5c93e32457c8e6478782ff62e8ef77acf72738dda59cd603cdf4821abe12ca3</code> </pre> <br><a name="callica"></a><br><h2>  CNI Calico安装 </h2><br><p> 现在是时候建立一个我们的pod可以在其中工作的网络。 我使用印花布，我们会放上它。 <br> 对于初学者，请配置kubelet的访问权限。 我们在master01上执行所有命令 <br> 如果您以root身份运行 </p><br><pre> <code class="plaintext hljs">export KUBECONFIG=/etc/kubernetes/admin.conf</code> </pre> <br><p> 如果来自简单用户 </p><br><pre> <code class="plaintext hljs">mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config</code> </pre> <br><p> 您也可以从笔记本电脑或任何本地计算机上管理群集。 为此，请将/etc/kubernetes/admin.conf文件复制到便携式计算机或$ HOME / .kube / config中的任何其他计算机上 </p><br><p> 我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">根据Kubernetes文档放置了</a> CNI <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </p><br><pre> <code class="plaintext hljs">kubectl apply -f https://docs.projectcalico.org/v3.8/manifests/calico.yaml</code> </pre> <br><p> 我们等到所有豆荚升起 </p><br><pre> <code class="plaintext hljs">watch -n1 kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE kube-system calico-kube-controllers-59f54d6bbc-psr2z 1/1 Running 0 96s kube-system calico-node-hm49z 1/1 Running 0 96s kube-system coredns-5c98db65d4-svcx9 1/1 Running 0 77m kube-system coredns-5c98db65d4-zdlb8 1/1 Running 0 77m kube-system kube-apiserver-master01 1/1 Running 0 76m kube-system kube-controller-manager-master01 1/1 Running 0 77m kube-system kube-proxy-nkdqn 1/1 Running 0 77m kube-system kube-scheduler-master01 1/1 Running 0 77m</code> </pre> <br><a name="mastes-other"></a><br><h2> 启动第二个和第三个kubernetes向导 </h2><br><p> 在启动master02和master03之前，您需要使用创建集群时kubeadm生成的master01复制证书。 我将通过scp复制 <br> 在master01上 </p><br><pre> <code class="plaintext hljs">export master02=10.73.71.26 export master03=10.73.71.27 scp -r /etc/kubernetes/pki $master02:/etc/kubernetes/ scp -r /etc/kubernetes/pki $master03:/etc/kubernetes/</code> </pre> <br><p> 在master02和master03上 <br> 为kubeadm创建配置 </p><br><pre> <code class="plaintext hljs">./create-config.sh kubeadm</code> </pre> <br><p> 并将master02和master03添加到集群 </p><br><pre> <code class="plaintext hljs">kubeadm init --config=kubeadmin/kubeadm-init.yaml</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">几个网络接口出现毛刺！</b> <div class="spoiler_text"><p> 在生产中，我使用kubernetes v1.13.5和calico v3.3。 而且我没有这样的故障。 <br> 但是在准备本文并使用稳定版本时（在撰写本文时为v1.15.1 kubernetes和3.8版callico），我遇到了一个问题，该问题表示为CNI启动错误 </p><br><pre> <code class="plaintext hljs">root@master01:~/kubernetes-ceph-percona# kubectl get pods -A -w NAMESPACE NAME READY STATUS RESTARTS AGE kube-system calico-kube-controllers-658558ddf8-t6gfs 0/1 ContainerCreating 0 11s kube-system calico-node-7td8g 1/1 Running 0 11s kube-system calico-node-dthg5 0/1 CrashLoopBackOff 1 11s kube-system calico-node-tvhkq 0/1 CrashLoopBackOff 1 11s</code> </pre> <br><p> 当服务器具有多个网络接口时，这是calico守护程序设置故障 <br> 在githab上，此故障有一个问题<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/projectcalico/calico/issues/2720</a> <br> 通过编辑守护程序集calico-node并将IP_AUTODETECTION_METHOD参数添加到env来解决此问题。 </p><br><pre> <code class="plaintext hljs">kubectl edit -n kube-system ds calico-node</code> </pre> <br><p> 添加IP_AUTODETECTION_METHOD参数以及该向导在其上运行的接口的名称； 在我的情况下是ens19 </p><br><pre> <code class="plaintext hljs">- name: IP_AUTODETECTION_METHOD value: ens19</code> </pre> <br><p><img src="https://habrastorage.org/webt/xe/pq/7h/xepq7hbpjwhgowfk0hkc6-ryw8a.png"><br> 检查集群中的所有节点均已启动并正在运行 </p><br><pre> <code class="plaintext hljs"># kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready master 28m v1.15.1 master02 Ready master 26m v1.15.1 master03 Ready master 18m v1.15.1</code> </pre> <br><p> 活着的氧化钙是什么 </p><br><pre> <code class="plaintext hljs"># kubectl get pods -A -o wide | grep calico kube-system calico-kube-controllers-59f54d6bbc-5lxgn 1/1 Running 0 27m kube-system calico-node-fngpz 1/1 Running 1 24m kube-system calico-node-gk7rh 1/1 Running 0 8m55s kube-system calico-node-w4xtt 1/1 Running 0 25m</code> </pre> </div></div><br><a name="worknodes"></a><br><h2> 将工作节点添加到集群 </h2><br><p> 目前，我们有一个集群，其中正在运行三个主节点。 但是主节点是运行kubernetes集群的api，调度程序和其他服务的机器。 为了运行Pod，我们需要所谓的工作程序节点。 <br> 如果资源有限，则可以在主节点上运行Pod，但我个人不建议这样做。 </p><br><div class="spoiler">  <b class="spoiler_title">在主节点上运行壁炉</b> <div class="spoiler_text"><p> 为了允许在主节点上启动壁炉，请在任何向导上执行以下命令 </p><br><pre> <code class="plaintext hljs">kubectl taint nodes --all node-role.kubernetes.io/master-</code> </pre> </div></div><br><p> 与主节点上一样，在工作服务器上安装kubelet，kubeadm，kubectl和docker节点 </p><br><div class="spoiler">  <b class="spoiler_title">安装kubelet，kubeadm，kubectl和docker</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add - cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF apt-get update apt-get install -y kubelet kubeadm kubectl apt-mark hold kubelet kubeadm kubectl</code> </pre> <br><h4> 安装Docker </h4><br><p> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a>安装docker <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> </p><br><pre> <code class="plaintext hljs">apt-get remove docker docker-engine docker.io containerd runc apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common</code> </pre> <br><pre> <code class="plaintext hljs">curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add - apt-key fingerprint 0EBFCD88</code> </pre> <br><pre> <code class="plaintext hljs">add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/debian \ $(lsb_release -cs) \ stable"</code> </pre> <br><pre> <code class="plaintext hljs">apt-get update apt-get install docker-ce docker-ce-cli containerd.io</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">安装使用Ansible安装Kubelet，Kubectl，Kubeadm和docker</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">git clone https://github.com/rjeka/kubernetes-ceph-percona.git cd kubernetes-ceph-percona/playbooks vim masters.ini</code> </pre> <br><p> 在masters组中，注册ip master。 <br> 在worker组中，编写工作节点的ip。 </p><br><pre> <code class="plaintext hljs"># sudo c  ansible-playbook -i hosts.ini kubelet.yaml -K ansible-playbook -i hosts.ini docker.yaml -K # sudo  ansible-playbook -i hosts.ini kubelet.yaml ansible-playbook -i hosts.ini docker.yaml</code> </pre> </div></div></div></div><br><p> 现在该回到我们安装主节点时kubeadm生成的行了。 <br> 她对我来说像这样。 </p><br><pre> <code class="plaintext hljs">kubeadm join 10.73.71.25:6443 --token ivwoap.259retezqf34amx8 \ --discovery-token-ca-cert-hash sha256:b5c93e32457c8e6478782ff62e8ef77acf72738dda59cd603cdf4821abe12ca3</code> </pre> <br><p> 必须在每个工作程序节点上执行此命令。 <br> 如果您尚未编写令牌，则可以生成一个新的令牌 </p><br><pre> <code class="plaintext hljs">kubeadm token create --print-join-command --ttl=0</code> </pre> <br><p>  kubeadm工作后，您的新节点将进入集群并准备工作 </p><br><pre> <code class="plaintext hljs">This node has joined the cluster: * Certificate signing request was sent to apiserver and a response was received. * The Kubelet was informed of the new secure connection details. Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</code> </pre> <br><p> 现在让我们看一下结果 </p><br><pre> <code class="plaintext hljs">root@master01:~# kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready master 10d v1.15.1 master02 Ready master 10d v1.15.1 master03 Ready master 10d v1.15.1 worknode01 Ready &lt;none&gt; 5m44s v1.15.1 worknode02 Ready &lt;none&gt; 59s v1.15.1 worknode03 Ready &lt;none&gt; 51s v1.15.1</code> </pre> <br><a name="haproxy"></a><br><h2> 在工作节点上安装haproxy </h2><br><p> 现在，我们有了一个具有三个主节点和三个工作节点的工作集群。 <br> 问题是现在我们的工作节点没有HA模式。 <br> 如果查看kubelet配置文件，我们将看到我们的工作节点仅访问三个主节点之一。 </p><br><pre> <code class="plaintext hljs">root@worknode01:~# cat /etc/kubernetes/kubelet.conf | grep server: server: https://10.73.71.27:6443</code> </pre> <br><p> 就我而言，这是master03。 使用此配置，如果master03崩溃，则工作程序节点将失去与集群API服务器的通信。 为了使我们的集群完全具备高可用性，我们将在每个工作服务器上安装一个负载均衡器（Haproxy），根据循环机制，它将分散对三个主节点的请求，在工作节点上的kubelet配置中，我们会将服务器地址更改为127.0.0.1:6443 <br> 首先，在每个工作程序节点上安装HAProxy。 <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有一个很好的备忘单可供安装</a> </p><br><pre> <code class="plaintext hljs">curl https://haproxy.debian.net/bernat.debian.org.gpg | \ apt-key add - echo deb http://haproxy.debian.net stretch-backports-2.0 main | \ tee /etc/apt/sources.list.d/haproxy.list apt-get update apt-get install haproxy=2.0.\*</code> </pre> <br><p> 安装HAproxy之后，我们需要为其创建配置。 <br> 如果在工作节点上没有包含配置文件的目录，则我们将其克隆 </p><br><pre> <code class="plaintext hljs">git clone https://github.com/rjeka/kubernetes-ceph-percona.git cd kubernetes-ceph-percona/</code> </pre> <br><p> 并使用haproxy标志运行配置脚本 </p><br><pre> <code class="plaintext hljs">./create-config.sh haproxy</code> </pre> <br><p> 该脚本将配置并重新启动haproxy。 <br> 检查haproxy是否开始侦听端口6443。 </p><br><pre> <code class="plaintext hljs">root@worknode01:~/kubernetes-ceph-percona# netstat -alpn | grep 6443 tcp 0 0 127.0.0.1:6443 0.0.0.0:* LISTEN 30675/haproxy tcp 0 0 10.73.75.241:6443 0.0.0.0:* LISTEN 30675/haproxy</code> </pre> <br><p> 现在，我们需要告诉kubelet访问localhost而不是主节点。 为此，请在所有工作节点上的/etc/kubernetes/kubelet.conf和/etc/kubernetes/bootstrap-kubelet.conf文件中编辑服务器值。 </p><br><pre> <code class="plaintext hljs">vim /etc/kubernetes/kubelet.conf vim nano /etc/kubernetes/bootstrap-kubelet.conf</code> </pre> <br><p> 服务器值应采用以下形式： </p><br><pre> <code class="plaintext hljs">server: https://127.0.0.1:6443</code> </pre> <br><p> 进行更改后，重新启动kubelet和docker服务 </p><br><pre> <code class="plaintext hljs">systemctl restart kubelet &amp;&amp; systemctl restart docker</code> </pre> <br><p> 检查所有节点是否正常工作。 </p><br><pre> <code class="plaintext hljs">kubectl get nodes NAME STATUS ROLES AGE VERSION master01 Ready master 29m v1.15.1 master02 Ready master 27m v1.15.1 master03 Ready master 26m v1.15.1 worknode01 Ready &lt;none&gt; 25m v1.15.1 worknode02 Ready &lt;none&gt; 3m15s v1.15.1 worknode03 Ready &lt;none&gt; 3m16s v1.15.1</code> </pre> <br><p> 到目前为止，我们集群中没有用于测试HA的应用程序。 但是，我们可以在第一个主节点上停止kubelet的操作，并确保我们的集群保持运行状态。 </p><br><pre> <code class="plaintext hljs">systemctl stop kubelet &amp;&amp; systemctl stop docker</code> </pre> <br><p> 从第二个主节点检查 </p><br><pre> <code class="plaintext hljs">root@master02:~# kubectl get nodes NAME STATUS ROLES AGE VERSION master01 NotReady master 15h v1.15.1 master02 Ready master 15h v1.15.1 master03 Ready master 15h v1.15.1 worknode01 Ready &lt;none&gt; 15h v1.15.1 worknode02 Ready &lt;none&gt; 15h v1.15.1 worknode03 Ready &lt;none&gt; 15h v1.15.1</code> </pre> <br><p> 除了停止服务的节点以外，所有节点均正常运行。 <br> 不要忘记在第一个主节点上回退kubernetes服务 </p><br><pre> <code class="plaintext hljs">systemctl start kubelet &amp;&amp; systemctl start docker</code> </pre> <br><a name="ingress"></a><br><h2> 安装入口控制器 </h2><br><p> 入口控制器是Kubernetes附加组件，我们可以使用它从外部访问我们的应用程序。 详细的描述在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Kuberbnetes文档中</a> 。 有很多控制器入口，我使用Nginx的控制器。 我将讨论其安装。  Nginx提供的有关Ingress控制器的操作，配置和安装的文档可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方网站</a>上阅读 </p><br><p> 让我们开始安装，所有命令都可以使用master01执行。 <br> 自行安装控制器 </p><br><pre> <code class="plaintext hljs">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/mandatory.yaml</code> </pre> <br><p> 现在-一项可通过其访问的服务 <br> 为此，请准备配置 </p><br><pre> <code class="plaintext hljs">./create-config.sh ingress</code> </pre> <br><p> 并将其发送到我们的集群 </p><br><pre> <code class="plaintext hljs">kubectl apply -f ingress/service-nodeport.yaml</code> </pre> <br><p> 检查我们的Ingress是否在正确的地址上正常工作，并在正确的端口上进行侦听。 </p><br><pre> <code class="plaintext hljs"># kubectl get svc -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx NodePort 10.99.35.95 10.73.71.25,10.73.71.26,10.73.71.27 80:31669/TCP,443:31604/TCP 10m</code> </pre> <br><pre> <code class="plaintext hljs"> kubectl describe svc -n ingress-nginx ingress-nginx Name: ingress-nginx Namespace: ingress-nginx Labels: app.kubernetes.io/name=ingress-nginx app.kubernetes.io/part-of=ingress-nginx Annotations: kubectl.kubernetes.io/last-applied-configuration: {"apiVersion":"v1","kind":"Service","metadata":{"annotations":{},"labels":{"app.kubernetes.io/name":"ingress-nginx","app.kubernetes.io/par... Selector: app.kubernetes.io/name=ingress-nginx,app.kubernetes.io/part-of=ingress-nginx Type: NodePort IP: 10.99.35.95 External IPs: 10.73.71.25,10.73.71.26,10.73.71.27 Port: http 80/TCP TargetPort: 80/TCP NodePort: http 31669/TCP Endpoints: 192.168.142.129:80 Port: https 443/TCP TargetPort: 443/TCP NodePort: https 31604/TCP Endpoints: 192.168.142.129:443 Session Affinity: None External Traffic Policy: Cluster Events: &lt;none&gt;</code> </pre> <br><a name="dashboard"></a><br><h2> 安装Web UI（仪表板） </h2><br><p>  Kubernetes有一个标准的Web UI，通过它有时可以方便地快速查看集群或其各个部分的状态。 在我的工作中，我经常使用仪表板进行部署的初始诊断或集群各部分的状态。 <br> 该文档的链接<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">位于kubernetes网站上</a> <br> 安装方式 我正在使用稳定版本，但尚未尝试2.0。 </p><br><pre> <code class="plaintext hljs">#  kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml # 2.0 kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta1/aio/deploy/recommended.yaml</code> </pre> <br><p> 在将面板安装到集群中之后，该面板在以下位置可用 </p><br><pre> <code class="plaintext hljs">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/.</code> </pre> <br><p> 但是，为了达到目的，我们需要使用kubectl代理从本地计算机转发端口。 对我来说，这种方案不是很方便。 因此，我将更改控制面板的服务，以使仪表板在端口30443上任何群集节点的地址上可用。还有其他访问仪表板的方法，例如，通过入口。 也许我会在以下出版物中考虑这种方法。 <br> 要更改服务，请运行已更改服务的部署 </p><br><pre> <code class="plaintext hljs">kubectl apply -f dashboard/service-nodeport.yaml</code> </pre> <br><p> 剩下创建管理员用户和令牌以通过仪表板访问集群的过程 </p><br><pre> <code class="plaintext hljs">kubectl apply -f dashboard/rbac.yaml kubectl -n kube-system describe secret $(kubectl -n kube-system get secret | grep admin-user | awk '{print $1}')</code> </pre> <br><p> 之后，您可以登录到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://10.73.71.25:30443</a>的控制面板。 <br><img src="https://habrastorage.org/webt/p7/zu/8q/p7zu8qv47mwdsmdydtvyo7gs_y4.png"><br> 仪表板主屏幕 <br><img src="https://habrastorage.org/webt/h2/ks/jq/h2ksjq_7egqatf4ulnl0zkwqvqk.png"></p><br><p> 恭喜你！ 如果您已完成此步骤，那么您将拥有一个可用的Kubernetes HA集群，该集群可用于部署应用程序。 <br> Kubernetes    ,      .          . <br>       ,  GitHub,    ,    . <br> C ,  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462473/">https://habr.com/ru/post/zh-CN462473/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462461/index.html">GOES-17事故调查结果</a></li>
<li><a href="../zh-CN462465/index.html">使用苹果的故乡</a></li>
<li><a href="../zh-CN462467/index.html">前端每周摘要（2019年7月29日至8月4日）</a></li>
<li><a href="../zh-CN462469/index.html">R中针对“企业”任务的并行计算的几点注意事项</a></li>
<li><a href="../zh-CN462471/index.html">使用pwnable.kr 16解决工作-UAF。 释放漏洞后使用</a></li>
<li><a href="../zh-CN462475/index.html">阿列克谢·萨瓦捷捷夫（Alexey Savvateev）：如何借助数学打击腐败（2016年诺贝尔经济学奖）</a></li>
<li><a href="../zh-CN462477/index.html">科学家声称AI是一项新专利的作者，并正在试图改变专利法</a></li>
<li><a href="../zh-CN462479/index.html">Steam Windows客户端本地特权升级0天</a></li>
<li><a href="../zh-CN462481/index.html">类型系统常见问题</a></li>
<li><a href="../zh-CN462483/index.html">功能编程：一种古怪的玩具，会降低劳动生产率。 第一部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>