<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♟️ 🛏️ 😧 Kami memproses pesanan dari toko online menggunakan RabbitMQ dan TypeScript 🐠 👩🏻‍⚕️ 🖐🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Popularitas perdagangan Internet terus meningkat, seperti halnya pembagian informatisasi semua jenis kegiatan yang terkait dengan perda...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami memproses pesanan dari toko online menggunakan RabbitMQ dan TypeScript</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469991/"><p><img src="https://habrastorage.org/webt/wh/2y/cv/wh2ycv5atat_nuru35jo5pwfo08.jpeg"></p><br><p>  Halo semuanya!  Popularitas perdagangan Internet terus meningkat, seperti halnya pembagian informatisasi semua jenis kegiatan yang terkait dengan perdagangan.  Seiring dengan ini, kompleksitas pemrosesan informasi semakin meningkat.  Setiap pesanan yang dibuat oleh pelanggan toko online menghasilkan sejumlah besar integrasi dengan berbagai layanan.  Layanan tersebut dapat mencakup pemrosesan pembayaran, pengiriman, layanan akuntansi dan loyalitas.  Setiap pesanan harus dibayar, dicatat, dikumpulkan dan dikirim, dan juga tersedia untuk analisis lebih lanjut.  Ini, dan bukan situasi yang sederhana, diperumit oleh fakta bahwa pengguna toko online tidak ingin menunggu lama dan menyakitkan untuk sesuatu ketika melakukan pemesanan.  Respons dari toko online harus cepat, karena setiap milidetik keterlambatan meningkatkan peluang kehilangan pelanggan, dan selanjutnya untung.  Pada artikel ini saya ingin berbicara tentang broker pesan RabbitMQ dan bagaimana menggunakannya untuk mengatur pemrosesan pesanan menggunakan Node.js dan TypeScript.  Selamat datang di kucing. </p><a name="habracut"></a><br><h2 id="neobhodimaya-teoriya">  Teori yang diperlukan </h2><br><p>  Saya pikir banyak yang telah mendengar tentang RabbitMQ, karena versi open source pertama dari broker pesan ini, berdasarkan protokol AMQP, sudah dirilis pada tahun 2007.  Perantara pesan diperlukan untuk menghubungkan komponen-komponen sistem yang berbeda menjadi satu kesatuan, karena lem diperlukan untuk menyadarkan kembali vas yang rusak.  Dengan menggunakan pialang pesan, Anda dapat menerapkan pemrosesan peristiwa yang tidak sinkron yang diterima dalam sistem.  Hanya pemrosesan pesanan yang tidak sinkron yang dibutuhkan toko online.  Tetapi pertama-tama Anda harus memahami komponen dasar RabbitMQ.  Pialang ini memiliki tiga komponen utama yang dengannya kami akan membangun proses pemrosesan: </p><br><ul><li>  <strong>Pesan</strong>  Ini adalah unit informasi terkecil di dalam broker pesan dan layanan pemrosesan kami yang dapat diproses.  RabbitMQ sendiri menyimpan pesan dalam bentuk biner, tetapi untuk sistem kami dan untuk artikel ini tidak penting.  Kami akan menerima dan memproses pesan dalam bentuk JSON.  Perlu juga disebutkan bahwa pesan di RabbitMQ memiliki header.  Mereka mirip dengan header permintaan http.  Ini adalah array asosiatif di mana Anda dapat menulis informasi yang diperlukan. </li><li>  <strong>Antrian pesan</strong> .  Ini adalah antrian tempat RabbitMQ menyimpan pesan.  Antrian pesan dapat berlangganan oleh satu atau lebih konsumen.  Setiap pesan dalam antrian kelinci didistribusikan ke konsumen menggunakan algoritma round-robin. </li><li>  <strong>Tukar</strong>  Ini, seperti namanya, adalah titik pertukaran.  Antrean atau penukar lainnya dapat dilampirkan pada poin ini.  Titik pertukaran tidak menyimpan pesan, fungsi utamanya adalah untuk merutekan pesan ke satu atau beberapa antrian, atau titik pertukaran yang sama.  Setiap antrian atau penukar terikat oleh kunci perutean.  Ada beberapa jenis penukar di RabbitMQ yang memengaruhi bagaimana tepatnya pertukaran akan merutekan pesan yang diterima di dalamnya. </li></ul><br><p>  Untuk menggambarkan bagaimana berbagai jenis penukar bekerja, perlu dipahami apa itu kunci perutean.  Kunci perutean ada dalam pengikatan antrian ke penukar, dan dalam pesan itu sendiri.  <strong>Kunci perutean</strong> hanya string yang dibagi menjadi beberapa blok.  Setiap blok dipisahkan oleh sebuah titik.  Misalnya, “beri tahu.sendEmail.sendSms”.  Pada saat yang sama, pola dapat diatur untuk tombol perutean pesan menggunakan karakter khusus # dan *.  * - mengatakan bahwa setelah titik mana saja satu blok dapat pergi, tetapi setelah # sejumlah blok dapat pergi.  Misalnya, "notify.sendSms. *" Atau "notify. #".  Sekarang Anda dapat beralih ke jenis titik pertukaran. </p><br><p>  Ada empat jenis penukar: </p><br><ul><li>  <strong>Tanpa kipas</strong>  Logika perutean dari pertukaran ini sederhana, ia mengarahkan pesan masuk ke semua antrian atau penukar yang terlampir padanya. </li></ul><br><p><img src="https://habrastorage.org/webt/iw/f5/ib/iwf5ibz1b-6-qqhby_z_kqope9e.png"></p><br><ul><li>  <strong>Langsung</strong>  Pertukaran ini mengalihkan pesan tergantung pada apakah kunci perutean pesan cocok dengan kunci perutean yang mengikat. </li></ul><br><p><img src="https://habrastorage.org/webt/vu/pm/ia/vupmiavbtemxaxoecqcuklmpvqe.png"></p><br><ul><li>  <strong>Topik</strong>  Pertukaran jenis ini serta Direct mengarahkan pesan tergantung pada tombol routing.  Tetapi suatu pola dapat bertindak sebagai kunci perutean. </li></ul><br><p><img src="https://habrastorage.org/webt/yz/h4/ug/yzh4ug3abx7ywf9ex-bei3k20oe.png"></p><br><ul><li>  <strong>Tajuk</strong> .  Pertukaran ini, tidak seperti yang lain, menggunakan header pesan untuk perutean.  Pada saat yang sama, antrian ke penukar juga terikat menggunakan array asosiatif.  Logika yang digunakan penukar untuk merutekan pesan dapat diubah menggunakan kunci "x-match" khusus, yang diatur dalam larik pengikatan asosiatif.  Kunci dapat diatur ke dua nilai semua atau apa pun.  Jika nilainya semua, maka tajuk pesan harus benar-benar cocok dengan larik pengikatan asosiatif, jika nilainya ada, maka nilainya harus cocok dengan setidaknya satu kunci. </li></ul><br><p><img src="https://habrastorage.org/webt/gq/pd/gm/gqpdgmxxipjwviioorrzouqdj0o.png"></p><br><p>  Ini adalah komponen inti dari RabbitMQ.  Anda dapat membaca lebih lanjut tentang komponen ini dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi protokol AMQP</a> .  Selanjutnya, kita akan merancang dan mengimplementasikan sistem pemrosesan pesanan menggunakan TypeScript sebagai contoh, sekaligus memahami pengaturan masing-masing komponen. </p><br><h2 id="proektirovanie">  Desain </h2><br><p>  Untuk menyederhanakan contoh, kami mengasumsikan bahwa agar pemrosesan pesanan online berhasil, kami harus memiliki fungsionalitas berikut: </p><br><ul><li>  Simpan pesanan yang masuk </li><li>  Kirim SMS ke klien dengan nomor pesanan, serta status pesanan </li><li>  Kirim pesan ke layanan pengiriman kurir tentang pesanan baru dari toko online kami, jika klien telah memilih metode pengiriman ini </li></ul><br><p>  Tetapi itu tidak cukup untuk mengimplementasikan fungsi ini, karena toko online kami berencana untuk memperluas fungsionalitas dan memberikan lebih banyak peluang berbeda kepada pelanggannya di masa depan (dan ini selalu terjadi).  Misalnya, beri tahu pelanggan melalui email atau berikan beberapa metode pengiriman untuk pesanan.  Oleh karena itu kita perlu merancang sistem sedemikian rupa sehingga menambahkan fungsionalitas itu sederhana. </p><br><p>  Perlu juga disebutkan bahwa saya akan menggunakan templat untuk pesan yang ditangguhkan sehingga dimungkinkan, jika layanan eksternal tidak tersedia, untuk mengulangi logika beberapa kali.  Anda dapat membaca tentang templat ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </p><br><p>  Untuk lebih jelas menggambarkan tujuan akhir, saya akan menggambar diagram. </p><br><p><img src="https://habrastorage.org/webt/mu/bz/ji/mubzjikeu0b35eac4e_qj0rxdt4.png"></p><br><p>  Mari kita lihat bagaimana proses pemrosesan order bekerja pada diagram ini.  Skema ini dibagi menjadi beberapa blok dan warna berbeda.  Blok putih menunjukkan layanan eksternal yang tidak akan kami pertimbangkan.  Blok abu-abu menunjukkan elemen RabbitMQ.  Antrian dan penukar.  Warna hijau mencerminkan blok logika bisnis yang perlu diimplementasikan.  Juga, setiap blok yang terkait dengan logika kita diberi nomor.  Angka-angka menunjukkan proses dan subproses secara berurutan. </p><br><p>  Pertama-tama, pesan HTTP API masuk ke layanan kami.  Setelah itu, kita harus menetapkan nomor ke pesanan, menyimpan pesanan di database dengan status "baru" dan mengirim respons tentang keberhasilan pembuatan pesanan, dengan nomornya, kembali.  Klien, setelah menerima pesan tentang keberhasilan pembuatan pesanan, menjalankan bisnisnya sendiri.  Dengan mengirimkan respons positif, kami mengirim objek pesanan ke pertukaran pasca-pemrosesan, yang darinya jatuh ke pekerja formasi kunci perutean.  Pekerja ini, setelah menerima objek pesanan dari antrian, berdasarkan itu (apakah ada email atau telepon pelanggan dalam urutan, metode pengiriman yang dipilih) harus membentuk kunci routing order.  Setelah membentuk kunci perutean, pekerja mengirim pesan kembali ke pertukaran pasca pemrosesan, tetapi sekarang kunci perutean pesanan telah berubah dan penukar dapat mengirimkannya pada rute yang diinginkan.  Bergantung pada kuncinya, pesanan dapat dikirim untuk dipertukarkan, yang bertanggung jawab atas pemberitahuan, pertukaran integrasi, atau keduanya sekaligus.  Dan selanjutnya pada logika yang sama dalam antrian dan pekerja. </p><br><p>  Pekerja pengirim SMS dan layanan pengiriman akan mencoba memproses pesan beberapa kali.  Jumlah upaya tersebut dapat dilewatkan dalam variabel lingkungan.  Tetapi Anda tidak boleh memproses pesan tanpa henti, karena kesalahan mungkin terletak pada pesan itu sendiri atau logika pekerja.  Oleh karena itu, setelah melebihi jumlah upaya yang diizinkan, pesan akan dihapus dari antrian dan dikirim ke toko kesalahan, yang darinya dapat dikirim kembali ke tingkat pemrosesan yang diinginkan. </p><br><h2 id="realizaciya">  Implementasi </h2><br><p>  Untuk memverifikasi implementasinya, Anda perlu kelinci itu sendiri.  Saya sarankan menggunakan buruh pelabuhan dan gambar broker resmi untuk tujuan ini.  Instal dan jalankan wadah dengan perintah berikut. </p><br><pre><code class="bash hljs">docker run -d --name rabbit -p 5672:5672 -e rabbitmq:3.7.15-management-alpine</code> </pre> <br><p>  Ini adalah gambar dengan antarmuka web yang tersedia di port 15672 untuk memudahkan debugging. </p><br><p>  Kami akan mengimplementasikan rencana kami dengan TypeScript dan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">amqplib</a> (implementasi klien RabbitMQ untuk Node.js), jadi untuk permulaan Anda perlu menjelaskan beberapa antarmuka.  Kami menggambarkan antarmuka dari pesanan dan pesan yang akan kami kirim ke kelinci. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    export interface Product { id: string; name: string; price: number; } //    export interface Order { clientName: string; city: string; email?: string; phone?: string; products: Product[]; totalSum: number; deliveryAddress?: string; } //         export interface OrderWithPhone extends Order { phone: string; } //        export interface OrderWithDeliveryAddress extends Order { deliveryAddress: string; } // Types Guard'        export const isOrderWithPhone = (order: Order): order is OrderWithPhone =&gt; Boolean(order.phone); export const isOrderWithDeliveryAddress = (order: Order): order is OrderWithDeliveryAddress =&gt; Boolean(order.deliveryAddress); //    . export interface Message&lt;O extends Order&gt; { errors: string[]; retry: number; order: O; //         export interface FailOrder extends Message&lt;Order&gt; { exchange: string; routingKey: string; }</span></span></code> </pre> <br><p>  Sekarang kita perlu menggambarkan antarmuka konfigurasi antrian dan penukar, atas dasar yang mana kita akan membangun struktur pemrosesan pada kelinci. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Types, ExchangeTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Options } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'amqplib'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   RabbitMQ       export enum Types { QUEUE = 'queue', EXCHANGE = 'exchange', } //      export enum ExchangeTypes { TOPIC = 'topic', } //    export interface Queue { name: string; options: Options.AssertQueue; } //    export interface Exchange { name: string; type: ExchangeTypes; } //    export interface Binding { type: Types; destination: string; source: string; routingKey: string; } //   RabbitMQ export interface PipelineConfig { queues: Queue[]; exchanges: Exchange[]; bindings: Binding[]; }</span></span></code> </pre> <br><p>  Setelah mendeskripsikan komponen utama sistem, kami menjelaskan konfigurasi yang dibuat pada diagram menggunakan objek. </p><br><p>  Antrian </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ <span class="hljs-comment"><span class="hljs-comment">//        routingKey { name: 'generateRoutingKey', options: { durable: true, }, }, //   sms { name: 'sendSms', options: { durable: true, }, }, //      { name: 'delivery', options: { durable: true, }, }, //         sms { name: 'sendSmsHold', options: { durable: true, deadLetterExchange: 'notify', deadLetterRoutingKey: 'sendSms', messageTtl: 60000, }, }, //            { name: 'deliveryHold', options: { durable: true, deadLetterExchange: 'integrates', deadLetterRoutingKey: 'delivery', messageTtl: 60000, }, }, ];</span></span></code> </pre> <br><p>  Saat menjelaskan antrian, opsi berikut digunakan untuk antrian </p><br><ul><li>  <strong>tahan lama</strong> .  Secara default, semua pesan antrian disimpan dalam memori.  Karena itu, ketika broker reboot, pesan akan hilang.  Untuk menghindari ini, Anda dapat menggunakan opsi ini.  Dengan pengaturan ini, kelinci akan menyiram pesan ke disk.  Tapi ada satu peringatan.  Agar pesan disimpan setelah broker memulai kembali, pengaturan ini tidak cukup, pesan harus dikirim ke antrian dengan opsi persisten. </li><li>  <strong>messageTtl</strong> .  Pesan seumur hidup.  Diberikan dalam milidetik </li><li>  <strong>deadLetterExchange</strong> .  Nama penukar di mana pesan akan dikirim dari antrian saat pesan itu kedaluwarsa </li><li>  <strong>deadLetterRoutingKey</strong> .  RoutingKey dengan mana pesan akan dikirim ke exchanger dari opsi sebelumnya </li></ul><br><p>  Pertukaran </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ExchangeTypes } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ExchangeTypes.TOPIC, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ExchangeTypes.TOPIC, }, { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ExchangeTypes.TOPIC, }, ];</code> </pre> <br><p>  Binding </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Types } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> [ { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.EXCHANGE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.notify.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.EXCHANGE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.integrates.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'generateRoutingKey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'generateRoutingKey'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSms'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.sendSms.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'delivery'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'#.delivery.#'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSmsHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSmsHold'</span></span>, }, { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: Types.QUEUE, <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'deliveryHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">source</span></span>: <span class="hljs-string"><span class="hljs-string">'integrates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">routingKey</span></span>: <span class="hljs-string"><span class="hljs-string">'deliveryHold'</span></span>, }, ];</code> </pre> <br><p>  Konfigurasi penuh </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { PipelineConfig } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> exchanges <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./exchanges'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> queues <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./queues'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bindings <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./bindigs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipelineConfig: PipelineConfig = { exchanges, queues, bindings, };</code> </pre> <br><p>  Untuk terhubung ke kelinci, tulis kelas. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { connect, Connection, Channel } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'amqplib'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RabbitConnect</span></span></span><span class="hljs-class"> </span></span>{ private _uri: string; private _connection: Connection; private _chanel: Channel; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-comment"><span class="hljs-comment">//    rabbit     this._uri = process.env.RABBIT_URI || 'amqp://localhost'; } protected async connect() { this._connection = await connect(this._uri); this._chanel = await this._connection.createChannel(); } protected async disconnect() { await this._chanel.close(); return this._connection.close(); } protected get chanel() { return this._chanel; } }</span></span></code> </pre> <br><p>  Mari kita tulis kelas Pipeline, yang saat startup akan membuat semua infrastruktur yang diperlukan pada kelinci sesuai dengan konfigurasi yang dijelaskan sebelumnya. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { RabbitConnect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./RabbitConnect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { PipelineConfig } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Types } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pipeline</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RabbitConnect</span></span></span><span class="hljs-class"> </span></span>{ private _pipeline: PipelineConfig; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(pipelineConfig: PipelineConfig) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._pipeline = pipelineConfig; } public <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> create() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.connect(); <span class="hljs-comment"><span class="hljs-comment">//   const createQueues = this._pipeline.queues.map(queue =&gt; this.chanel.assertQueue(queue.name, queue.options), ) as PromiseLike&lt;any&gt;[]; //   const createExchanges = this._pipeline.exchanges.map(exchange =&gt; this.chanel.assertExchange(exchange.name, exchange.type), ) as PromiseLike&lt;any&gt;[]; await Promise.all([...createQueues, ...createExchanges]); //       const createBindings = this._pipeline.bindings.map(binding =&gt; { if (binding.type === Types.QUEUE) { return this.chanel.bindQueue(binding.destination, binding.source, binding.routingKey); } return this.chanel.bindExchange(binding.destination, binding.source, binding.routingKey); }); await Promise.all(createBindings); return this.disconnect(); } catch (error) { console.error(error); throw new Error(error); } } }</span></span></code> </pre> <br><p>  Sekarang kita akan menulis kelas pekerja abstrak dengan fungsi umum untuk semua pekerja yang darinya dimungkinkan untuk diwariskan. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { RabbitConnect } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./RabbitConnect'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Message, Order, FailOrder } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ConsumeMessage } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'amqplib'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface WorkerParams { maxRetry?: number; <span class="hljs-comment"><span class="hljs-comment">//     active: string; //    exchange: string; //       holdKey?: string; //      } export abstract class Worker&lt;M extends Order&gt; extends RabbitConnect { private _maxRetry: number; private _active: string; private _holdKey: string | undefined; protected exchange: string; private _currentMessage: Message&lt;M&gt;; private _currentConsumeMessage: ConsumeMessage; constructor({ active, holdKey, exchange, maxRetry }: WorkerParams) { super(); this._maxRetry = maxRetry || 0; this._active = active; this._holdKey = holdKey; this.exchange = exchange; } public async subscribe() { await this.connect(); this.chanel.consume(this._active, this.checkMessage.bind(this)); } //          private async checkMessage(message: ConsumeMessage) { this._currentConsumeMessage = message; const orderMessage: Message&lt;M&gt; = JSON.parse(message.content.toString()); if (orderMessage.retry &gt;= this._maxRetry) { await this.sendToErrorStorage('  '); } this._currentMessage = orderMessage; //           await this.handler(orderMessage.order || orderMessage); } //       protected async sendToErrorStorage(error: string) { const message: FailOrder = { order: this._currentMessage.order, errors: [...this._currentMessage.errors, error], retry: this._currentMessage.retry + 1, exchange: this.exchange, routingKey: this._active }; console.log('   ', message); this.ack(); } //       protected async hold(error: string) { if (!this._holdKey) { return; } const orderMessage = { order: this._currentMessage.order, errors: [...this._currentMessage.errors, error], retry: this._currentMessage.retry + 1, }; const orderData = Buffer.from(JSON.stringify(orderMessage)); return this.chanel.publish(this.exchange, this._holdKey, orderData); } //      protected async ack() { return this.chanel.ack(this._currentConsumeMessage); } protected abstract handler(message: M): void; }</span></span></code> </pre> <br><p>  Secara default, kelinci membutuhkan konfirmasi untuk pemrosesan pesan yang berhasil dari pekerja.  Untuk ini, saluran koneksi memiliki metode ack.  Jika pekerja tidak dapat memproses pesan, maka ada metode nack yang memberitahu kelinci untuk mengirim pesan ke pekerja lain. </p><br><p>  Sekarang kita dapat menulis beberapa pekerja sederhana dari diagram. </p><br><p>  Pekerja menghasilkan kunci perutean. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Worker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Worker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { isOrderWithPhone, isOrderWithDeliveryAddress, Order, Message, } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Keys } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../constants'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GenerateRoutingKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Order</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({ <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-string"><span class="hljs-string">'generateRoutingKey'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exchange</span></span>: <span class="hljs-string"><span class="hljs-string">'postprocessing'</span></span>, }); } protected <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(order: Order) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> routingKey: string[] = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isOrderWithPhone(order)) { routingKey.push(Keys.SEND_SMS); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isOrderWithDeliveryAddress(order)) { routingKey.push(Keys.SEND_TO_DELIVERY); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> message: Message&lt;Order&gt; = { <span class="hljs-attr"><span class="hljs-attr">retry</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-attr"><span class="hljs-attr">errors</span></span>: [], order, }; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.chanel.publish( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.exchange, routingKey.join(<span class="hljs-string"><span class="hljs-string">'.'</span></span>), Buffer.from(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(message)), ); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ack(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sendToErrorStorage(error); } } }</code> </pre> <br><p>  Pekerja mengirim sms. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Worker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Worker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { OrderWithPhone } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SendSms</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderWithPhone</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({ <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSms'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exchange</span></span>: <span class="hljs-string"><span class="hljs-string">'notify'</span></span>, <span class="hljs-attr"><span class="hljs-attr">holdKey</span></span>: <span class="hljs-string"><span class="hljs-string">'sendSmsHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetry</span></span>: process.env.MAX_RETRY ? <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(process.env.MAX_RETRY) : <span class="hljs-number"><span class="hljs-number">5</span></span>, }); } protected <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(message: OrderWithPhone) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">' sms  : '</span></span>, message.phone); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ack(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hold(error); } } }</code> </pre> <br><p>  Integrasi pekerja dengan layanan pengiriman. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Worker } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Worker'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { OrderWithDeliveryAddress } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../interfaces'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Delivery</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Worker</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderWithDeliveryAddress</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>({ <span class="hljs-attr"><span class="hljs-attr">active</span></span>: <span class="hljs-string"><span class="hljs-string">'delivery'</span></span>, <span class="hljs-attr"><span class="hljs-attr">exchange</span></span>: <span class="hljs-string"><span class="hljs-string">'interates'</span></span>, <span class="hljs-attr"><span class="hljs-attr">holdKey</span></span>: <span class="hljs-string"><span class="hljs-string">'deliveryHold'</span></span>, <span class="hljs-attr"><span class="hljs-attr">maxRetry</span></span>: process.env.MAX_RETRY ? <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(process.env.MAX_RETRY) : <span class="hljs-number"><span class="hljs-number">5</span></span>, }); } protected <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> handler(message: OrderWithDeliveryAddress) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'      : '</span></span>, message.deliveryAddress); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ack(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.hold(error); } } }</code> </pre> <br><p>  Titik masuk ke aplikasi. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Pipeline } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Pipeline'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { pipelineConfig } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./pipeline'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { GenerateRoutingKey } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./workers/GenerateRoutingKey'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { SendSms } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./workers/SendSms'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Delivery } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./workers/Delivery'</span></span>; <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipeline = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Pipeline(pipelineConfig); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> generateRoutingKey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenerateRoutingKey(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sendSms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SendSms(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> delivery = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Delivery(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> pipeline.create(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all([generateRoutingKey.subscribe(), sendSms.subscribe(), delivery.subscribe()]); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error); process.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>); } })();</code> </pre> <br><p>  Saya tidak akan memberikan contoh kelas kode untuk menulis pesanan ke database dan menghasilkan nomor pesanan Internet.  Ini di luar ruang lingkup artikel ini.  Untuk memeriksa kode, Anda dapat menggunakan antarmuka web kelinci dengan mengirimkan json pesanan ke posrprocessing penukar. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Skema konstruksi seperti itu untuk memproses pesanan online membuatnya mudah untuk mengukur sistem.  Tidak akan sulit bagi kami untuk menambahkan beberapa antrian dan pekerja ke skema ini untuk menambahkan fungsionalitas yang diperlukan.  Misalnya, Anda dapat menambahkan pengiriman pemberitahuan melalui email atau mengirim pesanan untuk penghitungan dalam 1C.  Sirkuit yang dikonversi akan terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/id/rt/7j/idrt7j5jx9zmzcma6axa3st7-nq.png"></p><br><p>  Saya harap Anda menikmati artikel ini.  Saya akan senang dengan komentar dan kritik.  Semua kode yang dikirimkan dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditemukan di github</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469991/">https://habr.com/ru/post/id469991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469979/index.html">Rekaman laporan dari mitap iOS kedua Redmadrobot</a></li>
<li><a href="../id469983/index.html">Bagaimana cara membuat strategi untuk mengalahkan penuaan?</a></li>
<li><a href="../id469985/index.html">Mempercepat program untuk prosesor Redd yang disintesis tanpa optimisasi: mengganti jam</a></li>
<li><a href="../id469987/index.html">20 Perusahaan Pengembangan Pasar Terbaik Dari Seluruh Dunia</a></li>
<li><a href="../id469989/index.html">C # Regex dalam contoh</a></li>
<li><a href="../id469995/index.html">Python SAX parser vs python DOM parser. Parsim FIAS-rumah</a></li>
<li><a href="../id469997/index.html">Berita utama apa yang paling mungkin menarik perhatian atau analisis HabraHabr</a></li>
<li><a href="../id470001/index.html">Kiat & trik Linux: server, buka</a></li>
<li><a href="../id470003/index.html">F # 1: Hello World</a></li>
<li><a href="../id470005/index.html">Kontrol komputer jarak jauh melalui browser</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>