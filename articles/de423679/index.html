<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚟 ▪️ 🐭 Eine Aufgabe mit Wolkenkratzer und Eiern - nicht Newtons Mülleimer? 🤧 👩‍👧‍👦 🎑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Tat ist er der meiste. Aber das Wichtigste zuerst. 

 Erklärung des Problems 
 Ich beherrsche Python, löse alles auf Codewars. Ich stoße auf ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Aufgabe mit Wolkenkratzer und Eiern - nicht Newtons Mülleimer?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423679/">  In der Tat ist er der meiste.  Aber das Wichtigste zuerst. <br><br><h3>  Erklärung des Problems </h3><br>  Ich beherrsche Python, löse alles auf Codewars.  Ich stoße auf eine bekannte Aufgabe über einen Wolkenkratzer und Eier.  Der einzige Unterschied besteht darin, dass die Quelldaten nicht 100 Stockwerke und 2 Eier sind, sondern etwas mehr. <br>  Gegeben: N Eier, M versucht sie zu werfen, endloser Wolkenkratzer. <br><br>  Definieren: Der maximale Boden, von dem aus Sie ein Ei werfen können, ohne zu brechen.  Eier sind im Vakuum kugelförmig und wenn eines von ihnen nicht bricht und beispielsweise aus dem 99. Stock fällt, halten die anderen auch einem Sturz aus allen Stockwerken unter einem Hundertstel stand. <br><br>  0 &lt;= N, M &lt;= 20.000. <br>  Die Laufzeit von zwei Dutzend Tests beträgt 12 Sekunden. <br><a name="habracut"></a><br><h3>  Suche nach einer Lösung </h3><br>  Wir müssen eine Funktionshöhe (n, m) schreiben, die die Bodennummer für das angegebene n, m zurückgibt.  Da es sehr oft erwähnt wird und jedes Mal, wenn Sie "Höhe" Faulheit schreiben, werde ich es überall außer dem Code als f (n, m) bezeichnen. <br><br>  Beginnen wir mit Nullen.  Wenn es keine Eier gibt oder versucht wird, sie zu werfen, kann natürlich nichts bestimmt werden und die Antwort ist Null.  <b>f (0, m) = 0, f (n, 0) = 0.</b> <br><br>  Angenommen, es gibt ein Ei und es gibt 10 Versuche. Sie können alles riskieren und es sofort aus dem hundertsten Stock werfen, aber im Falle eines Fehlers können Sie nichts anderes bestimmen. Es ist also logischer, vom ersten Stock aus zu beginnen und nach jedem Wurf einen Stock nach oben zu gehen. bis entweder der Versuch oder das Ei endet.  Das Maximum, wo Sie bekommen können, wenn das Ei nicht versagt, ist Boden Nummer 10. <b>f (1, m) = m</b> <br><br>  Nehmen Sie das zweite Ei, versuchen Sie es erneut 10. Nun, dann können Sie eine Chance mit einem Hundertstel eingehen?  Wenn es kaputt geht, gibt es noch einen und 9 Versuche, mindestens 9 Stockwerke können passieren.  Vielleicht müssen Sie also nicht vom hundertsten, sondern vom zehnten riskieren?  Ist logisch.  Bei Erfolg bleiben dann 2 Eier und 9 Versuche übrig.  Analog dazu müssen Sie jetzt weitere 9 Stockwerke hinaufsteigen.  Mit einer Reihe von Erfolgen - weitere 8, 7, 6, 5, 4, 3, 2 und 1. Insgesamt befinden wir uns mit zwei ganzen Eiern im 55. Stock und ohne es zu versuchen.  Die Antwort ist die Summe der ersten M Mitglieder der arithmetischen Folge mit dem ersten Element 1 und Schritt 1. <b>f (2, m) = (m * m + m) / 2</b> .  Es ist auch klar, dass bei jedem Schritt die Funktion f (1, m) aufgerufen wurde, aber dies ist noch nicht genau. <br><br>  Fahren Sie mit drei Eiern und zehn Versuchen fort.  Im Falle eines erfolglosen ersten Wurfs werden die mit 2 Eiern und 9 Versuchen bedeckten Böden von unten bedeckt, was bedeutet, dass der erste Wurf vom Boden f (2, 9) + 1 ausgeführt werden muss. Wenn dies erfolgreich ist, haben wir 3 Eier und 9 Versuche .  Und für den zweiten Versuch müssen Sie weitere f (2.8) + 1 Stockwerke hinaufsteigen.  Und so weiter, bis 3 Eier und 3 Versuche an den Händen bleiben.  Und dann ist es Zeit, sich ablenken zu lassen, indem man Fälle mit N = M betrachtet, in denen es so viele Eier gibt, wie es Versuche gibt. <br><br><div class="spoiler">  <b class="spoiler_title">Und zur gleichen Zeit, wenn es mehr Eier gibt.</b> <div class="spoiler_text">  Aber hier ist alles offensichtlich - Eier jenseits derjenigen, die brechen, werden für uns nicht nützlich sein, selbst wenn jeder Wurf erfolglos ist.  <b>f (n, m) = f (m, m), wenn n&gt; m ist</b> .  Und alles in allem 3 Eier, 3 Würfe.  Wenn das erste Ei zerbricht, können Sie f (2, 2) Stockwerke nach unten überprüfen, und wenn es nicht bricht, dann f (3,2) Stockwerke nach oben, dh das gleiche f (2, 2).  Insgesamt f (3, 3) = 2 * f (2, 2) + 1 = 7. Und f (4, 4) besteht analog aus zwei f (3, 3) und einem, und es wird 15. Alle sein es ähnelt den Zweierpotenzen, und wir schreiben: <b>f (m, m) = 2 ^ m - 1</b> . <br><br>  Es sieht aus wie eine binäre Suche in der physischen Welt: Wir gehen von der Etage Nummer 2 ^ (m-1) aus, im Erfolgsfall gehen wir 2 ^ (m-2) Etagen höher und im Falle eines Misserfolgs gehen wir so viel runter und so weiter. bis die Versuche ausgehen.  In unserem Fall stehen wir die ganze Zeit auf. <br></div></div><br>  Kehren wir zu f (3, 10) zurück.  Tatsächlich kommt es bei jedem Schritt auf die Summe f (2, m-1) an - die Anzahl der Stockwerke, die im Falle eines Ausfalls bestimmt werden können, Einheiten und f (3, m-1) - die Anzahl der Stockwerke, die im Erfolgsfall bestimmt werden können.  Und es wird deutlich, dass es aufgrund der Zunahme der Anzahl der Eier und Versuche unwahrscheinlich ist, dass sich etwas ändert.  <b>f (n, m) = f (n - 1, m - 1) + 1 + f (n, m - 1)</b> .  Und dies ist eine universelle Formel, die in Code implementiert werden kann. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lru_cache @lru_cache() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n,m)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> m==<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m**<span class="hljs-number"><span class="hljs-number">2</span></span>+m)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n&gt;=m: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>**n<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height(n<span class="hljs-number"><span class="hljs-number">-1</span></span>,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>+height(n,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br>  Natürlich bin ich zuvor auf den Rechen der nicht-meroisierenden rekursiven Funktionen getreten und habe herausgefunden, dass f (10, 40) mit der Anzahl der Aufrufe an sich fast 40 Sekunden dauert - 97806983. Aber das Memoisieren wird auch nur in den Anfangsintervallen gespeichert.  Wenn f (200.400) in 0,8 Sekunden ausgeführt wird, ist f (200, 500) bereits in 31 Sekunden.  Es ist lustig, dass bei der Messung der Laufzeit mit% timeit das Ergebnis viel weniger als real ist.  Offensichtlich dauert der erste Durchlauf der Funktion die meiste Zeit, während der Rest einfach die Ergebnisse seiner Memoisierung verwendet.  Lügen, eklatante Lügen und Statistiken. <br><br><h3>  Rekursion ist nicht erforderlich, wir schauen weiter </h3><br>  So erscheint zum Beispiel in den Tests f (9477, 10000), aber mein erbärmliches f (200, 500) passt nicht mehr zum richtigen Zeitpunkt.  Es gibt also eine andere Lösung, ohne Rekursion werden wir die Suche fortsetzen.  Ich habe den Code ergänzt, indem ich Funktionsaufrufe mit bestimmten Parametern gezählt habe, um zu sehen, in was er sich letztendlich zerlegt hat.  Für 10 Versuche wurden die folgenden Ergebnisse erhalten: <br><br>  f (3,10) = 7+ 1 · f (2,9) + 1 · f (2,8) + 1 · f (2,7) + 1 · f (2,6) + 1 · f (2 , 5) + 1 · f (2,4) + 1 · f (2,3) + 1 · f (3,3) <br>  f (4,10) = 27+ 1 · f (2,8) + 2 · f (2,7) + 3 · f (2,6) + 4 · f (2,5) + 5 · f (2 , 4) + 6 · f (2,3) + 6 · f (3,3) + 1 · f (4,4) <br>  f (5,10) = 55+ 1 · f (2,7) + 3 · f (2,6) + 6 · f (2,5) + 10 · f (2,4) + 15 · f (2 , 3) + 15 · f (3,3) + 5 · f (4,4) + 1 · f (5,5) <br>  f (6,10) = 69+ 1 · f (2,6) + 4 · f (2,5) + 10 · f (2,4) + 20 · f (2,3) + 20 · f (3 , 3) + 10 · f (4,4) + 4 · f (5,5) + 1 · f (6,6) <br>  f (7,10) = 55+ 1 · f (2,5) + 5 · f (2,4) + 15 · f (2,3) + 15 · f (3,3) + 10 · f (4) , 4) + 6 · f (5,5) + 3 · f (6,6) + 1 · f (7,7) <br>  f (8,10) = 27+ 1 · f (2,4) + 6 · f (2,3) + 6 · f (3,3) + 5 · f (4,4) + 4 · f (5) , 5) + 3 · f (6,6) + 2 · f (7,7) + 1 · f (8,8) <br>  f (9,10) = 7+ 1 · f (2,3) + 1 · f (3,3) + 1 · f (4,4) + 1 · f (5,5) + 1 · f (6) , 6) + 1 · f (7,7) + 1 · f (8,8) + 1 · f (9,9) <br><br>  Eine gewisse Regelmäßigkeit ist sichtbar: <br><br><img src="https://habrastorage.org/webt/tz/vf/gv/tzvfgvzzjnvtp4oqmb3sbgyhehk.png"><br><br>  Diese Koeffizienten werden theoretisch berechnet.  Jedes Blau ist die Summe von oben und links.  Und die violetten sind die gleichen blauen, nur in umgekehrter Reihenfolge.  Sie können rechnen, aber dies ist wieder eine Rekursion, und darin war ich enttäuscht.  Höchstwahrscheinlich haben viele (es ist schade, dass ich es nicht bin) diese Zahlen bereits gelernt, aber im Moment werde ich die Intrige nach meiner eigenen Lösung beibehalten.  Ich beschloss, auf sie zu spucken und auf die andere Seite zu gehen. <br><br>  Er öffnete das Exel, baute eine Platte mit den Ergebnissen der Funktion und begann nach Mustern zu suchen.  C3 = IF (C $ 2&gt; $ B3; 2 ^ $ B3-1; C2 + B2 + 1), wobei $ 2 die Zeile mit der Anzahl der Eier (1-13) ist, $ B die Spalte mit der Anzahl der Versuche (1-20) ist; C3 - Zelle am Schnittpunkt zweier Eier und eines Versuchs. <br><br><img src="https://habrastorage.org/webt/da/u4/uz/dau4uz9wluuwrll54ugfiol02uq.png"><br><br>  Die graue Diagonale ist N = M, und hier ist deutlich zu erkennen, dass sich rechts davon (für N&gt; M) nichts ändert.  Es kann gesehen werden - aber es kann nicht anders sein, denn dies sind alle Ergebnisse der Arbeit der Formel, in der angegeben wird, dass jede Zelle gleich der Summe von oben, oben links und eins ist.  Es wurde jedoch keine universelle Formel gefunden, bei der Sie N und M ersetzen und die Bodennummer erhalten können.  Spoiler: existiert nicht.  Aber dann ist es so einfach, diese Tabelle in Excel zu erstellen. Vielleicht ist es möglich, dieselbe Python zu generieren und Antworten daraus zu ziehen. <br><br><h3>  Numpy tust du nicht </h3><br>  Ich erinnere mich, dass es NumPy gibt, das nur für die Arbeit mit mehrdimensionalen Arrays entwickelt wurde. Warum probieren Sie es nicht aus?  Zunächst benötigen wir ein eindimensionales Array von Nullen der Größe N + 1 und ein eindimensionales Array von Einheiten der Größe N. Nehmen Sie das erste Array von Null zum vorletzten Element und fügen Sie es elementweise mit dem ersten Array vom ersten bis zum letzten Element und mit einem Array von Einheiten hinzu.  Fügen Sie dem resultierenden Array am Anfang Null hinzu.  M-mal wiederholen.  Die Elementnummer N des resultierenden Arrays ist die Antwort.  Die ersten 3 Schritte sehen folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/4w/hf/ki/4whfkie9lt2lkiyywknshrit0h4.png"><br><br>  NumPy arbeitet so schnell, dass ich nicht die gesamte Tabelle gespeichert habe - jedes Mal, wenn ich die erforderliche Zeile erneut lese.  Eine Sache - das Ergebnis der Arbeit an großen Zahlen war falsch.  Höhere Ränge sind wie diese, die niedrigeren nicht.  So sehen die arithmetischen Fehler von Gleitkommazahlen aus, die sich aus mehreren Additionen ergeben.  Es spielt keine Rolle - Sie können den Typ des Arrays in int ändern.  Nein, Ärger - es stellte sich heraus, dass NumPy aus Gründen der Geschwindigkeit nur mit seinen Datentypen arbeitet und sein int im Gegensatz zum Python int nicht mehr als 2 ^ 64-1 sein kann. Danach läuft es still über und fährt mit -2 ^ 64 fort.  Und ich erwarte tatsächlich Zahlen unter dreitausend Zeichen.  Aber es funktioniert sehr schnell, f (9477, 10000) läuft 233 ms, es stellt sich nur eine Art Unsinn am Ausgang heraus.  Ich werde nicht einmal den Code geben, da so etwas.  Ich werde versuchen, dasselbe zu einer sauberen Python zu machen. <br><br><h3>  Iteriert, iteriert, aber nicht iteriert </h3><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y+<span class="hljs-number"><span class="hljs-number">1</span></span>, arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[n]</code> </pre> <br>  44 Sekunden zur Berechnung von f (9477, 10000) sind etwas viel.  Aber absolut sicher.  Was kann optimiert werden?  Erstens muss nicht alles rechts von der Diagonale M, M betrachtet werden.  Die zweite - das letzte Array als Ganzes für eine Zelle zu betrachten.  Dazu passen die letzten beiden Zellen der vorherigen.  Um f (10, 20) zu berechnen, reichen nur diese grauen Zellen aus: <br><br><img src="https://habrastorage.org/webt/zc/zm/zg/zczmzgfzspyvo2zenqsk4p9y1jo.png"><br><br>  Und so sieht es im Code aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; n <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i &lt; mn: <span class="hljs-comment"><span class="hljs-comment">#    m,m arr = [0] + list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr += [arr[-1]] i+=1 arr.pop(-1) while i &lt; n or i &lt; mn: #        arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr = arr + [arr[-1]+1] if n &gt; len(arr) else [0] + arr i+=1 while i &lt; m: # ,     -  arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) i+=1 return arr[0]</span></span></code> </pre> <br>  Und was denkst du?  f (9477, 10000) in 2 Sekunden!  Diese Eingabe ist jedoch zu gut. Die Länge des Arrays beträgt zu jedem Zeitpunkt nicht mehr als 533 Elemente (10000-9477).  Lassen Sie uns f (5477, 10000) - 11 Sekunden überprüfen.  Es ist auch gut, aber nur im Vergleich zu 44 Sekunden - zwanzig Tests mit dieser Zeit werden nicht bestanden. <br><br>  Das ist es nicht.  Aber da es eine Aufgabe gibt, dann gibt es eine Lösung, die Suche wird fortgesetzt.  Ich fing wieder an, die Excel-Tabelle zu betrachten.  Die Zelle links von (m, m) ist immer eins weniger.  Und die Zelle links davon ist nicht mehr da, in jeder Reihe wird der Unterschied größer.  Die Zelle darunter (m, m) ist immer doppelt so groß.  Und die Zelle darunter ist nicht mehr zweimal, sondern etwas kleiner, aber für jede Spalte anders, je weiter, desto größer.  Und auch die Zahlen in einer Zeile wachsen zunächst schnell und nach der Mitte langsam.  Lassen Sie mich eine Tabelle mit Unterschieden zwischen benachbarten Zellen erstellen. Vielleicht wird dort welches Muster angezeigt? <br><br><h3>  Wärmer </h3><br><img src="https://habrastorage.org/webt/6b/vn/we/6bvnwew8keybhtyzxprylcwir6i.png"><br><br>  Bah, vertraute Zahlen!  Das heißt, die Summe N dieser Zahlen in der Zeilennummer M ist dies die Antwort?  Es stimmt, sie zu zählen ist ungefähr das gleiche wie das, was ich bereits getan habe. Es ist unwahrscheinlich, dass dies die Arbeit erheblich beschleunigen wird.  Aber du musst versuchen: <br><br><div class="spoiler">  <b class="spoiler_title">f (9477, 10000): 17 Sekunden</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y, arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:], arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>])) + [<span class="hljs-number"><span class="hljs-number">1</span></span>] m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:n+<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Oder 8, wenn Sie nur das halbe Dreieck zählen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(arr) &lt; n+<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">#    ,  n &lt;  arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr += [arr[-1]] m-=2 while m &gt; 1: arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) m-=1 if len(arr) &lt; n+1: arr += arr[::-1][1:] #  n   ,   return sum(arr[1:n+1])</span></span></code> </pre><br></div></div><br>  Um nicht zu sagen, dass eine optimalere Lösung.  Bei einigen Daten funktioniert es schneller, bei einigen langsamer.  Wir müssen tiefer gehen.  Was ist dieses Dreieck mit Zahlen, die zweimal in der Lösung vorkamen?  Es ist eine Schande zuzugeben, aber ich habe die höhere Mathematik, in der das Dreieck gedacht haben muss, sicher vergessen, also musste ich es googeln. <br><br><h3>  Bingo! </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pascals Dreieck</a> , wie es offiziell genannt wird.  Unendliche Binomialkoeffiziententabelle.  Die Antwort auf das Problem mit N Eiern und M Würfen ist also die Summe der ersten N Koeffizienten bei der Erweiterung des Newton-Binomials vom M-ten Grad mit Ausnahme der Null. <br><br>  Ein beliebiger Binomialkoeffizient kann durch die Fakultäten der Zeilennummer und der Koeffizientennummer in der Zeile berechnet werden: bk = m! / (N! * (Mn!)).  Das Beste ist jedoch, dass Sie die Zahlen in der Zeichenfolge nacheinander berechnen können, wobei Sie die Anzahl und den Nullkoeffizienten (immer eins) kennen: bk [n] = bk [n-1] * (m - n + 1) / n.  Bei jedem Schritt verringert sich der Zähler um eins und der Nenner erhöht sich.  Und die prägnante endgültige Lösung sieht folgendermaßen aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> h, bk = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#      for i in range(1, n + 1): bk = bk * m // ih += bk m-=1 return h</span></span></code> </pre><br>  33 ms  zur Berechnung von f (9477, 10000)!  Diese Lösung kann auch optimiert werden, obwohl in den angegebenen Bereichen und es funktioniert gut.  Wenn n in der zweiten Hälfte des Dreiecks liegt, können wir es in mn invertieren, die Summe der ersten n Koeffizienten berechnen und von 2 ^ m-2 subtrahieren.  Wenn n nahe an der Mitte liegt und m ungerade ist, können die Berechnungen auch reduziert werden: Die Summe der ersten Hälfte der Linie beträgt 2 ^ (m-1) -1, der letzte Koeffizient in der ersten Hälfte kann durch Fakultäten berechnet werden, seine Zahl ist (m-1) / 2, und fügen Sie dann entweder weitere Koeffizienten hinzu, wenn sich n in der rechten Hälfte des Dreiecks befindet, oder subtrahieren Sie, wenn sich in der linken Hälfte befindet.  Wenn m gerade ist, können Sie die Hälfte der Linie nicht zählen, aber Sie können die Summe der ersten m / 2 + 1-Koeffizienten ermitteln, indem Sie den Durchschnitt durch Fakultäten berechnen und die Hälfte davon zu 2 ^ (m-1) -1 addieren.  Bei Eingabedaten im Bereich von 10 ^ 6 reduziert dies die Ausführungszeit sehr deutlich. <br><br>  Nach einer erfolgreichen Entscheidung begann ich, nach Recherchen anderer zu diesem Thema zu suchen, fand aber in den Interviews nur dasselbe mit nur zwei Eiern, und dies ist kein Sport.  Das Internet wird ohne meine Entscheidung unvollständig sein, entschied ich, und hier ist es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423679/">https://habr.com/ru/post/de423679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423651/index.html">Wir laden alle zum Hackathon SmartMail Hack: About Welcome ein</a></li>
<li><a href="../de423655/index.html">Generika + Frühling: Möge die Macht mit dir sein</a></li>
<li><a href="../de423657/index.html">Ich respektiere die Kapselung nicht oder verwende keine andere Art von Methodentabelle, um schnell private Methoden aufzurufen</a></li>
<li><a href="../de423663/index.html">Wir schreiben einen einfachen Übersetzer in Lisp - III</a></li>
<li><a href="../de423677/index.html">Jetpack-Piloten: Frankie West</a></li>
<li><a href="../de423683/index.html">Basierend auf gesundem Menschenverstand: DevOps von Grund auf neu entwickeln</a></li>
<li><a href="../de423685/index.html">PostgreSQL-Parallelität: nicht kugelförmig, kein Pferd, nicht im Vakuum</a></li>
<li><a href="../de423687/index.html">HyperX Pulsefire FPS Pro - schneller, gemeiner, erschwinglicher</a></li>
<li><a href="../de423689/index.html">RTOS MAX - kostenlos? Wir planen, eine Lizenz für die kostenlose kommerzielle Nutzung zu eröffnen</a></li>
<li><a href="../de423693/index.html">Eine andere Möglichkeit, Webpack 4 und Codetrennung zu verwenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>