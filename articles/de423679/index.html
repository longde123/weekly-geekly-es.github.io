<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸšŸ â–ªï¸ ğŸ­ Eine Aufgabe mit Wolkenkratzer und Eiern - nicht Newtons MÃ¼lleimer? ğŸ¤§ ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ ğŸ‘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In der Tat ist er der meiste. Aber das Wichtigste zuerst. 

 ErklÃ¤rung des Problems 
 Ich beherrsche Python, lÃ¶se alles auf Codewars. Ich stoÃŸe auf ei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Eine Aufgabe mit Wolkenkratzer und Eiern - nicht Newtons MÃ¼lleimer?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423679/">  In der Tat ist er der meiste.  Aber das Wichtigste zuerst. <br><br><h3>  ErklÃ¤rung des Problems </h3><br>  Ich beherrsche Python, lÃ¶se alles auf Codewars.  Ich stoÃŸe auf eine bekannte Aufgabe Ã¼ber einen Wolkenkratzer und Eier.  Der einzige Unterschied besteht darin, dass die Quelldaten nicht 100 Stockwerke und 2 Eier sind, sondern etwas mehr. <br>  Gegeben: N Eier, M versucht sie zu werfen, endloser Wolkenkratzer. <br><br>  Definieren: Der maximale Boden, von dem aus Sie ein Ei werfen kÃ¶nnen, ohne zu brechen.  Eier sind im Vakuum kugelfÃ¶rmig und wenn eines von ihnen nicht bricht und beispielsweise aus dem 99. Stock fÃ¤llt, halten die anderen auch einem Sturz aus allen Stockwerken unter einem Hundertstel stand. <br><br>  0 &lt;= N, M &lt;= 20.000. <br>  Die Laufzeit von zwei Dutzend Tests betrÃ¤gt 12 Sekunden. <br><a name="habracut"></a><br><h3>  Suche nach einer LÃ¶sung </h3><br>  Wir mÃ¼ssen eine FunktionshÃ¶he (n, m) schreiben, die die Bodennummer fÃ¼r das angegebene n, m zurÃ¼ckgibt.  Da es sehr oft erwÃ¤hnt wird und jedes Mal, wenn Sie "HÃ¶he" Faulheit schreiben, werde ich es Ã¼berall auÃŸer dem Code als f (n, m) bezeichnen. <br><br>  Beginnen wir mit Nullen.  Wenn es keine Eier gibt oder versucht wird, sie zu werfen, kann natÃ¼rlich nichts bestimmt werden und die Antwort ist Null.  <b>f (0, m) = 0, f (n, 0) = 0.</b> <br><br>  Angenommen, es gibt ein Ei und es gibt 10 Versuche. Sie kÃ¶nnen alles riskieren und es sofort aus dem hundertsten Stock werfen, aber im Falle eines Fehlers kÃ¶nnen Sie nichts anderes bestimmen. Es ist also logischer, vom ersten Stock aus zu beginnen und nach jedem Wurf einen Stock nach oben zu gehen. bis entweder der Versuch oder das Ei endet.  Das Maximum, wo Sie bekommen kÃ¶nnen, wenn das Ei nicht versagt, ist Boden Nummer 10. <b>f (1, m) = m</b> <br><br>  Nehmen Sie das zweite Ei, versuchen Sie es erneut 10. Nun, dann kÃ¶nnen Sie eine Chance mit einem Hundertstel eingehen?  Wenn es kaputt geht, gibt es noch einen und 9 Versuche, mindestens 9 Stockwerke kÃ¶nnen passieren.  Vielleicht mÃ¼ssen Sie also nicht vom hundertsten, sondern vom zehnten riskieren?  Ist logisch.  Bei Erfolg bleiben dann 2 Eier und 9 Versuche Ã¼brig.  Analog dazu mÃ¼ssen Sie jetzt weitere 9 Stockwerke hinaufsteigen.  Mit einer Reihe von Erfolgen - weitere 8, 7, 6, 5, 4, 3, 2 und 1. Insgesamt befinden wir uns mit zwei ganzen Eiern im 55. Stock und ohne es zu versuchen.  Die Antwort ist die Summe der ersten M Mitglieder der arithmetischen Folge mit dem ersten Element 1 und Schritt 1. <b>f (2, m) = (m * m + m) / 2</b> .  Es ist auch klar, dass bei jedem Schritt die Funktion f (1, m) aufgerufen wurde, aber dies ist noch nicht genau. <br><br>  Fahren Sie mit drei Eiern und zehn Versuchen fort.  Im Falle eines erfolglosen ersten Wurfs werden die mit 2 Eiern und 9 Versuchen bedeckten BÃ¶den von unten bedeckt, was bedeutet, dass der erste Wurf vom Boden f (2, 9) + 1 ausgefÃ¼hrt werden muss. Wenn dies erfolgreich ist, haben wir 3 Eier und 9 Versuche .  Und fÃ¼r den zweiten Versuch mÃ¼ssen Sie weitere f (2.8) + 1 Stockwerke hinaufsteigen.  Und so weiter, bis 3 Eier und 3 Versuche an den HÃ¤nden bleiben.  Und dann ist es Zeit, sich ablenken zu lassen, indem man FÃ¤lle mit N = M betrachtet, in denen es so viele Eier gibt, wie es Versuche gibt. <br><br><div class="spoiler">  <b class="spoiler_title">Und zur gleichen Zeit, wenn es mehr Eier gibt.</b> <div class="spoiler_text">  Aber hier ist alles offensichtlich - Eier jenseits derjenigen, die brechen, werden fÃ¼r uns nicht nÃ¼tzlich sein, selbst wenn jeder Wurf erfolglos ist.  <b>f (n, m) = f (m, m), wenn n&gt; m ist</b> .  Und alles in allem 3 Eier, 3 WÃ¼rfe.  Wenn das erste Ei zerbricht, kÃ¶nnen Sie f (2, 2) Stockwerke nach unten Ã¼berprÃ¼fen, und wenn es nicht bricht, dann f (3,2) Stockwerke nach oben, dh das gleiche f (2, 2).  Insgesamt f (3, 3) = 2 * f (2, 2) + 1 = 7. Und f (4, 4) besteht analog aus zwei f (3, 3) und einem, und es wird 15. Alle sein es Ã¤hnelt den Zweierpotenzen, und wir schreiben: <b>f (m, m) = 2 ^ m - 1</b> . <br><br>  Es sieht aus wie eine binÃ¤re Suche in der physischen Welt: Wir gehen von der Etage Nummer 2 ^ (m-1) aus, im Erfolgsfall gehen wir 2 ^ (m-2) Etagen hÃ¶her und im Falle eines Misserfolgs gehen wir so viel runter und so weiter. bis die Versuche ausgehen.  In unserem Fall stehen wir die ganze Zeit auf. <br></div></div><br>  Kehren wir zu f (3, 10) zurÃ¼ck.  TatsÃ¤chlich kommt es bei jedem Schritt auf die Summe f (2, m-1) an - die Anzahl der Stockwerke, die im Falle eines Ausfalls bestimmt werden kÃ¶nnen, Einheiten und f (3, m-1) - die Anzahl der Stockwerke, die im Erfolgsfall bestimmt werden kÃ¶nnen.  Und es wird deutlich, dass es aufgrund der Zunahme der Anzahl der Eier und Versuche unwahrscheinlich ist, dass sich etwas Ã¤ndert.  <b>f (n, m) = f (n - 1, m - 1) + 1 + f (n, m - 1)</b> .  Und dies ist eine universelle Formel, die in Code implementiert werden kann. <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> lru_cache @lru_cache() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n,m)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n==<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> m==<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n==<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m**<span class="hljs-number"><span class="hljs-number">2</span></span>+m)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> n&gt;=m: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>**n<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> height(n<span class="hljs-number"><span class="hljs-number">-1</span></span>,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>+height(n,m<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br>  NatÃ¼rlich bin ich zuvor auf den Rechen der nicht-meroisierenden rekursiven Funktionen getreten und habe herausgefunden, dass f (10, 40) mit der Anzahl der Aufrufe an sich fast 40 Sekunden dauert - 97806983. Aber das Memoisieren wird auch nur in den Anfangsintervallen gespeichert.  Wenn f (200.400) in 0,8 Sekunden ausgefÃ¼hrt wird, ist f (200, 500) bereits in 31 Sekunden.  Es ist lustig, dass bei der Messung der Laufzeit mit% timeit das Ergebnis viel weniger als real ist.  Offensichtlich dauert der erste Durchlauf der Funktion die meiste Zeit, wÃ¤hrend der Rest einfach die Ergebnisse seiner Memoisierung verwendet.  LÃ¼gen, eklatante LÃ¼gen und Statistiken. <br><br><h3>  Rekursion ist nicht erforderlich, wir schauen weiter </h3><br>  So erscheint zum Beispiel in den Tests f (9477, 10000), aber mein erbÃ¤rmliches f (200, 500) passt nicht mehr zum richtigen Zeitpunkt.  Es gibt also eine andere LÃ¶sung, ohne Rekursion werden wir die Suche fortsetzen.  Ich habe den Code ergÃ¤nzt, indem ich Funktionsaufrufe mit bestimmten Parametern gezÃ¤hlt habe, um zu sehen, in was er sich letztendlich zerlegt hat.  FÃ¼r 10 Versuche wurden die folgenden Ergebnisse erhalten: <br><br>  f (3,10) = 7+ 1 Â· f (2,9) + 1 Â· f (2,8) + 1 Â· f (2,7) + 1 Â· f (2,6) + 1 Â· f (2 , 5) + 1 Â· f (2,4) + 1 Â· f (2,3) + 1 Â· f (3,3) <br>  f (4,10) = 27+ 1 Â· f (2,8) + 2 Â· f (2,7) + 3 Â· f (2,6) + 4 Â· f (2,5) + 5 Â· f (2 , 4) + 6 Â· f (2,3) + 6 Â· f (3,3) + 1 Â· f (4,4) <br>  f (5,10) = 55+ 1 Â· f (2,7) + 3 Â· f (2,6) + 6 Â· f (2,5) + 10 Â· f (2,4) + 15 Â· f (2 , 3) + 15 Â· f (3,3) + 5 Â· f (4,4) + 1 Â· f (5,5) <br>  f (6,10) = 69+ 1 Â· f (2,6) + 4 Â· f (2,5) + 10 Â· f (2,4) + 20 Â· f (2,3) + 20 Â· f (3 , 3) + 10 Â· f (4,4) + 4 Â· f (5,5) + 1 Â· f (6,6) <br>  f (7,10) = 55+ 1 Â· f (2,5) + 5 Â· f (2,4) + 15 Â· f (2,3) + 15 Â· f (3,3) + 10 Â· f (4) , 4) + 6 Â· f (5,5) + 3 Â· f (6,6) + 1 Â· f (7,7) <br>  f (8,10) = 27+ 1 Â· f (2,4) + 6 Â· f (2,3) + 6 Â· f (3,3) + 5 Â· f (4,4) + 4 Â· f (5) , 5) + 3 Â· f (6,6) + 2 Â· f (7,7) + 1 Â· f (8,8) <br>  f (9,10) = 7+ 1 Â· f (2,3) + 1 Â· f (3,3) + 1 Â· f (4,4) + 1 Â· f (5,5) + 1 Â· f (6) , 6) + 1 Â· f (7,7) + 1 Â· f (8,8) + 1 Â· f (9,9) <br><br>  Eine gewisse RegelmÃ¤ÃŸigkeit ist sichtbar: <br><br><img src="https://habrastorage.org/webt/tz/vf/gv/tzvfgvzzjnvtp4oqmb3sbgyhehk.png"><br><br>  Diese Koeffizienten werden theoretisch berechnet.  Jedes Blau ist die Summe von oben und links.  Und die violetten sind die gleichen blauen, nur in umgekehrter Reihenfolge.  Sie kÃ¶nnen rechnen, aber dies ist wieder eine Rekursion, und darin war ich enttÃ¤uscht.  HÃ¶chstwahrscheinlich haben viele (es ist schade, dass ich es nicht bin) diese Zahlen bereits gelernt, aber im Moment werde ich die Intrige nach meiner eigenen LÃ¶sung beibehalten.  Ich beschloss, auf sie zu spucken und auf die andere Seite zu gehen. <br><br>  Er Ã¶ffnete das Exel, baute eine Platte mit den Ergebnissen der Funktion und begann nach Mustern zu suchen.  C3 = IF (C $ 2&gt; $ B3; 2 ^ $ B3-1; C2 + B2 + 1), wobei $ 2 die Zeile mit der Anzahl der Eier (1-13) ist, $ B die Spalte mit der Anzahl der Versuche (1-20) ist; C3 - Zelle am Schnittpunkt zweier Eier und eines Versuchs. <br><br><img src="https://habrastorage.org/webt/da/u4/uz/dau4uz9wluuwrll54ugfiol02uq.png"><br><br>  Die graue Diagonale ist N = M, und hier ist deutlich zu erkennen, dass sich rechts davon (fÃ¼r N&gt; M) nichts Ã¤ndert.  Es kann gesehen werden - aber es kann nicht anders sein, denn dies sind alle Ergebnisse der Arbeit der Formel, in der angegeben wird, dass jede Zelle gleich der Summe von oben, oben links und eins ist.  Es wurde jedoch keine universelle Formel gefunden, bei der Sie N und M ersetzen und die Bodennummer erhalten kÃ¶nnen.  Spoiler: existiert nicht.  Aber dann ist es so einfach, diese Tabelle in Excel zu erstellen. Vielleicht ist es mÃ¶glich, dieselbe Python zu generieren und Antworten daraus zu ziehen. <br><br><h3>  Numpy tust du nicht </h3><br>  Ich erinnere mich, dass es NumPy gibt, das nur fÃ¼r die Arbeit mit mehrdimensionalen Arrays entwickelt wurde. Warum probieren Sie es nicht aus?  ZunÃ¤chst benÃ¶tigen wir ein eindimensionales Array von Nullen der GrÃ¶ÃŸe N + 1 und ein eindimensionales Array von Einheiten der GrÃ¶ÃŸe N. Nehmen Sie das erste Array von Null zum vorletzten Element und fÃ¼gen Sie es elementweise mit dem ersten Array vom ersten bis zum letzten Element und mit einem Array von Einheiten hinzu.  FÃ¼gen Sie dem resultierenden Array am Anfang Null hinzu.  M-mal wiederholen.  Die Elementnummer N des resultierenden Arrays ist die Antwort.  Die ersten 3 Schritte sehen folgendermaÃŸen aus: <br><br><img src="https://habrastorage.org/webt/4w/hf/ki/4whfkie9lt2lkiyywknshrit0h4.png"><br><br>  NumPy arbeitet so schnell, dass ich nicht die gesamte Tabelle gespeichert habe - jedes Mal, wenn ich die erforderliche Zeile erneut lese.  Eine Sache - das Ergebnis der Arbeit an groÃŸen Zahlen war falsch.  HÃ¶here RÃ¤nge sind wie diese, die niedrigeren nicht.  So sehen die arithmetischen Fehler von Gleitkommazahlen aus, die sich aus mehreren Additionen ergeben.  Es spielt keine Rolle - Sie kÃ¶nnen den Typ des Arrays in int Ã¤ndern.  Nein, Ã„rger - es stellte sich heraus, dass NumPy aus GrÃ¼nden der Geschwindigkeit nur mit seinen Datentypen arbeitet und sein int im Gegensatz zum Python int nicht mehr als 2 ^ 64-1 sein kann. Danach lÃ¤uft es still Ã¼ber und fÃ¤hrt mit -2 ^ 64 fort.  Und ich erwarte tatsÃ¤chlich Zahlen unter dreitausend Zeichen.  Aber es funktioniert sehr schnell, f (9477, 10000) lÃ¤uft 233 ms, es stellt sich nur eine Art Unsinn am Ausgang heraus.  Ich werde nicht einmal den Code geben, da so etwas.  Ich werde versuchen, dasselbe zu einer sauberen Python zu machen. <br><br><h3>  Iteriert, iteriert, aber nicht iteriert </h3><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>]*(n+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y+<span class="hljs-number"><span class="hljs-number">1</span></span>, arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:])) m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr[n]</code> </pre> <br>  44 Sekunden zur Berechnung von f (9477, 10000) sind etwas viel.  Aber absolut sicher.  Was kann optimiert werden?  Erstens muss nicht alles rechts von der Diagonale M, M betrachtet werden.  Die zweite - das letzte Array als Ganzes fÃ¼r eine Zelle zu betrachten.  Dazu passen die letzten beiden Zellen der vorherigen.  Um f (10, 20) zu berechnen, reichen nur diese grauen Zellen aus: <br><br><img src="https://habrastorage.org/webt/zc/zm/zg/zczmzgfzspyvo2zenqsk4p9y1jo.png"><br><br>  Und so sieht es im Code aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] i = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; n <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> i &lt; mn: <span class="hljs-comment"><span class="hljs-comment">#    m,m arr = [0] + list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr += [arr[-1]] i+=1 arr.pop(-1) while i &lt; n or i &lt; mn: #        arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) arr = arr + [arr[-1]+1] if n &gt; len(arr) else [0] + arr i+=1 while i &lt; m: # ,     -  arr = list(map(lambda x,y: x+y+1, arr[:-1], arr[1:])) i+=1 return arr[0]</span></span></code> </pre> <br>  Und was denkst du?  f (9477, 10000) in 2 Sekunden!  Diese Eingabe ist jedoch zu gut. Die LÃ¤nge des Arrays betrÃ¤gt zu jedem Zeitpunkt nicht mehr als 533 Elemente (10000-9477).  Lassen Sie uns f (5477, 10000) - 11 Sekunden Ã¼berprÃ¼fen.  Es ist auch gut, aber nur im Vergleich zu 44 Sekunden - zwanzig Tests mit dieser Zeit werden nicht bestanden. <br><br>  Das ist es nicht.  Aber da es eine Aufgabe gibt, dann gibt es eine LÃ¶sung, die Suche wird fortgesetzt.  Ich fing wieder an, die Excel-Tabelle zu betrachten.  Die Zelle links von (m, m) ist immer eins weniger.  Und die Zelle links davon ist nicht mehr da, in jeder Reihe wird der Unterschied grÃ¶ÃŸer.  Die Zelle darunter (m, m) ist immer doppelt so groÃŸ.  Und die Zelle darunter ist nicht mehr zweimal, sondern etwas kleiner, aber fÃ¼r jede Spalte anders, je weiter, desto grÃ¶ÃŸer.  Und auch die Zahlen in einer Zeile wachsen zunÃ¤chst schnell und nach der Mitte langsam.  Lassen Sie mich eine Tabelle mit Unterschieden zwischen benachbarten Zellen erstellen. Vielleicht wird dort welches Muster angezeigt? <br><br><h3>  WÃ¤rmer </h3><br><img src="https://habrastorage.org/webt/6b/vn/we/6bvnwew8keybhtyzxprylcwir6i.png"><br><br>  Bah, vertraute Zahlen!  Das heiÃŸt, die Summe N dieser Zahlen in der Zeilennummer M ist dies die Antwort?  Es stimmt, sie zu zÃ¤hlen ist ungefÃ¤hr das gleiche wie das, was ich bereits getan habe. Es ist unwahrscheinlich, dass dies die Arbeit erheblich beschleunigen wird.  Aber du musst versuchen: <br><br><div class="spoiler">  <b class="spoiler_title">f (9477, 10000): 17 Sekunden</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>: arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>] + list(map(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x,y: x+y, arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:], arr[:<span class="hljs-number"><span class="hljs-number">-1</span></span>])) + [<span class="hljs-number"><span class="hljs-number">1</span></span>] m-=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum(arr[<span class="hljs-number"><span class="hljs-number">1</span></span>:n+<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Oder 8, wenn Sie nur das halbe Dreieck zÃ¤hlen</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> len(arr) &lt; n+<span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment">#    ,  n &lt;  arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) arr += [arr[-1]] m-=2 while m &gt; 1: arr = [1] + list(map(lambda x,y: x+y, arr[1:], arr[:-1])) m-=1 if len(arr) &lt; n+1: arr += arr[::-1][1:] #  n   ,   return sum(arr[1:n+1])</span></span></code> </pre><br></div></div><br>  Um nicht zu sagen, dass eine optimalere LÃ¶sung.  Bei einigen Daten funktioniert es schneller, bei einigen langsamer.  Wir mÃ¼ssen tiefer gehen.  Was ist dieses Dreieck mit Zahlen, die zweimal in der LÃ¶sung vorkamen?  Es ist eine Schande zuzugeben, aber ich habe die hÃ¶here Mathematik, in der das Dreieck gedacht haben muss, sicher vergessen, also musste ich es googeln. <br><br><h3>  Bingo! </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pascals Dreieck</a> , wie es offiziell genannt wird.  Unendliche Binomialkoeffiziententabelle.  Die Antwort auf das Problem mit N Eiern und M WÃ¼rfen ist also die Summe der ersten N Koeffizienten bei der Erweiterung des Newton-Binomials vom M-ten Grad mit Ausnahme der Null. <br><br>  Ein beliebiger Binomialkoeffizient kann durch die FakultÃ¤ten der Zeilennummer und der Koeffizientennummer in der Zeile berechnet werden: bk = m! / (N! * (Mn!)).  Das Beste ist jedoch, dass Sie die Zahlen in der Zeichenfolge nacheinander berechnen kÃ¶nnen, wobei Sie die Anzahl und den Nullkoeffizienten (immer eins) kennen: bk [n] = bk [n-1] * (m - n + 1) / n.  Bei jedem Schritt verringert sich der ZÃ¤hler um eins und der Nenner erhÃ¶ht sich.  Und die prÃ¤gnante endgÃ¼ltige LÃ¶sung sieht folgendermaÃŸen aus: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function">:</span></span> h, bk = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#      for i in range(1, n + 1): bk = bk * m // ih += bk m-=1 return h</span></span></code> </pre><br>  33 ms  zur Berechnung von f (9477, 10000)!  Diese LÃ¶sung kann auch optimiert werden, obwohl in den angegebenen Bereichen und es funktioniert gut.  Wenn n in der zweiten HÃ¤lfte des Dreiecks liegt, kÃ¶nnen wir es in mn invertieren, die Summe der ersten n Koeffizienten berechnen und von 2 ^ m-2 subtrahieren.  Wenn n nahe an der Mitte liegt und m ungerade ist, kÃ¶nnen die Berechnungen auch reduziert werden: Die Summe der ersten HÃ¤lfte der Linie betrÃ¤gt 2 ^ (m-1) -1, der letzte Koeffizient in der ersten HÃ¤lfte kann durch FakultÃ¤ten berechnet werden, seine Zahl ist (m-1) / 2, und fÃ¼gen Sie dann entweder weitere Koeffizienten hinzu, wenn sich n in der rechten HÃ¤lfte des Dreiecks befindet, oder subtrahieren Sie, wenn sich in der linken HÃ¤lfte befindet.  Wenn m gerade ist, kÃ¶nnen Sie die HÃ¤lfte der Linie nicht zÃ¤hlen, aber Sie kÃ¶nnen die Summe der ersten m / 2 + 1-Koeffizienten ermitteln, indem Sie den Durchschnitt durch FakultÃ¤ten berechnen und die HÃ¤lfte davon zu 2 ^ (m-1) -1 addieren.  Bei Eingabedaten im Bereich von 10 ^ 6 reduziert dies die AusfÃ¼hrungszeit sehr deutlich. <br><br>  Nach einer erfolgreichen Entscheidung begann ich, nach Recherchen anderer zu diesem Thema zu suchen, fand aber in den Interviews nur dasselbe mit nur zwei Eiern, und dies ist kein Sport.  Das Internet wird ohne meine Entscheidung unvollstÃ¤ndig sein, entschied ich, und hier ist es. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423679/">https://habr.com/ru/post/de423679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423651/index.html">Wir laden alle zum Hackathon SmartMail Hack: About Welcome ein</a></li>
<li><a href="../de423655/index.html">Generika + FrÃ¼hling: MÃ¶ge die Macht mit dir sein</a></li>
<li><a href="../de423657/index.html">Ich respektiere die Kapselung nicht oder verwende keine andere Art von Methodentabelle, um schnell private Methoden aufzurufen</a></li>
<li><a href="../de423663/index.html">Wir schreiben einen einfachen Ãœbersetzer in Lisp - III</a></li>
<li><a href="../de423677/index.html">Jetpack-Piloten: Frankie West</a></li>
<li><a href="../de423683/index.html">Basierend auf gesundem Menschenverstand: DevOps von Grund auf neu entwickeln</a></li>
<li><a href="../de423685/index.html">PostgreSQL-ParallelitÃ¤t: nicht kugelfÃ¶rmig, kein Pferd, nicht im Vakuum</a></li>
<li><a href="../de423687/index.html">HyperX Pulsefire FPS Pro - schneller, gemeiner, erschwinglicher</a></li>
<li><a href="../de423689/index.html">RTOS MAX - kostenlos? Wir planen, eine Lizenz fÃ¼r die kostenlose kommerzielle Nutzung zu erÃ¶ffnen</a></li>
<li><a href="../de423693/index.html">Eine andere MÃ¶glichkeit, Webpack 4 und Codetrennung zu verwenden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>