<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❇️ 🏴󠁧󠁢󠁥󠁮󠁧󠁿 👲🏼 Núcleo ASP.NET válido 🤟🏽 📐 👩🏿‍🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Especialmente para os amantes de livros da série "C ++ em 24 horas", decidi escrever um artigo sobre o ASP.NET Core. 


 Se você não desenvolveu o .NE...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Núcleo ASP.NET válido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437002/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="Núcleo ASP.NET válido"></a> </p><br><p>  Especialmente para os amantes de livros da série "C ++ em 24 horas", decidi escrever um artigo sobre o ASP.NET Core. </p><br><p>  Se você não desenvolveu o .NET ou qualquer plataforma semelhante antes, não faz sentido entrar em detalhes.  Mas se você estiver interessado em saber o que são IoC, DI, DIP, Interseptores, Middleware, Filtros (ou seja, tudo o que distingue o Core do .NET clássico), então você definitivamente precisa clicar em "Leia mais" à medida que estiver desenvolvendo Sem entender tudo isso, claramente não está correto. </p><a name="habracut"></a><br><h2 id="ioc-di-dip">  IoC, DI, DIP </h2><br><p>  Se um teatro começa com um cabide, o ASP.NET Core inicia com uma injeção de dependência.  Para lidar com o DI, você precisa entender o que é IoC. </p><br><p>  Falando sobre IoC, muitas vezes se lembra do princípio de Hollywood de "Não ligue para nós, nós ligaremos para você".  O que significa "Não há necessidade de nos ligar, nós mesmos ligaremos para você". </p><br><p> Fontes diferentes fornecem padrões diferentes aos quais a IoC pode ser aplicada.  E provavelmente eles estão bem e apenas se complementam.  Aqui estão alguns desses padrões: fábrica, localizador de serviço, método de modelo, observador, estratégia. </p><br><p>  Vejamos a IoC usando um aplicativo de console simples como exemplo. </p><br><p>  Suponha que tenhamos duas classes simples que implementam uma interface com um método: </p><br><pre><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p>  Ambos dependem da abstração (neste caso, a interface atua como uma abstração). </p><br><p>  E digamos que temos um objeto de nível superior usando estas classes: </p><br><pre> <code class="plaintext hljs"> class Logging : ILayer { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Dependendo do parâmetro do construtor, a variável _instance é inicializada por uma classe específica.  Além disso, ao chamar Write, a saída para o console ou para Debug será concluída.  Tudo parece estar muito bom e até parece corresponder à primeira parte do princípio da Inversão da Dependência </p><br><blockquote>  Objetos de nível superior são independentes dos objetos de nível inferior.  Ambos e aqueles dependem de abstrações. </blockquote><p>  No nosso caso, o ILayer atua como uma abstração. </p><br><p>  Mas também devemos ter um objeto de nível ainda mais alto.  Um que usa a classe Logging </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Ao inicializar o Log com 1, obtemos na classe Logging uma instância da classe que gera dados para o console.  Se inicializarmos o Log com qualquer outro número, o log.Write produzirá dados para Debug.  Parece que tudo funciona, mas funciona mal.  Nosso objeto de nível superior Main depende dos detalhes do código do objeto de nível inferior - a classe Logging.  Se mudarmos algo nesta classe, precisaremos alterar o código da classe Main.  Para impedir que isso aconteça, faremos uma inversão de controle - Inversão de Controle.  Vamos fazer com que a classe Main controle o que acontece na classe Logging.  A classe Logging receberá, como parâmetro construtor, uma instância de uma classe que implementa a interface ILayer </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  E agora, nossa classe Principal ficará assim: </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  De fato, decoramos nosso objeto Logging com o objeto necessário para nós. </p><br><p>  Agora, nosso aplicativo está em conformidade com a segunda parte do princípio de Inversão de dependência: </p><br><blockquote>  As abstrações são independentes dos detalhes.  Os detalhes dependem das abstrações.  I.e.  não sabemos os detalhes do que está acontecendo na classe Logging, apenas passamos a classe para lá que implementa a abstração necessária. </blockquote><p>  Existe um termo termo acoplamento estanque - conexão estanque.  Quanto mais fraca a conexão entre os componentes no aplicativo, melhor.  Gostaria de observar que este exemplo de uma aplicação simples não atinge nem um pouco o ideal.  Porque  Sim, porque na classe de nível mais alto em Main, usamos duas vezes a criação de instâncias de classe usando new.  E existe uma frase mnemônica “Novo é uma pista” - o que significa que quanto menos você usar novo, menos conexões estreitas de componentes no aplicativo e melhor.  Idealmente, não devemos usar o novo DebugLayer, mas devemos obter o DebugLayer de alguma outra maneira.  Qual?  Por exemplo, de um contêiner de IoC ou usando a reflexão de um parâmetro passado para Principal. </p><br><p>  Agora, descobrimos o que é Inversion of Control (IoC) e o que é Dependency Inversion (DIP).  Resta entender o que é injeção de dependência (DI).  IoC é um paradigma de design.  Injeção de Dependência é um padrão.  É isso que temos agora no construtor da classe Logging.  Temos uma instância de uma dependência específica.  A classe Logging depende de uma instância de uma classe que implementa ILayer.  E esta instância é injetada através do construtor. </p><br><h2 id="ioc-container">  Container IoC </h2><br><p>  Um contêiner de IoC é um objeto que contém muitas dependências específicas (dependência).  Caso contrário, a dependência pode ser chamada de serviço - como regra, é uma classe com uma certa funcionalidade.  Se necessário, a dependência do tipo requerido pode ser obtida no contêiner.  Injetar dependência em um contêiner é Injetar.  Extrair - resolver.  Aqui está um exemplo do contêiner IoC auto-escrito mais simples: </p><br><pre> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p>  Apenas uma dúzia de linhas de código, mas você já pode usá-lo (não para produção, é claro, mas para fins educacionais). </p><br><p>  Você pode registrar a dependência (por exemplo, ConsoleLayer ou DebugLayer que usamos no exemplo anterior) assim: </p><br><pre> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p>  E extraia-o do contêiner no local necessário do programa, da seguinte maneira: </p><br><pre> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p>  Em contêineres reais, Dispose () também é implementado, o que permite destruir recursos que se tornaram desnecessários. </p><br><p>  A propósito, o nome container IoC não transmite exatamente o significado, já que o termo IoC é muito mais amplo em aplicações.  Portanto, recentemente, o termo contêiner DI tem sido usado com mais e mais frequência (já que a injeção de dependência ainda é aplicada). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root">  Vida útil do serviço + vários métodos de extensão no Root de composição </h2><br><p>  Os aplicativos ASP.NET Core contêm o arquivo Startup.cs, que é o ponto de partida do aplicativo para configurar o DI.  Configura a DI no método ConfigureServices. </p><br><pre> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p>  Esse código adicionará a classe SomeRepository ao contêiner de DI, que implementa a interface ISomeRepository.  O fato de o serviço ser adicionado ao contêiner usando AddScoped significa que uma instância da classe será criada toda vez que uma página for solicitada. <br>  Você pode adicionar um serviço a um contêiner sem especificar uma interface. </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p>  Mas esse método não é recomendado, pois seu aplicativo perde a flexibilidade e as conexões próximas aparecem.  É recomendável que você sempre especifique uma interface, pois, nesse caso, a qualquer momento, você pode substituir uma implementação da interface por outra.  E se as implementações suportarem o princípio de substituição de Liskov, alterando o nome da classe de implementação com um "toque do pulso", você alterará a funcionalidade de todo o aplicativo. </p><br><p>  Existem mais 2 opções para adicionar um serviço - AddSingleton e AddTransient. <br>  Ao usar AddSingleton, o serviço é criado uma vez e, ao usar o aplicativo, a chamada vai para a mesma instância.  Use esse método com cuidado, pois são possíveis vazamentos de memória e problemas de multithreading. </p><br><p>  AddSingleton tem um pequeno recurso.  Pode ser inicializado no primeiro acesso a ele </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p>  imediatamente quando adicionado ao construtor </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p>  Na segunda maneira, você pode até adicionar um parâmetro ao construtor. <br>  Se você deseja adicionar um parâmetro ao construtor de um serviço adicionado não apenas usando AddSingleton, mas também usando AddTransient / AddScoped, você pode usar a expressão lambda: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p>  E, finalmente, ao usar o AddTransient, um serviço é criado toda vez que você o acessa.  Ótimo para serviços leves que não consomem memória e recursos. </p><br><p>  Se com AddSingleton e AddScoped tudo deve ficar mais ou menos claro, o AddTransient precisa de esclarecimentos.  A documentação oficial fornece um exemplo no qual um determinado serviço é adicionado ao contêiner de DI, tanto como parâmetro do construtor de outro serviço, como separadamente.  E caso seja adicionado separadamente usando AddTransient, ele cria sua instância 2 vezes.  Vou dar um exemplo muito, muito simplificado.  Na vida real, não é recomendado para uso, porque  classes para simplificar não herdam interfaces.  Digamos que temos uma classe simples: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p>  E há uma segunda classe que contém a primeira como um serviço dependente e recebe essa dependência como um parâmetro construtor: </p><br><pre> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p>  Agora injetamos dois serviços: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p>  E em algum controlador em Ação, adicione o recebimento de nossas dependências e exiba os valores na janela Debug. </p><br><pre> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p>  Portanto, como resultado, obtemos 2 valores Guid diferentes.  Mas se substituirmos AddTransient por AddScoped, obteremos 2 valores idênticos. </p><br><p>  O contêiner de IoC do aplicativo ASP.NET Core contém alguns serviços por padrão.  Por exemplo, IConfiguration é um serviço com o qual você pode obter configurações do aplicativo nos arquivos appsettings.json e appsettings.Development.json.  IHostingEnvironment e ILoggerFactory com os quais você pode obter a configuração atual e uma classe auxiliar que permite o log. </p><br><p>  As classes são recuperadas do contêiner usando a seguinte construção típica (o exemplo mais comum): </p><br><pre> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p>  Uma variável com modificadores de acesso somente leitura privados é criada no escopo do controlador.  A dependência é obtida do contêiner no construtor da classe e atribuída a uma variável privada.  Além disso, essa variável pode ser usada em qualquer método ou controlador de ação. <br>  Às vezes, você não deseja criar uma variável para usá-la em apenas uma ação.  Então você pode usar o atributo [FromServices].  Um exemplo: </p><br><pre> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = «  " + dateTime.Now; return View(); }</code> </pre> <br><p>  Parece estranho, mas para não chamar o método da classe estática DateTime.Now () no código, às vezes isso é feito para que o valor de tempo seja obtido do serviço como parâmetro.  Assim, torna-se possível passar a qualquer momento como parâmetro, o que significa que fica mais fácil escrever testes e, como regra, fica mais fácil fazer alterações no aplicativo. <br>  Isso não quer dizer que a estática seja má.  Métodos estáticos são mais rápidos.  E provavelmente a estática pode ser usada em algum lugar do próprio contêiner de IoC.  Mas se salvarmos nosso aplicativo de tudo estático e novo, obteremos mais flexibilidade. </p><br><h2 id="storonnie-di-konteynery">  Contêineres DI de terceiros </h2><br><p>  O que examinamos e o que o contêiner de DI do ASP.NET Core realmente implementa por padrão é a injeção de construtor.  Ainda há a oportunidade de injetar dependência na propriedade usando a chamada injeção de propriedade, mas esse recurso não está disponível no contêiner incorporado ao ASP.NET Core.  Por exemplo, podemos ter alguma classe que você implementa como dependência, e essa classe tem algum tipo de propriedade pública.  Agora imagine que durante ou depois de injetarmos a dependência, precisamos definir o valor da propriedade.  Vamos voltar a um exemplo semelhante ao exemplo que examinamos recentemente. <br>  Se tivermos essa classe: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p>  que podemos introduzir como vício, </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p>  então, usando o contêiner padrão, não podemos definir o valor da propriedade. <br>  Se você quiser usar esta oportunidade para definir um valor para a propriedade OperationId, poderá usar algum tipo de contêiner de DI de terceiros que ofereça suporte à injeção de propriedade.  A propósito, a injeção de propriedades não é particularmente recomendada.  No entanto, ainda existem Injeção de método e Injeção de método de incubação, que podem ser úteis para você e que também não são suportadas pelo contêiner padrão. </p><br><p>  Contêineres de terceiros podem ter outros recursos muito úteis.  Por exemplo, usando um contêiner de terceiros, você só pode adicionar dependência aos controladores que possuem uma palavra específica no nome.  E frequentemente usado - recipientes DI, otimizados para desempenho. <br>  Aqui está uma lista de alguns contêineres DI de terceiros suportados pelo ASP.NET Core: Autofac, Castle Windsor, LightInject, DryIoC, StructureMap, Unity </p><br><p>  Embora esteja usando um contêiner DI padrão, não é possível usar injeção de propriedade / método, mas é possível implementar um serviço dependente como parâmetro construtor implementando o padrão Factory da seguinte maneira: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p>  Nesse caso, GetService retornará nulo se o serviço dependente não for encontrado.  Há uma variação de GetRequiredService que lançará uma exceção se o serviço dependente não for encontrado. <br>  O processo de obtenção de um serviço dependente usando GetService realmente aplica o padrão do localizador de serviço. </p><br><h2 id="autofac">  Autofac </h2><br><p>  Vamos dar uma olhada no Autofac com um exemplo prático.  Convenientemente, os serviços do contêiner podem ser registrados e recebidos, da maneira padrão e usando o Autofac. </p><br><p>  Instale o pacote NuGet Autofac.Extensions.DependencyInjection. <br>  Altere o valor retornado pelo método ConfigureServices de void para IServiceProvider.  E adicione propriedade </p><br><pre> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p>  Depois disso, será possível adicionar código como o seguinte ao final do método ConfigureServices da classe Startup (esta é apenas uma das opções para registrar serviços): </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p>  Aqui builder.Populate (services);  Adiciona serviços do IServiceCollection ao contêiner.  Além disso, já é possível registrar serviços no builder.RegisterType.  Ah sim.  Eu quase esqueci.  Você deve alterar de void para IServiceProvider o valor de retorno do método ConfigureServices. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors">  AOP com ASP.NET Core - Autofac Interseptors </h2><br><p>  Falando sobre programação orientada a aspectos, eles mencionam outro termo - preocupações transversais.  Preocupação é alguma informação que afeta o código.  Na versão russa, eles usam a palavra responsabilidade.  Bem, preocupações transversais são responsabilidades que afetam outras responsabilidades.  Mas, idealmente, eles não devem se influenciar, certo?  Quando eles se influenciam, fica mais difícil mudar o programa.  É mais conveniente quando temos todas as operações separadamente.  Log, transações, armazenamento em cache e muito mais podem ser feitos usando o AOP sem alterar o código das próprias classes e métodos. </p><br><p>  No mundo .NET, um método é frequentemente usado quando o código AOP é incorporado usando um pós-processador em um código de aplicativo já compilado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PostSharp</a> ) ou, como alternativa, você pode usar interceptores - esses são interceptores de eventos que podem ser adicionados ao código do aplicativo.  Esses interceptadores, em regra, usam o decorador que já examinamos para o trabalho deles. </p><br><p>  Vamos criar seu próprio interceptador.  O exemplo mais simples e mais típico que é mais fácil de reproduzir é o log. <br>  Além do pacote Autofac.Extensions.DependencyInjection, também instalaremos o pacote Autofac.Extras.DynamicProxy <br>  Instalado?  Adicione uma classe de log simples que será chamada ao acessar determinados serviços. </p><br><pre> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p>  Adicione ao nosso registro Registro automático do interceptador: </p><br><pre> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p>  E agora, a cada chamada para a classe, o método Intercept da classe Logger será chamado. <br>  Assim, podemos simplificar nossa vida e não escrever uma entrada de log no início de cada método.  Nós o teremos automaticamente.  E, se desejado, será fácil alterá-lo ou desativá-lo para todo o aplicativo. </p><br><p>  Também podemos remover .InterceptedBy (typeof (Logger));  e inclua interceptação de chamada apenas para serviços de aplicativos específicos usando o atributo [Interceptar (typeof (Logger))] - você deve especificá-lo antes do cabeçalho da classe </p><br><h2 id="middleware">  Middleware </h2><br><p>  O ASP.NET possui uma cadeia específica de chamadas de código que ocorrem em todas as solicitações.  Mesmo antes do carregamento da UI / MVC, determinadas ações são executadas. </p><br><p>  Ou seja, por exemplo, se adicionarmos no início do método Configure da classe Startup.cs o código </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p>  então, podemos ver no console de depuração quais arquivos nossos aplicativos solicitam.  De fato, obtemos os recursos da AOP "prontos para uso" <br>  Um exemplo um pouco inútil, mas claro e informativo do uso de middleware, mostrarei agora: </p><br><pre> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p>  A cada solicitação, uma cadeia de chamadas é iniciada.  De cada app.Use, depois de chamar next.invoke (), a transição para a próxima chamada é feita.  E tudo termina após o app.Run funcionar. <br>  Você pode executar algum código apenas ao acessar uma rota específica. <br>  Você pode fazer isso usando o app. </p><br><pre> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p>  Agora, se você for apenas para a página do site, poderá ver o texto “Olá!”. Se adicionar / Adeus à barra de endereços, verá Adeus. </p><br><p>  Além de Use and Map, você pode usar UseWhen ou MapWhen para adicionar código à cadeia de middleware apenas sob determinadas condições específicas. </p><br><p>  Até agora, ainda existem exemplos inúteis, certo?  Aqui está um exemplo normal: </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p>  Aqui, adicionamos cabeçalhos a cada solicitação para ajudar a proteger a página contra ataques de hackers. </p><br><p>  Ou aqui está um exemplo de localização: </p><br><pre> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p>  Agora, se você adicionar o parâmetro? Culture = fr ao endereço da página, poderá mudar o idioma do aplicativo para francês (se a localização for adicionada ao seu aplicativo, tudo funcionará) </p><br><h2 id="filters">  Filtros </h2><br><p>  Se a cadeia de middleware se referir a processos antes do MVC, os filtros trabalharão juntos com o MVC. <br>  O diagrama esquemático a seguir mostra como os filtros funcionam. </p><br><p><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="Filtros"></p><br><p>  Primeiro, os filtros de autorização são elaborados.  I.e.  você pode criar algum tipo de filtro ou vários filtros e inserir neles algum tipo de código de autorização que funcionará mediante solicitações. </p><br><p>  Então eles cumprem os filtros de recursos.  Usando esses filtros, você pode, por exemplo, retornar algumas informações do cache. </p><br><p>  Em seguida, ocorre a ligação de dados e os filtros de ação são executados.  Com a ajuda deles, você pode manipular os parâmetros passados ​​para Action e o resultado retornado. </p><br><p>  Os filtros de exceção, como o nome sugere, permitem adicionar algum tipo de tratamento geral de erros para o aplicativo.  Deve ser bastante conveniente lidar com erros em todos os lugares da mesma forma.  Uma espécie de AOP-shny plus. </p><br><p>  Os filtros de resultados permitem executar alguma ação antes de executar o controlador de ação ou depois.  Eles são bastante semelhantes aos filtros de ação, mas são executados apenas se não houver erros.  Adequado para lógica vinculada ao View. </p><br><p>       .            : </p><br><pre> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // -    ,     ,    context.Result = new ContentResult() { Content = "        " }; } }</code> </pre> <br><p>     DI  (   Startup.cs) </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p>      -    Action    </p><br><pre> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p>   –    middleware    - action   .              Configure </p><br><pre> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("  middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p>      Action-     </p><br><pre> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BRKPP1NYCu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437002/">https://habr.com/ru/post/pt437002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436992/index.html">Tentativa e erro ao escolher o proxy reverso HTTP</a></li>
<li><a href="../pt436994/index.html">Liquibase e Maven</a></li>
<li><a href="../pt436996/index.html">Curso Final de Especialização em Python do Grupo Mail.ru</a></li>
<li><a href="../pt436998/index.html">Proteção de microchips contra engenharia reversa e entrada não autorizada</a></li>
<li><a href="../pt437000/index.html">Como ensinar as pessoas a usar o git</a></li>
<li><a href="../pt437004/index.html">Os programadores da YML sonham com testes ansíveis?</a></li>
<li><a href="../pt437006/index.html">Revisão da impressora 3D Wanhao Duplicator 10</a></li>
<li><a href="../pt437008/index.html">PNL. O básico. Técnicas. Autodesenvolvimento. Parte 1</a></li>
<li><a href="../pt437010/index.html">Ecos do passado: a experiência de Young na base do novo método de espectroscopia de raios-X</a></li>
<li><a href="../pt437014/index.html">A tarefa de N corpos ou como explodir uma galáxia sem sair da cozinha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>