<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùáÔ∏è üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø üë≤üèº N√∫cleo ASP.NET v√°lido ü§üüèΩ üìê üë©üèø‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Especialmente para os amantes de livros da s√©rie "C ++ em 24 horas", decidi escrever um artigo sobre o ASP.NET Core. 


 Se voc√™ n√£o desenvolveu o .NE...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>N√∫cleo ASP.NET v√°lido</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437002/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="N√∫cleo ASP.NET v√°lido"></a> </p><br><p>  Especialmente para os amantes de livros da s√©rie "C ++ em 24 horas", decidi escrever um artigo sobre o ASP.NET Core. </p><br><p>  Se voc√™ n√£o desenvolveu o .NET ou qualquer plataforma semelhante antes, n√£o faz sentido entrar em detalhes.  Mas se voc√™ estiver interessado em saber o que s√£o IoC, DI, DIP, Interseptores, Middleware, Filtros (ou seja, tudo o que distingue o Core do .NET cl√°ssico), ent√£o voc√™ definitivamente precisa clicar em "Leia mais" √† medida que estiver desenvolvendo Sem entender tudo isso, claramente n√£o est√° correto. </p><a name="habracut"></a><br><h2 id="ioc-di-dip">  IoC, DI, DIP </h2><br><p>  Se um teatro come√ßa com um cabide, o ASP.NET Core inicia com uma inje√ß√£o de depend√™ncia.  Para lidar com o DI, voc√™ precisa entender o que √© IoC. </p><br><p>  Falando sobre IoC, muitas vezes se lembra do princ√≠pio de Hollywood de "N√£o ligue para n√≥s, n√≥s ligaremos para voc√™".  O que significa "N√£o h√° necessidade de nos ligar, n√≥s mesmos ligaremos para voc√™". </p><br><p> Fontes diferentes fornecem padr√µes diferentes aos quais a IoC pode ser aplicada.  E provavelmente eles est√£o bem e apenas se complementam.  Aqui est√£o alguns desses padr√µes: f√°brica, localizador de servi√ßo, m√©todo de modelo, observador, estrat√©gia. </p><br><p>  Vejamos a IoC usando um aplicativo de console simples como exemplo. </p><br><p>  Suponha que tenhamos duas classes simples que implementam uma interface com um m√©todo: </p><br><pre><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p>  Ambos dependem da abstra√ß√£o (neste caso, a interface atua como uma abstra√ß√£o). </p><br><p>  E digamos que temos um objeto de n√≠vel superior usando estas classes: </p><br><pre> <code class="plaintext hljs"> class Logging : ILayer { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  Dependendo do par√¢metro do construtor, a vari√°vel _instance √© inicializada por uma classe espec√≠fica.  Al√©m disso, ao chamar Write, a sa√≠da para o console ou para Debug ser√° conclu√≠da.  Tudo parece estar muito bom e at√© parece corresponder √† primeira parte do princ√≠pio da Invers√£o da Depend√™ncia </p><br><blockquote>  Objetos de n√≠vel superior s√£o independentes dos objetos de n√≠vel inferior.  Ambos e aqueles dependem de abstra√ß√µes. </blockquote><p>  No nosso caso, o ILayer atua como uma abstra√ß√£o. </p><br><p>  Mas tamb√©m devemos ter um objeto de n√≠vel ainda mais alto.  Um que usa a classe Logging </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  Ao inicializar o Log com 1, obtemos na classe Logging uma inst√¢ncia da classe que gera dados para o console.  Se inicializarmos o Log com qualquer outro n√∫mero, o log.Write produzir√° dados para Debug.  Parece que tudo funciona, mas funciona mal.  Nosso objeto de n√≠vel superior Main depende dos detalhes do c√≥digo do objeto de n√≠vel inferior - a classe Logging.  Se mudarmos algo nesta classe, precisaremos alterar o c√≥digo da classe Main.  Para impedir que isso aconte√ßa, faremos uma invers√£o de controle - Invers√£o de Controle.  Vamos fazer com que a classe Main controle o que acontece na classe Logging.  A classe Logging receber√°, como par√¢metro construtor, uma inst√¢ncia de uma classe que implementa a interface ILayer </p><br><pre> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p>  E agora, nossa classe Principal ficar√° assim: </p><br><pre> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p>  De fato, decoramos nosso objeto Logging com o objeto necess√°rio para n√≥s. </p><br><p>  Agora, nosso aplicativo est√° em conformidade com a segunda parte do princ√≠pio de Invers√£o de depend√™ncia: </p><br><blockquote>  As abstra√ß√µes s√£o independentes dos detalhes.  Os detalhes dependem das abstra√ß√µes.  I.e.  n√£o sabemos os detalhes do que est√° acontecendo na classe Logging, apenas passamos a classe para l√° que implementa a abstra√ß√£o necess√°ria. </blockquote><p>  Existe um termo termo acoplamento estanque - conex√£o estanque.  Quanto mais fraca a conex√£o entre os componentes no aplicativo, melhor.  Gostaria de observar que este exemplo de uma aplica√ß√£o simples n√£o atinge nem um pouco o ideal.  Porque  Sim, porque na classe de n√≠vel mais alto em Main, usamos duas vezes a cria√ß√£o de inst√¢ncias de classe usando new.  E existe uma frase mnem√¥nica ‚ÄúNovo √© uma pista‚Äù - o que significa que quanto menos voc√™ usar novo, menos conex√µes estreitas de componentes no aplicativo e melhor.  Idealmente, n√£o devemos usar o novo DebugLayer, mas devemos obter o DebugLayer de alguma outra maneira.  Qual?  Por exemplo, de um cont√™iner de IoC ou usando a reflex√£o de um par√¢metro passado para Principal. </p><br><p>  Agora, descobrimos o que √© Inversion of Control (IoC) e o que √© Dependency Inversion (DIP).  Resta entender o que √© inje√ß√£o de depend√™ncia (DI).  IoC √© um paradigma de design.  Inje√ß√£o de Depend√™ncia √© um padr√£o.  √â isso que temos agora no construtor da classe Logging.  Temos uma inst√¢ncia de uma depend√™ncia espec√≠fica.  A classe Logging depende de uma inst√¢ncia de uma classe que implementa ILayer.  E esta inst√¢ncia √© injetada atrav√©s do construtor. </p><br><h2 id="ioc-container">  Container IoC </h2><br><p>  Um cont√™iner de IoC √© um objeto que cont√©m muitas depend√™ncias espec√≠ficas (depend√™ncia).  Caso contr√°rio, a depend√™ncia pode ser chamada de servi√ßo - como regra, √© uma classe com uma certa funcionalidade.  Se necess√°rio, a depend√™ncia do tipo requerido pode ser obtida no cont√™iner.  Injetar depend√™ncia em um cont√™iner √© Injetar.  Extrair - resolver.  Aqui est√° um exemplo do cont√™iner IoC auto-escrito mais simples: </p><br><pre> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p>  Apenas uma d√∫zia de linhas de c√≥digo, mas voc√™ j√° pode us√°-lo (n√£o para produ√ß√£o, √© claro, mas para fins educacionais). </p><br><p>  Voc√™ pode registrar a depend√™ncia (por exemplo, ConsoleLayer ou DebugLayer que usamos no exemplo anterior) assim: </p><br><pre> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p>  E extraia-o do cont√™iner no local necess√°rio do programa, da seguinte maneira: </p><br><pre> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p>  Em cont√™ineres reais, Dispose () tamb√©m √© implementado, o que permite destruir recursos que se tornaram desnecess√°rios. </p><br><p>  A prop√≥sito, o nome container IoC n√£o transmite exatamente o significado, j√° que o termo IoC √© muito mais amplo em aplica√ß√µes.  Portanto, recentemente, o termo cont√™iner DI tem sido usado com mais e mais frequ√™ncia (j√° que a inje√ß√£o de depend√™ncia ainda √© aplicada). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root">  Vida √∫til do servi√ßo + v√°rios m√©todos de extens√£o no Root de composi√ß√£o </h2><br><p>  Os aplicativos ASP.NET Core cont√™m o arquivo Startup.cs, que √© o ponto de partida do aplicativo para configurar o DI.  Configura a DI no m√©todo ConfigureServices. </p><br><pre> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p>  Esse c√≥digo adicionar√° a classe SomeRepository ao cont√™iner de DI, que implementa a interface ISomeRepository.  O fato de o servi√ßo ser adicionado ao cont√™iner usando AddScoped significa que uma inst√¢ncia da classe ser√° criada toda vez que uma p√°gina for solicitada. <br>  Voc√™ pode adicionar um servi√ßo a um cont√™iner sem especificar uma interface. </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p>  Mas esse m√©todo n√£o √© recomendado, pois seu aplicativo perde a flexibilidade e as conex√µes pr√≥ximas aparecem.  √â recomend√°vel que voc√™ sempre especifique uma interface, pois, nesse caso, a qualquer momento, voc√™ pode substituir uma implementa√ß√£o da interface por outra.  E se as implementa√ß√µes suportarem o princ√≠pio de substitui√ß√£o de Liskov, alterando o nome da classe de implementa√ß√£o com um "toque do pulso", voc√™ alterar√° a funcionalidade de todo o aplicativo. </p><br><p>  Existem mais 2 op√ß√µes para adicionar um servi√ßo - AddSingleton e AddTransient. <br>  Ao usar AddSingleton, o servi√ßo √© criado uma vez e, ao usar o aplicativo, a chamada vai para a mesma inst√¢ncia.  Use esse m√©todo com cuidado, pois s√£o poss√≠veis vazamentos de mem√≥ria e problemas de multithreading. </p><br><p>  AddSingleton tem um pequeno recurso.  Pode ser inicializado no primeiro acesso a ele </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p>  imediatamente quando adicionado ao construtor </p><br><pre> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p>  Na segunda maneira, voc√™ pode at√© adicionar um par√¢metro ao construtor. <br>  Se voc√™ deseja adicionar um par√¢metro ao construtor de um servi√ßo adicionado n√£o apenas usando AddSingleton, mas tamb√©m usando AddTransient / AddScoped, voc√™ pode usar a express√£o lambda: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p>  E, finalmente, ao usar o AddTransient, um servi√ßo √© criado toda vez que voc√™ o acessa.  √ìtimo para servi√ßos leves que n√£o consomem mem√≥ria e recursos. </p><br><p>  Se com AddSingleton e AddScoped tudo deve ficar mais ou menos claro, o AddTransient precisa de esclarecimentos.  A documenta√ß√£o oficial fornece um exemplo no qual um determinado servi√ßo √© adicionado ao cont√™iner de DI, tanto como par√¢metro do construtor de outro servi√ßo, como separadamente.  E caso seja adicionado separadamente usando AddTransient, ele cria sua inst√¢ncia 2 vezes.  Vou dar um exemplo muito, muito simplificado.  Na vida real, n√£o √© recomendado para uso, porque  classes para simplificar n√£o herdam interfaces.  Digamos que temos uma classe simples: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p>  E h√° uma segunda classe que cont√©m a primeira como um servi√ßo dependente e recebe essa depend√™ncia como um par√¢metro construtor: </p><br><pre> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p>  Agora injetamos dois servi√ßos: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p>  E em algum controlador em A√ß√£o, adicione o recebimento de nossas depend√™ncias e exiba os valores na janela Debug. </p><br><pre> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p>  Portanto, como resultado, obtemos 2 valores Guid diferentes.  Mas se substituirmos AddTransient por AddScoped, obteremos 2 valores id√™nticos. </p><br><p>  O cont√™iner de IoC do aplicativo ASP.NET Core cont√©m alguns servi√ßos por padr√£o.  Por exemplo, IConfiguration √© um servi√ßo com o qual voc√™ pode obter configura√ß√µes do aplicativo nos arquivos appsettings.json e appsettings.Development.json.  IHostingEnvironment e ILoggerFactory com os quais voc√™ pode obter a configura√ß√£o atual e uma classe auxiliar que permite o log. </p><br><p>  As classes s√£o recuperadas do cont√™iner usando a seguinte constru√ß√£o t√≠pica (o exemplo mais comum): </p><br><pre> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p>  Uma vari√°vel com modificadores de acesso somente leitura privados √© criada no escopo do controlador.  A depend√™ncia √© obtida do cont√™iner no construtor da classe e atribu√≠da a uma vari√°vel privada.  Al√©m disso, essa vari√°vel pode ser usada em qualquer m√©todo ou controlador de a√ß√£o. <br>  √Äs vezes, voc√™ n√£o deseja criar uma vari√°vel para us√°-la em apenas uma a√ß√£o.  Ent√£o voc√™ pode usar o atributo [FromServices].  Um exemplo: </p><br><pre> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = ¬´  " + dateTime.Now; return View(); }</code> </pre> <br><p>  Parece estranho, mas para n√£o chamar o m√©todo da classe est√°tica DateTime.Now () no c√≥digo, √†s vezes isso √© feito para que o valor de tempo seja obtido do servi√ßo como par√¢metro.  Assim, torna-se poss√≠vel passar a qualquer momento como par√¢metro, o que significa que fica mais f√°cil escrever testes e, como regra, fica mais f√°cil fazer altera√ß√µes no aplicativo. <br>  Isso n√£o quer dizer que a est√°tica seja m√°.  M√©todos est√°ticos s√£o mais r√°pidos.  E provavelmente a est√°tica pode ser usada em algum lugar do pr√≥prio cont√™iner de IoC.  Mas se salvarmos nosso aplicativo de tudo est√°tico e novo, obteremos mais flexibilidade. </p><br><h2 id="storonnie-di-konteynery">  Cont√™ineres DI de terceiros </h2><br><p>  O que examinamos e o que o cont√™iner de DI do ASP.NET Core realmente implementa por padr√£o √© a inje√ß√£o de construtor.  Ainda h√° a oportunidade de injetar depend√™ncia na propriedade usando a chamada inje√ß√£o de propriedade, mas esse recurso n√£o est√° dispon√≠vel no cont√™iner incorporado ao ASP.NET Core.  Por exemplo, podemos ter alguma classe que voc√™ implementa como depend√™ncia, e essa classe tem algum tipo de propriedade p√∫blica.  Agora imagine que durante ou depois de injetarmos a depend√™ncia, precisamos definir o valor da propriedade.  Vamos voltar a um exemplo semelhante ao exemplo que examinamos recentemente. <br>  Se tivermos essa classe: </p><br><pre> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p>  que podemos introduzir como v√≠cio, </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p>  ent√£o, usando o cont√™iner padr√£o, n√£o podemos definir o valor da propriedade. <br>  Se voc√™ quiser usar esta oportunidade para definir um valor para a propriedade OperationId, poder√° usar algum tipo de cont√™iner de DI de terceiros que ofere√ßa suporte √† inje√ß√£o de propriedade.  A prop√≥sito, a inje√ß√£o de propriedades n√£o √© particularmente recomendada.  No entanto, ainda existem Inje√ß√£o de m√©todo e Inje√ß√£o de m√©todo de incuba√ß√£o, que podem ser √∫teis para voc√™ e que tamb√©m n√£o s√£o suportadas pelo cont√™iner padr√£o. </p><br><p>  Cont√™ineres de terceiros podem ter outros recursos muito √∫teis.  Por exemplo, usando um cont√™iner de terceiros, voc√™ s√≥ pode adicionar depend√™ncia aos controladores que possuem uma palavra espec√≠fica no nome.  E frequentemente usado - recipientes DI, otimizados para desempenho. <br>  Aqui est√° uma lista de alguns cont√™ineres DI de terceiros suportados pelo ASP.NET Core: Autofac, Castle Windsor, LightInject, DryIoC, StructureMap, Unity </p><br><p>  Embora esteja usando um cont√™iner DI padr√£o, n√£o √© poss√≠vel usar inje√ß√£o de propriedade / m√©todo, mas √© poss√≠vel implementar um servi√ßo dependente como par√¢metro construtor implementando o padr√£o Factory da seguinte maneira: </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p>  Nesse caso, GetService retornar√° nulo se o servi√ßo dependente n√£o for encontrado.  H√° uma varia√ß√£o de GetRequiredService que lan√ßar√° uma exce√ß√£o se o servi√ßo dependente n√£o for encontrado. <br>  O processo de obten√ß√£o de um servi√ßo dependente usando GetService realmente aplica o padr√£o do localizador de servi√ßo. </p><br><h2 id="autofac">  Autofac </h2><br><p>  Vamos dar uma olhada no Autofac com um exemplo pr√°tico.  Convenientemente, os servi√ßos do cont√™iner podem ser registrados e recebidos, da maneira padr√£o e usando o Autofac. </p><br><p>  Instale o pacote NuGet Autofac.Extensions.DependencyInjection. <br>  Altere o valor retornado pelo m√©todo ConfigureServices de void para IServiceProvider.  E adicione propriedade </p><br><pre> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p>  Depois disso, ser√° poss√≠vel adicionar c√≥digo como o seguinte ao final do m√©todo ConfigureServices da classe Startup (esta √© apenas uma das op√ß√µes para registrar servi√ßos): </p><br><pre> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p>  Aqui builder.Populate (services);  Adiciona servi√ßos do IServiceCollection ao cont√™iner.  Al√©m disso, j√° √© poss√≠vel registrar servi√ßos no builder.RegisterType.  Ah sim.  Eu quase esqueci.  Voc√™ deve alterar de void para IServiceProvider o valor de retorno do m√©todo ConfigureServices. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors">  AOP com ASP.NET Core - Autofac Interseptors </h2><br><p>  Falando sobre programa√ß√£o orientada a aspectos, eles mencionam outro termo - preocupa√ß√µes transversais.  Preocupa√ß√£o √© alguma informa√ß√£o que afeta o c√≥digo.  Na vers√£o russa, eles usam a palavra responsabilidade.  Bem, preocupa√ß√µes transversais s√£o responsabilidades que afetam outras responsabilidades.  Mas, idealmente, eles n√£o devem se influenciar, certo?  Quando eles se influenciam, fica mais dif√≠cil mudar o programa.  √â mais conveniente quando temos todas as opera√ß√µes separadamente.  Log, transa√ß√µes, armazenamento em cache e muito mais podem ser feitos usando o AOP sem alterar o c√≥digo das pr√≥prias classes e m√©todos. </p><br><p>  No mundo .NET, um m√©todo √© frequentemente usado quando o c√≥digo AOP √© incorporado usando um p√≥s-processador em um c√≥digo de aplicativo j√° compilado ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PostSharp</a> ) ou, como alternativa, voc√™ pode usar interceptores - esses s√£o interceptores de eventos que podem ser adicionados ao c√≥digo do aplicativo.  Esses interceptadores, em regra, usam o decorador que j√° examinamos para o trabalho deles. </p><br><p>  Vamos criar seu pr√≥prio interceptador.  O exemplo mais simples e mais t√≠pico que √© mais f√°cil de reproduzir √© o log. <br>  Al√©m do pacote Autofac.Extensions.DependencyInjection, tamb√©m instalaremos o pacote Autofac.Extras.DynamicProxy <br>  Instalado?  Adicione uma classe de log simples que ser√° chamada ao acessar determinados servi√ßos. </p><br><pre> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p>  Adicione ao nosso registro Registro autom√°tico do interceptador: </p><br><pre> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p>  E agora, a cada chamada para a classe, o m√©todo Intercept da classe Logger ser√° chamado. <br>  Assim, podemos simplificar nossa vida e n√£o escrever uma entrada de log no in√≠cio de cada m√©todo.  N√≥s o teremos automaticamente.  E, se desejado, ser√° f√°cil alter√°-lo ou desativ√°-lo para todo o aplicativo. </p><br><p>  Tamb√©m podemos remover .InterceptedBy (typeof (Logger));  e inclua intercepta√ß√£o de chamada apenas para servi√ßos de aplicativos espec√≠ficos usando o atributo [Interceptar (typeof (Logger))] - voc√™ deve especific√°-lo antes do cabe√ßalho da classe </p><br><h2 id="middleware">  Middleware </h2><br><p>  O ASP.NET possui uma cadeia espec√≠fica de chamadas de c√≥digo que ocorrem em todas as solicita√ß√µes.  Mesmo antes do carregamento da UI / MVC, determinadas a√ß√µes s√£o executadas. </p><br><p>  Ou seja, por exemplo, se adicionarmos no in√≠cio do m√©todo Configure da classe Startup.cs o c√≥digo </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p>  ent√£o, podemos ver no console de depura√ß√£o quais arquivos nossos aplicativos solicitam.  De fato, obtemos os recursos da AOP "prontos para uso" <br>  Um exemplo um pouco in√∫til, mas claro e informativo do uso de middleware, mostrarei agora: </p><br><pre> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p>  A cada solicita√ß√£o, uma cadeia de chamadas √© iniciada.  De cada app.Use, depois de chamar next.invoke (), a transi√ß√£o para a pr√≥xima chamada √© feita.  E tudo termina ap√≥s o app.Run funcionar. <br>  Voc√™ pode executar algum c√≥digo apenas ao acessar uma rota espec√≠fica. <br>  Voc√™ pode fazer isso usando o app. </p><br><pre> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p>  Agora, se voc√™ for apenas para a p√°gina do site, poder√° ver o texto ‚ÄúOl√°!‚Äù. Se adicionar / Adeus √† barra de endere√ßos, ver√° Adeus. </p><br><p>  Al√©m de Use and Map, voc√™ pode usar UseWhen ou MapWhen para adicionar c√≥digo √† cadeia de middleware apenas sob determinadas condi√ß√µes espec√≠ficas. </p><br><p>  At√© agora, ainda existem exemplos in√∫teis, certo?  Aqui est√° um exemplo normal: </p><br><pre> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p>  Aqui, adicionamos cabe√ßalhos a cada solicita√ß√£o para ajudar a proteger a p√°gina contra ataques de hackers. </p><br><p>  Ou aqui est√° um exemplo de localiza√ß√£o: </p><br><pre> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p>  Agora, se voc√™ adicionar o par√¢metro? Culture = fr ao endere√ßo da p√°gina, poder√° mudar o idioma do aplicativo para franc√™s (se a localiza√ß√£o for adicionada ao seu aplicativo, tudo funcionar√°) </p><br><h2 id="filters">  Filtros </h2><br><p>  Se a cadeia de middleware se referir a processos antes do MVC, os filtros trabalhar√£o juntos com o MVC. <br>  O diagrama esquem√°tico a seguir mostra como os filtros funcionam. </p><br><p><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="Filtros"></p><br><p>  Primeiro, os filtros de autoriza√ß√£o s√£o elaborados.  I.e.  voc√™ pode criar algum tipo de filtro ou v√°rios filtros e inserir neles algum tipo de c√≥digo de autoriza√ß√£o que funcionar√° mediante solicita√ß√µes. </p><br><p>  Ent√£o eles cumprem os filtros de recursos.  Usando esses filtros, voc√™ pode, por exemplo, retornar algumas informa√ß√µes do cache. </p><br><p>  Em seguida, ocorre a liga√ß√£o de dados e os filtros de a√ß√£o s√£o executados.  Com a ajuda deles, voc√™ pode manipular os par√¢metros passados ‚Äã‚Äãpara Action e o resultado retornado. </p><br><p>  Os filtros de exce√ß√£o, como o nome sugere, permitem adicionar algum tipo de tratamento geral de erros para o aplicativo.  Deve ser bastante conveniente lidar com erros em todos os lugares da mesma forma.  Uma esp√©cie de AOP-shny plus. </p><br><p>  Os filtros de resultados permitem executar alguma a√ß√£o antes de executar o controlador de a√ß√£o ou depois.  Eles s√£o bastante semelhantes aos filtros de a√ß√£o, mas s√£o executados apenas se n√£o houver erros.  Adequado para l√≥gica vinculada ao View. </p><br><p>       .            : </p><br><pre> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // -    ,     ,    context.Result = new ContentResult() { Content = "        " }; } }</code> </pre> <br><p>     DI  (   Startup.cs) </p><br><pre> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p>      -    Action    </p><br><pre> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p>   ‚Äì    middleware    - action   .              Configure </p><br><pre> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("  middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p>      Action-     </p><br><pre> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BRKPP1NYCu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437002/">https://habr.com/ru/post/pt437002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt436992/index.html">Tentativa e erro ao escolher o proxy reverso HTTP</a></li>
<li><a href="../pt436994/index.html">Liquibase e Maven</a></li>
<li><a href="../pt436996/index.html">Curso Final de Especializa√ß√£o em Python do Grupo Mail.ru</a></li>
<li><a href="../pt436998/index.html">Prote√ß√£o de microchips contra engenharia reversa e entrada n√£o autorizada</a></li>
<li><a href="../pt437000/index.html">Como ensinar as pessoas a usar o git</a></li>
<li><a href="../pt437004/index.html">Os programadores da YML sonham com testes ans√≠veis?</a></li>
<li><a href="../pt437006/index.html">Revis√£o da impressora 3D Wanhao Duplicator 10</a></li>
<li><a href="../pt437008/index.html">PNL. O b√°sico. T√©cnicas. Autodesenvolvimento. Parte 1</a></li>
<li><a href="../pt437010/index.html">Ecos do passado: a experi√™ncia de Young na base do novo m√©todo de espectroscopia de raios-X</a></li>
<li><a href="../pt437014/index.html">A tarefa de N corpos ou como explodir uma gal√°xia sem sair da cozinha</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>