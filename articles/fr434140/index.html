<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👩🏻‍🔬 🤚🏼 Une brève histoire des fonctionnalités asynchrones Javascript 🍖 🤸🏾 🤦🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendant que j'étudiais Javascript, je suis tombé sur de nombreux articles sur les fonctions et opérations asynchrones encore et encore. Malgré les ava...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Une brève histoire des fonctionnalités asynchrones Javascript</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434140/"> Pendant que j'étudiais Javascript, je suis tombé sur de nombreux articles sur les fonctions et opérations asynchrones encore et encore.  Malgré les avantages incontestables d'une telle fonctionnalité, à chaque fois j'ai été mis en difficulté par la cotation citée par les auteurs.  Les mots ont changé, l'essence est restée la même, la bouillie se préparait dans ma tête.  Under the cut - un petit guide du développement historique et des versions d'ECMA. <br><a name="habracut"></a><br><h3>  Pourquoi avons-nous besoin d'opérations asynchrones? </h3><br>  Un programme informatique peut effectuer un nombre illimité de tâches.  Ce n'est un secret pour personne que les applications Web doivent fonctionner avec de nombreuses tâches différentes, qui doivent souvent utiliser les mêmes données.  En particulier, l'un des exemples les plus courants est l'affichage des informations utilisateur (UI) et la récupération des informations à l'aide des demandes du serveur.  Sans surprise, presque tous les développeurs Web sont confrontés à cela: travailler avec une base de données donnée, fournir une interface utilisateur, organiser une API - tout cela est littéralement dans toutes les tâches de test des programmeurs JS. <br><br>  <i>Pourquoi ne pas exécuter les commandes séquentiellement?</i> <br><br>  Souvent, les informations nécessaires à l'utilisateur ne peuvent être obtenues qu'après une période de temps considérable.  Si vous organisez le programme comme: <br><br><ol><li>  Obtenir des informations sur le site https: / some / api / item / 1 </li><li>  Affichez des informations sur le premier élément à l'écran. </li></ol><br>  de graves difficultés surgiront avec le rendu de la page et la création d'une impression agréable sur l'utilisateur (la soi-disant expérience utilisateur).  Imaginez: une page, disons, Netflix ou Aliexpress devra obtenir des données de centaines de bases de données avant de commencer à afficher le contenu à l'utilisateur.  Un tel délai sera similaire au chargement d'un niveau de jeu 3D, et si le joueur est prêt à attendre, l'utilisateur du site Web souhaite obtenir le plus d'informations pour le moment. <br><br>  La solution a été trouvée: <b>les opérations asynchrones</b> .  Alors que le thread principal du programme est en train d'initialiser et d'afficher des éléments de site Web sur la toile, il génère également des tâches vers les autres threads dans l'esprit de « <i>récupérer les marchandises pour l'utilisateur</i> ».  Dès que ce fil termine son travail, les informations «s'installent» dans le fil principal, et deviennent disponibles pour l'affichage, et sur la page Web elle-même il y a un certain espace réservé - un objet qui prend de la place pour les informations futures. <br><br><img src="https://habrastorage.org/webt/vy/r4/9o/vyr49os4a1j-sw7sgg3mi9-_gw8.png" alt="image" width="320" height="240"><br><br>  À ce stade, la page est déjà affichée, malgré le fait que certaines demandes ne soient pas encore passées. <br><br><img src="https://habrastorage.org/webt/uo/aw/vz/uoawvz0tie7t2hpm6zyeojapgu0.png" alt="image" width="320" height="240"><br><br>  Très probablement, quelque part au bas de la page, quelques demandes supplémentaires renvoient une valeur, et la page continue d'être mise à jour et rendue dynamiquement, sans aucun inconvénient pour l'utilisateur. <br><br><h3>  ES5 et versions antérieures: rappel </h3><br>  Avant de procéder à l'examen des rappels, examinons / découvrons les <b>fonctions d'un ordre supérieur</b> . <br><br>  Une fonction d'ordre supérieur dans JS est une <i>fonction qui prend une autre fonction comme argument</i> .  Voici un exemple: <br><br><pre><code class="javascript hljs">objectIsString(objectRef) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(objectRef) === <span class="hljs-string"><span class="hljs-string">'String'</span></span>; } listOfObjects.filter(objectIsString);</code> </pre> <br>  Ainsi, la fonction objectIsString a été transmise à la fonction d'ordre supérieur - filtre - qui permet de filtrer listOfObjects et de ne laisser que des objets de type chaîne dans la liste. <br>  Les rappels fonctionnent de manière similaire.  Il s'agit d'une fonction passée en argument à une autre fonction.  Le plus souvent, la fonction setTimeout est utilisée comme exemple de fonction qui traite les rappels.  En général, il est utilisé comme setTimeout (fonction, timeoutValue), où fonction est une fonction de rappel exécutée par le navigateur après une période spécifiée dans timeout. <br><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><br>  Imprimer 2 1. <br><br><h3>  ES 6: Promesses </h3><br>  Dans la norme 6, un nouveau type a été introduit - Promise (promesse, ci-après - Promise).  Une promesse est un type dont les objets ont l'un des trois états suivants: en attente, rempli, rejeté.  De plus, avec les deux derniers états, vous pouvez «associer» des fonctions - des rappels.  Dès que le processus asynchrone décrit dans le cadre de la promesse elle-même aboutit / échoue, la fonction qui lui est associée sera appelée.  Ce processus est appelé «rappels suspendus» et il est effectué à l'aide des méthodes then et catch de la promesse elle-même.  La différence est que lorsque vous appelez ensuite les arguments, deux fonctions sont transférées - en cas de succès (onFullfillment) et d'échec (onRejected), tandis que catch accepte, comme il n'est pas difficile à deviner, uniquement une fonction pour traiter les erreurs dans une promesse.  Afin de déterminer si une promesse a été exécutée avec succès dans un cas particulier, ainsi que de paramétrer le résultat renvoyé <br><br>  Créons et utilisons une promesse par étapes. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// : let promise; //     Promise. let promise = new Promise((resolve, reject) =&gt; { }); //  ,  . let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve("result"); }, 1000); });</span></span></code> </pre> <br>  Ajoutez maintenant des gestionnaires d'événements à l'aide de la méthode then.  L'argument de la fonction qui gère le succès est le résultat, tandis que l'argument de la fonction pour gérer l'échec de la promesse est l'erreur. <br><br><pre> <code class="javascript hljs">promise .then( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { }, error =&gt; { } ); <span class="hljs-comment"><span class="hljs-comment">//     – . promise .then( result =&gt; { //  - -    resolve alert("Fulfilled: " + result); // result -  resolve }, error =&gt; { //   -    reject alert("Rejected: " + error); // error -  reject } );</span></span></code> </pre><br>  C'est fait! <br><br>  Nous décrirons donc une fois de plus le processus de création d'une promesse: <br><br><ol><li>  Initialiser l'objet (nouvelle promesse) </li><li>  Nous passons la fonction de résolution et / ou de rejet comme seul argument au constructeur.  Une fonction doit avoir au moins 1 opération asynchrone </li><li>  En utilisant les méthodes then / catch, nous ajoutons des fonctions - gestionnaires de résultats. </li></ol><br><h3>  Générateurs.  Rendement </h3><br>  Toujours dans la norme ES6, un nouveau type de fonction a été défini - les générateurs.  Ces fonctions ont la capacité de renvoyer plusieurs fois différentes valeurs avec des appels identiques à première vue.  Voyons comment ils le font et pourquoi l'utiliser. <br><br>  La forme standard du générateur: function * functionName () {}.  Dans le corps des fonctions elles-mêmes, le mot yield est utilisé pour renvoyer une valeur intermédiaire. <br><br>  À titre d'exemple, considérons le générateur suivant: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generateNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br>  Pour le moment, le générateur est au début de son exécution.  Chaque fois que la prochaine méthode de générateur est appelée, le code décrit avant le rendement (ou le retour) le plus proche sera exécuté et la valeur indiquée dans la ligne avec l'un de ces mots sera également retournée. <br><br><pre> <code class="javascript hljs">Let one = generateNumber.next(); <span class="hljs-comment"><span class="hljs-comment">// {value: 1, done: false}</span></span></code> </pre> <br>  Le prochain appel renverra de la même manière la valeur 2. Le troisième appel renverra la valeur 3 et mettra fin à l'exécution de la fonction. <br><br><pre> <code class="javascript hljs">Let two = generateNumber.next(); <span class="hljs-comment"><span class="hljs-comment">// {value: 2, done: false} Let three = generateNumber.next(); // {value: 3, done: false}</span></span></code> </pre> <br>  Malgré cela, le générateur est toujours accessible via la fonction <i>suivante</i> .  Cependant, il renverra la même valeur: l'objet {done: true}. <br><br><h3>  ES7.  Async / attente </h3><br>  Avec le désir de plaire aux amateurs de POO à l'aide de classes de sucre syntaxiques et d'imitation d'héritage, les créateurs d'ES7 tentent de faciliter la compréhension de javascript et pour ceux qui aiment écrire du code synchrone.  À l'aide de constructions asynchrones / attendent, l'utilisateur est capable d'écrire du code asynchrone aussi similaire que possible à synchrone.  Si vous le souhaitez, vous pouvez vous débarrasser des promesses récemment étudiées et réécrire le code avec des changements minimes. <br>  Prenons un exemple: <br><br>  Utiliser des promesses: <br><br><pre> <code class="javascript hljs">requestBook(id) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bookAPIHelper.getBook(id).then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(book)}); }</code> </pre> <br>  Utilisation de async / wait. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> requestBook(id) { Const book = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> bookAPIHelper.getBook(id); Console.log(book); }</code> </pre> <br>  Décrivons ce que nous avons vu: <br><br>  1) Async - mot clé ajouté lors de la déclaration d'une fonction asynchrone <br>  2) Attendre - un mot-clé ajouté lors de l'appel d'une fonction asynchrone. <br><br><h3>  ES8.  Itération asynchrone </h3><br>  L'itération sur les données de manière synchrone est devenue possible dans ES5.  Après deux spécifications, il a été décidé d'ajouter la possibilité d'une itération asynchrone fonctionnant dans des sources de données asynchrones.  Maintenant, lorsque next () est appelé, il ne renverra pas {value, done}, mais une promesse (voir ES6). <br><br>  Examinons la fonction createAsyncIterable (itérable). <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createAsyncIterable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">iterable</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> elem <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> iterable) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> elem; } }</code> </pre> <br>  Comme vous pouvez le voir, la fonction initialise la collection, pour chaque appel aux éléments dont une promesse sera retournée avec la valeur spécifiée dans itérable. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asyncIterable = createAsyncIterable([<span class="hljs-string"><span class="hljs-string">'async 1'</span></span>, <span class="hljs-string"><span class="hljs-string">'async 2'</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> asyncIterator = asyncIterable[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.asyncIterator](); asyncIterator.next() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result); <span class="hljs-comment"><span class="hljs-comment">// { // value: 'async 1', // done: false, // } return asyncIterator.next(); }) .then(result =&gt; { console.log(result); // { // value: 'async 2', // done: false, // } return asyncIterator.next(); }) .then(result =&gt; { console.log(result); // { // value: 'undefined', // done: true, // } });</span></span></code> </pre> <br>  De plus, la nouvelle norme définit une boucle d'attente qui convient à de telles opérations. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> createAsyncIterable([<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>]))</code> </pre> <br><h3>  TL; DR </h3><br>  Il n'est pas du tout nécessaire de connaître et de mémoriser par cœur à quelle version d'ECMAScript telle ou telle syntaxe appartient, surtout si vous venez de commencer à vous familiariser avec le comportement asynchrone dans JS.  Dans le même temps, l'étude de l'asynchronie dans l'ordre exactement proposé par l'histoire du développement des spécifications permettra au programmeur de comprendre parfaitement la syntaxe et les instructions transmises au moteur JS, mais aussi de suivre la logique d'amélioration d'ECMAScript en tant que produit, de comprendre les tendances dictées par les développeurs JS, de les séparer et d'accepter . <br><br>  Bref, alors: <br><br>  Rappels &lt;= ES5 <br>  Promesses, rendement (générateurs): ES6 <br>  Async / attente: ES7 <br>  Itérateurs asynchrones: ES8 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434140/">https://habr.com/ru/post/fr434140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434130/index.html">Interface réactive. Conférence d'Artyom Belov à FrontTalks 2018</a></li>
<li><a href="../fr434132/index.html">Achetez un téléviseur et roulez-le: LG prévoit de commencer à vendre des téléviseurs flexibles dans l'année à venir</a></li>
<li><a href="../fr434134/index.html">Analyse des résultats de l'enquête Kaggle ML & DS 2018</a></li>
<li><a href="../fr434136/index.html">Anatomie d'entreprise</a></li>
<li><a href="../fr434138/index.html">Nous écrivons notre propre machine virtuelle</a></li>
<li><a href="../fr434142/index.html">L'équipe QRL a fixé un délai serré pour la migration des jetons</a></li>
<li><a href="../fr434146/index.html">Top 10 des films informatiques</a></li>
<li><a href="../fr434150/index.html">Caractéristiques de la recherche d'emploi en Europe</a></li>
<li><a href="../fr434154/index.html">Jeu de données du Nouvel An 2018: sémantique ouverte de la langue russe</a></li>
<li><a href="../fr434156/index.html">Fractale de Gerasimov. Trouvé un modèle. Table noire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>