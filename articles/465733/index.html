<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游 游늽 游뛌游낗 쯈u칠 hacer si los certificados est치n podridos y el racimo se convierte en una calabaza? 游꺟 游빂游낖 游븺游</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Si en respuesta al comando kubectl get pod obtienes: 



 Unable to connect to the server: x509: certificate has expired or is not yet valid 
 entonce...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>쯈u칠 hacer si los certificados est치n podridos y el racimo se convierte en una calabaza?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/465733/"> Si en respuesta al comando <code>kubectl get pod</code> obtienes: <br><br><pre> <code class="plaintext hljs">Unable to connect to the server: x509: certificate has expired or is not yet valid</code> </pre><br>  entonces, muy probablemente, ha pasado un a침o, los certificados de sus kubernetes han expirado, los componentes del cl칰ster han dejado de usarlos, la interacci칩n entre ellos se ha detenido y su cl칰ster se ha convertido en una calabaza. <br><br><img src="https://habrastorage.org/webt/fq/ad/wn/fqadwn7ysbxuqblyhbwpyfvrx9w.jpeg" alt="imagen"><br><a name="habracut"></a><br>  쯈u칠 hacer y c칩mo restaurar un cl칰ster? <br><br>  Primero, debemos comprender d칩nde se encuentran los certificados que deben actualizarse. <br><br>  Dependiendo de la forma en que se instal칩 el cl칰ster, la ubicaci칩n y el nombre de los archivos de certificado pueden variar.  Entonces, por ejemplo, al crear un cl칰ster, Kubeadm descompone los archivos de certificado de acuerdo con las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mejores pr치cticas</a> .  Por lo tanto, todos los certificados se encuentran en el <code>/etc/kuberenetes/pki</code> , en archivos con la extensi칩n <code>.crt</code> , claves privadas, respectivamente, en los archivos <code>.key</code> .  Adem치s en <code>/etc/kubernetes/</code> archivos <code>.conf</code> con configuraci칩n de acceso para el administrador de cuentas de usuario, controlador de administrador, sheduler y kubelet desde el nodo maestro.  Los certificados en archivos <code>.conf</code> encuentran en el campo user.client-certificate-data en forma codificada en base64. <br><br>  Puede ver la fecha de vencimiento a qui칠n se emiti칩 y qui칠n firm칩 el certificado utilizando este peque침o script shcert <br><br><div class="spoiler">  <b class="spoiler_title">shcert</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash [ -f "$1" ] || exit if [[ $1 =~ \.(crt|pem)$ ]]; then openssl x509 -in "$1" -text -noout fi if [[ $1 =~ \.conf$ ]]; then certfile=$(mktemp) grep 'client-certificate-data:' "$1"| awk '{ print $2}' | base64 -d &gt; "$certfile" openssl x509 -in "$certfile" -text -noout rm -f "$certfile" fi</span></span></code> </pre><br></div></div><br>  Todav칤a hay certificados que usan kubelet en los nodos de trabajo para la autenticaci칩n en la API.  Si us칩 kubeadm join para agregar nodos al cl칰ster, lo m치s probable es que el nodo se haya conectado utilizando el procedimiento de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">arranque TLS</a> , en cuyo caso kubelet puede renovar su certificado autom치ticamente si se le da la opci칩n <code>--rotate-certificates</code> .  En versiones recientes de kubernetes, esta opci칩n ya est치 habilitada de forma predeterminada. <br>  Verificar que el nodo est칠 conectado usando el procedimiento de arranque TLS es bastante simple: en este caso, el archivo <code>/etc/kubernetes/kubelet.conf</code> generalmente se especifica en el archivo de certificado del cliente en el archivo <code>/var/lib/kubelet/pki/kubelet-client-current.pem</code> que es un enlace simb칩lico al certificado actual. <br><br>  Tambi칠n puede ver las fechas de vencimiento de este certificado utilizando el script <code>shcert</code> <br><br>  <b>Volvemos al problema de la renovaci칩n de certificados.</b> <br><br>  Si instal칩 el cl칰ster usando kubeadm, tengo buenas noticias para usted.  A partir de la versi칩n 1.15, kubeadm puede actualizar casi todos los certificados de plano de control con un comando <br><br><pre> <code class="bash hljs">kubeadm alpha certs renew all</code> </pre> <br>  Este comando renovar치 todos los certificados en el directorio / etc / kubernetes, incluso si ya han expirado y todo se ha roto. <br><br>  Solo el certificado de kubelet no se actualizar치; este es el que se encuentra en el archivo <code>/etc/kubernetes/kubelet.conf</code> . <br><blockquote>  Actualizaci칩n: kubeadm, a partir de la versi칩n 1.17, incluye en todos los nodos (incluso en el primer asistente donde se realiz칩 kubeadm init) la renovaci칩n autom치tica del certificado culet.  La comprobaci칩n es muy simple: en <code>/etc/kubernetes/kubelet.conf</code> ruta al archivo <code>/var/lib/kubelet/pki/kubelet-client-current.pem</code> se indicar치 en el campo del certificado del cliente </blockquote><br>  Para renovar este certificado, use el comando crear cuenta de usuario <br><br><pre> <code class="bash hljs">kubeadm alpha kubeconfig user --client-name system:node:kube.slurm.io --org system:nodes &gt; /etc/kubernetes/kubelet.conf</code> </pre><br>  Si el sistema tiene una cuenta de usuario, este comando actualiza el certificado de esta cuenta.  No olvide especificar el nombre de host correcto en la opci칩n <code>--client-name</code> , puede ver <code>--client-name</code> nombre de host en el campo Asunto de un certificado existente: <br><br><pre> <code class="bash hljs">shcert /etc/kubernetes/kubelet.conf</code> </pre> <br>  Y, por supuesto, despu칠s de actualizar los certificados, debe reiniciar todos los componentes del plano de control, reiniciar todo el nodo o detener los contenedores con etcd, api, controlador-administrador y planificador con el <code>docker stop</code> , y luego reiniciar kubelet <code>systemctl restart kubelet</code> . <br><br>  Si su cl칰ster tiene una versi칩n anterior: 1.13 o menos, simplemente no funcionar치 para actualizar kubeadm a 1.15, ya que arrastra las dependencias de kubelet y kubernetes-cni, lo que puede causar problemas, ya que el rendimiento de los componentes del cl칰ster difiere en las versiones en m치s de uno escenario, no garantizado.  La forma m치s f치cil de salir de esta situaci칩n es instalar kubeadm en otra m치quina, tomar el archivo binario <code>/usr/bin/kubeadm</code> , copiarlo en los nodos maestros del cl칰ster fallecido y usarlo solo para renovar certificados.  Y despu칠s de revitalizar el cl칰ster, actual칤celo paso a paso utilizando m칠todos regulares, instalando kubeadm una versi칩n m치s nueva cada vez. <br><br>  Y finalmente, de la versi칩n 1.15, kubeadm aprendi칩 c칩mo renovar todos los certificados al actualizar un cl칰ster con el <code>kubeadm upgrade</code> .  Entonces, si actualiza regularmente su cl칰ster al menos una vez al a침o, sus certificados siempre ser치n v치lidos. <br><br>  Pero si el cl칰ster no est치 instalado usando kubeadm, entonces deber치 recoger openssl y renovar todos los certificados individualmente. <br><br>  El problema es que los certificados contienen campos extendidos y diferentes herramientas de instalaci칩n de cl칰ster pueden agregar su propio conjunto de campos.  Adem치s, los nombres de estos campos en la configuraci칩n de openssl y en la salida del contenido del certificado est치n correlacionados, pero de forma d칠bil.  Es necesario googlear y seleccionar. <br><br>  Dar칠 una configuraci칩n de ejemplo para openssl, en secciones separadas de las cuales se describen los atributos extendidos, espec칤ficos para cada tipo de certificado.  Nos referiremos a la secci칩n correspondiente al crear y firmar csr.  Esta configuraci칩n se utiliz칩 para revitalizar el grupo establecido hace un a침o por el ranchero. <br><br><div class="spoiler">  <b class="spoiler_title">openssl.cnf</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">[req] distinguished_name = req_distinguished_name req_extensions = v3_req [v3_req] keyUsage = nonRepudiation, digitalSignature, keyEncipherment extendedKeyUsage = clientAuth [client] keyUsage = critical,digitalSignature, keyEncipherment extendedKeyUsage = clientAuth [apiproxyclient] keyUsage = critical,digitalSignature, keyEncipherment extendedKeyUsage = clientAuth, serverAuth [etcd] keyUsage = critical,digitalSignature, keyEncipherment extendedKeyUsage = clientAuth, serverAuth subjectAltName = @alt_names [api] keyUsage = critical,digitalSignature, keyEncipherment extendedKeyUsage = clientAuth, serverAuth subjectAltName = @alt_names [alt_names] DNS.1 = ec2-us-east-1-1a-c1-master-2 DNS.2 = ec2-us-east-1-1a-c1-master-3 DNS.3 = ec2-us-east-1-1a-c1-master-1 DNS.4 = localhost DNS.5 = kubernetes DNS.6 = kubernetes.default DNS.7 = kubernetes.default.svc DNS.8 = kubernetes.default.svc.cluster.local IP.1 = 10.0.0.109 IP.2 = 10.0.0.159 IP.3 = 10.0.0.236 IP.4 = 127.0.0.1 IP.5 = 10.43.0.1</code> </pre> <br></div></div><br>  Los atributos reales y los nombres adicionales en el certificado se pueden ver con el comando <br><br><pre> <code class="bash hljs">openssl x509 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cert.crt -text</code> </pre><br>  Al renovar el certificado para la API del servidor, tuve un problema: el certificado actualizado no funcionaba.  La soluci칩n fue emitir un certificado que fuera v치lido por 1 a침o en el pasado. <br><br>  En openssl, no puede emitir un certificado v치lido en el pasado con un comando simple, el c칩digo establece estrictamente que el certificado es v치lido solo desde el momento actual.  Pero puede retroceder localmente en el tiempo usando la biblioteca libfaketime <br><br><pre> <code class="bash hljs">yum install libfaketime LD_PRELOAD=/usr/lib64/faketime/libfaketime.so.1 FAKETIME=<span class="hljs-string"><span class="hljs-string">"-365d"</span></span> openssl x509 -req ...</code> </pre> <br>  Emitimos certificados extendidos de acuerdo con el siguiente algoritmo: <br><br>  Creamos una CSR utilizando un certificado existente, especifique la secci칩n deseada con una lista de atributos avanzados en el archivo de configuraci칩n: <br><br><pre> <code class="bash hljs">openssl x509 -x509toreq -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"node.cert"</span></span> -out <span class="hljs-string"><span class="hljs-string">"node.csr"</span></span> -signkey <span class="hljs-string"><span class="hljs-string">"node.key"</span></span> -extfile <span class="hljs-string"><span class="hljs-string">"openssl.cnf"</span></span> -extensions client</code> </pre> <br>  Lo firmamos con el certificado ra칤z correspondiente, cambiando el tiempo hace 1 a침o y especificando la secci칩n deseada con una lista de atributos avanzados en el archivo de configuraci칩n <br><br><pre> <code class="bash hljs">LD_PRELOAD=/usr/lib64/faketime/libfaketime.so.1 FAKETIME=<span class="hljs-string"><span class="hljs-string">"-365d"</span></span> openssl x509 -req -days 36500 -<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"node.csr"</span></span> -CA <span class="hljs-string"><span class="hljs-string">"kube-ca.pem"</span></span> -CAkey <span class="hljs-string"><span class="hljs-string">"kube-ca-key.pem"</span></span> -CAcreateserial -out <span class="hljs-string"><span class="hljs-string">"node.new.cert"</span></span> -extfile <span class="hljs-string"><span class="hljs-string">"openssl.cnf"</span></span> -extensions client</code> </pre> <br>  Verificamos los atributos y reiniciamos los componentes del plano de control. <br><br>  Sergey Bondarev, <br>  Profesor slurm <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">slurm.io</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/465733/">https://habr.com/ru/post/465733/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../465723/index.html">Posit-aritm칠tica: derrotando un punto flotante en su propio campo. Parte 1</a></li>
<li><a href="../465725/index.html">Entrenamiento Cisco 200-125 CCNA v3.0. D칤a 28. Estudio en profundidad de ACL</a></li>
<li><a href="../465727/index.html">Convi칠rtete en Zuckerberg o programador de infancia</a></li>
<li><a href="../465729/index.html">Eventos digitales en Mosc칰 del 2 al 8 de septiembre.</a></li>
<li><a href="../465731/index.html">Una gran cantidad de canales de YouTube para aprender ingl칠s para programadores</a></li>
<li><a href="../465735/index.html">C칩mo es el sistema de enfriamiento pasivo en computadoras MIC-7900</a></li>
<li><a href="../465737/index.html">Tamiz Sundarama</a></li>
<li><a href="../465741/index.html">C칩mo el enredo cu치ntico ayudar치 en la detecci칩n de ondas gravitacionales</a></li>
<li><a href="../465743/index.html">Regresi칩n lineal y m칠todos para su restauraci칩n.</a></li>
<li><a href="../465745/index.html">Tutorial de TensorFlow: Tutorial para principiantes de 10 minutos de TensorFlow [Traducci칩n]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>