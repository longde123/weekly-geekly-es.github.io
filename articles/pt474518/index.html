<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚öïÔ∏è üõÄ ü§µüèæ FP vs OOP üë©üèΩ‚Äçüî¨ üõÉ üíÉüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="H√° pouco tempo, v√°rias postagens apareceram no hub, contrastando a abordagem funcional e de objeto, o que gerou nos coment√°rios uma discuss√£o acalorad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>FP vs OOP</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474518/"><p>  H√° pouco tempo, v√°rias postagens apareceram no hub, contrastando a abordagem funcional e de objeto, o que gerou nos coment√°rios uma discuss√£o acalorada sobre o que realmente √© - programa√ß√£o orientada a objeto e como ela difere de funcional.  Embora um pouco tarde, quero compartilhar com outras pessoas o que Robert Martin, tamb√©m conhecido como tio Bob, pensa sobre isso. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/cf/hd/udcfhd13y7i2zdqhnhtotltstyg.jpeg"></div><a name="habracut"></a><br><p>  Nos √∫ltimos anos, pude repetidamente programar em conjunto com pessoas que estudam Programa√ß√£o Funcional que eram tendenciosas em rela√ß√£o √† OOP.  Isso geralmente era expresso na forma de declara√ß√µes como: "Bem, isso √© muito parecido com algo objeto". </p><br><p>  Eu acho que isso vem da cren√ßa de que FP e OOP s√£o mutuamente exclusivos.  Muitos parecem pensar que, se o programa √© funcional, n√£o √© orientado a objetos.  Eu acredito que a forma√ß√£o dessa opini√£o √© uma consequ√™ncia l√≥gica do estudo de algo novo. </p><br><p>  Quando adotamos uma nova t√©cnica, geralmente come√ßamos a evitar as t√©cnicas antigas que usamos anteriormente.  Isso √© natural, porque acreditamos que a nova t√©cnica √© "melhor" e, portanto, a t√©cnica antiga √© provavelmente "pior". </p><br><p>  Neste post, justifico-me que, embora OOP e FP sejam ortogonais, esses conceitos n√£o s√£o mutuamente exclusivos.  Que um bom programa funcional pode (e deve) ser orientado a objetos.  E que um bom programa orientado a objetos pode (e deve) ser funcional.  Mas, para fazer isso, precisamos determinar os termos. </p><br><h2 id="chto-takoe-oop">  O que √© OOP? </h2><br><p>  Abordarei a quest√£o de uma perspectiva reducionista.  Existem muitas defini√ß√µes corretas de POO que abrangem muitos conceitos, princ√≠pios, t√©cnicas, padr√µes e filosofias.  Pretendo ignor√°-los e me concentrar no pr√≥prio sal.  Aqui, o reducionismo √© necess√°rio porque toda essa riqueza de oportunidades em torno da OOP n√£o √© realmente algo espec√≠fico para a OOP;  √© apenas parte da riqueza de oportunidades encontradas no desenvolvimento de software em geral.  Aqui vou me concentrar na parte da OOP, que √© definidora e irremov√≠vel. </p><br><p>  Veja duas express√µes: </p><br><p>  1: f (o);  2: de (); </p><br><p>  Qual a diferen√ßa? </p><br><p>  Claramente, n√£o h√° diferen√ßa sem√¢ntica.  Toda a diferen√ßa est√° inteiramente na sintaxe.  Mas um parece processual e o outro √© orientado a objetos.  Isso ocorre porque estamos acostumados ao fato de que a express√£o 2 implica implicitamente uma sem√¢ntica de comportamento especial que a express√£o 1. N√£o possui. Essa sem√¢ntica de comportamento espec√≠fica √© o polimorfismo. </p><br><p>  Quando vemos a express√£o 1., vemos a fun√ß√£o <strong>f</strong> , que √© chamada para a qual o objeto <strong>o √©</strong> transferido.  Isso implica que existe apenas uma fun√ß√£o chamada f, e n√£o o fato de ser um membro da coorte padr√£o de fun√ß√µes em torno de o. </p><br><p>  Por outro lado, quando vemos a express√£o 2., vemos um objeto com o nome <strong>o para o</strong> qual uma mensagem com o nome <strong>f</strong> √© enviada.  Esperamos que haja outros tipos de objetos que recebam a mensagem f e, portanto, n√£o sabemos qual comportamento espec√≠fico esperar de f ap√≥s a chamada.  O comportamento depende do tipo o.  isto √©, f √© polim√≥rfico. </p><br><p>  Esse fato que esperamos dos m√©todos de comportamento polim√≥rfico √© a ess√™ncia da programa√ß√£o orientada a objetos.  Esta √© uma defini√ß√£o reducionista e essa propriedade n√£o pode ser removida do OOP.  POO sem polimorfismo n√£o √© POO.  Todas as outras propriedades de POO, como encapsulamento de dados e m√©todos vinculados a esses dados e at√© heran√ßa, est√£o mais relacionadas √† express√£o 1. do que √† express√£o 2. </p><br><p>  Programadores que usam C e Pascal (e at√© certo ponto at√© Fortran e Cobol) sempre criaram sistemas de fun√ß√µes e estruturas encapsuladas.  Para criar essas estruturas, voc√™ nem precisa de uma linguagem de programa√ß√£o orientada a objetos.  O encapsulamento e at√© a simples heran√ßa nessas l√≠nguas s√£o √≥bvios e naturais.  (Em C e Pascal mais naturalmente do que em outros) </p><br><p>  Portanto, o que realmente distingue os programas OOP dos programas n√£o OOP √© o polimorfismo. </p><br><p>  Voc√™ pode argumentar que o poliforismo pode ser feito simplesmente usando o interruptor f interno ou longas cadeias if / else.  Isso √© verdade, ent√£o eu preciso definir outra limita√ß√£o para OOP. </p><br><p>  O uso do polimorfismo n√£o deve criar a depend√™ncia do chamador no chamado. </p><br><p>  Para explicar isso, vejamos novamente as express√µes.  A express√£o 1: f (o) parece depender da fun√ß√£o f no n√≠vel do c√≥digo fonte.  Tiramos essa conclus√£o porque tamb√©m assumimos que f √© apenas um e que, portanto, o chamador deve saber sobre o chamado. </p><br><p>  No entanto, quando olhamos para a express√£o 2. de () assumimos outra coisa.  Sabemos que pode haver muitas realiza√ß√µes de f e n√£o sabemos qual dessas fun√ß√µes f ser√° realmente chamada.  Portanto, o c√≥digo-fonte que cont√©m a express√£o 2 √© independente da fun√ß√£o que est√° sendo chamada no n√≠vel do c√≥digo-fonte. </p><br><p>  Mais especificamente, isso significa que m√≥dulos (arquivos com c√≥digo fonte) que cont√™m chamadas de fun√ß√£o polim√≥rficas n√£o devem se referir a m√≥dulos (arquivos com c√≥digo fonte) que cont√™m a implementa√ß√£o dessas fun√ß√µes.  N√£o pode haver <strong>inclus√£o,</strong> <strong>uso</strong> ou <strong>exig√™ncia</strong> ou qualquer outra palavra-chave que torne alguns arquivos de c√≥digo-fonte dependentes de outros. </p><br><p>  Portanto, nossa defini√ß√£o reducionista de POO √©: </p><br><blockquote>  Uma t√©cnica que usa o polimorfismo din√¢mico para chamar fun√ß√µes e n√£o cria depend√™ncias do chamador no chamado no n√≠vel do c√≥digo-fonte. </blockquote><br><h2 id="chto-takoe-fp">  O que √© AF? </h2><br><p>  E, novamente, usarei a abordagem reducionista.  O FP tem tradi√ß√µes e hist√≥ria ricas, cujas ra√≠zes s√£o mais profundas do que a pr√≥pria programa√ß√£o.  Existem princ√≠pios, t√©cnicas, teoremas, filosofias e conceitos que permeiam esse paradigma.  Ignorarei tudo isso e irei direto √† ess√™ncia, √† propriedade inerente que separa FP de outros estilos.  Aqui est√°: </p><br><p>  f (a) == f (b) se a == b. </p><br><p>  Em um programa funcional, chamar uma fun√ß√£o com o mesmo argumento fornece o mesmo resultado, n√£o importa quanto tempo o programa esteja em execu√ß√£o.  Isso √†s vezes √© chamado de transpar√™ncia referencial. </p><br><p>  Segue-se do exposto acima que f n√£o deve alterar as partes do estado global que afetam o comportamento de f.  Al√©m disso, se dissermos que f representa todas as fun√ß√µes do sistema - ou seja, todas as fun√ß√µes do sistema devem ser referencialmente transparentes -, nenhuma fun√ß√£o do sistema pode alterar o estado global.  Nenhuma fun√ß√£o pode fazer algo que possa levar a outra fun√ß√£o do sistema retornando um valor diferente com os mesmos argumentos. </p><br><p>  Isso tem uma conseq√º√™ncia mais profunda - nenhum valor nomeado pode ser alterado.  Ou seja, n√£o h√° operador de atribui√ß√£o. </p><br><p>  Se voc√™ considerar cuidadosamente essa afirma√ß√£o, poder√° concluir que um programa que consiste apenas em fun√ß√µes transparentemente transparentes n√£o pode fazer nada - j√° que qualquer comportamento √∫til do sistema altera o estado de algo;  mesmo que seja apenas o estado da impressora ou tela.  No entanto, se excluirmos o ferro dos requisitos de transpar√™ncia referencial e de todos os elementos do mundo ao nosso redor, acontece que podemos criar sistemas muito √∫teis. </p><br><p>  O foco, √© claro, est√° na recurs√£o.  Considere uma fun√ß√£o que assume uma estrutura com estado como argumento.  Este argumento consiste em todas as informa√ß√µes de estado que uma fun√ß√£o precisa para funcionar.  Quando o trabalho √© conclu√≠do, a fun√ß√£o cria uma nova estrutura com um estado cujo conte√∫do √© diferente do anterior.  E com a √∫ltima a√ß√£o, a fun√ß√£o se chama com uma nova estrutura como argumento. </p><br><p>  Este √© apenas um dos truques simples que um programa funcional pode usar para armazenar altera√ß√µes de estado sem precisar mudar de estado [1]. </p><br><p>  Portanto, a defini√ß√£o reducionista de programa√ß√£o funcional: </p><br><blockquote>  Transpar√™ncia referencial - Voc√™ n√£o pode reatribuir valores. </blockquote><br><h2 id="fp-protiv-oop">  FP vs OOP </h2><br><p>  Neste ponto, tanto os defensores da OOP quanto os da FI j√° est√£o me olhando atrav√©s de miras √≥pticas.  Reducionismo n√£o √© a melhor maneira de fazer amigos.  Mas √†s vezes √© √∫til.  Nesse caso, acho que √© √∫til lan√ßar luz sobre o holivar anti-OOP que est√° desaparecendo. </p><br><p>  √â claro que as duas defini√ß√µes reducionistas que eu escolhi s√£o completamente ortogonais.  Polimorfismo e Transpar√™ncia Referencial n√£o t√™m nada a ver um com o outro.  Eles n√£o se cruzam de forma alguma. </p><br><p>  Mas a ortogonalidade n√£o implica exclus√£o m√∫tua (pergunte a James Clerk Maxwell).  √â inteiramente poss√≠vel criar um sistema que use polimorfismo din√¢mico e transpar√™ncia referencial.  N√£o √© apenas poss√≠vel, √© certo e bom! </p><br><p>  Por que essa combina√ß√£o √© boa?  Pelas mesmas raz√µes que os dois componentes!  Os sistemas constru√≠dos com polimorfismo din√¢mico s√£o bons porque t√™m baixa conectividade.  Depend√™ncias podem ser invertidas e colocadas em lados diferentes dos limites da arquitetura.  Esses sistemas podem ser testados usando Moki e Fake e outros tipos de dobros de teste.  Os m√≥dulos podem ser modificados sem fazer altera√ß√µes em outros m√≥dulos.  Portanto, esses sistemas s√£o mais f√°ceis de modificar e melhorar. </p><br><p>  Os sistemas constru√≠dos com transpar√™ncia referencial tamb√©m s√£o bons porque s√£o previs√≠veis.  A imutabilidade do estado torna esses sistemas mais f√°ceis de entender, mudar e melhorar.  Isso reduz bastante a probabilidade de corridas e outros problemas de multithreading. </p><br><p>  A principal id√©ia aqui √© esta: </p><br><blockquote>  N√£o h√° holivar FP vs OOP </blockquote><p>  FP e OOP funcionam bem juntos.  Ambos s√£o bons e adequados para uso em sistemas modernos.  O sistema, baseado em uma combina√ß√£o dos princ√≠pios de OOP e FP, maximiza a flexibilidade, a manuten√ß√£o, a testabilidade, a simplicidade e a resist√™ncia.  Se voc√™ remover um para adicionar outro, isso s√≥ piorar√° a estrutura do sistema. </p><br><p>  [1] Como usamos m√°quinas com arquitetura Von Neumann, assumimos que elas possuem c√©lulas de mem√≥ria cujo estado realmente muda.  No mecanismo de recurs√£o que descrevi, a otimiza√ß√£o da recurs√£o da cauda n√£o permitir√° a cria√ß√£o de novas molduras de vidro e a moldura de vidro original ser√° usada.  Mas essa viola√ß√£o da transpar√™ncia referencial (geralmente) est√° oculta do programador e n√£o afeta nada. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt474518/">https://habr.com/ru/post/pt474518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt474502/index.html">Odnoklassniki analisando no Joker 2019</a></li>
<li><a href="../pt474504/index.html">Backend ortodoxo</a></li>
<li><a href="../pt474508/index.html">Realiza√ß√µes da bioprinting 3D de enxertos de pele</a></li>
<li><a href="../pt474514/index.html">Como sobrevivem os magnatas da minera√ß√£o chinesa de Bitcoin</a></li>
<li><a href="../pt474516/index.html">Aplica√ß√µes de voz: o bilion√©simo mercado que a R√∫ssia n√£o percebe</a></li>
<li><a href="../pt474522/index.html">Hist√≥ria de vira-lata</a></li>
<li><a href="../pt474526/index.html">Semin√°rios on-line da Hewlett Packard Enterprise em novembro e janeiro</a></li>
<li><a href="../pt474528/index.html">O livro "Computa√ß√£o qu√¢ntica para verdadeiros profissionais de TI"</a></li>
<li><a href="../pt474532/index.html">Laborat√≥rio de r√°dio Nizhny Novgorod e r√°dios com detectores de cristal</a></li>
<li><a href="../pt474534/index.html">Livro de Alan Turing e Nota Misteriosa - Detetive Cient√≠fico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>