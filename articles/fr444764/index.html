<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèΩ üì¢ üè† Cryptographie en Java üßö üë©üèø‚Äç‚öñÔ∏è üßîüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article "Java Cryptography" de Jakob Jenkov. 


 Cette publication est une traduction du premier ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cryptographie en Java</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444764/"><p> Bonjour, Habr!  Je vous pr√©sente la traduction de l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"Java Cryptography"</a> de Jakob Jenkov. </p><br><p>  Cette publication est une traduction du premier article sur la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cryptographie Java</a> d'une s√©rie d'articles pour les d√©butants qui souhaitent apprendre les bases de la cryptographie en Java. </p><a name="habracut"></a><br><h2 id="oglavlenie">  Table des mati√®res: </h2><br><ol><li>  Cryptographie Java </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Chiffre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Messagedigest</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mac</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Signature</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Keypair</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©n√©rateur de cl√©s</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">KeyPairGenerator</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Keystore</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Keytool</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Attestation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CertificateFactory</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CertPath</a> </li></ol><br><h1 id="java-cryptography">  Cryptographie Java </h1><br><p>  <strong>L'API de cryptographie Java</strong> offre la possibilit√© de crypter et de d√©crypter des donn√©es en java, ainsi que de g√©rer les cl√©s, les signatures et d'authentifier (authentifier) ‚Äã‚Äãles messages, de calculer des hachages cryptographiques et bien plus encore. </p><br><p>  Cet article explique les bases de l'utilisation de l'API Java Cryptography pour effectuer diverses t√¢ches qui n√©cessitent un chiffrement s√©curis√©. </p><br><p>  Cet article n'explique pas les bases de la th√©orie cryptographique.  Vous devrez voir ces informations ailleurs. </p><br><h2 id="rasshirenie-kriptografii-java">  Extension de cryptographie Java </h2><br><p>  L'API de cryptographie Java est fournie par ce que l'on appelle <strong>l'extension de cryptographie Java</strong> (JCE).  JCE fait depuis longtemps partie de la plateforme Java.  Initialement, JCE a √©t√© s√©par√© de Java en raison des restrictions √† l'exportation sur la technologie de chiffrement aux √âtats-Unis.  Par cons√©quent, les algorithmes de chiffrement les plus puissants n'√©taient pas inclus dans la plate-forme Java standard.  Ces algorithmes de chiffrement plus robustes peuvent √™tre appliqu√©s si votre entreprise est situ√©e aux √âtats-Unis, mais dans d'autres cas, vous devrez utiliser des algorithmes plus faibles ou impl√©menter vos propres algorithmes de chiffrement et les connecter √† JCE. </p><br><p>  Depuis 2017, les r√®gles d'exportation des algorithmes de chiffrement aux √âtats-Unis ont √©t√© consid√©rablement assouplies et, dans la plupart des r√©gions du monde, vous pouvez utiliser les normes de chiffrement internationales via Java JCE. </p><br><p>  Architecture de cryptographie Java </p><br><p>  <strong>Java Cryptography Architecture (JCA)</strong> est le nom de la conception de l'API de cryptographie interne en Java.  JCA est structur√© autour de plusieurs classes de base et interfaces √† usage g√©n√©ral.  La fonctionnalit√© r√©elle de ces interfaces est fournie par les fournisseurs.  Ainsi, vous pouvez utiliser la classe Cipher pour chiffrer et d√©chiffrer certaines donn√©es, mais l'impl√©mentation sp√©cifique du chiffrement (algorithme de chiffrement) d√©pend du fournisseur particulier utilis√©. </p><br><p>  Vous pouvez √©galement impl√©menter et connecter vos propres fournisseurs, mais vous devez √™tre prudent avec cela.  Il est difficile de mettre en ≈ìuvre correctement le chiffrement sans failles de s√©curit√©!  Si vous ne savez pas ce que vous faites, vous feriez probablement mieux d‚Äôutiliser le fournisseur Java int√©gr√© ou un fournisseur de confiance tel que Bouncy Castle. </p><br><h3 id="osnovnye-klassy-i-interfeysy">  Classes principales et interfaces </h3><br><p>  L'API Java Cryptography se compose des packages Java suivants: </p><br><ul><li>  java.security </li><li>  java.security.cert </li><li>  java.security.spec </li><li>  java.security.interfaces </li><li>  javax.crypto </li><li>  javax.crypto.spec </li><li>  javax.crypto.interfaces </li></ul><br><p>  Les principales classes et interfaces de ces packages: </p><br><ul><li>  Fournisseur </li><li>  SecureRandom </li><li>  Chiffre </li><li>  Messagedigest </li><li>  Signature </li><li>  Mac </li><li>  AlgorithmParameters </li><li>  AlgorithmParameterGenerator </li><li>  Keyfactory </li><li>  SecretKeyFactory </li><li>  KeyPairGenerator </li><li>  G√©n√©rateur de cl√©s </li><li>  Accord de cl√© </li><li>  Keystore </li><li>  CertificateFactory </li><li>  CertPathBuilder </li><li>  CertPathValidator </li><li>  CertStore </li></ul><br><h3 id="provider-postavschik-kriptografii">  Fournisseur </h3><br><p>  La classe Provider (java.security.Provider) est la classe centrale de l'API de chiffrement Java.  Pour utiliser l'API de cryptographie Java, vous devez installer un fournisseur de cryptographie.  Le SDK Java est livr√© avec son propre fournisseur de cryptographie.  Sauf si vous d√©finissez explicitement le fournisseur de cryptographie, le fournisseur par d√©faut sera utilis√©.  Cependant, ce fournisseur de chiffrement peut ne pas prendre en charge les algorithmes de chiffrement que vous souhaitez utiliser.  Par cons√©quent, vous devrez peut-√™tre installer votre propre fournisseur de cryptographie. </p><br><p>  L'un des fournisseurs de cryptographie les plus populaires pour l'API de cryptographie Java est appel√© Bouncy Castle.  Voici un exemple o√π BouncyCastleProvider est d√©fini comme fournisseur cryptographique: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.bouncycastle.jce.provider.BouncyCastleProvider; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.security.Security; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProviderExample</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Security.addProvider(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BouncyCastleProvider()); } }</code> </pre> <br><h3 id="cipher-shifr">  Chiffre </h3><br><p>  La classe Cipher (javax.crypto.Cipher) repr√©sente un algorithme cryptographique.  Un chiffrement peut √™tre utilis√© √† la fois pour le chiffrement et pour le d√©chiffrement des donn√©es.  La classe Cipher est expliqu√©e plus en d√©tail dans les sections suivantes, avec une br√®ve description ci-dessous. </p><br><p>  Cr√©ation d'une instance de la classe de chiffrement qui utilise l'algorithme de chiffrement AES pour un usage interne: </p><br><pre> <code class="java hljs">Cipher cipher = Cipher.getInstance(<span class="hljs-string"><span class="hljs-string">"AES/CBC/PKCS5Padding"</span></span>);</code> </pre> <br><p>  La <em>m√©thode Cipher.getInstance (...)</em> accepte une cha√Æne qui d√©termine l'algorithme de chiffrement √† utiliser, ainsi que d'autres param√®tres d'algorithme. <br>  Dans l'exemple ci-dessus: </p><br><ul><li>  AES - algorithme de chiffrement </li><li>  CBC est un mode dans lequel l'algorithme AES peut fonctionner. </li><li>  PKCS5Padding est la fa√ßon dont l'algorithme AES doit traiter les derniers octets de donn√©es pour le chiffrement.  Qu'est-ce que cela signifie exactement, regardez dans le manuel de cryptographie dans son ensemble, et non dans cet article. </li></ul><br><h4 id="inicializaciya-shifra">  Initialisation du chiffrement </h4><br><p>  Avant d'utiliser une instance de chiffrement, vous devez l'initialiser.  L'instance de chiffrement est initialis√©e en appelant la m√©thode <em>init ()</em> .  La m√©thode <em>init ()</em> prend deux param√®tres: </p><br><ul><li>  Mode - Cryptage / d√©cryptage </li><li>  Cl√© </li></ul><br><p>  Le premier param√®tre indique le mode de fonctionnement de l'instance de chiffrement: pour chiffrer ou d√©chiffrer des donn√©es.  Le deuxi√®me param√®tre indique quelle cl√© ils utilisent pour crypter ou d√©crypter les donn√©es. </p><br><p>  Un exemple: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); cipher.init(Cipher.ENCRYPT_MODE, key);</code> </pre><br><p>  Veuillez noter que la m√©thode de cr√©ation de cl√© dans cet exemple n'est pas s√ªre et ne doit pas √™tre utilis√©e dans la pratique.  Cet article dans les sections suivantes explique comment cr√©er des cl√©s de mani√®re plus s√©curis√©e. </p><br><p>  Pour initialiser une instance de chiffrement pour d√©chiffrer des donn√©es, vous devez utiliser Cipher.DECRYPT_MODE, par exemple: </p><br><pre> <code class="java hljs">cipher.init(Cipher.DECRYPT_MODE, key);</code> </pre> <br><h4 id="shifrovanie-ili-deshifrovanie-dannyh">  Cryptage ou d√©cryptage des donn√©es </h4><br><p>  Apr√®s avoir initialis√© le chiffrement, vous pouvez commencer √† chiffrer ou d√©chiffrer les donn√©es en appelant les m√©thodes <em>update ()</em> ou <em>doFinal ()</em> .  La m√©thode <em>update ()</em> est utilis√©e si vous chiffrez ou d√©chiffrez une donn√©e.  La m√©thode <em>doFinal ()</em> est appel√©e lorsque vous chiffrez la derni√®re donn√©e ou si le bloc de donn√©es que vous passez √† <em>doFinal ()</em> est un ensemble unique de donn√©es pour le chiffrement. </p><br><p>  Un exemple de chiffrement des donn√©es √† l'aide de la m√©thode <em>doFinal ()</em> : </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] plainText = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvwxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] cipherText = cipher.doFinal(plainText);</code> </pre> <br><p>  Pour d√©crypter les donn√©es, vous devez passer le texte chiffr√© (donn√©es) √† la <em>m√©thode doFinal ()</em> ou <em>doUpdate ()</em> . </p><br><h3 id="keys-klyuchi">  Cl√©s </h3><br><p>  Pour crypter ou d√©crypter des donn√©es, vous avez besoin d'une cl√©.  Il existe deux types de cl√©s, selon le type d'algorithme de chiffrement utilis√©: </p><br><ul><li>  Cl√©s sym√©triques </li><li>  Cl√©s asym√©triques </li></ul><br><p>  Les cl√©s sym√©triques sont utilis√©es pour les algorithmes de chiffrement sym√©triques.  Les algorithmes de chiffrement sym√©trique utilisent la m√™me cl√© pour le chiffrement et le d√©chiffrement. <br>  Les cl√©s asym√©triques sont utilis√©es pour les algorithmes de chiffrement asym√©triques.  Les algorithmes de chiffrement asym√©triques utilisent une cl√© pour le chiffrement et une autre pour le d√©chiffrement.  Les algorithmes de chiffrement √† cl√© publique et priv√©e sont des exemples d'algorithmes de chiffrement asym√©triques. </p><br><p>  D'une mani√®re ou d'une autre, la partie qui doit d√©chiffrer les donn√©es doit conna√Ætre la cl√© n√©cessaire pour d√©chiffrer les donn√©es.  Si le d√©chiffreur n'est pas partie au chiffrement des donn√©es, les deux parties doivent se mettre d'accord sur une cl√© ou √©changer une cl√©.  C'est ce qu'on appelle l'√©change de cl√©s. </p><br><h4 id="bezopasnost-klyucha">  S√©curit√© des cl√©s </h4><br><p>  Les cl√©s doivent √™tre difficiles √† deviner afin qu'un attaquant ne puisse pas facilement r√©cup√©rer une cl√© de chiffrement.  Dans l'exemple de la section pr√©c√©dente sur la classe Cipher, une cl√© tr√®s simple et cod√©e en dur a √©t√© utilis√©e.  En pratique, cela ne vaut pas la peine.  Si la cl√© des parties est facile √† deviner, il sera facile pour un attaquant de d√©chiffrer les donn√©es chiffr√©es et, √©ventuellement, de cr√©er lui-m√™me de faux messages.  Il est important de cr√©er une cl√© difficile √† deviner.  Ainsi, la cl√© doit √™tre constitu√©e d'octets al√©atoires.  Plus il y a d'octets al√©atoires, plus il est difficile de deviner, car il y a plus de combinaisons possibles. </p><br><h4 id="generaciya-klyucha">  G√©n√©ration de cl√©s </h4><br><p>  Pour g√©n√©rer des cl√©s de chiffrement al√©atoires, vous pouvez utiliser la classe Java KeyGenerator.  KeyGenerator sera d√©crit plus en d√©tail dans les chapitres suivants, voici un petit exemple de son utilisation ici: </p><br><pre> <code class="java hljs">KeyGenerator keyGenerator = KeyGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"AES"</span></span>); SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keyBitSize = <span class="hljs-number"><span class="hljs-number">256</span></span>; keyGenerator.init(keyBitSize, secureRandom); SecretKey secretKey = keyGenerator.generateKey();</code> </pre> <br><p>  L'instance SecretKey r√©sultante peut √™tre transmise √† la m√©thode <em>Cipher.init ()</em> , par exemple comme ceci: </p><br><pre> <code class="java hljs">cipher.init(Cipher.ENCRYPT_MODE, secretKey);</code> </pre> <br><h4 id="generaciya-pary-klyuchey">  G√©n√©ration de paires de cl√©s </h4><br><p>  Les algorithmes de chiffrement asym√©triques utilisent une paire de cl√©s compos√©e d'une cl√© publique et d'une cl√© priv√©e pour chiffrer et d√©chiffrer les donn√©es.  Pour cr√©er une paire de cl√©s asym√©triques, vous pouvez utiliser KeyPairGenerator (java.security.KeyPairGenerator).  KeyPairGenerator sera d√©crit plus en d√©tail dans les chapitres suivants, ci-dessous est un exemple simple d'utilisation de Java KeyPairGenerator: </p><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair();</code> </pre> <br><h4 id="hranilische-klyuchey--key-store">  Magasin de cl√©s </h4><br><p>  Java KeyStore est une base de donn√©es qui peut contenir des cl√©s.  Java KeyStore est repr√©sent√© par la classe KeyStore (java.security.KeyStore).  Un magasin de cl√©s peut contenir des cl√©s des types suivants: </p><br><ul><li>  Cl√©s priv√©es </li><li>  Cl√©s publiques et certificats (Cl√©s publiques + certificats) </li><li>  Cl√©s secr√®tes </li></ul><br><p>  Les cl√©s priv√©es et publiques sont utilis√©es dans le chiffrement asym√©trique.  La cl√© publique peut avoir un certificat associ√©.  Un certificat est un document prouvant l'identit√© d'une personne, d'une organisation ou d'un appareil pr√©tendant poss√©der une cl√© publique. </p><br><p>  Le certificat est g√©n√©ralement sign√© num√©riquement par la partie utilisatrice comme preuve. <br>  Les cl√©s priv√©es sont utilis√©es dans le chiffrement sym√©trique. La classe KeyStore est assez complexe, c'est pourquoi elle est d√©crite plus en d√©tail plus loin dans un chapitre s√©par√© sur Java KeyStore. </p><br><h4 id="instrument-upravleniya-klyuchami-keytool">  Outil de gestion des cl√©s (Keytool) </h4><br><p>  Java Keytool est un outil en ligne de commande qui peut fonctionner avec des fichiers Java KeyStore.  Keytool peut g√©n√©rer des paires de cl√©s dans un fichier KeyStore, exporter des certificats et importer des certificats dans KeyStore et certaines autres fonctions.  Keytool est livr√© avec une installation Java.  Keytool est d√©crit plus en d√©tail plus loin dans un chapitre s√©par√© sur Java Keytool. </p><br><h3 id="daydzhest-soobscheniya-messagedigest">  R√©sum√© des messages </h3><br><p>  Lorsque vous recevez des donn√©es crypt√©es de l'autre c√¥t√©, pouvez-vous √™tre s√ªr que personne n'a modifi√© les donn√©es crypt√©es en route vers vous? </p><br><p>  En r√®gle g√©n√©rale, la solution consiste √† calculer le r√©sum√© de message √† partir des donn√©es avant de le chiffrer, puis √† chiffrer √† la fois les donn√©es et le r√©sum√© de message, et √† l'envoyer sur le r√©seau.  Un r√©sum√© de message est une valeur de hachage calcul√©e sur la base des donn√©es de message.  Si au moins un octet est modifi√© dans les donn√©es chiffr√©es, le r√©sum√© de message calcul√© √† partir des donn√©es changera √©galement. </p><br><p>  Lorsque vous recevez des donn√©es chiffr√©es, vous les d√©chiffrez, calculez le r√©sum√© de message √† partir de celles-ci et comparez le r√©sum√© de message calcul√© avec le r√©sum√© du message envoy√© avec les donn√©es chiffr√©es.  Si les deux r√©sum√©s de messages sont identiques, il y a une forte probabilit√© (mais pas 100%) que les donn√©es n'aient pas √©t√© modifi√©es. </p><br><p>  Java MessageDigest (java.security.MessageDigest) peut √™tre utilis√© pour calculer les r√©sum√©s de messages.  Pour cr√©er une instance de MessageDigest, la m√©thode <em>MessageDigest.getInstance ()</em> est appel√©e.  Il existe plusieurs algorithmes diff√©rents de r√©sum√© des messages.  Vous devez sp√©cifier l'algorithme que vous souhaitez utiliser lors de la cr√©ation de l'instance MessageDigest.  L'utilisation de MessageDigest sera d√©crite plus en d√©tail dans le chapitre Java MessageDigest. </p><br><h4 id="kratkoe-vvedenie-v-klass-messagedigest">  Une br√®ve introduction √† la classe MessageDigest: </h4><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>);</code> </pre> <br><p>  Cet exemple cr√©e une instance de MessageDigest qui utilise l'algorithme de hachage cryptographique interne SHA-256 pour calculer les r√©sum√©s de messages. </p><br><p>  Pour calculer le r√©sum√© de message de certaines donn√©es, vous appelez la m√©thode <em>update ()</em> ou <em>digest ()</em> .  La m√©thode <em>update ()</em> peut √™tre appel√©e plusieurs fois et le r√©sum√© du message est mis √† jour √† l'int√©rieur de l'objet.  Lorsque vous avez transmis toutes les donn√©es que vous souhaitez inclure dans le r√©sum√© de message, vous appelez <em>digest ()</em> et r√©cup√©rez le r√©sum√© du r√©sum√© de message. </p><br><p>  Un exemple d'appel multiple de <em>update ()</em> , suivi d'un appel √† <em>digest ()</em> : </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); messageDigest.update(data1); messageDigest.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest();</code> </pre> <br><p>  Vous pouvez √©galement appeler <em>digest ()</em> une fois, en transmettant toutes les donn√©es pour calculer le r√©sum√© du message.  Un exemple: </p><br><pre> <code class="java hljs">MessageDigest messageDigest = MessageDigest.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data1 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digest = messageDigest.digest(data1);</code> </pre> <br><h3 id="kod-autentifikacii-soobscheniya-mac">  Code d'authentification de message (MAC) </h3><br><p>  La classe Java Mac est utilis√©e pour cr√©er un MAC (Message Authentication Code) √† partir d'un message.  Le MAC est similaire √† un r√©sum√© de message, mais utilise une cl√© suppl√©mentaire pour crypter le r√©sum√© de message.  N'ayant que les donn√©es source et la cl√©, vous pouvez v√©rifier le MAC.  Ainsi, un MAC est un moyen plus s√ªr de prot√©ger un bloc de donn√©es contre la modification qu'un r√©sum√© de message.  La classe Mac est d√©crite plus en d√©tail dans le chapitre Java Mac, suivie d'une br√®ve introduction. </p><br><p>  Une instance Java Mac est cr√©√©e en appelant la m√©thode <em>Mac.getInstance ()</em> , en passant le nom de l'algorithme √† utiliser comme param√®tre.  Voici √† quoi √ßa ressemble: </p><br><pre> <code class="java hljs">Mac mac = Mac.getInstance(<span class="hljs-string"><span class="hljs-string">"HmacSHA256"</span></span>);</code> </pre> <br><p>  Avant de cr√©er un MAC √† partir de donn√©es, vous devez initialiser l'instance Mac avec la cl√©.  Voici un exemple d'initialisation d'une instance Mac avec une cl√©: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] keyBytes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[]{<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> ,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>}; String algorithm = <span class="hljs-string"><span class="hljs-string">"RawBytes"</span></span>; SecretKeySpec key = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecretKeySpec(keyBytes, algorithm); mac.init(key);</code> </pre> <br><p>  Apr√®s avoir initialis√© l'instance Mac, vous pouvez calculer le MAC √† partir des donn√©es en appelant les m√©thodes <em>update ()</em> et <em>doFinal ()</em> .  Si vous disposez de toutes les donn√©es pour calculer le MAC, vous pouvez imm√©diatement appeler la m√©thode <em>doFinal ()</em> .  Voici √† quoi √ßa ressemble: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); mac.update(data); mac.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] macBytes = mac.doFinal();</code> </pre> <br><h3 id="podpis-signature">  Signature </h3><br><p>  La classe Signature (java.security.Signature) est utilis√©e pour signer num√©riquement les donn√©es.  Lorsque des donn√©es sont sign√©es, une signature num√©rique est cr√©√©e √† partir de ces donn√©es.  Ainsi, la signature est s√©par√©e des donn√©es. </p><br><p>  Une signature num√©rique est cr√©√©e en cr√©ant un r√©sum√© de message (hachage) √† partir des donn√©es et en chiffrant ce r√©sum√© de message avec la cl√© priv√©e de l'appareil, de la personne ou de l'organisation qui doit signer les donn√©es.  Le r√©sum√© du message crypt√© est appel√© signature num√©rique. </p><br><p>  Pour cr√©er une instance de Signature, la m√©thode <em>Signature.getInstance (...)</em> est appel√©e: </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>);</code> </pre> <br><h4 id="podpis-dannyh">  Signature des donn√©es </h4><br><p>  Pour signer des donn√©es, vous devez initialiser l'instance de signature en mode signature en appelant la m√©thode initSign (...), en passant la cl√© priv√©e pour signer les donn√©es.  Un exemple d'initialisation d'une instance de signature en mode signature: </p><br><pre> <code class="java hljs">signature.initSign(keyPair.getPrivate(), secureRandom);</code> </pre> <br><p>  Apr√®s avoir initialis√© l'instance de signature, elle peut √™tre utilis√©e pour signer les donn√©es.  Cela se fait en appelant la m√©thode update (), en passant les donn√©es de signature en tant que param√®tre.  Vous pouvez appeler la m√©thode update () plusieurs fois pour compl√©ter les donn√©es de cr√©ation de la signature.  Une fois toutes les donn√©es transmises √† la m√©thode update (), la m√©thode sign () est appel√©e pour obtenir une signature num√©rique.  Voici √† quoi √ßa ressemble: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign();</code> </pre> <br><h4 id="proverka-podpisi">  V√©rification de signature </h4><br><p>  Pour v√©rifier la signature, vous devez initialiser l'instance de signature en mode v√©rification en appelant la <em>m√©thode initVerify (...)</em> , en transmettant la cl√© publique en tant que param√®tre, qui est utilis√©e pour v√©rifier la signature.  Un exemple d'initialisation d'une instance de signature en mode de v√©rification ressemble √† ceci: </p><br><pre> <code class="java hljs">Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initVerify(keyPair.getPublic());</code> </pre> <br><p>  Apr√®s l'initialisation en mode v√©rification, les donn√©es sign√©es sont transmises √† la m√©thode <em>update ()</em> .  Un appel √† la m√©thode <em>verify ()</em> renvoie <em>vrai</em> ou <em>faux</em> selon que la signature peut √™tre v√©rifi√©e ou non.  Voici la v√©rification de signature: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data2 = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature2.update(data2); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature);</code> </pre> <br><h4 id="polnyy-primer-podpisi-i-proverki">  Exemple complet de signature et de v√©rification </h4><br><pre> <code class="java hljs">SecureRandom secureRandom = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecureRandom(); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="hljs-string"><span class="hljs-string">"DSA"</span></span>); KeyPair keyPair = keyPairGenerator.generateKeyPair(); Signature signature = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature.initSign(keyPair.getPrivate(), secureRandom); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] data = <span class="hljs-string"><span class="hljs-string">"abcdefghijklmnopqrstuvxyz"</span></span>.getBytes(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>); signature.update(data); <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] digitalSignature = signature.sign(); Signature signature2 = Signature.getInstance(<span class="hljs-string"><span class="hljs-string">"SHA256WithDSA"</span></span>); signature2.initVerify(keyPair.getPublic()); signature2.update(data); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> verified = signature2.verify(digitalSignature); System.out.println(<span class="hljs-string"><span class="hljs-string">"verified = "</span></span> + verified);</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444764/">https://habr.com/ru/post/fr444764/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444752/index.html">L'histoire de SXSW: comment tout a commenc√©</a></li>
<li><a href="../fr444756/index.html">La DARPA d√©veloppera un moteur nucl√©aire de fus√©e</a></li>
<li><a href="../fr444758/index.html">Diff√©rences techniques des syst√®mes de BI (Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../fr444760/index.html">Machine CNC de ce qui gisait dans le garage</a></li>
<li><a href="../fr444762/index.html">CSTroN - un moniteur fait maison sur une matrice CSTN vintage avec une entr√©e VGA et une carte de contr√¥le FPGA</a></li>
<li><a href="../fr444766/index.html">Les employ√©s de Facebook avaient acc√®s aux mots de passe des utilisateurs Facebook et Instagram</a></li>
<li><a href="../fr444768/index.html">R√©duire la d√©pendance aux donn√©es marqu√©es dans les r√©seaux g√©n√©ratifs-contradictoires</a></li>
<li><a href="../fr444770/index.html">Comment nous avons recherch√© une fuite de donn√©es dans SimilarWeb</a></li>
<li><a href="../fr444774/index.html">Erreur avec la migration des param√®tres r√©gionaux ru-RU dans Google Chrome et comment s'en d√©barrasser</a></li>
<li><a href="../fr444776/index.html">N'ayez pas peur d'essayer, ou comment je suis devenu programmeur √† l'√¢ge de bien plus de 18 ans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>