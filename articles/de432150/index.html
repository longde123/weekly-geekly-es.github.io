<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏽 ✝️ 🚕 Rückblick auf Automatisierung und Veränderung in Timeweb-Entwicklungsprozessen 👩🏾‍🔧 👏🏿 👩🏿‍🤝‍👩🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Am 1. November 2017 wurde ich Leiter des Entwicklungsteams in der Timeweb-Softwareentwicklungsabteilung. Und am 12. November 2018 fragte der Abteilung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rückblick auf Automatisierung und Veränderung in Timeweb-Entwicklungsprozessen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/timeweb/blog/432150/"> Am 1. November 2017 wurde ich Leiter des Entwicklungsteams in der Timeweb-Softwareentwicklungsabteilung.  Und am 12. November 2018 fragte der Abteilungsleiter, wann der Artikel für Habrahabr fertig sein würde, weil die Marketingabteilung fragte, die Freiwilligen beendet waren und der Inhaltsplan etwas anderes erforderte. <br><br>  Daher möchte ich einen Rückblick darauf geben, wie sich die Entwicklungs-, Test- und Lieferprozesse unserer Produkte im vergangenen Jahr verändert haben.  Über ältere Prozesse und Tools, Docker, Gitlab und wie wir uns entwickeln. <br><a name="habracut"></a><br>  Timeweb Hoster existiert seit 2006.  Während dieser ganzen Zeit investiert das Unternehmen viel Mühe, um den Kunden einen einzigartigen und bequemen Service zu bieten, der es von den Mitbewerbern unterscheidet.  Timeweb verfügt über eigene mobile Anwendungen, eine webbasierte E-Mail-Schnittstelle, Kontrollfelder für virtuelles Hosting, VDS, ein Partnerprogramm, Support-Tools und vieles mehr. <br><br>  <b>In unserem Gitlab befinden sich ungefähr 250 Projekte:</b> Client-Anwendungen, interne Tools, Bibliotheken und Konfigurations-Repositorys.  Dutzende von ihnen werden aktiv entwickelt und unterstützt: Sie verpflichten sich während der Arbeitswoche, testen, sammeln und geben sie frei. <br><br>  Zusätzlich zu der großen Menge an Legacy-Code bringt dies eine angemessene Anzahl geerbter Prozesse und zugehöriger Tools mit sich.  Wie jedes Vermächtnis müssen sie auch gewartet, optimiert, überarbeitet und manchmal ersetzt werden. <br><br>  Von all dieser Fülle von Projekten sind Control Panels dem Hosting von Kunden am nächsten.  Und genau im Projekt „Control Panel“ führen wir am häufigsten verschiedene Infrastrukturverbesserungen durch und unternehmen große Anstrengungen, um die vernetzte Infrastruktur in Form zu halten.  Weitergabe der gesammelten Erfahrungen und bevorzugten Praktiken an andere Produkte und deren Teams. <br><br>  Über verschiedene Änderungen an Werkzeugen und Prozessen im letzten Jahr werde ich berichten. <br><br><h2>  Vagrant → Docker-Compose </h2><br><h3>  Das Problem </h3><br>  Am ersten Arbeitstag habe ich versucht, die Bedienfelder vor Ort anzuheben.  Zu diesem Zeitpunkt befanden sich fünf Webanwendungen in einem Repository: <br><br>  - PU Virtual Hosting 3.0, <br>  - PU VDS 2.0, <br>  - PU-Webmaster, <br>  - PERSONAL (Werkzeughalter), <br>  - Richtlinien (Demo standardisierter Front-End-Komponenten). <br><br>  Zum Ausführen lokal verwendeter Vagrant.  Vagrant startete ansible.  Zum Starten und Konfigurieren wurde die Hilfe von Kollegen und etwa ein Tag sauberer Zeit benötigt.  Ich musste eine spezielle Version von Virtual Box installieren (es gab Probleme mit der aktuellen stabilen Version). Die Arbeit über die Konsole in der virtuellen Maschine war sehr nervig: Triviale Befehle wie die Installation von npm / composer wurden erheblich verlangsamt. <br><br>  Die Leistung der Anwendungen selbst in der virtuellen Maschine war angesichts des verwendeten Technologie-Stacks und der Leistung der Maschine bei weitem nicht möglich.  Ganz zu schweigen davon, dass eine virtuelle Maschine eine virtuelle Maschine ist und per Definition einen erheblichen Teil der Ressourcen Ihres PCs beansprucht. <br><br><h3>  Lösung </h3><br>  Die lokale Entwicklungsumgebung wurde neu geschrieben, um in Docker-Containern ausgeführt zu werden.  Die auf Docker basierende Containerisierung ist die häufigste Lösung zum Isolieren der Anwendungsumgebung in allen Phasen ihres Lebenszyklus.  Daher gibt es keine speziellen Alternativen. <br><br><h3>  Schlussfolgerungen </h3><br>  Von den Profis: <br><br>  - Lokal reagiert die Anwendung schneller, Container benötigen weniger als VMs. <br>  - Das Starten einer neuen Instanz dauert, wie die Praxis gezeigt hat, nur wenige Minuten und erfordert nur Docker (-compose), der nicht niedriger als bestimmte Versionen ist.  Führen Sie nach dem Klonen einfach Folgendes aus: <br><br><pre><code class="bash hljs">make install-dev make run-dev</code> </pre> <br>  Es gab einige Kompromisse: <br><br>  - Ich musste Shell-Bindungen für Docker-Befehle (Composer, npm usw.) schreiben.  Sie sind wie docker-compose.yml im Vergleich zu Vagrant nicht vollständig plattformübergreifend.  Das Starten unter Mac erfordert beispielsweise zusätzliche Anstrengungen, und unter Windows ist es wahrscheinlich einfacher, eine Distribution mit Docker in der virtuellen Linux-Maschine auszuführen.  Dies ist jedoch ein akzeptabler Kompromiss  Das Team verwendet nur Debian-basierte Distributionen. Dies ist eine akzeptable Einschränkung für die kommerzielle Entwicklung. <br>  - Zur Unterstützung virtueller Hosts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird</a> lokal ein Container gestartet, der auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github.com/jwilder/nginx-proxy basiert</a> .  Nicht dass es sich um eine Krücke handelt, sondern um zusätzliche Software, an die man sich manchmal erinnern muss, obwohl sie keine Probleme verursacht. <br><br>  Ja, jeder im Team musste zumindest ein wenig erkennen, was Docker ist.  Dank der erwähnten Shell-Skripte und Makefile führen Entwickler 95% ihrer Aufgaben aus, ohne an Container zu denken, sondern in einer garantiert identischen Umgebung. <br><br><h2>  newcp-dev → cp-steht </h2><br>  Diese seltsamen Ausdrücke sind die Namen von Maschinen mit Prüfständen für neue und alte Bedienfelder. <br><br><h3>  Das Problem </h3><br>  Ansible Rezepte wurden ausschließlich in Vagrant verwendet, sodass der Hauptvorteil nicht erreicht wurde: Die Versionen der Pakete im Produkt und auf den Ständen unterschieden sich von denen, an denen die Entwickler arbeiteten. <br><br>  Die Nichtübereinstimmung der Versionen der Server-Softwarepakete auf dem alten Stand mit dem, was die Entwickler hatten, führte zu Problemen.  Die Synchronisierung wurde durch die Tatsache erschwert, dass Systemadministratoren ein anderes Konfigurationsverwaltungssystem verwenden und es nicht möglich ist, es in das Entwickler-Repository zu integrieren. <br><br><h3>  Lösung </h3><br>  Nach der Containerisierung war es nicht schwierig, die Docker-Compose-Konfiguration für die Verwendung auf Prüfständen zu erweitern.  Es wurde eine neue Maschine erstellt, um Stände auf DOCKER_HOST bereitzustellen. <br><br><h3>  Schlussfolgerungen </h3><br>  Entwickler sind jetzt zuversichtlich, dass lokale Umgebungen und Testumgebungen relevant sind. <br><br><h2>  TeamCity → gitlab-ci </h2><br><h3>  Die Probleme </h3><br>  Die Projektkonfiguration in TeamCity ist ein mühsamer und undankbarer Prozess.  Die CI-Konfiguration wurde getrennt vom Code in XML gespeichert, für die keine normale Versionierung gilt, sowie eine Übersicht über die Änderungen.  Wir hatten auch Probleme mit der Stabilität des Erstellungsprozesses auf TeamCity-Agenten. <br><br><h3>  Lösung </h3><br>  Da gitlab bereits als Repository für Repositorys verwendet wurde, war die Verwendung des CI nicht nur logisch, sondern auch einfach und angenehm.  Jetzt befindet sich die gesamte CI / CD-Konfiguration direkt im Repository. <br><br><h3>  Ergebnis </h3><br>  Im Laufe des Jahres sind fast alle von TeamCity zusammengestellten Projekte sicher nach gitlab-ci umgezogen.  Wir hatten die Möglichkeit, schnell eine Vielzahl von Funktionen zur Automatisierung von CI / CD-Prozessen zu implementieren. <br>  Screenshots von Pipelines sind am offensichtlichsten: <br><br><img src="https://habrastorage.org/webt/st/v2/il/stv2ileqimz3apyuvtkowk2gad8.png" alt="Abb. 1. Feature-Branch: Alle verfügbaren automatischen Prüfungen und Tests sind enthalten. Wenn Sie fertig sind, wird ein Kommentar mit einem Link zur Pipeline an die Redmine-Aufgabe gesendet. Manuelle Aufgaben zum Zusammenbau und Starten eines Standes mit diesem Zweig."><br>  <i>Abb.</i>  <i>1. Feature-Branch: Alle verfügbaren automatischen Prüfungen und Tests sind enthalten.</i>  <i>Wenn Sie fertig sind, wird ein Kommentar mit einem Link zur Pipeline an die Redmine-Aufgabe gesendet.</i>  <i>Manuelle Aufgaben zum Zusammenbau und Starten eines Standes mit diesem Zweig.</i> <br><br><img src="https://habrastorage.org/webt/yz/tp/ud/yztpudorntvx4ffl3es47l5ihti.png" alt="Abb. 2. Geplante Erstellung mit Code Freeze entwickeln (Checkout: rc): Entwicklung nach Zeitplan mit Code Freeze. Die Montage der Bilder für die Stände der einzelnen Bedienfelder erfolgt parallel."><br>  <i>Abb.</i>  <i>2. Geplante Erstellung mit Code Freeze entwickeln (Checkout: rc): Entwicklung nach Zeitplan mit Code Freeze.</i>  <i>Die Montage der Bilder für die Stände der einzelnen Bedienfelder erfolgt parallel.</i> <br><br><img src="https://habrastorage.org/webt/d4/-t/wt/d4-twtogb-re2pl9gl0i6j4qzz8.png" alt="Abb. 3. Tag-Pipeline: Freigabe eines der Bedienfelder. Manuelle Aufgabe zur Rollback-Freigabe."><br>  <i>Abb.</i>  <i>3. Tag-Pipeline: Freigabe eines der Bedienfelder.</i>  <i>Manuelle Aufgabe zur Rollback-Freigabe.</i> <br><br>  Darüber hinaus gibt es ab gitlab-ci eine Statusänderung und die Ernennung einer Person in redmine in den Phasen In Bearbeitung → Überprüfung → Qualitätssicherung, Benachrichtigung in Slack über Freigaben und Aktualisierungen, Staging und Rollbacks. <br><br>  Dies ist praktisch, aber wir haben einen methodischen Punkt nicht berücksichtigt.  Nachdem eine solche Automatisierung in einem Projekt implementiert wurde, gewöhnen sich die Leute schnell daran.  Und wenn Sie zu einem anderen Projekt wechseln, bei dem dies noch nicht vorhanden ist oder der Prozess anders ist, können Sie vergessen, die Aufgabe in redmine zu verschieben und neu zuzuweisen, oder einen Kommentar mit einem Link zu Merge Request hinterlassen (was auch gitlab-ci tut), wodurch der Betrachter gezwungen wird, nach dem gewünschten zu suchen MR selbst.  Gleichzeitig möchten Sie die .gitlab-ci.yml-Teile und den zugehörigen Shell-Code zwischen den Projekten einfach nicht kopieren, da Sie das Kopieren und Einfügen unterstützen müssen. <br><br>  <b>Fazit:</b> Automatisierung ist gut, aber wenn sie auf der Ebene aller Teams und Projekte gleich ist - noch besser.  Ich wäre der angesehenen Öffentlichkeit für Ideen dankbar, wie die Wiederverwendung einer solchen Konfiguration schön organisiert werden kann. <br><br><h3>  Pipeline-Dauer: 80 min → 8 min </h3><br>  Allmählich nahm unser CI unanständig viel Zeit in Anspruch.  Die Tester litten stark darunter: Jeder Fix im Master musste eine Stunde auf eine Veröffentlichung warten.  Es sah so aus: <br><br><img src="https://habrastorage.org/webt/zg/pc/xf/zgpcxfwroial8l7dkg2gikodlms.png" alt="Abb. 4.Pipeline 80 lvl min Dauer."><br>  <i>Abb.</i>  <i>4.Pipeline 80 <s>lvl</s> min Dauer.</i> <br><br>  Ich musste mich mehrere Tage lang mit der Analyse langsamer Orte befassen und nach Möglichkeiten suchen, um zu beschleunigen und gleichzeitig die Funktionalität aufrechtzuerhalten. <br><br>  Die längsten Stellen im Prozess waren die Installation von npm-Paketen.  Ohne Probleme ersetzten sie es durch Garn und sparten an mehreren Stellen bis zu 7 Minuten. <br><br>  Sie lehnten automatische Staging-Updates ab und bevorzugten die manuelle Kontrolle des Status dieses Standes. <br><br>  Wir haben auch mehrere Läufer hinzugefügt und die Zusammenstellung von Anwendungsbildern und alle Überprüfungen in parallele Aufgaben unterteilt.  Nach diesen Optimierungen begann die Pipeline der Hauptniederlassung mit der Aktualisierung aller Stände in den meisten Fällen 7-8 Minuten zu dauern. <br><br><h2>  Capistrano → Bereitsteller </h2><br>  Für den Einsatz in der Produktion und auf dem Qa-Stand wurde Capistrano verwendet (und wird zum Zeitpunkt des Schreibens weiterhin verwendet).  Das Hauptszenario für dieses Tool ist: Klonen des Repositorys auf den Zielserver und Ausführen aller dortigen Aufgaben. <br><br>  Zuvor wurde die Bereitstellung von einem QS-Techniker mit den erforderlichen SSH-Schlüsseln von Vagrant ausgelöst.  Dann, als Vagrant aufgab, zog Capistrano in einen separaten Container.  Jetzt erfolgt die Bereitstellung aus dem Container mit Capistrano mit Gitlab-Läufern, die mit speziellen Tags gekennzeichnet sind und über die erforderlichen Schlüssel verfügen, automatisch, wenn die erforderlichen Tags angezeigt werden. <br><br>  Das Problem hierbei ist, dass der gesamte Erstellungsprozess: <br><br>  a) verbraucht erheblich die Ressourcen des Kampfservers (insbesondere Knoten / Schluck), <br>  b) Es gibt keine Möglichkeit, Composer- und Npm-Versionen auf dem neuesten Stand zu halten.  Knoten usw. <br><br>  Es ist logischer, auf einem Build-Server aufzubauen (in unserem Fall Gitlab-Runner) und fertige Artefakte auf den Zielserver hochzuladen.  Dadurch wird der Battle Server vor Assembly-Dienstprogrammen und ausländischer Verantwortung geschützt. <br><br>  Jetzt betrachten wir Deployer als Ersatz für Capistrano (da wir keine Rubisten haben und auch nicht den Wunsch haben, mit DSL zu arbeiten) und planen, die Baugruppe auf die Gitlab-Seite zu übertragen.  In einigen unkritischen Projekten haben wir es bereits versucht und sind bisher zufrieden: Es sieht einfacher aus, wir haben keine Einschränkungen festgestellt. <br><br><h2>  Gitflow: RC-Zweige → Tags </h2><br>  Die Entwicklung erfolgt in wöchentlichen Zyklen.  Innerhalb von fünf Tagen wird eine neue Version entwickelt: Die Entwicklung akzeptiert die Verbesserungen und Korrekturen, die für die Veröffentlichung nächste Woche geplant sind.  Am Freitagabend wird der Code automatisch eingefroren.  Am Montag beginnt der Test der neuen Version, es werden Verbesserungen vorgenommen und bis Mitte der Arbeitswoche erfolgt eine Veröffentlichung. <br><br>  Zuvor haben wir Zweige mit Namen der Form rc18-47 verwendet, was bedeutet, dass der Release-Kandidat die 47. Woche des Jahres 2018 ist.  Code Freeze sollte den RC-Zweig von der Entwicklung auschecken.  Aber im Oktober dieses Jahres haben wir auf Tags umgestellt.  Tags wurden vor, aber nach der Veröffentlichung und Fusion von rc mit master gesetzt.  Jetzt führt das Erscheinungsbild des Tags zu einer automatischen Bereitstellung, und das Einfrieren ist eine Verschmelzung der Entwicklung zum Master. <br><br>  Also haben wir zusätzliche Entitäten in Git und Variablen im Prozess entfernt. <br>  Jetzt ziehen wir Projekte, die im Prozess zurückbleiben, auf einen ähnlichen Workflow. <br><br><h2>  Fazit </h2><br>  Die Automatisierung von Prozessen, deren Optimierung sowie Entwicklung ist eine ständige Angelegenheit: Solange sich das Produkt aktiv entwickelt und das Team arbeitet, gibt es entsprechende Aufgaben.  Es erscheinen neue Ideen, wie Routinemaßnahmen beseitigt werden können: Funktionen sind in gitlab-ci implementiert. <br><br>  Wenn Anwendungen wachsen, dauern CI-Prozesse unannehmbar lange - es ist Zeit, an ihrer Leistung zu arbeiten.  Da Ansätze und Tools veraltet sind, müssen Sie sich Zeit nehmen, um sie umzugestalten, zu überprüfen und zu aktualisieren. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/7s/ep/wa/7sepwab6lc2aunuzcyjfcothxeu.png" alt="Bild"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de432150/">https://habr.com/ru/post/de432150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de432138/index.html">Lassen Sie uns über Metriken sprechen, um die Arbeit eines Programmierers zu bewerten</a></li>
<li><a href="../de432142/index.html">Bienenstocküberwachung und offenes Projekt</a></li>
<li><a href="../de432144/index.html">Wie wir für SAP-Filialen in Europa über 1C Kassen in Russland integriert haben</a></li>
<li><a href="../de432146/index.html">Zimbra Collaboration Suite als würdiger Ersatz für Microsoft Exchange</a></li>
<li><a href="../de432148/index.html">Merkmale beim Testen von Krediten: Wie sich ein Fehler auf Einnahmen in Höhe von Tausenden von Dollar auswirkt</a></li>
<li><a href="../de432152/index.html">Schlussfolgerungen zur Zukunft des Einzelhandels nach dem Black Friday</a></li>
<li><a href="../de432154/index.html">Bedingter Zugriff als Zugriffskontrollmechanismus</a></li>
<li><a href="../de432156/index.html">Neues 2GIS - Verbindung zu öffentlichen Tests herstellen</a></li>
<li><a href="../de432158/index.html">Verwenden von JIRA und Confluence in einem großen Projekt</a></li>
<li><a href="../de432160/index.html">Video von Android Kolesa Mobile: Über modulare Entwicklung, Backend-gesteuerte Benutzeroberfläche und kontinuierliche Integration</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>