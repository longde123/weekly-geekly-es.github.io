<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∞Ô∏è üêß üññüèø Conectamos mapas on-line ao navegador no smartphone. Parte 2 - cart√µes de vetor üèáüèΩ üíú üöç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Estamos escrevendo um aplicativo de servidor que ir√° gerar blocos de varredura PNG com base em mapas vetoriais online. Use a raspagem da Web com o Pup...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conectamos mapas on-line ao navegador no smartphone. Parte 2 - cart√µes de vetor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461053/"><p>  Estamos escrevendo um aplicativo de servidor que ir√° gerar blocos de varredura PNG com base em mapas vetoriais online.  Use a raspagem da Web com o Puppeteer para obter dados do mapa. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Conte√∫do: </h3><br><p> 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdu√ß√£o.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de varredura padr√£o</a> <br>  2 - Continua√ß√£o.  Escrevendo um rasterizador simples para mapas vetoriais <br>  3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um caso especial.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conectamos o cart√£o OverpassTurbo</a> </p><br><h3 id="prodolzhenie">  Continua√ß√£o </h3><br><p>  E assim chegamos ao t√≥pico mais interessante.  Imagine que encontramos um site com um mapa que realmente queremos adicionar ao nosso navegador.  Fazemos tudo de acordo com as instru√ß√µes da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte anterior</a> .  Abrimos a visualiza√ß√£o do conte√∫do do site, e n√£o h√° fotos!  Absolutamente.  Bem, alguns √≠cones e √© isso.  E algum outro arquivo de texto com uma lista de coordenadas. </p><br><p>  Parab√©ns, encontramos um mapa vetorial.  Grosso modo, √© renderizado em tempo real pelo seu navegador.  Ent√£o ela n√£o precisa de nenhum ladrilho preparado.  Por um lado, n√£o existem tantos mapas vetoriais at√© o momento.  Mas essa tecnologia √© muito promissora e, com o tempo, elas podem se tornar muitas vezes mais.  Bem, n√≥s descobrimos.  E, no entanto, o que fazemos agora? </p><br><p>  Primeiro, voc√™ pode tentar baixar um navegador de uma vers√£o muito, muito antiga.  Um que n√£o suporta as fun√ß√µes necess√°rias para renderizar o mapa.  √â poss√≠vel que voc√™ mostre uma vers√£o diferente do site.  Com mapa raster.  Bem, o que voc√™ precisa fazer com isso voc√™ j√° sabe. </p><br><p>  No entanto, se esse truque n√£o funcionou, mas voc√™ ainda deseja obter esse cart√£o e, al√©m disso, n√£o no navegador do smartphone, ou seja, no navegador, existe uma maneira. </p><br><h3 id="osnovnaya-ideya">  Ideia principal </h3><br><p>  Vamos prosseguir com o fato de que queremos obter um mapa que possa ser aberto em qualquer um dos navegadores.  Ent√£o precisamos de um adaptador - um tipo de intermedi√°rio que ir√° gerar blocos para n√≥s no formato PNG. </p><br><p>  Acontece que voc√™ precisa <del>  inventar uma bicicleta </del>  desenvolva outro mecanismo para visualizar dados vetoriais.  Bem, ou voc√™ pode escrever um script que ir√° para o site, permitindo que ele desenhe seu pr√≥prio mapa vetorial por conta pr√≥pria.  E ent√£o ele aguardar√° o download, far√° uma captura de tela, recortar√° e retornar√° ao usu√°rio.  Talvez eu escolha a segunda op√ß√£o. </p><br><p>  Para tirar screenshots, usarei um "navegador de controle remoto" - Chrome sem cabe√ßa.  Voc√™ pode control√°-lo usando a biblioteca js do n√≥ <strong>Puppeteer</strong> .  Voc√™ pode aprender sobre o b√°sico sobre como trabalhar com esta biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> . </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Ol√° Mundo!  Ou crie e personalize um projeto </h3><br><p>  Se voc√™ ainda n√£o instalou o Node.js., v√° para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">esta</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">esta</a> p√°gina, selecione seu sistema operacional e execute a instala√ß√£o de acordo com as instru√ß√µes. </p><br><p>  Crie uma nova pasta para o projeto e abra-a no terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  Iniciamos o gerente de cria√ß√£o de um novo projeto </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Aqui voc√™ pode especificar o nome do projeto ( <strong>nome do pacote</strong> ), o nome do arquivo para inserir o aplicativo ( <strong>ponto de entrada</strong> ) e o nome do autor ( <strong>autor</strong> ).  Para todas as outras solicita√ß√µes, concordamos com os par√¢metros padr√£o: n√£o inserimos nada e apenas pressione <strong>Enter</strong> .  No final - pressione <strong>y</strong> e <strong>Enter</strong> . </p><br><p>  Em seguida, instale as estruturas necess√°rias para o trabalho.  Express para criar um servidor e Puppeteer para trabalhar com um navegador. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  Como resultado, o arquivo de configura√ß√£o do projeto <strong>package.json</strong> aparece na pasta do projeto.  No meu caso, isso: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  Vou adicionar a linha de partida √† se√ß√£o de scripts para iniciar nosso aplicativo de maneira mais conveniente. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Agora crie dois arquivos com a implementa√ß√£o da funcionalidade b√°sica.  O primeiro arquivo √© o ponto de entrada para o aplicativo.  No meu caso, <strong>router.js</strong> .  Ele criar√° um servidor e far√° o roteamento. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Agora crie um segundo arquivo.  Ele controlar√° o navegador e far√° capturas de tela.  Eu tenho o nome <strong>mapshoter.js</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Execute nosso script e verifique seu desempenho.  Para fazer isso, digite o console: </p><br><p> <code>$ npm start</code> </p> <br><p>  Uma mensagem aparece dizendo "Servidor criado na porta 5000".  Agora abra um navegador no seu computador e v√° para o endere√ßo local do nosso servidor.  Em vez das coordenadas <strong>x, y, z,</strong> voc√™ pode inserir qualquer n√∫mero.  Eu digitei 1, 2, 3. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  Se tudo for feito corretamente, uma captura de tela do site do Google ser√° exibida. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="imagem"></p><br><p>  Pressione Ctrl + C no console para interromper nosso script. </p><br><p>  Parab√©ns, a base da nossa aplica√ß√£o est√° pronta!  Criamos um servidor que aceita nossas solicita√ß√µes de html, tira uma captura de tela e retorna uma imagem para n√≥s.  Agora √© hora de avan√ßar para a implementa√ß√£o dos detalhes. </p><br><h3 id="rasschitaem-koordinaty">  Calcular as coordenadas </h3><br><p>  A id√©ia √© que o navegador abra um site com um mapa e insira as coordenadas do local que precisamos na barra de pesquisa.  Depois de clicar no bot√£o "Localizar", este local estar√° exatamente no centro da tela.  Portanto, ser√° f√°cil cortar a √°rea que precisamos. </p><br><p>  Mas primeiro, voc√™ precisa calcular as coordenadas do centro do bloco com base no n√∫mero de s√©rie.  Farei isso com base na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">f√≥rmula</a> para encontrar o canto superior esquerdo.  Eu coloquei na fun√ß√£o <strong>getCoordinates ()</strong> . </p><br><p>  E, como em alguns sites, al√©m do centro do bloco, voc√™ tamb√©m precisa especificar suas bordas, procurarei por eles tamb√©m.  Bem, vamos criar um m√≥dulo separado para esses c√°lculos sob o nome <strong>geoTools.js</strong> .  Aqui est√° o c√≥digo dele: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Agora estamos prontos para come√ßar a implementar o script para trabalhar com o navegador.  Vejamos alguns cen√°rios de como isso pode ser feito. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Cen√°rio 1 - Pesquisa API </h3><br><p>  Vamos come√ßar com o caso mais simples, quando voc√™ pode simplesmente inserir as coordenadas no URL da p√°gina do mapa.  Por exemplo, assim: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Vamos dar uma olhada no script.  Apenas substitua, exclua todo o conte√∫do do arquivo <strong>mapshoter.js</strong> e cole o c√≥digo abaixo. </p><br><p>  Nesta vers√£o, ao iniciar o navegador, especificamos par√¢metros adicionais que permitir√£o iniciar e funcionar em servidores Linux, como o Heroku.  Agora tamb√©m reduziremos o tamanho da janela para que o menor n√∫mero poss√≠vel de blocos de mapas caiba na tela.  Assim, aumentamos a velocidade de carregamento da p√°gina. </p><br><p>  Em seguida, calculamos as coordenadas do centro do bloco desejado.  N√≥s os colamos no URL e clicamos nele.  O bloco aparece exatamente no centro da tela.  Corte um peda√ßo de 256x256 pixels.  Este ser√° o bloco que precisamos.  Resta apenas devolv√™-lo ao usu√°rio. </p><br><p>  Antes de passar para o c√≥digo, observe que, para maior clareza, todo o tratamento de erros foi removido do script. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //   URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Agora execute nosso script e veja o mapa para esta se√ß√£o. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  Se tudo for feito corretamente, o servidor retornar√° esse bloco: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  Para garantir que n√£o misturemos nada durante o corte, compare nosso bloco com o original do OpenStreetMaps.org </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa-sayta">  Cen√°rio 2 - Pesquisa usando a interface do site </h3><br><p>  No entanto, nem sempre √© poss√≠vel controlar um cart√£o atrav√©s de uma linha do navegador.  Bem, nesses casos, nosso script se comportar√° como um usu√°rio real.  Ele imprimir√° as coordenadas na caixa de pesquisa e clique no bot√£o Pesquisar.  Depois disso, ele remover√° o marcador do ponto encontrado, que geralmente aparece no centro da tela.  E ent√£o ele clicar√° nos bot√µes para aumentar ou diminuir a escala at√© atingir o desejado.  Em seguida, ele far√° uma captura de tela e retornar√° ao usu√°rio. </p><br><p>  Observo que geralmente ap√≥s a pesquisa a mesma escala √© definida.  15, por exemplo.  No nosso exemplo, isso nem sempre acontece.  Portanto, reconheceremos o n√≠vel de zoom a partir dos par√¢metros dos elementos html na p√°gina. </p><br><p>  Tamb√©m neste exemplo, procuraremos elementos da interface usando os seletores XPath.  Mas como voc√™ os reconhece? </p><br><p>  Para fazer isso, abra a p√°gina necess√°ria no navegador e abra a barra de ferramentas do desenvolvedor ( <strong>Ctll + Alt + I</strong> para Google Chrome).  Pressione o bot√£o para selecionar itens.  Clicamos no elemento de seu interesse (cliquei no campo de pesquisa). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  A lista de itens rola at√© a que voc√™ clicou e √© destacada em azul.  Clique no bot√£o com tr√™s pontos √† esquerda do nome. </p><br><p>  No menu pop-up, selecione Copiar.  Em seguida, se voc√™ precisar de um seletor regular, clique em <strong>Copiar seletor</strong> .  Mas, para o mesmo exemplo, usaremos o item <strong>Copiar XPath</strong> . </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Agora substitua o conte√∫do do arquivo <strong>mapshoter.js</strong> por este c√≥digo.  Nele, j√° colecionei seletores para todos os elementos de interface necess√°rios. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[1]/div[1]/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonXPath = '//*[@id="gtm-poi-card-get-directions"]' const deletePinButonXPatch = '//*[@id="map"]/div[1]/div/div/div[1]/div[2]/div/div[4]/div/div[4]' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await click( directionButonXPath, page ) await page.waitFor( 100 ) await click( deletePinButonXPatch, page ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Execute nosso script e siga o link.  Se tudo for feito corretamente, o script retornar√° para n√≥s algo como esse bloco. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Otimiza√ß√£o </h3><br><p>  Em princ√≠pio, os dois m√©todos descritos acima s√£o suficientes para conectar-se a muitos sites com mapas vetoriais.  Por√©m, se voc√™ precisar acessar repentinamente algum novo mapa, precisar√° modificar levemente o script no arquivo mapshoter.js.  Ou seja, esse m√©todo facilita a adi√ß√£o de novos cart√µes.  Isso √© de suas vantagens. </p><br><p>  Mas tamb√©m h√° desvantagens.  E o principal √© a velocidade do trabalho.  Basta comparar.  Em m√©dia, leva cerca de 0,5 segundos para baixar um bloco raster comum.  O recebimento de um bloco de nosso script no momento leva cerca de 8 segundos. </p><br><p>  Mas isso n√£o √© tudo!  Usamos o n√≥ single-threaded js e nossas solicita√ß√µes longas acabam bloqueando o thread principal, que do lado de fora parecer√° com uma fila s√≠ncrona regular.  E quando tentamos fazer o download do mapa para a tela inteira (na qual, por exemplo, 24 blocos s√£o colocados), ou seja, existe o risco de encontrar um problema. </p><br><p>  E mais uma coisa.  Alguns navegadores t√™m um tempo limite: eles param de carregar ap√≥s 30 segundos.  E isso significa que, com a implementa√ß√£o atual, apenas 3-4 blocos ter√£o tempo para carregar.  Bem, vamos ver o que podemos fazer sobre isso. </p><br><p>  Provavelmente, a maneira mais √≥bvia √© simplesmente aumentar o n√∫mero de servidores nos quais nosso script ser√° executado.  Por exemplo, se tivermos 10 servidores, eles ter√£o tempo para processar os blocos da tela inteira em 30 segundos.  (Se voc√™ n√£o quiser pagar muito dinheiro, poder√° obt√™-lo registrando v√°rias contas gratuitas no Heroku) </p><br><p>  Em segundo lugar, ainda √© poss√≠vel implementar multithreading no n√≥ js usando o m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">worker_threads</a> .  De acordo com minhas observa√ß√µes, em um servidor com um processador de n√∫cleo √∫nico em uma conta gratuita Heroku, eu consigo iniciar tr√™s threads.  Tr√™s fluxos com um navegador separado em cada um, que pode funcionar simultaneamente sem bloquear um ao outro.  Para ser sincero, observo que, como resultado do aumento da carga no processador, a velocidade de download de um bloco aumentou um pouco.  No entanto, se voc√™ tentar fazer o download de um mapa para a tela inteira, depois de 30 segundos, mais da metade do mapa ter√° tempo para carregar.  Mais de 12 pe√ßas.  J√° est√° melhor. </p><br><p>  Terceiro.  Na implementa√ß√£o atual do script, com cada solicita√ß√£o, gastamos tempo fazendo o download do navegador Chrome e, em seguida, concluindo-o.  Agora, criaremos um navegador com anteced√™ncia e transferiremos um link para ele no mapshoter.js.  Como resultado, a velocidade n√£o ser√° alterada para a primeira solicita√ß√£o.  Mas, para toda a velocidade de download subsequente de um bloco, √© reduzida para 4 segundos.  E depois de 30 segundos, todo o mapa tem tempo para carregar - todos os 24 blocos que s√£o colocados na minha tela. </p><br><p>  Bem, se voc√™ implementar tudo isso, o script poder√° se tornar bastante vi√°vel.  Ent√£o, vamos come√ßar.  Para um trabalho mais simples com multithreading, usarei o m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">node-worker-threads-pool</a> - um tipo de wrapper sobre worker_threads.  Vamos instal√°-lo. </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Corrija o arquivo router.js.  Adicione a ele a cria√ß√£o de um pool de threads.  As linhas ser√£o 3 partes.  Seu c√≥digo ser√° descrito no arquivo <strong>worker.js</strong> , veremos mais adiante.  Enquanto isso, exclua o lan√ßamento do m√≥dulo de captura de tela diretamente.  Em vez disso, adicionaremos uma nova tarefa ao pool de threads.  Eles come√ßar√£o a process√°-lo quando qualquer um dos threads for liberado. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Agora, d√™ uma olhada no arquivo <strong>worker.js</strong> .  Cada vez que uma nova tarefa <strong>chega, o</strong> m√©todo <strong>parentPort.on ()</strong> √© iniciado.  Infelizmente, ele n√£o pode lidar com fun√ß√µes ass√≠ncronas / aguardadas.  Portanto, usaremos a fun√ß√£o do adaptador na forma do m√©todo <strong>doMyAsyncCode ()</strong> . </p><br><p>  Nele, em um formato leg√≠vel conveniente, colocaremos a l√≥gica do trabalhador.  Ou seja, inicie o navegador (se ainda n√£o estiver em execu√ß√£o) e ative o m√©todo para tirar uma captura de tela.  Na inicializa√ß√£o, passaremos para esse m√©todo um link para o navegador em execu√ß√£o. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  Para maior clareza, voltemos √† primeira vers√£o do <strong>mapshoter.js</strong> .  N√£o vai mudar muito.  Agora, nos par√¢metros de entrada, ele aceitar√° um link para o navegador e, quando o script terminar, n√£o desligar√° o navegador, mas simplesmente fechar√° a guia criada. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Em princ√≠pio, √© tudo.  Agora voc√™ pode enviar o resultado para o servidor de qualquer maneira conveniente para voc√™.  Por exemplo, atrav√©s da janela de encaixe.  Se voc√™ quiser ver o resultado final, pode clicar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">neste link</a> .  Voc√™ tamb√©m pode encontrar o c√≥digo completo do projeto no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">GitHub</a> . </p><br><h3 id="zaklyuchenie">  Conclus√£o </h3><br><p>  Agora vamos avaliar o resultado.  Por um lado, apesar de todos os truques, a velocidade do download ainda √© muito baixa.  Al√©m disso, por causa dos freios, esse cart√£o √© simplesmente desagrad√°vel de rolar. </p><br><p>  Por outro lado, esse script lida com cart√µes que antes eram geralmente imposs√≠veis de conectar ao navegador no smartphone.  √â improv√°vel que essa solu√ß√£o seja aplicada como o principal m√©todo de obten√ß√£o de dados cartogr√°ficos.  Mas aqui como um adicional, com a ajuda do qual, se necess√°rio, ser√° poss√≠vel abrir um cart√£o ex√≥tico - √© bem poss√≠vel. </p><br><p>  Al√©m disso, as vantagens desse script incluem o fato de ser f√°cil trabalhar com ele.  √â f√°cil escrever.  E, o mais importante, pode ser refeito com extrema facilidade para conectar qualquer outro cart√£o online. </p><br><p>  Bem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no pr√≥ximo artigo</a> , tratarei exatamente disso.  Transformarei o script em um tipo de API para trabalhar com o mapa interativo OverpassTurbo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461053/">https://habr.com/ru/post/pt461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461043/index.html">Gerenciamento de conflitos em um ato de equil√≠brio de equipe ou uma necessidade vital?</a></li>
<li><a href="../pt461045/index.html">Obtenha uma extra√ß√£o do Rosreestr atrav√©s do FSIS USRN e python. Parte 1</a></li>
<li><a href="../pt461047/index.html">Escrever ou n√£o escrever. Cartas √†s autoridades durante os eventos</a></li>
<li><a href="../pt461049/index.html">ONYX BOOX Faust - Quem procura n√£o √© obrigado a passear</a></li>
<li><a href="../pt461051/index.html">Os 10 erros mais comuns que encontrei nos projetos Go</a></li>
<li><a href="../pt461055/index.html">Rekko Challenge 2019: como foi</a></li>
<li><a href="../pt461057/index.html">Canais de telegrama sobre desenvolvimento de jogos</a></li>
<li><a href="../pt461059/index.html">Escrevendo um aplicativo Android para f√£s de filmes - Parte 1 (prototipagem)</a></li>
<li><a href="../pt461061/index.html">Ligas de magn√©sio, limites duplos e segrega√ß√£o</a></li>
<li><a href="../pt461063/index.html">Intera√ß√£o de R com bancos de dados no exemplo do Microsoft SQL Server e outros DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>