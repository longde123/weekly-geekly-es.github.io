<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕰️ 🐧 🖖🏿 Conectamos mapas on-line ao navegador no smartphone. Parte 2 - cartões de vetor 🏇🏽 💜 🚍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Estamos escrevendo um aplicativo de servidor que irá gerar blocos de varredura PNG com base em mapas vetoriais online. Use a raspagem da Web com o Pup...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conectamos mapas on-line ao navegador no smartphone. Parte 2 - cartões de vetor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461053/"><p>  Estamos escrevendo um aplicativo de servidor que irá gerar blocos de varredura PNG com base em mapas vetoriais online.  Use a raspagem da Web com o Puppeteer para obter dados do mapa. </p><a name="habracut"></a><br><h3 id="soderzhanie">  Conteúdo: </h3><br><p> 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Introdução.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mapas de varredura padrão</a> <br>  2 - Continuação.  Escrevendo um rasterizador simples para mapas vetoriais <br>  3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um caso especial.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conectamos o cartão OverpassTurbo</a> </p><br><h3 id="prodolzhenie">  Continuação </h3><br><p>  E assim chegamos ao tópico mais interessante.  Imagine que encontramos um site com um mapa que realmente queremos adicionar ao nosso navegador.  Fazemos tudo de acordo com as instruções da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte anterior</a> .  Abrimos a visualização do conteúdo do site, e não há fotos!  Absolutamente.  Bem, alguns ícones e é isso.  E algum outro arquivo de texto com uma lista de coordenadas. </p><br><p>  Parabéns, encontramos um mapa vetorial.  Grosso modo, é renderizado em tempo real pelo seu navegador.  Então ela não precisa de nenhum ladrilho preparado.  Por um lado, não existem tantos mapas vetoriais até o momento.  Mas essa tecnologia é muito promissora e, com o tempo, elas podem se tornar muitas vezes mais.  Bem, nós descobrimos.  E, no entanto, o que fazemos agora? </p><br><p>  Primeiro, você pode tentar baixar um navegador de uma versão muito, muito antiga.  Um que não suporta as funções necessárias para renderizar o mapa.  É possível que você mostre uma versão diferente do site.  Com mapa raster.  Bem, o que você precisa fazer com isso você já sabe. </p><br><p>  No entanto, se esse truque não funcionou, mas você ainda deseja obter esse cartão e, além disso, não no navegador do smartphone, ou seja, no navegador, existe uma maneira. </p><br><h3 id="osnovnaya-ideya">  Ideia principal </h3><br><p>  Vamos prosseguir com o fato de que queremos obter um mapa que possa ser aberto em qualquer um dos navegadores.  Então precisamos de um adaptador - um tipo de intermediário que irá gerar blocos para nós no formato PNG. </p><br><p>  Acontece que você precisa <del>  inventar uma bicicleta </del>  desenvolva outro mecanismo para visualizar dados vetoriais.  Bem, ou você pode escrever um script que irá para o site, permitindo que ele desenhe seu próprio mapa vetorial por conta própria.  E então ele aguardará o download, fará uma captura de tela, recortará e retornará ao usuário.  Talvez eu escolha a segunda opção. </p><br><p>  Para tirar screenshots, usarei um "navegador de controle remoto" - Chrome sem cabeça.  Você pode controlá-lo usando a biblioteca js do nó <strong>Puppeteer</strong> .  Você pode aprender sobre o básico sobre como trabalhar com esta biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> . </p><br><h3 id="hello-world-ili-sozdaem-i-nastraivaem-proekt">  Olá Mundo!  Ou crie e personalize um projeto </h3><br><p>  Se você ainda não instalou o Node.js., vá para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">esta</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">esta</a> página, selecione seu sistema operacional e execute a instalação de acordo com as instruções. </p><br><p>  Crie uma nova pasta para o projeto e abra-a no terminal. </p><br><pre><code class="plaintext hljs">$ cd /Mapshoter_habr</code> </pre> <br><p>  Iniciamos o gerente de criação de um novo projeto </p><br><pre> <code class="plaintext hljs">$ npm init</code> </pre> <br><p>  Aqui você pode especificar o nome do projeto ( <strong>nome do pacote</strong> ), o nome do arquivo para inserir o aplicativo ( <strong>ponto de entrada</strong> ) e o nome do autor ( <strong>autor</strong> ).  Para todas as outras solicitações, concordamos com os parâmetros padrão: não inserimos nada e apenas pressione <strong>Enter</strong> .  No final - pressione <strong>y</strong> e <strong>Enter</strong> . </p><br><p>  Em seguida, instale as estruturas necessárias para o trabalho.  Express para criar um servidor e Puppeteer para trabalhar com um navegador. </p><br><pre> <code class="plaintext hljs">$ npm install express $ npm i puppeteer</code> </pre> <br><p>  Como resultado, o arquivo de configuração do projeto <strong>package.json</strong> aparece na pasta do projeto.  No meu caso, isso: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapshoter_habr"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"main"</span></span>: <span class="hljs-string"><span class="hljs-string">"router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"nnngrach"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ISC"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"dependencies"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"express"</span></span>: <span class="hljs-string"><span class="hljs-string">"^4.17.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"puppeteer"</span></span>: <span class="hljs-string"><span class="hljs-string">"^1.18.1"</span></span> } }</code> </pre> <br><p>  Vou adicionar a linha de partida à seção de scripts para iniciar nosso aplicativo de maneira mais conveniente. </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"start"</span></span>: <span class="hljs-string"><span class="hljs-string">"node router.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"test"</span></span>: <span class="hljs-string"><span class="hljs-string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span> },</code> </pre> <br><p>  Agora crie dois arquivos com a implementação da funcionalidade básica.  O primeiro arquivo é o ponto de entrada para o aplicativo.  No meu caso, <strong>router.js</strong> .  Ele criará um servidor e fará o roteamento. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        const express = require( 'express' ) const mapshoter = require( './mapshoter' ) //  ,       const PORT = process.env.PORT || 5000 //     const app = express() app.listen( PORT, () =&gt; { console.log( '    ', PORT ) }) //       // http://siteName.com/x/y/z app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { //      const x = req.params.x const y = req.params.y const z = req.params.z //      const screenshot = await mapshoter.makeTile( x, y, z ) //        const imageBuffer = Buffer.from( screenshot, 'base64' ) //    res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) //    res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Agora crie um segundo arquivo.  Ele controlará o navegador e fará capturas de tela.  Eu tenho o nome <strong>mapshoter.js</strong> . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   const browser = await puppeteer.launch() //       const page = await browser.newPage() await page.goto( 'https://www.google.ru/' ) //    const screenshot = await page.screenshot() //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Execute nosso script e verifique seu desempenho.  Para fazer isso, digite o console: </p><br><p> <code>$ npm start</code> </p> <br><p>  Uma mensagem aparece dizendo "Servidor criado na porta 5000".  Agora abra um navegador no seu computador e vá para o endereço local do nosso servidor.  Em vez das coordenadas <strong>x, y, z,</strong> você pode inserir qualquer número.  Eu digitei 1, 2, 3. </p><br><p> <code>http://localhost:5000/1/2/3</code> </p> <br><p>  Se tudo for feito corretamente, uma captura de tela do site do Google será exibida. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/66a/8db/ca5/66a8dbca5b15566f395ec6bf4163279c.png" alt="imagem"></p><br><p>  Pressione Ctrl + C no console para interromper nosso script. </p><br><p>  Parabéns, a base da nossa aplicação está pronta!  Criamos um servidor que aceita nossas solicitações de html, tira uma captura de tela e retorna uma imagem para nós.  Agora é hora de avançar para a implementação dos detalhes. </p><br><h3 id="rasschitaem-koordinaty">  Calcular as coordenadas </h3><br><p>  A idéia é que o navegador abra um site com um mapa e insira as coordenadas do local que precisamos na barra de pesquisa.  Depois de clicar no botão "Localizar", este local estará exatamente no centro da tela.  Portanto, será fácil cortar a área que precisamos. </p><br><p>  Mas primeiro, você precisa calcular as coordenadas do centro do bloco com base no número de série.  Farei isso com base na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">fórmula</a> para encontrar o canto superior esquerdo.  Eu coloquei na função <strong>getCoordinates ()</strong> . </p><br><p>  E, como em alguns sites, além do centro do bloco, você também precisa especificar suas bordas, procurarei por eles também.  Bem, vamos criar um módulo separado para esses cálculos sob o nome <strong>geoTools.js</strong> .  Aqui está o código dele: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   -   function getCoordinates( x, y, z ) { const n = Math.pow( 2, z ) const lon = x / n * 360.0 - 180.0 const lat = 180.0 * ( Math.atan( Math.sinh( Math.PI * ( 1 - 2 * y / n) ) ) ) / Math.PI return { lat: lat, lon: lon } } //          function getCenter( left, rigth, top, bottom ) { let lat = ( left + rigth ) / 2 let lon = ( top + bottom ) / 2 return { lat: lat, lon: lon } } //        function getAllCoordinates( stringX, stringY, stringZ ) { //      const x = Number( stringX ) const y = Number( stringY ) const z = Number( stringZ ) //     //    -  -  const topLeft = getCoordinates( x, y, z ) const bottomRight = getCoordinates( x+1, y+1, z ) //   const center = getCenter( topLeft.lat, bottomRight.lat, topLeft.lon, bottomRight.lon ) //   const bBox = { latMin: bottomRight.lat, lonMin: topLeft.lon, latMax: topLeft.lat, lonMax: bottomRight.lon } return { bBox: bBox, center: center } } module.exports.getAllCoordinates = getAllCoordinates</span></span></code> </pre> <br><p>  Agora estamos prontos para começar a implementar o script para trabalhar com o navegador.  Vejamos alguns cenários de como isso pode ser feito. </p><br><h3 id="scenariy-1--poisk-s-pomoschyu-api">  Cenário 1 - Pesquisa API </h3><br><p>  Vamos começar com o caso mais simples, quando você pode simplesmente inserir as coordenadas no URL da página do mapa.  Por exemplo, assim: </p><br><p> <code>https://nakarte.me/#m=5/50.28144/89.30666&amp;l=O/Wp</code> </p> <br><p>  Vamos dar uma olhada no script.  Apenas substitua, exclua todo o conteúdo do arquivo <strong>mapshoter.js</strong> e cole o código abaixo. </p><br><p>  Nesta versão, ao iniciar o navegador, especificamos parâmetros adicionais que permitirão iniciar e funcionar em servidores Linux, como o Heroku.  Agora também reduziremos o tamanho da janela para que o menor número possível de blocos de mapas caiba na tela.  Assim, aumentamos a velocidade de carregamento da página. </p><br><p>  Em seguida, calculamos as coordenadas do centro do bloco desejado.  Nós os colamos no URL e clicamos nele.  O bloco aparece exatamente no centro da tela.  Corte um pedaço de 256x256 pixels.  Este será o bloco que precisamos.  Resta apenas devolvê-lo ao usuário. </p><br><p>  Antes de passar para o código, observe que, para maior clareza, todo o tratamento de erros foi removido do script. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,    Heroku const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) //        //       const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) //         URL const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" //   URL  ,    await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) //    const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //      await browser.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Agora execute nosso script e veja o mapa para esta seção. </p><br><p> <code>http://localhost:5000/24/10/5</code> </p> <br><p>  Se tudo for feito corretamente, o servidor retornará esse bloco: </p><br><p><img src="https://habrastorage.org/webt/gg/t5/gr/ggt5grzq5iuw26bjt2zdhckeoic.png"></p><br><p>  Para garantir que não misturemos nada durante o corte, compare nosso bloco com o original do OpenStreetMaps.org </p><br><p><img src="https://habrastorage.org/webt/32/kp/fs/32kpfsblzjzrx3c16ap3gjpfgx4.png"></p><br><h3 id="scenariy-2--poisk-s-pomoschyu-interfeysa-sayta">  Cenário 2 - Pesquisa usando a interface do site </h3><br><p>  No entanto, nem sempre é possível controlar um cartão através de uma linha do navegador.  Bem, nesses casos, nosso script se comportará como um usuário real.  Ele imprimirá as coordenadas na caixa de pesquisa e clique no botão Pesquisar.  Depois disso, ele removerá o marcador do ponto encontrado, que geralmente aparece no centro da tela.  E então ele clicará nos botões para aumentar ou diminuir a escala até atingir o desejado.  Em seguida, ele fará uma captura de tela e retornará ao usuário. </p><br><p>  Observo que geralmente após a pesquisa a mesma escala é definida.  15, por exemplo.  No nosso exemplo, isso nem sempre acontece.  Portanto, reconheceremos o nível de zoom a partir dos parâmetros dos elementos html na página. </p><br><p>  Também neste exemplo, procuraremos elementos da interface usando os seletores XPath.  Mas como você os reconhece? </p><br><p>  Para fazer isso, abra a página necessária no navegador e abra a barra de ferramentas do desenvolvedor ( <strong>Ctll + Alt + I</strong> para Google Chrome).  Pressione o botão para selecionar itens.  Clicamos no elemento de seu interesse (cliquei no campo de pesquisa). </p><br><p><img src="https://habrastorage.org/webt/rb/wu/37/rbwu37fuodlucpg4q_xqfsfk-my.png"></p><br><p>  A lista de itens rola até a que você clicou e é destacada em azul.  Clique no botão com três pontos à esquerda do nome. </p><br><p>  No menu pop-up, selecione Copiar.  Em seguida, se você precisar de um seletor regular, clique em <strong>Copiar seletor</strong> .  Mas, para o mesmo exemplo, usaremos o item <strong>Copiar XPath</strong> . </p><br><p><img src="https://habrastorage.org/webt/p9/wo/t-/p9wot-lbr6ho7ttgvmsb9yrfica.png"></p><br><p>  Agora substitua o conteúdo do arquivo <strong>mapshoter.js</strong> por este código.  Nele, já colecionei seletores para todos os elementos de interface necessários. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const searchFieldXPath = '//*[@id="map"]/div[1]/div[1]/div/input' const zoomPlusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[1]' const zoomMinusXPath = '//*[@id="map"]/div[2]/div[2]/div[4]/div[1]/a[2]' const directionButonXPath = '//*[@id="gtm-poi-card-get-directions"]' const deletePinButonXPatch = '//*[@id="map"]/div[1]/div/div/div[1]/div[2]/div/div[4]/div/div[4]' //         () const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `lat=${coordinates.center.lat} lng=${coordinates.center.lon}` //      const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} const browser = await puppeteer.launch( herokuDeploymentParams ) const page = await browser.newPage() await page.setViewport( { width: 1100, height: 450 } ) //         const pageUrl = 'https://www.waze.com/en/livemap?utm_campaign=waze_website' await page.goto( pageUrl, { waitUntil: 'networkidle2', timeout: 10000 } ) //    ,      await click( searchFieldXPath, page ) //        await page.keyboard.type( centerCoordinates ) //  Enter    page.keyboard.press( 'Enter' ); //  500     await page.waitFor( 500 ) //       //       await click( directionButonXPath, page ) await page.waitFor( 100 ) await click( deletePinButonXPatch, page ) await page.waitFor( 100 ) //       //        while( z &gt; await fetchCurrentZoom( page )) { await click( zoomPlusXPath, page ) await page.waitFor( 300 ) } while( z &lt; await fetchCurrentZoom( page )) { await click( zoomMinusXPath, page ) await page.waitFor( 300 ) } //    const cropOptions = { fullPage: false, clip: { x: 422, y: 97, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   await browser.close() return screenshot } //  : //        async function click( xPathSelector, page ) { await page.waitForXPath( xPathSelector ) const foundedElements = await page.$x( xPathSelector ) if ( foundedElements.length &gt; 0 ) { await foundedElements[0].click() } else { throw new Error( "XPath element not found: ", xPathSelector ) } } //         html  async function fetchCurrentZoom( page ) { const xPathSelector = '//*[@id="map"]/div[2]' await page.waitForXPath( xPathSelector ) const elems = await page.$x(xPathSelector) const elementParams = await page.evaluate((...elems) =&gt; { return elems.map(e =&gt; e.className); }, ...elems); const zoom = elementParams[0].split('--zoom-').pop() return zoom } module.exports.makeTile = makeTile</span></span></code> </pre> <br><p>  Execute nosso script e siga o link.  Se tudo for feito corretamente, o script retornará para nós algo como esse bloco. </p><br><p> <code>http://localhost:5000/1237/640/11</code> </p> <br><p><img src="https://habrastorage.org/webt/3c/oo/0l/3coo0lmxp12svhu_m16vecfbjsw.png"></p><br><h3 id="optimizaciya">  Otimização </h3><br><p>  Em princípio, os dois métodos descritos acima são suficientes para conectar-se a muitos sites com mapas vetoriais.  Porém, se você precisar acessar repentinamente algum novo mapa, precisará modificar levemente o script no arquivo mapshoter.js.  Ou seja, esse método facilita a adição de novos cartões.  Isso é de suas vantagens. </p><br><p>  Mas também há desvantagens.  E o principal é a velocidade do trabalho.  Basta comparar.  Em média, leva cerca de 0,5 segundos para baixar um bloco raster comum.  O recebimento de um bloco de nosso script no momento leva cerca de 8 segundos. </p><br><p>  Mas isso não é tudo!  Usamos o nó single-threaded js e nossas solicitações longas acabam bloqueando o thread principal, que do lado de fora parecerá com uma fila síncrona regular.  E quando tentamos fazer o download do mapa para a tela inteira (na qual, por exemplo, 24 blocos são colocados), ou seja, existe o risco de encontrar um problema. </p><br><p>  E mais uma coisa.  Alguns navegadores têm um tempo limite: eles param de carregar após 30 segundos.  E isso significa que, com a implementação atual, apenas 3-4 blocos terão tempo para carregar.  Bem, vamos ver o que podemos fazer sobre isso. </p><br><p>  Provavelmente, a maneira mais óbvia é simplesmente aumentar o número de servidores nos quais nosso script será executado.  Por exemplo, se tivermos 10 servidores, eles terão tempo para processar os blocos da tela inteira em 30 segundos.  (Se você não quiser pagar muito dinheiro, poderá obtê-lo registrando várias contas gratuitas no Heroku) </p><br><p>  Em segundo lugar, ainda é possível implementar multithreading no nó js usando o módulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">worker_threads</a> .  De acordo com minhas observações, em um servidor com um processador de núcleo único em uma conta gratuita Heroku, eu consigo iniciar três threads.  Três fluxos com um navegador separado em cada um, que pode funcionar simultaneamente sem bloquear um ao outro.  Para ser sincero, observo que, como resultado do aumento da carga no processador, a velocidade de download de um bloco aumentou um pouco.  No entanto, se você tentar fazer o download de um mapa para a tela inteira, depois de 30 segundos, mais da metade do mapa terá tempo para carregar.  Mais de 12 peças.  Já está melhor. </p><br><p>  Terceiro.  Na implementação atual do script, com cada solicitação, gastamos tempo fazendo o download do navegador Chrome e, em seguida, concluindo-o.  Agora, criaremos um navegador com antecedência e transferiremos um link para ele no mapshoter.js.  Como resultado, a velocidade não será alterada para a primeira solicitação.  Mas, para toda a velocidade de download subsequente de um bloco, é reduzida para 4 segundos.  E depois de 30 segundos, todo o mapa tem tempo para carregar - todos os 24 blocos que são colocados na minha tela. </p><br><p>  Bem, se você implementar tudo isso, o script poderá se tornar bastante viável.  Então, vamos começar.  Para um trabalho mais simples com multithreading, usarei o módulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">node-worker-threads-pool</a> - um tipo de wrapper sobre worker_threads.  Vamos instalá-lo. </p><br><p> <code>$ npm install node-worker-threads-pool --save</code> </p> <br><p>  Corrija o arquivo router.js.  Adicione a ele a criação de um pool de threads.  As linhas serão 3 partes.  Seu código será descrito no arquivo <strong>worker.js</strong> , veremos mais adiante.  Enquanto isso, exclua o lançamento do módulo de captura de tela diretamente.  Em vez disso, adicionaremos uma nova tarefa ao pool de threads.  Eles começarão a processá-lo quando qualquer um dos threads for liberado. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'express'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PORT = process.env.PORT || <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express() app.listen( PORT, () =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-string"><span class="hljs-string">'    '</span></span>, PORT ) }) <span class="hljs-comment"><span class="hljs-comment">//   . const { StaticPool } = require( 'node-worker-threads-pool' ) const worker = "./worker.js" const workersPool = new StaticPool({ size: 3, task: worker, workerData: "no" }) app.get( '/:x/:y/:z', async ( req, res, next ) =&gt; { const x = req.params.x const y = req.params.y const z = req.params.z //       //       const screenshot = await workersPool.exec( { x, y, z } ) const imageBuffer = Buffer.from( screenshot, 'base64' ) res.writeHead( 200, { 'Content-Type': 'image/png', 'Content-Length': imageBuffer.length }) res.end( imageBuffer ) })</span></span></code> </pre> <br><p>  Agora, dê uma olhada no arquivo <strong>worker.js</strong> .  Cada vez que uma nova tarefa <strong>chega, o</strong> método <strong>parentPort.on ()</strong> é iniciado.  Infelizmente, ele não pode lidar com funções assíncronas / aguardadas.  Portanto, usaremos a função do adaptador na forma do método <strong>doMyAsyncCode ()</strong> . </p><br><p>  Nele, em um formato legível conveniente, colocaremos a lógica do trabalhador.  Ou seja, inicie o navegador (se ainda não estiver em execução) e ative o método para tirar uma captura de tela.  Na inicialização, passaremos para esse método um link para o navegador em execução. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { parentPort, workerData } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mapshoter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./mapshoter'</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//     var browser = "empty" //         //    ,     parentPort.on( "message", ( params ) =&gt; { doMyAsyncCode( params ) .then( ( result) =&gt; { parentPort.postMessage( result ) }) }) //  ,    async/aswit //     async function doMyAsyncCode( params ) { //      await prepareEnviroment() //     const screenshot = await mapshoter.makeTile( params.x, params.y, params.z, browser ) return screenshot } //  .     ,    async function prepareEnviroment( ) { if ( browser === "empty" ) { const herokuDeploymentParams = {'args' : ['--no-sandbox', '--disable-setuid-sandbox']} browser = await puppeteer.launch( herokuDeploymentParams ) } }</span></span></code> </pre> <br><p>  Para maior clareza, voltemos à primeira versão do <strong>mapshoter.js</strong> .  Não vai mudar muito.  Agora, nos parâmetros de entrada, ele aceitará um link para o navegador e, quando o script terminar, não desligará o navegador, mas simplesmente fechará a guia criada. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> puppeteer = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'puppeteer'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> geoTools = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>( <span class="hljs-string"><span class="hljs-string">'./geoTools'</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> x, y, z, browserLink </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      const browser = await browserLink //      const page = await browser.newPage() await page.setViewport( { width: 660, height: 400 } ) const coordinates = geoTools.getAllCoordinates( x, y, z ) const centerCoordinates = `${z}/${coordinates.center.lat}/${coordinates.center.lon}&amp;l=` const pageUrl = 'https://nakarte.me/#m=' + centerCoordinates + "O/Wp" await page.goto( pageUrl, { waitUntil: 'networkidle0', timeout: 20000 } ) const cropOptions = { fullPage: false, clip: { x: 202, y: 67, width: 256, height: 256 } } const screenshot = await page.screenshot( cropOptions ) //   .   . await page.close() return screenshot } module.exports.makeTile = makeTile</span></span></code> </pre><br><p>  Em princípio, é tudo.  Agora você pode enviar o resultado para o servidor de qualquer maneira conveniente para você.  Por exemplo, através da janela de encaixe.  Se você quiser ver o resultado final, pode clicar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">neste link</a> .  Você também pode encontrar o código completo do projeto no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">GitHub</a> . </p><br><h3 id="zaklyuchenie">  Conclusão </h3><br><p>  Agora vamos avaliar o resultado.  Por um lado, apesar de todos os truques, a velocidade do download ainda é muito baixa.  Além disso, por causa dos freios, esse cartão é simplesmente desagradável de rolar. </p><br><p>  Por outro lado, esse script lida com cartões que antes eram geralmente impossíveis de conectar ao navegador no smartphone.  É improvável que essa solução seja aplicada como o principal método de obtenção de dados cartográficos.  Mas aqui como um adicional, com a ajuda do qual, se necessário, será possível abrir um cartão exótico - é bem possível. </p><br><p>  Além disso, as vantagens desse script incluem o fato de ser fácil trabalhar com ele.  É fácil escrever.  E, o mais importante, pode ser refeito com extrema facilidade para conectar qualquer outro cartão online. </p><br><p>  Bem, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no próximo artigo</a> , tratarei exatamente disso.  Transformarei o script em um tipo de API para trabalhar com o mapa interativo OverpassTurbo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461053/">https://habr.com/ru/post/pt461053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461043/index.html">Gerenciamento de conflitos em um ato de equilíbrio de equipe ou uma necessidade vital?</a></li>
<li><a href="../pt461045/index.html">Obtenha uma extração do Rosreestr através do FSIS USRN e python. Parte 1</a></li>
<li><a href="../pt461047/index.html">Escrever ou não escrever. Cartas às autoridades durante os eventos</a></li>
<li><a href="../pt461049/index.html">ONYX BOOX Faust - Quem procura não é obrigado a passear</a></li>
<li><a href="../pt461051/index.html">Os 10 erros mais comuns que encontrei nos projetos Go</a></li>
<li><a href="../pt461055/index.html">Rekko Challenge 2019: como foi</a></li>
<li><a href="../pt461057/index.html">Canais de telegrama sobre desenvolvimento de jogos</a></li>
<li><a href="../pt461059/index.html">Escrevendo um aplicativo Android para fãs de filmes - Parte 1 (prototipagem)</a></li>
<li><a href="../pt461061/index.html">Ligas de magnésio, limites duplos e segregação</a></li>
<li><a href="../pt461063/index.html">Interação de R com bancos de dados no exemplo do Microsoft SQL Server e outros DBMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>