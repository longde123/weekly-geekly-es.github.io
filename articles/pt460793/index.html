<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🌾 🥀 🥣 Estruturando aplicações de reação 👩🏿‍🤝‍👨🏻 🥓 👱</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O material, cuja tradução publicamos hoje, revela as abordagens usadas por seu autor na estruturação de aplicativos React. Em particular, discutiremos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estruturando aplicações de reação</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/460793/">  O material, cuja tradução publicamos hoje, revela as abordagens usadas por seu autor na estruturação de aplicativos React.  Em particular, discutiremos aqui a estrutura de pastas usada, o nome das entidades, os locais onde os arquivos de teste estão localizados e outras coisas semelhantes. <br><br>  Um dos recursos mais agradáveis ​​do React é que essa biblioteca não força o desenvolvedor a cumprir rigorosamente certas convenções relacionadas à estrutura do projeto.  Muito disso permanece a critério do programador.  Essa abordagem é diferente da, digamos, adotada nas estruturas Ember.js ou Angular.  Eles oferecem aos desenvolvedores mais recursos padrão.  Essas estruturas fornecem convenções sobre a estrutura de projetos e regras para nomear arquivos e componentes. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/k6/9y/ug/k69yugvbt27p3wtccvzeqrf_v4w.jpeg"></a> <br><br>  Pessoalmente, gosto da abordagem adotada pelo React.  O fato é que eu prefiro controlar algo sozinho, sem depender de certos "acordos".  No entanto, existem muitas vantagens na abordagem de estruturação de projetos que a Angular oferece.  A escolha entre liberdade e regras mais ou menos rígidas se resume ao que está mais perto de você e de sua equipe. <br><br>  Ao longo dos anos de trabalho com o React, tentei várias maneiras diferentes de estruturar aplicativos.  Algumas das idéias que apliquei foram mais bem-sucedidas do que outras.  Portanto, aqui vou falar sobre tudo que se mostrou bem na prática.  Espero que você encontre aqui algo que seja útil para você. <br><a name="habracut"></a><br>  Não estou tentando mostrar aqui uma maneira "apenas correta" de estruturar aplicativos.  Você pode pegar algumas das minhas idéias e alterá-las para atender às suas necessidades.  Você pode discordar de mim continuando a trabalhar como antes.  Equipes diferentes criam aplicativos diferentes e usam meios diferentes para atingir seus objetivos. <br><br>  É importante observar que, se você olhar para o site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Thread</a> , do qual participo no desenvolvimento, e para o dispositivo de sua interface, encontrará lugares em que essas regras sobre as quais falarei não são respeitadas.  O fato é que quaisquer "regras" na programação devem ser tomadas apenas como recomendações e não como padrões abrangentes válidos em qualquer situação.  E se você acha que algum tipo de “regra” não combina com você, você, com o objetivo de melhorar a qualidade do que está trabalhando, deve encontrar forças para se desviar dessas “regras”. <br><br>  Na verdade, agora, sem mais delongas, ofereço minha história sobre a estruturação de aplicativos React. <br><br><h2>  <font color="#3AC1EF">Não se preocupe muito com as regras.</font> </h2><br>  Talvez você decida que a recomendação de que você não se preocupa muito com as regras parece estranha no início de nossa conversa.  Mas é exatamente isso que quero dizer quando digo que o principal erro que os programadores têm em termos de observação das regras é que os programadores atribuem muita importância às regras.  Isto é especialmente verdade no início do trabalho em um novo projeto.  No momento da criação do primeiro <code>index.jsx</code> simplesmente impossível saber o que é melhor para este projeto.  À medida que o projeto se desenvolve, você naturalmente encontrará algum tipo de estrutura de arquivos e pastas, o que provavelmente será muito bom para esse projeto.  Se, durante a continuação do trabalho, a estrutura existente não for bem-sucedida, ela poderá ser melhorada. <br><br>  Se você ler isso e se achar pensando que não há nada em seu aplicativo que esteja sendo discutido, isso não será um problema.  Cada aplicativo é único, não há duas equipes de desenvolvimento absolutamente idênticas.  Portanto, cada equipe, trabalhando em um projeto, chega a alguns acordos em relação à sua estrutura e métodos de trabalho.  Isso ajuda os membros da equipe a trabalhar produtivamente.  Não se esforce para, depois de aprender como alguém está fazendo algo, apresente isso imediatamente.  Não tente introduzir em seu trabalho o que é chamado em certos materiais e, mesmo assim, a "maneira mais eficaz" de resolver um problema.  Sempre adotei e adotei a estratégia a seguir em relação a essas recomendações.  Eu tenho meu próprio conjunto de regras, mas lendo sobre como os outros agem em determinadas situações, escolho o que me parece bem-sucedido e adequado para mim.  Isso leva ao fato de que, com o tempo, meus métodos de trabalho melhoram.  Ao mesmo tempo, não tenho choques e não há desejo de reescrever tudo do zero. <br><br><h2>  <font color="#3AC1EF">Componentes importantes estão localizados em pastas separadas</font> </h2><br>  A abordagem para colocar arquivos de componentes nas pastas em que cheguei é que os componentes que podem ser considerados "importantes", "básicos", "principais" no contexto do aplicativo são colocados em pastas separadas.  Essas pastas, por sua vez, estão localizadas na pasta de <code>components</code> .  Por exemplo, se estamos falando de um aplicativo para uma loja de eletrônicos, o componente <code>&lt;Product&gt;</code> usado para descrever o produto pode ser reconhecido como um componente semelhante.  Aqui está o que eu quero dizer: <br><br><pre> <code class="plaintext hljs">- src/  - components/    - product/      - product.jsx      - product-price.jsx    - navigation/      - navigation.jsx    - checkout-flow/      - checkout-flow.jsx</code> </pre> <br>  Nesse caso, os componentes "secundários" usados ​​apenas por determinados componentes "principais" estão localizados na mesma pasta que esses componentes "principais".  Essa abordagem se provou na prática.  O fato é que, devido à sua aplicação, uma certa estrutura aparece no projeto, mas o nível de aninhamento de pastas não é muito grande.  Sua aplicação não leva à aparência de algo como <code>../../../</code> nos comandos de importação de componentes, não dificulta a movimentação pelo projeto.  Essa abordagem permite criar uma hierarquia clara de componentes.  Esse componente, cujo nome corresponde ao nome da pasta, é considerado "básico".  Outros componentes localizados na mesma pasta servem para dividir o componente "base" em partes, o que simplifica o trabalho com o código desse componente e seu suporte. <br><br>  Embora eu seja um defensor da presença de uma certa estrutura de pastas no projeto, acredito que o mais importante é a seleção de bons nomes de arquivos.  As próprias pastas são menos importantes. <br><br><h2>  <font color="#3AC1EF">Usando subpastas para subcomponentes</font> </h2><br>  Uma das desvantagens da abordagem acima é que seu uso pode levar ao aparecimento de pastas de componentes "básicos" que contêm muitos arquivos.  Considere, por exemplo, o componente <code>&lt;Product&gt;</code> .  Arquivos CSS serão anexados a ele (falaremos sobre eles mais adiante), arquivos de teste, muitos subcomponentes e, possivelmente, outros recursos - como imagens e ícones SVG.  Esta lista de "adições" não é limitada.  Tudo isso cairá na mesma pasta que o componente "base". <br><br>  Eu realmente não me importo com isso.  Isso serve para mim se os arquivos tiverem nomes bem pensados ​​e se puderem ser encontrados com facilidade (usando as ferramentas de busca de arquivos no editor).  Nesse caso, a estrutura da pasta desaparece em segundo plano.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está um</a> tweet sobre este tópico. <br><br>  No entanto, se você preferir que seu projeto tenha uma estrutura mais extensa, não há nada difícil em mover subcomponentes para suas próprias pastas: <br><br><pre> <code class="javascript hljs">- src/  - components/    - product/      - product.jsx      - ...      - product-price/        - product-price.jsx</code> </pre> <br><h2>  <font color="#3AC1EF">Os arquivos de teste estão localizados no mesmo local que os arquivos dos componentes sob teste.</font> </h2><br>  Começamos esta seção com uma recomendação simples, que é a de que os arquivos de teste devem ser colocados no mesmo local que os arquivos com o código que foram verificados com a ajuda deles.  Também falarei sobre como prefiro estruturar os componentes, tentando garantir que eles fiquem próximos um do outro.  Mas agora posso dizer que acho conveniente colocar os arquivos de teste nas mesmas pastas que os arquivos de componentes.  Nesse caso, os nomes dos arquivos com os testes são idênticos aos nomes dos arquivos com o código.  <code>.test</code> nomes dos testes, antes da extensão do nome do arquivo, o sufixo <code>.test</code> adicionado apenas: <br><br><ul><li>  Nome do arquivo do componente: <code>auth.js</code> </li><li>  Nome do arquivo de teste: <code>auth.test.js</code> </li></ul><br>  Essa abordagem tem vários pontos fortes: <br><br><ul><li>  Isso facilita a localização de arquivos de teste.  À primeira vista, você pode entender se há um teste para o componente com o qual estou trabalhando. </li><li>  Todos os comandos de importação necessários são muito simples.  No teste, para importar o código testado, você não precisa criar estruturas que descrevam, por exemplo, a saída da pasta <code>__tests__</code> .  Essas equipes parecem extremamente simples.  Por exemplo, assim: <code>import Auth from './auth'</code> . </li></ul><br>  Se tivermos alguns dados usados ​​durante o teste, por exemplo, algo como zombarias de solicitações de API, os colocaremos na mesma pasta em que o componente e seu teste já estão.  Quando tudo o que é necessário está em uma pasta, isso contribui para o crescimento da produtividade.  Por exemplo, se você usar uma estrutura de pastas ramificadas e o programador tiver certeza de que existe um determinado arquivo, mas não conseguir lembrar o nome, o programador precisará procurar esse arquivo em vários subdiretórios.  Com a abordagem proposta, basta olhar para o conteúdo de uma pasta e tudo ficará claro. <br><br><h2>  <font color="#3AC1EF">Módulos CSS</font> </h2><br>  Eu sou um grande fã de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">módulos CSS</a> .  Descobrimos que eles são ótimos para criar regras modulares de CSS para componentes. <br><br>  Além disso, gosto muito da tecnologia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">componentes</a> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estilo</a> .  No entanto, no decorrer do trabalho em projetos nos quais muitos desenvolvedores participaram, verificou-se que a presença de arquivos CSS reais no projeto aumenta a usabilidade. <br><br>  Como você provavelmente já adivinhou, nossos arquivos CSS estão localizados, como outros arquivos, ao lado dos arquivos componentes, nas mesmas pastas.  Isso simplifica bastante o movimento entre arquivos quando você precisa entender rapidamente o significado de uma classe. <br><br>  Uma recomendação mais geral, cuja essência permeia todo esse material, é que todo o código relacionado a um determinado componente seja mantido na mesma pasta em que esse componente está localizado.  Longe vão os dias em que pastas separadas foram usadas para armazenar código CSS e JS, código de teste e outros recursos.  O uso de estruturas complexas de pastas complica o movimento entre arquivos e não tem nenhum benefício óbvio, exceto pelo fato de ajudar a "organizar o código".  Mantenha os arquivos interconectados na mesma pasta - isso significa gastar menos tempo movendo-se entre as pastas durante o trabalho. <br><br>  Até criamos um carregador Webpack para CSS, cujos recursos correspondem aos recursos de nosso trabalho.  Ele verifica os nomes de classe declarados e gera um erro no console se nos referirmos a uma classe que não existe. <br><br><h2>  <font color="#3AC1EF">Quase sempre, apenas um código de componente é colocado em um arquivo</font> </h2><br>  Minha experiência mostra que os programadores geralmente aderem estritamente à regra de que o código para um e apenas um componente React deve estar em um arquivo.  Ao mesmo tempo, apoio totalmente a idéia de que não vale a pena colocar muitos componentes em um arquivo (imagine as dificuldades de nomear esses arquivos!).  Mas acredito que não há nada errado em colocar o código de um determinado componente "grande" e o código do componente "pequeno" associado a ele no mesmo arquivo.  Se esse movimento ajudar a preservar a pureza do código, se o componente "pequeno" não for muito grande para colocá-lo em um arquivo separado, isso não prejudicará ninguém. <br><br>  Por exemplo, se eu criar um componente <code>&lt;Product&gt;</code> e precisar de um pequeno pedaço de código para exibir o preço, posso fazer isso: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Price = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ price, currency }</span></span></span><span class="hljs-function">) =&gt;</span></span> (  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">    {currency}    {formatPrice(price)}  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Product = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> {  <span class="hljs-comment"><span class="hljs-comment">// ,      !  return (    &lt;div&gt;      &lt;Price price={props.price} currency={props.currency} /&gt;      &lt;div&gt;loads more stuff...&lt;/div&gt;    &lt;/div&gt;  ) }</span></span></code> </pre> <br>  A coisa boa dessa abordagem é que eu não precisei criar um arquivo separado para o componente <code>&lt;Price&gt;</code> e que esse componente esteja disponível exclusivamente para o componente <code>&lt;Product&gt;</code> .  Como não exportamos esse componente, ele não pode ser importado para outro local do aplicativo.  Isso significa que, quando perguntado se deve colocar <code>&lt;Price&gt;</code> em um arquivo separado, você pode dar uma resposta clara e positiva se precisar importá-lo para outro lugar.  Caso contrário, você pode fazer isso sem colocar o código <code>&lt;Price&gt;</code> em um arquivo separado. <br><br><h2>  <font color="#3AC1EF">Pastas separadas para componentes universais</font> </h2><br>  Recentemente, usamos componentes universais.  Eles, de fato, formam nosso sistema de design (que planejamos publicar um dia), mas até agora começamos pequenos - com componentes como <code>&lt;Button&gt;</code> e <code>&lt;Logo&gt;</code> .  Um componente é considerado "universal" se não estiver vinculado a uma parte específica do site, mas é um dos elementos básicos da interface do usuário. <br><br>  Componentes semelhantes estão localizados em sua própria pasta ( <code>src/components/generic</code> ).  Isso simplifica bastante o trabalho com todos os componentes universais.  Eles estão em um só lugar - é muito conveniente.  Com o tempo, à medida que o projeto cresce, planejamos desenvolver um guia de estilo (somos grandes fãs do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">react-styleguidist</a> ) para simplificar ainda mais o trabalho com componentes universais. <br><br><h2>  <font color="#3AC1EF">Usando aliases para importar entidades</font> </h2><br>  A estrutura de pastas relativamente plana em nossos projetos garante que os comandos de importação não tenham estruturas muito longas como <code>../../</code> .  Mas é difícil ficar sem eles.  Portanto, usamos o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">babel-plugin-module-resolvedor</a> para configurar aliases que simplificam os comandos de importação. <br><br>  Você pode fazer o mesmo com o Webpack, mas, graças ao plug-in Babel, os mesmos comandos de importação podem funcionar em testes. <br><br>  Configuramos isso com um par de aliases: <br><br><pre> <code class="javascript hljs">{  <span class="hljs-attr"><span class="hljs-attr">components</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components'</span></span>,  <span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>, }</code> </pre> <br>  O primeiro é extremamente simples.  Permite importar qualquer componente, iniciando o comando com a palavra <code>components</code> .  Na abordagem normal, os comandos de importação são mais ou menos assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../components/product/product'</span></span></code> </pre> <br>  Em vez disso, podemos escrevê-los assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Product <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'components/product/product'</span></span></code> </pre> <br>  Ambos os comandos importam o mesmo arquivo.  Isso é muito conveniente, pois permite que você não pense na estrutura da pasta. <br><br>  O segundo alias é um pouco mais complicado: <br><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">'^generic/([\\w_]+)'</span></span>: <span class="hljs-string"><span class="hljs-string">'./src/components/generic/\\1/\\1'</span></span>,</code> </pre> <br>  Nós usamos regex aqui.  Ele encontra comandos de importação que começam com <code>generic</code> (o sinal <code>^</code> no início da expressão permite selecionar apenas os comandos que começam com <code>generic</code> ) e captura o que é depois de <code>generic/</code> no grupo.  Depois disso, usamos o fragmento capturado ( <code>\\1</code> ) na construção <code>./src/components/generic/\\1/\\1</code> . <br><br>  Como resultado, podemos usar os comandos de importação para componentes universais desse tipo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'generic/button'</span></span></code> </pre> <br>  Eles são convertidos para os seguintes comandos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'src/components/generic/button/button'</span></span></code> </pre> <br>  Este comando, por exemplo, serve para importar um arquivo JSX que descreve um botão universal.  Fizemos tudo isso porque essa abordagem simplifica bastante a importação de componentes universais.  Além disso, será útil se decidirmos alterar a estrutura dos arquivos do projeto (isso, conforme nosso sistema de design está crescendo, é bem possível). <br><br>  Aqui, gostaria de observar que você deve ter cuidado ao trabalhar com pseudônimos.  Se você tiver apenas alguns deles, e eles foram projetados para resolver problemas de importação padrão, tudo está bem.  Mas se você tiver muitos deles, eles podem trazer mais confusão do que benefícios. <br><br><h2>  <font color="#3AC1EF">Pasta lib universal para utilitários</font> </h2><br>  Gostaria de recuperar todo o tempo que gastei tentando encontrar o lugar perfeito para o código que não é o componente.  Compartilhei tudo isso de acordo com princípios diferentes, destacando o código de utilitários, serviços e funções auxiliares.  Tudo isso tem tantos nomes que eu não vou mencionar todos eles.  Agora não estou tentando descobrir a diferença entre o "utilitário" e a "função auxiliar" para encontrar o lugar certo para um determinado arquivo.  Agora eu uso uma abordagem muito mais simples e compreensível: tudo isso cai em uma única pasta <code>lib</code> . <br><br>  A longo prazo, o tamanho dessa pasta pode ser tão grande que você precisará estruturá-la de alguma forma, mas isso é completamente normal.  É sempre mais fácil equipar algo com uma certa estrutura do que se livrar de erros de estrutura excessiva. <br><br>  No nosso projeto Thread, a pasta <code>lib</code> contém cerca de 100 arquivos.  Eles são divididos aproximadamente igualmente em arquivos que contêm a implementação de certos recursos e em arquivos de teste.  Não causou nenhuma dificuldade em encontrar os arquivos necessários.  Graças aos <code>lib/name_of_thing</code> pesquisa inteligentes incorporados à maioria dos editores, quase sempre preciso digitar algo como <code>lib/name_of_thing</code> , e o que eu preciso é encontrado. <br><br>  Além disso, temos um alias que simplifica a importação da pasta <code>lib</code> , permitindo que você use comandos desse tipo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> formatPrice <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lib/format_price'</span></span></code> </pre> <br>  Não se assuste com as estruturas de pastas simples que podem causar o armazenamento de vários arquivos em uma pasta.  Normalmente, essa estrutura é tudo o que é necessário para um determinado projeto. <br><br><h2>  <font color="#3AC1EF">Ocultando bibliotecas de terceiros por trás de APIs nativas</font> </h2><br>  Eu realmente gosto do sistema de monitoramento de bugs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sentry</a> .  Eu costumava usá-lo no desenvolvimento de partes de aplicativos para servidor e cliente.  Com sua ajuda, você pode capturar exceções e receber notificações sobre sua ocorrência.  Essa é uma ótima ferramenta que nos permite acompanhar os problemas encontrados no site. <br><br>  Sempre que uso uma biblioteca de terceiros em meu projeto, penso em como fazê-lo para que, se necessário, possa ser substituído o mais facilmente possível por outra coisa.  Freqüentemente, como no mesmo sistema Sentry de que realmente gostamos, isso não é necessário.  Mas, apenas no caso, nunca é demais pensar em uma maneira de evitar o uso de um determinado serviço ou em uma maneira de alterá-lo para outra coisa. <br><br>  A melhor solução para esse problema é desenvolver sua própria API que oculte as ferramentas de outras pessoas.  Isso é como criar um módulo <code>lib/error-reporting.js</code> que exporta a função <code>reportError()</code> .  O núcleo deste módulo usa o Sentry.  Mas o Sentry é importado diretamente apenas neste módulo e em nenhum outro lugar.  Isso significa que substituir o Sentry por outra ferramenta parecerá muito simples.  Para fazer isso, basta alterar um arquivo em um só lugar.  Enquanto a API pública desse arquivo permanecer inalterada, o restante do projeto nem saberá que, ao chamar <code>reportError()</code> , não é o Sentry que é usado, mas outra coisa. <br><br>  Observe que a API pública do módulo é chamada de funções que ele exporta e seus argumentos.  Eles também são chamados de interface pública do módulo. <br><br><h2>  <font color="#3AC1EF">Usando PropTypes (ou ferramentas como TypeScript ou Flow)</font> </h2><br>  Quando faço programação, penso em três versões de mim mesmo: <br><br><ul><li>  Jack do passado e o código que ele escreveu (às vezes código duvidoso). </li><li>  Jack de hoje e o código que ele escreve agora. </li><li>  Jack do futuro.  Quando penso nesse futuro, pergunto a mim mesmo o presente sobre como escrever código que facilitará minha vida no futuro. </li></ul><br>  Pode parecer estranho, mas achei útil, pensando em como escrever código, faça a seguinte pergunta: "Como será percebido em seis meses?". <br><br>  Uma maneira simples de se apresentar e ser mais produtivo é especificar os tipos de propriedades ( <code>PropTypes</code> ) usadas pelos componentes.  Isso economizará tempo procurando possíveis erros de digitação.  Isso o protegerá de situações nas quais, usando o componente, são aplicadas propriedades dos tipos errados ou elas esquecem completamente a transferência de propriedades.  No nosso caso, a <a href="">regra eslint-react / prop-types</a> é um bom lembrete da necessidade de usar <code>PropTypes</code> . <br><br>  Se você for ainda mais longe, é recomendável descrever as propriedades com a maior precisão possível.  Por exemplo, você pode fazer isso: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.object.isRequired</code> </pre> <br>  Mas seria muito melhor fazer isso: <br><br><pre> <code class="javascript hljs">blogPost: PropTypes.shape({  <span class="hljs-attr"><span class="hljs-attr">id</span></span>: PropTypes.number.isRequired,  <span class="hljs-attr"><span class="hljs-attr">title</span></span>: PropTypes.string.isRequired,  <span class="hljs-comment"><span class="hljs-comment">//    }).isRequired</span></span></code> </pre> <br>  No primeiro exemplo, a verificação mínima necessária é executada.  No segundo, o desenvolvedor recebe informações muito mais úteis.  Eles serão muito úteis, por exemplo, se alguém se esquecer de um determinado campo usado no objeto. <br><br><h2>  <font color="#3AC1EF">Bibliotecas de terceiros são usadas apenas quando são realmente necessárias.</font> </h2><br>  Essa dica é mais relevante do que nunca com o advento dos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ganchos React</a> .  Por exemplo, eu participei de uma grande alteração de uma das partes do site Thread e decidi prestar atenção especial ao uso de bibliotecas de terceiros.  ,       ,          .   (   ),  .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,      React-.      —  ,    ,   React  API Context,        . <br><br> ,  ,  Redux,    .       ,      (            ,     ). ,           ,   ,           . <br><br><h2> <font color="#3AC1EF">   </font> </h2><br>   —   ,       ,   .      . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     emitter.send('user_add_to_cart') //     emitter.on('user_add_to_cart', () =&gt; {  //  -  })</span></span></code> </pre> <br>      ,            .     ,             .      ,   «   ».   ,      ,   ,    .         . «»      - ,       .  ,    ,        . <br><br>      Redux.       .     ,  .  ,     ,  <code>user_add_to_cart</code> ,   .       .  , ,       Redux,      .     ,    Redux    ,     . <br><br>  ,       ,   ,  ,     : <br><br><ul><li>  ,   , .         . </li><li>  ,  ,   .       ,    . </li><li>  ,  -  , . ,     ,    . </li></ul><br>    - ,    .    ,        ,   .      ,        ,   ,           «» . <br><br>       ,       ,  API Context  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-</a> . <br><br><h2> <font color="#3AC1EF">     </font> </h2><br>         ,    (, ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ).     :    ,      . <br><br> ,    ,          ,     .        : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mount(  <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=&gt;</span></span></span><span class="xml">    </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ComponentUnderTest</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">  </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">UserAuth.Provider</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> )</span></span></code> </pre> <br>      : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wrapper = mountWithAuth(ComponentUnderTest, {  <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Jack'</span></span>,  <span class="hljs-attr"><span class="hljs-attr">userId</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, })</code> </pre> <br>       : <br><br><ul><li>     .       —     ,     ,   ,      . </li><li>      —    <code>mountWithAuth</code>       .    ,          . </li></ul><br>   ,           <code>test-utils.js</code> . ,       —   .       . <br><br><h2>  <font color="#3AC1EF">Sumário</font> </h2><br>       .     ,     , ,  ,      .         ,  ,              .        ,   :       .               .           -     ,   . <br><br>  <b>Caros leitores!</b>     React-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt460793/">https://habr.com/ru/post/pt460793/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt460777/index.html">Esta é a vez: por que a Apple mudou os requisitos para desenvolvedores de aplicativos</a></li>
<li><a href="../pt460779/index.html">Depuração avançada</a></li>
<li><a href="../pt460783/index.html">Consenso sobre a reputação do nó. É necessário?</a></li>
<li><a href="../pt460785/index.html">Aplicativos para e-books no sistema operacional Android. Parte 1. Introdução e aplicativos de escritório</a></li>
<li><a href="../pt460789/index.html">Finalmente, rejuvenescimento é uma coisa</a></li>
<li><a href="../pt460795/index.html">12 dicas para melhorar o desempenho do aplicativo JavaScript</a></li>
<li><a href="../pt460797/index.html">Desenvolvimento de JavaScript responsável, parte 2</a></li>
<li><a href="../pt460799/index.html">Solicitação de pagamento da API do navegador padrão</a></li>
<li><a href="../pt460801/index.html">27 ferramentas incríveis do VS Code para desenvolvedores modernos de JavaScript</a></li>
<li><a href="../pt460803/index.html">Leitura para o verão: livros para técnicos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>