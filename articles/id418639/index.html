<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏽 🌕 👱 Akka Streaming untuk manusia biasa 🤘🏽 👐🏿 👩🏿‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana saya bisa mencetak aliran pesan yang berkelanjutan dari Twitter dengan beberapa baris kode dengan menambahkan data cuaca ke tempat-tempat ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Akka Streaming untuk manusia biasa</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/418639/">  Bagaimana saya bisa mencetak aliran pesan yang berkelanjutan dari Twitter dengan beberapa baris kode dengan menambahkan data cuaca ke tempat-tempat tinggal penulisnya?  Dan bagaimana Anda dapat membatasi kecepatan permintaan ke penyedia cuaca sehingga mereka tidak memasukkan kami ke daftar hitam? <br><br>  Hari ini kami akan memberi tahu Anda bagaimana melakukannya, tetapi pertama-tama kita akan mengenal teknologi Akka Streams, yang membuat bekerja dengan aliran data real-time semudah programmer bekerja dengan ekspresi LINQ tanpa memerlukan implementasi aktor individu atau antarmuka Reactive Streams. . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ibpnza_PCr0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Artikel ini didasarkan pada transkrip dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan Vagif Abilov</a> dari konferensi Desember kami DotNext 2017 Moscow. <br><a name="habracut"></a><br>  Nama saya Vagif, saya bekerja untuk perusahaan Norwegia, Miles.  Hari ini kita akan berbicara tentang perpustakaan Akka Streams. <br><br>  Akka dan Reactive Streaming adalah persimpangan dari set yang cukup sempit, dan orang mungkin mendapatkan kesan bahwa ini adalah ceruk yang Anda butuhkan untuk memiliki pengetahuan yang hebat untuk masuk, tetapi justru sebaliknya.  Dan artikel ini dimaksudkan untuk menunjukkan bahwa dengan menggunakan Akka Streams, Anda dapat menghindari pemrograman tingkat rendah yang diperlukan saat menggunakan Reactive Streams dan Akka.NET.  Ke depan, saya dapat langsung mengatakan: jika pada awal proyek kami, di mana kami menggunakan Akka, kami tahu tentang keberadaan Akka Streams, kami akan menulis banyak berbeda, kami akan menghemat waktu dan kode. <br><blockquote> <i>"Mungkin yang terburuk yang bisa kamu lakukan adalah membuat orang yang tidak kesakitan untuk minum aspirin."</i> <br>  Max Kreminski <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">“Pintu tertutup, sakit kepala, dan kebutuhan intelektual”</a> </blockquote>  Sebelum kita masuk ke detail teknis, sedikit tentang apa jalan Anda menuju Akka Streams dan apa yang bisa membawa Anda ke sana.  Suatu hari saya menemukan blog Max Kreminski, di mana dia mengajukan pertanyaan filosofis untuk programmer: bagaimana atau mengapa tidak mungkin bagi seorang programmer untuk menjelaskan apa itu monad.  Dia menjelaskannya dengan cara ini: sangat sering orang langsung pergi ke detail teknis, menjelaskan betapa indahnya pemrograman fungsional dan seberapa banyak pengertian yang ada di monad, tanpa repot-repot bertanya-tanya mengapa programmer mungkin membutuhkannya sama sekali.  Menggambar analogi, itu seperti mencoba menjual aspirin tanpa repot-repot mencari tahu apakah pasien Anda sakit. <br><br>  Dengan menggunakan analogi ini, saya ingin mengajukan pertanyaan berikut: jika Akka Streams adalah aspirin, lalu apa rasa sakit yang akan menuntun Anda ke sana? <br><br><h1>  Streaming data </h1><br>  Pertama, mari kita bicara tentang aliran data.  Alurnya bisa sangat sederhana, linier. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Browser Anda tidak mendukung video HTML5. <source src="https://media.giphy.com/media/ZNejul2eTftImnVrsY/giphy.mp4" type="video/mp4"></video></div></div></div><br>  Di sini kami memiliki konsumen data tertentu (kelinci dalam video).  Ini mengkonsumsi data pada kecepatan yang sesuai dengannya.  Ini adalah interaksi ideal konsumen dengan arus: ia menetapkan bandwidth, dan data mengalir dengan tenang ke sana.  Aliran data sederhana ini bisa tak terbatas, atau bisa berakhir. <br><br>  Tetapi alirannya mungkin lebih kompleks.  Jika Anda menanam beberapa kelinci berdampingan, kita akan memiliki paralelisasi aliran.  Apa yang Reactive Streaming coba selesaikan adalah bagaimana tepatnya kita dapat berkomunikasi dengan aliran pada tingkat yang lebih konseptual, mis., Terlepas dari apakah kita hanya berbicara tentang semacam pengukuran sensor suhu, di mana pengukuran linear masuk , atau kami memiliki pengukuran terus menerus dari ribuan sensor suhu yang memasuki sistem melalui antrian RabbitMQ dan disimpan dalam log sistem.  Semua hal di atas dapat dianggap sebagai satu aliran komposit.  Jika Anda melangkah lebih jauh, maka manajemen produksi otomatis (misalnya, oleh beberapa toko online) juga dapat direduksi menjadi aliran data, dan alangkah baiknya jika kita dapat berbicara tentang perencanaan aliran semacam itu, tidak peduli betapa rumitnya itu. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7c/fa0/3af/a7cfa03af65ad4d88c1ce13d316e272e.jpg"><br><br>  Untuk proyek-proyek modern, dukungan utas tidak terlalu baik.  Jika saya ingat dengan benar, Aaron Stannard, yang tweet-nya Anda lihat di gambar, ingin mendapatkan aliran file multi-gigabyte yang mengandung CSV, mis.  teks, dan ternyata tidak ada yang bisa Anda ambil dan gunakan segera, tanpa banyak tindakan tambahan.  Tapi dia tidak bisa mendapatkan aliran nilai CSV, yang membuatnya sedih.  Ada beberapa solusi (dengan pengecualian beberapa area khusus), banyak hal yang diterapkan oleh metode lama, ketika kita membuka semua ini, mulai membaca, buffering, dalam kasus terburuk, kita mendapatkan sesuatu seperti notepad yang mengatakan file terlalu besar. <br><br>  Pada tingkat konseptual yang tinggi, kita semua terlibat dalam pemrosesan aliran data, dan Akka Streaming akan membantu Anda jika: <br><br><ul><li>  Anda terbiasa dengan Akka, tetapi ingin menyisihkan diri Anda detail yang terkait dengan penulisan kode aktor dan koordinasinya; <br></li><li>  Anda terbiasa dengan Aliran Reaktif dan ingin menggunakan implementasi spesifikasi mereka yang sudah jadi; <br></li><li>  Elemen blok Akka Streams untuk tahapan cocok untuk memodelkan proses Anda; <br></li><li>  Anda ingin mengambil keuntungan dari tekanan balik Akka Streams (tekanan balik) untuk mengelola dan memperbaiki secara bertahap tahapan throughput dari alur kerja Anda. <br></li></ul><br><h1>  Dari aktor ke Akka Streams </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/9e2/067/5d1/9e20675d1a251ffc62b578eba2e7167d.jpg"><br><br>  Cara pertama adalah dari aktor ke Akka Streams, caraku. <br><br>  Gambar menunjukkan mengapa kami mulai menggunakan model aktor.  Kami lelah oleh kontrol manual arus, keadaan bersama, itu saja.  Setiap orang yang telah bekerja dengan sistem besar, dengan yang multi-threaded, memahami berapa banyak ini membutuhkan waktu dan betapa mudahnya membuat kesalahan di dalamnya, yang bisa berakibat fatal bagi keseluruhan proses.  Ini membawa kami ke model aktor.  Kami tidak menyesali pilihan yang dibuat, tetapi, tentu saja, ketika Anda mulai bekerja dan pemrograman lebih banyak, itu bukan karena antusiasme awal memberi jalan kepada sesuatu yang lain, tetapi Anda mulai menyadari bahwa sesuatu dapat dilakukan bahkan lebih efektif. <br><blockquote>  <i>“Secara default, penerima pesan mereka dimasukkan dalam kode aktor.</i>  <i>Jika saya membuat aktor A yang mengirim pesan ke aktor B, dan Anda ingin mengganti penerima dengan aktor C, dalam kasus umum ini tidak akan berfungsi untuk Anda ”</i> <br>  Noel Welch (garis bawah.io) </blockquote>  Aktor dikritik karena tidak menulis.  Salah satu yang pertama menulis tentang ini di blog-nya adalah Noel Welch, salah satu pengembang Underscore.  Dia memperhatikan bahwa sistem aktor terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8f/e3b/3dd/d8fe3b3dd378bb187c4a85de3e982960.jpg"><br><br>  Jika Anda tidak menggunakan hal-hal tambahan, seperti injeksi ketergantungan, alamat penerimanya dijahit ke aktor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/62f/78b/3df62f78bf5f64bda875c5f448057427.jpg"><br><br>  Ketika mereka mulai mengirim pesan satu sama lain, semua ini Anda tetapkan sebelumnya, para aktor pemrograman.  Dan tanpa trik tambahan, sistem kaku seperti itu diperoleh. <br>  Salah satu pengembang Akka, Roland Kuhn, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menjelaskan</a> apa yang umumnya dimaksud dengan tata letak yang buruk.  Metode aktor didasarkan pada metode tell, mis., Pesan searah: itu adalah tipe void, mis. Tidak mengembalikan apa pun (atau unit, tergantung pada bahasanya).  Oleh karena itu, mustahil untuk membangun deskripsi proses dari rantai aktor.  Jadi Anda kirim kirim, lalu apa?  Berhenti  Kami batal.  Anda dapat membandingkannya, misalnya, dengan ekspresi LINQ, di mana setiap elemen dari ekspresi mengembalikan IQueryable, IEnumerable, dan semua ini dapat dengan mudah dikompilasi.  Aktor tidak memberikan kesempatan seperti itu.  Pada saat yang sama, Roland Kuhn keberatan dengan fakta bahwa mereka, kata mereka, tidak menyusun prinsip, mengatakan bahwa sebenarnya mereka disusun dengan cara lain, dalam arti yang sama di mana masyarakat manusia menyesuaikan diri dengan tata letak.  Kedengarannya seperti argumen filosofis, tetapi jika Anda memikirkannya, analoginya masuk akal - ya, para aktor saling mengirim pesan satu arah, tetapi kami juga berkomunikasi satu sama lain, mengucapkan pesan satu arah, tetapi pada saat yang sama kami berinteraksi dengan cukup efektif, yaitu, kami menciptakan sistem yang kompleks.  Namun demikian, kritik terhadap aktor seperti itu tetap ada. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SampleActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Idle(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Idle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Job&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Working</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Cancel&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } }</code> </pre> <br>  Selain itu, implementasi aktor membutuhkan setidaknya menulis kelas jika Anda bekerja di C #, atau berfungsi jika Anda bekerja di F #.  Dalam contoh di atas - kode boilerplate, yang harus Anda tulis dalam hal apa pun.  Meskipun tidak terlalu besar, itu adalah sejumlah baris tertentu yang harus selalu Anda tulis di tingkat rendah ini.  Hampir semua kode yang ada di sini adalah semacam upacara.  Apa yang terjadi ketika seorang aktor langsung menerima pesan sama sekali tidak ditampilkan di sini.  Dan semua ini perlu ditulis.  Ini, tentu saja, tidak terlalu banyak, tetapi ini adalah bukti bahwa kami bekerja dengan para aktor di tingkat rendah, menciptakan metode yang tidak berlaku. <br><br>  Bagaimana jika kita dapat pergi ke tingkat yang berbeda, lebih tinggi, bertanya pada diri sendiri pertanyaan pemodelan proses kami, yang meliputi pemrosesan data dari berbagai sumber yang dicampur, dikonversi dan ditransfer? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  Sebuah analog dari pendekatan ini adalah apa yang kita semua telah terbiasa bekerja dengan LINQ selama sepuluh tahun.  Kami tidak heran bagaimana gabung bekerja.  Kami tahu bahwa ada penyedia LINQ yang akan melakukan semua ini untuk kami, dan kami tertarik pada tingkat yang lebih tinggi dalam memenuhi permintaan.  Dan kami biasanya dapat mencampur database di sini, kami dapat mengirim permintaan distributif.  Bagaimana jika Anda bisa menggambarkan prosesnya dengan cara ini? <br><br><pre> <code class="cs hljs">HttpGet pageUrl |&gt; fun s -&gt; Regex.Replace(s, <span class="hljs-string"><span class="hljs-string">"[^A-Za-z']"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>) |&gt; fun s -&gt; Regex.Split(s, <span class="hljs-string"><span class="hljs-string">" +"</span></span>) |&gt; Set.ofArray |&gt; Set.filter (fun word -&gt; not (Spellcheck word)) |&gt; Set.iter (fun word -&gt; printfn <span class="hljs-string"><span class="hljs-string">" %s"</span></span> word)</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(Sumber)</a> <br><br>  Atau, misalnya, transformasi fungsional.  Yang disukai banyak orang tentang pemrograman fungsional adalah Anda dapat melewatkan data melalui serangkaian transformasi, dan Anda mendapatkan kode ringkas yang cukup jelas, terlepas dari bahasa apa Anda menulisnya.  Cukup mudah dibaca.  Kode dalam gambar secara khusus ditulis dalam F #, tetapi secara umum, mungkin, semua orang mengerti apa yang terjadi di sini. <br><br><pre> <code class="cs hljs">val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = Source(<span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">10</span></span>) val <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = Sink.ignore val bcast = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Broadcast[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val merge = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Merge[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val f1,f2,f3,f4 = Flow[Int].map(_ + <span class="hljs-number"><span class="hljs-number">10</span></span>) source ~&gt; f1 ~&gt; bcast ~&gt; f2 ~&gt; merge ~&gt; f3 ~&gt; sink bcast ~&gt; f4 ~&gt; merge ~&gt;</code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(Sumber)</a> <br><br>  Bagaimana dengan ini?  Dalam contoh di atas, kami memiliki sumber data sumber, yang terdiri dari bilangan bulat dari 1 hingga 10. Ini adalah apa yang disebut DSL grafis (bahasa khusus domain).  Elemen-elemen dari bahasa domain pada contoh di atas adalah simbol panah searah - ini adalah operator tambahan yang didefinisikan oleh alat bahasa yang secara grafis menunjukkan arah aliran.  Kami melewati Source melalui serangkaian transformasi - untuk memudahkan demonstrasi, mereka semua hanya menambahkan sepuluh ke angka.  Selanjutnya, Broadcast: kami mengalikan saluran, yaitu setiap nomor memasuki dua saluran.  Lalu kami menambahkan 10 lagi, mencampur aliran data kami, mendapatkan aliran baru, menambahkan 10 juga, dan semua ini mengalir ke aliran data kami, di mana tidak ada yang terjadi.  Ini adalah kode asli yang ditulis dalam Scala, bagian dari Akka Streams, diimplementasikan dalam bahasa ini.  Artinya, Anda menentukan fase transformasi data Anda, menunjukkan apa yang harus dilakukan dengan mereka, menentukan sumber, stok, beberapa pos pemeriksaan, dan kemudian membentuk grafik seperti itu menggunakan DSL grafis.  Ini semua kode untuk satu program.  Beberapa baris kode menunjukkan apa yang terjadi dalam proses. <br><br>  Mari kita lupa bagaimana menulis kode definisi untuk masing-masing aktor dan alih-alih mempelajari tata letak tingkat tinggi primitif yang akan membuat dan menghubungkan aktor yang diperlukan dalam diri mereka.  Ketika kami menjalankan grafik seperti itu, sistem yang menyediakan Akka Streams akan membuat aktor yang diperlukan dengan sendirinya, mengirim semua data ini di sana, memprosesnya sebagaimana mestinya, dan akhirnya memberikannya kepada penerima akhir. <br><br><pre> <code class="hljs pgsql">var runnable = Source .<span class="hljs-keyword"><span class="hljs-keyword">From</span></span>(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">To</span></span>(Sink.<span class="hljs-keyword"><span class="hljs-keyword">ForEach</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(x =&gt; Console.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(x.ToString));</code> </pre> <br>  Contoh di atas menunjukkan bagaimana ini terlihat dalam C #.  Cara paling sederhana: kami memiliki satu sumber data - ini adalah angka dari 1 hingga 1000 (seperti yang Anda lihat, di Akka Streams, setiap IEnumerable dapat menjadi sumber aliran data, yang sangat nyaman).  Kami melakukan beberapa perhitungan sederhana, katakanlah, kami kalikan dua, dan kemudian pada aliran data semua ini ditampilkan di layar. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(builder =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcast = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = Flow.FromFunction(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Sum((x, y) =&gt; x + y); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)).To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)).Via(count).Via(sum).To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(bcast.In, merge.Out); });</code> </pre> <br>  Apa yang ditunjukkan pada contoh di atas disebut "DSL grafis dalam C #".  Sebenarnya, tidak ada grafik di sini, ini adalah port dengan Scala, tetapi di C # tidak ada cara untuk mendefinisikan operator dengan cara ini, sehingga terlihat sedikit lebih rumit, tetapi masih cukup kompak untuk memahami apa yang terjadi di sini.  Jadi, kami membuat grafik tertentu (ada berbagai jenis grafik, ini dia disebut FlowShape) dari berbagai komponen, di mana ada sumber data dan ada beberapa transformasi.  Kami mengirim data ke satu saluran tempat kami menghasilkan penghitungan, yaitu jumlah elemen data yang akan dikirim, dan di saluran lain kami menghasilkan jumlah dan kemudian kami mencampur semuanya.  Selanjutnya kita akan melihat contoh yang lebih menarik daripada hanya memproses bilangan bulat. <br>  Ini adalah jalur pertama yang dapat mengarahkan Anda ke Akka Streams, jika Anda memiliki pengalaman bekerja dengan model aktor dan Anda telah memikirkan apakah akan menulis masing-masing secara manual, bahkan aktor paling sederhana.  Cara kedua yang dilakukan Akka Streams adalah melalui Reactive Streams. <br><br><h1>  Dari Aliran Reaktif ke Aliran Akka </h1><br>  Apa itu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Streaming Reaktif</a> ?  Ini adalah inisiatif bersama untuk mengembangkan standar untuk pemrosesan aliran data yang tidak sinkron.  Ini mendefinisikan set minimum antarmuka, metode dan protokol yang menggambarkan operasi dan entitas yang diperlukan untuk mencapai tujuan - pemrosesan data secara asinkron secara real time dengan tekanan balik yang tidak menghalangi (tekanan balik).  Ini memungkinkan berbagai implementasi menggunakan bahasa pemrograman yang berbeda. <br><br>  Aliran Reaktif memungkinkan Anda untuk memproses sejumlah elemen yang berpotensi tidak terbatas dalam urutan dan mentransfer elemen secara tidak sinkron antara komponen dengan tekanan balik yang tidak menghalangi. <br><br>  Daftar penggagas penciptaan Reactive Streams cukup mengesankan: di sini adalah Netflix, dan Oracle, serta Twitter. <br><br>  Spesifikasi ini sangat sederhana untuk membuat implementasi dalam berbagai bahasa dan platform semudah mungkin diakses.  Komponen utama API Aliran Reaktif: <br><br><ol><li>  Penerbit <br></li><li>  Pelanggan <br></li><li>  Berlangganan <br></li><li>  Prosesor <br></li></ol><br>  Pada dasarnya, spesifikasi ini tidak menyiratkan bahwa Anda akan mulai mengimplementasikan antarmuka ini secara manual.  Dipahami bahwa ada beberapa pengembang perpustakaan yang akan melakukan ini untuk Anda.  Dan Akka Streams adalah salah satu implementasi dari spesifikasi ini. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscriber&lt;T&gt; subscriber</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSubscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscription subscription</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T element</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception cause</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br>  Antarmuka, seperti yang Anda lihat dari contoh, sangat sederhana: misalnya, Penerbit hanya berisi satu metode - “berlangganan”.  Pelanggan, Pelanggan, hanya berisi beberapa reaksi terhadap acara tersebut. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscription</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cancel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IProcessor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T1</span></span>, <span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T1</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; { }</code> </pre> <br>  Akhirnya, berlangganan berisi dua metode - "mulai" dan "menolak".  Prosesor tidak mendefinisikan metode baru sama sekali, melainkan menggabungkan penerbit dan pelanggan. <br><br>  Apa yang membedakan Streaming Reaktif dari implementasi stream lainnya?  Streaming Reaktif menggabungkan model push dan pull.  Untuk dukungan, ini adalah skenario kinerja yang paling efisien.  Misalkan Anda memiliki pelanggan data yang lambat.  Dalam hal ini, dorongan untuknya bisa berakibat fatal: jika Anda mengiriminya sejumlah besar data, ia tidak akan dapat memprosesnya.  Lebih baik menggunakan tarikan sehingga pelanggan sendiri menarik data dari penerbit.  Tetapi jika penerbit lambat, ternyata pelanggan diblokir sepanjang waktu, menunggu sepanjang waktu.  Solusi perantara mungkin adalah konfigurasi: kami memiliki file konfigurasi tempat kami menentukan yang mana yang lebih cepat.  Dan jika kecepatan mereka berubah? <br><br>  Jadi, implementasi yang paling elegan adalah di mana kita dapat secara dinamis mengubah model push dan pull. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/ab6/298/971ab6298b3f313b90503cf6a860e188.png"><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(Sumber (Apache Flink))</a> <br><br>  Diagram menunjukkan bagaimana ini bisa terjadi.  Demo ini menggunakan Apache Flink.  Yellow adalah penerbit, produser data, ia ditetapkan sekitar 50% dari kemampuannya.  Pelanggan mencoba untuk memilih strategi terbaik - ternyata menjadi dorongan.  Kemudian kami mengatur ulang pelanggan ke kecepatan sekitar 20%, dan dia beralih untuk menarik.  Lalu kita pergi 100%, kembali lagi 20%, ke model tarik, dll. Semua ini terjadi dalam dinamika, Anda tidak perlu menghentikan layanan, memasukkan sesuatu ke dalam konfigurasi.  Ini adalah ilustrasi bagaimana tekanan balik bekerja di Akka Streams. <br><br><h1>  Prinsip aliran Akka </h1><br>  Tentu saja, Akka Streams tidak akan mendapatkan popularitas jika tidak ada blok bawaan yang sangat mudah digunakan.  Ada banyak dari mereka.  Mereka dibagi menjadi tiga kelompok utama: <br><br><ol><li>  Sumber data (Sumber) - tahap pemrosesan dengan satu output. <br></li><li>  Sink adalah langkah pemrosesan entri tunggal. <br></li><li>  Checkpoint (Flow) - tahap pemrosesan dengan satu input dan satu output.  Transformasi fungsional terjadi di sini, dan tidak harus dalam memori: itu bisa, misalnya, panggilan ke layanan web, ke beberapa elemen paralelisme, multi-threaded. <br></li></ol><br>  Dari ketiga jenis ini, grafik dapat dibentuk.  Ini sudah merupakan tahap pemrosesan yang lebih kompleks, yang dibangun dari sumber, saluran air, dan pos pemeriksaan.  Tetapi tidak semua grafik dapat dieksekusi: jika ada lubang di dalamnya, yaitu, buka input dan output, maka grafik ini tidak berjalan. <br>  Grafik adalah Grafik Runnable, jika ditutup, yaitu ada output untuk setiap input: jika data telah dimasukkan, pasti ada di suatu tempat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41f/059/a3c/41f059a3cebba7f1e023c8036a29cc8e.jpg"><br><br>  Akka Streams memiliki sumber bawaan: dalam gambar Anda melihat berapa banyak dari mereka.  Nama-nama mereka adalah tentang satu-ke-satu dan mencerminkan apa yang dimiliki Scala atau JVM, dengan pengecualian beberapa sumber yang bermanfaat .NET-spesifik.  Dua yang pertama (FromEnumerator dan Dari) adalah beberapa yang paling penting: penomoran apa saja, setiap ienumerable dapat diubah menjadi sumber aliran. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/504/3cb/0e7/5043cb0e7cd9fb15e6b00582b5230103.jpg"><br><br>  Ada built-in drain: beberapa dari mereka menyerupai metode LINQ, misalnya, Pertama, Terakhir, FirstOrDefault.  Tentu saja, semua yang Anda dapatkan, Anda dapat membuang ke file, ke stream, bukan di Akka Streams, tetapi di stream .NET.  Dan lagi, jika Anda memiliki aktor dalam sistem Anda, Anda dapat menggunakannya baik pada input maupun pada output sistem, yaitu, jika Anda ingin, menanamkan ini dalam sistem Anda selesai. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a6/947/229/0a6947229a7ddbb5577b39634a4b6c11.jpg"><br><br>  Dan ada sejumlah besar pos-pos pemeriksaan built-in, yang, mungkin, bahkan lebih mengingatkan pada LINQ, karena di sini ada Select, dan SelectMany, dan GroupBy, yaitu, semua yang kita gunakan untuk bekerja dengan di LINQ. <br><br>  Sebagai contoh, Select in Scala disebut SelectAsync: itu cukup kuat karena mengambil tingkat paralelisme sebagai salah satu argumen.  Artinya, Anda dapat menunjukkan bahwa, misalnya, Pilih mengirim data ke beberapa layanan web secara paralel dalam sepuluh utas, lalu semuanya dikumpulkan dan diteruskan.  Bahkan, Anda menentukan tingkat penskalaan dari pos pemeriksaan dengan satu baris kode. <br><br>  Deklarasi aliran adalah rencana pelaksanaannya, yaitu, grafik, bahkan yang dijalankan, tidak dapat dieksekusi begitu saja - itu perlu diwujudkan.  Harus ada sistem instantiated, sistem aktor, Anda harus memberikan streaming, rencana ini untuk dieksekusi, dan kemudian akan dieksekusi.  Selain itu, pada saat dijalankan sangat optimal, seperti ketika Anda mengirim ekspresi LINQ ke database: penyedia dapat mengoptimalkan SQL Anda untuk output data yang lebih efisien, pada dasarnya mengganti perintah permintaan dengan yang lain.  Sama dengan Akka Streams: mulai dari versi 2.0 Anda dapat menetapkan sejumlah pos pemeriksaan tertentu, dan sistem akan memahami bahwa beberapa di antaranya dapat digabungkan sehingga dijalankan oleh satu aktor (fusi operator).  Pos pemeriksaan, sebagai aturan, menjaga urutan elemen pemrosesan. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  Materialisasi aliran dapat dibandingkan dengan elemen ToList terakhir dalam ekspresi LINQ dalam contoh di atas.  Jika kami tidak menulis ToList, maka kami mendapatkan ekspresi LINQ tidak material yang tidak akan menyebabkan data ditransfer ke server SQL atau Oracle, karena sebagian besar penyedia LINQ mendukung apa yang disebut eksekusi permintaan tangguhan (eksekusi permintaan tertunda), t yaitu, permintaan dieksekusi hanya ketika perintah diberikan untuk memberikan hasil.  Bergantung pada apa yang diminta - daftar atau hasil pertama - tim yang paling efektif akan dibentuk.  Ketika kami mengatakan ToList, kami meminta penyedia LINQ untuk memberi kami hasil yang sudah selesai. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString));</code> </pre> <br>  Akka Streams bekerja dengan cara yang sama.  Dalam gambar adalah grafik yang diluncurkan kami, yang terdiri dari sumber pos pemeriksaan dan limpasan, dan kami sekarang ingin menjalankannya. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MyActorSystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> materializer = ActorMaterializer.Create(system)) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> runnable.Run(materializer); }</code> </pre> <br>  Agar ini terjadi, kita perlu membuat sistem aktor, di dalamnya ada seorang materializer, berikan grafik kita kepadanya, dan dia akan melaksanakannya.  Jika kami membuatnya kembali, itu akan mengeksekusinya lagi, dan hasil lainnya dapat diperoleh. <br><br>  Selain materialisasi aliran, berbicara tentang bagian materi Akka Streams, ada baiknya menyebutkan nilai-nilai yang terwujud. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source1 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink1 = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(output.Add); IRunnableGraph&lt;NotUsed&gt; runnable1 = source1.To(sink1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source2 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink2 = Sink.Sum&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;((x,y) =&gt; x + y); IRunnableGraph&lt;Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; runnable2 = source2.ToMaterialized(sink2, Keep.Right);</code> </pre> <br>  Ketika kita memiliki aliran yang mengalir dari sumber melalui pos pemeriksaan ke saluran, maka jika kita tidak meminta nilai perantara, nilai itu tidak tersedia bagi kita, karena akan dieksekusi dengan cara yang paling efisien.  Ini seperti kotak hitam.  Tetapi mungkin menarik bagi kita untuk menarik beberapa nilai perantara, karena pada setiap titik di sebelah kiri beberapa nilai masuk, nilai-nilai lain keluar di sebelah kanan, dan Anda dapat menentukan grafik untuk menunjukkan apa yang Anda minati.  Dalam contoh di atas, grafik run-in di mana NotUsed ditunjukkan, yaitu, tidak ada nilai material yang menarik minat kami.  Di bawah ini kita buat dengan indikasi bahwa di sisi kanan limpasan, yaitu, setelah semua transformasi selesai, kita perlu memberikan nilai terwujud.  Kami mendapatkan Tugas grafik - tugas, setelah selesai kami mendapatkan int, yaitu, apa yang terjadi pada akhir grafik ini.  Anda dapat menunjukkan dalam setiap paragraf bahwa Anda memerlukan semacam nilai terwujud, semua ini akan dikumpulkan secara bertahap. <br><br>  Untuk mentransfer data ke aliran Akka Streams atau mengeluarkannya dari sana, tentu saja, beberapa jenis interaksi dengan dunia luar diperlukan.  Tahap sumber tertanam berisi berbagai aliran data reaktif: <br><br><ul><li>  Source.FromEnumerator dan Source.From memungkinkan Anda untuk mentransfer data dari sumber apa pun yang mengimplementasikan IEnumerable; <br></li><li>  Unfold dan UnfoldAsync menghasilkan hasil perhitungan fungsi asalkan mengembalikan nilai-nilai non-nol; <br></li><li>  FromInputStream mengubah Stream; <br></li><li>  FromFile mem-parsing isi file ke dalam aliran reaktif; <br></li><li>  ActorPublisher mengonversi pesan aktor. <br></li></ul><br>  Seperti yang sudah saya katakan, untuk pengembang NET. Sangat produktif untuk menggunakan Enumerator atau IEnumerable, tetapi kadang-kadang terlalu primitif, terlalu efisien untuk mengakses data.  Sumber yang lebih kompleks yang berisi sejumlah besar data memerlukan konektor khusus.  Konektor semacam itu ditulis.  Ada proyek sumber terbuka Alpakka, yang awalnya muncul di Scala dan sekarang di .NET.  Selain itu, Akka memiliki apa yang disebut aktor gigih, dan mereka memiliki aliran mereka sendiri yang dapat digunakan (misalnya, Akka Persistence Query membentuk aliran konten dari Akka Event Journal). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/c40/b29/109c40b2934e0a4a4e280b27d2cd1e8b.jpg"><br><br>  Jika Anda bekerja dengan Scala, maka cara termudah adalah untuk Anda: ada banyak konektor, dan Anda pasti akan menemukan sesuatu sesuai selera Anda.  Sebagai informasi, Kafka adalah apa yang disebut Kafka Reaktif, bukan Aliran Kafka.  Kafka Streaming, sejauh yang saya tahu, tidak mendukung tekanan balik.  Kafka reaktif adalah implementasi aliran dari Kafka yang mendukung aliran reaktif. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/160/09d/f2416009d41f26f08e665b2d510aa7db.jpg"><br><br>  Daftar konektor .NET Alpakka lebih sederhana, tetapi diisi ulang, dan ada elemen kompetisi.  Ada tweet berusia enam bulan dari David Fowler dari Microsoft, yang mengatakan bahwa SignalR sekarang dapat bertukar data dengan Reactive Extensions, dan salah satu pengembang di Akka menjawab bahwa itu sebenarnya ada di Akka Streams selama beberapa waktu.  Akka mendukung berbagai layanan dari Microsoft Azure.  CSV adalah hasil dari frustrasi Aaron Stannard ketika ia menemukan bahwa tidak ada aliran yang baik untuk CSV: sekarang Akka memiliki alirannya sendiri untuk CSV XML.  Ada AMQP (pada kenyataannya, RabbitMQ), sedang dalam pengembangan, tetapi tersedia untuk digunakan, berfungsi.  Kafka juga sedang dikembangkan.  Daftar ini akan terus berkembang. <br><br>  Beberapa kata tentang alternatif, karena jika Anda bekerja dengan aliran data, Akka Streams, tentu saja, bukan satu-satunya cara untuk menangani aliran ini.  Kemungkinan besar, dalam proyek Anda, pilihan cara menerapkan utas akan bergantung pada banyak faktor lain yang mungkin menjadi kunci.  Misalnya, jika Anda banyak bekerja dengan Microsoft Azure dan Orleans secara organik dibangun ke dalam kebutuhan proyek Anda dengan dukungan mereka untuk aktor virtual, atau, seperti yang mereka sebut, biji-bijian, maka mereka memiliki implementasi sendiri yang tidak memenuhi spesifikasi Reactive Streams - Orleans Streams, yang itu akan menjadi yang terdekat bagi Anda, dan masuk akal bagi Anda untuk memperhatikannya.  Jika Anda banyak bekerja dengan TPL, ada TPL DataFlow - ini mungkin analogi terdekat dengan Akka Streams: ini juga memiliki primitif untuk menyusun aliran data, serta alat buffering dan pembatasan bandwidth (BoundedCapacity, MaxMessagePerTask).  Jika ide-ide model aktor dekat dengan Anda, maka Akka Streams adalah cara untuk mengatasi ini dan menghemat banyak waktu tanpa harus menulis setiap aktor secara manual. <br><br><h1>  Contoh Implementasi: Aliran Log Kejadian </h1><br>  Mari kita lihat beberapa contoh implementasi.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh pertama tidak secara langsung menerapkan aliran, itu adalah bagaimana menggunakan aliran. </font><font style="vertical-align: inherit;">Ini adalah pengalaman pertama kami dengan Akka Streams, ketika kami menemukan bahwa sebenarnya kami dapat berlangganan beberapa aliran yang akan menyederhanakan banyak hal bagi kami. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/43e/de0/51f/43ede051f01ec132e11502f9cebaccaf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengunggah berbagai file media ke cloud. </font><font style="vertical-align: inherit;">Ini adalah tahap awal proyek: di sini dalam 15 menit terakhir 23 file, di antaranya 7 kesalahan. </font><font style="vertical-align: inherit;">Sekarang praktis tidak ada kesalahan dan jumlah file jauh lebih besar - ratusan melalui setiap beberapa menit. </font><font style="vertical-align: inherit;">Semua ini terkandung dalam Dashboard Kibana.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kibana membaca data dari Elasticsearch, dan karena data sekunder dan bukan primer disimpan di Elasticsearch, implementasi dari pengindeks ini mengharuskan Anda untuk menghapusnya dan mengeluarkan perintah untuk mengisinya lagi. Karena proyek ini sedang dikembangkan, ini memungkinkan kami untuk mengubah format data, memperluasnya dengan nilai-nilai baru, yaitu indeks perlu terus diperbarui. Itu diisi ulang dengan isi jurnal acara Akka, yang disimpan dalam database Microsoft SQL Server. Baik peristiwa yang sebelumnya disimpan dan peristiwa waktu nyata harus ditampilkan di panel operasi saat ini.</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> EventJournal ( Ordering <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PersistenceID <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SequenceNr <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Timestamp</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, IsDeleted <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Manifest <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Payload VARBINARY(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Tags <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> QU_EventJournal <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (PersistenceID, SequenceNr) )</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mencapai ini, kita perlu, di satu sisi, untuk menulis ulang data yang diambil dari SQL Server, yang berisi beberapa eventstore aktor persisten Akka, eventJournal. Gambar menunjukkan toko acara yang khas. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cae/28e/b8e/cae28eb8efd64485e534c63d90550ce2.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan di sisi lain, data datang secara real time. Dan ternyata untuk menulis indeks, kita perlu membaca data dari database, ditambah data real-time tiba, dan pada titik tertentu kita perlu memahami: di sini data dari sini berakhir, ini baru. Momen batas ini memerlukan verifikasi tambahan agar tidak kehilangan apa pun dan tidak merekam apa pun dua kali. Artinya, ternyata agak rumit. Kolega saya dan saya tidak senang dengan apa yang sedang terjadi. Bukan itu kode yang sangat kompleks, hanya agak suram. Sampai kami ingat bahwa aktor gigih di Akka mendukung permintaan kegigihan.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/bb9/08b/6b2bb908be095a552de279cbefad7f1b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini hanya kesempatan untuk mendapatkannya dalam bentuk aliran data yang disarikan di atas sumbernya, mereka berasal dari basis data atau diperoleh secara waktu nyata. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kueri bawaan (kueri persistensi):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Allpersistencelds </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EldPersistenseldelds </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EventByPersistenceldeld </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentEventsByPersistenceld </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EventsByTag </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentEventsByTag </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan ada sejumlah metode yang dapat kita gunakan, misalnya, ada metode saat ini - ini adalah snapshot, data historis hingga titik waktu tertentu. </font><font style="vertical-align: inherit;">Dan tanpa awalan ini, pertama dan termasuk yang asli. </font><font style="vertical-align: inherit;">Kami membutuhkan EventsByTag.</font></font><br><br><pre> <code class="hljs kotlin">let system = mailbox.Context.System let queries = PersistenceQuery.Get(system) .ReadJournalFor&lt;SqlReadJournal&gt;(SqlReadJournal.Identifier) let mat = ActorMaterializer.Create(system) let offset = getCurrentOffset client config let ks = KillSwitches.Shared <span class="hljs-string"><span class="hljs-string">"persistence-elastic"</span></span> let task = queries.EventsByTag(PersistenceUtils.anyEventTag, offset) .Select(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> e -&gt; ElasticTypes.EventEnvelope.FromAkka e) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GroupedWithin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config.BatchSize, config.BatchTimeout)</span></span></span></span> .Via(ks.Flow()) .RunForeach((<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> batch -&gt; processItems client batch), mat) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContinueWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handleStreamError mailbox, TaskContinuationOptions.OnlyOnFaulted)</span></span></span></span> |&gt; Async.AwaitTaskVoid</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan ternyata kami punya cukup kode. </font><font style="vertical-align: inherit;">Itu ditulis dalam F #, tetapi dalam C # itu tentang kompak yang sama. </font><font style="vertical-align: inherit;">Kami mendapatkan EventsByTag, menggunakan blok bawaan Akka Streams, dan dari semua ini kami mendapatkan data yang kami helm di Elasticsearch. </font><font style="vertical-align: inherit;">Artinya, kami mengambil keuntungan dari implementasi aliran data orang lain, dan ini memungkinkan kami untuk melupakan dari mana data kami, dari mana asalnya - dari database atau itu terjadi secara real time. </font><font style="vertical-align: inherit;">Implementasi ini memberi kami semua ini dengan satu permintaan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun di sini kami adalah konsumen data ini. </font><font style="vertical-align: inherit;">Dalam kasus ketika kita ingin menghasilkan data seperti itu sendiri, contohnya menjadi lebih menarik, dan kita melihatnya pada data nyata, karena Twitter adalah salah satu penggagas spesifikasi ini, dan tweet adalah sesuatu yang dapat diakses oleh semua orang, yang kita semua mengerti . </font><font style="vertical-align: inherit;">Ini adalah contoh standar tentang cara Akka Streams bekerja.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh Implementasi: Jet Tweets </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada contoh untuk Akka untuk Scala, untuk Akka.NET, tetapi saya menemukan contoh-contoh ini tidak cukup, karena mereka menunjukkan satu contoh spesifik tentang bagaimana data ditarik keluar dan apa yang dilakukan dengan itu, tetapi saya ingin melihat komplikasi bertahap, yaitu, mulai dengan aliran sederhana dan terus menambahkan beberapa desain baru ke dalamnya. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita akan menggunakan pustaka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tweetinvi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ini adalah pustaka sumber terbuka yang menyediakan data dari Twitter, itu hanya mendukung keluaran data dalam bentuk aliran. </font><font style="vertical-align: inherit;">Aliran ini tidak memenuhi spesifikasi Aliran Reaktif, yaitu, kami tidak dapat langsung mengambilnya, tetapi itu bahkan bagus, karena itu akan memungkinkan kami untuk menunjukkan bagaimana kami dapat, menggunakan Akka yang umumnya primitif, menulis aliran kami sendiri berdasarkan ini, yang akan memenuhi spesifikasi ini.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/acf/ac1/103/acfac11035eee1b69f2eb4c148f2f7f4.jpg"><br><br>       ,      , . .  Broadcast-.        ,     ,       .         :     ,         ,    ,    ,          . <br><br>      GitHub-,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AkkaStreamsDemo</a> .    (      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a> ). <br><br>  Mari kita mulai dengan yang sederhana.        Twitter:   Program.cs <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> useCachedTweets = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika saya diblokir dari Twitter, saya telah men-cache tweet, mereka lebih cepat. </font><font style="vertical-align: inherit;">Untuk memulai, kami membuat beberapa RunnableGraph.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IRunnableGraph&lt;IActorRef&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRunnableGraph</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tweetSource = Source.ActorRef&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, OverflowStrategy.DropHead); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatFlow = Flow.Create&lt;ITweet&gt;().Select(Utils.FormatTweet); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writeSink = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(Console.WriteLine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tweetSource.Via(formatFlow).To(writeSink); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami memiliki sumber tweet di sini, yang berasal dari aktor. </font><font style="vertical-align: inherit;">Saya akan menunjukkan kepada Anda bagaimana kami menarik tweet ini di sana, memformatnya (format tweet hanya memberikan tweet kepada penulis) dan kemudian menulisnya di layar. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StartTweetStream - di sini kita akan menggunakan perpustakaan Tweetinvi.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTweetStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IActorRef actor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = Stream.CreateSampleStream(); stream.TweetReceived += (_, arg) =&gt; { arg.Tweet.Text = arg.Tweet.Text.Replace(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = JsonConvert.SerializeObject(arg.Tweet); File.AppendAllText(<span class="hljs-string"><span class="hljs-string">"tweets.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{json}</span></span></span><span class="hljs-string">\r\n"</span></span>); actor.Tell(arg.Tweet); }; stream.StartStream(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melalui CreateSampleStream kami mendapatkan tweet sampel, mereka dikeluarkan dengan kecepatan yang tidak terlalu tinggi. Dari semua ini, kami memilih apa yang kami butuhkan dan membuat aktor yang mengatakan: "Terima tweet ini." Selanjutnya kita perlu mendapatkan IEnumerable, sehingga pada akhirnya kita mendapatkan sumbernya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TweetEnumerator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terlihat sangat sederhana: kami memiliki koleksi tweet, dan kami perlu menerapkan Current, MoveNext, Reset, dan Buang menjadi warga negara yang baik. Jika kita menjalankan ini, kita akan melihat contoh real-time. Ada banyak non-cetak, karena ini berasal dari negara-negara non-Latin yang berbeda. Ini adalah versi termudah dari program kami.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kita mengubah nilai useCachedTweets menjadi true, dan di sini komplikasinya dimulai. CashedTweets adalah hal yang sama, hanya saja saya punya file 50.000 tweet yang sudah saya pilih, simpan, kita akan menggunakannya. Saya mencoba memilih tweet yang berisi data pada koordinat geografis penulisnya, yang kami perlukan. Langkah selanjutnya adalah kita ingin memparalelkan tweet. Setelah eksekusi, pertama kita akan memiliki pemilik tweet dalam daftar, dan kemudian koordinatnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TweetsWithBroadcast:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika itu adalah Scala, itu akan benar-benar terlihat seperti DSL grafis. </font><font style="vertical-align: inherit;">Di sini kita membuat Siaran dengan dua saluran - keluar (0), keluar (1) - dan dalam satu kasus kita mencetak CreatedBy, yang lain kita mencetak koordinat, lalu kita campur semuanya dan mengirimkannya ke stok. </font><font style="vertical-align: inherit;">Cukup sederhana untuk saat ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Langkah selanjutnya dalam demo kami adalah sedikit menyulitkan. </font><font style="vertical-align: inherit;">Mari kita mulai mengubah bandwidth.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br>          10   ,               10.    ,    ,  ,    . , ,   Akka Streams   Reactive Streams:     .   ,     ,   ,  ,    -  .    , ,    ,          .    ,      .   ,    ,    .     Buffer(10, OverFlowStrategy.DropHead).      ,         .      10        ,      .  , ,  - ,   —      - ,   , ,   , . .          . ,      . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(Flow.Create&lt;ICoordinates&gt;().SelectAsync(<span class="hljs-number"><span class="hljs-number">5</span></span>, Utils.GetWeatherAsync)) .Via(formatTemperature) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini kita memiliki saluran kedua, memiliki SelectAsync, di mana kita mendapatkan cuaca. Kami tidak hanya mengirim ini ke layanan pengiriman cuaca, kami juga mengatakan bahwa kode ini dijalankan dengan level paralelisasi 5: ini berarti bahwa 5 thread paralel akan dibuat jika layanan ini cukup lambat di mana layanan ini akan meminta cuaca. Layanan itu sendiri diterapkan di sini, juga masuk akal untuk menunjukkan betapa sederhananya kode ini.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeatherAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestUrl = <span class="hljs-string"><span class="hljs-string">$"http://api.met.no/weatherapi/locationforecast/1.9/?lat=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">;lon=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetStringAsync(requestUrl); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = XDocument.Parse(result); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = doc.Root.Descendants(<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>).First().Attribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>).Value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>.Parse(temp); }</code> </pre> <br> ( <a href=""></a> ) <br><br>    .     -,      ,   -  ,   HttpClient   ,   XML,   ,     . <br><br>  ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,      ,      .     10     10    ,          ,   . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cukup mengesankan betapa mudahnya menggambarkan proses semacam itu, termasuk menunjukkan tingkat paralelisme. </font><font style="vertical-align: inherit;">Ini hanya beberapa blok yang dapat digunakan di Akka Streams, saya sudah mengatakan bahwa ada banyak dari mereka. </font><font style="vertical-align: inherit;">Kemungkinan Anda dapat memanfaatkan banyak dari mereka cukup tinggi. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika saya menggunakan model aktor, mungkin setahun yang lalu, ketika saya tidak terbiasa dengan Akka Streams, saya akan menulis secara terpisah setiap aktor untuk ini. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, Anda tidak perlu menulis kode untuk setiap pos pemeriksaan, semua ini dapat dilakukan dengan alat Akka Streams, jadi secara total dalam C # diperlukan beberapa puluh baris kode, yang memungkinkan kami untuk memfokuskan kontrol kami, perhatian kami pada tingkat yang lebih tinggi dari organisasi proses, dan bukan pada detail mikro, bagian dalam aliran data.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertimbangan terakhir </font></font></h1><br><img src="https://habrastorage.org/getpro/habr/post_images/17a/f2f/c2b/17af2fc2bfbacfc95fbe5bc9504a346e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gagasan apa tentang Akka Streams yang ingin saya buat sendiri setelah membaca artikel ini? Di DotNext 2017 Moscow saya menghadiri </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentasi oleh Alex Thyssen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentang Fungsi Azure. Dalam arti tertentu, ini adalah perubahan dalam gagasan tentang bagaimana menulis kode untuk ditempatkan, bahwa alih-alih berfokus pada konfigurasi mesin, kami menginstal program-program semacam itu pada mesin ini yang berbicara dengan layanan ini dan menerima data ini) , kami fokus langsung pada bagian fungsional dan helm fungsional ini masuk ke cloud. Kami tidak memikirkan dengan tepat node mesin mana yang akan mengeksekusi kode ini, kami berpikir tentang bagaimana fungsi kami harus bekerja sama satu sama lain. Analogi serupa dapat ditarik antara sistem yang ditulis menggunakan model aktor, tetapi secara manual dan Akka Streams, yaitu. kita lupa bagaimana menulis aktor secara manual dan alih-alih fokus pada keseluruhan deskripsi proses.Dalam sebagian besar skenario, kami berhasil tetap berada pada level yang cukup tinggi sambil mempertahankan skalabilitas dan kinerja sistem.</font></font><br><br>  Akka Streams       , ,   ,     ,   ,      .    ,         ,     ,      ,    ,           .   Akka Streams —  ,     ,          . <br><br>        ,       Akka Streams,  «Akka Stream Rap».  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  ,    . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Ct3eIQ0Tgc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote> <i>This is the Akka Stream. <br><br> This is the Source that feeds the Akka Stream. <br><br> This is the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Streams. <br><br> This is the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Bidiflow that turns back the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the source that feeds the Akka Streams. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini adalah Wastafel yang diisi dari Bidiflow yang mengembalikan Throttle yang mempercepat TakeWhile yang menarik dari Drop yang menghapus dari Zip yang menggabungkan dari Saldo yang membagi FilterNot yang memilih dari Gabung yang mengumpulkan dari Siaran yang bercabang MapAsync yang memetakan dari Sumber yang memberi makan Akka Stream.</font></font></i> </blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menit periklanan. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda menyukai laporan dan menginginkan hal lain seperti itu, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext 2018</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Moskow berikutnya akan diadakan di Moskow pada 22-23 November </font><font style="vertical-align: inherit;">, dan mungkin tidak kalah menariknya bagi Anda di sana. </font><font style="vertical-align: inherit;">Bergegas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk mendapatkan tiket</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan harga Juli (mulai 1 Agustus, biaya tiket akan meningkat).</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418639/">https://habr.com/ru/post/id418639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418629/index.html">Cara memverifikasi secara independen apakah Anda dapat mematenkan produk Anda dan melakukan pencarian paten</a></li>
<li><a href="../id418631/index.html">7 pedoman kode javascript</a></li>
<li><a href="../id418633/index.html">Reaktivitas JavaScript: Contoh Sederhana dan Intuitif</a></li>
<li><a href="../id418635/index.html">Membuat mesin arcade emulator. Bagian 1</a></li>
<li><a href="../id418637/index.html">Kubernet kepada massa: Slurm dimulai pada 3 Agustus</a></li>
<li><a href="../id418641/index.html">Kesalahan yang membuat desainer tidak berkembang</a></li>
<li><a href="../id418643/index.html">Sit vs stand: bagaimana cara kerjanya lebih baik?</a></li>
<li><a href="../id418645/index.html">Makalah dari konferensi musim semi C ++ Russia 2018</a></li>
<li><a href="../id418647/index.html">TESS meluncurkan pencarian planet ekstrasurya</a></li>
<li><a href="../id418649/index.html">Generasi berkelanjutan dari versi alternatif TLS akan menyelesaikan masalah osifikasi protokol lama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>