<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚§¥Ô∏è üßíüèª ‚ò™Ô∏è Solu√ß√£o de palavras cruzadas em japon√™s com PÃ∂yÃ∂tÃ∂hÃ∂oÃ∂Ã∂nÃ∂ Rust e WebAssembly ü•ò üë©üèº‚Äçüé§ ü§≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Como criar um solucionador de n√£o-programa para Python, reescreva-o no Rust para execut√°-lo diretamente no navegador atrav√©s do WebAssembly. 


 TL; D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Solu√ß√£o de palavras cruzadas em japon√™s com PÃ∂yÃ∂tÃ∂hÃ∂oÃ∂Ã∂nÃ∂ Rust e WebAssembly</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454586/"><p><img src="https://habrastorage.org/webt/sy/k0/va/syk0va4uczwmji3lwzhq2nqq2hy.png" alt="Logotipo da ferrugem como nonogram"></p><br><p>  Como criar um solucionador de n√£o-programa para Python, reescreva-o no Rust para execut√°-lo diretamente no navegador atrav√©s do WebAssembly. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TL; DR</a> </p><a name="habracut"></a><br><h2 id="nachalo">  Iniciar </h2><br><p>  Sobre palavras cruzadas em japon√™s (nonograms) no Habr√© j√° havia v√°rias postagens.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplo</a> <br>  e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais um</a> . </p><br><blockquote>  As imagens s√£o criptografadas com n√∫meros localizados √† esquerda das linhas e tamb√©m acima das colunas.  O n√∫mero de n√∫meros mostra quantos grupos de c√©lulas pretas (ou suas cores, para palavras cruzadas coloridas) est√£o na linha ou coluna correspondente e os pr√≥prios n√∫meros - quantas c√©lulas mescladas cada um desses grupos cont√©m (por exemplo, um conjunto de tr√™s n√∫meros - 4, 1 e 3 significa que nesta linha existem tr√™s grupos: o primeiro - de quatro, o segundo - de um, o terceiro - de tr√™s c√©lulas negras).  Em palavras cruzadas em preto e branco, os grupos devem ser separados por pelo menos uma c√©lula vazia; nas palavras cruzadas em cores, esta regra se aplica apenas a grupos de uma cor e grupos multicoloridos podem ser espa√ßados (as c√©lulas vazias tamb√©m podem estar nas bordas das linhas).  √â necess√°rio determinar a localiza√ß√£o dos grupos de c√©lulas. </blockquote><p>  Um dos pontos de vista mais geralmente aceitos √© que palavras cruzadas "corretas" podem ser chamadas apenas daquelas que s√£o resolvidas de maneira "l√≥gica".  Isso geralmente √© chamado de m√©todo de solu√ß√£o, no qual as depend√™ncias entre diferentes linhas e / ou colunas n√£o s√£o levadas em considera√ß√£o.  Em outras palavras, uma solu√ß√£o √© uma sequ√™ncia de decis√µes <strong>independentes</strong> de linhas ou colunas individuais at√© que todas as c√©lulas sejam preenchidas (mais sobre o algoritmo abaixo).  Por exemplo, somente esses nonogramas podem ser encontrados no site <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://nonograms.org/</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://nonograms.ru/</a> ).  Os nonogramas deste site j√° foram citados como exemplo no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Resolvendo palavras cruzadas coloridas em japon√™s na velocidade da luz</a> .  Para fins de compara√ß√£o e verifica√ß√£o, meu solucionador tamb√©m adicionou suporte para baixar e analisar palavras cruzadas deste site (obrigado a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">KyberPrizrak</a> pela permiss√£o para usar materiais de seu site). </p><br><p>  No entanto, o conceito de nonogramas pode ser estendido a um problema mais geral, quando o m√©todo "l√≥gico" usual leva a um beco sem sa√≠da.  Nesses casos, √© preciso fazer uma suposi√ß√£o sobre a cor de uma c√©lula e, depois de provar que essa cor leva a uma contradi√ß√£o, marcar a cor oposta para essa c√©lula.  A sequ√™ncia de tais etapas pode (se voc√™ tiver paci√™ncia) nos fornecer todas as solu√ß√µes.  Este artigo abordar√° principalmente a solu√ß√£o de um caso mais geral de palavras cruzadas. </p><br><h2 id="python">  Python </h2><br><p>  Cerca de um ano e meio atr√°s, acidentalmente me deparei com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> que descrevia um m√©todo para resolver uma √∫nica linha (como se viu mais tarde, o m√©todo era bastante lento). </p><br><p>  Quando implementei esse m√©todo no Python (minha principal linguagem de trabalho) e adicionei uma atualiza√ß√£o seq√ºencial de todas as linhas, vi que tudo isso n√£o estava sendo resolvido muito rapidamente.  Depois de estudar o material, verificou-se que, neste t√≥pico, existem muitos trabalhos e implementa√ß√µes que oferecem abordagens diferentes para esta tarefa. </p><br><p>  Pareceu-me que o trabalho mais ambicioso na an√°lise de v√°rias implementa√ß√µes de solucionadores foi realizado por Jan Wolter, publicando em seu site (que, at√© onde eu sei, continua sendo o maior reposit√≥rio p√∫blico de nonogramas na Internet), um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estudo detalhado</a> contendo uma riqueza de informa√ß√µes e links que podem ajudar na criando seu pr√≥prio solucionador. </p><br><p>  Estudando v√°rias fontes (elas estar√£o no final do artigo), eu melhorei gradualmente a velocidade e a funcionalidade do meu solucionador.  Como resultado, fiquei viciado e participei da implementa√ß√£o, refatora√ß√£o e depura√ß√£o de algoritmos por cerca de 10 meses em um tempo livre do trabalho. </p><br><h3 id="osnovnye-algoritmy">  Algoritmos principais </h3><br><p>  O solucionador resultante pode ser representado na forma de quatro n√≠veis de decis√£o: </p><br><ul><li><p>  solucionador linear ( <strong>linha</strong> ): na entrada, uma linha de c√©lulas e uma linha de descri√ß√£o (pistas); na sa√≠da, uma linha parcialmente resolvida.  Na solu√ß√£o python, implementei 4 algoritmos diferentes (3 deles s√£o adaptados para palavras cruzadas em cores).  O mais r√°pido acabou sendo o algoritmo BguSolver, nomeado ap√≥s a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fonte original</a> .  Este √© um m√©todo muito eficaz e praticamente padr√£o para resolver seq√º√™ncias de caracteres n√£o programadas usando programa√ß√£o din√¢mica.  O pseudoc√≥digo deste m√©todo pode ser encontrado, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste artigo</a> . </p><br></li><li><p>  ( <strong>propaga√ß√£o</strong> ) colocamos todas as linhas e colunas em uma fila, passamos por isso com um solucionador linear, quando recebemos novas informa√ß√µes ao resolver uma linha (coluna), atualizamos a fila, respectivamente, com novas colunas (linhas).  Continue at√© a linha estar vazia. </p><br><div class="spoiler">  <b class="spoiler_title">Exemplo e c√≥digo</b> <div class="spoiler_text"><p> Tomamos a pr√≥xima tarefa a resolver a partir da fila.  Seja uma sequ√™ncia vazia (n√£o resolvida) de comprimento 7 (que a denotamos como <code>???????</code> ) com uma descri√ß√£o dos blocos <code>[2, 3]</code> .  O solucionador linear produzir√° uma string parcialmente resolvida <code>?X??XX?</code>  onde <code>X</code> √© a c√©lula preenchida.  Ao atualizar a linha, vemos que as colunas com os n√∫meros 1, 4, 5 foram alteradas (a indexa√ß√£o come√ßa em 0).  Isso significa que novas informa√ß√µes apareceram nas colunas indicadas e podem ser retornadas ao solucionador "linear".  Colocamos essas colunas na fila de tarefas com maior prioridade (a fim de fornec√™-las ao solucionador linear a seguir). </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">propagation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(board)</span></span></span><span class="hljs-function">:</span></span> line_jobs = PriorityDict() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> row_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.height): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>, row_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> column_index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(board.width): new_job = (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, column_index) line_jobs[new_job] = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (is_column, index), priority <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> line_jobs.sorted_iter(): new_jobs = solve_and_update(board, index, is_column) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> new_job <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_jobs: <span class="hljs-comment"><span class="hljs-comment"># upgrade priority new_priority = priority - 1 line_jobs[new_job] = new_priority def solve_and_update(board, index, is_column): if is_column: row_desc = board.columns_descriptions[index] row = tuple(board.get_column(index)) else: row_desc = board.rows_descriptions[index] row = tuple(board.get_row(index)) updated = line_solver(row_desc, row) if row != updated: for i, (pre, post) in enumerate(zip(row, updated)): if _is_pixel_updated(pre, post): yield (not is_column, i) if is_column: board.set_column(index, updated) else: board.set_row(index, updated)</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>an√°lise</strong> ) para cada c√©lula n√£o resolvida, classificamos todas as op√ß√µes de cores e tentamos a propaga√ß√£o com essas novas informa√ß√µes.  Se tivermos uma contradi√ß√£o, jogaremos essa cor fora das op√ß√µes de cores da c√©lula e tentaremos nos beneficiar dela novamente usando propaga√ß√£o.  Se for resolvido at√© o fim, adicionamos a solu√ß√£o √† lista de solu√ß√µes, mas continuamos os experimentos com outras cores (pode haver v√°rias solu√ß√µes).  Se chegarmos a uma situa√ß√£o em que √© imposs√≠vel resolver ainda mais, simplesmente ignoramos e repetimos o procedimento com uma cor / c√©lula diferente. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><p>  Retorna True se uma contradi√ß√£o for recebida como resultado da amostra. </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, cell_state)</span></span></span><span class="hljs-function">:</span></span> board = self.board pos, assumption = cell_state.position, cell_state.color <span class="hljs-comment"><span class="hljs-comment"># already solved if board.is_cell_solved(pos): return False if assumption not in board.cell_colors(pos): LOG.warning("The probe is useless: color '%s' already unset", assumption) return False save = board.make_snapshot() try: board.set_color(cell_state) propagation( board, row_indexes=(cell_state.row_index,), column_indexes=(cell_state.column_index,)) except NonogramError: LOG.debug('Contradiction', exc_info=True) # rollback solved cells board.restore(save) else: if board.is_solved_full: self._add_solution() board.restore(save) return False LOG.info('Found contradiction at (%i, %i)', *pos) try: board.unset_color(cell_state) except ValueError as ex: raise NonogramError(str(ex)) propagation( board, row_indexes=(pos.row_index,), column_indexes=(pos.column_index,)) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><ul><li><p>  ( <strong>retorno</strong> ) se, durante a investiga√ß√£o, voc√™ n√£o ignora um quebra-cabe√ßa parcialmente resolvido, mas continua invocando recursivamente o mesmo procedimento, obtemos retorno (em outras palavras, uma caminhada completa na profundidade da √°rvore de decis√£o em potencial).  Aqui, um grande papel come√ßa a desempenhar, qual das c√©lulas ser√° escolhida como a pr√≥xima extens√£o da solu√ß√£o em potencial.  Uma boa pesquisa sobre este t√≥pico est√° <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nesta publica√ß√£o</a> . </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><p>  O retorno √© bastante confuso comigo, mas essas duas fun√ß√µes descrevem aproximadamente o que acontece durante uma pesquisa recursiva </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">search</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, search_directions, path=</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Return False if the given path is a dead end (no solutions can be found) """</span></span> board = self.board depth = len(path) save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> search_directions: state = search_directions.popleft() assumption, pos = state.color, state.position cell_colors = board.cell_colors(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> assumption <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cell_colors: LOG.warning(<span class="hljs-string"><span class="hljs-string">"The assumption '%s' is already expired. "</span></span> <span class="hljs-string"><span class="hljs-string">"Possible colors for %s are %s"</span></span>, assumption, pos, cell_colors) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(cell_colors) == <span class="hljs-number"><span class="hljs-number">1</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Only one color for cell %r left: %s. Solve it unconditionally'</span></span>, pos, assumption) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> NonogramError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The path %s is invalid"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The only color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> rate = board.solution_rate guess_save = board.make_snapshot() <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning(<span class="hljs-string"><span class="hljs-string">'Trying state: %s (depth=%d, rate=%.4f, previous=%s)'</span></span>, state, depth, rate, path) success = self._try_state(state, path) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: board.restore(guess_save) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> success: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: LOG.warning( <span class="hljs-string"><span class="hljs-string">"Unset the color %s for cell '%s'. Solve it unconditionally"</span></span>, assumption, pos) board.unset_color(state) self._solve_without_search() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> ValueError: LOG.warning( <span class="hljs-string"><span class="hljs-string">"The last possible color '%s' for the cell '%s' "</span></span> <span class="hljs-string"><span class="hljs-string">"lead to the contradiction. "</span></span> <span class="hljs-string"><span class="hljs-string">"The whole branch (depth=%d) is invalid. "</span></span>, assumption, pos, depth) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> board.is_solved_full: self._add_solution() LOG.warning( <span class="hljs-string"><span class="hljs-string">"The negation of color '%s' for the cell '%s' lead to full solution. "</span></span> <span class="hljs-string"><span class="hljs-string">"No need to traverse the path %s anymore"</span></span>, assumption, pos, path) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-comment"><span class="hljs-comment"># do not restore the solved cells on a root path - they are really solved! if path: board.restore(save) return True def _try_state(self, state, path): board = self.board full_path = path + (state,) probe_jobs = self._get_all_unsolved_jobs(board) try: # update with more prioritized cells for new_job, priority in self._set_guess(state): probe_jobs[new_job] = priority __, best_candidates = self._solve_jobs(probe_jobs) except NonogramError as ex: LOG.warning('Dead end found (%s): %s', full_path[-1], str(ex)) return False rate = board.solution_rate LOG.info('Reached rate %.4f on %s path', rate, full_path) if rate == 1: return True cells_left = round((1 - rate) * board.width * board.height) LOG.info('Unsolved cells left: %d', cells_left) if best_candidates: return self.search(best_candidates, path=full_path) return True</span></span></code> </pre> <br></div></div><br></li></ul><br><p>  Portanto, come√ßamos a resolver nossas palavras cruzadas a partir do segundo n√≠vel (o primeiro √© adequado apenas para o caso degenerado, quando em todas as palavras cruzadas h√° apenas uma linha ou coluna) e subimos gradualmente os n√≠veis.  Como voc√™ pode imaginar, cada n√≠vel causa o n√≠vel subjacente v√°rias vezes; portanto, para uma solu√ß√£o eficaz, √© imperativo ter primeiro e segundo n√≠veis r√°pidos, que podem ser chamados milh√µes de vezes para quebra-cabe√ßas complexos. </p><br><p>  Nesse est√°gio, verifica-se (bastante esperado) que o python n√£o seja a ferramenta adequada para o desempenho m√°ximo em uma tarefa que exige muita CPU: todos os c√°lculos s√£o extremamente ineficientes em compara√ß√£o com as linguagens de n√≠vel inferior.  Por exemplo, o solucionador de BGU com algoritmos mais pr√≥ximos (em Java), de acordo com os resultados das medi√ß√µes, mostrou ser 7-17 (√†s vezes at√© 27) vezes mais r√°pido em uma variedade de tarefas. </p><br><div class="spoiler">  <b class="spoiler_title">Mais detalhes</b> <div class="spoiler_text"><pre>         pynogram_my BGU_my speedup
 Dan√ßarina 0.976 0.141 6.921986      
 Cat 1.064 0.110 9.672727      
 Skid 1.084 0.101 10.732673     
 Bucks 1.116 0.118 9.457627      
 Edge 1.208 0,094 12,851064     
 Fuma√ßa 1.464 0.120 12.200000     
 N√≥ 1.332 0.140 9.514286      
 Balan√ßo 1,784 0,138 12,927536     
 M√£e 2,108 0,147 14,340136     
 DiCap 2.076 0,176 11,795455     
 Tragic 2,386 0,265 8,935849      
 Merka 2.084 0,196 10.632653     
 Petro 2.948 0.219 13.461187     
 M&amp;M 3,588 0,375 9,568000      
 Assinado 4.068 0,242 16.809917     
 Luz 3.848 0.488 7.885246      
 Forever 111.000 13.570 8.179808  
 Center 5.700 0,327 17,431193     
 Hot 3.150 0.278 11.330935     
 Karat√™ 2.500 0.219 11.415525     
 9-Dom 510.000 70.416 7.242672      
 Bandeira 149.000 5.628 26.474769     
 Le√£o 71.000 2.895 24.525043     
 Marley 12.108 4.405 2.748695      
 Coisa 321.000 46.166 6.953169      
 Natureza inf 433.138 inf     
 Sierp inf inf NaN      
 Gettys inf inf NaN      
</pre><br><p>  As medi√ß√µes foram realizadas no meu carro, os quebra-cabe√ßas s√£o retirados do conjunto padr√£o que Jan Wolter usou em sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">compara√ß√£o</a> </p></div></div><br><p>  E isso j√° foi depois que eu comecei a usar o PyPy, e no CPython padr√£o o tempo de c√°lculo foi maior do que no PyPy 4-5 vezes!  Podemos dizer que o desempenho de um solucionador Java semelhante acabou sendo 28-85 vezes maior que o c√≥digo CPython. </p><br><p>  Tentativas de melhorar o desempenho do meu solucionador usando a cria√ß√£o de perfil (cProfile, SnakeViz, line_profiler) levaram a alguma acelera√ß√£o, mas √© claro que elas n√£o deram um resultado estranho. </p><br><h3 id="itogihttpsgithubcomtsionyxpynogram">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Resumo</a> : </h3><br><p>  <strong>O +</strong> solver pode resolver todos os quebra-cabe√ßas dos sites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://webpbn.com</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://nonograms.org</a> e seu pr√≥prio formato (baseado em ini) </p><br><p>  <strong>+</strong> resolve nonogramas em preto e branco e em cores com qualquer n√∫mero de cores (o n√∫mero m√°ximo de cores encontradas √© 10) </p><br><p>  <strong>+</strong> resolve quebra-cabe√ßas com tamanhos de bloco ausentes (manchados).  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Um exemplo de um quebra-cabe√ßa</a> . </p><br><p>  <strong>+</strong> pode renderizar quebra-cabe√ßas no console / nas maldi√ß√µes / janela no navegador (ao instalar a op√ß√£o adicional <em>pynogram-web</em> ).  Para todos os modos, √© poss√≠vel visualizar o progresso da solu√ß√£o em tempo real. </p><br><p>  <strong>-</strong> c√°lculos lentos (em compara√ß√£o com as implementa√ß√µes descritas na compara√ß√£o de artigos dos solucionadores, consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela</a> ). </p><br><p>  <strong>-</strong> retorno ineficiente: alguns quebra-cabe√ßas podem ser resolvidos por horas (quando a √°rvore de decis√£o √© muito grande). </p><br><h2 id="rust">  Ferrugem </h2><br><p>  No come√ßo do ano, comecei a estudar Rust.  Comecei, como sempre, com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o livro</a> , aprendi sobre o WASM, passei pelo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial proposto</a> .  No entanto, eu queria uma tarefa real na qual voc√™ possa se engajar nos pontos fortes da linguagem (principalmente sua super performance), e n√£o alguns exemplos inventados por algu√©m.  Ent√£o voltei aos nonogramas.  Mas agora eu j√° tinha uma vers√£o funcional de todos os algoritmos em Python, que foi deixada para "apenas" reescrever. </p><br><p>  As boas not√≠cias estavam me esperando desde o in√≠cio: descobriu-se que Rust, com seu sistema de tipos, descreve perfeitamente as estruturas de dados para minha tarefa.  Por exemplo, uma das correspond√™ncias b√°sicas <em>BinaryColor + BinaryBlock</em> / <em>MultiColor + ColoredBlock</em> permite separar permanentemente os nonogramas em preto e branco e em cores.  Se em algum lugar do c√≥digo tentarmos resolver uma sequ√™ncia colorida usando blocos de descri√ß√£o bin√°ria comuns, obteremos um erro de compila√ß√£o sobre incompatibilidade de tipos. </p><br><div class="spoiler">  <b class="spoiler_title">Tipos b√°sicos se parecem com isso</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">blank</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_solved</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solution_rate</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_updated_with</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, new: &amp;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Result</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">variants</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as_color_id</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_color_ids</span></span></span></span>(ids: &amp;[ColorId]) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span>: Color; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_str_and_color</span></span></span></span>(s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> size = s.parse::&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt;().expect(<span class="hljs-string"><span class="hljs-string">"Non-integer block size given"</span></span>); Self::from_size_and_color(size, color) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_size_and_color</span></span></span></span>(size: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, color: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;ColorId&gt;) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">color</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Color; } <span class="hljs-meta"><span class="hljs-meta">#[derive(Debug, PartialEq, Eq, Hash, Clone)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Description</span></span></span></span>&lt;T: Block&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Block, { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;T&gt;, } <span class="hljs-comment"><span class="hljs-comment">// for black-and-white puzzles #[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd)] pub enum BinaryColor { Undefined, White, Black, BlackOrWhite, } impl Color for BinaryColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct BinaryBlock(pub usize); impl Block for BinaryBlock { type Color = BinaryColor; // omitted } // for multicolor puzzles #[derive(Debug, PartialEq, Eq, Hash, Default, Copy, Clone, PartialOrd, Ord)] pub struct MultiColor(pub ColorId); impl Color for MultiColor { // omitted } #[derive(Debug, PartialEq, Eq, Hash, Default, Clone)] pub struct ColoredBlock { size: usize, color: ColorId, } impl Block for ColoredBlock { type Color = MultiColor; // omitted }</span></span></code> </pre> </div></div><br><p>  Ao portar o c√≥digo, alguns pontos indicaram claramente que uma linguagem de tipo estaticamente como Rust (bem, ou, por exemplo, C ++) √© mais adequada para esta tarefa.  Mais precisamente, gen√©ricos e caracter√≠sticas descrevem um dom√≠nio melhor do que hierarquias de classe.  Portanto, no c√≥digo Python, eu tinha duas classes para um <code>BguSolver</code> linear, <code>BguSolver</code> e <code>BguColoredSolver</code> que resolviam uma linha em preto e branco e uma linha de cores, respectivamente.  No c√≥digo Rust, ainda tenho a √∫nica <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> gen√©rica <code>struct DynamicSolver&lt;B: Block, S = &lt;B as Block&gt;::Color&gt;</code> , que pode resolver os dois tipos de tarefas, dependendo do tipo passado durante a cria√ß√£o ( <code>DynamicSolver&lt;BinaryBlock&gt;, DynamicSolver&lt;ColoredBlock&gt;</code> ).  Isso, √© claro, n√£o significa que algo semelhante n√£o possa ser feito em Python, apenas no Rust o sistema de tipos claramente indicado para mim: se voc√™ n√£o fosse por esse caminho, teria que escrever uma tonelada de c√≥digo repetido. </p><br><p>  Al√©m disso, quem tentou escrever no Rust, sem d√∫vida percebeu o efeito da "confian√ßa" no compilador, quando o processo de escrever c√≥digo √© reduzido ao seguinte algoritmo pseudo-meta: </p><br><pre> write_initial_code
 while (compiler_hints = $ (verifica√ß√£o de carga))! = 0;  fazer
     fix_errors (dicas do compilador)
 fim
</pre><br><p>  Quando o compilador parar de emitir erros e avisos, seu c√≥digo ser√° consistente com o sistema de tipos e com o verificador de empr√©stimos e voc√™ avisar√° antecipadamente a ocorr√™ncia de v√°rios bugs em potencial (√© claro, sujeitos a um design cuidadoso dos tipos de dados). </p><br><p>  Vou dar alguns exemplos de fun√ß√µes que mostram como o c√≥digo Rust pode ser conciso (em compara√ß√£o com os equivalentes do Python). </p><br><div class="spoiler">  <b class="spoiler_title">unsolved_neighbours</b> <div class="spoiler_text"><p>  Fornece uma lista de "vizinhos" n√£o resolvidos para um determinado ponto (x, y) </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, position)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.neighbours(position): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.is_cell_solved(*pos): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> pos</code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsolved_neighbours</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, point: &amp;Point) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>&lt;Item = Point&gt; + <span class="hljs-symbol"><span class="hljs-symbol">'_</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.neighbours(&amp;point) .into_iter() .filter(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> |n| !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cell(n).is_solved()) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">parcial_sums</b> <div class="spoiler_text"><p>  Para um conjunto de blocos descrevendo uma linha, forne√ßa somas parciais (levando em considera√ß√£o as lacunas necess√°rias entre os blocos) Os √≠ndices resultantes indicar√£o a posi√ß√£o m√≠nima na qual o bloco pode terminar (essas informa√ß√µes ser√£o usadas posteriormente para um solucionador linear). </p><br><p>  Por exemplo, para esse conjunto de blocos <code>[2, 3, 1]</code> , temos a sa√≠da <code>[2, 6, 8]</code> , o que significa que o primeiro bloco pode ser deslocado ao m√°ximo para a esquerda, de modo que sua borda direita ocupe a 2¬™ c√©lula, da mesma forma que o resto blocos: </p><br><pre>             1 2 3 4 5 6 7 8 9 
             _ _ _ _ _ _ _ _ _ _
      2 3 1 | _ | _ | _ | _ | _ | _ | _ | _ | _ | 
               ^ ^ ^
               |  |  |
 fim de 1 bloco |  |  | 
 fim do bloco 2 -------- |
 fim do bloco 3 ------------
</pre><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@expand_generator def partial_sums(blocks): if not blocks: return sum_so_far = blocks[0] yield sum_so_far for block in blocks[1:]: sum_so_far += block + 1 yield sum_so_far</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partial_sums</span></span></span></span>(desc: &amp;[<span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>]) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>&gt; { desc.iter() .scan(<span class="hljs-literal"><span class="hljs-literal">None</span></span>, |prev, block| { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> current = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> prev_size) = prev { prev_size + block.<span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { block.<span class="hljs-number"><span class="hljs-number">0</span></span> }; *prev = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(current); *prev }) .collect() }</code> </pre> </div></div><br><p>  Ao portar, fiz v√°rias altera√ß√µes </p><br><ul><li>  o n√∫cleo do solucionador (algoritmos) passou por pequenas altera√ß√µes (principalmente para suportar tipos gen√©ricos de c√©lulas e blocos) </li><li>  deixou o √∫nico algoritmo (mais r√°pido) para o solucionador linear </li><li>  em vez do formato ini, introduziu um formato TOML ligeiramente modificado </li><li>  n√£o adicionou suporte para palavras cruzadas borradas, porque, estritamente falando, esta √© uma classe de tarefas diferente </li><li><p>  deixou o √∫nico caminho para a sa√≠da - apenas para o console, mas agora as c√©lulas coloridas no console s√£o desenhadas realmente coloridas (gra√ßas a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta caixa</a> ) </p><br><div class="spoiler">  <b class="spoiler_title">assim</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xm/fd/ez/xmfdezlfahkoksuj3h0djom3p9k.png" alt="Jack pardal"></p><br></div></div><br></li></ul><br><h3 id="poleznye-instrumenty">  Ferramentas √∫teis </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O clippy</a> √© um analisador est√°tico padr√£o que √†s vezes pode at√© dar dicas, aumentando ligeiramente o desempenho do c√≥digo. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O valgrind</a> √© uma ferramenta para an√°lise din√¢mica de aplicativos.  Usei-o como um criador de perfil para procurar botneks ( <code>valrgind --tool=callgrind</code> ) e, particularmente, se√ß√µes de c√≥digo <code>valrgind --tool=massif</code> mem√≥ria ( <code>valrgind --tool=massif</code> ).  Dica: defina <em>[profile.release] debug = true</em> para Cargo.toml antes de iniciar o criador de perfil.  Isso deixar√° os caracteres de depura√ß√£o no execut√°vel. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">kcachegrind</a> para visualizar arquivos de callgrind.  Uma ferramenta muito √∫til para encontrar os lugares mais problem√°ticos em termos de desempenho. </li></ul><br><h3 id="proizvoditelnost">  Desempenho </h3><br><p>  Que para que reescrita em Rust foi iniciada.  Pegamos as palavras cruzadas da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela de compara√ß√£o</a> j√° mencionada e as executamos nos melhores solucionadores descritos no artigo original.  Resultados e descri√ß√£o das execu√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Pegamos o <a href="">arquivo</a> resultante e constru√≠mos alguns gr√°ficos: como o tempo de solu√ß√£o varia de milissegundos a dezenas de minutos, o gr√°fico √© feito com uma escala logar√≠tmica. </p><br><div class="spoiler">  <b class="spoiler_title">executar no laptop jupyter</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pandas <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> matplotlib.pyplot <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> plt %matplotlib inline <span class="hljs-comment"><span class="hljs-comment"># strip the spaces df = pd.read_csv('perf.csv', skipinitialspace=True) df.columns = df.columns.str.strip() df['name'] = df['name'].str.strip() # convert to numeric df = df.replace('\+\ *', np.inf, regex=True) ALL_SOLVERS = list(df.columns[3:]) df.loc[:,ALL_SOLVERS] = df.loc[:,ALL_SOLVERS].apply(pd.to_numeric) # it cannot be a total zero df = df.replace(0, 0.001) #df.set_index('name', inplace=True) SURVEY_SOLVERS = [s for s in ALL_SOLVERS if not s.endswith('_my')] MY_MACHINE_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] in SURVEY_SOLVERS] MY_SOLVERS = [s for s in ALL_SOLVERS if s.endswith('_my') and s[:-3] not in SURVEY_SOLVERS] bar_width = 0.17 df_compare = df.replace(np.inf, 10000, regex=True) plt.rcParams.update({'font.size': 20}) def compare(first, others): bars = [first] + list(others) index = np.arange(len(df)) fig, ax = plt.subplots(figsize=(30,10)) df_compare.sort_values(first, inplace=True) for i, column in enumerate(bars): ax.bar(index + bar_width*i, df_compare[column], bar_width, label=column[:-3]) ax.set_xlabel("puzzles") ax.set_ylabel("Time, s (log)") ax.set_title("Compare '{}' with others (lower is better)".format(first[:-3])) ax.set_xticks(index + bar_width / 2) ax.set_xticklabels("#" + df_compare['ID'].astype(str) + ": " + df_compare['name'].astype(str)) ax.legend() plt.yscale('log') plt.xticks(rotation=90) plt.show() fig.savefig(first[:-3] + '.png', bbox_inches='tight') for my in MY_SOLVERS: compare(my, MY_MACHINE_SOLVERS) compare(MY_SOLVERS[0], MY_SOLVERS[1:])</span></span></code> </pre> </div></div><br><h5 id="python-solver">  solucionador de python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/si/qb/5o/siqb5ohxk_bjjaulmkohy1uhzkw.png" alt="desempenho do pynogram"><br></a> <br>  (a <em>imagem √© clic√°vel</em> ) </p><br><p>  Vemos que o <em>picograma</em> aqui √© mais lento que todos os solucionadores apresentados.  A √∫nica exce√ß√£o a essa regra √© o solucionador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tamura / Copris</a> baseado no SAT, que resolve os quebra-cabe√ßas mais simples (a parte esquerda do gr√°fico) por mais tempo que o nosso.  No entanto, esse √© um recurso dos solucionadores SAT: eles s√£o projetados para palavras cruzadas super complexas nas quais um solucionador regular fica preso no retorno por um longo tempo.  Isso √© claramente vis√≠vel no lado direito do gr√°fico, onde <em>Tamura / Copris</em> resolve os quebra-cabe√ßas mais dif√≠ceis dezenas e centenas de vezes mais r√°pido que todos os outros. </p><br><h5 id="rust-solver">  solucionador de ferrugem </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/bh/be/cb/bhbecb0ccinpwfhysauyjkrcx24.png" alt="desempenho sem grade"><br></a> <br>  (a <em>imagem √© clic√°vel</em> ) </p><br><p>  Este gr√°fico mostra que a n√£o <em>grade</em> em tarefas simples tamb√©m lida com ou um pouco pior que os solucionadores de alto desempenho escritos em C e C ++ ( <em>Wolter</em> e <em>Syromolotov</em> ).  Com a complica√ß√£o das tarefas, nosso solucionador repete aproximadamente a trajet√≥ria do solucionador de <em>BGU</em> (Java), mas quase sempre √† frente dele em cerca de uma ordem de magnitude.  Nas tarefas mais dif√≠ceis, <em>Tamura / Copris</em> est√° sempre √† frente de todos. </p><br><h5 id="rust-vs-python">  ferrugem vs python </h5><br><p> <a href=""><img src="https://habrastorage.org/webt/ih/0b/2r/ih0b2rnmyk5o_rpgckz_5hkkifc.png" alt="py-vs-rust-performance"><br></a> <br>  (a <em>imagem √© clic√°vel</em> ) </p><br><p>  E, finalmente, uma compara√ß√£o dos nossos dois solucionadores descritos aqui.  Pode-se ver que o solucionador Rust quase sempre est√° de 1 a 3 ordens de magnitude √† frente do solucionador python. </p><br><h3 id="itogihttpsgithubcomtsionyxnonogrid">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Resumo</a> : </h3><br><p>  <strong>O +</strong> solver pode resolver todos os quebra-cabe√ßas dos sites <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://webpbn.com</a> (exceto blotted - com tamanhos de blocos parcialmente ocultos), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://nonograms.org</a> e seu pr√≥prio formato (baseado em TOML) </p><br><p>  <strong>+</strong> resolve nonogramas em preto e branco e em cores com qualquer n√∫mero de cores </p><br><p>  <strong>+</strong> pode renderizar quebra-cabe√ßas no console (cor c webpbn.com desenha cores reais) </p><br><p>  <strong>+</strong> funciona r√°pido (em compara√ß√£o com as implementa√ß√µes descritas na compara√ß√£o de artigos dos solucionadores, consulte a tabela). </p><br><p>  <strong>- o</strong> backtracking permaneceu ineficaz, como na solu√ß√£o Python: alguns quebra-cabe√ßas (por exemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">, um 20x20 t√£o inofensivo</a> ) podem ser resolvidos por horas (quando a √°rvore de decis√£o √© muito grande).  Talvez, em vez de voltar atr√°s, valha a pena usar os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solucionadores SAT</a> j√° mencionados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">hub</a>  √â verdade que o √∫nico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">solucionador de SAT</a> que encontrei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Rust</a> √† primeira vista parece inacabado e abandonado. </p><br><h2 id="webassembly">  Webassembly </h2><br><p>  Portanto, reescrever o c√≥digo no Rust valeu a pena: o solucionador se tornou muito mais r√°pido.  No entanto, o Rust nos oferece outro recurso incrivelmente interessante: compila√ß√£o no WebAssembly e a capacidade de executar seu c√≥digo diretamente no navegador. </p><br><p>  Para implementar esse recurso, existe uma ferramenta especial para o Rust que fornece os ligantes necess√°rios e gera um padr√£o para voc√™ executar sem problemas as fun√ß√µes do Rust no c√≥digo JS - este <em>wasm-pack</em> (+ <em>wasm-bindgen</em> ).  A maior parte do trabalho com ele e outras ferramentas importantes j√° est√° descrita no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tutorial Rust and WebAssembly</a> .  No entanto, h√° alguns pontos que eu tive que descobrir por conta pr√≥pria: </p><br><ul><li><p>  ao ler, cria a sensa√ß√£o de que o tutorial foi escrito principalmente para um desenvolvedor de JS que deseja acelerar seu c√≥digo com o Rust.  Bem, ou pelo menos para algu√©m familiarizado com o <em>npm</em> .  Para mim, como uma pessoa distante do front-end, foi surpreendente descobrir que mesmo o exemplo padr√£o do livro n√£o deseja trabalhar com um servidor da Web de terceiros diferente do <code>npm run start</code> . </p><br><p>  Felizmente, o wasm-pack possui um modo que permite gerar c√≥digo JS regular (que n√£o √© um m√≥dulo npm).  <code>wasm-pack build --target no-modules --no-typescript</code> na sa√≠da produzir√° apenas dois arquivos: <em>project-name.wasm</em> - o bin√°rio do c√≥digo Rust compilado no WebAssembly e <em>project-name.js</em> .  O √∫ltimo arquivo pode ser inclu√≠do em qualquer p√°gina HTML <code>&lt;script src="project-name.js"&gt;&lt;/script&gt;</code> e usar as fun√ß√µes WASM sem se preocupar com npm, webpack, ES6, m√≥dulos e outras alegrias do desenvolvedor JS moderno.  O modo <code>no-modules</code> √© ideal para desenvolvedores n√£o front-end durante o desenvolvimento de um aplicativo WASM, bem como para exemplos e demonstra√ß√µes, porque n√£o requer nenhuma infraestrutura front-end adicional. </p><br></li><li><p>  O WebAssembly √© bom para tarefas muito pesadas para JavaScript.  Antes de tudo, s√£o tarefas que realizam muitos c√°lculos.  E, nesse caso, essa tarefa pode ser executada por um longo tempo, mesmo com o WebAssembly, violando o princ√≠pio ass√≠ncrono da web moderna.  Estou falando de todos os tipos de <em>scripts</em> de <em>aviso: sem resposta</em> que eu observei quando meu solucionador estava funcionando.  Para resolver esse problema, voc√™ pode usar o mecanismo de <em>trabalho</em> da <em>Web</em> .  Nesse caso, o esquema para trabalhar com fun√ß√µes WASM "pesadas" pode ser assim: </p><br><ol><li>  no script principal de um evento (por exemplo, clicando em um bot√£o), envie uma mensagem ao trabalhador com a tarefa de iniciar uma fun√ß√£o pesada. </li><li>   ,        . </li><li>      -   () </li></ol><br></li></ul><br><p>   WASM-         JS,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  WASM</a> .      -   (       ),     <code>HashMap</code>       ,     .    ( JS)    ,          /   . </p><br><p>       ,  <a href="">  Mutex</a> ,        thread-safe.       smart-    .   thread-safe     <em>Rc</em>  <em>Arc</em>  <em>RefCell</em>  <em>RwLock</em> .         :         30%.         <code>--features=threaded</code>      thread-safe ,     WASM-. </p><br><p>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6574</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">8098</a>    (     10 ): </p><br><div class="scrollable-table"><table><thead><tr><th> id </th><th> non-thread-safe </th><th> thread-safe </th><th> web-interface </th></tr></thead><tbody><tr><td> 6574 </td><td> 5.4 </td><td> 7.4 </td><td> 9.2 </td></tr><tr><td> 8098 </td><td> 21.5 </td><td> 28.4 </td><td> 29.9 </td></tr></tbody></table></div><br><p> ,   -    40..70% ,       ,      (32..37%)      thread-safe  ( <code>cargo build --release --features=threaded</code> ). </p><br><p>    Firefox 67.0  Chromium 74.0. </p><br><p> WASM-   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ).            <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://webpbn.com/</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://www.nonograms.org/</a> </p><br><h3 id="todo"> TODO </h3><br><ul><li><p> ""  /,  /    . </p><br></li><li><p>     ,     .      "" ,    ,        .      . </p><br></li><li><p>     (    ,      3600 ).  WASM     ,     (  ,   (!) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> ,   ,     WASM). ,  , -  ,       nonogrid  . </p><br></li><li><p>   .      : ,       ,      WASM   .    ,         ( )    ,    JS  ,      . </p><br></li><li><p>     JS.         backtrace,       . </p><br></li><li><p>        (     <a href="">TOML-</a> ) </p><br></li></ul><br><h2 id="itogi">  Sum√°rio </h2><br><ul><li><p>           ,    (, , etc). </p><br></li><li><p>   Rust  1-3     PyPy       1.5-2  (  ). </p><br></li><li><p>    Python  Rust  ,            Python (, , comprehensions),      Rust-. </p><br></li><li><p>   Rust  WebAssembly   .     Rust ,   WASM,      (     1.5  ). </p><br></li></ul><br><h2 id="osnovnye-istochniki">   </h2><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The 'pbnsolve' Paint-by-Number Puzzle Solver by Jan Wolter</a> and the <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">survey</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">The BGU Nonograms Project</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Solving Nonograms by combining relaxations</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">An Efficient Approach to Solving Nonograms</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Color and black and white Japanese crosswords on-line</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">      </a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">'Nonolib' library by Dr. Steven Simpson</a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Rust and WebAssembly</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt454586/">https://habr.com/ru/post/pt454586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt454574/index.html">Aprendizado de m√°quina em microfinan√ßas: construindo um modelo de pontua√ß√£o para clientes com um hist√≥rico de cr√©dito vazio</a></li>
<li><a href="../pt454576/index.html">Os autores do GandCrab param de trabalhar: eles alegam ter roubado o suficiente</a></li>
<li><a href="../pt454578/index.html">Como conectar a galeria PhotoSwipe no android webview</a></li>
<li><a href="../pt454582/index.html">O comprimento da matriz deve ser armazenado em uma vari√°vel local em C #?</a></li>
<li><a href="../pt454584/index.html">Escola de desenvolvimento de interfaces: an√°lise de tarefas para Minsk e um novo conjunto em Moscou</a></li>
<li><a href="../pt454588/index.html">A Gazprom Neft convida voc√™ a visitar: GPN Data Science Meetup</a></li>
<li><a href="../pt454590/index.html">Zimbra Collaboration Suite e controle m√≥vel com ABQ</a></li>
<li><a href="../pt454592/index.html">WAF atrav√©s dos olhos de hackers</a></li>
<li><a href="../pt454596/index.html">Modelos mentais em seguran√ßa da informa√ß√£o</a></li>
<li><a href="../pt454598/index.html">Arquitetura sem servidor e microsservi√ßos: a combina√ß√£o perfeita?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>