<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèª üññ üíë C√≥mo intent√© hacer un analizador est√°tico GLSL (y qu√© sali√≥ mal) üôáüèΩ ‚õπüèª üï≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una vez que me estaba preparando para Ludum Dare e hice un juego simple en el que usaba sombreadores de p√≠xeles (otros no fueron incorporados al motor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo intent√© hacer un analizador est√°tico GLSL (y qu√© sali√≥ mal)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428027/"><p>  Una vez que me estaba preparando para Ludum Dare e hice un juego simple en el que usaba sombreadores de p√≠xeles (otros no fueron incorporados al motor Phaser). </p><br><div class="spoiler">  <b class="spoiler_title">¬øQu√© son los sombreadores?</b> <div class="spoiler_text"><p>  Los sombreadores son programas similares a GLSL C que se ejecutan en una tarjeta gr√°fica.  Hay dos tipos de sombreadores, en este art√≠culo estamos hablando de sombreadores de p√≠xeles (tambi√©n son "fragmentos", sombreadores de fragmentos), que se pueden representar de manera muy aproximada en esta forma: </p><br><pre><code class="hljs lisp">color = pixelShader(<span class="hljs-name"><span class="hljs-name">x</span></span>, y, ...other attributes)</code> </pre> <br><p>  Es decir  Se ejecuta un sombreador para cada p√≠xel de la imagen de salida, determinando o refinando su color. <br>  Puede leer el art√≠culo introductorio en otro art√≠culo en el centro: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://habr.com/post/333002/</a> </p></div></div><br><p>  Despu√©s de la prueba, le tir√© el enlace a un amigo y recib√≠ de √©l una captura de pantalla con la pregunta "¬øes esto normal?" </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ys/ti/qp/ystiqpls-jpsxgixk9blbocn6u8.png"></div><br><p>  No, eso no era normal.  Despu√©s de mirar cuidadosamente el c√≥digo del sombreador, encontr√© un error de c√°lculo: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &lt; M) { realColor = mix(color1,color2, <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(<span class="hljs-number"><span class="hljs-number">1.</span></span> - t / R1, <span class="hljs-number"><span class="hljs-number">0.5</span></span>)); }</code> </pre> <br><p>  Porque  Como la constante R1 era menor que M, en algunos casos el resultado en el primer argumento de pow fue un n√∫mero menor que cero.  La ra√≠z cuadrada del n√∫mero negativo es algo misterioso, al menos para el est√°ndar GLSL.  Mi tarjeta de video no estaba confundida, y de alguna manera sali√≥ de esta posici√≥n (parece haber regresado de pow 0), pero result√≥ ser m√°s legible para un amigo. </p><br><p>  Y luego pens√©: ¬øpuedo evitar tales problemas en el futuro?  Nadie est√° a salvo de errores, especialmente aquellos que no se reproducen localmente.  No puede escribir pruebas unitarias para GLSL.  Al mismo tiempo, las transformaciones dentro del sombreador son bastante simples: multiplicaci√≥n, divisi√≥n, senos, cosenos ... ¬øEs realmente imposible rastrear los valores de cada variable y asegurarse de que bajo ninguna circunstancia vaya m√°s all√° de los l√≠mites permisibles de los valores? </p><br><p>  As√≠ que decid√≠ intentar hacer un an√°lisis est√°tico para GLSL.  Lo que surgi√≥ de esto: puedes leerlo debajo del corte. </p><br><p>  Te avisar√© de inmediato: no pude obtener ning√∫n producto terminado, solo un prototipo educativo. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-analiz">  An√°lisis preliminar </h2><br><p>  Habiendo estudiado un poco de los art√≠culos existentes sobre este tema (y descubr√≠ en el camino que el tema se llama An√°lisis de Rango de Valor), me alegr√© de tener GLSL y no otro idioma.  Juzga por ti mismo: </p><br><ul><li>  sin "din√°mica": referencias a funciones, interfaces, tipos inferidos autom√°ticamente, etc. </li><li>  sin manejo directo de memoria </li><li>  sin m√≥dulos, enlaces, enlace tard√≠o: el c√≥digo fuente completo del sombreador est√° disponible <br>  los rangos son generalmente conocidos por los valores de entrada </li><li>  pocos tipos de datos, y esos giran en torno a un flotador.  raramente se usan int / bool, y no es tan importante seguirlos </li><li>  raramente se usan ifs y bucles (debido a problemas de rendimiento).  los bucles, si se usan, a menudo son contadores simples para pasar por una matriz o repetir un cierto efecto varias veces.  Nadie escribir√° tal horror en GLSL (espero). </li></ul><br><pre> <code class="python hljs">//   - https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/RangeAnalysis.pdf k = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> k &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>: i = <span class="hljs-number"><span class="hljs-number">0</span></span> j = k <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; j: i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> j = j ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span> k = k + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  En general, dadas las limitaciones de GLSL, la tarea parece ser solucionable.  El algoritmo principal es el siguiente: </p><br><ol><li>  analiza el c√≥digo del sombreador y crea una secuencia de comandos que cambian los valores de cualquier variable </li><li>  conociendo los rangos iniciales para las variables, vaya a trav√©s de la secuencia, actualizando los rangos cuando cambian </li><li>  Si el rango viola cualquier l√≠mite dado (por ejemplo, un n√∫mero negativo puede llegar a pow, o algo mayor que 1 llegar√° al "color de salida" gl_FragColor en el componente rojo), debe mostrar una advertencia </li></ol><br><h2 id="ispolzuemye-tehnologii">  Tecnolog√≠as utilizadas </h2><br><p>  Aqu√≠ tuve una elecci√≥n larga y dolorosa.  Por un lado, mi √°mbito principal es verificar los sombreadores WebGL, entonces, ¬øpor qu√© no javascript para ejecutar todo en el navegador durante el desarrollo?  Por otro lado, he planeado salir de Phaser durante mucho tiempo y probar otro motor como Unity o LibGDX.  Tambi√©n habr√° sombreadores, pero JavaScript desaparecer√°. </p><br><p>  Y, por otro lado, la tarea se realiz√≥ principalmente para el entretenimiento.  Y el mejor entretenimiento del mundo es el zool√≥gico.  Por lo tanto: </p><br><ol><li>  An√°lisis de c√≥digo GLSL realizado en javascript.  Es solo que r√°pidamente encontr√© la biblioteca para analizar GLSL en AST, y la interfaz de usuario de prueba parece estar m√°s familiarizada con estar basada en la web.  AST se convierte en una secuencia de comandos, que se env√≠a a ... </li><li>  ... la segunda parte, que est√° escrita en C ++ y compilada en WebAssembly.  Decid√≠ de esta manera: si de repente quiero fijar este analizador a alg√∫n otro motor, con una biblioteca C ++, esto deber√≠a hacerse de la manera m√°s simple. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Algunas palabras sobre el kit de herramientas</b> <div class="spoiler_text"><ul><li>  Tom√© Visual Studio Code como IDE principal y, en general, estoy contento con √©l.  Necesito un poco de felicidad: lo principal es que Ctrl + Click deber√≠a funcionar y autocompletarse al escribir.  Ambas funciones funcionan bien tanto en C ++ como en JS.  Bueno, la capacidad de no cambiar diferentes IDEs entre ellos tambi√©n es excelente. </li><li>  para compilar C ++, WebAssembly usa la herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">cheerp</a> (es de pago, pero gratuita para proyectos de c√≥digo abierto).  No encontr√© ning√∫n problema con su uso, excepto que optimiz√≥ el c√≥digo bastante extra√±o, pero aqu√≠ no estoy seguro de qui√©n es la culpa: el cheerp en s√≠ o el compilador clang que usa. </li><li>  para pruebas unitarias en C ++ tom√≥ el viejo y bueno gtest </li><li>  para construir js en paquete tom√≥ algo de micro paquete.  √âl satisfizo mis requisitos "Quiero un paquete de 1 npm y un par de banderas de l√≠nea de comando", pero al mismo tiempo no sin problemas, por desgracia.  Digamos que watch falla en cualquier error al analizar JavaScript entrante con el mensaje <code>[Object object]</code> , lo que no ayuda mucho. </li></ul></div></div><br><p>  Todo, ahora puedes irte. </p><br><h2 id="korotko-o-modeli">  Brevemente sobre el modelo. </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ch/hf/8s/chhf8sgclvkleyx_kwasvr74hz8.png"></div><br><p>  El analizador guarda en la memoria una lista de variables que se encuentran en el sombreador, y para cada una almacena el rango de valores actual posible (como <code>[0,1]</code> o <code>[1,‚àû)</code> ). </p><br><p>  El analizador recibe un flujo de trabajo como este: </p><br><pre> <code class="hljs matlab">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> opCode: <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span> arguments: [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,-,-,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,-,-]</code> </pre> <br><p>  Aqu√≠ llamamos a la funci√≥n sin, las variables con id = 3 y 4 se alimentan a ella, y el resultado se escribe en las variables 1 y 2. Esta llamada corresponde al GLSL-th: </p><br><pre> <code class="hljs lisp">vec2 a = sin(<span class="hljs-name"><span class="hljs-name">b</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Tenga en cuenta los argumentos vac√≠os (marcados como "-").  En GLSL, casi todas las funciones integradas est√°n sobrecargadas para diferentes conjuntos de tipos de entrada, es decir.  hay <code>sin(float)</code> , <code>sin(vec2)</code> , <code>sin(vec3)</code> , <code>sin(vec4)</code> .  Por conveniencia, traigo todas las versiones sobrecargadas a una forma, en este caso <code>sin(vec4)</code> . </p><br><p>  El analizador genera una lista de cambios para cada variable, como </p><br><pre> <code class="hljs vhdl">cmdId: <span class="hljs-number"><span class="hljs-number">10</span></span> branchId: <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">variable</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">range</span></span>: [-<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  Lo que significa que "la variable 2 en la l√≠nea 10 en la rama 1 tiene un rango de -1 a 1 inclusive" (hablaremos de la rama un poco m√°s adelante).  Ahora puede resaltar hermosos rangos de valores en el c√≥digo fuente. </p><br><h2 id="horoshee-nachalo">  Buen comienzo </h2><br><p>  Cuando el √°rbol AST ya ha comenzado a convertirse en una lista de comandos, es hora de implementar funciones y m√©todos est√°ndar.  Hay muchos de ellos (y tambi√©n tienen un mont√≥n de sobrecargas, como escrib√≠ anteriormente), pero en general tienen transformaciones de rango predecibles.  Digamos, por ejemplo, que todo resulta bastante obvio: </p><br><pre> <code class="hljs ruby">uniform float angle; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; (-‚àû,‚àû) /<span class="hljs-regexp"><span class="hljs-regexp">/... float y = sin(angle); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [-1,1] float ynorm = 1 + y; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -&gt; [0,2] gl_FragColor.r = ynorm /</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>.; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> -&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vb/aj/0f/vbaj0fdcx0nnk3lc2qti7egg7yq.png"></div><br><p>  El canal rojo del color de salida est√° dentro del rango aceptable, no hay errores. </p><br><p>  Si cubre m√°s funciones incorporadas, entonces para la mitad de los sombreadores, tal an√°lisis es suficiente.  Pero, ¬øqu√© pasa con la segunda mitad, con condiciones, bucles y funciones? </p><br><h2 id="vetvleniya">  Ramas </h2><br><p>  Tomemos por ejemplo tal sombreador. </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D uSampler; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec2 uv; <span class="hljs-comment"><span class="hljs-comment">// [0,1] void main() { float a = texture2D(uSampler, uv).a; // -&gt; [0,1] float k; // -&gt; ? if (a &lt; 0.5) { k = a * 2.; } else { k = 1. - a; } gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  La variable <code>a</code> se toma de la textura y, por lo tanto, el valor de esta variable se encuentra entre 0 y 1. Pero, ¬øqu√© valores puede tomar <code>k</code> ? </p><br><p>  Puede seguir el camino simple y ‚Äúunir las ramas‚Äù: calcule el rango en cada uno de los casos y d√© el total.  Para la rama if, obtenemos <code>k = [0,2]</code> , y para la rama else, <code>k = [0,1]</code> .  Si combina, resulta <code>[0,2]</code> , y necesita dar un error, porque  los valores mayores que 1 caen en el color de salida de <code>gl_FragColor</code> . </p><br><p>  Sin embargo, esta es una falsa alarma clara, y para un analizador est√°tico no hay nada peor que las falsas alarmas: si no se apaga despu√©s del primer grito de "lobo", entonces seguramente despu√©s del d√©cimo. </p><br><p>  Por lo tanto, debemos procesar ambas ramas por separado, y en ambas ramas debemos aclarar el rango de la variable <code>a</code> (aunque formalmente no se ha cambiado).  As√≠ es como podr√≠a verse: </p><br><p>  Rama 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &lt; <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0, 0.5) k = a * 2.; //k = [0, 1) gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Rama 2: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= <span class="hljs-number"><span class="hljs-number">0.5</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//a = [0.5, 1] k = 1. - a; //k = [0, 0.5] gl_FragColor = vec4(1.) * k; }</span></span></code> </pre> <br><p>  Por lo tanto, cuando el analizador encuentra una determinada condici√≥n que se comporta de manera diferente seg√∫n el rango, crea ramas (brunches) para cada uno de los casos.  En cada caso, refina el rango de la variable fuente y se mueve hacia abajo en la lista de comandos. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n7/fp/dy/n7fpdy2xtg92oy5f0qsl7p8thz4.png"></div><br><p>  Vale la pena aclarar que las ramas en este caso no est√°n relacionadas con la construcci√≥n if-else.  Las ramas se crean cuando un rango de una variable se divide en subrangos, y la causa puede ser una declaraci√≥n condicional opcional.  Por ejemplo, la funci√≥n de paso tambi√©n crea ramas.  El siguiente sombreador GLSL hace lo mismo que el anterior, pero no usa ramificaci√≥n (que, por cierto, es mejor en t√©rminos de rendimiento). </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> k = mix(a * <span class="hljs-number"><span class="hljs-number">2</span></span>., <span class="hljs-number"><span class="hljs-number">1</span></span>. - a, step(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>, a)); <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = vec4(<span class="hljs-number"><span class="hljs-number">1</span></span>.) * k;</code> </pre> <br><p>  La funci√≥n de paso deber√≠a devolver 0 si a &lt;0.5 y 1 de lo contrario.  Por lo tanto, tambi√©n se crear√°n ramas aqu√≠, similar al ejemplo anterior. </p><br><h2 id="utochnenie-drugih-peremennyh">  Refinamiento de otras variables. </h2><br><p>  Considere un ejemplo anterior ligeramente modificado: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = texture2D(uSampler, uv).a; <span class="hljs-comment"><span class="hljs-comment">// -&gt; [0,1] float b = a - 0.5; // -&gt; [-0.5, 0.5] if (b &lt; 0.) { k = a * 2.; // k,a -&gt; ? } else { k = 1. - a; }</span></span></code> </pre> <br><p>  Aqu√≠ el matiz es el siguiente: la ramificaci√≥n ocurre con respecto a la variable <code>b</code> , y los c√°lculos ocurren con la variable <code>a</code> .  Es decir, dentro de cada rama habr√° un valor correcto del rango <code>b</code> , pero completamente innecesario, y el valor original del rango <code>a</code> , completamente incorrecto. </p><br><p>  Sin embargo, el analizador vio que el rango <code>b</code> se obtuvo calculando a partir de <code>a</code> .  Si recuerda esta informaci√≥n, cuando ramifica, el analizador puede revisar todas las variables de origen y refinar su rango realizando el c√°lculo inverso. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pi/lb/sz/pilbszwvjnellonuoosc_oux7wq.png"></div><br><h2 id="funkcii-i-cikly">  Funciones y bucles </h2><br><p>  GLSL no tiene m√©todos virtuales, punteros de funci√≥n o incluso llamadas recursivas, por lo que cada llamada de funci√≥n es √∫nica.  Por lo tanto, es m√°s f√°cil insertar el cuerpo de la funci√≥n en el lugar de la llamada (en l√≠nea, en otras palabras).  Esto ser√° completamente consistente con la secuencia de comandos. </p><br><p>  Es m√°s complicado con los ciclos, porque  formalmente, GLSL es totalmente compatible con el bucle C-like.  Sin embargo, con mayor frecuencia, los bucles se usan en la forma m√°s simple, como esta: </p><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) {}</code> </pre> <br><p>  Dichos ciclos son f√°ciles de "desplegar", es decir  inserte el cuerpo del bucle 12 veces uno tras otro.  Como resultado, despu√©s de pensarlo, hasta ahora decid√≠ apoyar solo esa opci√≥n. </p><br><p>  La ventaja de este enfoque es que los comandos se pueden emitir en un flujo al analizador sin requerir que memorice ning√∫n fragmento (como cuerpos de funciones o bucles) para su posterior reutilizaci√≥n. </p><br><h2 id="vsplyvshie-problemy">  Problemas emergentes </h2><br><h3 id="problema-1-slozhnost-ili-nevozmozhnost-utochneniya">  Problema # 1: dificultad o incapacidad para aclarar </h3><br><p>  Arriba, examinamos casos cuando, al refinar los valores de una variable, sacamos conclusiones sobre los valores de otra variable.  Y este problema se resuelve cuando se involucran operaciones como la suma / resta.  Pero, digamos, ¬øqu√© hacer con la trigonometr√≠a?  Por ejemplo, tal condici√≥n: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(a) &gt; <span class="hljs-number"><span class="hljs-number">0.</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    a? }</span></span></code> </pre> <br><p>  ¬øC√≥mo calcular el rango de <code>a</code> interior si?  Resulta un conjunto interminable de rangos con pasos pi, que luego ser√°n muy inconvenientes para trabajar. </p><br><p>  Y puede haber tal situaci√≥n: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a = getSomeValue(); <span class="hljs-comment"><span class="hljs-comment">// [-10,10] float b = getAnotherValue(); //[-20, 30] float k = a + b; if (k &gt; 0) { //a? b? }</span></span></code> </pre> <br><p>  Aclarar los rangos <code>b</code> en el caso general no ser√° realista.  Y, por lo tanto, los falsos positivos son posibles. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7e/z9/ea/7ez9eady082-nfgem7j0c65hslk.png"></div><br><h3 id="problema-2-zavisimye-diapazony">  Problema # 2: rangos dependientes </h3><br><p>  Considere este ejemplo: </p><br><pre> <code class="hljs pgsql">uniform <span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> //-&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { <span class="hljs-type"><span class="hljs-type">float</span></span> val2 = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - <span class="hljs-number"><span class="hljs-number">1.</span></span>; gl_FragColor = vec4(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> - val2); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/0m/jo/gh0mjodwd1oqeoh32mcdkollcyg.png"></div><br><p>  Para empezar, el analizador considera el rango de la variable <code>val2</code> , y se espera que sea <code>[0,1] - 1 == [-1, 0]</code> </p><br><p>  Sin embargo, entonces, considerando el <code>value - val2</code> , el analizador no tiene en cuenta que <code>val2</code> se obtuvo del <code>value</code> , y trabaja con rangos como si fueran independientes entre s√≠.  Obtiene <code>[0,1] - [-1,0] = [0,2]</code> e informa un error.  Aunque en realidad deber√≠a haber obtenido un 1 constante. </p><br><p>  Posible soluci√≥n: almacenar para cada variable no solo el historial de rangos, sino tambi√©n todo el ‚Äú√°rbol geneal√≥gico‚Äù: qu√© variables depend√≠an, qu√© operaciones, etc.  Otra cosa es que "desplegar" este pedigr√≠ no ser√° f√°cil. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/47/-_/qb/47-_qbz4nhcsbbfo_8wvtepll94.png"></div><br><h3 id="problema-3-diapazony-zavisimye-neyavno">  Problema # 3: rangos impl√≠citamente dependientes </h3><br><p>  Aqu√≠ hay un ejemplo: </p><br><pre> <code class="hljs lisp">float k = sin(<span class="hljs-name"><span class="hljs-name">a</span></span>) + cos(<span class="hljs-name"><span class="hljs-name">a</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Aqu√≠, el analizador supondr√° que el rango <code>k = [-1,1] + [-1,1] = [-2,2]</code> .  Lo cual est√° mal, porque  <code>sin(a) + cos(a)</code> para cualquier <code>a</code> encuentra en el rango <code>[-‚àö2, ‚àö2]</code> . </p><br><p>  El resultado de calcular <code>sin(a)</code> formalmente no depende del resultado de calcular <code>cos(a)</code> .  Sin embargo, dependen del mismo rango de <code>a</code> . </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pf/wz/ne/pfwznek8x2iguen0bhyx0thwjuq.png"></div><br><h2 id="itogi-i-vyvody">  Resumen y conclusiones </h2><br><p>  Al final result√≥ que, hacer un an√°lisis de rango de valores incluso para un lenguaje tan simple y altamente especializado como GLSL no es una tarea f√°cil.  La cobertura de las caracter√≠sticas del lenguaje a√∫n se puede fortalecer: admitir matrices, matrices y todas las operaciones integradas es una tarea puramente t√©cnica que simplemente requiere mucho tiempo.  Pero, ¬øc√≥mo resolver situaciones con dependencias entre variables? La pregunta todav√≠a no est√° clara para m√≠.  Sin resolver estos problemas, los falsos positivos son inevitables, cuyo ruido en √∫ltima instancia puede superar los beneficios del an√°lisis est√°tico. </p><br><p>  Dado lo que encontr√©, no estoy particularmente sorprendido por la ausencia de algunas herramientas bien conocidas para el an√°lisis del rango de valores en otros idiomas: claramente hay m√°s problemas en ellas que en el relativamente simple GLSL.  Al mismo tiempo, puede escribir al menos pruebas unitarias en otros idiomas, pero aqu√≠ no puede hacerlo. </p><br><p>  Una soluci√≥n alternativa podr√≠a ser la compilaci√≥n de otros idiomas en GLSL: aqu√≠ recientemente hubo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un art√≠culo sobre compilaci√≥n de kotlin</a> .  Luego puede escribir pruebas unitarias para el c√≥digo fuente y cubrir todas las condiciones de contorno.  O haga un "analizador din√°mico" que ejecute los mismos datos que van al sombreador a trav√©s del c√≥digo kotlin original y advierte sobre posibles problemas. </p><br><p>  Entonces en este punto me detuve.  La biblioteca, por desgracia, no funcion√≥, pero tal vez este prototipo sea √∫til para alguien. </p><br><p>  Repositorio en github, para su revisi√≥n: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/AlexeyGrishin/glsl-value-range-analysis</a> </li></ul><br><p>  Para probar: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://alexeygrishin.github.io/glsl-value-range-analysis/html/</a> </li></ul><br><h2 id="bonus-osobennosti-sborki-webassembly-s-raznymi-flagami-kompilyatora">  Bonificaci√≥n: caracter√≠sticas de ensamblaje web con diferentes indicadores de compilaci√≥n </h2><br><p>  Inicialmente, hice el analizador sin usar stdlib, a la antigua usanza, con matrices y punteros.  En ese momento estaba muy preocupado por el tama√±o del archivo wasm de salida, quer√≠a que fuera peque√±o.  Pero a partir de alg√∫n punto comenc√© a sentir incomodidad y, por lo tanto, decid√≠ transferir todo a stdlib: punteros inteligentes, colecciones normales, eso es todo. </p><br><p>  En consecuencia, tuve la oportunidad de comparar los resultados de ensamblaje de dos versiones de la biblioteca, con y sin stdlib.  Bueno, tambi√©n vea c√≥mo el buen / mal cheerp (y el sonido que usa) optimiza el c√≥digo. </p><br><p>  Por lo tanto, compil√© ambas versiones con diferentes conjuntos de indicadores de optimizaci√≥n ( <code>-O0</code> , <code>-O0</code> , <code>-O1</code> , <code>-O2</code> , <code>-Os</code> y <code>-Oz</code> ), y para algunas de estas versiones <code>-Oz</code> la velocidad de an√°lisis de 3000 operaciones con 1000 ramas.  Estoy de acuerdo, no es el mejor ejemplo, pero en mi humilde opini√≥n es suficiente para un an√°lisis comparativo. </p><br><p>  Lo que sucedi√≥ seg√∫n el tama√±o del archivo wasm: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qz/u9/sc/qzu9sc7tg2jdz7v5-zfbvceqkv8.png"></div><br><p>  Sorprendentemente, la opci√≥n de tama√±o con la optimizaci√≥n "cero" es mejor que casi todas las dem√°s.  Asumir√© que en <code>O3</code> una l√≠nea agresiva de todo en el mundo, que infla el binario.  La versi√≥n esperada sin stdlib es m√°s compacta, pero no tanto que <del>  soportar tal humillaci√≥n </del>  para privarse del placer de trabajar con colecciones convenientes. </p><br><p>  Por velocidad de ejecuci√≥n: </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/w_/dc/hs/w_dchsujm7zdc4rvzjsaiwpzeme.png"></div><br><p>  Ahora puedo ver que <code>-O3</code> no <code>-O3</code> en vano comer su pan, en comparaci√≥n con <code>-O0</code> .  Al mismo tiempo, la diferencia entre versiones con y sin stdlib est√° pr√°cticamente ausente (hice 10 mediciones, creo que con un n√∫mero mayor la diferencia desaparecer√≠a por completo). </p><br><p>  Vale la pena se√±alar 2 puntos: </p><br><ul><li>  El gr√°fico muestra los valores promedio de 10 ejecuciones consecutivas del an√°lisis, pero en todas las pruebas el primer an√°lisis dur√≥ 2 veces m√°s que el resto (es decir, 120 ms, y las siguientes ya estaban alrededor de 60 ms).  Probablemente hubo alguna inicializaci√≥n de WebAssembly. </li><li>  Con la bandera <code>-O3</code> , agarr√© algunos errores terriblemente extra√±os que no atrap√© para otras banderas.  Por ejemplo, las funciones min y max de repente comenzaron a funcionar de la misma manera, como min. </li></ul><br><h2 id="zaklyuchenie">  Conclusi√≥n </h2><br><p>  Gracias a todos por su atenci√≥n. <br>  Deje que los valores de sus variables nunca vayan m√°s all√° de los l√≠mites. <br>  Y aqui tienes. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es428027/">https://habr.com/ru/post/es428027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es428011/index.html">Canciones de zombies espaciales</a></li>
<li><a href="../es428019/index.html">Juega a Mortal Kombat con TensorFlow.js</a></li>
<li><a href="../es428021/index.html">Sellos contra la red neuronal. O seleccione y ejecute una red neuronal para reconocer objetos en Raspberry Zero</a></li>
<li><a href="../es428023/index.html">Conceptos b√°sicos de seguridad el√©ctrica en el dise√±o de dispositivos electr√≥nicos.</a></li>
<li><a href="../es428025/index.html">Conexi√≥n de un archivo de intercambio (SWAP) en MAC OS X cuando se utiliza un SSD externo como sistema</a></li>
<li><a href="../es428029/index.html">Eventos digitales en Mosc√∫ del 29 de octubre al 4 de noviembre.</a></li>
<li><a href="../es428031/index.html">Integraci√≥n de 3CX con 1C: Gesti√≥n de comercio: un m√©todo para combinar configuraciones</a></li>
<li><a href="../es428033/index.html">En los EE. UU., Legaliz√≥ la pirater√≠a de dispositivos inteligentes y computadoras de a bordo con el fin de reparar y actualizar</a></li>
<li><a href="../es428035/index.html">Red Hat ser√° absorbido por IBM</a></li>
<li><a href="../es428039/index.html">El gobierno no planea abogar por la neutralidad de la red</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>