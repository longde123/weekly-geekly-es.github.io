<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾 📕 🏧 Créer les bordures d'une carte générée de manière procédurale 👋🏿 🌫️ 👨‍👨‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Scott Turner continue de travailler sur son jeu généré de manière procédurale et a maintenant décidé de s'attaquer au problème de la conception des fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Créer les bordures d'une carte générée de manière procédurale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png" alt="image"></div><br>  <i>Scott Turner continue de travailler sur son jeu généré de manière procédurale et a maintenant décidé de s'attaquer au problème de la conception des frontières des cartes.</i>  <i>Pour ce faire, il doit résoudre plusieurs problèmes difficiles et même créer son propre langage pour décrire les frontières.</i> <br><br>  Les bordures sont restées un élément important des cartes fantaisie, qui figuraient sur ma liste depuis un certain temps.  Les cartes fonctionnelles ont généralement une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">frontière</a> simple, mais les cartes fantastiques et les cartes médiévales, dont les premières empruntent souvent des idées, ont des limites assez réfléchies et artistiques.  Ces limites indiquent clairement que la carte est intentionnellement rendue fantastique et donnent au spectateur un sentiment d'émerveillement. <br><br>  Il existe actuellement quelques façons simples de tracer des frontières dans mon jeu <b>Dragons Abound</b> .  Elle peut tracer une ligne simple ou double autour du périmètre de la carte et ajouter des éléments simples dans les coins, comme dans ces figures: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/9f8/477/aed9f8477ef53b5550b742ea1fde36b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br>  Le jeu peut également ajouter un champ au bas de la bordure pour le nom de la carte.  Il existe plusieurs variantes de ce domaine dans <b>Dragons Abound</b> , y compris des éléments complexes tels que les fausses têtes de vis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/f6f/c3a/42ff6fc3adae5b40293bb82d5a1be325.png"></div><br>  Il existe une variabilité dans ces champs de nom, mais ils sont tous créés manuellement. <br><br>  Un aspect intéressant des limites des cartes fantaisie est qu'elles sont à la fois créatives et modèles.  Souvent, ils se composent d'un petit nombre d'éléments simples qui se combinent de différentes manières pour créer un résultat unique.  Comme toujours, la première étape lorsque je travaille avec un nouveau sujet est d'étudier une collection d'exemples de carte, de créer un catalogue de types d'éléments de bordure et d'étudier leur apparence. <br><a name="habracut"></a><br>  La bordure la plus simple est une ligne longeant les bords de la carte et indiquant ses limites.  Comme je l'ai dit plus haut, on l'appelle aussi la "ligne de trame": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/c81/c98/99fc81c98e1092077272081464d28752.png"></div><br>  Il existe également une variation avec l'emplacement des bordures sur la carte.  Dans cette version, la carte atteint les bords de l'image, mais la bordure crée une bordure virtuelle à l'intérieur de l'image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/aef/1db/43faef1db7bf3af195c857d7ed673710.png"></div><br>  Cela peut être fait avec n'importe quel type de bordure, mais il n'est généralement utilisé qu'avec des bordures simples comme la bordure d'un cadre. <br><br>  Un concept de conception de cartes fantaisie populaire consiste à simuler comme si elles étaient dessinées sur un vieux parchemin déchiré.  Parfois, cela est réalisé en dessinant la bordure comme le bord rugueux du papier: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/cb2/ff1/907cb2ff125bbd178f9a16717e5e724f.png"></div><br>  Voici un exemple plus sophistiqué: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/751/860/d6e/751860d6e43ed2e857cf6f3ba7f766e0.png"></div><br>  D'après mon expérience, cette méthode est devenue moins populaire parce que des outils numériques sont entrés en service.  Si vous voulez que la carte ressemble à un vieux parchemin déchiré, il est plus facile de lui appliquer la texture du parchemin que de la dessiner à la main. <br><br>  L'outil le plus puissant pour créer des bordures de carte est la répétabilité.  Dans le cas le plus simple, il suffit de répéter une seule ligne pour créer deux lignes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/139/e12/31d139e129fe513e07937c5a2bd88979.png"></div><br>  Vous pouvez ajouter de l'intérêt à la carte en variant le style de l'élément répété, dans ce cas en combinant une seule ligne épaisse avec une seule ligne mince: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/ccd/118/530ccd11872f4aa6a32d4b3271cf94f3.png"></div><br>  Selon l'élément, différentes variantes de style sont possibles.  Dans cet exemple, la ligne se répète, mais la couleur change: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc7/89e/96c/fc789e96ccfba58ac4cb595e5ec33fb7.png"></div><br>  Pour créer des motifs plus complexes, vous pouvez utiliser la «répétabilité répétable».  Cette bordure se compose d'environ cinq lignes simples avec des largeurs et des distances différentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Cette bordure répète les lignes, mais les sépare de sorte qu'elles ressemblent à deux fines bordures distinctes.  Dans cette partie de l'article, je ne parlerai pas du traitement des angles, mais des angles différents pour les deux lignes contribuent également à créer cette différence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  S'agit-il de deux lignes, quatre ou six?  Je pense que tout dépend de la façon dont vous les dessinez! <br><br>  Un autre élément de stylisation consiste à remplir l'espace entre les éléments de couleur, de motif ou de texture.  Dans cet exemple, la bordure est devenue plus intéressante en raison du remplissage de couleur d'accentuation entre les deux lignes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/ccf/158/1d8ccf158b9ae0378ddaef1031ba15c9.png"></div><br>  Voici un exemple de la façon dont la bordure est remplie d'un motif: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f87/37d/bb2/f8737dbb215166947e42f0da1b45cfc7.png"></div><br>  De plus, les éléments peuvent être stylisés de manière à avoir une apparence tridimensionnelle.  Voici une carte dans laquelle la bordure est ombrée de sorte qu'elle semble volumineuse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/25b/695/a8025b69549773f8935d2b37680401a3.png"></div><br>  Dans cette carte, la bordure est ombrée pour avoir l'air en trois dimensions, et cela est combiné avec l'emplacement des bordures à l'intérieur des bords de la carte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/899/9e7/36c8999e74172c962aef40a4a9e3addc.png"></div><br>  Un autre élément de bordure commun est l'échelle sous la forme de rayures multicolores: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Ces rayures forment une grille ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">grille cartographique</a> ).  Sur les cartes réelles, l'échelle aide à déterminer les distances, mais sur les cartes fantastiques, c'est principalement un élément décoratif. <br><br>  Ces rayures sont généralement dessinées en noir et blanc, mais parfois du rouge ou une autre couleur est ajoutée: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/f0f/f67/450f0ff67ac1fdf5c5e2ffaf8fbe80c0.png"></div><br>  Cet élément peut également être combiné avec d'autres, comme dans cet exemple avec des lignes et une échelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/d56/29d/313d5629d6ec8b8d7c7c4c1ead322a09.png"></div><br>  Cet exemple est un peu inhabituel.  Généralement, l'échelle (le cas échéant) est l'élément le plus interne de la bordure. <br><br>  Sur cette carte, il existe différentes échelles avec différentes résolutions (ainsi que d'étranges notes runiques!): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/cd6/217/74bcd62173160e440a4ee6cfad2128c1.png"></div><br>  (Sur Reddit, l'utilisateur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AbouBenAdhem</a> m'a informé que les marques runiques sont des nombres 48 et 47 écrits en cunéiforme babylonien. De plus, les «échelles avec différentes résolutions» ont six divisions divisées en dix divisions plus petites, ce qui correspond au système de nombres hexadécimal babylonien. Habituellement J'indique les sources des cartes, mais il y a trop de petites pièces dans ce post, donc je n'ai pas pris la peine. Cependant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cette carte a été</a> créée par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Thomas Ray</a> pour l'auteur S.E.Boleyn, donc, peut-être, l'action dans ses livres se déroule dans l'entourage de Babylone.) <br><br>  En plus des lignes et de l'échelle, l'élément le plus courant est un motif géométrique répétitif.  Il se compose souvent de parties telles que des cercles, des losanges et des rectangles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/6ba/f61/31c6baf612bf2fa11a13905e4482d82e.png"></div><br>  Les éléments géométriques, comme les lignes, peuvent être ombrés pour leur donner un aspect tridimensionnel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/cc8/c33/43ecc8c33bbf3143ba32c18b878d16e2.png"></div><br>  Des frontières complexes peuvent être créées en combinant ces éléments de différentes manières.  Voici la bordure qui combine les lignes, les motifs géométriques et l'échelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Les exemples ci-dessus étaient des cartes numériques, mais, bien sûr, la même chose peut être faite avec des cartes manuscrites.  Voici un exemple d'un motif géométrique simple créé à la main: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f7/c2d/e3d/6f7c2de3d5db82a9c7e9884d726be98e.png"></div><br>  Ces éléments peuvent également être combinés de manière flexible de nombreuses manières.  Voici un motif géométrique combiné avec un «bord déchiqueté»: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/f1a/150/0faf1a15052e90a479428c4c495ad44c.png"></div><br>  Dans les exemples ci-dessus, le motif géométrique est assez simple.  Mais vous pouvez créer des motifs très complexes en combinant de manière différente les éléments géométriques de base: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/13f/fc2/38e13ffc2a2aac266aabb291a7d7f0e6.png"></div><br>  Un autre élément populaire du motif est le tissage ou le nœud celtique: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/00e/8d8/07e00e8d868b6ca48be746fbe07e61ca.png"></div><br>  Voici une bordure en osier plus complexe contenant la couleur, l'échelle et d'autres éléments: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Sur cette carte, le tissage est combiné avec un élément de bord déchiqueté: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/4df/588/e954df58825bc42d408b61804a1287a9.png"></div><br>  En plus des motifs géométriques et du tissage, tout motif répétitif peut faire partie de la bordure de la carte.  Voici un exemple utilisant des formes ressemblant à des pointes de flèches: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Et voici un exemple avec un motif d'onde répétitif: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/c13/3c2/841c133c2f1c0f724b5d076e5ea415fb.png"></div><br>  Et enfin, des runes ou d'autres éléments de l'alphabet fantastique sont parfois ajoutés aux bords des cartes fantaisie: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Les exemples ci-dessus sont tirés de cartes fantastiques modernes, mais voici un exemple de carte historique (XVIIIe siècle) avec des lignes et un motif dessiné à la main: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/b9f/3b8/1d7b9f3b8f0c7eb296079c5f6f6b23aa.png"></div><br>  Bien sûr, vous pouvez trouver des exemples de cartes avec de nombreux autres éléments sur les bordures.  Certaines des plus belles sont entièrement dessinées à la main et ont des décorations si soigneusement conçues qu'elles peuvent surpasser la carte elle-même ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">World of Alma</a> , Francesca Baerald): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/004/e18/1c7004e186e0d2be63b98539375316ff.png"></div><br>  Cela vaut également la peine de parler de <i>symétrie</i> .  Comme la répétabilité, la symétrie est un outil puissant et les bordures de carte sont généralement symétriques ou comportent des éléments symétriques. <br><br>  De nombreuses bordures de carte sont symétriques de l'intérieur vers l'extérieur, comme dans cet exemple: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br>  Ici, la bordure est composée de plusieurs lignes avec et sans remplissage, mais de l'extérieur vers l'intérieur, elle se répète idéalement par rapport au centre de la bordure. <br><br>  Dans cet exemple plus complexe, la bordure est symétrique, à l'exception de l'alignement des bandes noires et blanches d'échelle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br>  Étant donné que la duplication de l'échelle n'a pas de sens, elle est souvent considérée comme un élément distinct, même si le reste de la bordure est symétrique. <br><br>  En plus de la symétrie interne-externe, les bordures sont souvent resymétriques sur toute leur longueur.  Certaines bordures illustrées peuvent avoir un design simple qui s'étend sur toute la longueur du bord de la carte, mais dans la plupart des cas, le motif est assez court et se répète, remplissant la bordure d'un coin à l'autre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Notez que dans cet exemple, le motif contient un élément qui n'est pas symétrique (de gauche à droite), mais le motif général est symétrique et se répète: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Une exception notable à cette règle est les bordures remplies de runes ou de caractères alphabétiques.  Souvent, ils se révèlent uniques, comme si un long message était écrit le long de la frontière: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  Bien sûr, il existe de nombreux autres exemples d'éléments de bordure de carte que je n'ai pas examinés ici, mais nous avons déjà un bon point de référence.  Dans les prochaines parties, je développerai plusieurs fonctions dans <b>Dragons Abound</b> pour décrire, afficher et générer des bordures de carte de manière similaire à ces exemples.  Dans la deuxième partie, nous commencerons par définir le langage de description des bordures des cartes. <br><br><h2>  2e partie </h2><br>  Dans cette partie, je vais créer la version initiale du Map Border Description Language (MBDL). <br><br>  Pourquoi passer du temps à créer un langage de description de limites de carte?  Premièrement, ce sera l'objectif de ma génération procédurale.  Plus tard, j'écrirai un algorithme pour créer de nouvelles bordures de carte, et la sortie de cet algorithme sera une description de la nouvelle bordure sur MBDL.  Deuxièmement, MBDL servira de représentation textuelle des limites de la carte.  En particulier, je dois pouvoir sauvegarder et réutiliser mes limites.  Pour ce faire, j'ai besoin d'une notation de texte qui peut être écrite et utilisée pour recréer la bordure de la carte. <br><br>  Je vais commencer à créer MBDL en définissant l'élément le plus simple: la ligne.  La ligne a une couleur et une largeur.  Par conséquent, dans MBDL, je présenterai la ligne sous cette forme: <br><br><blockquote><code>L(width, color)</code> </blockquote> <br>  Voici quelques exemples (désolé pour mes compétences Photoshop): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/db8/68e/db2db868ede7282a34c695f8062a691b.png"></div><br>  La séquence d'éléments est rendue de l'extérieur vers l'intérieur (*), nous supposons donc que c'est la bordure en haut de la carte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/75e/b3a/b7c75eb3aefb8f77d1915166c0bdd979.png"></div><br>  Regardez le deuxième exemple - une ligne avec des bordures est représentée comme trois éléments de ligne distincts. <br><br>  <i>(* Dessiner de l'extérieur vers l'intérieur était un choix arbitraire - il me semblait juste que c'était plus naturel que de rendre de l'intérieur vers l'extérieur. Malheureusement, comme cela s'est avéré beaucoup plus tard, il y avait une bonne raison de travailler dans la direction opposée. Bientôt je vais vous en parler, mais tout est laissé dans le post - ancien, car il faudrait beaucoup de temps pour refaire toutes les illustrations)</i> <br><br>  De manière pratique, les espaces peuvent être représentés sous forme de lignes sans couleur: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/1a4/171/0ba1a41719610641d7b5a5e26da0692e.png"></div><br>  Mais il serait plus visuel d'avoir un élément d'espace vertical spécifique: <br><br><blockquote>  VS (largeur) </blockquote><br>  Les éléments simples suivants sont des formes géométriques: rayures, losanges et ellipses.  Il est supposé que les lignes sont étirées sur toute la longueur de la bordure, de sorte qu'elles n'ont pas de longueur explicitement spécifiée.  Mais les figures géométriques ne peuvent pas remplir toute la ligne.Par conséquent, en plus de la largeur (*), chacune doit avoir une longueur, une couleur de contour, une largeur de contour et une couleur de remplissage: <br><br><blockquote> <code>B(width, length, outline, outline width, fill) <br> D(width, length, outline, outline width, fill) <br> E(width, length, outline, outline width, fill)</code> </blockquote> <br>  (* J'ai accepté de considérer la largeur dans la direction de l'extérieur vers l'intérieur, et la longueur est mesurée le long de la bordure.) <br><br>  Voici des exemples de formes géométriques simples: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/fad/cf6/a3dfadcf6a5a98a9785b0b487a6e17fc.png"></div><br>  Pour que ces éléments remplissent toute la longueur de la bordure, ils doivent être répétés.  Pour indiquer le groupe d'éléments qui seront répétés pour remplir la longueur de la bordure, j'utilise des crochets: <br><br><blockquote> <code>[ element element element ... ]</code> </blockquote> <br>  Voici un exemple d'un motif répétitif de rectangles et de losanges: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Parfois, j'ai besoin d'un espace (horizontal) entre les éléments d'un motif répétitif.  Bien que vous puissiez utiliser un élément sans couleurs pour créer un espace, il sera plus intelligent et plus pratique d'avoir un élément d'espace horizontal: <br><br><blockquote> <code>HS(length)</code> </blockquote> <br>  La dernière fonction requise pour cette première itération de MBDL est la possibilité d'empiler des éléments les uns sur les autres.  Voici un exemple de bordure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/7e9/3f3/8ea7e93f3040563ef7ec2715ca39a14d.png"></div><br>  La façon la plus simple de le décrire est une large ligne jaune sous le motif supérieur.  Vous pouvez implémenter cela de différentes manières (par exemple, un espace vertical négatif), mais j'ai décidé d'utiliser des accolades pour indiquer l'ordre des éléments vers l'intérieur: <br><br><blockquote> <code>{element element element ...}</code> </blockquote> <br>  En fait, cette entrée vous indique de vous rappeler où se trouvait le motif de l'extérieur vers l'intérieur lorsque vous entrez les crochets, puis de revenir à ce point lorsque vous quittez les crochets.  Les parenthèses peuvent également être considérées comme une description des éléments occupant un espace vertical.  Par conséquent, la bordure illustrée ci-dessus peut être décrite comme suit: <br><br><blockquote> <code><b>L(1, black) <br> {L(20, yellow)} <br> VS(3) <br> [B(5, 10, black, 3, none) <br> D(5, 10, black,3,red)] <br> VS(3) <br> L(1, black)</b></code> </blockquote> <br>  Nous dessinons une ligne noire, fixons où nous sommes, dessinons une ligne jaune, puis revenons à la position précédemment fixée, descendons un peu, dessinons un motif de rectangles et de losanges, descendons un peu, puis dessinons une autre ligne noire. <br><br>  Il y a beaucoup plus à faire dans MBDL, mais cela suffit pour décrire les nombreuses limites des cartes.  L'étape suivante consiste à convertir la description des limites du MBDL en bordure elle-même.  Cela revient à convertir une représentation écrite d'un programme informatique (tel que Javascript) en exécution de ce programme.  La première étape est l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">analyse lexicale (analyse) de la</a> langue - la transformation du texte source en une véritable bordure de la carte ou en une sorte de forme intermédiaire, qui est plus facile à convertir en bordure. <br><br>  L'analyse est un domaine assez bien étudié de l'informatique.  L'analyse d'un langage n'est pas très simple, mais dans notre cas, il est bon (*) que MBDL soit une grammaire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sans</a> contexte.  Les grammaires sans contexte sont analysées assez facilement, et il existe de nombreux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">outils d'analyse Javascript</a> pour elles.  Je me suis installé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nearley.js</a> , qui semble être assez mature et (plus important encore) un outil bien documenté. <br><br>  <i>(* Ce n'est pas seulement de la chance, je me suis assuré que la langue était hors contexte.)</i> <br><br>  Je ne vais pas vous présenter les grammaires sans contexte, mais la syntaxe Nearley est assez simple et vous devez comprendre le sens sans aucun problème.  La grammaire Nearley consiste en un ensemble de règles.  Chaque règle a un caractère à gauche, une flèche et la partie droite de la règle, qui peut être une séquence de caractères et de non-caractères, ainsi que diverses options séparées par le "|"  (ou): <br><br><blockquote> <code><b>border -&gt; element | element border <br> element -&gt;</b> “ <b>L"</b></code> </blockquote> <br>  Chacune des règles stipule que le côté gauche peut être remplacé par l'une des options du côté droit.  Autrement dit, la première règle dit qu'une bordure est un élément, ou un élément, suivie d'une autre bordure.  Qui lui-même peut être un élément, ou un élément suivi d'une bordure, etc.  La deuxième règle dit qu'un élément ne peut être qu'une chaîne "L".  Autrement dit, ensemble, ces règles correspondent à ces limites: <br><br><blockquote> <code><b>L <br> LLL</b></code> </blockquote> <br>  et ne correspondent pas à de telles limites: <br><br><blockquote> <code><b>X <br> L3L</b></code> </blockquote> <br>  Soit dit en passant, si vous souhaitez expérimenter cette grammaire (ou toute autre) dans Nearley, il existe un bac à sable en ligne <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> .  Vous pouvez entrer des cas de grammaire et de test pour voir ce qui correspond et ne correspond pas. <br><br>  Voici une définition plus complète d'une primitive de ligne: <br><br><blockquote> <code><b>@builtin “number.ne" <br> @builtin “string.ne" <br> border -&gt; element | element border <br> element -&gt; “L(" decimal “," dqstring “)"</b></code> </blockquote> <br>  Nearley a plusieurs éléments intégrés communs, et le nombre est l'un d'entre eux.  Par conséquent, je peux l'utiliser pour reconnaître la largeur numérique d'une primitive de ligne.  Pour la reconnaissance des couleurs, j'utilise un autre élément intégré et autorise l'utilisation de n'importe quelle chaîne entre guillemets. <br><br>  Ce serait bien d'ajouter des espaces entre différents personnages, alors faisons-le.  Nearley prend en charge les classes de caractères et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RBNF</a> pour «zéro ou plus» de quelque chose avec «: *», donc je peux l'utiliser pour spécifier «zéro ou plusieurs espaces» et le coller n'importe où pour autoriser les espaces dans les descriptions: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element border <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")"</b></code> </blockquote> <br>  Cependant, l'utilisation de WS partout rend la lecture de la grammaire difficile, donc je vais les abandonner, mais imaginez qu'ils le sont. <br><br>  Un élément peut également être un espace vertical: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")"</b></code> </blockquote> <br>  Cela correspond à ces limites <br><br><blockquote> <code><b>L(3.5,"black") VS(3.5)</b></code> </blockquote> <br>  Viennent ensuite les primitives de bande, losange et ellipse. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")"</b></code> </blockquote> <br>  Il correspondra à ces éléments <br><br><blockquote> <code><b>B(34, 17, "white", 3, "black")</b></code> </blockquote> <br>  (Notez que les primitives géométriques ne sont pas des «éléments» car elles ne peuvent pas être seules au niveau supérieur. Elles doivent être entourées d'un motif.) <br><br>  J'ai aussi besoin d'une primitive d'espace horizontal: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Maintenant, je vais ajouter une opération de répétition de motif.  Il s'agit d'une séquence d'un ou plusieurs éléments entre crochets.  J'utiliserai l'opérateur RBNF ": +", qui signifie ici "un ou plusieurs". <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric):+ "]"</b></code> </blockquote> <br>  Notez que le motif ne peut être rempli qu'avec des primitives géométriques.  Nous ne pouvons pas, par exemple, placer une ligne à l'intérieur d'un motif.  L'élément pattern va maintenant correspondre à quelque chose comme ça. <br><br><blockquote> <code><b>[B(34,17,"white",3,"black")E(13,21,"white",3,"rgb(27,0,0)")]</b></code> </blockquote> <br>  La dernière partie du langage est l'opérateur de superposition.  Il s'agit d'un nombre quelconque d'éléments entre accolades. <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric ):+ "]" <br> element -&gt; "{" (element ):+ "}"</b></code> </blockquote> <br>  ce qui nous permet de faire ce qui suit: <br><br><blockquote> <code><b>{L(3.5,"rgb(98,76,15)")VS(3.5)}</b></code> </blockquote> <br>  (Notez que contrairement à l'opérateur de répétition, l'opérateur de superposition peut être utilisé en interne.) <br><br>  Après avoir nettoyé la description et ajouté des espaces aux endroits nécessaires, nous obtenons la grammaire MBDL suivante: <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> element -&gt; "(" WS (element WS):+ ")" <br> element -&gt; "[" WS (geometric WS):+ "]" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br>  Ainsi, MBDL est maintenant défini et nous avons créé une grammaire du langage.  Il peut être utilisé avec Nearley pour reconnaître les chaînes de langue.  Avant de plonger dans MBDL / Nearley, je voudrais implémenter les primitives utilisées dans MBDL afin que la frontière décrite sur MBDL puisse être affichée.  C'est ce que nous ferons dans la partie suivante. <br><br><h2>  3e partie </h2><br>  Nous allons maintenant commencer à implémenter les primitives de rendu elles-mêmes.  (À ce stade, je n'ai pas encore besoin de lier l'analyseur aux primitives de rendu. Pour les tests, je vais simplement les appeler manuellement.) <br><br>  Commençons par la ligne primitive.  Rappelez-vous à quoi ça ressemble: <br><br><blockquote> <code><b>L(width, color)</b></code> </blockquote> <br>  En plus de la largeur et de la couleur, il existe un paramètre implicite ici - la distance par rapport au bord extérieur de la carte.  (Je dessine les bordures du bord de la carte vers l'extérieur. Notez que nous sommes partis d'une autre!) Il ne doit pas pointer vers le MBDL, car cela peut être suivi par l'interpréteur qui exécute le MBDL pour dessiner la frontière.  Cependant, cela doit être entré pour toutes les primitives de rendu afin qu'elles sachent où les dessiner.  J'appellerai ce paramètre offset. <br><br>  Si je n'avais besoin que de tracer une bordure en haut de la carte, la primitive de ligne serait très simple à mettre en œuvre.  Cependant, en fait, je devrai tirer d'en haut.  en bas, à gauche et à droite.  (Peut-être qu'un jour je réaliserai des bordures obliques ou courbes, mais pour l'instant nous respecterons les bordures rectangulaires standard.) De plus, la longueur et l'emplacement de l'élément de ligne dépendent de la taille de la carte (ainsi que du décalage).  Par conséquent, en tant que paramètres, j'ai besoin de toutes ces données. <br><br>  Après avoir défini tous ces paramètres, il suffit de créer simplement une primitive de ligne et de l'utiliser pour tracer une ligne autour de la carte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a56/74f/785/a5674f78512bef22e569656701203401.png"></div><br>  (Notez que j'utilise diverses fonctions de <b>Dragons Abound</b> pour tracer la ligne «manuscrite».) Essayons de créer une bordure plus complexe: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black)</b></code> </blockquote> <br>  Cela ressemble à ceci: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86a/ad8/849/86aad88494c1c17f993524ef09ef9b2f.png"></div><br>  Assez bien.  Notez qu'il existe des endroits où les lignes noires et la ligne dorée ne sont pas tout à fait alignées en raison des fluctuations.  Si je veux me débarrasser de ces taches, vous pouvez simplement réduire la quantité d'oscillation. <br><br>  L'implémentation d'une primitive d'espace vertical est assez simple;  il effectue juste un incrément de décalage.  Ajoutons un peu d'espace: <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black) <br> VS(5) <br> L(3, black) L(10, red) L(3, black)</b></code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eab/471/b90/eab471b902eb44e703f460d700936937.png"></div><br>  Lorsque vous dessinez des lignes, des angles peuvent être obtenus en dessinant entre le décalage et le dessin le long de la carte dans le sens horaire.  Mais en général, je dois implémenter la troncature de chaque côté de la bordure de la carte pour créer une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">connexion angulaire avec un biseau</a> .  Cela sera nécessaire pour créer des bordures avec des motifs correctement joints aux coins et, dans le cas général, éliminera la nécessité de dessiner des éléments avec des bords à un angle qui serait autrement requis.  (*) <br><br>  <i>(Remarque: comme cela sera dit dans les parties suivantes, au fil du temps, j'ai refusé d'utiliser des régions de troncature lors de la mise en œuvre des angles. La principale raison est que pour créer des angles complexes, par exemple, des décalages carrés:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  <i>des zones de troncature de plus en plus complexes sont nécessaires.</i>  <i>De plus, au fil du temps, j'ai trouvé une meilleure façon de travailler avec des motifs dans les coins.</i>  <i>Au lieu de retourner et de réécrire cette partie de l'article, j'ai décidé de la laisser pour illustrer le processus de «créativité».)</i> <br><br>  L'idée principale est de tronquer chaque bordure en diagonale et de créer quatre zones tronquées dans lesquelles chaque côté de la bordure sera tracé: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/31a/cf9/9fb31acf993cde46b6a7fdc408be6afd.png"></div><br>  Lors de la troncature, tout ce qui est dessiné dans la zone correspondante sera coupé à l'angle souhaité. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/52b/f00/f02/52bf00f026f6979f6425345389fa646a.png"></div><br>  Malheureusement, cela crée de petits espaces le long des lignes diagonales, probablement parce que le navigateur effectue imparfaitement le lissage le long du bord tronqué.  Le test a montré qu'un arrière-plan brille à travers l'espace entre les deux bords.  Il était possible de résoudre ce problème en développant un peu un des masques (la moitié du pixel semble être suffisant), mais cela ne résout pas toujours le problème. <br><br>  Ensuite, vous devez implémenter des formes géométriques.  Contrairement aux lignes, elles sont répétées dans le motif, remplissant le côté de la bordure de la carte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br>  Une personne dessine ce motif de gauche à droite, dessine un rectangle, un losange, puis répète la même chose jusqu'à ce que toute la bordure soit remplie.  Par conséquent, cela peut également être implémenté dans le programme en dessinant un motif le long de la bordure.  Cependant, il sera plus facile de dessiner d'abord tous les rectangles, puis tous les losanges.  Il suffira de dessiner le long de la bordure la même figure géométrique à intervalles.  Et il est très pratique que chaque élément ait le même intervalle.  Bien sûr, une personne ne le ferait pas, car il est trop difficile de ranger les éléments aux bons endroits, mais ce n'est pas un problème pour le programme. <br><br>  En d'autres termes, la procédure de dessin de formes géométriques simples nécessite des paramètres dans lesquels toutes les tailles et couleurs de la figure sont transmises (c'est-à-dire largeur, longueur, épaisseur de ligne, couleur de ligne et remplissage), ainsi que la position de départ (qui, pour des raisons qui deviendront claires bientôt, Je considérerai le centre de la figure), l'intervalle d'espace horizontal pour la transition entre les répétitions et le nombre de répétitions.  Il sera également pratique d'indiquer la direction de répétition sous la forme du vecteur [dx, dy], afin que nous puissions effectuer des répétitions de gauche à droite, de droite à gauche, de haut en bas, en changeant simplement le vecteur et le point de départ.  Assemblez le tout et obtenez une bande de formes répétitives: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bcd/c33/409bcdc33756610ac6ace2d0fde0a3a4.png"></div><br>  En utilisant ce code plusieurs fois et en effectuant le rendu avec le même décalage, je peux combiner les bandes noires et blanches pour créer l'échelle de la carte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/8f5/0d9/b888f50d9f164b9319cc8b3cf8d38588.png"></div><br>  Avant de commencer à comprendre comment appliquer tout cela à la bordure réelle de la carte, implémentons d'abord la même fonctionnalité pour les ellipses et les losanges. <br><br>  Les losanges ne sont que des rectangles avec des sommets pivotés, vous n'avez donc qu'à apporter une petite modification au code.  Il s'est avéré que je n'ai toujours pas de code prêt à l'emploi pour le rendu de l'ellipse, mais il est très facile de prendre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vue paramétrique de l'ellipse</a> et de créer une fonction me donnant les points de l'ellipse: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fa/74e/079/3fa74e079dd2c29afa5acb0135d4092f.png"></div><br>  Voici un exemple (créé manuellement) qui utilise les fonctionnalités implémentées ci-dessus: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/bf2/d39/bf8bf2d3992b34bc173622dc86c0d8b5.png"></div><br>  Pour une si petite quantité de code, ça a l'air plutôt bien! <br><br>  Résolvons maintenant le cas complexe des bordures avec des éléments répétitifs: les coins. <br><br>  S'il existe une bordure avec des éléments répétitifs, il existe plusieurs façons de résoudre le problème des coins.  La première consiste à ajuster les répétitions afin qu'elles soient exécutées dans les coins sans mariage notable: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Une autre option consiste à arrêter la répétition quelque part près du coin des deux côtés.  Cela est souvent fait si le motif ne peut pas être facilement «tourné» dans le coin: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br>  La dernière option consiste à fermer le motif avec une décoration d'angle: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br>  Un jour, j'arriverai aux décorations d'angle, mais pour l'instant, nous utiliserons la première option.  Comment faire tourner un motif de rayures ou de cercles dans les coins de la carte sans espaces? <br><br>  L'idée principale est de placer l'élément de motif exactement dans le coin de sorte que la moitié de celui-ci se trouve sur un bord de la carte et l'autre sur celui adjacent.  Dans cet exemple, le cercle est exactement dans le coin et peut être tracé dans n'importe quelle direction: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br>  Dans d'autres cas, l'élément est à moitié dessiné dans une direction et à moitié dans l'autre, mais les bords coïncident: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br>  Dans ce cas, une bande blanche est dessinée des deux côtés, mais est connectée dans le coin sans espaces. <br><br>  Il y a deux aspects à considérer lors du placement d'un élément dans un coin. <br><br>  Tout d'abord, l'élément d'angle sera divisé et mis en miroir par rapport à la diagonale passant par le centre de l'élément.  Les éléments à symétrie radiale, par exemple les carrés, les cercles et les étoiles, ne changeront pas de forme.  Les éléments sans symétrie radiale, par exemple les rectangles et les losanges, changeront de forme lors de la symétrie par rapport à la diagonale. <br><br>  Deuxièmement, pour que les éléments d'angle des deux côtés se connectent correctement, il doit y avoir un nombre entier d'éléments (*) le long des deux côtés de la carte.  Ils ne doivent pas nécessairement être le même nombre, mais il doit y avoir un nombre entier d'éléments des deux côtés.  Si un nombre fractionnaire de motifs est contenu sur un côté, alors d'un côté le motif ne coïncidera pas avec le côté adjacent. <br><br>  <i>(* Dans certains cas, par exemple, avec de longues rayures, une répétition partielle peut se produire avec une répétition complète et les éléments seront toujours alignés. Cependant, l'élément d'angle résultant sera asymétrique et différera en longueur du même élément sur les côtés de la carte. Un exemple de cela peut être vu ici:</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/418/110/263418110aafe94ef8c62d57e8540371.png"></div><br>  <i>Une barre d'échelle blanche apparaît avec différentes répétitions partielles et, par conséquent, un élément décalé par rapport au centre est obtenu.</i>  <i>Pour l'échelle de la carte, ce n'est pas toujours le cas, car elle montre la distance absolue et n'a pas besoin d'être symétrique.</i>  <i>Mais pour un motif décoratif, cela semble généralement mauvais.)</i> <br><br>  Voici un exemple montrant comment un nombre entier de répétitions est coupé exactement dans le coin: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/8de/0a3/8ab8de0a3452332e2813b3771091b165.png"></div><br>  Si vous faites la même chose des quatre côtés, les coins coïncideront et le motif sera parfaitement situé sur toute la longueur de la bordure: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/c9a/e46/dfcc9ae46a68807e983705e553aa2ba3.png"></div><br>  Après un examen attentif, vous remarquerez que le motif ne se produit pas exactement dans les coins.  La moitié du cercle dans chaque coin est prise de chaque côté, et ces deux moitiés sont dessinées indépendamment à la main, elles ne sont donc pas parfaites.  Mais maintenant, ils sont assez proches de cela. <br><br>  Ainsi, nous pouvons réaliser une connexion parfaite du motif dans les coins, en choisissant un nombre entier de répétitions pour chaque bord.  Cependant, la solution à ce problème n'est pas anodine. <br><br>  Supposons d'abord que nous savons que le côté mesure 866 pixels et que nous voulons répéter l'élément 43 fois.  Ensuite, l'élément doit être répété tous les 20,14 pixels.  Comment définir la longueur spécifique d'un élément (et dans le cas général, un modèle d'éléments)?  Dans l'exemple ci-dessus, j'ai ajouté un espace supplémentaire entre les cercles.  Mais si les cercles se touchaient initialement, cela changera le schéma.  Peut-être vaut-il la peine d'étirer les cercles pour qu'ils continuent à se toucher? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/2b0/ebd/e362b0ebd3fd04e5d8b00de5d3aba151.png"></div><br>  Maintenant, les éléments se touchent, mais les cercles se sont transformés en ellipses et les coins ont une forme étrange.  (Rappelez-vous, j'ai dit que les éléments sans symétrie radiale changent de forme lorsqu'ils sont réfléchis par rapport à un angle? Pour les rayures, ce ne sera pas un gros problème.) Ou, peut-être, cela vaut la peine de compresser tous les éléments afin qu'ils se touchent et s'adaptent dans une longueur appropriée: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/ba8/0af/d7cba80afb431dc6c9afc52d7ad94b5c.png"></div><br>  Mais pour réaliser cela, nous devons rendre les éléments beaucoup plus petits qu'ils ne l'étaient à l'origine.  Aucune de ces options ne semble parfaite. <br><br>  Le deuxième problème se produit lorsque les côtés de la carte sont de tailles différentes.  Maintenant, nous devons résoudre le problème de trouver un nombre entier de répétitions adapté aux deux côtés.  Il serait idéal de trouver une solution adaptée aux deux côtés.  Mais je ne veux pas faire cela au prix d'un changement de modèle trop important.  Il peut être préférable de créer des motifs légèrement différents des deux côtés s'ils sont tous les deux suffisamment proches du motif d'origine. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Et enfin, le troisième problème se pose lorsque j'utilise la fonction de superposition de plusieurs éléments les uns sur les autres: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4ed/6ac/4d94ed6acf107193f2109bd2b2f07a67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je ne veux pas apporter de modifications au modèle qui détruirait la relation entre les éléments. </font><font style="vertical-align: inherit;">Je pense qu'avec une mise à l'échelle correcte, les ratios dans leur ensemble resteront, mais je dois tester cela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tâche intéressante, non? </font><font style="vertical-align: inherit;">Jusqu'à présent, je n'ai pas de solutions de haute qualité pour elle. </font><font style="vertical-align: inherit;">Peut-être qu'ils apparaîtront plus tard!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partie 4 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons donc implémenté des primitives pour dessiner des lignes et des formes géométriques. J'ai commencé à travailler sur l'utilisation de formes répétitives pour remplir les bordures et j'ai parlé des difficultés à placer des motifs arbitraires sur la bordure de la carte afin qu'ils s'adaptent parfaitement dans les coins. Le problème principal est que dans le cas général, vous devez allonger (ou raccourcir) le motif pour qu'il s'adapte latéralement. Les options pour changer la longueur du motif - ajouter ou supprimer des espaces, changer la longueur des éléments des motifs - entraînent divers changements dans le motif lui-même. Il semble que la tâche de sélectionner un motif à partir de plusieurs éléments soit très difficile!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque je rencontre des tâches apparemment sans compromis, j'aime commencer par implémenter une version simple. Les tâches infructueuses peuvent souvent être résolues en résolvant à plusieurs reprises des problèmes «simples» jusqu'à ce que le résultat soit suffisamment bon. Et parfois, la mise en œuvre d'une version simple donne une certaine compréhension qui simplifie la solution d'un problème plus complexe. Si cela ne s'améliore pas et que le problème reste inconfortable, alors nous aurons au moins une version simplifiée qui peut toujours être utile, bien que pas tout à fait comme il se doit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le moyen le plus simple consiste à modifier la longueur du motif en ajoutant des longueurs sans rien changer au motif. </font><font style="vertical-align: inherit;">Essentiellement, cela ajoute un espace vide à la fin du motif. </font><font style="vertical-align: inherit;">(Remarque: il est préférable de répartir l'espace vide entre tous les éléments du motif.) Il convient de considérer qu'une telle solution ne peut que rallonger le motif. </font><font style="vertical-align: inherit;">Nous pouvons toujours ajouter de l'espace vide au motif, mais ne pouvons pas le prendre si nécessaire - peut-être qu'il n'y aura plus d'espace vide dans le motif! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avec cette approche, l'algorithme de localisation des motifs sur le côté de la carte sera très simple:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Divisez la longueur du côté de la carte par la longueur du motif et arrondissez-la pour déterminer le nombre de répétitions du motif qui correspondent à ce côté. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distance entre les éléments dans ce cas sera égale à la longueur du côté divisée par le nombre de répétitions. </font><font style="vertical-align: inherit;">(C'est le plus proche de l'emplacement d'origine, étant donné que nous ne pouvons ajouter que de l'espace.)</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tracez un motif sur le côté, en tenant compte de la distance calculée. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il était difficile de mettre en œuvre ce système. </font><font style="vertical-align: inherit;">Les virages tenaces ne voulaient pas coïncider. </font><font style="vertical-align: inherit;">Il m'a fallu trop de temps pour réaliser que lorsque la carte n'est pas carrée, je ne peux pas dessiner des zones de troncature sur quatre côtés à partir du centre de la carte, car cela crée des angles de troncature qui ne sont pas égaux à 45 degrés. </font><font style="vertical-align: inherit;">En fait, les zones de troncature devraient ressembler à l'arrière d'une enveloppe:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/29a/beb/b2029abeb54302b5f7d3335a15c95f86.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quand j'ai compris cela, l'algorithme a commencé à fonctionner sans problème. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Mais n'oubliez pas la note précédente qu'au fil du temps j'ai abandonné les zones de troncature!)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici un exemple avec un ratio d'environ 2: 1:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/739/d19/bff739d19d76fdb4db63033b970eb241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur cette échelle, c'est assez difficile à remarquer, mais les coins se connectent correctement et il n'y a qu'une légère différence visuelle entre les côtés. </font><font style="vertical-align: inherit;">Dans ce cas, l'algorithme d'alignement des motifs n'a besoin que d'insérer des pixels fractionnaires, il est donc invisible à l'œil, notamment parce que les contours des cercles se chevauchent d'un pixel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un autre exemple avec des rayures:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/852/625/aa8852625e15121ce822cc6ca5fe8742.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ceci est le haut de la bordure carrée. </font><font style="vertical-align: inherit;">Voici la même bordure sur une carte plus rectangulaire:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/207/9b1/90d2079b1e869c59ee204f1a75f5dbc7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, vous pouvez voir que sur le côté de la carte il y a un écart visuellement plus grand entre les bandes. </font><font style="vertical-align: inherit;">L'algorithme ne doit pas insérer plus d'espace que la longueur d'un élément complet; </font><font style="vertical-align: inherit;">par conséquent, le pire des cas se produit lorsque nous avons des éléments longs et un côté court légèrement différent d'une taille appropriée. </font><font style="vertical-align: inherit;">Mais dans la plupart des cas pratiques, l'alignement n'est pas très nocif. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un exemple avec un motif de plusieurs éléments:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/602/4f8/d186024f8ee1e4fbcd5918c63537a024.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, les rayures chevauchent les rayures: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/af7/ad6/c60af7ad6c71ee4ef1850f0bf194af62.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez voir que puisque le même alignement est effectué pour chaque élément, les bandes restent centrées les unes par rapport aux autres. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai suggéré qu'une bonne solution pour placer le motif sur le côté de la carte serait difficile, mais une approche très simple avec une distribution uniforme de l'élément de motif pour remplir l'espace souhaité fonctionne assez bien pour de nombreux motifs. C'est un rappel pour nous tous: il n'est pas nécessaire de supposer que la décision doit être compliquée; cela peut être plus facile que vous ne le pensez! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, cette solution ne fonctionne pas pour les motifs avec des éléments en contact, par exemple, pour l'échelle de la carte. Dans ce cas, l'ajout d'espace décale les éléments:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/d7e/27f/3cdd7e27f8c2d92be26d36e7b4807f5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre option pour allonger un motif, que j'ai mentionné ci-dessus, consiste à étirer les éléments individuels du motif. </font><font style="vertical-align: inherit;">Il convient à quelque chose comme un motif d'échelle, mais il aura l'air mauvais dans un motif avec des éléments symétriques, car l'étirement les rendra asymétriques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La mise en œuvre de l'option avec étirement s'est avérée plus difficile que prévu, principalement parce que j'ai dû étirer les éléments à différents bords de la carte de différentes tailles (car la carte n'est peut-être pas carrée mais rectangulaire), et également changer dynamiquement la disposition des éléments en fonction des nouveaux étirés. tailles. </font><font style="vertical-align: inherit;">Mais après quelques heures, j'ai réussi à y parvenir:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/552/3c4/d1c5523c43a9828cd9c1c1bee6f4bbde.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai maintenant toutes les fonctionnalités nécessaires pour dessiner la bordure de la carte (bien que les éléments de bordure eux-mêmes soient créés manuellement): </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2b/ccc/326/d2bccc326a0500f92267378e137e2f6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> J'ai converti l'image en niveaux de gris, car je ne voulais pas me soucier de la sélection des couleurs, et la carte elle-même est plutôt ennuyeuse, mais comme preuve de concept, les bordures sont plutôt jolies. </font></font><br><br><h2>  Partie 5 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie 2, j'ai développé la grammaire MBDL (Map Border Description Language) et dans les parties 3 et 4, j'ai implémenté des procédures pour exécuter toutes les primitives de langage. </font><font style="vertical-align: inherit;">Je vais maintenant travailler sur la connexion de ces parties afin de pouvoir décrire la bordure sur MBDL et la dessiner sur la carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la partie 3, j'ai écrit la grammaire MBDL pour qu'elle fonctionne avec l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outil d'analyse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Javascript </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Nearley</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La grammaire terminée ressemble à ceci:</font></font><br><br><blockquote> <code><b>@builtin</b> <b>"</b> <b>number.ne"</b> <br> <b>@builtin</b> <b>"</b> <b>string.ne"</b> <br> <b>border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>VS(" number</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>(" WS (element WS):+</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>[" WS (geometric WS):+</b> <b>"</b> <b>]"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>B(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>E(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>D(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>HS(" number</b> <b>"</b> <b>)"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par défaut, lors de l'analyse réussie d'une règle à l'aide de Nearley, la règle renvoie un tableau contenant tous les éléments qui correspondent au côté droit de la règle. </font><font style="vertical-align: inherit;">Par exemple, si la règle</font></font><br><br><blockquote> <code><b>test -&gt;</b> <b>"</b> <b>A" |</b> <b>"</b> <b>B" |</b> <b>"</b> <b>C"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> assorti avec de la ficelle </font></font><br><br><blockquote> <code><b>A</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> alors Nearley reviendra </font></font><br><br><blockquote> <code><b>[</b> <b>"</b> <b>A" ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un tableau avec une seule valeur est la chaîne «A» correspondant au côté droit de la règle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que retourne Nearley lorsqu'un élément est analysé à l'aide de cette règle?</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a trois parties à droite de la règle, elle renverra donc un tableau avec trois valeurs. </font><font style="vertical-align: inherit;">La première valeur sera celle qui renvoie la règle pour WS, la deuxième valeur sera celle qui renverra la règle pour la décimale et la troisième valeur sera celle qui renverra la règle pour WS. </font><font style="vertical-align: inherit;">Si, en utilisant la règle ci-dessus, je pars "57", alors le résultat sera le suivant:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> [ "5", "7" ], <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le résultat final de l'analyse de Nearley sera un tableau imbriqué de tableaux, qui est un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arbre de syntaxe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dans certains cas, l'arbre de syntaxe est une représentation très utile; dans d'autres cas, pas tout à fait. Dans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par exemple, un tel arbre n'est pas particulièrement utile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heureusement, les règles Nearley peuvent remplacer le comportement standard et retourner tout ce qu'elles veulent. En fait, la règle (intégrée) pour la </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décimale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ne renvoie pas une liste de nombres, elle renvoie le nombre Javascript équivalent, ce qui dans la plupart des cas est beaucoup plus utile, c'est-à-dire que la valeur de retour de la règle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numérique</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a la forme:</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> 57, <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les règles Nearley redéfinissent le comportement standard en ajoutant un post-processeur à la règle, en prenant un tableau standard et en le remplaçant par ce dont vous avez besoin. Un postprocesseur est juste du code Javascript entre crochets spéciaux à la fin d'une règle. Par exemple, dans la règle des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombres</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">je ne suis jamais intéressé par les espaces possibles de chaque côté du nombre. Par conséquent, il serait pratique que la règle renvoie simplement un nombre et non un tableau de trois éléments. Voici un post-processeur qui effectue cette tâche:</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS {% default =&gt; default[1] %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce post-processeur prend le résultat standard (le tableau à trois éléments illustré ci-dessus) et le remplace par le deuxième élément du tableau, qui est le numéro Javascript de la règle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décimale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alors maintenant, la règle </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">numérique</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> renvoie le nombre réel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette fonctionnalité peut être utilisée pour traiter une langue entrante dans une langue intermédiaire, ce qui est plus facile à utiliser. </font><font style="vertical-align: inherit;">Par exemple, je peux utiliser la grammaire Nearley pour transformer une chaîne MBDL en un tableau de structures Javascript, chacune représentant une primitive identifiée par un champ «op». </font><font style="vertical-align: inherit;">La règle pour la primitive de ligne ressemblera à ceci:</font></font><br><br><blockquote> <code><b>element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)" {% data=&gt; {op:</b> <b>"</b> <b>L", width: data[1], color: data[3]} %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Autrement dit, le résultat de l'analyse de «L (13, noir)» sera la structure Javascript: </font></font><br><br><blockquote> <code><b>{op:</b> <b>"</b> <b>L", width: 13, color:</b> <b>"</b> <b>black"}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir ajouté le post-traitement approprié, le résultat renvoyé par la grammaire peut être une séquence (tableau) de structures d'opération pour la ligne entrante. </font><font style="vertical-align: inherit;">Autrement dit, le résultat de l'analyse de la chaîne</font></font><br><br><blockquote> <code><b>L( 415, “black") <br> VS(5) <br> [B(1, 2, “black", 3, “white") HS(5) E(1, 2, “black", 3, “white")]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera </font></font><br><br><blockquote> <code><b>[ <br> {op: "L", width: 415, color: "black"}, <br> {op: "VS", width: 5}, <br> {op: "P", <br> elements: [{op: "B", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}, <br> {op: "HS", width: 5}, <br> {op: "E", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}]} <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui est beaucoup plus facile à traiter pour créer une bordure de carte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À ce stade, vous pouvez avoir une question - si la phase de post-traitement de la règle Nearley peut contenir du Javascript, alors pourquoi ne pas ignorer la vue intermédiaire et simplement dessiner la bordure de la carte à droite pendant le post-traitement? </font><font style="vertical-align: inherit;">Pour de nombreuses tâches, cette approche serait idéale. </font><font style="vertical-align: inherit;">J'ai décidé de ne pas l'utiliser pour plusieurs raisons.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Premièrement, dans MBDL, il y a quelques (*) composants qui ne peuvent pas être exécutés pendant le processus d'analyse. Par exemple, nous ne pouvons pas dessiner des éléments géométriques répétitifs (bande ou losange) pendant le processus d'analyse, car nous devons connaître les informations d'autres éléments dans le même modèle. En particulier, nous devons connaître la longueur totale du motif afin de comprendre jusqu'où nous devons organiser les répétitions de chaque élément individuel. Autrement dit, l'élément du motif doit toujours créer une représentation intermédiaire de tous les éléments géométriques. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(* Il y a d'autres composants avec des limitations similaires dont je n'ai pas encore parlé.)</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, Javascript dans Nearley est intégré dans les règles, nous ne pourrons donc pas transmettre d'informations supplémentaires à Javascript, à l'exception des variables globales. Par exemple, pour dessiner la frontière, j'ai besoin de connaître la taille de la carte, les quatre zones de troncature utilisées, etc. Bien que je puisse ajouter du code qui rend ces informations disponibles pour les post-processeurs Nearley, ce sera un peu compliqué et il pourrait être difficile de maintenir un tel code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour ces raisons, j'analyse une représentation intermédiaire, qui est ensuite exécutée pour créer la bordure de la carte elle-même.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La prochaine étape consistera à développer un interpréteur qui reçoit une représentation intermédiaire de MBDL et l'exécute pour générer des limites de carte. Ce n'est pas très difficile à faire. Fondamentalement, le travail consiste à définir les conditions initiales (par exemple, générer des régions de troncature pour les quatre côtés de la carte) et itérer sur la séquence de structures de la représentation intermédiaire à chaque exécution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a quelques moments glissants.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, je dois passer du rendu de l'intérieur au dessin de l'intérieur vers l'extérieur. La raison en est que je veux que la plupart des bordures ne chevauchent pas la carte, j'ai donc besoin de dessiner les bordures de sorte que les lignes du bord intérieur coïncident avec les bords de la carte. Si je dessine de l'extérieur vers l'intérieur, j'ai besoin de connaître la largeur de la bordure avant de commencer à dessiner afin que la bordure ne chevauche pas la carte. Si je dessine de l'intérieur vers l'extérieur, je commence simplement par le bord de la carte et je dessine. Il vous permet également d'imposer éventuellement une bordure sur la carte; il suffit de commencer la bordure avec un espace vertical négatif (VS).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un autre point difficile est la répétition des schémas. </font><font style="vertical-align: inherit;">Pour dessiner des motifs répétitifs, je dois regarder tous les éléments du motif et déterminer le plus large, car cela définira la largeur de l'ensemble du motif. </font><font style="vertical-align: inherit;">Je dois également regarder et suivre la longueur du motif afin de savoir quelle distance il me reste avant chaque répétition. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voici un exemple de bordure assez complexe que j'ai utilisé pour tester l'interpréteur:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c8/88a/2a9/3c888a2a96352845f6165f5eca7f6ab3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Je pense qu'il était possible (nécessaire?) De le joindre pour le tester à l'analyseur, mais pour cette bordure, je viens de créer une vue intermédiaire manuellement: </font></font><br><br><blockquote> <code><b>[ <br> {op:'P', elements: [ <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'white'}, <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'black'}, <br> ]}, <br> {op:'VS', width: 2}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'PUSH'}, <br> {op:'L', width:10, color: 'rgb(222,183,64)'}, <br> {op:'POP'}, <br> {op:'PUSH'}, <br> {op:'P', elements: [ <br> {op:'E', width: 5, length: 5, lineWidth: 1, color: 'black', fill: 'red'}, <br> {op:'HS', length: 10}, <br> ]}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'POP'}, <br> {op:'VS', width: 2}, <br> {op:'P', elements: [ <br> {op:'E', width: 2, length: 2, lineWidth: 0, color: 'black', fill: 'white'}, <br> {op:'HS', length: 13}, <br> ]}, <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai créé cette vue par essais et erreurs. Quoi qu'il en soit, l'interprète fonctionne! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dernière étape, permettez-moi d'utiliser l'analyseur pour créer une vue intermédiaire à partir de la version MBDL. Il n'y a rien de spécial à me montrer ici: j'ai dû corriger plusieurs noms de champs, mais sinon le code fonctionnait bien. Pour la frontière, j'ai utilisé une version légèrement différente de MBDL:</font></font><br><br><blockquote> <code><b>[B(5,37,"black",2,"white") B(5,37,"black",2,"black")] <br> VS(3) <br> L(3,"black") <br> {L(10,"rgb(222,183,64)")} <br> [E(5,5,"black",1,"red") HS(-5) E(2,2,"none",0,"white") HS(10)] <br> L(3,"black")</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elle dessine la même bordure, mais d'une manière légèrement différente. </font><font style="vertical-align: inherit;">J'ai également changé la syntaxe de la superposition, en remplaçant les parenthèses par des accolades pour qu'elle soit plus différente de l'autre syntaxe. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour montrer pourquoi je voulais dessiner de l'intérieur vers l'extérieur, et pas seulement placer automatiquement la bordure à l'extérieur de la carte, je peux ajouter un espace vertical négatif au début de cette bordure pour déplacer l'échelle de la carte à l'intérieur du bord de la carte:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">J'ai maintenant la plupart des infrastructures nécessaires à la génération procédurale des bordures de carte: un langage de description des limites, un analyseur de langage et des procédures pour effectuer une représentation intermédiaire. </font><font style="vertical-align: inherit;">Il ne reste plus qu'à gérer la partie difficile - la génération procédurale!</font></font><br><br><h2>  Partie 6 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant que l'intégralité du MBDL a été implémentée, j'avais l'intention de procéder à la génération procédurale des bordures de carte, mais je ne sais pas encore comment je veux le faire, car je vais m'attarder un peu et implémenter quelques autres fonctionnalités de MBDL. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la première discussion sur le traitement des coins avec des motifs, j'ai parlé de deux approches différentes. À la fin, j'ai réalisé les coins biseautés, mais il y avait une deuxième option: arrêter le motif près du coin, comme dans ces exemples:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/94d/01b/3b794d01b552c42ed9b8362f5405ff9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/3a8/159/ee23a8159d81afd1f7c95c16a90bcdf7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une telle solution est souvent utilisée lorsque le motif de bordure est une sorte de figure asymétrique, de runes ou autre chose qui ne peut pas être tourné de 90 degrés, tout en maintenant l'alignement. Mais il est évident que cela fonctionnera avec des formes géométriques. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C'est peut-être l'option que vous choisissez avant de générer la bordure, mais vous pouvez ajouter un peu de flexibilité si vous l'activez à partir d'une partie de la bordure et utilisez le coin biseauté de l'autre. Pour ce faire, je dois ajouter une nouvelle commande à MBDL. Je soupçonne que d'autres options peuvent survenir pour différentes parties de la frontière, donc j'ajouterai une commande d'options générales:</font></font><br><br><blockquote> <code><b>element -&gt; "O(MITER)"</b> <br> <b>element -&gt; "O(STOPPED)"</b> <br> <b>element -&gt; "O(STOPPED," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Ici encore, pour plus de clarté, nous omettons les espaces et certains autres détails.) Jusqu'à présent, les seules options sont «MITRE» pour les coins biseautés et «ARRÊTÉ» pour l'arrêt près des coins. </font><font style="vertical-align: inherit;">Si aucune valeur n'est transmise STOPPED, le programme arrête le motif à une distance raisonnable du coin. </font><font style="vertical-align: inherit;">Si la valeur est transmise, le motif s'arrête à cette distance du coin. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si des coins ARRÊTÉS sont utilisés, alors j'arrête de dessiner le motif de coin loin des coins.</font></font> Voici à quoi ça ressemble: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/5df/49e/a8e5df49eecf2ebc5e94e571cb7d0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, j'ai utilisé l'option MITRE pour le modèle d'échelle noir et blanc, de sorte qu'il reflète en fonction de l'angle. </font><font style="vertical-align: inherit;">Pour un motif de cercles rouges et de carrés noirs à l'intérieur d'une ligne dorée (et pour un motif de cercles à l'extérieur de la bordure), j'ai utilisé STOPPED. </font><font style="vertical-align: inherit;">Vous pouvez voir que ces deux motifs se terminent près du coin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, il y a quelques problèmes. Tout d'abord, nous voyons qu'à gauche, l'élément le plus proche du coin est un carré noir et en haut un cercle rouge. Cela s'est produit parce que le coin est près du début de la répétition d'un côté et près de la fin de la répétition de l'autre. Mais ça a l'air bizarre. Il serait préférable que les coins soient symétriques, même si pour cela nous devions ajouter un autre élément à la fin du motif. Deuxièmement, vous pouvez voir que le motif à l'extérieur de la bordure (demi-cercles et points noirs) se termine également par une répétition dans le coin. Mais comme la longueur de cette répétition est bien inférieure à la longueur des cercles rouges / carrés noirs, ils se retrouvent à des endroits différents. Il serait probablement préférable que tous les motifs s'arrêtent à la même distance du coin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour résoudre le premier problème, vous devez ajouter une autre répétition du premier élément du motif à la fin de chaque côté de la bordure. </font><font style="vertical-align: inherit;">Mais en fait, c'est un peu plus compliqué, car je pourrais utiliser un décalage horizontal négatif à l'intérieur du motif pour chevaucher plusieurs éléments (comme ici). </font><font style="vertical-align: inherit;">Vous devez également ajouter une autre répétition à tout élément du motif qui a le même point de départ que le premier élément.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/331/6fc/9c43316fcd44d79a0b2374401a46240a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, le motif est symétrique par rapport à l'angle et semble beaucoup mieux. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ensuite, je dois suivre le motif ARRÊT le plus long et arrêter chaque motif ARRÊT à cette distance:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a33/920/c6c/a33920c6cda9072bbda915544f1f4926.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Maintenant, le motif des cercles blancs est plus mis de côté, mais il n'est toujours pas aligné avec le motif des cercles rouges. </font></font> Pourquoi?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cela est dû au fait que le motif de cercle blanc est plus éloigné du bord de la carte et que la bordure est plus longue que celle où le motif de cercle rouge est tracé. </font><font style="vertical-align: inherit;">Pour résoudre ce problème, vous devez déplacer les motifs de manière uniforme et en tenant compte de leur décalage par rapport au bord de la carte.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70b/574/2c1/70b5742c1d4f404335b97128f09d6baf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maintenant, tout est magnifiquement aligné. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième option pour les angles est les décalages carrés dans les coins, par exemple ceux-ci:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce sera beaucoup plus difficile à mettre en œuvre! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, la grammaire de cette option est simple et utilise l'opcode Option:</font></font><br><br><blockquote> <code><b>element -&gt; "O(SQOFFSET)"</b> <br> <b>element -&gt; "O(SQOFFSET," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le nombre indique la taille du déplacement carré pour l'élément sur le bord de la carte; </font><font style="vertical-align: inherit;">Les éléments avec différents décalages doivent être alignés en conséquence. </font><font style="vertical-align: inherit;">S'il n'y a pas de nombre, le programme sélectionne la taille de décalage appropriée. </font><font style="vertical-align: inherit;">La mise à zéro du nombre désactive le décalage carré. </font><font style="vertical-align: inherit;">Cela vous permet de créer des bordures dans lesquelles certains éléments utilisent des décalages carrés, tandis que d'autres ne le font pas, comme dans cette bordure:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La première chose que j'ai réalisée est que j'aurais besoin de zones de troncature supplémentaires car j'utilise la troncature pour traiter les endroits où la bordure change de direction. </font><font style="vertical-align: inherit;">SQOFFSET nécessitera des zones de troncature plus complexes; </font><font style="vertical-align: inherit;">Vous aurez également besoin de zones distinctes pour différents éléments lorsque vous activez et désactivez SQOFFSET. </font><font style="vertical-align: inherit;">Étant donné que les zones de troncature ajoutent de toute façon des artefacts indésirables, cela semble être trop de travail.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque j'ai travaillé sur les modèles pouvant être arrêtés ci-dessus, j'ai implémenté le remplissage d'un modèle asymétrique pour ajouter une autre répétition à une extrémité du modèle. J'ai également réalisé que cela éliminerait le besoin de coins biseautés. Je vais simplement dessiner tous les motifs le long de la bordure dans le sens horaire, en commençant le motif dans un coin et en terminant près du coin suivant. Cela me permettra de me débarrasser des zones de troncature. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le plus important dans cette nouvelle façon de travailler avec les coins est que le premier élément du motif n'est plus «divisé» en deux côtés. Si vous regardez les motifs d'échelle en noir et blanc sur les cartes ci-dessus, vous pouvez voir qu'il y a un rectangle blanc passant dans le coin. Maintenant, le rectangle blanc jouxte le coin:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/909/c83/ead909c83fa91ff80af290ab92ca9fae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les cartes sont dessinées dans les deux sens, mais ce n'est pas un très gros problème. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour commencer, j'ai implémenté des décalages pour les lignes. </font><font style="vertical-align: inherit;">Pour ce faire, il suffisait de tourner la ligne par rapport aux angles correspondants:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/bf6/2fd/9c2bf62fdfec732f56361f4aa17fc19e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comme vous pouvez le comprendre, je peux combiner des angles avec des décalages et des angles réguliers, comme dans la carte ci-dessus: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f5b/e02/e0bf5be02606044dd5fba4f82d3dad67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien sûr, il est plus difficile de tourner les motifs au coin de la rue. </font><font style="vertical-align: inherit;">L'idée générale est de dessiner d'un coin à presque l'autre, et ainsi de suite le long de la frontière, jusqu'à revenir au début. </font><font style="vertical-align: inherit;">Il suffit théoriquement de dessiner uniquement des motifs horizontaux et verticaux, et tout doit être magnifiquement aligné; </font><font style="vertical-align: inherit;">en fait, suivre tout cela est assez morne. </font><font style="vertical-align: inherit;">En fait, j'ai dû réécrire complètement le code deux fois et écrire un tas de papier, mais je n'en parlerai pas en détail. </font><font style="vertical-align: inherit;">Montrez simplement le résultat:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/35b/889/91235b889603c973fcfe094a1614a993.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une illusion d'optique gênante apparaît dans les coins - l'élément d'angle semble non centré plus près de l'extérieur du coin. </font><font style="vertical-align: inherit;">En fait, ce n'est pas vrai, mais il semble que oui, car plus près de l'intérieur du coin, il y a visuellement plus d'espace vide. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étant donné que les segments des angles de décalage sont assez courts, il est très facile de créer un motif de non-équilibre dans le coin:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/601/dff/b1b601dffc11782fb8cbe738a906b0e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parfois, ça a l'air assez moche. </font><font style="vertical-align: inherit;">Cela m'a rappelé une vieille blague:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patient: "Docteur, quand je fais ça, ça me fait mal." </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docteur: "Alors ne fais pas ça!"</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je vais donc essayer de ne pas le faire. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habituellement, je ne dessinerai pas l'échelle de la carte le long de l'angle de décalage, mais si j'en ai besoin, je devrai utiliser l'option qui étire le motif afin que l'échelle de la carte s'insère dans le coin sans espaces entre les rectangles:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26f/a88/0da/26fa880da6d00d380afdae60c489dd9c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez voir qu'en conséquence, la taille des rectangles d'échelle varie considérablement. </font><font style="vertical-align: inherit;">Autrement dit, ce n'est pas une très bonne option. </font><font style="vertical-align: inherit;">(Soit dit en passant, les angles de décalage ont également un bug dans le motif des cercles. Plus tard, je l'ai corrigé, mais comme je l'ai dit, il est très difficile de le faire.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si le motif est trop grand pour tenir sur le segment de l'angle de décalage, l'algorithme se rend simplement:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/044/b2d/b4d044b2dc2bf23cd670113476b9803d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce qui est loin d'être idéal, mais, comme je l'ai dit plus haut, "alors ne le faites pas". </font><font style="vertical-align: inherit;">(Il n'est en fait pas très difficile d'ajouter une fonction de compression ou d'étirement si j'en ai besoin.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Que se passe-t-il si j'utilise les deux coins décalés et l'option qui arrête les motifs devant les coins? </font><font style="vertical-align: inherit;">Dans ce cas, je m'arrête juste non loin des coins décalés:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/170/d60/9c1/170d609c1b789359490e35741215ba04.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Il me semble que c'est une décision logique. </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr444190/">https://habr.com/ru/post/fr444190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr444178/index.html">9 conseils pour créer des jeux indépendants à partir d'un seul développeur</a></li>
<li><a href="../fr444182/index.html">Go conditions et leurs bizarreries</a></li>
<li><a href="../fr444184/index.html">À propos des perspectives des centres de données pré-assemblés</a></li>
<li><a href="../fr444186/index.html">Flutter 1.2. Quoi de neuf</a></li>
<li><a href="../fr444188/index.html">CG Pods - Casque TWS qui pourrait</a></li>
<li><a href="../fr444192/index.html">Gestion des API Mitap - IBM, Google, Yandex et Leroy Merlin Experience - Record Available</a></li>
<li><a href="../fr444198/index.html">Dropbox limite la synchronisation: maintenant seulement 3 appareils</a></li>
<li><a href="../fr444200/index.html">Session de résolution de problèmes</a></li>
<li><a href="../fr444204/index.html">Présentation des tests en Python. 3e partie</a></li>
<li><a href="../fr444206/index.html">27 mars, Moscou - JavaScript MeetUP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>