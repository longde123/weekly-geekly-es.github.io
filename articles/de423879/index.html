<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõ∞Ô∏è ü•§ üìÇ Ist es einfach, dem alten Framework neue Funktionen hinzuzuf√ºgen? Mehl der Wahl am Beispiel der Entwicklung von SObjectizer üêÉ üõÄüèæ üñ®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Entwicklung eines kostenlosen Frameworks f√ºr Entwickleranforderungen ist ein spezifisches Thema. Wenn das Framework gleichzeitig ziemlich lange le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ist es einfach, dem alten Framework neue Funktionen hinzuzuf√ºgen? Mehl der Wahl am Beispiel der Entwicklung von SObjectizer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/423879/"><img src="https://habrastorage.org/webt/en/lw/bb/enlwbb8hjnjmprjbfysbwsnejiy.jpeg"><br><br>  Die Entwicklung eines kostenlosen Frameworks f√ºr Entwickleranforderungen ist ein spezifisches Thema.  Wenn das Framework gleichzeitig ziemlich lange lebt und sich entwickelt, werden die Besonderheiten hinzugef√ºgt.  Heute werde ich versuchen, dies anhand eines Beispiels f√ºr einen Versuch zu zeigen, die Funktionalit√§t eines "Actor" -Frameworks f√ºr C ++ namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SObjectizer zu erweitern</a> . <br><br>  Tatsache ist, dass dieses Framework bereits ziemlich alt ist und sich mehrmals dramatisch ge√§ndert hat.  Sogar seine aktuelle Inkarnation, SObjectizer-5, hat viele Ver√§nderungen erfahren, sowohl ernsthafte als auch nicht ernsthafte.  Au√üerdem reagieren wir sehr empfindlich auf Kompatibilit√§t, und √Ñnderungen, die die Kompatibilit√§t beeintr√§chtigen, sind ein zu schwerwiegender Schritt, als dass wir uns nur daf√ºr entscheiden k√∂nnten. <br><br>  Im Moment m√ºssen wir entscheiden, wie der n√§chsten Version eine neue Funktion hinzugef√ºgt werden soll.  Bei der Suche nach einer geeigneten L√∂sung ergaben sich zwei Optionen.  Beide sehen ziemlich realisierbar aus.  Aber sie unterscheiden sich sehr voneinander.  Sowohl in Bezug auf die Komplexit√§t und Komplexit√§t der Implementierung als auch in Bezug auf das ‚ÄûErscheinungsbild‚Äú.  Das hei√üt,  Was der Entwickler tun wird, sieht in jeder der Optionen anders aus.  Wahrscheinlich sogar grundlegend anders. <br><br>  Und jetzt m√ºssen wir als Entwickler des Frameworks eine Entscheidung zugunsten der einen oder anderen L√∂sung treffen.  Oder man muss zugeben, dass keiner von ihnen zufriedenstellend ist und daher etwas anderes erfunden werden muss.  Solche Entscheidungen in der Geschichte von SObjectizer mussten mehr als einmal getroffen werden.  Wenn jemand daran interessiert ist, sich in den Schuhen des Entwicklers eines solchen Frameworks zu f√ºhlen, dann sind Sie bei cat willkommen. <br><a name="habracut"></a><br><h1>  Urspr√ºngliches Problem </h1><br>  Also kurz die Essenz des urspr√ºnglichen Problems.  SObjectizer hatte von Anfang an folgende Funktion: Eine Timer-Nachricht ist nicht so einfach abzubrechen.  Unter dem Timer wird zun√§chst eine verz√∂gerte Nachricht verstanden.  Das hei√üt,  Eine Nachricht, die nicht sofort, sondern nach einiger Zeit an den Empf√§nger gesendet werden soll.  Zum Beispiel senden wir_verz√∂gert mit einer Pause von 1s.  Dies bedeutet, dass in der Realit√§t die Nachricht vom Timer 1s nach dem Aufruf send_delayed gesendet wird. <br><br>  Eine ausstehende Nachricht kann grunds√§tzlich abgebrochen werden.  Wenn sich die Nachricht noch im Besitz des Timers befindet, wird die Nachricht nach dem Abbrechen nirgendwo hingehen.  Es wird vom Timer ausgel√∂st und das wars.  Wenn der Timer jedoch bereits eine Nachricht gesendet hat und sich jetzt in der Anforderungswarteschlange f√ºr den empfangenden Agenten befindet, funktioniert das Abbrechen des Timers nicht.  In SObjectizer gibt es keinen Mechanismus zum Entfernen einer Nachricht aus der Anwendungswarteschlange. <br><br>  Das Problem wird durch mindestens zwei Faktoren versch√§rft. <br><br>  Erstens unterst√ºtzt SObjectizer die Lieferung im 1: N-Modus, d.h.  Wenn die Nachricht an die Multi-Consumer-Mbox gesendet wurde, befindet sich die Nachricht nicht in einer Warteschlange, sondern in mehreren Warteschlangen f√ºr N Empf√§nger gleichzeitig. <br><br>  Zweitens wird in SObjectizer der Dispatcher-Mechanismus verwendet, und die Dispatcher k√∂nnen sehr unterschiedlich sein, einschlie√ülich der vom Benutzer f√ºr ihre spezifischen Anforderungen geschriebenen.  Anforderungswarteschlangen werden von Dispatchern verwaltet.  Und in der Schnittstelle des Dispatchers gibt es keine Funktionalit√§t zum Zur√ºckziehen einer Anwendung, die bereits an den Dispatcher √ºbertragen wurde.  Aber selbst wenn solche Funktionen in die Schnittstelle eingebettet w√§ren, ist es weit davon entfernt, dass sie in allen F√§llen effektiv implementiert werden k√∂nnten.  Ganz zu schweigen von der Tatsache, dass eine solche Funktionalit√§t die Komplexit√§t der Entwicklung neuer Disponenten erh√∂hen w√ºrde. <br><br>  Wenn der Timer bereits eine ausstehende Nachricht an den / die Empf√§nger gesendet hat, ist es im Allgemeinen objektiv derzeit unm√∂glich, SObjectizer zu zwingen, diese Instanz der Nachricht nicht zuzustellen. <br><blockquote>  Tats√§chlich ist dieses Problem auch f√ºr periodische Nachrichten relevant (d. H. Nachrichten, die der Zeitgeber periodisch in vorbestimmten Zeitintervallen senden sollte).  In der Praxis ist das Abbrechen periodischer Nachrichten jedoch viel weniger erforderlich als das Abbrechen einer ausstehenden Nachricht.  Zumindest in unserer Praxis ist dies so. </blockquote><h2>  Was kann jetzt getan werden? </h2><br>  Dieses Problem ist also nicht neu und es gibt seit langem Empfehlungen, wie man damit umgeht. <br><br><h3>  Eindeutige ID in ausstehender Nachricht </h3><br>  Der einfachste Weg ist, einen Z√§hler zu behalten.  Der Agent verf√ºgt √ºber einen Z√§hler. Beim Senden einer ausstehenden Nachricht wird der aktuelle Z√§hlerwert in der Nachricht gesendet.  Wenn eine Nachricht abgebrochen wird, wird der Z√§hler am Agenten erh√∂ht.  Beim Empfang der Nachricht wird der aktuelle Z√§hlerwert im Agenten mit dem Wert aus der Nachricht verglichen.  Wenn die Werte nicht √ºbereinstimmen, wird die Nachricht abgelehnt: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id_; ... }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> expected_msg_id_{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">timer_id_t</span></span> timer_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_some_event</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   . //   send_periodic, ..    //  timer_id   . timer_ = so_5::send_periodic&lt;delayed_msg&gt;(*this, 25s, //     . 0s, //    . //      delayed_msg, //      id   . ++expected_msg_id_, ... //  . ); ... } void on_cancel_event() { //   ,        //   .   : timer_.reset(); //     . ++expected_msg_id_; //   id-. ... } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     id    //  . if(expected_msg_id_ == cmd-&gt;id_) { ... //  . } } };</span></span></code> </pre> <br>  Das Problem bei dieser Methode ist, dass der Agentenentwickler durch die Pflege dieser Z√§hler verwirrt werden muss.  Und wenn wir als verz√∂gerte Nachricht die Nachricht eines anderen senden m√ºssen, die jemand anderes getan hat und in der es kein id_-Feld gibt, befinden wir uns in einer schwierigen Situation. <br><br>  Auf der anderen Seite ist dies der derzeit effektivste Weg. <br><br><h3>  Verwenden Sie eine eindeutige mbox f√ºr verz√∂gerte Nachrichten </h3><br>  Eine andere M√∂glichkeit, die gut funktioniert, besteht darin, eine eindeutige Mailbox (mbox) f√ºr eine verz√∂gerte Nachricht zu verwenden.  In diesem Fall erstellen wir f√ºr jede ausstehende Nachricht eine neue Mbox, abonnieren sie und senden die ausstehende Nachricht an diese Mbox.  Wenn eine Nachricht storniert werden muss, l√∂schen wir einfach die mbox-Abonnements. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">demo_agent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">delayed_msg</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//   id_   . }; so_5::mbox_t timer_mbox_; //   . so_5::timer_id_t timer_; void on_some_event() { //        mbox //     . timer_mbox_ = so_environment().create_mbox(); some_state.event(time_mbox_, ...); another_state.event(time_mbox_, ...); ... //    . timer_ = so_5::send_delayed&lt;delayed_msg&gt;( so_environment(), timer_mbox_, //     . 25s, 0s, ... //    delayed_msg. ); } void on_cancel_event() { //        mbox. timer_.reset(); so_drop_subscription_for_all_states(timer_mbox_); } void on_delayed_msg(mhood_t&lt;delayed_msg&gt; cmd) { //     ,   //    . ... } };</span></span></code> </pre> <br>  Diese Methode kann bereits mit Nachrichten anderer Personen arbeiten, in denen sich keine eindeutige Kennung befindet.  Es erfordert aber auch Arbeit und Aufmerksamkeit des Entwicklers. <br><br>  Beispielsweise gibt es in der obigen Ausf√ºhrungsform keinen Schutz gegen die Tatsache, dass eine ausstehende Nachricht bereits fr√ºher gesendet wurde.  Vor dem Senden einer neuen ausstehenden Nachricht sollten Sie immer Aktionen von on_cancel_event () ausf√ºhren, da der Agent sonst unn√∂tige Abonnements daf√ºr hat. <br><br><h2>  Warum wurde dieses Problem noch nicht gel√∂st? </h2><br>  Hier ist alles ganz einfach: Tats√§chlich ist dies kein so ernstes Problem, wie es scheinen mag.  Zumindest im wirklichen Leben muss man sich nicht oft damit auseinandersetzen.  Normalerweise werden ausstehende und periodische Nachrichten √ºberhaupt nicht abgebrochen (weshalb die Funktion send_delayed √ºbrigens keine timer_id zur√ºckgibt).  Und wenn die Notwendigkeit einer Stornierung besteht, k√∂nnen Sie eine der oben beschriebenen Methoden anwenden.  Oder verwenden Sie sogar eine andere.  Erstellen Sie beispielsweise separate Agenten, die eine ausstehende Nachricht verarbeiten.  Diese Agenten k√∂nnen abgemeldet werden, wenn eine ausstehende Nachricht abgebrochen werden muss. <br><br>  Vor dem Hintergrund anderer Aufgaben, mit denen wir konfrontiert waren, war die Vereinfachung der garantierten L√∂schung einer ausstehenden Nachricht nicht so wichtig, dass unsere Ressourcen f√ºr die L√∂sung dieses Problems aufgewendet wurden. <br><br><h2>  Warum ist das Problem jetzt relevant? </h2><br>  Hier ist alles genauso einfach.  Einerseits erreichten die H√§nde endlich. <br><br>  Wenn jedoch neue Leute, die keine Erfahrung mit SObjectizer haben, anfangen, SObjectizer zu verwenden, √ºberrascht sie diese Funktion mit der L√∂schung von Timern sehr.  Nicht so angenehm √ºberraschend.  Und wenn ja, dann m√∂chte ich die negativen Eindr√ºcke beim Kennenlernen unseres Tools minimieren. <br><br>  Au√üerdem hatten wir unsere eigenen Aufgaben, wir mussten ausstehende Nachrichten nicht st√§ndig abbrechen.  Und neue Benutzer haben ihre eigenen Aufgaben, vielleicht ist alles umgekehrt. <br><br><h1>  Neue Erkl√§rung des Problems </h1><br>  Fast sofort, als die Pr√ºfung der M√∂glichkeit einer ‚Äûgarantierten Timer-Stornierung‚Äú begann, kam mir der Gedanke, dass die Aufgabe erweitert werden k√∂nnte.  Sie k√∂nnen versuchen, das Problem des Abrufs einer der zuvor gesendeten Nachrichten zu l√∂sen, die nicht unbedingt verz√∂gert und regelm√§√üig sind. <br><br>  Von Zeit zu Zeit ist diese Gelegenheit gefragt.  Stellen Sie sich zum Beispiel vor, wir haben mehrere interagierende Agenten zweier Typen: entry_point (akzeptiert Anforderungen von Clients) und processor (verarbeitet Anforderungen): <br><br><img src="https://habrastorage.org/webt/s7/mo/jp/s7mojpeyu9s6prshykrqxul14he.png"><br><br>  Entry_point-Agenten senden Anforderungen an den Prozessoragenten, der sie so weit wie m√∂glich verarbeitet und auf entry_point-Agenten antwortet.  Manchmal stellt entry_point jedoch fest, dass die Verarbeitung einer zuvor gesendeten Anforderung nicht mehr erforderlich ist.  Beispielsweise hat der Client einen Abbruchbefehl gesendet oder der Client ist "abgefallen", und Sie m√ºssen seine Anforderungen nicht mehr verarbeiten.  Wenn Anforderungsnachrichten vom Prozessoragenten in die Warteschlange gestellt werden, k√∂nnen Sie sie nicht mehr abrufen.  Und es w√§re n√ºtzlich. <br><br>  Daher wird der derzeitige Ansatz zur L√∂sung des Problems der "garantierten Timer-L√∂schung" genau als Unterst√ºtzung f√ºr "R√ºckrufnachrichten" ausgef√ºhrt.  Wir senden jede Nachricht auf besondere Weise, wir haben ein Handle zur Hand, mit dem Sie die Nachricht abrufen k√∂nnen.  Und es ist nicht so wichtig, ob eine regul√§re oder eine versp√§tete Nachricht antwortet. <br><br><h1>  Ein Versuch, die Implementierung von "R√ºckrufnachrichten" zu finden. </h1><br>  Sie m√ºssen also das Konzept der "R√ºckrufnachricht" einf√ºhren und dieses Konzept in SObjectizer unterst√ºtzen.  Und so, um in der 5.5-Filiale zu bleiben.  Die erste Version dieses Threads, 5.5.0, wurde vor fast vier Jahren im Oktober 2014 ver√∂ffentlicht.  Seitdem gab es in 5.5 keine wesentlichen √Ñnderungen.  Projekte, die bereits auf SObjectize-5.5 umgestellt oder sofort gestartet wurden, k√∂nnen problemlos auf neue Releases im 5.5-Zweig umstellen.  Diese Kompatibilit√§t muss diesmal beibehalten werden. <br><br>  Im Allgemeinen ist alles einfach: Sie m√ºssen nehmen und tun. <br><br><h2>  Was ist klar, wie zu tun </h2><br>  Nach der ersten Herangehensweise an das Problem wurden zwei Dinge bei der Implementierung von ‚ÄûR√ºckrufnachrichten‚Äú klar. <br><br><h3>  Atomic Flag und seine √úberpr√ºfung vor der Nachrichtenverarbeitung </h3><br>  Erstens ist es offensichtlich, dass es im Rahmen der aktuellen SObjectizer-5.5-Architektur (und m√∂glicherweise noch globaler: im Rahmen der Prinzipien von SObjectizer-5 selbst) unm√∂glich ist, Nachrichten aus Dispatcher-Anforderungswarteschlangen zu entfernen, in denen Nachrichten warten, bis die empfangenden Agenten sie verarbeiten.  Der Versuch, dies zu tun, wird die ganze Idee heterogener Disponenten zunichte machen, die selbst der Benutzer je nach den Besonderheiten seiner Aufgabe (zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser</a> ) selbst machen kann.  Dar√ºber hinaus ist es beim Senden einer Nachricht im 1: N-Modus, in dem N gro√ü ist, teuer, eine Liste von Zeigern auf eine Instanz der gesendeten Nachricht in allen Warteschlangen zu f√ºhren. <br><br>  Dies bedeutet, dass zusammen mit der Nachricht eine Art Atomflag √ºbertragen werden muss, das unmittelbar nach dem Entfernen der Nachricht aus der Anforderungswarteschlange, jedoch bevor die Nachricht zur Verarbeitung an den empfangenden Agenten gesendet wird, analysiert werden muss.  Das hei√üt,  Die Nachricht wird in die Warteschlange gestellt und von dort nirgendwo entfernt.  Aber wenn die Nachricht an der Reihe ist, wird ihre Flagge √ºberpr√ºft.  Und wenn das Flag anzeigt, dass die Nachricht zur√ºckgezogen wurde, wird die Nachricht nicht verarbeitet. <br><br>  Dementsprechend besteht der Nachrichtenr√ºckruf selbst darin, einen speziellen Wert f√ºr das Atomflag innerhalb der Nachricht festzulegen. <br><br><h3>  Revocable_handle_t &lt;M&gt; -Objekt </h3><br>  Zweitens ist es bisher (?) Offensichtlich, dass zum Senden einer widerruflichen Nachricht nicht die √ºblichen Methoden zum Senden von Nachrichten verwendet werden sollten, sondern ein spezielles Objekt unter dem bedingten Namen revocable_handle_t. <br><br>  Um eine widerrufliche Nachricht zu senden, muss der Benutzer eine Instanz von revocable_handle_t erstellen und dann die send-Methode f√ºr diese Instanz aufrufen.  Und wenn die Nachricht zur√ºckgerufen werden muss, erfolgt dies mithilfe der Widerrufsmethode.  So etwas wie: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_message</span></span></span><span class="hljs-class"> {</span></span>...}; ... so_5::<span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_message&gt; msg; <span class="hljs-comment"><span class="hljs-comment">//    . msg.send(target, //  . ... //    my_message. ); ... //   . msg.revoke();</span></span></code> </pre> <br>  Es gibt noch keine klaren Details zur Implementierung von revocable_handle_t, was seitdem nicht √ºberraschend ist  Der Mechanismus der Arbeit von R√ºckrufnachrichten wurde noch nicht ausgew√§hlt.  Das Prinzip der Arbeit ist jedoch, dass in revocable_handle_t ein intelligenter Link zur gesendeten Nachricht und zum Atomflag daf√ºr gespeichert wird.  Die Methode revoke () versucht, den Flag-Wert zu ersetzen.  Wenn dies erfolgreich ist, wird die Nachricht nach dem Extrahieren aus der Bestellwarteschlange nicht mehr verarbeitet. <br><br><h3>  Womit es nicht befreundet sein wird </h3><br>  Leider gibt es einige Dinge, mit denen das Abrufen von Nachrichten nicht richtig verkn√ºpft werden kann.  Nur weil die zur√ºckgezogene Nachricht weiterhin in den Warteschlangen verbleibt, in denen sie bereits angekommen ist. <br><br><h4>  message_limits </h4><br>  Ein so wichtiges Merkmal von SObjectizer wie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">message_limits</a> soll Agenten vor √úberlastung sch√ºtzen.  Message_limits basieren auf der Anzahl der Nachrichten in der Warteschlange.  Eine Nachricht in die Warteschlange gestellt - der Z√§hler wurde erh√∂ht.  Aus der Reihe geraten - reduziert. <br><br>  Weil  Wenn eine Nachricht widerrufen wird, bleibt sie in der Warteschlange. Message_limits hat keinen Einfluss auf die Antwort der Nachricht.  Daher kann sich herausstellen, dass die Anzahl der Nachrichten vom Typ M in der Warteschlange begrenzt ist, aber alle wurden zur√ºckgerufen.  In der Tat wird keiner von ihnen verarbeitet.  Das Einreihen einer neuen Nachricht vom Typ M funktioniert jedoch nicht, da  das Limit ist √ºberschritten. <br><br>  Die Situation ist nicht gut.  Aber wie kommt man da raus?  Unverst√§ndlich. <br><br><h4>  Feste Warteschlangenketten </h4><br>  In SObjectizer kann eine Nachricht nicht nur an mbox, sondern auch an mchain gesendet werden (dies ist unser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Analogon zum CSP-Kanal</a> ).  Und Ketten k√∂nnen eine feste Gr√∂√üe f√ºr ihre Warteschlangen haben.  Der Versuch, eine neue Nachricht f√ºr mchain mit einer festen Gr√∂√üe in die vollst√§ndige mchain einzuf√ºgen, sollte zu einer Reaktion f√ºhren.  Warten Sie beispielsweise auf die Freigabe von Speicherplatz in der Warteschlange.  Oder um die √§lteste Nachricht zu pushen. <br><br>  Im Falle eines Nachrichtenr√ºckrufs bleibt er in der mchain-Warteschlange.  Es stellt sich heraus, dass die Nachricht nicht mehr ben√∂tigt wird, aber Platz in der mchain-Warteschlange beansprucht.  Und verhindert, dass neue Nachrichten an mchain gesendet werden. <br><br>  Die gleiche schlechte Situation wie bei message_limits.  Und wieder ist nicht klar, wie es behoben werden kann. <br><br><h2>  Was ist nicht klar, wie zu tun ist </h2><br>  Wir haben also die Wahl zwischen zwei (bisher?) Optionen f√ºr die Implementierung von R√ºckrufnachrichten.  Die erste Option ist einfach zu implementieren und erfordert keine √Ñnderung der Innereien von SObjectizer.  Die zweite Option ist viel komplizierter, aber darin wei√ü der Nachrichtenempf√§nger nicht einmal, dass es sich um widerrufbare Nachrichten handelt.  Wir werden jeden von ihnen kurz betrachten. <br><br><h3>  Empfangen Sie widerrufliche Nachrichten als widerrufliche_t &lt;M&gt; </h3><br>  Die erste L√∂sung, die erstens machbar und zweitens recht praktisch aussieht, ist die Einf√ºhrung eines speziellen Wrappers revocable_t &lt;M&gt;.  Wenn der Benutzer eine widerrufliche Nachricht vom Typ M √ºber revocable_handle_t &lt;M&gt; sendet, wird nicht die Nachricht M gesendet, sondern die Nachricht M innerhalb des speziellen Wrappers revocable_t &lt;M&gt;.  Dementsprechend empf√§ngt und verarbeitet der Benutzer nicht die Nachricht vom Typ M, sondern die Nachricht revocable_t &lt;M&gt;.  Zum Beispiel auf diese Weise: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">processor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request</span></span></span><span class="hljs-class"> {</span></span> ... }; <span class="hljs-comment"><span class="hljs-comment">// ,    . void so_define_agent() override { //   . so_subscribe_self().event( //     ,    //   . [this](mhood_t&lt; revocable_t&lt;request&gt; &gt; cmd) { // ,      . cmd-&gt;try_handle([this](mhood_t&lt;request&gt; msg) { ... }); }); ... } ... };</span></span></code> </pre> <br>  Die Methode revocable_t &lt;M&gt; :: try_handle () √ºberpr√ºft den Wert des Atom-Flags und ruft, wenn die Nachricht nicht abgerufen wird, die an sie √ºbergebene Lambda-Funktion auf.  Wenn die Nachricht zur√ºckgezogen wird, f√ºhrt try_handle () nichts aus. <br><br><h4>  Vor- und Nachteile dieses Ansatzes </h4><br>  Das Hauptplus ist, dass diese Reise leicht durchgef√ºhrt werden kann (zumindest soweit es scheint).  Tats√§chlich sind revocable_handle_t &lt;M&gt; und revocable_t &lt;M&gt; nur ein subtiles Add-On zum SObjectizer. <br><br>  Eingriffe in SObjectizer-Interna k√∂nnen erforderlich sein, um Freunde widerruflich_t und mutable_msg zu machen.  Tatsache ist, dass es in SObjectizer das Konzept unver√§nderlicher Nachrichten gibt (sie k√∂nnen sowohl im 1: 1-Modus als auch im 1: N-Modus gesendet werden).  Und es gibt das Konzept <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ver√§nderlicher Nachrichten</a> , die nur im 1: 1-Modus gesendet werden k√∂nnen.  In diesem Fall behandelt SObjectizer auf besondere Weise den Marker mutable_msg &lt;M&gt; und f√ºhrt zur Laufzeit die entsprechenden √úberpr√ºfungen durch.  Im Fall von revocable_t &lt;mutable_msg &lt;M&gt;&gt; m√ºssen Sie SObjectizer beibringen, dieses Konstrukt als mutable_msg &lt;M&gt; zu behandeln. <br><br>  Ein weiteres Plus ist, dass der zus√§tzliche Overhead (sowohl f√ºr die Metadaten der widerrufbaren Nachricht als auch f√ºr die √úberpr√ºfung des Atom-Flags) nur an Stellen anf√§llt, an denen Sie nicht darauf verzichten k√∂nnen.  Wenn R√ºckrufnachrichten nicht verwendet werden, entsteht √ºberhaupt kein zus√§tzlicher Aufwand. <br><br>  Aber das Hauptminus ist ideologisch.  Bei diesem Ansatz wirkt sich die Verwendung widerrufbarer Nachrichten sowohl auf den Absender (unter Verwendung von widerrufbar_handle_t &lt;M&gt;) als auch auf den Empf√§nger (unter Verwendung von widerrufbar_t &lt;M&gt;) aus.  Der Empf√§nger muss jedoch nicht wissen, dass er R√ºckrufnachrichten erh√§lt.  Dar√ºber hinaus k√∂nnen Sie als Empf√§nger einen vorgefertigten Drittanbieter-Agenten haben, der ohne revocable_t &lt;M&gt; geschrieben wurde. <br><br>  Dar√ºber hinaus bleiben ideologische Fragen offen, beispielsweise √ºber die M√∂glichkeit, solche Nachrichten weiterzuleiten.  Nach ersten Sch√§tzungen sind diese Probleme jedoch gel√∂st. <br><br><h3>  Empfangen Sie R√ºckrufnachrichten als regul√§re Nachrichten </h3><br>  Der zweite Ansatz besteht darin, nur die Nachricht vom Typ M auf der Empf√§ngerseite zu sehen und keine Vorstellung von der Existenz von revocable_handle_t &lt;M&gt; und revocable_t &lt;M&gt; zu haben.  Das hei√üt,  Wenn der Prozessor eine Anfrage erhalten soll, sollte er nur eine Anfrage ohne zus√§tzliche Wrapper sehen. <br><br>  Eigentlich kann man bei diesem Ansatz nicht auf einige Wrapper verzichten, aber sie werden im SObjectizer versteckt und der Benutzer sollte sie nicht sehen.  Nachdem die Anwendung aus der Warteschlange abgerufen wurde, stellt SObjectizer fest, dass es sich um eine speziell umschlossene widerrufbare Nachricht handelt, √ºberpr√ºft das Flag f√ºr die Relevanz der Nachricht und erweitert die Nachricht, falls sie noch relevant ist.  Anschlie√üend wird eine Nachricht zur Verarbeitung an den Agenten gesendet, als w√§re es eine regul√§re Nachricht. <br><br><h4>  Vor- und Nachteile dieses Ansatzes </h4><br>  Der Hauptvorteil dieses Ansatzes liegt auf der Hand: Der Nachrichtenempf√§nger wei√ü nicht, mit welchen Nachrichten er arbeitet.  Auf diese Weise kann der Absender von Nachrichten Nachrichten f√ºr alle Agenten ruhig zur√ºckziehen, auch f√ºr diejenigen, die von anderen Entwicklern geschrieben wurden. <br><br>  Ein weiteres wichtiges Plus ist die M√∂glichkeit, sich in den Mechanismus zur Verfolgung der Nachrichten√ºbermittlung zu integrieren ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier wird die Rolle dieses Mechanismus ausf√ºhrlicher beschrieben</a> ).  Das hei√üt,  Wenn msg_tracing aktiviert ist und der Absender die Nachricht zur√ºckzieht, finden Sie Spuren davon im msg_tracing-Protokoll.  Was beim Debuggen sehr praktisch ist. <br><br>  Der Hauptnachteil ist jedoch die Komplexit√§t der Implementierung dieses Ansatzes.  Dabei m√ºssen mehrere Faktoren ber√ºcksichtigt werden. <br><br>  Erstens Overhead.  Alle m√∂glichen Dinge. <br><br>  Angenommen, Sie k√∂nnen in einer Nachricht ein spezielles Flag erstellen, das angibt, ob diese Nachricht widerruflich ist oder nicht.  √úberpr√ºfen Sie dieses Flag, bevor Sie mit der Verarbeitung der einzelnen Nachrichten beginnen.  Grob gesagt wird dem Nachrichten√ºbermittlungsmechanismus ein weiteres if hinzugef√ºgt, das w√§hrend der Verarbeitung jeder (!) Nachricht funktioniert. <br><br>  Ich bin mir sicher, dass in realen Anwendungen der Verlust dabei kaum sp√ºrbar sein wird.  Aber der R√ºckgang bei synthetischen Benchmarks wird sicherlich auftreten.  Je abstrakter der Benchmark, desto weniger echte Arbeit leistet er, desto mehr wird er sinken.  Und das ist aus Marketing-Sicht schlecht, weil  Es gibt eine Reihe von Personen, die Schlussfolgerungen zum Rahmen in Bezug auf synthetische Benchmarks ziehen.  Und sie tun es speziell: Sie verstehen nicht, um welche Art von Benchmark es sich handelt, sondern zeigen im Grunde genommen an, auf welcher Hardware sie arbeiten, sondern vergleichen die Gesamtsummen mit der Leistung eines speziellen Tools, in einem anderen Szenario, auf einer anderen Hardware usw. ., usw. <br><br>  Da wir ein universelles Framework erstellen, das, wie sich herausstellt, anhand abstrakter Zahlen in abstrakten Benchmarks beurteilt wird, m√∂chten wir im Allgemeinen nicht beispielsweise 5% der Leistung im Zustellungsmechanismus <i>aller</i> Nachrichten verlieren, da eine Funktion hinzugef√ºgt wird, die nur Zeit ben√∂tigt von Zeit zu Zeit und nicht an alle Benutzer. <br><br>  Daher m√ºssen Sie sicherstellen, dass SObjectizer beim Senden der Nachricht an den Empf√§nger versteht, dass Sie beim Extrahieren der Nachricht auf besondere Weise damit umgehen m√ºssen.  Wenn eine Nachricht an einen Agenten √ºbermittelt wird, speichert SObjectizer im Prinzip mit der Nachricht einen Zeiger auf eine Funktion, die bei der Verarbeitung der Nachricht verwendet wird.  Dies wird jetzt ben√∂tigt, um asynchrone Nachrichten und synchrone Anforderungen auf unterschiedliche Weise zu verarbeiten.  So sieht die Anforderung der an den Agenten adressierten Nachricht aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">execution_demand_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//! Receiver of demand. agent_t * m_receiver; //! Optional message limit for that message. const message_limit::control_block_t * m_limit; //! ID of mbox. mbox_id_t m_mbox_id; //! Type of the message. std::type_index m_msg_type; //! Event incident. message_ref_t m_message_ref; //! Demand handler. demand_handler_pfn_t m_demand_handler; ... };</span></span></code> </pre> <br>  Wobei demand_handler_pfn_t ein regul√§rer Funktionszeiger ist: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">demand_handler_pfn_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">current_thread_id_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">execution_demand_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; )</span></span></span></span>;</code> </pre><br>  Der gleiche Mechanismus kann auch verwendet werden, um die zur√ºckgezogene Nachricht speziell zu verarbeiten.  Das hei√üt,  Wenn mbox eine Nachricht an den Agenten sendet, wei√ü der Agent, ob eine asynchrone Nachricht oder eine synchrone Anforderung an ihn gesendet wird.  Ebenso kann einem Agenten auf besondere Weise eine asynchrone R√ºckrufnachricht gegeben werden.  Der Agent speichert zusammen mit der Nachricht einen Zeiger auf eine Funktion, die wei√ü, wie er mit gesperrten Nachrichten umgehen soll. <br><br>  Alles scheint in Ordnung zu sein, aber es gibt zwei gro√üe "Aber" ... :( <br><br>  Erstens verf√ºgt die vorhandene mbox-Schnittstelle (n√§mlich die Klasse <a href="">abstract_message_mbox_t</a> ) √ºber keine Methoden zum Senden von R√ºckrufnachrichten.  Diese Schnittstelle muss also erweitert werden.  Und damit die mbox-Implementierungen anderer Leute, die mit abstract_message_box_t aus SObjectizer-5.5 verkn√ºpft sind, nicht kaputt gehen (insbesondere ist die mbox-Serie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">so_5_extra</a> implementiert und ich m√∂chte sie einfach nicht kaputt machen). <br><br>  Zweitens k√∂nnen Nachrichten nicht nur an mbox-s gesendet werden, hinter denen Agenten versteckt sind, sondern auch an mchain-s.  Welches sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">unsere Gegenst√ºcke zu CSP-Kan√§len?</a>  Und bis jetzt lagen die Anwendungen ohne zus√§tzliche Zeiger auf Funktionen.  So f√ºgen Sie einen zus√§tzlichen Zeiger in jedes Element der Anwendungswarteschlangen-Kette ein ... Sie k√∂nnen das nat√ºrlich, aber es sieht nach einer ziemlich teuren L√∂sung aus.  Dar√ºber hinaus haben die mchain-Implementierungen selbst bisher keine Situation vorgesehen, in der die extrahierte Nachricht √ºberpr√ºft und m√∂glicherweise weggeworfen werden muss. <br><br>  Wenn Sie versuchen, alle oben beschriebenen Probleme zusammenzufassen, besteht das Hauptproblem dieses Ansatzes darin, dass die Implementierung nicht so einfach ist, sodass sie in F√§llen, in denen keine R√ºckrufnachrichten verwendet werden, kosteng√ºnstig ist. <br><br><h3>  Aber was ist mit der garantierten Stornierung ausstehender Nachrichten? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich bef√ºrchte, das urspr√ºngliche Problem ist in der Wildnis der technischen Details verloren gegangen. </font><font style="vertical-align: inherit;">Angenommen, es gibt widerrufbare Nachrichten. Wie erfolgt die Stornierung ausstehender / periodischer Nachrichten? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier sind, wie sie sagen, Optionen m√∂glich. </font><font style="vertical-align: inherit;">Das Arbeiten mit ausstehenden / periodischen Nachrichten kann beispielsweise Teil der Funktionalit√§t von revocable_handle_t &lt;M&gt; sein:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_mesage&gt; msg; msg.send_delayed(target, <span class="hljs-number"><span class="hljs-number">15</span></span>s, ...); ... msg.revoke();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Oder Sie k√∂nnen zus√§tzlich zu revocable_handle_t &lt;M&gt; eine zus√§tzliche Hilfsklasse cancelable_timer_t &lt;M&gt; erstellen, die die Methoden send_delayed / send_periodic bereitstellt. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wei√üer Fleck: synchrone Anfragen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SObjectizer-5 unterst√ºtzt nicht nur die asynchrone Interaktion zwischen Entit√§ten im Programm (durch Senden von Nachrichten an mbox und mchain), sondern auch die synchrone Interaktion √ºber request_value / request_future. </font><font style="vertical-align: inherit;">Diese synchrone Interaktion funktioniert nicht nur f√ºr Agenten.</font></font> Das hei√üt,<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen nicht nur √ºber seine mbox eine synchrone Anfrage an einen Agenten senden. </font><font style="vertical-align: inherit;">Bei mchains k√∂nnen Sie auch synchrone Anforderungen stellen, z. B. an einen anderen Arbeitsthread, f√ºr den receive () oder select () f√ºr mchain aufgerufen wurde. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist daher immer noch unklar, ob synchrone Anforderungen in Verbindung mit widerrufbaren Nachrichten verwendet werden d√ºrfen. </font><font style="vertical-align: inherit;">Einerseits macht das vielleicht Sinn. </font><font style="vertical-align: inherit;">Und es k√∂nnte zum Beispiel so aussehen:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">revocable_handle_t</span></span>&lt;my_request&gt; msg; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f = msg.request_future&lt;my_reply&gt;(target, ...); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(some_condition) msg.revoke(); ... f.get(); <span class="hljs-comment"><span class="hljs-comment">//      revoke().</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Auf der anderen Seite gibt es immer noch viele unverst√§ndliche Nachrichten mit R√ºckrufnachrichten, so dass das Problem der synchronen Interaktion auf bessere Zeiten verschoben wurde. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W√§hlen Sie, aber seien Sie vorsichtig. </font><font style="vertical-align: inherit;">Aber w√§hle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt also ein Verst√§ndnis f√ºr das Problem. </font><font style="vertical-align: inherit;">Es gibt zwei M√∂glichkeiten, dies zu l√∂sen. </font><font style="vertical-align: inherit;">Was im Moment machbar erscheint. </font><font style="vertical-align: inherit;">Sie unterscheiden sich jedoch stark in der Benutzerfreundlichkeit des Benutzers und noch mehr in den Implementierungskosten. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen zwischen diesen beiden Optionen w√§hlen. </font><font style="vertical-align: inherit;">Oder sich etwas anderes einfallen lassen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist die Schwierigkeit bei der Auswahl? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Schwierigkeit besteht darin, dass SObjectizer ein freies Framework ist. </font><font style="vertical-align: inherit;">Er bringt uns kein Geld direkt. </font><font style="vertical-align: inherit;">Wir machen es, wie sie sagen, f√ºr uns. </font><font style="vertical-align: inherit;">Aus rein wirtschaftlichen Gr√ºnden ist eine einfachere und schnellere Implementierung rentabler.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andererseits wird nicht alles in Geld gemessen, und auf lange Sicht ist ein gut gemachtes Tool, dessen Funktionen normalerweise miteinander verkn√ºpft sind, besser als ein Patchwork-Patch aus Patches, die irgendwie zusammenkleben. Die Qualit√§t wird sowohl von den Benutzern als auch von uns selbst bewertet, wenn wir anschlie√üend unsere Entwicklung begleiten und neue Funktionen hinzuf√ºgen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Wahl liegt also tats√§chlich zwischen kurzfristigen Vorteilen und langfristigen Aussichten. In der modernen Welt sind C ++ - Tools mit langfristigen Aussichten zwar irgendwie neblig. Das macht die Wahl noch schwieriger. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unter solchen Bedingungen m√ºssen Sie w√§hlen. Achtung Aber w√§hle.</font></font><br><br><h1>  Fazit </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir versucht, den Prozess des Entwerfens und Implementierens neuer Funktionen in unserem Framework ein wenig zu zeigen. </font><font style="vertical-align: inherit;">Ein solcher Prozess findet regelm√§√üig bei uns statt. </font><font style="vertical-align: inherit;">Fr√ºher oft, weil </font><font style="vertical-align: inherit;">In den Jahren 2014-2016 hat sich SObjectizer viel aktiver entwickelt. </font><font style="vertical-align: inherit;">Jetzt hat sich das Tempo der Ver√∂ffentlichung neuer Versionen verringert. </font><font style="vertical-align: inherit;">Was objektiv ist, auch weil das Hinzuf√ºgen neuer Funktionen, ohne etwas zu besch√§digen, mit jeder neuen Version schwieriger wird. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich hoffe es war interessant, hinter die Kulissen zu schauen. </font><font style="vertical-align: inherit;">Vielen Dank f√ºr Ihre Aufmerksamkeit!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423879/">https://habr.com/ru/post/de423879/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423869/index.html">Die Zukunft der Arbeitspl√§tze. Die Hauptsache aus dem Bericht des Weltwirtschaftsforums</a></li>
<li><a href="../de423871/index.html">Wir l√∂sen ein logisches Problem f√ºr Studenten in SQL</a></li>
<li><a href="../de423873/index.html">PICASO 3D Designer X 3D-Drucker√ºbersicht</a></li>
<li><a href="../de423875/index.html">Speicherung einer gro√üen Anzahl von Dateien</a></li>
<li><a href="../de423877/index.html">29. bis 31. Oktober: Erstellen eines produktionsbereiten Kubernetes-Clusters</a></li>
<li><a href="../de423881/index.html">Was waren die Schwei√üer f√ºr Optik (Teil zwei)</a></li>
<li><a href="../de423885/index.html">Eine Einladung zu einer Lichtshow und ein kleiner Insider von der zuk√ºnftigen Circle of Light-Plattform in Moskau</a></li>
<li><a href="../de423889/index.html">Meine Entt√§uschung √ºber Software</a></li>
<li><a href="../de423891/index.html">Ausdrucksb√§ume f√ºr die Unternehmensentwicklung</a></li>
<li><a href="../de423893/index.html">Hallo Welt f√ºr den Empfang von Daten von einem Bluetooth (BLE) -Ger√§t √ºber C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>