<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî† üß§ ü§πüèΩ Tes Qt 5 Ketiga dengan PVS-Studio üöà üëåüèø üîï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari waktu ke waktu, tim kami memeriksa kembali proyek yang sudah kami tulis artikelnya. Proyek lain yang diperiksa ulang adalah Qt. Terakhir kali kam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tes Qt 5 Ketiga dengan PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/426485/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/87d/907/dd987d90784865f850555bc198a97b81.png" alt="PVS-Studio &amp; Qt"></div><br>  Dari waktu ke waktu, tim kami memeriksa kembali proyek yang sudah kami tulis artikelnya.  Proyek lain yang diperiksa ulang adalah Qt.  Terakhir kali kami mengujinya dengan PVS-Studio pada tahun 2014.  Sejak 2014, proyek mulai diperiksa secara teratur dengan bantuan Coverity.  Ini menarik.  Mari kita lihat apakah kita sekarang dapat menemukan kesalahan menarik menggunakan PVS-Studio. <br><a name="habracut"></a><br><h2>  Qt </h2><br>  Artikel sebelumnya: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cara mengurangi kemungkinan kesalahan pada tahap penulisan kode,</a> " Juli 2011. </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Qt 5 framework check</a> ," April 2014. </li></ul><br>  Kali ini <a href="">Qt Base</a> (Core, Gui, Widgets, Network, ...) dan <a href="">modul super Qt5 diuji</a> .  Tentang Qt Creator, kami berencana untuk menulis artikel terpisah nanti.  Untuk verifikasi, kami menggunakan penganalisa statis PVS-Studio, versi percobaan yang dapat Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">unduh</a> dari situs. <br><br>  Menurut pendapat subjektif saya, kode Qt telah menjadi lebih baik.  Selama bertahun-tahun sejak tes terakhir, banyak diagnostik baru telah muncul di alat analisa PVS-Studio.  Meskipun demikian, selama studi peninjauan peringatan, saya tidak menemukan banyak kesalahan untuk proyek sebesar ini.  Saya ulangi sekali lagi bahwa ini adalah kesan pribadi saya.  Saya tidak melakukan riset khusus tentang kepadatan kesalahan dulu atau sekarang. <br><br>  Kemungkinan besar, pemeriksaan rutin menggunakan penganalisa statis Coverity kemungkinan besar memengaruhi kualitas kode.  Pada tahun 2014, dengan bantuan Coverity, proyek Qt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qt-project</a> ) mulai diperiksa, dan pada 2016, Qt Creator ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qt-creator</a> ).  Pendapat saya: jika Anda sedang mengembangkan proyek terbuka, maka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Coverity Scan</a> dapat menjadi solusi gratis yang baik yang secara signifikan akan meningkatkan kualitas dan keandalan proyek Anda. <br><br>  Namun, seperti yang bisa ditebak oleh pembaca, jika saya tidak melihat sesuatu yang menarik dalam laporan PVS-Studio, maka tidak akan ada artikel :).  Dan karena ada artikel, yaitu cacat.  Mari lihat mereka.  Secara total, saya menulis 96 kesalahan. <br><br><h2>  Salin-Tempel dan Kesalahan Jenis yang tidak berhasil </h2><br>  Mari kita mulai dengan genre klasik, ketika penyebab kesalahan adalah kurangnya perhatian.  Kesalahan ini diremehkan oleh programmer.  Bagi yang belum membaca, saya sarankan Anda melihat dua artikel ini: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Efek baris terakhir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jahat hidup dalam fungsi perbandingan</a> </li></ul><br>  Kesalahan ini adalah antarbahasa.  Sebagai contoh, artikel kedua memberikan banyak contoh kesalahan dalam fungsi perbandingan yang ditulis dalam C, C ++ dan C #.  Sekarang, ketika mengimplementasikan dukungan bahasa Java di PVS-Studio, kami menemukan pola kesalahan yang sama.  Di sini, misalnya, adalah bug yang baru-baru ini kami temukan di perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hibernate</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object other)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (other instanceof Id) { Id that = (Id) other; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Jika Anda melihat lebih dekat, ternyata bidang Purchasingequequence dibandingkan dengan dirinya sendiri.  Opsi yang benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> that.purchaseSequence.equals(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseSequence) &amp;&amp; that.purchaseNumber == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.purchaseNumber;</code> </pre> <br>  Secara umum, semuanya seperti biasa, dan penganalisa PVS-Studio harus "menyapu kandang Augean" di proyek-proyek Jawa.  Ngomong-ngomong, kami mengundang semua orang untuk ikut serta dalam pengujian versi Beta PVS-Studio untuk Java, yang akan segera muncul dalam waktu dekat.  Untuk melakukan ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tulis kepada kami</a> (pilih "Saya ingin penganalisis untuk Java"). <br><br>  Sekarang kembali ke kesalahan dalam proyek Qt. <br><br>  <b>Cacat N1</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">windowDpiAwareness</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND hwnd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getWindowDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  Peringatan PVS-Studio: V501 CWE-571 Ada sub-ekspresi yang identik 'QWindowsContext :: user32dll.getWindowDpiAwarenessContext' di kiri dan di kanan operator '&amp;&amp;'.  qwindowscontext.cpp 150 <br><br>  Penjelasan khusus selain pesan analisa tidak diperlukan di sini.  Tampaknya bagi saya ungkapan itu seharusnya seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext &amp;&amp; QWindowsContext::user32dll.getWindowDpiAwarenessContext ? QWindowsContext::user32dll.getAwarenessFromDpiAwarenessContext( QWindowsContext::user32dll.getWindowDpiAwarenessContext(hwnd)) : <span class="hljs-number"><span class="hljs-number">-1</span></span>;</code> </pre> <br>  <b>Cacat N2, N3</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QReadWriteLockPrivate::release() { Q_ASSERT(!recursive); Q_ASSERT(!waitingReaders &amp;&amp; !waitingReaders &amp;&amp; !readerCount &amp;&amp; !writerCount); freelist-&gt;release(id); }</code> </pre> <br>  Peringatan PVS-Studio: V501 CWE-571 Ada sub-ekspresi yang identik ke kiri dan ke kanan operator '&amp;&amp;':! WaitingReaders &amp;&amp;!! WaitingReaders qreadwritelock.cpp 632 <br><br>  Kesalahan ada di dalam <i>kondisi</i> makro <i>Q_ASSERT</i> , jadi itu tidak signifikan.  Tapi tetap saja, ini sebuah kesalahan.  Variabel <i>waitingReaders</i> diperiksa dua kali.  Dan ternyata mereka lupa memeriksa beberapa variabel lainnya. <br><br>  Kesalahan identik ditemukan di baris 625 file qreadwritelock.cpp.  Salin-Tempel hidup lama!  :) <br><br>  <b>Cacat N4</b> <br><br><pre> <code class="cpp hljs">QString QGraphicsSceneBspTree::debug(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node-&gt;type == Node::Horizontal) { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tmp += debug(firstChildIndex(index)); tmp += debug(firstChildIndex(index) + <span class="hljs-number"><span class="hljs-number">1</span></span>); } .... }</code> </pre> <br>  Peringatan PVS-Studio: V523 CWE-691 Pernyataan 'then' sama dengan pernyataan 'else'.  qgraphicsscene_bsp.cpp 179 <br><br>  Kemungkinan besar, blok teks disalin, tetapi mereka lupa memperbaikinya. <br><br>  <b>Cacat N5</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> FillRule { OddEvenFill, WindingFill }; QDataStream &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&gt;&gt;(QDataStream &amp;s, QPainterPath &amp;p) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fillRule; s &gt;&gt; fillRule; Q_ASSERT(fillRule == Qt::OddEvenFill || Qt::WindingFill); .... }</code> </pre> <br>  PVS-Studio Warning: V768 CWE-571 Konstanta enumerasi 'WindingFill' digunakan sebagai variabel tipe-Boolean.  qpainterpath.cpp 2479 <br><br>  Setuju, ini blooper yang indah!  <i>Q_ASSERT</i> tidak memeriksa apa pun, karena kondisinya selalu benar.  Kondisi ini benar karena konstanta bernama <i>Qt :: WindingFill</i> adalah 1. <br><br>  <b>Cacat N6</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QVariant::canConvert(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> targetTypeId) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentType == QMetaType::SChar || currentType == QMetaType::Char) currentType = QMetaType::UInt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || currentType == QMetaType::Char) targetTypeId = QMetaType::UInt; .... }</code> </pre> <br>  Sebelum membaca peringatan, coba cari kesalahan ketik sendiri.  Dengan menambahkan gambar, saya akan membantu Anda untuk tidak segera membaca pesan analisa :). <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86f/f1d/7c5/86ff1d7c55cdc0fb71cbce45f2f84f05.png" alt="Waktunya berpikir"></div><br><br>  Peringatan PVS-Studio: V560 CWE-570 Bagian dari ekspresi kondisional selalu salah: currentType == QMetaType :: Char.  qvariant.cpp 3529 <br><br>  Kondisi "currentType == QMetaType :: Char" diperiksa di <i>if</i> pertama.  Jika kondisi terpenuhi, maka variabel <i>currentType</i> ditugaskan nilai <i>QMetaType :: UInt</i> .  Oleh karena itu, lebih lanjut variabel <i>currentType</i> tidak lagi sama dengan <i>QMetaType :: Char</i> .  Oleh karena itu, penganalisa melaporkan bahwa di kedua <i>jika,</i> subekspresi "currentType == QMetaType :: Char" selalu salah. <br><br>  Bahkan, yang kedua <i>kalau</i> harus seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (targetTypeId == QMetaType::SChar || targetTypeId == QMetaType::Char) targetTypeId = QMetaType::UInt;</code> </pre> <br><br>  <b>Catatan Diagnostik V560</b> <br><br>  Laporan itu menemukan banyak peringatan V560.  Namun, saya tidak melihat mereka lagi segera setelah saya menemukan kasus yang menarik untuk artikel tersebut, yang dianggap di atas sebagai cacat N6. <br><br>  Sebagian besar pesan V560 tidak dapat disebut false, tetapi tidak ada gunanya.  Dengan kata lain, mendeskripsikannya dalam sebuah artikel tidaklah menarik.  Untuk memperjelas apa yang sebenarnya saya maksud, pertimbangkan satu kasus seperti itu. <br><br><pre> <code class="cpp hljs">QString QTextHtmlExporter::findUrlForImage(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocument *doc, ....) { QString url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!doc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> url; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QTextDocument *parent = qobject_cast&lt;QTextDocument *&gt;(doc-&gt;parent())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> findUrlForImage(parent, cacheKey, isPixmap); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc &amp;&amp; doc-&gt;docHandle()) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Peringatan PVS-Stuidio: V560 CWE-571 Bagian dari ekspresi kondisional selalu benar: doc.  qtextdocument.cpp 2992 <br><br>  Analyzer benar-benar benar bahwa pointer <i>doc</i> tidak selalu <i>nullptr</i> ketika diperiksa ulang.  Tapi ini bukan kesalahan, hanya programmer saja yang aman.  Anda dapat menyederhanakan kode dengan menulis: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doc-&gt;docHandle()) {</code> </pre> <br>  <b>Cacat N7</b> <br><br>  Dan kasus terakhir, yang bisa digolongkan sebagai salah ketik.  Kesalahan terjadi karena kebingungan dalam nama-nama konstanta, yang hanya berbeda dalam kasus huruf pertama. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... } QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) .... }</code> </pre> <br>  Peringatan PVS-Studio: V616 CWE-480 'CursorShowing' dinamai konstan dengan nilai 0 digunakan dalam operasi bitwise.  qwindowscursor.cpp 669 <br><br>  Secara lebih rinci, saya sudah menganalisis kesalahan ini dalam sebuah catatan kecil yang terpisah: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sekali lagi, penganalisa PVS-Studio ternyata lebih penuh perhatian</a> daripada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seseorang</a> ." <br><br><h2>  Kelemahan keamanan </h2><br>  Bahkan, semua kesalahan yang dibahas dalam artikel ini bisa disebut cacat keamanan.  Semuanya diklasifikasikan menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penghitungan Kelemahan Umum</a> (lihat ID CWE dalam pesan analisis).  Jika kesalahan diklasifikasikan sebagai CWE, mereka berpotensi risiko keamanan.  Ini dijelaskan lebih terinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman SAST PVS-Studio</a> . <br><br>  Namun, saya ingin memilih sejumlah kesalahan menjadi kelompok yang terpisah.  Mari kita lihat mereka. <br><br>  <b>Cacat N8, N9</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... SetSecurityDescriptorOwner(pSD.data(), pTokenUser-&gt;User.Sid, FALSE); SetSecurityDescriptorGroup(pSD.data(), pTokenGroup-&gt;PrimaryGroup, FALSE); .... }</code> </pre> <br>  Peringatan PVS-Studio: <br><br><ul><li>  V530 CWE-252 Nilai kembali fungsi 'SetSecurityDescriptorOwner' diperlukan untuk digunakan.  qlocalserver_win.cpp 167 </li><li>  V530 CWE-252 Nilai kembali fungsi 'SetSecurityDescriptorGroup' diperlukan untuk digunakan.  qlocalserver_win.cpp 168 </li></ul><br>  Ada berbagai fungsi yang terkait dengan kontrol akses.  Fungsi-fungsi <i>SetSecurityDescriptorOwner</i> dan <i>SetSecurityDescriptorGroup</i> adalah di antara mereka. <br><br>  Dengan fungsi seperti itu Anda harus bekerja dengan sangat hati-hati.  Misalnya, Anda harus memeriksa status yang mereka kembalikan.  Apa yang terjadi jika panggilan ke fungsi-fungsi ini gagal?  Menebak tidak perlu, perlu menulis kode untuk menangani kasus ini. <br><br>  Tidak perlu mengambil keuntungan dari kurangnya verifikasi dan mengubah kesalahan tersebut menjadi kerentanan.  Namun, ini sama sekali bukan tempat untuk risiko, dan Anda perlu menulis kode yang lebih aman. <br><br>  <b>Cacat N10</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QLocalServerPrivate::addListener() { .... InitializeAcl(acl, aclSize, ACL_REVISION_DS); .... }</code> </pre> <br>  PVS-Studio Warning: V530 CWE-252 Nilai pengembalian fungsi 'InitializeAcl' harus digunakan.  qlocalserver_win.cpp 144 <br><br>  Situasinya mirip dengan yang dibahas di atas. <br><br>  <b>Cacat N11, N12</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sha1ProcessChunk</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... quint8 chunkBuffer[<span class="hljs-number"><span class="hljs-number">64</span></span>]; .... <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SHA1_WIPE_VARIABLES .... memset(chunkBuffer, 0, 64); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V597 CWE-14 Kompiler dapat menghapus panggilan fungsi 'memset', yang digunakan untuk membersihkan buffer 'chunkBuffer'.  Fungsi RtlSecureZeroMemory () harus digunakan untuk menghapus data pribadi.  sha1.cpp 189 <br><br>  Kompiler akan menghapus panggilan fungsi <i>memset</i> .  Sudah berkali-kali dalam artikel saya menganalisis situasi ini.  Saya tidak ingin mengulang sendiri.  Saya merujuk ke artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembersihan Data Pribadi yang Aman</a> ". <br><br>  Dan kesalahan lain ada di file sha1.cpp yang sama, di baris 247. <br><br><h2>  Pointer kosong </h2><br>  Sudah waktunya untuk berbicara tentang petunjuk.  Ada banyak kesalahan dalam topik ini. <br><br>  <b>Cacat N13</b> <br><br><pre> <code class="cpp hljs">QByteArray &amp;QByteArray::append(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *str, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) len = qstrlen(str); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (str &amp;&amp; len) { .... }</code> </pre> <br>  Peringatan PVS-Studio: V595 CWE-476 Pointer 'str' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2118, 2119. qbytearray.cpp 2118 <br><br>  Situasi klasik adalah ketika pointer digunakan di awal dan kemudian diperiksa untuk kesetaraan <i>nullptr</i> .  Ini adalah pola kesalahan yang sangat umum, dan kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">melihatnya</a> secara teratur di hampir semua proyek. <br><br>  <b>Cacat N14, N15</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> QMetaObjectPrivate *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">priv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> uint* data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObjectPrivate*&gt;(data); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isFlag() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsFlag; }</code> </pre> <br>  Peringatan PVS-Studio: V595 CWE-476 Pointer 'mobj' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2671, 2672. qmetaobject.cpp 2671 <br><br>  Untuk jaga-jaga, saya membawa tubuh fungsi <i>priv</i> .  Untuk beberapa alasan, terkadang pembaca mulai menemukan situasi di mana kode akan berfungsi.  Saya tidak mengerti dari mana ketidakpercayaan ini berasal dan keinginan untuk melihat fitur yang rumit salah :).  Misalnya, seseorang dapat menyarankan dalam komentar bahwa <i>priv</i> adalah makro dari formulir: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> priv(A) foo(sizeof(A))</span></span></code> </pre> <br>  Maka semuanya akan bekerja. <br><br>  Untuk menghindari diskusi seperti itu, saya mencoba mengutip fragmen kode di mana semua informasi yang mengkonfirmasi adanya kesalahan disediakan. <br><br>  Jadi, penunjuk <i>modj</i> dereferensi dan kemudian diperiksa. <br><br>  Lebih jauh lagi pada adegan datang Copy-Paste "perkasa dan mengerikan".  Karena kesalahan yang persis sama terdeteksi pada fungsi <i>isScoped</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QMetaEnum::isScoped() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> offset = priv(mobj-&gt;d.data)-&gt;revision &gt;= <span class="hljs-number"><span class="hljs-number">8</span></span> ? <span class="hljs-number"><span class="hljs-number">2</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mobj &amp;&amp; mobj-&gt;d.data[handle + offset] &amp; EnumIsScoped; }</code> </pre> <br>  Peringatan PVS-Studio: V595 CWE-476 Pointer 'mobj' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2683, 2684. qmetaobject.cpp 2683 <br><br>  <b>Cacat N16-N21</b> <br><br>  Pertimbangkan contoh lain dan, saya pikir, cukup. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QTextCursor::insertFragment(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QTextDocumentFragment &amp;fragment) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!d || !d-&gt;priv || fragment.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; d-&gt;priv-&gt;beginEditBlock(); d-&gt;remove(); fragment.d-&gt;insert(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); d-&gt;priv-&gt;endEditBlock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fragment.d &amp;&amp; fragment.d-&gt;doc) d-&gt;priv-&gt;mergeCachedResources(fragment.d-&gt;doc-&gt;docHandle()); }</code> </pre> <br>  Peringatan PVS-Studio: V595 CWE-476 Pointer 'fragment.d' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2238, 2241. qtextcursor.cpp 2238 <br><br>  Semua sama saja.  Perhatikan urutan pekerjaan dengan pointer yang disimpan dalam <i>fragmen</i> variabel. <br><br>  Kesalahan lain dari jenis ini: <br><br><ul><li>  V595 CWE-476 Pointer 'window' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 1846, 1848. qapplication.cpp 1846 </li><li>  V595 CWE-476 Pointer 'window' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 1858, 1860. qapplication.cpp 1858 </li><li>  V595 CWE-476 Pointer 'reply' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 492, 502. qhttpnetworkconnectionchannel.cpp 492 </li><li>  V595 CWE-476 Pointer 'newHandle' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 877, 883. qsplitter.cpp 877 </li><li>  V595 CWE-476 Pointer 'widget' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2320, 2322. qwindowsvistastyle.cpp 2320 </li><li>  Bahkan, ada lebih banyak kesalahan.  Dengan cepat aku bosan mempelajari peringatan V595, dan untuk artikel itu aku sudah menulis cukup banyak fragmen kode. </li></ul><br>  <b>Cacat N22-N33</b> <br><br>  Ada kode di mana pointer diperiksa bahwa operator <i>baru</i> kembali.  Ini sangat lucu di tengah fakta bahwa ada banyak tempat di mana hasil dari fungsi <i>malloc</i> tidak diperiksa (lihat kelompok kesalahan berikut). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QTranslatorPrivate::do_load(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;realname, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QString &amp;directory) { .... d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d-&gt;unmapPointer) { file.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>); qint64 readResult = file.read(d-&gt;unmapPointer, d-&gt;unmapLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readResult == qint64(unmapLength)) ok = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } .... }</code> </pre> <br>  Peringatan PVS-Studio: V668 CWE-571 Tidak ada gunanya menguji pointer 'd-&gt; unmap Pointer' terhadap null, karena memori dialokasikan menggunakan operator 'baru'.  Pengecualian akan dihasilkan jika terjadi kesalahan alokasi memori.  qtranslator.cpp 596 <br><br>  Memeriksa pointer tidak masuk akal, karena jika terjadi kesalahan alokasi memori, pengecualian <i>std :: bad_alloc</i> akan <i>dibuang</i> .  Jika Anda ingin operator <i>baru</i> mengembalikan <i>nullptr</i> ketika tidak ada cukup memori, maka Anda harus menulis: <br><br><pre> <code class="cpp hljs">d-&gt;unmapPointer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::nothrow) <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[d-&gt;unmapLength];</code> </pre> <br>  Penganalisa tahu tentang penggunaan operator <i>baru ini</i> dan tidak akan memberikan peringatan dalam kasus ini. <br><br>  Kesalahan lainnya: Saya akan memberi mereka file <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qt-V668.txt</a> . <br><br>  <b>Cacat N34-N70</b> <br><br>  Seperti yang dijanjikan, sekarang giliran kesalahan ketika mereka tidak memeriksa hasil dari memanggil fungsi <i>malloc</i> , <i>calloc</i> , <i>strdup</i> , dll.  Kesalahan ini lebih serius daripada yang terlihat pada pandangan pertama.  Lebih detail: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mengapa penting untuk memeriksa apa fungsi malloc dikembalikan</a> ." <br><br><pre> <code class="cpp hljs">SourceFiles::SourceFiles() { nodes = (SourceFileNode**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFileNode*)*(num_nodes=<span class="hljs-number"><span class="hljs-number">3037</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = <span class="hljs-number"><span class="hljs-number">0</span></span>; n &lt; num_nodes; n++) nodes[n] = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }</code> </pre> <br>  Peringatan PVS-Studio: V522 CWE-690 Mungkin ada dereferensi 'simpul' penunjuk null potensial.  Periksa baris: 138, 136. makefiledeps.cpp 138 <br><br>  Pointer digunakan tanpa verifikasi sebelumnya. <br><br>  Semua kesalahan ini bertipe sama, jadi saya tidak akan membahasnya lebih detail.  Saya akan memberikan sisa daftar peringatan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qt-V522-V575.txt</a> . <br><br><h2>  Kesalahan logis dalam kondisi </h2><br>  <b>Cacat N71</b> <br><br><pre> <code class="cpp hljs">QString QEdidParser::parseEdidString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> quint8 *data) { <span class="hljs-function"><span class="hljs-function">QByteArray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">buffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">reinterpret_cast</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *&gt;(data), </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">13</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Erase carriage return and line feed buffer = buffer.replace('\r', '\0').replace('\n', '\0'); // Replace non-printable characters with dash for (int i = 0; i &lt; buffer.count(); ++i) { if (buffer[i] &lt; '\040' &amp;&amp; buffer[i] &gt; '\176') buffer[i] = '-'; } return QString::fromLatin1(buffer.trimmed()); }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V547 CWE-570 Ekspresi 'buffer [i] &lt;' \ 040 '&amp;&amp; buffer [i]&gt;' \ 176 '' selalu salah.  qedidparser.cpp 169 <br><br>  Fungsi harus melakukan tindakan berikut "Ganti karakter yang tidak dapat dicetak dengan tanda hubung".  Namun, dia tidak melakukannya.  Mari kita perhatikan lebih dekat kondisi ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> &amp;&amp; buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  Itu tidak masuk akal.  Karakter tidak boleh kurang dari '\ 040' dan lebih besar dari '\ 176' secara bersamaan.  Dalam kondisi Anda harus menggunakan operator '||'.  Kode yang benar adalah: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (buffer[i] &lt; <span class="hljs-string"><span class="hljs-string">'\040'</span></span> || buffer[i] &gt; <span class="hljs-string"><span class="hljs-string">'\176'</span></span>)</code> </pre> <br>  <b>Cacat N72</b> <br><br>  Kesalahan serupa, karena pengguna Windows tidak beruntung. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(Q_OS_WIN) static QString driveSpec(const QString &amp;path) { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (path.size() </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 2) return QString(); char c = path.at(0).toLatin1(); if (c &lt; 'a' &amp;&amp; c &gt; 'z' &amp;&amp; c &lt; 'A' &amp;&amp; c &gt; 'Z') return QString(); if (path.at(1).toLatin1() != ':') return QString(); return path.mid(0, 2); } #endif</span></span></span></span></code> </pre> <br>  Penganalisa menghasilkan dua peringatan sekaligus: <br><br><ul><li>  V590 CWE-571 Pertimbangkan untuk memeriksa ekspresi 'c &lt;' a '&amp;&amp; c&gt;' z '&amp;&amp; c &lt;' A '&amp;&amp; c&gt;' Z '.  Ekspresi berlebihan atau mengandung kesalahan cetak.  qdir.cpp 77 </li><li>  V560 CWE-570 Bagian dari ekspresi kondisional selalu salah: c&gt; 'z'.  qdir.cpp 77 </li></ul><br>  Kesalahan logis dalam kondisi: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span> &amp;&amp; c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> &amp;&amp; c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>)</code> </pre> <br>  Seperti yang saya pahami, programmer ingin menemukan karakter yang bukan huruf alfabet Latin.  Dalam hal ini, kondisinya harus seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((c &lt; <span class="hljs-string"><span class="hljs-string">'a'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'z'</span></span>) &amp;&amp; (c &lt; <span class="hljs-string"><span class="hljs-string">'A'</span></span> || c &gt; <span class="hljs-string"><span class="hljs-string">'Z'</span></span>))</code> </pre> <br>  <b>Cacat N73</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SelectionMode { NoSelection, SingleSelection, MultiSelection, ExtendedSelection, ContiguousSelection }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QAccessibleTableCell::unselectCell() { QAbstractItemView::SelectionMode selectionMode = view-&gt;selectionMode(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode &amp; QAbstractItemView::NoSelection)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; .... }</code> </pre> <br>  Peringatan PVS-Studio: V616 CWE-480 The 'QAbstractItemView :: NoSelection' dinamai konstan dengan nilai 0 digunakan dalam operasi bitwise.  itemviews.cpp 976 <br><br>  Konstanta <i>QAbstractItemView :: NoSelection bernama</i> adalah nol.  Oleh karena itu, subekspresi <i>(selectionMode &amp; QAbstractItemView :: NoSelection)</i> tidak masuk akal.  Itu akan selalu 0. <br><br>  Saya pikir itu harus ditulis di sini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_index.isValid() || (selectionMode == QAbstractItemView::NoSelection))</code> </pre> <br>  <b>Cacat N74</b> <br><br>  Kode berikut sulit bagi saya untuk mengerti.  Dia salah, tapi aku tidak tahu harus jadi apa dia.  Mengomentari suatu fungsi juga tidak membantu saya. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Re-engineered from the inline function _com_error::ErrorMessage(). // We cannot use it directly since it uses swprintf_s(), which is not // present in the MSVCRT.DLL found on Windows XP (QTBUG-35617). static inline QString errorMessageFromComError(const _com_error &amp;comError) { TCHAR *message = nullptr; FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, DWORD(comError.Error()), MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT), message, 0, NULL); if (message) { const QString result = QString::fromWCharArray(message).trimmed(); LocalFree(static_cast&lt;HLOCAL&gt;(message)); return result; } if (const WORD wCode = comError.WCode()) return QString::asprintf("IDispatch error #%u", uint(wCode)); return QString::asprintf("Unknown error 0x0%x", uint(comError.Error())); }</span></span></code> </pre> <br>  Peringatan PVS-Studio: 'pesan' Ekspresi V547 CWE-570 selalu salah.  qwindowscontext.cpp 802 <br><br>  Pemrogram mungkin berasumsi bahwa fungsi <i>FormatMessage</i> akan mengubah nilai penunjuk <i>pesan</i> .  Tapi ini tidak benar.  Fungsi <i>FormatMessage</i> tidak dapat mengubah nilai pointer, karena diteruskan ke fungsi berdasarkan nilai.  Berikut adalah prototipe dari fungsi ini: <br><br><pre> <code class="cpp hljs">DWORD __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FormatMessageW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments )</span></span></span></span>;</code> </pre> <br><br><h2>  Kebocoran memori potensial </h2><br>  <b>Cacat N75-N92</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourceDependChildren</span></span></span><span class="hljs-class"> {</span></span> SourceFile **children; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num_nodes, used_nodes; SourceDependChildren() : children(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>), num_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>), used_nodes(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } ~SourceDependChildren() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (children) <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(children); children = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addChild</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SourceFile *s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(num_nodes &lt;= used_nodes) { num_nodes += <span class="hljs-number"><span class="hljs-number">200</span></span>; children = (SourceFile**)<span class="hljs-built_in"><span class="hljs-built_in">realloc</span></span>(children, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(SourceFile*)*(num_nodes)); } children[used_nodes++] = s; } };</code> </pre> <br>  Peringatan PVS-Studio: V701 CWE-401 realloc () kemungkinan kebocoran: ketika realloc () gagal mengalokasikan memori, penunjuk asli 'anak-anak' hilang.  Pertimbangkan untuk menetapkan realloc () ke pointer sementara.  makefiledeps.cpp 103 <br><br>  Perluasan buffer dilakukan dengan cara yang berbahaya.  Jika fungsi <i>realokasi</i> tidak dapat mengalokasikan memori, itu akan mengembalikan <i>NULL</i> .  <i>NULL</i> ini akan segera ditempatkan dalam variabel <i>anak</i> - <i>anak</i> dan tidak akan ada kemungkinan untuk membebaskan buffer yang dialokasikan sebelumnya.  Kebocoran memori akan terjadi. <br><br>  Kesalahan serupa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">qt-701.txt</a> . <br><br><h2>  Lain-lain </h2><br>  <b>Cacat N93</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GradientBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">typename</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlendType</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QT_FASTCALL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qt_fetch_linear_gradient_template</span></span></span><span class="hljs-class">(....) {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t+inc*length &lt; qreal(INT_MAX &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>)) &amp;&amp; t+inc*length &gt; qreal(INT_MIN &gt;&gt; (FIXPT_BITS + <span class="hljs-number"><span class="hljs-number">1</span></span>))) { .... }</code> </pre> <br>  Peringatan PVS-Studio: V610 CWE-758 Perilaku tidak spesifik.  Periksa operator shift '&gt;&gt;'.  Operan kiri '(- 2147483647 - 1)' negatif.  qdrawhelper.cpp 4015 <br><br>  Nilai negatif <i>INT_MIN</i> tidak dapat digeser.  Ini adalah perilaku yang tidak ditentukan, dan Anda tidak dapat mengandalkan hasil dari operasi semacam itu.  Bit paling signifikan bisa sama dengan 0 atau 1. <br><br>  <b>Cacat N94</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QObjectPrivate::addConnection(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signal, Connection *c) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &gt;= connectionLists-&gt;count()) connectionLists-&gt;resize(signal + <span class="hljs-number"><span class="hljs-number">1</span></span>); ConnectionList &amp;connectionList = (*connectionLists)[signal]; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (signal &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... }</code> </pre> <br>  Peringatan PVS-Studio: V781 CWE-129 Nilai dari variabel 'sinyal' diperiksa setelah digunakan.  Mungkin ada kesalahan dalam logika program.  Periksa baris: 397, 413. qobject.cpp 397 <br><br>  Pemeriksaan <i>(sinyal &lt;0)</i> menunjukkan bahwa nilai argumen <i>sinyal</i> mungkin negatif.  Namun, argumen ini sebelumnya digunakan untuk mengindeks array.  Ternyata pemeriksaan dilakukan terlambat.  Program sudah akan terganggu. <br><br>  <b>Cacat N95</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> QXmlStreamWriterPrivate::finishStartElement(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> contents) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { write(<span class="hljs-string"><span class="hljs-string">"/&gt;"</span></span>); QXmlStreamWriterPrivate::Tag &amp;tag = tagStack_pop(); lastNamespaceDeclaration = tag.namespaceDeclarationsSize; lastWasStartElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { write(<span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>); } inStartElement = inEmptyElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; lastNamespaceDeclaration = namespaceDeclarations.size(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hadSomethingWritten; }</code> </pre> <br>  PVS-Studio Warning: V519 CWE-563 Variabel 'lastNamespaceDeclaration' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 3188, 3194. qxmlstream.cpp 3194 <br><br>  Saya akan menyoroti esensi kesalahan: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inEmptyElement) { lastNamespaceDeclaration = tag.namespaceDeclarationsSize; } lastNamespaceDeclaration = namespaceDeclarations.size();</code> </pre> <br>  <b>Cacat N96</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QRollEffect::scroll() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentHeight != totalHeight) { currentHeight = totalHeight * (elapsed/duration) + (<span class="hljs-number"><span class="hljs-number">2</span></span> * totalHeight * (elapsed%duration) + duration) / (<span class="hljs-number"><span class="hljs-number">2</span></span> * duration); <span class="hljs-comment"><span class="hljs-comment">// equiv. to int((totalHeight*elapsed) / duration + 0.5) done = (currentHeight &gt;= totalHeight); } done = (currentHeight &gt;= totalHeight) &amp;&amp; (currentWidth &gt;= totalWidth); .... }</span></span></code> </pre> <br>  V519 CWE-563 Variabel 'selesai' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 509, 511. qeffects.cpp 511 <br><br>  Semuanya sama seperti pada kasus sebelumnya.  Perhatikan variabel yang <i>dilakukan</i> . <br><br><h2>  Kesimpulan </h2><br>  Bahkan melihat melalui laporan itu secara dangkal, saya menulis hampir 100 kesalahan.  Saya senang dengan hasil PVS-Studio. <br><br>  Tentu saja, pemeriksaan kode langka semacam itu tidak ada hubungannya dengan peningkatan kualitas dan keandalan kode.  Mereka hanya menunjukkan kemampuan penganalisa kode.  Alat analisis statis harus diterapkan secara teratur.  Dalam hal ini, mereka mengurangi biaya memperbaiki bug dan melindungi aplikasi dari banyak kerentanan potensial. <br><br>  Terima kasih atas perhatian anda  Untuk mengikuti publikasi baru kami, saya mengundang Anda untuk berlangganan salah satu saluran kami: <ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VK.com</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pvsstudio_rus</a> </li><li>  "Sekolah tua" RSS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">viva64-blog-ru</a> </li><li>  Twitter: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@pvsstudio_rus</a> </li><li>  Telegram: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@pvsstudio_rus</a> </li></ol><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br>  Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemeriksaan Ketiga Qt 5 dengan PVS-Studio</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id426485/">https://habr.com/ru/post/id426485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id426475/index.html">Miya - asisten dari smartphone</a></li>
<li><a href="../id426477/index.html">Seluruh kebenaran tentang RTOS. Artikel # 15. Partisi Memori: Layanan dan Struktur Data</a></li>
<li><a href="../id426479/index.html">Bangku tes buatan sendiri untuk motherboard</a></li>
<li><a href="../id426481/index.html">Hexagon Maps in Unity: Path Finder, Pemain Regu, Animasi</a></li>
<li><a href="../id426483/index.html">Seseorang yang menyusul Tesla. Agar lebih menguntungkan</a></li>
<li><a href="../id426487/index.html">Tes otomatisasi dari awal. Bagian 1</a></li>
<li><a href="../id426489/index.html">Tentang hubungan bilangan prima dan irasional</a></li>
<li><a href="../id426491/index.html">Minggu Keamanan 39: pada kematian Google+</a></li>
<li><a href="../id426493/index.html">Diskon konstan dari hoster untuk pengunjung VPS dan VPS.today Cari</a></li>
<li><a href="../id426495/index.html">Desainer Solo. Cara membangun karier saat Anda bekerja sendirian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>