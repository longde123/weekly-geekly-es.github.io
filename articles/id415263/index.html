<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤´ğŸ¾ ğŸ§—ğŸ» ğŸ¤¼ Bagaimana kami menambahkan pintu masuk ke peta dan mengurangi ukuran pangkalan sebesar 10% ğŸ·ï¸ ğŸ”‰ ğŸ‘©ğŸ¼â€ğŸ­</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada akhir bulan lalu, 2GIS mulai menampilkan beranda. Kami telah menunjukkan pintu masuk ke organisasi sejak 2013, dan pintu masuk tampaknya merupaka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana kami menambahkan pintu masuk ke peta dan mengurangi ukuran pangkalan sebesar 10%</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/2gis/blog/415263/"><img src="https://habrastorage.org/webt/en/6k/fp/en6kfpoagwhj42loeubjzo0rzo0.jpeg"><br><br>  Pada akhir bulan lalu, 2GIS mulai menampilkan beranda.  Kami telah menunjukkan pintu masuk ke organisasi sejak 2013, dan pintu masuk tampaknya merupakan pintu masuk yang sama.  Jadi mengapa sekarang?  Semua produk dan proses internal siap, yang perlu Anda lakukan adalah menambahkan sedikit lebih banyak dan memperbaiki tampilan di UI. <br><br>  Selain jawaban standar "Ada prioritas lain," ada juga yang tidak cukup standar: "Tidak begitu sederhana."  Artikel ini adalah tentang kesulitan apa dan bagaimana kami menyelesaikannya. <br><a name="habracut"></a><br>  Pertama, pintu masuk bukan pintu masuk.  Jadi, dalam satu pintu masuk bisa mengarah beberapa pintu masuk, biasanya dari sisi bangunan yang berbeda.  Definisi "blok apartemen (multi-level) dengan pintu masuk bersama" juga salah.  Kebetulan bahwa satu pintu masuk mengarah ke lantai pertama dari pintu masuk, dan yang lainnya - ke lantai kedua dan selanjutnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zz/w7/pr/zzw7prchtb-1ictjkzvrfd6c_-8.png" alt="Masuk dengan dua pintu masuk"></div><br>  Kedua, saya ingin mencari pintu masuk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yb/ty/ut/ybtyutk7jllplorjkmqiywob1ha.png" alt="Pintu masuk dalam hasil pencarian"></div><br>  Ini adalah kesempatan yang cukup dicari, karena pintu masuknya jauh dari selalu terletak di jalan yang jelas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fm/j7/41/fmj741efgjyhdj29y3udi2lsjym.png" alt="Rumah dengan penomoran masuk bukan yang paling jelas"></div><br>  Selain nomor masuk, ada juga nama (biasanya dari satu huruf). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ef/wk/2d/efwk2d9a_gsaw5vokxqoyiqzuzm.png" alt="Surat-surat atas nama beranda"></div><br>  Atau bahkan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di Kaliningrad</a> - alamat terpisah diberikan tepat ke tangga. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rw/iz/4w/rwiz4wywzkk_nnjll6xzrpy5k1o.png" alt="Penomoran pintu masuk independenced di Kaliningrad"></div><br>  Ketiga, kami memutuskan bahwa jika kami ingin melakukan pencarian pintu masuk, maka mengapa tidak segera mendukung pencarian dengan nomor apartemen.  Mereka memutuskan - dan mengumpulkan rentang apartemen, sejauh ini tanpa lantai mengikat.  Seperti halnya pintu masuk, apartemen tidak hanya memiliki nama numerik (paling sering ada varian dengan huruf "a"), dan rentangnya jauh dari selalu kontinu.  Di rumah-rumah tua St. Petersburg, penomorannya agak aneh: apartemen 1 dan 3 bisa berada di pintu masuk yang sama, dan apartemen 2 bisa berada di seberang gedung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/se/uh/m2seuh3ovc_5ob8b1ulcdlru8x8.jpeg" alt="Pintu masuk khas Petersburg tua"></div><br><div class="spoiler">  <b class="spoiler_title">Penyimpangan liris tentang validasi data</b> <div class="spoiler_text">  Jangan mencoba membuat validasi data yang dikumpulkan dengan sangat cerdas - di ibu kota utara ada kasus-kasus ketika Anda dapat masuk ke satu apartemen dari beberapa pintu masuk, dan di beberapa pemukiman Eropa, alamat itu berisi di samping nama pintu masuk dan nomor apartemen di pintu masuk ini.  Peter juga senang dengan sebuah bangunan dengan dua pintu masuk kedelapan. <br></div></div><br>  Keempat, saya ingin selalu menunjukkan pintu masuk di peta, dan tidak hanya ketika kita mempelajari informasi rumah atau pintu masuk tertentu. <br><br>  Dan, akhirnya, ada banyak pintu masuk - menurut perkiraan saat ini, ada sekitar seratus ribu di antaranya di Moskow saja.  Penilaian pertama "di jari" memang memberikan beberapa angka astronomi - kami melakukan kesalahan setiap enam kali ke sisi yang lebih besar. <br><br>  <b>Kesimpulan:</b> <br><br><ul><li>  Kami membutuhkan entitas tambahan, yang memiliki namanya sendiri, berisi daftar rentang apartemen dan yang dapat dilampirkan di pintu masuk gedung. </li><li>  Kami akan mencari entitas ini dan akan menunjukkannya kartu informasi terpisah. </li><li>  Kami dipaksa untuk sekali lagi meningkatkan ukuran data yang diunduh oleh aplikasi seluler, atau menunjukkan data ini hanya jika ada koneksi jaringan, atau untuk membuat sesuatu dengan format. </li></ul><br><h3>  Mendapatkan solusi </h3><br>  Dua poin pertama memerlukan perubahan pada produk internal dan eksternal, tetapi ini adalah rutin.  Yang terakhir adalah masalah yang sama sekali berbeda.  Karena kami tidak suka mengganggu pengguna, kami menetapkan batasan: data harus tersedia secara offline, dan menambahkannya tidak boleh menambah ukuran database. <br><br>  Bagaimana?  Di satu sisi, Anda perlu mengurangi ukuran data saat ini, di sisi lain, Anda dapat membuat format untuk menyimpan informasi tentang pintu masuk, sehingga jumlah data tambahan minimal. <br><br><h3>  Kurangi volume data </h3><br>  Ada dua cara untuk menguranginya: <br><br><ul><li>  Perhatikan dengan cermat data yang disimpan dan cobalah untuk menemukan sesuatu yang bisa kita lakukan tanpa. </li><li>  Pikirkan apakah mungkin menyimpan data dengan lebih efisien daripada yang kita lakukan sekarang. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Evolusi format penyimpanan data sebelum era beranda</b> <div class="spoiler_text"><h4>  Opsi pertama dan termudah </h4><br>  Cara tradisional untuk menyimpan data yang kompleks adalah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menormalkannya</a> , menempatkannya dalam database tabel, dan membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks</a> tambahan.  Sekali, 2GIS melakukan hal itu, kecuali untuk mengurangi ukuran, isi setiap tabel diurutkan sehingga sesering mungkin nilai sel bertepatan dengan nilai-nilai dari baris sebelumnya.  Kami menyimpan kolom secara independen, dan menciutkan urutan nilai yang identik. <br><br>  Contoh yang sangat disederhanakan untuk mengoptimalkan penyimpanan meja dengan bangunan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bh/jw/gy/bhjwgyi3kccb_sx2l4zho_pqlsy.png" alt="Contoh penyimpanan tabel yang dioptimalkan"></div><br>  Normalisasi memungkinkan Anda untuk mengurangi redundansi, tetapi ada juga sisi negatif - untuk membentuk elemen UI untuk beberapa objek, Anda harus membuat beberapa kueri yang mengakses sejumlah besar tabel.  Namun, pada saat itu, tabel ini digunakan tidak hanya untuk mendapatkan data untuk ditampilkan, tetapi untuk hampir semua tugas, termasuk pencarian teks dan berbagai jenis pencarian perjalanan.  Untuk semua tugas ini, data yang dinormalisasi hanya memungkinkan kami untuk mengurangi jumlah informasi yang diproses. <br><br>  Data untuk rendering peta sudah memiliki format biner sendiri dan disimpan di blok yang terpisah.  Secara bertahap, kami membuat format biner terpisah untuk mempercepat pencarian arah dan pencarian teks.  Hanya informasi yang tersisa di database, yang digunakan untuk menampilkan kartu objek, serta untuk tautan dari beberapa objek dengan yang lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yd/4k/jh/yd4kjhjwh0pjpbj8bqmvksnqngk.png" alt="Kartu dan komunikasi"></div><br><h4>  Sederhanakan pekerjaan </h4><br>  Bagaimana Anda bisa menyederhanakan bekerja dengan data?  Terima semua data yang diperlukan untuk menggambar kartu sekaligus oleh pengenal objek.  Karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">versi online</a> sudah menerima semua data dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API</a> untuk satu permintaan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">format JSON</a> , Anda dapat sekaligus menggabungkan format yang digunakan oleh semua produk kami. <br><br>  Baik json's untuk menampilkan kartu, dan komunikasi harus diterima untuk sejumlah objek, dari kekuatan beberapa puluh sekaligus.  Tetapi ada skenario di mana atribut individu perlu diperoleh sekaligus untuk sampel besar, hingga ratusan ribu.  Lebih logis untuk memisahkan atribut tersebut menjadi entitas yang terpisah dengan format penyimpanan yang terpisah - properti.  Properti dapat bertipe dan disimpan lebih efisien dalam format biner. <br><br>  Pendekatan naif untuk menyimpan json adalah menggunakan database nilai kunci.  Ambil Moskow sebagai contoh, sebagai yang terbesar dari proyek kami.  Bahkan dalam bentuk sesederhana mungkin - untuk setiap objek json itu sendiri disimpan, 8 byte pengidentifikasi dan karakter pembatas - direktori akan mengambil 1,9 GiB.  Ukuran yang dihasilkan hampir enam kali lebih besar dari opsi yang dijelaskan sebelumnya, dan ini masih tanpa ikatan dan properti. <br><br>  Kami sengaja menggembungkan objek dengan mengisinya dengan informasi tentang segala hal yang mungkin diperlukan untuk menampilkan kartu mereka, tetapi Anda masih perlu menyimpan nama bidang, tanda kutip, koma, dan tanda kurung. <br><br><h4>  Kompres data </h4><br>  Normalisasi bukan satu-satunya cara untuk menghilangkan redundansi.  Cara populer kedua adalah kompresi.  Arsip lzma dari file kami yang sangat tebal hanya membutuhkan 55 MiB. <br><br>  Tentu saja, kita tidak dapat menggunakan format ini secara langsung, karena untuk mengakses objek yang berubah-ubah kita perlu membongkar semua data yang disimpan sebelumnya, dan arsip lzma tidak dibongkar dengan sangat cepat. <br><br>  Bagaimana kita bisa mendapatkan akses acak cepat di satu sisi, dan di sisi lain, dengan mengompresi data, mengurangi ukuran ruang yang diperlukan?  Jawabannya adalah menggunakan pagination. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ag/lk/jr/aglkjrbolu5w7cclmf-_cuqsjly.png" alt="Format penyimpanan biner"></div><br>  Sekarang setelah data diberi nomor halaman, kita dapat memampatkan masing-masing secara individual.  Untuk mengakses tempat sewenang-wenang, kita perlu membuka ritsleting dan memindai halaman, tetapi ini jauh lebih cepat daripada membongkar dan memindai seluruh arsip. <br><br>  Dalam format ini, semua data disimpan - json'y, hubungan dan properti.  Tetap mengaitkan data ini dengan pengidentifikasi objek.  Untuk setiap pengidentifikasi, kita perlu menyimpan satu atau lebih pasangan <i>&lt;nomor penyimpanan, nomor data dalam penyimpanan&gt;</i> . <br><br><img src="https://habrastorage.org/webt/7b/db/tz/7bdbtzgxk03-5c189bv4sesw7b8.png" alt="Format hubungan yang disederhanakan antara pengidentifikasi objek dan data dalam penyimpanan"><br>  Semua nomor seri, offset dan ukuran disimpan dalam format terkompresi mirip dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UTF-8</a> , di mana nilai kecil hanya memakan satu byte.  Ini memungkinkan kita untuk mengurangi ukuran tautan dengan hanya menyortir isi dari repositori biner untuk mengurangi frekuensi kemunculannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/od/9w/zv/od9wzvyv9ql8ps8g2gmmyq8njmo.png" alt="Sortir dan berhemat"></div><br>  Beberapa properti memiliki banyak nilai frekuensi, dan karenanya penyortiran memberikan keuntungan besar dalam ukuran.  Di sisi lain, karena itu, nomor seri data tidak dapat bertepatan untuk semua penyimpanan. <br><br>  Juga, jauh dari semua objek memiliki data di semua penyimpanan, dan karenanya menyimpan nomor penyimpanan lebih efisien daripada merujuk objek kosong. <br><br><h4>  Mempercepat pengambilan data </h4><br>  Format yang dijelaskan memiliki satu masalah.  Untuk menemukan jumlah objek yang menyimpan indeks untuk pengidentifikasi yang ditentukan, kita perlu menjalankan pencarian biner di dalam data objek pertama.  Untuk melakukan ini, Anda harus memuat 10,9 MiB ke dalam memori, atau melakukan 21 pembacaan tambahan.  Kedua solusi tidak cocok untuk kami, dan oleh karena itu kami mengurangi jumlah bacaan dengan menyimpan data di pohon. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8b/cx/to/8bcxto_pgnqn7drgqi5hkiae_su.png" alt="Format pohon untuk mencari data cepat dengan pengidentifikasi"></div><br>  Kami mengelompokkan data pada 32 objek, dan di tingkat menengah kami menyimpan 128 pengidentifikasi pertama dari node bersarang.  Kami menambahkan tiga level pohon dan mengurangi jumlah bacaan tambahan menjadi empat (tetapi pada kenyataannya, dengan memperhitungkan caching node pohon yang sebelumnya dibaca, bahkan menjadi 1-3).  Harga - sedikit kurang dari 400 KiB. <br><br>  Pada tahap ini, kita cukup efisien dalam menyimpan hubungan dan properti, tetapi json membutuhkan banyak ruang.  Ini bisa dimengerti.  Semakin besar ukuran halaman, semakin banyak objek di sana dan semakin baik algoritma kompresi dapat menentukan informasi apa yang berlebihan.  Tetapi, di sisi lain, semakin banyak pekerjaan yang perlu kita lakukan untuk membaca satu objek.  Json's adalah objek yang cukup besar, dan oleh karena itu ada sangat sedikit dari mereka dalam satu halaman.  Karena itu, Anda perlu membantu algoritma melakukan tugasnya dengan lebih baik. <br><br><h4>  Break json menjadi beberapa bagian </h4><br>  Pertama, banyak objek memiliki skema data yang cocok, hanya nilai atribut yang berbeda.  Kedua, banyak nilai atribut sama bahkan untuk objek dengan skema berbeda.  Kami akan memisahkan skema dan nilai atribut ke dalam penyimpanan terpisah, dan kami akan menyimpan json dalam bentuk: tautan ke skema + tautan ke nilai atribut. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/n8/ef/pqn8ef7v2wv7bkkvbgguql2vggq.png" alt="Pemisahan Json menjadi pengaturan dan data"></div><br>  Dalam skema data kami, jumlah nama atribut terbatas.  Jadi kita bisa meletakkannya di file terpisah dan menyimpan nomor sebagai gantinya.  Kami juga akan membuat beberapa perubahan lagi, dengan mempertimbangkan bahwa json selalu menjadi objek. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gq/i_/ak/gqi_akxdvngmmjmgjrg60y-5luu.png" alt="Format nyata untuk menyimpan manfaat objek json"></div><br>  Ya, kami pada dasarnya memeras data kami sendiri, mengurangi ruang lingkup agar algoritma berfungsi.  Namun di sisi lain, kami sedikit memperlambat akses ke data, dan algoritme masih membantu, mengompresi nilai yang sama yang disimpan di dekatnya. <br><br>  Kami mengatur ukuran halaman menjadi 1 KiB dan ternyata saat kami mengoptimalkan format sehingga, di satu sisi, pembacaannya tidak terlalu lambat, dan di sisi lain, data dikemas sebaik mungkin, kami ... sudah memintas â€œtabel yang dioptimalkanâ€ baik dalam ukuran maupun untuk kemudahan penggunaan.  Tapi tidak sia-sia semua ini!  Keuntungan maksimum harus berasal dari kompresi nilai atribut, properti, dan skema.  Kami menghasut zlib dan memverifikasi bahwa, dengan latar belakang sisa pekerjaan, membaca data dari database membutuhkan sedikit waktu.  Puas dengan hasilnya, kami beralih ke tugas lain. <br></div></div><br><h3>  Singkirkan yang tidak perlu </h3><br>  Kami mulai mengurangi dengan mencari data yang dapat Anda singkirkan.  Ternyata selama keberadaan format, kita telah belajar untuk melakukannya tanpa koneksi terbesar.  Ini 10% dari ukuran! <br><br>  Kode untuk data ini masih terikat, tetapi perubahan yang diperlukan cukup sepele.  Namun aplikasi yang sudah dirilis tidak dapat dengan mudah diubah.  Kami berusaha untuk mempertahankan selama mungkin tidak hanya mundur, tetapi juga kompatibilitas langsung.  Dan jika yang pertama akrab bagi semua orang, maka banyak orang mungkin dengan senang hati tidak memikirkan yang kedua.  Kami terpaksa mendukungnya karena ekor pengguna yang agak panjang, karena berbagai alasan, telah mematikan pembaruan otomatis dan tidak terburu-buru untuk beralih ke versi aplikasi yang baru. <br><br><div class="spoiler">  <b class="spoiler_title">Distribusi pengguna menurut versi</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/ld/kq/msldkqhkepk1gsouayqmglu36zo.png" alt="Distribusi pengguna menurut versi"></div><br>  Di bagian paling atas adalah distribusi pengguna oleh versi terbaru dari aplikasi Android.  Bawah adalah iOS. <br><br>  Sangat mudah untuk memperhatikan bahwa pengguna perangkat iOS diperbarui jauh lebih mudah, tetapi bahkan di antara mereka ada banyak pengguna versi yang lebih lama. <br></div></div><br>  Kami juga masih merilis data baru untuk versi beku untuk Windows Phone.  Dan meskipun pengguna WP8 hanya membuat sebagian kecil dari pemirsa kami, dalam jumlah absolut ini hampir 200.000 per bulan. <br><br>  Kami telah lama memiliki mekanisme yang memungkinkan kami menghasilkan beberapa format data, dan secara otomatis menentukan versi mana yang harus mendapatkan apa.  Peluang itu bagus, tetapi Anda masih perlu belajar cara membongkar format ini.  Tugas besar pertama adalah mengimplementasikan layanan yang akan menerima semua data dan menyaring yang baru untuk format database lama dan yang lama untuk yang baru. <br><br>  Bonus bagus dari pekerjaan yang dilakukan adalah mengurangi ukuran pembaruan bulanan, karena koneksi jarak jauh telah sangat berubah dari bulan ke bulan, menggembungkan ukuran perbedaan. <br><br>  Jika Anda melihat data yang tersisa, maka secara total Anda dapat menekan 10% yang sama, namun, harga akan jauh lebih tinggi.  Sejauh ini kami memutuskan untuk tidak menyentuh. <br><br><h3>  Optimalkan format penyimpanan saat ini </h3><br>  Seperti yang tertulis di atas, kami membuat 1 halaman KiB dan mengemas tidak semua repositori biner. <br><br>  Hal pertama yang kami lakukan adalah mencoba mengemas juga halaman-halaman dengan tautan, dan memeriksa apakah perbedaan dalam kecepatan menerima data ada di wilayah kesalahan. <br><br>  Item berikutnya adalah memilih ukuran halaman optimal.  Semakin besar ukuran halaman, semakin efisien data dikompresi, tetapi semakin lambat data diambil.  Dan jika dengan meningkatnya ukuran halaman, waktu dan biaya memori tumbuh secara linear, maka keuntungannya menjadi semakin tidak terlihat.  Setelah tes, kami memutuskan untuk menambah ukuran menjadi 8 KiB. <br><br><div class="spoiler">  <b class="spoiler_title">Pengaruh ukuran halaman pada pilihan besar</b> <div class="spoiler_text">  Jika pembesaran halaman diharapkan memperlambat pilihan kecil, maka yang besar - dari ratusan elemen - bahkan dipercepat.  Ini berarti bahwa dengan cara yang baik Anda harus memilih ukuran yang berbeda untuk penyimpanan tergantung pada kasus penggunaan data yang disimpan di dalamnya. <br></div></div><br>  Secara total, hanya dua poin ini yang dapat mengurangi basis sebesar 18%! <br><br><h3>  Ubah format kompresi </h3><br>  zlib, tentu saja, adalah klasik, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">zstd</a> memberikan kecepatan dekompresi yang lebih tinggi dengan rasio kompresi yang lebih besar.  Selain itu, zstd memungkinkan Anda untuk membuat kamus tunggal untuk semua data yang tersedia, dan kemudian menyimpannya sekali dan mengompresnya dengan semua halaman.  Jadi, kami memperlambat proses pembuatan file dengan database, tetapi kami memeras tambahan 8%. <br><br><h3>  Tambahkan beranda </h3><br><h4>  Cara mudah </h4><br>  Cara termudah adalah dengan membuat setiap pintu masuk objek yang terpisah, indeks secara terpisah (sesuai dengan perkiraan kasar + 10% dari ukuran indeks), dan secara terpisah menyimpan geometri mereka dalam data untuk menggambar peta. <br><br>  Metode ini akan mengembang basis dengan total 3%.  Pada tahap sebelumnya, kami menang lebih dari cukup untuk menenangkan diri dan bekerja dengan pintu masuk sesuai dengan skema yang biasa, tetapi ... pada saat mulai bekerja, kami tidak yakin tentang hal ini, dan mengerjakan format alternatif secara paralel. <br><br><div class="spoiler">  <b class="spoiler_title">Penilaian terperinci, untuk mereka yang tertarik</b> <div class="spoiler_text">  Mari kita coba mengevaluasi peningkatan ukuran paket dengan database untuk setiap objek: <br><br>  8 byte - pengidentifikasi, <br>  6 byte - jumlah penyimpanan yang digunakan (data + lima properti; properti diekstraksi dari data utama dan disimpan dalam bentuk biner, karena sering diperlukan untuk sejumlah besar objek sekaligus), <br>  3 byte - indeks di gudang data, <br>  2 byte - mengimbangi data objek, <br>  5 byte - nilai data - 2 byte per sirkuit, rata-rata 3 byte untuk informasi apartemen (kami percaya bahwa akan ada banyak duplikat dan data itu sendiri disimpan satu kali), <br>  6 byte - mengimbangi koordinat data (properti lain memiliki banyak nilai duplikat dan akan runtuh), <br>  8 byte - mengoordinasikan nilai. <br><br>  Total 38 byte per objek.  Dalam kasus Moskow, ini adalah 4,5 MiB untuk lebih dari 124 ribu input yang dikumpulkan. <br><br>  Selanjutnya, kita perlu menyimpan juga koneksi antara rumah dan pintu masuk, itu adalah 2,5 byte untuk setiap bangunan apartemen dan 8 byte untuk setiap pintu masuk.  1 lagi MiB. <br><br>  Sekarang kami mempertimbangkan berapa banyak ini akan terjadi pada peta. <br><br>  Pertama, kita harus menyimpan geometri.  Untuk polyline, titik pertama selalu membutuhkan 8 byte, dan semua yang berikutnya disimpan sebagai perbedaan akurasi yang diperlukan.  Di sini kami puas dengan ketepatan desimetres.  Sebagian besar input terdiri dari dua titik yang tidak terlalu jauh satu sama lain, dan oleh karena itu dapat diasumsikan bahwa geometri itu sendiri akan menempati 10 byte.  Total 1,2 MiB. <br><br>  Kita juga perlu mengasosiasikan pengidentifikasi input dan objek dengan geometri.  Indeks adalah penyimpanan biner yang sama dengan yang lainnya, hanya tujuan komunikasi (1 byte), nomor lapisan (1 byte) dan nomor objek (3 byte) yang disimpan.  Ditambah 8 byte per pengidentifikasi, serta pohon pencarian cepat.  Total 1,5 MiB lagi. <br><br>  Seperti yang dikatakan di awal artikel, kami ingin terus-menerus menampilkan pintu masuk di peta, dan cara termudah untuk melakukan ini adalah membongkar lapisan lain dengan titik-titik, tapi ... Anda juga dapat menggunakan kembali lapisan dengan geometri, membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">simbol</a> baru yang akan menampilkan gambar yang kita butuhkan pada titik terakhir dari polyline. <br><br>  10% dari indeks pencarian adalah 5,9 MiB.  Meringkas semuanya, kita mendapatkan 14,2 MiB, yang hanya sedikit lebih dari 3%. <br></div></div><br><h4>  Opsi saat ini </h4><br>  Alih-alih mengindeks pintu masuk dan menggelembungkan indeks pencarian, kami mencari rumah, tetapi juga menandai kata-kata permintaan dan mengekstrak alamat dari itu (relevan untuk mencari pintu masuk di Kaliningrad), pintu masuk dan / atau apartemen.  Jadi, di pintu keluar kita memiliki pengidentifikasi rumah dan bidang teks yang diketik, dimana kita harus menemukan tangga yang kita butuhkan. <br><br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text">  Ini adalah poin yang kontroversial.  Di satu sisi, ini memungkinkan kami untuk mengurangi ukuran basis data, dan di sisi lain, ia membatasi format input - pintu masuk tidak akan ada pada banyak permintaan yang akan diproses dengan benar menggunakan pencarian jujur. <br></div></div><br>  Selanjutnya, alih-alih membongkar objek individual, kami menyertakan semua informasi tentang pintu masuk langsung ke data bangunan. <br>  Dan akhirnya, kami mentransfer sebagian geometri ke direktori. <br><br>  Yang terakhir layak diungkapkan secara lebih rinci. <br><br>  Pertama, kami memperhatikan bahwa sebagian besar input adalah dua titik dan memiliki panjang yang sama.  Input tersebut dapat disimpan dalam bentuk titik + arah, mis.  simpan 1 byte per input. <br><br>  Kedua, kami berasumsi bahwa sebagian besar rumah di kota-kota modern adalah tipikal, oleh karena itu, perpindahan titik-titik pintu masuk mereka relatif ke titik pusat rumah akan bertepatan hingga belokan. <br><br>  Kami sudah memiliki titik pusat bangunan. ,       â€”   Â«Â»,        â€”         ? ,     json'  ,          . <br><br>   â€”     ,               . <br><br>  â€”  .      Â« - Â»,          json'      .     .      json'      ,        .        â€”      ,   ,       ,  json', ,    ,     . <br><br><div class="spoiler">  <b class="spoiler_title">Catatan</b> <div class="spoiler_text">  .              ,     ,     0,2% (972   ). <br></div></div><br>           ,            .      ,  . <br><br>    ? 3%   0,5%.     ,       (   ),        . <br><br><h3>  Hasil </h3><br>     ,          0,5%    26,6%     .  -      ,   â€”     Â«Â» ,        â€” 10,1%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/s8/p-/_v/s8p-_vjsi9mgzymzwusfn4vsz6g.png" alt="Ubah ukuran pangkalan Moskow seiring waktu"></div><br>     .       (        0,4%),       ,   ,   . <br><br><h3>  ? </h3><br>     ,         ,          .    ,         (    ). <br><br>        ,           ,        . <br><br> , ,   ,    . <br><br><h3> One more thought:  JSON  </h3><br>     ,            JSON.  Ini tidak sepenuhnya benar.    ,           .    rapidjson,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>    . <br><br>        JSON  C++  UI,    . <br><br> -,      . <br><br> -, ,   UI-,     ,      . <br><br>     JSON'  ,    UI   ,     . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415263/">https://habr.com/ru/post/id415263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415253/index.html">Foto-foto abad ke-19 dipulihkan menggunakan teknologi abad ke-21</a></li>
<li><a href="../id415255/index.html">Roskosmos mengumumkan penghentian penerbangan rudal Proton</a></li>
<li><a href="../id415257/index.html">8 Cara untuk Meningkatkan Visualisasi Data</a></li>
<li><a href="../id415259/index.html">pilih / poll / epoll: perbedaan praktis</a></li>
<li><a href="../id415261/index.html">VFX-artist dalam pengembangan game: fitur, karier, pengembangan</a></li>
<li><a href="../id415265/index.html">Mencari penerus KL-7: RACE dan AROFLEX</a></li>
<li><a href="../id415269/index.html">Cara Kerja JS: Pohon Sintaksis Abstrak, Parsing, dan Optimalisasi</a></li>
<li><a href="../id415271/index.html">Bagaimana Gantt Charts Menyederhanakan Manajemen Proyek</a></li>
<li><a href="../id415273/index.html">Mempelajari dasar-dasar pemrograman</a></li>
<li><a href="../id415275/index.html">Buku "C # 7 dan .NET Core. Pengembangan lintas platform untuk para profesional. Edisi ke-3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>