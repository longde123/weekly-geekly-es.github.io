<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✊🏿 🍊 👩🏻‍🤝‍👨🏿 Wie Youtube und Instagram: Internationalisierung und Lokalisierung einer Python-Anwendung 💾 👩‍👧 ☝🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Python ist das Herzstück weltberühmter Anwendungen wie Youtube, Instagram und Pinterest. Um auf dem Weltmarkt voranzukommen, muss eine Anwendung lokal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie Youtube und Instagram: Internationalisierung und Lokalisierung einer Python-Anwendung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/simbirsoft/blog/479738/">  Python ist das Herzstück weltberühmter Anwendungen wie Youtube, Instagram und Pinterest.  Um auf dem Weltmarkt voranzukommen, muss eine Anwendung lokalisiert werden, dh an die Merkmale eines bestimmten Landes angepasst und internationalisiert werden - dh Inhalte übersetzen.  In diesem Artikel werden wir unsere Erfahrungen zur Beschleunigung der Übersetzungsautomatisierung und zur Lösung einiger typischer Probleme in diesem Bereich teilen. <br><br><img src="https://habrastorage.org/webt/pj/ju/ug/pjjuugy6izlwm2of_m-qwzrkogm.jpeg"><a name="habracut"></a><br><br><h2>  Einleitung </h2><br>  Dies ist eine kurze Anleitung zur Internationalisierung von (i18n) Python-Anwendungen.  Diese Anleitung ist für alle Programmierer mit Erfahrung in der Python-Entwicklung interessant.  Das Lesen eines Artikels dauert 10-15 Minuten. <br><br>  Wir werden das bewährte gettext-Tool verwenden, das in der Python-Sprache enthalten ist. <br><br>  Zunächst werden wir verstehen, was Internationalisierung ist: <br><br>  <u>Internationalisierung (I18N)</u> ist der Prozess der Anpassung einer Anwendung an die Sprachen verschiedener Länder und Regionen, in denen sie nicht entwickelt wurde. <br><br>  Es gibt aber auch ein umfassenderes Konzept: <br><br>  <u>Bei der Lokalisierung (L10N)</u> wird eine internationalisierte Anwendung an eine bestimmte Region oder Sprache angepasst, indem Komponenten für ein bestimmtes Gebietsschema hinzugefügt und Text übersetzt werden. <br><br>  Lokalisierung bedeutet Übersetzung: <br><br><ul><li>  Datums- und Uhrzeitformat; </li><li>  Zahlenformat; </li><li>  Zeitzone </li><li>  ein Kalender </li><li>  Währungsdarstellungen; </li><li>  Steuern / Mehrwertsteuer; </li><li>  Temperatur und andere Maßnahmen; </li><li>  Postleitzahlen, Telefone; </li><li>  Adressformatierung; </li><li>  Code der Abrechnung. </li></ul><br><img src="https://habrastorage.org/webt/qn/iu/pp/qniuppyynx8jszhbt21l9xllxuw.png"><br><br>  Die Lokalisierung geht über die Übersetzung von Inhalten in eine andere Sprache hinaus.  Es gibt kulturelle und funktionale Parameter, die ebenfalls Aufmerksamkeit erfordern.  In Nordamerika lautet das Datumsformat beispielsweise MM / TT / JJJJ, in den meisten asiatischen Ländern jedoch TT / MM / JJJJ. <br><br><img src="https://habrastorage.org/webt/uf/rg/pd/ufrgpdvzppo4v91mpmwcwkoeoli.png"><br><br>  <i>Ein bekanntes Beispiel für einen Anwendungsübersetzungsfehler</i> <br><br>  Ein weiteres Beispiel betrifft die Anzeige von Namen in Anwendungen.  In den USA ist es akzeptabel, jemanden beim Namen anzurufen, und noch besser, der Kundenname wird in der Kopfzeile angezeigt, sobald sich der Kunde anmeldet.  In Japan ist das Gegenteil der Fall: Jemanden beim Namen zu nennen ist unhöflich oder sogar beleidigend.  Die Lokalisierung sollte dies berücksichtigen und die Verwendung von Namen für ein japanisches Publikum vermeiden. <br><br>  In diesem Artikel werden wir nur die Internationalisierung betrachten, aber Lokalisierungsmechanismen sind auf ähnliche Weise aufgebaut.  Die in diesem Artikel erwähnten Bibliotheken unterstützen die Anwendungslokalisierung. <br><br><h2>  Haupttypen </h2><br>  Die Internationalisierung gliedert sich in: <br><br><ol><li>  Übersetzung von Daten direkt in Python-Skripten. </li><li>  Übersetzung von Daten in Template-Engines. </li><li>  Übersetzung von in einer Datenbank gespeicherten Daten. </li></ol><br><h3>  1. Übersetzung von Python-Skriptdaten </h3><br>  Damit unsere Internationalisierung funktioniert, müssen wir uns mit der Babel-Bibliothek und dem Distutils-Toolkit befassen, um die Zusammenstellung des Projekts für den Verkauf und darüber hinaus zu verwalten. <br><br><h4>  Übersetzungsvorbereitung </h4><br>  Zunächst müssen wir eine Liste mit Übersetzungen erstellen.  Zunächst installieren wir die <a href="http://babel.pocoo.org/">Babel-</a> Bibliothek - eine allgemein anerkannte Python-Bibliothek zum Lokalisieren und Konvertieren von Daten und Währungen mit praktischen Ergänzungen zum Erstellen des Projekts (siehe unten). <br><br>  Python bietet ein Toolkit für Mehrsprachigkeit - gettext.  GNU gettext ist eine universelle Lokalisierungslösung, die Unterstützung für andere Programmiersprachen in mehrsprachigen Nachrichten bietet.  Gettext wird nicht nur in vielen Programmiersprachen, sondern auch bei der Übersetzung von Betriebssystemen verwendet, es ist eine erprobte, frei verbreitete Software, die auf <a href="https://github.com/autotools-mirror/gettext">github</a> verfügbar <a href="https://github.com/autotools-mirror/gettext">ist</a> . <br><br>  Damit die Übersetzungen funktionieren, müssen Sie das gettext-Modul importieren und die Skripte mit den Übersetzungen an die Eingabe übergeben.  Zunächst markieren wir alle übersetzten Zeichenketten mit der Sonderfunktion _ ('some_text').  Der Aufruf dieser Funktion im Projekt sieht folgendermaßen aus: <br><br><pre><code class="php hljs">import gettext import os localedir = os.path.join(os.path.abspath(<span class="hljs-string"><span class="hljs-string">'/path/to/locales'</span></span>), <span class="hljs-string"><span class="hljs-string">'locales'</span></span>) translate = gettext.translation(<span class="hljs-string"><span class="hljs-string">'domain_name'</span></span>, localedir, [<span class="hljs-string"><span class="hljs-string">'ru'</span></span>]) _ = translate.gettext <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(_(<span class="hljs-string"><span class="hljs-string">'some_text'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(_(<span class="hljs-string"><span class="hljs-string">'some_text_2'</span></span>))</code> </pre> <br>  Erstellen Sie in einem kleinen Codeteil ein Internationalisierungsobjekt, das das Verzeichnis 'locales' als Quelle für übersetzte Phrasen verwendet.  Das 'locales'-Verzeichnis wurde noch nicht erstellt, aber es ist das Verzeichnis, in dem die Anwendung zur Laufzeit nach Übersetzungen sucht. <br><br>  Der Kürze halber wird die Funktion translate.gettext im Folgenden als _ bezeichnet.  Unterstrich ist der gebräuchliche Name für diese Funktion, der von der Python-Community erkannt wird. <br><br>  Die Funktion _ () markiert die zu übersetzenden Zeilen.  Das gettext-Modul wird vom xgettext-Tool begleitet, das die Zeichenfolgenmarkierungen _ () nach Code analysiert und eine Portable Object Template (Pot-Datei) erstellt.  Um die Pot-Datei zu erstellen, kehren wir zu der installierten Babel-Bibliothek zurück, die viele Funktionen zur Unterstützung der Internationalisierung bietet.  Babel erweitert das Build-Skript setup.py, das entweder mit der Standard-Python-Distutils-Bibliothek oder dem Setuptools-Paket eines Drittanbieters Ihrer Wahl geschrieben werden kann.  Die Zusammenstellung von Python-Modulen würde den Rahmen unseres Artikels sprengen, nähere Informationen finden Sie in der <a href="https://docs.python.org/2/distutils/introduction.html">Dokumentation</a> .  Sie müssen lediglich eine setup.py-Datei mit folgendem Inhalt erstellen: <br><br><pre> <code class="php hljs">from babel.messages import frontend <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> babel from distutils.core import setup setup(name=<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, version=<span class="hljs-string"><span class="hljs-string">'1.0'</span></span>, cmdclass = {<span class="hljs-string"><span class="hljs-string">'extract_messages'</span></span>: babel.extract_messages, <span class="hljs-string"><span class="hljs-string">'init_catalog'</span></span>: babel.init_catalog, <span class="hljs-string"><span class="hljs-string">'update_catalog'</span></span>: babel.update_catalog, <span class="hljs-string"><span class="hljs-string">'compile_catalog'</span></span>: babel.compile_catalog,} )</code> </pre> <br>  So erstellten wir Anweisungen zum Aufbau des Projekts und fügten vier Internationalisierungsteams aus der Babel-Bibliothek hinzu.  Betrachten Sie diese Befehle in der Reihenfolge ihrer Verwendung genauer. <br><br>  <b>extract_messages</b> <br><br>  Dieser Befehl ist ein Wrapper über das GNU-Tool xgettext, mit dem _ () übersetzbare Tags in eine Pot-Datei geparst werden.  Zum Ausführen benötigen Sie mehrere Einstellungen für die Assembly.  Erstellen Sie dazu im Stammverzeichnis die Datei setup.cfg mit dem Inhalt: <br><br><pre> <code class="php hljs">[extract_messages] input_dirs = foobar output_file = foobar/locales/messages.pot</code> </pre> <br><br><ul><li>  eingabeverzeichnisse - Der Name des Verzeichnisses, aus dem alle Bezeichnungen im Code _ () für Übersetzungen ausgewählt werden. </li><li>  output_file - Pfad für die resultierende .pot-Datei </li></ul><br>  Führen Sie zum Ausführen des Befehls in der Konsole Folgendes aus: <br><br><pre> <code class="php hljs">$ python setup.py extract_messages</code> </pre> <br><br><pre> <code class="php hljs">running extract_messages extracting messages from foobar/__init__.py extracting messages from foobar/core.py ... writing PO template file to foobar/locales/messages.pot</code> </pre> <br>  In der Topf-Datei werden markierte Zeilen in einer Liste gesammelt, aus der Übersetzer dann Übersetzungen für jede der gewünschten Sprachen erstellen können. <br><br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment"># SOME DESCRIPTIVE TITLE. # Copyright (C) YEAR ORGANIZATION # FIRST AUTHOR &lt;EMAIL@ADDRESS&gt;, YEAR. # msgid "" msgstr "" "Project-Id-Version: PACKAGE VERSION\n" "POT-Creation-Date: 2018-01-28 16:47+0000\n" "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n" "Last-Translator: FULL NAME &lt;EMAIL@ADDRESS&gt;\n" "Language-Team: LANGUAGE &lt;LL@li.org&gt;\n" "MIME-Version: 1.0\n" "Content-Type: text/plain; charset=UTF-8\n" "Content-Transfer-Encoding: 8bit\n" "Generated-By: pygettext.py 1.5\n" #: src/main.py:5 msgid "some_text" msgstr "" #: src/main.py:6 msgid "some_text_2" msgstr ""</span></span></code> </pre> <br>  Als nächstes müssen Sie Übersetzungen für mehrere Sprachen erstellen.  Verwenden Sie dazu die folgenden babel-Befehle. <br><br>  <b>init_catalog</b> <br><br>  Dieser Befehl ist ein Wrapper über das GNU-Tool msginit, das ein neues Übersetzungsverzeichnis basierend auf der Pot-Datei erstellt. <br><br><pre> <code class="php hljs">$ python setup.py init_catalog -l en -i foobar/locales/messages.pot \ -o foobar/locales/en/LC_MESSAGES/base.po</code> </pre> <br><pre> <code class="php hljs">running init_catalog creating catalog <span class="hljs-string"><span class="hljs-string">'foobar/locales/en/LC_MESSAGES/messages.po'</span></span> based on <span class="hljs-string"><span class="hljs-string">'foobar/locales/messages.pot'</span></span></code> </pre> <br>  <b>Wichtig!</b>  Lokalisierungsdateien werden gemäß der Konvention auf eine bestimmte Weise gespeichert: <br><br>  locales // LC_MESSAGES / .po <br><br>  - ein Verzeichnis mit Übersetzungen in eine bestimmte Sprache, in unserem Fall Englisch (en).  Es kann auch ein Verzeichnis mit Übersetzungen geben, die nicht nur in eine bestimmte Sprache übersetzt werden, sondern auch zusätzliche Funktionen berücksichtigen.  Eine englische Übersetzung für die USA lautet beispielsweise "en_US". <br><br>  - Domain mit Übersetzungen.  Wenn unsere Anwendung wächst, werden Übersetzungen in Domänen unterteilt, um eine Datei nicht zu überlasten. <br><br>  <b>update_catalog</b> <br><br>  Dieser Befehl ist ein Wrapper für das GNU-Tool msgmerge, mit dem vorhandene Übersetzungsverzeichnisse für * .po-Dateien aktualisiert werden. <br><br>  Wenn wir neue Übersetzungen hinzufügen, führen wir einfach den folgenden Befehl aus: <br><br><pre> <code class="php hljs">$ python setup.py update_catalog -l en -i foobar/locales/messages.pot \ -o foobar/locales/en/LC_MESSAGES/base.po</code> </pre> <br><pre> <code class="php hljs">running update_catalog updating catalog <span class="hljs-string"><span class="hljs-string">'foobar/locales/en/LC_MESSAGES/base.po'</span></span> based on <span class="hljs-string"><span class="hljs-string">'foobar/locales/messages.pot'</span></span></code> </pre> <br>  Wir können die Lokalisierung auch auf Russisch angeben, indem wir ru anstelle von en angeben. <br><br>  <b>compile_catalog</b> <br><br>  Der letzte Befehl ist ein Wrapper über das GNU-Tool msgfmt.  Es verwendet übersetzbare Nachrichten aus * .po-Dateien und kompiliert sie in binäre * .mo-Dateien, um die Leistung zu optimieren. <br><br><pre> <code class="php hljs">$ python setup.py compile_catalog --directory foobar/locales --domain base</code> </pre><br><pre> <code class="php hljs">running compile_catalog compiling catalog to foobar/locales/en/LC_MESSAGES/base.mo</code> </pre><br>  --directory - Pfad zum Verzeichnis mit Lokalisierung, <br>  --domain - ein Flag zum Angeben einer Übersetzungsdomäne, wir geben es in Übereinstimmung mit vorhandenen Anwendungsdomänen an. <br><br>  Python-Skripte funktionieren nur mit optimierten * .mo-Übersetzungen.  Daher ist es bei jeder Änderung erforderlich, die Dateien mit Lokalisierung neu zu kompilieren, damit sie in der Anwendung angezeigt werden.  Um mit Übersetzungsdateien zu arbeiten, können Sie die poedit-Anwendung verwenden - sie ist für alle Betriebssysteme verfügbar und frei verteilt. <br><br><img src="https://habrastorage.org/webt/4_/x5/iy/4_x5iyrgxqxdw_qxlucmagupbt0.png"><br><br>  <i>poedit - Übersetzungsanwendung</i> <br><br>  Jede Übersetzung wird als separate Zeile angezeigt, was praktisch ist.  Nach Abschluss der Arbeit mit Übersetzungen wird beim Speichern von Änderungen automatisch eine * .mo-Binärdatei mit allen Änderungen kompiliert. <br><br>  Folglich sieht die Struktur der Übersetzungskataloge folgendermaßen aus: <br><br><pre> <code class="php hljs">locales ├── en │ └── LC_MESSAGES │ ├── base.mo │ └── base.po ├── ru │ └── LC_MESSAGES │ ├── base.mo │ └── base.po └── messages.pot</code> </pre> <br><br>  <b>Namenskonvention für Übersetzungsmarker</b> <br><br>  po-Dateien enthalten Textübersetzungen und werden logisch zu einer Datei mit einem gemeinsamen Namen zusammengefasst.  Diese Gruppen werden als Domänen bezeichnet.  Im obigen Beispiel gibt es nur eine Domain mit dem Namen base.  In großen Anwendungen wird es mehr Domänen geben, und Übersetzungslisten müssen unter Berücksichtigung der Struktur der Anwendung erstellt werden. <br><br>  Es ist notwendig, die Namen der Übersetzungstoken einheitlich zu halten, um weitere Verwirrung in den Übersetzungen zu vermeiden.  Beispielsweise haben wir ein Formular zum Speichern von Benutzerdaten auf der Benutzerprofilseite: <br><br>  <i>profile.user_form.component.title: Benutzerdaten</i> <i><br></i>  <i>profile.user_form.component.save: Speichern</i> <i><br></i>  <i>profile.user_form.field.username: Benutzername</i> <i><br></i>  <i>profile.user_form.field.password: Passwort</i> <i><br></i> <br><br>  <b>Anwendungsbereitstellung</b> <br><br>  Um die Anwendung im Docker bereitzustellen und bereitzustellen, müssen Sie die Übersetzungsdateien mit dem folgenden Befehl in * .mo-Binärdateien kompilieren: <br><br><pre> <code class="php hljs">$ python setup.py compile_catalog --domain &lt;&gt;</code> </pre> <br>  Wir empfehlen, * .mo und * .pot Dateien in .gitignore auszuschließen: <br><br>  <i># Übersetzungen</i> <i><br></i>  <i>* .mo</i> <i><br></i>  <i>* .pot</i> <br><br><h3>  2. Übersetzung von Daten in Template-Engines </h3><br>  Mit der Lokalisierung im Templating ist alles ein bisschen einfacher.  Betrachten Sie die beliebteste Python-Template-Engine - Jinja.  Für diese Template-Engine ist bereits eine Unterstützung für die Gettext-Lokalisierung durch Add-Ons implementiert.  Um das Add-On zu aktivieren, müssen Sie den Pfad zum Add-In-Modul im Umgebungskonstruktor angeben.  Für mehrsprachige Plattformen müssen Sie die Übersetzungen einmal herunterladen und während der Anwendungsinitialisierung Übersetzungsobjekte zum Umgebungsobjekt hinzufügen: <br><br><pre> <code class="php hljs">translations = get_gettext_translations() env = Environment(extensions=[<span class="hljs-string"><span class="hljs-string">'jinja2.ext.i18n'</span></span>]) env.install_gettext_translations(translations)</code> </pre><br>  Dann verwenden wir in den Vorlagen nur die Konstrukte: <br><br><pre> <code class="php hljs">{{ gettext(<span class="hljs-string"><span class="hljs-string">'some_text'</span></span>) }} {{ gettext(<span class="hljs-string"><span class="hljs-string">'Hello %(name)s!'</span></span>)|format(name=<span class="hljs-string"><span class="hljs-string">'World'</span></span>) }}</code> </pre> <br><h3>  3. Übersetzung der in der Datenbank gespeicherten Daten </h3><br>  Lassen Sie uns Optionen für die Arbeit mit Übersetzungen in den gängigsten relationalen Datenbanken betrachten.  Es ist zu beachten, dass die Implementierung von Übersetzungen und Lokalisierung für noSQL- und newSQL-Datenbanken ähnlich ist. <br><br>  <i>Hinweis:</i> Der Fall wird nicht berücksichtigt, wenn die Übersetzung für jede Sprache in einer separaten Spalte gespeichert ist.  Eine solche Implementierung beinhaltet Skalierungsbeschränkungen und andere Risiken mit weiterer Anwendungsunterstützung. <br><br><h4>  1) Separate Zeilen für jede Sprache </h4><br>  Bei diesem Ansatz basiert die Übersetzung in eine bestimmte Sprache in den Zeilen für jede Sprache auf dem Wert der Spalte, z. B. language_code.  Wenn sich der Wert en in dieser Spalte befindet, sollten sich alle übersetzten Werte auf das angegebene Land und die angegebene Region beziehen. <br><br><img src="https://habrastorage.org/webt/di/vv/b_/divvb_ulaekslblbgv98taqsncg.png"><br><br>  Für das beschriebene Schema sollten die Daten in der Tabelle folgendermaßen aussehen: <br><br><img src="https://habrastorage.org/webt/ds/kx/cx/dskxcx_ffmnvcv97yus9d10q_bq.png"><br><br>  <b>Vorteile:</b> <br><br><ul><li>  Einfache und effiziente Implementierung. </li><li>  Einfache Abfragen bei Verwendung eines bestimmten Sprachcodes. </li></ul><br><br>  <b>Nachteil:</b> <br><ul><li>  Mangel an Zentralisierung </li></ul><br>  Übersetzungen in verschiedene Sprachen können in verschiedenen Tabellen gespeichert werden.  Daher wissen Sie nicht, in wie viele Sprachen Ihre Anwendung vollständig übersetzt ist. <br><br>  Diese Lösung eignet sich für Anwendungen, bei denen zunächst nicht alle Daten vollständig internationalisiert werden müssen.  Es ist jedoch möglich, Übersetzungen für neue Regionen hinzuzufügen, wenn das Geschäft wächst. <br><br>  Die Datenanforderung lautet wie folgt: <br><br><pre> <code class="php hljs">SELECT p.product_name, p.price, p.description FROM product p WHERE p.language_code = @language_code;</code> </pre> <br><h3>  2) Tabellen mit Übersetzungen trennen </h3><br>  In diesem Ansatz erstellen wir für jede zu lokalisierende Tabelle Tabellen mit Übersetzungen. <br><br><img src="https://habrastorage.org/webt/yr/_i/ro/yr_iror7tyoqltdgao6fua4ambo.png"><br><br>  <b>Vorteile:</b> <br><br><ul><li>  Es ist nicht erforderlich, Tabellen für nicht übersetzte Daten zu verknüpfen. </li><li>  Abfragen werden einfach, da separate Tabellen für die Übersetzung vorhanden sind. </li><li>  Es gibt keine Diskrepanzen in den Daten. </li><li>  Zusätzlich zu Übersetzungen ist es möglich, den Rest der Daten in der Sprachtabelle effektiv zu lokalisieren. </li></ul><br>  <b>Nachteil:</b> <br><br><ul><li>  In großen Anwendungen ist die Übersetzungstabelle aufgebläht und verlangsamt sich.  Bei der Optimierung der Anwendung muss die Datenmigration in separaten Tabellen implementiert werden. </li></ul><br>  Die Datenanforderung lautet wie folgt: <br><br><pre> <code class="php hljs">SELECT tp.text, p.price, tc.text, c.contact_name FROM order_line o, product p, customer c, translation tp, translation tc, language l WHERE o.product_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> o.customer_id = c.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> p.name_translation_id = tp.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.name_translation_id = tc.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tp.language_id = l.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tc.language_id = l.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.name = @language_code <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> o.id = ***;</code> </pre> <br><h4>  3) Entitäten für übersetzte und nicht übersetzte Felder erstellen </h4><br>  In dieser Lösung erweitern Entitätstabellen, die ein oder mehrere übersetzte Felder enthalten, Daten durch nicht übersetzte. <br><br><img src="https://habrastorage.org/webt/ox/vv/dw/oxvvdwlufgyhcks2akl7vf5-mqk.png"><br><br>  <b>Vorteile:</b> <br><br><ul><li>  Übersetzungstabellen müssen nicht mit Tabellen kombiniert werden, die Daten enthalten, für die keine Übersetzung erforderlich ist.  Das Abtasten solcher Daten hat daher eine bessere Leistung. </li><li>  Es ist einfach, ORM-Abfragen zu schreiben, </li><li>  Eine einfache SQL-Abfrage, um übersetzten Text zu erhalten, </li><li>  Es ist einfach, die Übersetzung bestimmter Daten in alle verfügbaren Sprachen zu unterstützen. </li></ul><br>  <b>Nachteil:</b> <br><br><ul><li>  Die relative Komplexität der Implementierung. </li></ul><br>  Hier ist ein Beispiel für eine Abfrage, mit der übersetzter Text abgerufen wird: <br><br><pre> <code class="php hljs">SELECT pt.product_name, pt.description, p.price FROM order_line o, product p, product_translation pt, language l WHERE o.product_id = p.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> p.id = pt.product_non_trans_id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pt.language_id = l.id <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> l.name = @language_code;</code> </pre><br><h2>  Schlussfolgerungen </h2><br>  Bei der Lokalisierung und Internationalisierung von Anwendungen für den internationalen Markt können verschiedene Methoden verwendet werden, die jeweils bestimmte Merkmale und Einschränkungen aufweisen. <br><br>  In diesem Artikel haben wir folgende Arten der Internationalisierung untersucht: <br><br><ul><li>  <b>im Code: Wir</b> verwenden Übersetzungen, wenn <b>wir</b> einen Dienst oder eine Anwendung mit GUI erstellen. </li><li>  <b>in Templates: verwenden wir</b> bei der Entwicklung einer Webanwendung ohne dynamisches Frontend; </li><li>  <b>In der Datenbank:</b> Wird zum Speichern von Benutzerdaten oder dynamisch generierten Daten verwendet. </li></ul><br>  Wir hoffen, dass unser Artikel Ihnen bei der Auswahl der für Ihr Projekt am besten geeigneten Methode hilft. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de479738/">https://habr.com/ru/post/de479738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de479724/index.html">Tru Hacker sind vorbei</a></li>
<li><a href="../de479726/index.html">Vladimir aka wowik: "OpenStreetMap braucht Ideen, die in anderen Systemen nicht umsetzbar sind"</a></li>
<li><a href="../de479728/index.html">Wie organisiere ich einen erfolgreichen Start?</a></li>
<li><a href="../de479732/index.html">Stellen Sie die Ausgabe von etwas anderem als Speicherverlust ein</a></li>
<li><a href="../de479736/index.html">Kameras oder Laser</a></li>
<li><a href="../de479742/index.html">Backyards - ein automatisiertes Service-Mesh auf einer Multi-Cloud- und Hybrid-Infrastruktur</a></li>
<li><a href="../de479744/index.html">Python Memory Management: Ein wenig über Speicherfragmentierung</a></li>
<li><a href="../de479746/index.html">Unternehmenssoftware macht Ihre Mitarbeiter kühler. Brauchst du es</a></li>
<li><a href="../de479748/index.html">GoLand 2019.3 mit verbesserter Leistung, verbesserter Unterstützung für Go-Module und mehr</a></li>
<li><a href="../de479750/index.html">2. Fortinet Erste Schritte v 6.0. Lösungsarchitektur</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>