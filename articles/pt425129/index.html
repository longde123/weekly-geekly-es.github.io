<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèª ü¶Ñ ü§üüèø Como automatizar a cria√ß√£o de m√°quinas virtuais? Contamos em detalhes üôåüèº ü•î ‚ÜôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Criar uma nova m√°quina virtual √© uma rotina demorada. E quanto mais infraestrutura e organiza√ß√£o, mais procedimentos associados a esse processo. Autom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como automatizar a cria√ß√£o de m√°quinas virtuais? Contamos em detalhes</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/icl_services/blog/425129/"> Criar uma nova m√°quina virtual √© uma rotina demorada.  E quanto mais infraestrutura e organiza√ß√£o, mais procedimentos associados a esse processo.  Automatizamos esse processo usando o PowerShell. <br><br>  Bem-vindo ao kat, se voc√™ estiver interessado. <br><br><img src="https://habrastorage.org/webt/fv/fr/cc/fvfrccl_crsi5nfvcnstarorits.jpeg"><br><br><a name="habracut"></a><br>  Os programadores n√£o gostam de trabalhar duas vezes, os administradores de sistema tamb√©m. <br><br>  Abaixo est√° um exemplo de automa√ß√£o de um de nossos clientes. <br><br>  Quer√≠amos garantir que qualquer engenheiro ou gerente de projeto pudesse criar uma nova m√°quina virtual com o m√≠nimo de esfor√ßo e por um per√≠odo m√≠nimo.  Nosso cliente possui um sistema ITSM; neste exemplo, √© ServiceNow, criamos o formul√°rio da Web correspondente no cat√°logo de servi√ßos.  Para "pedir" uma nova m√°quina, o gerente precisa preencher os campos e confirmar a "ordem", depois que a cadeia do processo for lan√ßada e, na sa√≠da, deixaremos a m√°quina pronta para uso. <br><br>  Ent√£o, vejamos o que um gerente precisa definir para criar uma nova m√°quina virtual: <br><br><img src="https://habrastorage.org/webt/3l/8d/yo/3l8dyowobrfvbgpznotayqjywvu.png"><br><br>  <b>Descri√ß√£o da VM: descri√ß√£o da m√°quina virtual</b> <b><br></b>  Alguns esclarecimentos s√£o necess√°rios aqui.  Em nossa solu√ß√£o, o PowerShell 5.1 √© usado ativamente; portanto, somente no Windows, tentaremos adicionar no futuro suporte para m√°quinas Unix e mudar para o PowerShell Core. <br><br>  <b>SO</b> , sistema operacional.  N√£o h√° barreiras espec√≠ficas ao uso do Windows 2008 (R2), mas estamos usando o 2012R2 ou 2016. <br><br>  <b>Tamanho da VM</b> , tamanho da m√°quina virtual.  Para cada um, isso pode ser determinado √† sua maneira, neste exemplo Ram pequeno de 1CPU-4Gb, M√©dio 2CPU-8Gb, Grande 4-16. <br><br>  <b>O Armazenamento</b> 0 da <b>VM</b> , Disco 0 (C: \) tem um tamanho fixo que voc√™ n√£o pode alterar, apenas o seletor de armazenamento R√°pido / Lento est√° dispon√≠vel.  ‚ÄúR√°pido‚Äù pode ser de camada de armazenamento com SSD e ‚ÄúLento‚Äù pode ser armazenado em HDDs ‚Äúregulares‚Äù (√© claro, SAN).  O Disco1 (disco2 em diante) tamb√©m possui um seletor para selecionar Armazenamento, al√©m de campos para inserir o tamanho desejado em gigabytes, Carta para a parti√ß√£o e tamanho do cluster (o que √© importante para o SQL Server). <br><br>  <b>Confie</b> , determinamos que a m√°quina deve ser ingressada no dom√≠nio ou n√£o, com acesso da rede p√∫blica ou n√£o. <br><br>  <b>Tipo</b> , tipo de m√°quina.  Quase todas as m√°quinas podem ser definidas como um aplicativo front-end ou back-end ou outro em todos os outros casos.  Com base no tipo selecionado, podemos determinar ainda a sub-rede mais adequada para a m√°quina. <br><br>  <b>Ambiente</b> , na infraestrutura do cliente, existem dois datacenters: prim√°rio (produ√ß√£o) e secund√°rio (desenvolvimento / teste), os controladores de dom√≠nio s√£o conectados por um canal de comunica√ß√£o r√°pido e fornecem toler√¢ncia a falhas.  Por contrato, todas as m√°quinas virtuais no DC prim√°rio t√™m um endere√ßo IP a partir de 10.230 e no DC secund√°rio em 10.231. <br><br>  <b>(SLA) Service Level Agreement</b> , esse par√¢metro afeta a qualidade do servi√ßo desta m√°quina. <br><br>  <b>Aplica√ß√µes</b>  Adicionamos a capacidade de instalar e configurar o SQL Server.  Voc√™ deve selecionar a edi√ß√£o, nome da inst√¢ncia e agrupamento.  Tamb√©m √© poss√≠vel configurar a fun√ß√£o de servidor Web e muito mais. <br><br>  Agora precisamos determinar como armazenar os valores selecionados.  Decidimos que o formato mais conveniente √© um arquivo JSON.  Como eu disse anteriormente, o ambiente do cliente usa o ITSM ServiceNow;  o gerente, depois de selecionar todos os valores necess√°rios, clica no bot√£o "ordem" e, em seguida, o ServiceNow passa todos os par√¢metros para o script do PowerShell (para o ServiceNow de back-end), que criar√° o arquivo JSON.  Parece algo como isto: <br><br><pre><code class="plaintext hljs">.\CreateConfiguration.ps1 -SecurityZone trusted -VMDescription "VM for CRM System" -Requestor "evgeniy.vpro" -OSVersion 2k16 -OSEdition Standard -BuildNewVM -VMEnvironment Prod -VMServiceLevel GOLD -VMSize Medium -Disk0Tier Fast -Disk1Size 50 -Disk1Tier Eco -Disk1Letter D -MSSQLServer -MSSQLInstanceName "Instance1" -SQLCollation Latin1_General_CI_AS -SQLEdition Standard -Disk2Size 35 -Disk3Size 65</code> </pre> <br><br>  No corpo do script CreateConfiguration .ps1: <br><br><pre> <code class="plaintext hljs"># PowerShell- $config = [ordered]@{} #    . $config.SecurityZone=$SecurityZone</code> </pre><br><br>  No final, exporte nosso objeto para um arquivo JSON: <br><br><pre> <code class="plaintext hljs">$ServerConfig = New-Object ‚ÄìTypeName PSObject $config ConvertTo-Json -InputObject $ServerConfig -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$($Hostname.ToLower()).json" -Force</code> </pre><br><br>  Exemplo de configura√ß√£o: <br><br><pre> <code class="plaintext hljs">{ "Hostname": "dsctest552", "SecurityZone": "trusted", "Domain": "testdomain", "Requestor": "evgeniy.vpro", "VM": { "Size": "Medium", "Environment": "Prod", "SLA": "GOLD", "DbEngine": "MSSQL", "RAM": 8, "Storage": [ { "Id": 0, "Tier": "Fast", "Size": "100", "Allocation": 4, "Letter": "C" }, { "Id": 1, "Tier": "Eco", "Size": 50, "Label": "Data", "Allocation": 64, "Letter": "D" }, { "Id": 2, "Tier": "Fast", "Size": 35, "Label": "Data", "Allocation": 64, "Letter": "E" }, { "Id": 3, "Tier": "Fast", "Size": 65, "Label": "Data", "Allocation": 64, "Letter": "F" } ] }, "Network": { "MAC": "", "IP": "10.230.168.50", "Gateway": "10.230.168.1", "VLAN": ‚ÄúVLAN168‚Äù }, "OS": { "Version": "2k16", "Edition": "Standard", "Administrators": [ "LocaAdmin", "testdomain\\ Security-LocalAdmins" ] }, "OU": "OU=Servers,OU=Staging,DC=testdomain", "Applications": [ { "Application": "Microsoft SQL Server 2016", "InstanceName": "vd", "Collation": "Latin1_General_CI_AS", "Edition": "Standard", "Features": "SQLENGINE", "Folders": { "DataRoot": "E:\\MSSQL", "UserDB": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Data", "UserLog": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Log", "TempDB": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "TempDBLog": "D:\\MSSQL\\MSSQL11.vd\\MSSQL\\TempDB", "Backup": "E:\\MSSQL\\MSSQL11.vd\\MSSQL\\Backup" }, "MaxMemory": 2147483647 } ], "Description": "VM for CRM", "Certificate": { "File": null, "Thumbprint": null }, "Version": 0 }</code> </pre><br><br>  Voc√™ deve ter notado que o formul√°rio da Web n√£o tinha um nome de m√°quina virtual e endere√ßo IP.  Obtemos esses valores automaticamente da seguinte maneira: <br><br>  <b>O nome da m√°quina</b> , ITSM ServiceNow, possui uma se√ß√£o especial: CMDB (banco de dados de gerenciamento de configura√ß√£o), esse banco de dados armazena todos os registros sobre m√°quinas virtuais existentes, status, equipe de suporte etc.  Criamos cerca de 200 registros de backup com status Alocado.  Para obter um nome para a m√°quina virtual, solicitamos REST ao CMDB, obtemos o primeiro registro "gratuito" e alteramos seu status de Instala√ß√£o alocada para Instala√ß√£o pendente. <br><br>  <b>Endere√ßo IP e VLAN</b> , implantamos o IPAM em nossa rede - esse √© um recurso interno do Windows Server 2016 que permite gerenciar endere√ßos IP em sua rede.  N√£o √© necess√°rio usar todos os recursos do IPAM (DHCP, DNS, AD), mas us√°-lo apenas como um banco de dados de endere√ßos IP com uma extens√£o potencial de funcionalidade.  O script que cria o arquivo JSON faz uma solicita√ß√£o ao IPAM para o primeiro endere√ßo IP gratuito na sub-rede.  E a sub-rede VLAN (sub-rede x / 24) √© determinada com base nos valores SLA, Ambiente, Confian√ßa e Tipo selecionados. <br>  O arquivo de configura√ß√£o est√° pronto, todos os campos est√£o no lugar, voc√™ pode criar uma m√°quina.  A pergunta √©: "como armazenar credenciais para todos os nossos scripts?".  Usamos o pacote <a href="">CredentialManager</a> .  Este pacote funciona com a API incorporada do Windows Credential Manager para armazenar senhas.  Exemplo de cria√ß√£o de uma senha: <br><br><pre> <code class="plaintext hljs">New-StoredCredential -Target "ESXi" -UserName "testdomain.eu\vmwareadm" -Password "veryultraP@ssw00rd." -Type Generic -Persist LocalMachine</code> </pre><br><br>  A senha estar√° dispon√≠vel para leitura nesta m√°quina e conta. <br><br><pre> <code class="plaintext hljs">$ESXiAdmin = Get-StoredCredential -Type Generic -Target ESXi</code> </pre> <br><br>  Temos um servidor no qual todas as configura√ß√µes com o GIT s√£o armazenadas, agora podemos rastrear com seguran√ßa todas as altera√ß√µes nas configura√ß√µes: quem, o que, onde e quando. <br><br>  A tarefa agendada est√° configurada neste servidor: verifique a pasta com as configura√ß√µes e escreva no Log de Eventos do Windows todas as altera√ß√µes. <br><br>  Ap√≥s 15 minutos, a tarefa agendada gravar√° no Windows EventLog que um novo arquivo de configura√ß√£o foi detectado. <br><br>  √â hora de verificar essa configura√ß√£o.  Primeiro de tudo, precisamos garantir que o arquivo tenha a formata√ß√£o correta: <br><br><pre> <code class="plaintext hljs">$Configuration=(Get-Content -Raw $File | Out-String | ConvertFrom-Json)</code> </pre> <br><br>  Se tudo estiver bem, √© hora de come√ßar a criar a m√°quina e executar o script BuildVM.ps1. <br><br>  No BuildVM.ps1, verificamos que o arquivo de configura√ß√£o possui uma descri√ß√£o de todas as caracter√≠sticas da m√°quina virtual: tamanho, env, sla, tipo, armazenamento, ram, rede. <br><br>  Certifique-se de verificar se h√° uma m√°quina com o mesmo nome na infraestrutura (CheckVM.ps1). <br>  N√≥s nos conectamos atrav√©s do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">VMWare PowerShell CLI</a> ao nosso vSphere: <br><br><pre> <code class="plaintext hljs">$VmWareAdmin = Get-StoredCredential -Type Generic -Target ESXi Connect-VIServer -Server "vSphereSrv" -Credential $VmWareAdmin | Out-Null</code> </pre><br><br>  Verifique se h√° uma m√°quina com o mesmo nome na infraestrutura <br><br><pre> <code class="plaintext hljs">$VM=Get-VM $server -ErrorAction SilentlyContinue</code> </pre> <br><br>  E desligue: <br><br><pre> <code class="plaintext hljs">Disconnect-VIServer * -Force -Confirm:$false</code> </pre> <br><br>  Verifique se a m√°quina tamb√©m n√£o est√° dispon√≠vel no WinRM <br><br><pre> <code class="plaintext hljs">$ping=Test-NetConnection -ComputerName $Configuration.Hostname -CommonTCPPort WINRM -InformationLevel Quiet -ErrorAction SilentlyContinue</code> </pre> <br><br>  Se $ VM e $ ping estiverem vazios, voc√™ poder√° criar uma nova m√°quina.  (Lidamos com situa√ß√µes em que uma m√°quina j√° foi criada manualmente no ESXi ou est√° em outro datacenter.) <br><br><blockquote>  Algumas palavras sobre o carro.  Essa √© uma imagem de m√°quina virtual preparada que foi finalizada pelo sysprep e convertida em modelo no nosso vSphere.  O administrador local com a senha que conhecemos √© salva na imagem, essa conta n√£o falha ap√≥s o sysprep, o que nos permitir√° acessar cada m√°quina desse modelo e, posteriormente, podemos substitu√≠-la por motivos de seguran√ßa. </blockquote><br><br><h3>  Criando uma m√°quina virtual <br></h3><br>  Encontre o cluster SLR correspondente: <br><br><pre> <code class="plaintext hljs">$Cluster=Get-Cluster -Name $Configuration.VM.SLA</code> </pre> <br><br>  Verifique se temos espa√ßo suficiente no armazenamento de dados: <br><br><pre> <code class="plaintext hljs">$DatastoreCluster = Get-DatastoreCluster |Where-Object {$_.Name -like $Datastore1Name} $Datastore1 = Get-Datastore -Location $DatastoreCluster |sort -Property "FreeSpaceGB" |select -Last 1 IF ($Datastore1.FreeSpaceGB -le "200"){ Write-Host -foreground red "STOP: Not enough datastore capacity for DISK" $vdisk.Id Break }</code> </pre><br><br>  E mem√≥ria suficiente: <br><br><pre> <code class="plaintext hljs">$VMHost = Get-VMHost -Location $Cluster |sort -Property "MemoryUsageGB" |select -First 1 IF ($VMHost.MemoryUsageGB -le "20"){ Write-Host -foreground red "STOP: No enough ESXi host capacity" Break }</code> </pre><br><br>  Tomamos nosso modelo <br><br><pre> <code class="plaintext hljs">$VMTemplate = Get-Template -Name 'Win2016_Std_x64_Template'</code> </pre> <br><br>  E crie uma nova m√°quina virtual <br><br><pre> <code class="plaintext hljs">New-VM -Name $Configuration.Hostname.ToUpper() -VMHost $VMHost -ResourcePool $ResourcePool -Datastore $Datastore -Template $VMTemplate -Location "AutoDeployed VMs"</code> </pre> <br><br>  √â importante conectar a interface de rede a uma sub-rede com o DHCP ativado. <br><br>  Come√ßamos a m√°quina virtual <br><br><pre> <code class="plaintext hljs">Start-VM $VM</code> </pre> <br><br>  E salve a descri√ß√£o da m√°quina, para que posteriormente voc√™ possa determinar a m√°quina no n√≠vel do VMWare. <br><br><pre> <code class="plaintext hljs">Set-Annotation -Entity $VM -CustomAttribute "Change request" -Value $Configuration.Request -Confirm:$false Set-VM $VM -Notes $Configuration.Description -Confirm:$false</code> </pre><br><br>  A m√°quina foi iniciada e agora podemos descobrir o endere√ßo MAC recebido: <br><br><pre> <code class="plaintext hljs">$vMAC = (($VM | Get-NetworkAdapter | Select-Object -Property "MacAddress").MacAddress).Replace(':','')</code> </pre> <br><br>  Salve esse valor em nosso arquivo JSON. <br><br><pre> <code class="plaintext hljs">$Configuration.Network.MAC=$VMAC ConvertTo-Json -InputObject $Configuration -Depth 100 | Out-File "C:\Configs\TargetNodes\Build\$Hostname.json" -Force</code> </pre><br><br>  Aqui √© o momento de confirmar com o nosso Git que a m√°quina √© criada e possui seu pr√≥prio MAC exclusivo. <br><br>  A m√°quina inicia a inicializa√ß√£o (ap√≥s sysprep), instalando o equipamento e a configura√ß√£o inicial. <br><br>  Vamos esperar at√© que a nossa m√°quina WinRM esteja dispon√≠vel com o script EstablishConnection.ps1. <br><br>  Primeiro, descobrimos qual IP a m√°quina recebeu do DHCP: <br><br><pre> <code class="plaintext hljs"># $MAC = $vMAC while($isOnline -ne $true){ if((Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer -ErrorAction Ignore).IPAddress.IPAddressToString){ $tempIP=(Get-DhcpServerv4Lease -ClientId $MAC -ScopeId $StagingDHCPScope -ComputerName $DHCPServer).IPAddress.IPAddressToString break } else{ if($isOnline -ne $true){ Write-Host "`r$i`t" -NoNewline $i++ } } }</code> </pre><br><br>  E agora vamos esperar, quando a m√°quina estar√° dispon√≠vel no WinRM: <br><br><pre> <code class="plaintext hljs">$LocalAdmin = Get-StoredCredential -Type Generic -Target LocalAdmin $i=0 $isOnline=$false while($isOnline -ne $true){ if(Invoke-Command -ComputerName $tempIP -ScriptBlock{ Get-ItemProperty -Path "Registry::\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing" } -Credential $LocalAdmin -ErrorAction SilentlyContinue){ $isOnline=$true break } else{ if($isOnline -ne $true){ Write-Host "`r$i" -NoNewline $i++ Start-Sleep -Seconds 1 } } }</code> </pre><br><br>  A m√°quina est√° pronta para dirigir. <br><br><h3>  Configura√ß√£o de estado desejada <br></h3><br>  Para definir a configura√ß√£o desejada, usamos a parte do PowerShell - DSC (Configura√ß√£o do estado desejado).  H√° um DSC Pull Server configurado na rede: dscpull.testdomain.eu. <br>  Abaixo est√° a configura√ß√£o do nosso DSC Pull Server.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bom artigo sobre a configura√ß√£o do DSC Pull.</a> <br><br><pre> <code class="plaintext hljs">Node $NodeName { WindowsFeature DSCServiceFeature { Ensure = "Present" Name = "DSC-Service" } xDscWebService PSDSCPullServer { Ensure = "Present" EndpointName = "PSDSCPullServer" Port = 8080 PhysicalPath = "$env:SystemDrive\inetpub\PSDSCPullServer" CertificateThumbPrint = $certificateThumbPrint ModulePath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Modules" ConfigurationPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService\Configuration" State = "Started" DependsOn = "[WindowsFeature]DSCServiceFeature" RegistrationKeyPath = "$env:PROGRAMFILES\WindowsPowerShell\DscService" AcceptSelfSignedCertificates = $true UseSecurityBestPractices = $true } File RegistrationKeyFile { Ensure = 'Present' Type = 'File' DestinationPath = "$env:ProgramFiles\WindowsPowerShell\DscService\RegistrationKeys.txt" Contents = $RegistrationKey } }</code> </pre><br><br>  Est√° dispon√≠vel em: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://dscpull.testdomain.eu:8080</a> <br><br>  Seu ponto final: <a href="">https://dscpull.testdomain.eu:8080/PSDSCPullserver.svc</a> <br><br>  Todos os clientes do servidor pull devem ter o PowerShell 5.1 instalado <br>  Caso contr√°rio, o PowerShell 5.1 instalado: <br><br><pre> <code class="plaintext hljs">$PSVersionTable.PSVersion.Major ‚Äìlt 5</code> </pre> <br><br>  instale o PowerShell 5.1: <br><br><pre> <code class="plaintext hljs">Write-Host "Download PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock { [System.Net.ServicePointManager]::SecurityProtocol=[System.Net.SecurityProtocolType]::Tls12;Invoke-WebRequest -Uri "https://dscpull.testdomain.eu:8080/Files/Updates/WMF.msu" -OutFile C:\TEMP\WMF.MSU } Write-Host "Extract PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'wusa.exe' -ArgumentList "C:\temp\WMF.msu /extract:C:\temp\" -Wait -PassThru } Write-Host "Apply PowerShell 5.1" Invoke-Command -ComputerName $Node -ScriptBlock {Start-Process -FilePath 'dism.exe' -ArgumentList "/online /add-package /PackagePath:C:\temp\WindowsBlue-KB3191564-x64.cab /Quiet" -Wait -PassThru } Write-Host "PowerShell 5.1 has been installed"</code> </pre><br><br>  Um servidor PKI tamb√©m √© implantado em nossa rede.  Essa √© uma condi√ß√£o para a criptografia segura de credenciais armazenadas em arquivos DSC mof (arquivos Mof s√£o o "idioma" no qual o Pull Server e seus clientes se comunicam).  Quando um cliente tenta se registrar no servidor Pull, √© necess√°rio especificar um certificado Thumbprint e, posteriormente, o servidor Pull usar√° esse certificado para criptografar senhas.  Abaixo veremos como funciona. <br><br>  Importe a CA raiz para nossa nova m√°quina: <br><br><pre> <code class="plaintext hljs"> Invoke-Command -ComputerName $server -ScriptBlock{ $PKI="-----BEGIN CERTIFICATE----- MIIF2TCCA8GgAwIBAgIQSPIjcff9rotNdxbg3+ygqDANBgkqhkiG9w0BAQUFADAe **************************************************************** znafMvVx0B4tGEz2PFss/FviGdC3RohBHG0rF5jO50J4nS/3cGGm+HGdn1w/tZd0 a0FWpn9VCOSmXM2It+tSW1f4nZVt6T2kr1ZlTxkDhT7HMSGsrX/XJswzCkDGe3dE qrVVjNUkhVTaeeBWdujB5J6mcx7YkNsAUhODiS9Cf7FnYnxLFA72M0pijI48P5F0 ShM9HWAAUIrLkv13ug== -----END CERTIFICATE-----" $PKI | Out-File RootCA.cer Import-Certificate RootCA.cer -CertStoreLocation Cert:\LocalMachine\Root | select Thumbprint | Out-Null } -Credential $LocalAdmin | Out-Null</code> </pre><br><br>  Para trabalho adicional, precisamos de um par de chaves RSA.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Geraremos um certificado autoassinado</a> e trabalharemos temporariamente com ele. <br><br>  Agora podemos registrar no servidor Pull: <br><br><pre> <code class="plaintext hljs">$DscHostFQDN = [System.Net.Dns]::GetHostEntry([string]$env:computername).HostName $DscPullServerURL = "https://$($DscHostFQDN):8080/PSDSCPullserver.svc" $DscWebConfigChildPath = '\inetpub\psdscpullserver\web.config' $DscWebConfigPath = Join-Path -Path $env:SystemDrive -ChildPath $DscWebConfigChildPath $DscWebConfigXML = [xml](Get-Content $DscWebConfigPath) $DscRegKeyName = 'RegistrationKeys.txt' $DscRegKeyXMLNode = "//appSettings/add[@key = 'RegistrationKeyPath']" $DscRegKeyParentPath = ($DscWebConfigXML.SelectNodes($DscRegKeyXMLNode)).value $DscRegKeyPath = Join-Path -Path $DscRegKeyParentPath -ChildPath $DscRegKeyName $DscRegKey = Get-Content $DscRegKeyPath [DSCLocalConfigurationManager()] configuration RegisterOnPull { Node $Node { Settings { ConfigurationModeFrequencyMins = 1440 CertificateID = $Thumbprint RefreshMode ='Pull' RefreshFrequencyMins = 1440 RebootNodeIfNeeded = $true ConfigurationMode ='ApplyAndAutoCorrect' AllowModuleOverwrite = $true DebugMode = 'None' StatusRetentionTimeInDays = 1 } ConfigurationRepositoryWeb $([string]$env:computername) { ServerURL = $DscPullServerURL RegistrationKey = $DscRegKey CertificateID = $Thumbprint ConfigurationNames = @("$hostx") } } } RegisterOnPull -OutputPath $MetaConfigsStorage Set-DscLocalConfigurationManager -ComputerName $Node -Path $MetaConfigsStorage -Verbose -Force -Credential $LocalAdmin</code> </pre><br><br>  Envie a primeira configura√ß√£o para nossa m√°quina <br><br><pre> <code class="plaintext hljs">Configuration Rename { param ( [Parameter()] [System.String[]] $Node, $hostname ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname } } } Rename -Node $Node -OutputPath $DscConfigPath -hostname $hostname New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  O servidor renomeia e reinicia automaticamente.  Agora podemos executar o ingresso no dom√≠nio. <br><br><pre> <code class="plaintext hljs">Configuration JoinAD { param ( [Parameter()] [System.String[]] $Node, [Parameter(Mandatory = $true)] [ValidateNotNullorEmpty()] [System.Management.Automation.PSCredential] $DomainAdmin, $hostname, $domain ) Import-DscResource -ModuleName xComputerManagement Import-DscResource ‚ÄìModuleName PSDesiredStateConfiguration Node $Node { xComputer JoinDomain { Name = $hostname DomainName = $domain Credential = $DomainAdmin JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu" } GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( 'testdomain-eu\dscstaging' ) } } } $cd = @{ AllNodes = @( @{ NodeName = $Node PSDscAllowPlainTextPassword = $false PSDscAllowDomainUser=$true Certificatefile = $CertFile Thumbprint = $Certificate.ToString() } ) } JoinAD -Node $Node -OutputPath $DscConfigPath -DomainAdmin $DomainAdmin -hostname $hostname -ConfigurationData $cd -domain $domain New-DscChecksum $DscConfigPath -Force Invoke-Command -ComputerName $Node -ScriptBlock{Update-DscConfiguration -Verbose -Wait } -Credential $LocalAdmin -Verbose</code> </pre><br><br>  Aqui est√° a apar√™ncia do nosso arquivo mof: <br><br><pre> <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H \ nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO + BEyD2cr6vKHdn \ nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT + GX4IkPezR \ nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp + VQCx2ljlwif6ac4X / PQG \ n ----- END CMS -----"; <code class="plaintext hljs">instance of MSFT_Credential as $MSFT_Credential1ref { Password = "-----BEGIN CMS-----\nMIIBsgYJKoZIhvcNAQcDoIIBozCCAZ8CAQAxggFKMIIBRgIBADAuMBoxGDAWBgNVBAMMD1dJTi1H\nNFFKTFFQME4xNQIQOQN77pxew75HU6l7GPn99TANBgkqhkiG9w0BAQcwAASCAQAlhFf7Zs2gJbJEnc1DEK2yWbKcO+BEyD2cr6vKHdn\nQ9TrjvbysEOvYjT15o6MccwkMEwGCSqGSIb3DQEHATAdBglghkgBZQMEASoEEEdKJT+GX4IkPezR\nwYncyQiAIAFKxwJocH4ufRsq9L2Ipkp+VQCx2ljlwif6ac4X/PqG\n-----END CMS-----"; UserName = "testdomain.eu\\service_DomainJoin_001"; }; instance of MSFT_xComputer as $MSFT_xComputer1ref { ResourceID = "[xComputer]JoinDomain"; Credential = $MSFT_Credential1ref; DomainName = "testdomain.eu"; SourceInfo = "C:\\Program Files\\WindowsPowerShell\\Scripts\\JoinAD.ps1::34::9::xComputer"; Name = "dsctest51"; JoinOU = "OU=Servers,OU=Staging,DC=testdomain,DC=eu"; ModuleName = "xComputerManagement"; ModuleVersion = "4.1.0.0"; ConfigurationName = "JoinAD"; };</code> </pre><br><br>  Credenciais criptografadas DSC de uma conta de servi√ßo com direitos de administrador de dom√≠nio: testdomain.eu \\ service_DomainJoin_001 com um certificado autoassinado.  O DSC Client com sua chave privada descriptografa as credenciais e aplica todos os m√≥dulos de configura√ß√£o com as credenciais de dom√≠nio especificadas.  Nesse caso, ele realiza a jun√ß√£o de dom√≠nio na unidade organizacional especificada. <br><br><pre> <code class="plaintext hljs">GroupSet LocalAdmins { GroupName = @( 'Administrators') Ensure = 'Present' MembersToInclude = @( testdomain-eu\dscstaging' ) }</code> </pre><br><br>  Este m√≥dulo adiciona o dscstaging aos administradores locais para configura√ß√£o adicional. <br><br>  Ap√≥s a reinicializa√ß√£o, poderemos entrar na m√°quina com credenciais de dom√≠nio. <br><br>  Estamos aguardando o servidor receber um certificado da nossa PKI (temos a inscri√ß√£o autom√°tica configurada) e, no futuro, trabalharemos com o certificado emitido pela nossa PKI. <br><br><pre> <code class="plaintext hljs">$vmcert=Invoke-Command -ComputerName $server -ScriptBlock{ return Get-ChildItem -Path cert:\LocalMachine\My | where {$_.EnhancedKeyUsageList.FriendlyName -eq "Document Encryption"-and $_.Issuer -eq "CN=TestDomain Issuing CA, DC=testdomain, DC=eu"} } -ErrorAction Ignore</code> </pre> <br><br>  Agora, inscreva-se no Pull Server novamente com a impress√£o digital atualizada. <br><br>  √â isso, a m√°quina ingressada no dom√≠nio, e podemos us√°-la da maneira que mais nos conv√©m. <br><br><h3>  Instale o SQL Server <br></h3><br>  O arquivo JSON descreve os requisitos para o MS SQL Server; tamb√©m usamos o DSC para instalar e configurar o SQL Server.  √â assim que a configura√ß√£o se parece: <br><br><pre> <code class="plaintext hljs">Configuration $Node{ WindowsFeature "NetFramework35"{ Name = "NET-Framework-Core" Ensure = "Present" Source = "\\$DscHostFQDN\Files\Updates" } WindowsFeature "NetFramework45"{ Name = "NET-Framework-45-Core" Ensure= "Present" } SqlSetup "MSSQL2012NamedInstance"{ InstanceName = $MSSQL.InstanceName Features = $MSSQL.Features ProductKey = $ProductKey SQLCollation = $MSSQL.Collation SQLSysAdminAccounts = @('testdomain-EU\SQLAdmins',' testdomain-EU\Backup') InstallSharedDir = "C:\Program Files\Microsoft SQL Server" InstallSharedWOWDir = "C:\Program Files (x86)\Microsoft SQL Server" InstallSQLDataDir = $MSSQL.DataRoot SQLUserDBDir = $MSSQL.UserDBDir SQLUserDBLogDir = $MSSQL.UserLogDir SQLTempDBDir = $MSSQL.TempDBDir SQLTempDBLogDir = $MSSQL.TempDBLogDir SQLBackupDir = $MSSQL.BackupDir SourcePath = $SQLSource SAPwd = $SA SecurityMode = 'SQL' UpdateSource = ".\Updates" Action = "Install" ForceReboot = $True SQLSvcAccount = $SqlServiceCredential AgtSvcAccount = $SqlServiceCredential ISSvcAccount = $SqlServiceCredential BrowserSvcStartupType = "Automatic" DependsOn = '[WindowsFeature]NetFramework35', '[WindowsFeature]NetFramework45' }</code> </pre><br>  Onde $ MSSQL est√° definido: <br><pre> <code class="plaintext hljs">$MSSQL=$Configuration.Applications | where {$_.Application -eq "Microsoft SQL Server 2012"}</code> </pre> <br><br>  $ MSSQL.InstanceName - tudo isso √© indicado em nosso arquivo Json.  A aplica√ß√£o dessa configura√ß√£o instalar√° o MS SQL Server com todas as atualiza√ß√µes na pasta Atualiza√ß√µes e reiniciar√° o servidor, se necess√°rio. <br><br>  O carro est√° pronto. <br><br><h2>  Servi√ßo agora </h2><br>  Existem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">v√°rias APIs dispon√≠veis</a> no Service-Now.  Usamos a API Rest. <br>  Para obter uma lista de m√°quinas com status Alocado, uma consulta do formul√°rio √© usada: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instance.service-now.com/cmdb_ci_server_list.do?sysparm_query=install_status=16</a> ^ u_subtype = ^ ORDERBYname <br>  No PowerShell, fica assim: <br><pre> <code class="plaintext hljs">$url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=install_status=16^u_subtype=^ORDERBYname" $uri= new-object System.Uri("https://instance.service-now.com/") #       $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json #   Configuration Items  $ServersCI=$Servers.result</code> </pre> <br>  O primeiro objeto da matriz √© o nome do host que precisamos. <br>  Se a m√°quina estiver pronta, voc√™ poder√° alterar o status da m√°quina no Service-Now, para isso o script UpdateCI.ps1: <br><pre> <code class="plaintext hljs">param( $CI, [ValidateSet("Allocated","In use","Pending install")] $NewStatus='In use' ) $url="https://instance.service-now.com/api/now/table/cmdb_ci_server?sysparm_query=name=$CI" $uri= new-object System.Uri("https://instance.service-now.com/") $credentials = (Get-StoredCredential -Type Generic -Target DSC).GetNetworkCredential() $credentials = new-object System.Net.NetworkCredential $credentials.UserName, $credentials.SecurePassword Add-Type -AssemblyName System.Net.Http $handler = New-Object System.Net.Http.HttpClientHandler $handler.CookieContainer = New-Object System.Net.CookieContainer $handler.UseCookies=$true $handler.Credentials=$credentials $HttpClient = New-Object System.Net.Http.HttpClient($handler) $HttpClient.BaseAddress= $uri $Header = New-Object System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json") $HttpClient.DefaultRequestHeaders.Accept.Clear() $HttpClient.DefaultRequestHeaders.Accept.Add($Header); $response=$HttpClient.GetAsync($url) $respStream=$response.Result.Content.ReadAsStringAsync() $Servers = $respStream.Result | ConvertFrom-Json $ServerCI=$Servers.result[0] $update=@{} if($NewStatus -eq "In use"){ $update.install_status=1 } if($NewStatus -eq "Pending install"){ $update.install_status=4 } $stringcontent = New-Object System.Net.Http.StringContent((ConvertTo-Json -InputObject $update -Depth 100),[System.Text.Encoding]::UTF8, "application/json"); $result=$HttpClient.PutAsync("https://instance.service-now.com/api/now/table/cmdb_ci_server/$($ServerCI.sys_id)", $stringcontent)</code> </pre> <br>  Para obter a tabela e os registros, as solicita√ß√µes GET API REST s√£o usadas para alterar as solicita√ß√µes PUT / POST do registro, no corpo do qual os campos que voc√™ precisa alterar. <br><br>  <i>Criamos uma ferramenta conveniente com uma ferramenta gr√°fica como o Portal do Azure, que nos permite gerenciar a infraestrutura local o mais conveniente poss√≠vel para n√≥s e nossos clientes.</i> <br>  PS 12.24.2018.  Tudo parece estar desatualizado?  √â hora de usar o Azure DevOps.  No pr√≥ximo artigo, mostrarei como fazer tudo isso com o pipeline do Azure DevOps. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt425129/">https://habr.com/ru/post/pt425129/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt425113/index.html">"Tipografia digital" ou minha experi√™ncia em digitaliza√ß√£o m√≥vel de livros</a></li>
<li><a href="../pt425115/index.html">DevOps completo: trag√©dia grega em tr√™s atos</a></li>
<li><a href="../pt425117/index.html">Dois bits por transistor: ROM de alta densidade em um chip de ponto flutuante Intel 8087</a></li>
<li><a href="../pt425123/index.html">O cora√ß√£o misterioso da bateria eletr√¥nica Roland TR-808</a></li>
<li><a href="../pt425125/index.html">@Pythonetc setembro de 2018</a></li>
<li><a href="../pt425131/index.html">O que ler sobre a tecnologia blockchain: guias, livros e artigos</a></li>
<li><a href="../pt425133/index.html">Problemas de pagamento transfronteiri√ßo - por que e como a blockchain √© usada aqui</a></li>
<li><a href="../pt425135/index.html">Por que o VoIP √© reconhecido como um servi√ßo de informa√ß√µes nos EUA e o que isso significa para o setor de telecomunica√ß√µes e usu√°rios</a></li>
<li><a href="../pt425137/index.html">Trabalhamos no console com rapidez e efici√™ncia</a></li>
<li><a href="../pt425139/index.html">Estrelas pop sob as lentes da intelig√™ncia artificial</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>