<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>▶️ 🙄 👩🏾‍🏫 可视化基于图像的分类器解决方案的边界 👨‍👧‍👦 💆🏻 📽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 了解分类器如何将属性的初始多维空间分解为许多目标类是分析任何分类问题和评估使用机器学习获得的解决方案的重要步骤。 


 现代的分类器决策可视化方法主要是使用散点图，这些散点图只能显示原始训练样本的投影，而不能明确显示决策的实际边界，或者使用分类器的内部结构（例如kNN，SVM，逻辑回...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>可视化基于图像的分类器解决方案的边界</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483608/"><h2 id="vvedenie"> 引言 </h2><br><p> 了解分类器如何将属性的初始多维空间分解为许多目标类是分析任何分类问题和评估使用机器学习获得的解决方案的重要步骤。 </p><br><p> 现代的分类器决策可视化方法主要是使用散点图，这些散点图只能显示原始训练样本的投影，而不能明确显示决策的实际边界，或者使用分类器的内部结构（例如kNN，SVM，逻辑回归），因此很容易构造几何图形解释。 该方法不适用于例如神经网络分类器的可视化。 </p><br><p> 文章<em>``基于图像的分类器决策边界可视化''（Rodrigues等人，2018）</em>提出了一种有效，美观且相当简单的替代方法来可视化分类器解决方案，该方法没有上述缺点。 即，该方法适合于任何种类的分类器，并且使用具有任意采样率的图像来建立决策的边界。 </p><br><p>  <em>这篇文章简要概述了原始文章的主要思想和结果。</em> </p><a name="habracut"></a><br><h2 id="opisanie-metoda"> 方法说明 </h2><br><p> 该方法的基础是从像平面进行反向采样<em>（英语升采样）</em> <img src="https://habrastorage.org/getpro/habr/post_images/bbe/6f0/7de/bbe6f07de26be484f6cda1bf892ff41b.svg" alt="\ mathbb {R} ^ 2"> 它由特征空间中的一组像素表示 <img src="https://habrastorage.org/getpro/habr/post_images/083/a90/e39/083a90e392615e6ff9271b60c0ffb8db.svg" alt="\ mathbb {R} ^ n">  。 </p><br><p> 该方法需要两个映射 <img src="https://habrastorage.org/getpro/habr/post_images/da1/8e5/2bc/da18e52bcc30ce0aa0ecaeee335ae07f.svg" alt="P：\ mathbb {R} ^ n \到\ mathbb {R} ^ 2">  -从特征空间直接投影到像平面和反面 <img src="https://habrastorage.org/getpro/habr/post_images/5b3/03b/64d/5b303b64d69ea3c32dd0f084fbc68091.svg" alt="P ^ {-1}：\ mathbb {R} ^ 2 \到\ mathbb {R} ^ n">  。 作为此类映射，分别使用了<em>LAMP（Joia等人，2011）</em>和<em>iLAMP（Amorim等人，2012）</em> 。 </p><br><h4 id="postroenie"> 建筑 </h4><br><p> 要生成图像，您需要为每个像素分配一种颜色。 为此，对于每个像素 <img src="https://habrastorage.org/getpro/habr/post_images/7ba/469/280/7ba469280dbeae1ae4fcd637e6d8966e.svg" alt="ÿ"> 会发现 <img src="https://habrastorage.org/getpro/habr/post_images/bff/605/a65/bff605a65883fb83a49aeb1ef0d21f3f.svg" alt="N \ geq 1"> 来自源超空间的点 <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="ñ">  -用户指定的参数。 让像素 <img src="https://habrastorage.org/getpro/habr/post_images/7ba/469/280/7ba469280dbeae1ae4fcd637e6d8966e.svg" alt="ÿ"> 已经有 <img src="https://habrastorage.org/getpro/habr/post_images/434/1b0/03f/4341b003f49abd1e3af597087bc9b190.svg" alt="n（y）\ geq 0"> 训练集中的真实原型。 然后均匀选择 <img src="https://habrastorage.org/getpro/habr/post_images/b81/cfa/f99/b81cfaf992bc8f0efaa1099e7a7fe993.svg" alt="\ max（N-n（y），0）"> 来自像素表面的其余点，并通过反向投影找到它们的原型 <img src="https://habrastorage.org/getpro/habr/post_images/94f/124/acc/94f124acc806a90feaf324e0ad8450db.svg" alt="x_i = P ^ {-1}（y_i）">  。 因此，每个像素的颜色将至少由 <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="ñ"> 点空间，整个图像将被绘制。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0ad/fdd/96a/0adfdd96afccbad3702cd032a754481f.png" alt="方法差异" width="400"><br>  [图1]不同方法的示意图 </p><br><h4 id="opredelenie-cveta"> 颜色定义 </h4><br><p> 色泽 <img src="https://habrastorage.org/getpro/habr/post_images/804/c42/9d4/804c429d4bd8e4f2577d467481a193bd.svg" alt="d"> 每个像素 <img src="https://habrastorage.org/getpro/habr/post_images/7ba/469/280/7ba469280dbeae1ae4fcd637e6d8966e.svg" alt="ÿ"> 由多数投票决定相应原像的类别标签。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/469/c8d/c50/469c8dc5021ee22be2190d80d4a8f9bd.svg" alt="d（y）= \文字{argmax} _ {k \ in C} \ sum_ {y_i \ in y} [f（P ^ {-1}（y_i））= k]"><br><p> 在哪里 <img src="https://habrastorage.org/getpro/habr/post_images/fbc/aa2/dde/fbcaa2dde5e052a6e1800227925c3615.svg" alt="ç">  -许多班级 <img src="https://habrastorage.org/getpro/habr/post_images/b7b/64a/383/b7b64a3838b51c8557f97dadf1217771.svg" alt="f：\ mathbb {R} ^ n \到C">  -分类器。 </p><br><p> 每个班级都会被分配一个音调<em>（英语：Hue）</em> <img src="https://habrastorage.org/getpro/habr/post_images/23e/de5/d9b/23ede5d9b5363fbdc2108333f4ae7e33.svg" alt="H_T（k）">  -如果投影中包含真实样本中的点，并且色调略有变化 <img src="https://habrastorage.org/getpro/habr/post_images/9c9/128/5aa/9c91285aa90f350efd4554aebbbb0928.svg" alt="H _ {\文字{合成}}（k）"> 对于只有合成点的像素。 </p><br><h4 id="smeshenie"> 混乱 </h4><br><p> 定义像素混合<em>（源自英语混淆）</em> <img src="https://habrastorage.org/getpro/habr/post_images/704/5da/302/7045da3025a345f8eee22cdbc3371540.svg" alt="c（y）">  -作为主要类别的标签数与像素反向图像总数的比值 <img src="https://habrastorage.org/getpro/habr/post_images/7ba/469/280/7ba469280dbeae1ae4fcd637e6d8966e.svg" alt="ÿ">  ： </p><br><img src="https://habrastorage.org/getpro/habr/post_images/62d/5e7/47f/62d5e747f958e587200665af682cbae9.svg" alt="c（y）= \ frac {\ max_ {k \ in C} \ sum_ {y_i \ in y} [f（P ^ {-1}（y_i））= k]} {| y |}"><br><p> 高价值 <img src="https://habrastorage.org/getpro/habr/post_images/704/5da/302/7045da3025a345f8eee22cdbc3371540.svg" alt="c（y）"> 表示分类器的一致性，而低值表示接近划分边界。 混合以像素饱和度编码的信息 <img src="https://habrastorage.org/getpro/habr/post_images/63e/a67/704/63ea67704edb2fecd38058084b809c43.svg" alt="S（y）">  -一致性越高，饱和度越高。 </p><br><h4 id="plotnost"> 密实度 </h4><br><p> 尽管已产生最小值 <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="ñ"> 每个像素的原像点，可能有一些像素来自训练集，它们的真实点要多得多。 渲染时应考虑此类像素。 为此，请输入像素密度 <img src="https://habrastorage.org/getpro/habr/post_images/f76/9da/704/f769da704577ffcb3b5a6cde5ff711d5.svg" alt="\ rho（y）"> 作为其逆像点的数量 <img src="https://habrastorage.org/getpro/habr/post_images/083/a90/e39/083a90e392615e6ff9271b60c0ffb8db.svg" alt="\ mathbb {R} ^ n">  。 可以直接使用这种密度来确定像素的亮度 <img src="https://habrastorage.org/getpro/habr/post_images/5cb/176/90f/5cb17690f41ccca3920dd257b053536d.svg" alt="V（y）= \ frac {\ rho（y）} {\ rho_ {max}}">  ，但是该文章的作者指出，这无法产生预期的结果，因为 有些色调显然比其他色调暗。 因此，可以通过归一化的密度参数在饱和度和亮度的同时使用更复杂的设置。 </p><br><img src="https://habrastorage.org/getpro/habr/post_images/374/faf/768/374faf7680b448f460d3e89129445ff5.svg" alt="\ hat {\ rho} = max（\ frac {1} {20} \ frac {\ rho} {\ rho_ {avg}}，1）"><br><p> 那如果 <img src="https://habrastorage.org/getpro/habr/post_images/5f3/8f9/0c5/5f38f90c57fe8c26092278e6a36b55c7.svg" alt="\ hat {\ rho} \ in [0，0.5]">  -亮度线性地取决于内部的参数 <img src="https://habrastorage.org/getpro/habr/post_images/b1e/ef5/e22/b1eef5e220c553d3c437ee6ddb9f4f08.svg" alt="[V_ {min} = 0.1，V_ {max} = 1]">  。 在 <img src="https://habrastorage.org/getpro/habr/post_images/4cc/04d/a79/4cc04da7997da643ef6671babba1ec57.svg" alt="\ hat {\ rho} \ in [0.5，1]"> 从开始线性饱和 <img src="https://habrastorage.org/getpro/habr/post_images/990/75d/89e/99075d89ee3ecff0e455ea82750e353f.svg" alt="S_ {min} = 0.2"> 之前 <img src="https://habrastorage.org/getpro/habr/post_images/638/3c5/73c/6383c573c312afd338a8ba5dbbaacdeb.svg" alt="S_ {max} = 1">  。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6f2/21c/de5/6f221cde5e5f7fc053ec45964ec5dcbc.png" alt="颜色编码" width="400"><br>  [图2]颜色编码 </p><br><h2 id="eksperimenty-i-rezultaty"> 实验与结果 </h2><br><p> 为了进行实验，解决了<em>MNIST数字</em>图像集上的二进制分类和<em>图像分割数据集</em>上的多类分类问题，该<em>图像</em>分类<em>数据集</em>包含2310张图像，分为7类。 每个图像有19个属性。 </p><br><p> 使用各种分辨率设置成像结果 <img src="https://habrastorage.org/getpro/habr/post_images/bc2/e13/169/bc2e1316980f83eed49a82ca5dd0f525.svg" alt="[R"> 和最少数量的原型 <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="ñ">  MNIST上的二元分类器LogisticRegression的情况如图3所示。 通过高精度的直线分隔各类，并且可视化算法做得很好。 随着分辨率的提高，源点的云几乎完全溶解在许多生成的点中。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/037/5c6/69b/0375c669bf3ad059981b01727998baa9.png" alt="颜色编码" width="400"><br>  [图。  3] LogisticRegression分类器的各种分辨率参数和最小样本数N的可视化结果 </p><br><p> 可视化时间 <img src="https://habrastorage.org/getpro/habr/post_images/17c/6e0/1e3/17c6e01e344982b1f502a87aaf5560c5.svg" alt="R = 500 \文字{x} 500，N = 5"> 图[4]中针对三个不同分类器的多重分类。 起点的投影强烈混合，并且不可能在累积测试用例的投影的地方构造明确的划分边界。 但是，除了主类之外，还获得了明确的类边界，有关类的信息不会显示在普通投影上，而只能在合成点的帮助下获得。 </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/662/ff8/8f4/662ff88f47de55ce8855a2676691d102.png" alt="颜色编码" width="400"><br>  [图。  4]三种不同分类器的可视化结果，其中k = 7，R = 500x500，N = 5 </p><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> 类边界的可视化可用于决定性算法的构建和调试，超参数的选择，与再训练的斗争中，以呈现和分析结果。 </p><br><p> 原始文章作者描述的方法可以用于任何分类问题，其中数据可以表示为一组固定尺寸的符号。 与其他可视化算法不同，此方法可用于任何任意复杂的分类器以及具有任意数量示例（甚至很小的示例）的数据集，因为 即使很小 <img src="https://habrastorage.org/getpro/habr/post_images/a1e/39d/a1c/a1e39da1c84981d7264baa207047222a.svg" alt="ñ"> 该算法稳定运行，而不会损失很多质量。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483608/">https://habr.com/ru/post/zh-CN483608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483594/index.html">物理学家的未来经济学</a></li>
<li><a href="../zh-CN483598/index.html">更具音乐感的复活节彩蛋：我们将继续谈论倾听听众的礼物</a></li>
<li><a href="../zh-CN483600/index.html">免费释放您的Android</a></li>
<li><a href="../zh-CN483602/index.html">DefCon 27会议：创建电子徽章的幕后花絮 第二部分</a></li>
<li><a href="../zh-CN483604/index.html">铱星：在家接收和解码卫星星座信号</a></li>
<li><a href="../zh-CN483612/index.html">特斯拉司机因在自动驾驶仪上刷牙而被罚款</a></li>
<li><a href="../zh-CN483614/index.html">防止机器人俱乐部盗窃的方法</a></li>
<li><a href="../zh-CN483616/index.html">Lacmus项目：计算机视觉如何帮助挽救失去的人们</a></li>
<li><a href="../zh-CN483624/index.html">Yandex.Taxi比赛：编程冠军赛的后端赛道分析</a></li>
<li><a href="../zh-CN483628/index.html">从OpenAPI v3（aka Swagger 3）到TypeScript的代码生成</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>