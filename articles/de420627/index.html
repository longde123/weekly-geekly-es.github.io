<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïß üôç üñêüèº C # Asynchrone Programmierung: Wie geht es Ihnen mit der Leistung? üöµüèæ üòá üì∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zuletzt haben wir bereits dar√ºber gesprochen, ob Equals und GetHashCode beim Programmieren in C # √ºberschrieben werden sollen. Heute werden wir uns mi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # Asynchrone Programmierung: Wie geht es Ihnen mit der Leistung?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/420627/">  Zuletzt haben wir bereits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dar√ºber gesprochen,</a> ob Equals und GetHashCode beim Programmieren in C # √ºberschrieben werden sollen.  Heute werden wir uns mit den Leistungsparametern asynchroner Methoden befassen.  Jetzt mitmachen! <br><br><img src="https://habrastorage.org/webt/ag/zp/yy/agzpyy85elnfvb3vg4qotz0wt6s.jpeg"><a name="habracut"></a><br><br>  In den letzten beiden Artikeln im msdn-Blog haben wir uns mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">internen Struktur asynchroner Methoden in C #</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Erweiterungspunkten befasst</a> , die der C # -Compiler zur Steuerung des Verhaltens asynchroner Methoden bereitstellt. <br><br>  Basierend auf den Informationen im ersten Artikel f√ºhrt der Compiler viele Transformationen durch, um die asynchrone Programmierung der synchronen so √§hnlich wie m√∂glich zu machen.  Zu diesem Zweck erstellt er eine Instanz der Zustandsmaschine und √ºbergibt sie an den Builder der asynchronen Methode, die das Warteobjekt f√ºr die Aufgabe usw. aufruft. Nat√ºrlich hat eine solche Logik einen Preis, aber wie viel kostet sie uns? <br><br>  Bis zum Erscheinen der TPL-Bibliothek wurden asynchrone Operationen nicht in so gro√üer Menge verwendet, daher waren die Kosten nicht hoch.  Aber heute kann selbst eine relativ einfache Anwendung Hunderte, wenn nicht Tausende von asynchronen Operationen pro Sekunde ausf√ºhren.  Die TPL-Bibliothek f√ºr parallele Aufgaben wurde unter Ber√ºcksichtigung dieser Arbeitsbelastung erstellt, aber hier gibt es keine Magie und Sie m√ºssen f√ºr alles bezahlen. <br><br>  Um die Kosten asynchroner Methoden abzusch√§tzen, verwenden wir ein leicht modifiziertes Beispiel aus dem ersten Artikel. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StockPrices</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Count = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name, <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> price)&gt; _stockPricesCache; <span class="hljs-comment"><span class="hljs-comment">// Async version public async Task&lt;decimal&gt; GetStockPriceForAsync(string companyId) { await InitializeMapIfNeededAsync(); return DoGetPriceFromCache(companyId); } // Sync version that calls async init public decimal GetStockPriceFor(string companyId) { InitializeMapIfNeededAsync().GetAwaiter().GetResult(); return DoGetPriceFromCache(companyId); } // Purely sync version public decimal GetPriceFromCacheFor(string companyId) { InitializeMapIfNeeded(); return DoGetPriceFromCache(companyId); } private decimal DoGetPriceFromCache(string name) { foreach (var kvp in _stockPricesCache) { if (kvp.name == name) { return kvp.price; } } throw new InvalidOperationException($"Can't find price for '{name}'."); } [MethodImpl(MethodImplOptions.NoInlining)] private void InitializeMapIfNeeded() { // Similar initialization logic. } private async Task InitializeMapIfNeededAsync() { if (_stockPricesCache != null) { return; } await Task.Delay(42); // Getting the stock prices from the external source. // Generate 1000 items to make cache hit somewhat expensive _stockPricesCache = Enumerable.Range(1, Count) .Select(n =&gt; (name: n.ToString(), price: (decimal)n)) .ToList(); _stockPricesCache.Add((name: "MSFT", price: 42)); } }</span></span></code> </pre> <br>  Die <code>StockPrices</code> Klasse <code>StockPrices</code> Aktienkurse von einer externen Quelle zwischen und erm√∂glicht es Ihnen, sie √ºber die API anzufordern.  Der Hauptunterschied zum Beispiel im ersten Artikel ist der √úbergang von einem W√∂rterbuch zu einer Preisliste.  Um die Kosten verschiedener asynchroner Methoden im Vergleich zu synchronen Methoden abzusch√§tzen, muss die Operation selbst eine bestimmte Aufgabe erf√ºllen. In unserem Fall handelt es sich um eine lineare Suche nach Aktienkursen. <br><br>  Die <code>GetPricesFromCache</code> Methode <code>GetPricesFromCache</code> absichtlich auf einer einfachen Schleife, um eine Ressourcenzuweisung zu vermeiden. <br><br><h2>  Vergleich von synchronen Methoden und aufgabenbasierten asynchronen Methoden </h2><br>  Im ersten Leistungstest vergleichen wir die asynchrone Methode, die die asynchrone Initialisierungsmethode ( <code>GetStockPriceForAsync</code> ) <code>GetStockPriceForAsync</code> , die synchrone Methode, die die asynchrone Initialisierungsmethode ( <code>GetStockPriceFor</code> ) <code>GetStockPriceFor</code> , und die synchrone Methode, die die synchrone Initialisierungsmethode aufruft. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> StockPrices _stockPrices = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StockPrices(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SyncVsAsyncBenchmark</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Warming up the cache _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); } [Benchmark] public decimal GetPricesDirectlyFromCache() { return _stockPrices.GetPriceFromCacheFor("MSFT"); } [Benchmark(Baseline = true)] public decimal GetStockPriceFor() { return _stockPrices.GetStockPriceFor("MSFT"); } [Benchmark] public decimal GetStockPriceForAsync() { return _stockPrices.GetStockPriceForAsync("MSFT").GetAwaiter().GetResult(); }</span></span></code> </pre><br>  Die Ergebnisse sind unten gezeigt: <br><br><img src="https://habrastorage.org/webt/nc/cb/zd/nccbzd9-gv5ehroih0zxvdofc20.png"><br><br>  Bereits zu diesem Zeitpunkt haben wir interessante Daten erhalten: <br><br><ul><li>  Die asynchrone Methode ist ziemlich schnell.  <code>GetPricesForAsync</code> in diesem Test synchron ausgef√ºhrt und ist ungef√§hr 15% (*) langsamer als die rein synchrone Methode. </li><li>  Die synchrone <code>GetPricesFor</code> Methode, die die asynchrone <code>InitializeMapIfNeededAsync</code> Methode aufruft, hat noch geringere Kosten, weist jedoch √ºberraschenderweise √ºberhaupt keine Ressourcen zu (in der Spalte <code>GetPricesDirectlyFromCache</code> in der obigen Tabelle kostet sie sowohl f√ºr <code>GetPricesDirectlyFromCache</code> als auch f√ºr <code>GetPricesDirectlyFromCache</code> <code>GetStockPriceFor</code> ). </li></ul><br>  <i>(*) Nat√ºrlich kann nicht gesagt werden, dass die Kosten f√ºr die synchrone Ausf√ºhrung der asynchronen Methode in allen m√∂glichen F√§llen 15% betragen.</i>  <i>Dieser Wert h√§ngt direkt von der von der Methode ausgef√ºhrten Arbeitslast ab.</i>  <i>Der Unterschied zwischen dem Overhead eines reinen Aufrufs einer asynchronen Methode (die nichts tut) und einer synchronen Methode (die nichts tut) ist enorm.</i>  <i>Die Idee dieses Vergleichstests ist es zu zeigen, dass die Kosten der asynchronen Methode, die einen relativ geringen Arbeitsaufwand leistet, relativ gering sind.</i> <br><br>  Wie kommt es, dass beim Aufrufen von <code>InitializeMapIfNeededAsync</code> √ºberhaupt keine Ressourcen zugewiesen werden?  Im ersten Artikel dieser Reihe habe ich erw√§hnt, dass eine asynchrone Methode mindestens ein Objekt im verwalteten Header zuordnen sollte - die Taskinstanz selbst.  Lassen Sie uns diesen Punkt genauer diskutieren. <br><br><h2>  Optimierung Nr. 1: Zwischenspeichern von Aufgabeninstanzen, wenn m√∂glich </h2><br>  Die Antwort auf die obige Frage ist sehr einfach: <code>AsyncMethodBuilder</code> <b>verwendet eine Instanz der Aufgabe f√ºr jede erfolgreich abgeschlossene asynchrone Operation</b> .  Die von <code>Task</code> asynchrone Methode verwendet <code>AsyncMethodBuilder</code> mit der folgenden Logik in der <code>SetResult</code> Methode: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// AsyncMethodBuilder.cs from mscorlib public void SetResult() { // Ie the resulting task for all successfully completed // methods is the same -- s_cachedCompleted. m_builder.SetResult(s_cachedCompleted); }</span></span></code> </pre> <br>  Die <code>SetResult</code> Methode <code>SetResult</code> nur f√ºr erfolgreich abgeschlossene asynchrone Methoden aufgerufen, und ein <b>erfolgreiches Ergebnis f√ºr jede <code>Task</code> Methode kann frei zusammen verwendet werden</b> .  Wir k√∂nnen dieses Verhalten sogar mit dem folgenden Test verfolgen: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncVoidBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = Foo(); Assert.AreSame(t1, t2); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  Dies ist jedoch nicht die einzig m√∂gliche Optimierung.  <code>AsyncTaskMethodBuilder&lt;T&gt;</code> optimiert die Arbeit auf √§hnliche Weise: Es werden Aufgaben f√ºr <code>Task&lt;bool&gt;</code> und einige andere einfache Typen zwischengespeichert.  Beispielsweise werden alle Standardwerte f√ºr eine Gruppe von Ganzzahltypen zwischengespeichert und ein spezieller Cache f√ºr <code>Task&lt;int&gt;</code> , wobei Werte aus dem Bereich [-1;  9] (Weitere Informationen finden Sie unter <code>AsyncTaskMethodBuilder&lt;T&gt;.GetTaskForResult()</code> ). <br><br>  Dies wird durch folgenden Test best√§tigt: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AsyncTaskBuilderCachesResultingTask</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// These values are cached Assert.AreSame(Foo(-1), Foo(-1)); Assert.AreSame(Foo(8), Foo(8)); // But these are not Assert.AreNotSame(Foo(9), Foo(9)); Assert.AreNotSame(Foo(int.MaxValue), Foo(int.MaxValue)); async Task&lt;int&gt; Foo(int n) =&gt; n; }</span></span></code> </pre><br>  <b>Verlassen Sie sich nicht √ºberm√§√üig auf ein solches Verhalten</b> , aber es ist immer sch√∂n zu erkennen, dass die Entwickler der Sprache und Plattform alles tun, um die Produktivit√§t auf alle verf√ºgbaren Arten zu steigern.  Das Zwischenspeichern von Aufgaben ist eine beliebte Optimierungsmethode, die auch in anderen Bereichen verwendet wird.  Beispielsweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nutzt</a> eine neue Implementierung von <code>Socket</code> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">corefx-Repo-</a> Repository diese Methode in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gro√üem</a> Umfang und wendet nach M√∂glichkeit <a href="">zwischengespeicherte Aufgaben an</a> . <br><br><h2>  Optimierung Nr. 2: Verwenden von <code>ValueTask</code> </h2><br>  Die oben beschriebene Optimierungsmethode funktioniert nur in wenigen F√§llen.  Daher k√∂nnen wir stattdessen <code>ValueTask&lt;T&gt;</code> (**) verwenden, einen speziellen <code>ValueTask&lt;T&gt;</code> , der der Aufgabe √§hnlich ist.  Es werden keine Ressourcen zugewiesen, wenn die Methode synchron ausgef√ºhrt wird. <br><br>  <code>ValueTask&lt;T&gt;</code> ist eine unterscheidbare Kombination von <code>T</code> und <code>Task&lt;T&gt;</code> : Wenn die "Value-Task" abgeschlossen ist, wird der Basiswert verwendet.  Wenn die Grundzuordnung noch nicht ausgesch√∂pft ist, werden Ressourcen f√ºr die Aufgabe zugewiesen. <br><br>  Dieser spezielle Typ verhindert eine √ºberm√§√üige Heap-Bereitstellung, wenn eine Operation synchron ausgef√ºhrt wird.  Um <code>ValueTask&lt;T&gt;</code> , m√ºssen Sie den R√ºckgabetyp f√ºr <code>GetStockPriceForAsync</code> : Anstelle von <code>Task&lt;decimal&gt;</code> <code>ValueTask&lt;decimal&gt;</code> angeben: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> InitializeMapIfNeededAsync(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DoGetPriceFromCache(companyId); }</code> </pre><br>  Jetzt k√∂nnen wir den Unterschied mit einem zus√§tzlichen Vergleichstest bewerten: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/ek/pm/o5/ekpmo5bxsquftyndmelvwgsgjsc.png"><br><br>  Wie Sie sehen, ist die Version mit <code>ValueTask</code> nur geringf√ºgig schneller als die Version mit Task.  Der Hauptunterschied besteht darin, dass die Heap-Zuordnung verhindert wird.  In einer Minute werden wir die Machbarkeit eines solchen √úbergangs diskutieren, aber vorher m√∂chte ich √ºber eine knifflige Optimierung sprechen. <br><br><h2>  Optimierung Nr. 3: Verzicht auf asynchrone Methoden innerhalb eines gemeinsamen Pfades </h2><br>  Wenn Sie sehr h√§ufig eine asynchrone Methode verwenden und die Kosten noch weiter senken m√∂chten, empfehle ich Ihnen die folgende Optimierung: Entfernen Sie den Async-Modifikator, √ºberpr√ºfen Sie den Status der Aufgabe innerhalb der Methode und f√ºhren Sie den gesamten Vorgang synchron aus, wobei Sie asynchrone Ans√§tze vollst√§ndig aufgeben. <br><br>  Sieht kompliziert aus?  Betrachten Sie ein Beispiel. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = InitializeMapIfNeededAsync(); <span class="hljs-comment"><span class="hljs-comment">// Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(task, companyId); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync(Task initializeTask, string localCompanyId) { await initializeTask; return DoGetPriceFromCache(localCompanyId); } }</span></span></code> </pre><br>  In diesem Fall wird der <code>async</code> Modifikator in der <code>GetStockPriceWithValueTaskAsync_Optimized</code> Methode nicht verwendet. Wenn er also eine Aufgabe von der <code>InitializeMapIfNeededAsync</code> Methode empf√§ngt, √ºberpr√ºft er seinen Ausf√ºhrungsstatus.  Wenn die Aufgabe abgeschlossen ist, verwendet die Methode einfach <code>DoGetPriceFromCache</code> um sofort das Ergebnis zu erhalten.  Wenn die Initialisierungsaufgabe noch ausgef√ºhrt wird, ruft die Methode eine lokale Funktion auf und wartet auf Ergebnisse. <br><br>  Die Verwendung einer lokalen Funktion ist nicht die einzige, sondern eine der einfachsten M√∂glichkeiten.  Aber es gibt eine Einschr√§nkung.  W√§hrend der nat√ºrlichsten Implementierung erh√§lt die lokale Funktion einen externen Status (lokale Variable und Argument): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Oops! This will lead to a closure allocation at the beginning of the method! var task = InitializeMapIfNeededAsync(); // Optimizing for acommon case: no async machinery involved. if (task.IsCompleted) { return new ValueTask&lt;decimal&gt;(DoGetPriceFromCache(companyId)); } return DoGetStockPricesForAsync(); async ValueTask&lt;decimal&gt; DoGetStockPricesForAsync() { await task; return DoGetPriceFromCache(companyId); } }</span></span></code> </pre><br>  Leider generiert dieser Code aufgrund <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">eines Compilerfehlers</a> einen Abschluss, selbst wenn die Methode innerhalb des gemeinsamen Pfads ausgef√ºhrt wird.  So sieht diese Methode von innen aus: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Optimized</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> companyId</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> closure = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> __DisplayClass0_0() { __this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, companyId = companyId, task = InitializeMapIfNeededAsync() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (closure.task.IsCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ... } <span class="hljs-comment"><span class="hljs-comment">// The rest of the code }</span></span></code> </pre><br>  Wie im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zerlegen der lokalen Funktionen in C #</a> erl√§utert, verwendet der Compiler eine gemeinsame Abschlussinstanz f√ºr alle lokalen Variablen und Argumente in einem bestimmten Bereich.  Folglich macht eine solche Codegenerierung einen gewissen Sinn, aber es macht den ganzen Kampf mit der Zuweisung von Haufen nutzlos. <br><br>  <b>TIPP</b> .  Eine solche Optimierung ist eine sehr heimt√ºckische Sache.  Die Vorteile sind vernachl√§ssigbar, und selbst wenn Sie die <b>richtige</b> urspr√ºngliche lokale Funktion schreiben, k√∂nnen Sie versehentlich einen externen Status erhalten, der dazu f√ºhrt, dass der Heap zugewiesen wird.  Sie k√∂nnen weiterhin auf die Optimierung zur√ºckgreifen, wenn Sie mit einer h√§ufig verwendeten Bibliothek (z. B. BCL) in einer Methode arbeiten, die definitiv f√ºr einen geladenen Codeabschnitt verwendet wird. <br><br><h4>  Kosten f√ºr das Warten auf eine Aufgabe </h4><br>  Im Moment haben wir nur einen bestimmten Fall betrachtet: den Overhead einer asynchronen Methode, die synchron ausgef√ºhrt wird.  Dies geschieht absichtlich.  Je kleiner die asynchrone Methode ist, desto deutlicher sind die Kosten f√ºr die Gesamtleistung.  Detailliertere asynchrone Methoden werden in der Regel synchron ausgef√ºhrt und f√ºhren eine geringere Arbeitslast aus.  Und wir nennen sie normalerweise √∂fter. <br><br>  Wir m√ºssen uns jedoch der Kosten des asynchronen Mechanismus bewusst sein, wenn die Methode auf die Fertigstellung einer ausstehenden Aufgabe ‚Äûwartet‚Äú.  Um diese Kosten abzusch√§tzen, nehmen wir √Ñnderungen an <code>InitializeMapIfNeededAsync</code> und rufen <code>Task.Yield()</code> auch wenn der Cache initialisiert wird: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitializeMapIfNeededAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_stockPricesCache != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Yield(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// Old initialization logic }</span></span></code> </pre><br>  Wir f√ºgen unserem Benchmark-Paket die folgenden Methoden f√ºr Vergleichstests hinzu: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Benchmark</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceFor_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceFor(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceForAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); } [Benchmark] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetStockPriceWithValueTaskAsync_Await</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _stockPricesThatYield.GetStockPriceValueTaskForAsync(<span class="hljs-string"><span class="hljs-string">"MSFT"</span></span>).GetAwaiter().GetResult(); }</code> </pre><br><img src="https://habrastorage.org/webt/d9/hm/qt/d9hmqtsqod_pexw3xdmfprfww2m.png"><br><br>  Wie Sie sehen, ist der Unterschied sp√ºrbar - sowohl in Bezug auf die Geschwindigkeit als auch in Bezug auf die Speichernutzung.  Erkl√§ren Sie kurz die Ergebnisse. <br><br><ul><li>  Jede Warteoperation f√ºr eine nicht abgeschlossene Aufgabe dauert ungef√§hr 4 Mikrosekunden und weist jedem Aufruf fast 300 Bytes (**) zu.  Aus diesem Grund l√§uft GetStockPriceFor fast doppelt so schnell wie GetStockPriceForAsync und weist weniger Speicher zu. </li><li>  Eine auf ValueTask basierende asynchrone Methode dauert etwas l√§nger als die Variante mit Task, wenn diese Methode nicht synchron ausgef√ºhrt wird.  Eine Zustandsmaschine einer auf ValueTask &lt;T&gt; basierenden Methode sollte mehr Daten speichern als eine Zustandsmaschine einer auf Task &lt;T&gt; basierenden Methode. </li></ul><br>  <i>(**) Dies h√§ngt von der Plattform (x64 oder x86) und einer Reihe lokaler Variablen und Argumente der asynchronen Methode ab.</i> <br><br><h4>  Leistung asynchroner Methoden 101 </h4><br><ul><li>  Wenn die asynchrone Methode synchron ausgef√ºhrt wird, ist der Overhead ziemlich gering. </li><li>  Wenn die asynchrone Methode synchron ausgef√ºhrt wird, tritt der folgende Speicher-Overhead auf: F√ºr asynchrone Task-Methoden gibt es keinen Overhead, und f√ºr asynchrone Task &lt;T&gt; -Methoden betr√§gt der √úberlauf 88 Byte pro Operation (f√ºr x64-Plattformen). </li><li>  ValueTask &lt;T&gt; eliminiert den oben genannten Overhead f√ºr synchron ausgef√ºhrte asynchrone Methoden. </li><li>  Wenn eine auf ValueTask &lt;T&gt; basierende asynchrone Methode synchron ausgef√ºhrt wird, dauert es etwas k√ºrzer als die Methode mit Task &lt;T&gt;, andernfalls gibt es geringf√ºgige Unterschiede zugunsten der zweiten Option. </li><li>  Der Leistungsaufwand f√ºr asynchrone Methoden, die darauf warten, eine nicht abgeschlossene Aufgabe abzuschlie√üen, ist erheblich h√∂her (ungef√§hr 300 Byte pro Vorgang f√ºr x64-Plattformen). </li></ul><br>  Messungen sind nat√ºrlich unser Alles.  Wenn Sie feststellen, dass eine asynchrone Operation Leistungsprobleme verursacht, k√∂nnen Sie von <code>Task&lt;T&gt;</code> zu <code>ValueTask&lt;T&gt;</code> wechseln, die Task zwischenspeichern oder den gesamten Ausf√ºhrungspfad nach M√∂glichkeit synchronisieren.  Sie k√∂nnen auch versuchen, Ihre asynchronen Vorg√§nge zusammenzufassen.  Dies wird dazu beitragen, die Leistung zu verbessern, das Debuggen und die Code-Analyse im Allgemeinen zu vereinfachen.  <b>Nicht jeder kleine Code sollte asynchron sein.</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420627/">https://habr.com/ru/post/de420627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420615/index.html">JavaScript: Objekte erkunden</a></li>
<li><a href="../de420617/index.html">Webdesign-Handbuch f√ºr Entwickler</a></li>
<li><a href="../de420619/index.html">Responsive Images: CSS-Tricks, die Zeit sparen</a></li>
<li><a href="../de420623/index.html">Verteilte C ++ - Anwendungen mit minimalem Aufwand</a></li>
<li><a href="../de420625/index.html">KDD 2018, Erster Tag, Tutorials</a></li>
<li><a href="../de420629/index.html">PHP Digest Nr. 137 (6. - 20. August 2018)</a></li>
<li><a href="../de420631/index.html">Wir haben keine Angst vor "Wolken"</a></li>
<li><a href="../de420633/index.html">Schreiben eines GeoIP-Exporters f√ºr Prometheus mit Visualisierungen in Grafana in 15 Minuten</a></li>
<li><a href="../de420635/index.html">KI, praktischer Kurs. Das Grundmodell zum Erkennen von Emotionen in Bildern</a></li>
<li><a href="../de420637/index.html">WANHAO D9 / 300 3D-Drucker Test: Video</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>