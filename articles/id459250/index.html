<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“€ ğŸ˜„ ğŸµï¸ WAL di PostgreSQL: 2. Prerecord log ğŸ§  ğŸ‘Š ğŸŸ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terakhir kali, kami bertemu dengan perangkat dari salah satu objek penting dari memori bersama, cache buffer. Kemungkinan kehilangan informasi dari RA...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>WAL di PostgreSQL: 2. Prerecord log</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/459250/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Terakhir kali,</a> kami bertemu dengan perangkat dari salah satu objek penting dari memori bersama, cache buffer.  Kemungkinan kehilangan informasi dari RAM adalah alasan utama perlunya pemulihan dari kegagalan.  Hari ini kita akan berbicara tentang alat-alat ini. <br><br><h1>  Majalah </h1><br>  Sayangnya, mukjizat tidak terjadi: untuk bertahan dari hilangnya informasi dalam RAM, semua yang diperlukan harus ditulis ke disk (atau perangkat non-volatil lainnya) secara tepat waktu. <br><br>  Karena itu, inilah yang telah dilakukan.  Seiring dengan perubahan data, <em>jurnal</em> perubahan ini juga disimpan.  Saat kami mengubah sesuatu pada halaman di cache buffer, kami membuat catatan di log tentang perubahan ini.  Catatan berisi informasi minimum yang memadai sehingga, jika perlu, perubahan dapat diulang. <br><br>  Agar ini berfungsi, entri jurnal harus masuk ke disk <em>sebelum</em> halaman yang diubah sampai di sana.  Oleh karena itu namanya: log write-ahead. <br><br>  Jika kegagalan terjadi, data pada disk dalam keadaan tidak konsisten: beberapa halaman ditulis sebelumnya, beberapa nanti.  Tetapi masih ada jurnal yang dapat dibaca dan dilakukan kembali oleh operasi-operasi yang sudah selesai sebelum kegagalan, tetapi yang hasilnya tidak mencapai disk. <br><a name="habracut"></a><br><blockquote>  Mengapa tidak memaksa halaman data sendiri untuk ditulis ke disk, mengapa melakukan pekerjaan ganda?  Ternyata sangat efektif. <br>  Pertama-tama, log adalah aliran data berurutan untuk ditulis.  Bahkan HDD melakukan cukup baik dengan perekaman berurutan.  Tetapi catatan data itu sendiri adalah acak, karena halaman-halaman tersebut tersebar di disk kurang lebih secara acak. <br>  Kedua, entri jurnal bisa jauh lebih kecil dari satu halaman. <br>  Ketiga, saat merekam, Anda tidak perlu khawatir untuk memastikan bahwa data pada disk tetap konsisten pada setiap titik waktu yang sewenang-wenang (persyaratan ini sangat menyulitkan kehidupan). <br>  Dan keempat, seperti yang akan kita lihat nanti, jurnal (karena ada) dapat digunakan tidak hanya untuk pemulihan, tetapi juga untuk cadangan dan replikasi. <br></blockquote><br>  Anda harus mencatat semua operasi, di mana ada risiko ketidakkonsistenan pada disk jika terjadi kegagalan.  Secara khusus, tindakan berikut dicatat: <br><br><ul><li>  mengubah halaman dalam cache buffer (sebagai aturan, ini adalah tabel dan halaman indeks) - karena halaman yang diubah tidak langsung masuk ke disk; </li><li>  melakukan dan membatalkan transaksi - perubahan status terjadi di buffer XACT dan juga tidak segera mencapai disk; </li><li>  operasi file (membuat dan menghapus file dan direktori, misalnya, membuat file saat membuat tabel) - karena operasi ini harus terjadi secara bersamaan dengan perubahan data. </li></ul><br>  Tidak dicatat: <br><br><ul><li>  operasi dengan tabel non-jurnal (tidak dicatat) - namanya berbicara sendiri; </li><li>  operasi dengan tabel sementara - tidak masuk akal, karena masa hidup tabel tersebut tidak melebihi masa sesi yang membuatnya. </li></ul><br>  Sebelum PostgreSQL 10, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> tidak dicatat (mereka hanya melayani memetakan fungsi hash untuk tipe data yang berbeda), tetapi sekarang ini telah diperbaiki. <br><br><h1>  Perangkat logis </h1><br><img src="https://habrastorage.org/webt/vx/vj/67/vxvj673dzyqmhumlxby7i8wt5q0.png"><br><br>  Logikanya, jurnal dapat dianggap sebagai urutan catatan dari berbagai panjang.  Setiap catatan berisi <em>data</em> tentang operasi tertentu, didahului oleh <em>header</em> standar.  Judul, antara lain, menunjukkan: <br><br><ul><li>  Nomor transaksi tempat catatan itu berada. </li><li>  manajer sumber daya - komponen sistem yang bertanggung jawab untuk merekam; </li><li>  checksum (CRC) - memungkinkan Anda menentukan korupsi data; </li><li>  rekam panjang dan tautkan ke catatan sebelumnya. </li></ul><br>  Data itu sendiri memiliki format dan makna yang berbeda.  Misalnya, mereka dapat mewakili beberapa fragmen halaman yang perlu ditulis di atas kontennya dengan offset tertentu.  Manajer sumber daya yang ditentukan â€œmemahamiâ€ bagaimana menafsirkan data dalam catatannya.  Ada manajer terpisah untuk tabel, untuk setiap jenis indeks, untuk status transaksi, dll. Daftar lengkapnya dapat diperoleh jika diinginkan oleh perintah <br><br><pre><code class="plaintext hljs">pg_waldump -r list</code> </pre> <br><h1>  Perangkat fisik </h1><br>  Pada disk, log disimpan sebagai file di direktori $ PGDATA / pg_wal.  Setiap file default ke 16 MB.  Ukuran dapat ditingkatkan untuk menghindari sejumlah besar file dalam satu direktori.  Sebelum PostgreSQL 11, ini hanya bisa dilakukan ketika kompilasi kode sumber, tetapi sekarang Anda dapat menentukan ukuran saat menginisialisasi cluster ( <code>--wal-segsize</code> ). <br><br>  Entri log termasuk dalam file yang sedang digunakan;  ketika itu berakhir, yang berikutnya mulai digunakan. <br><br>  Buffer khusus dialokasikan untuk log di memori bersama server.  Ukuran cache jurnal ditetapkan oleh parameter <em>wal_buffers</em> (nilai default menyiratkan konfigurasi otomatis: 1/32 dari cache buffer dialokasikan). <br><br>  Cache jurnal disusun seperti cache buffer, tetapi ia bekerja terutama dalam mode ring buffer: entri ditambahkan ke "head" dan ditulis ke disk dari "tail". <br><br>  Posisi perekaman ("ekor") dan penyisipan ("kepala") menunjukkan fungsi masing-masing pg_current_wal_lsn dan pg_current_wal_insert lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331E4E64 | 0/331E4EA0 (1 row)</code> </pre><br>  Untuk merujuk ke catatan tertentu, tipe data pg_lsn (LSN = nomor urut log) digunakan - ini adalah nomor 64-bit yang mewakili offset byte sebelum menulis ke awal log.  LSN adalah output sebagai dua angka 32-bit dalam notasi heksadesimal. <br><br>  Anda dapat menemukan di file mana kita akan menemukan posisi yang diinginkan, dan dengan apa offset dari awal file: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> file_name, upper(to_hex(file_offset)) file_offset <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_walfile_name_offset(<span class="hljs-string"><span class="hljs-string">'0/331E4E64'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> file_name | file_offset --------------------------+------------- 000000010000000000000033 | 1E4E64 \ /\ /  0/331E4E64 </code> </pre><br>  Nama file terdiri dari dua bagian.  8 digit heksadesimal atas menunjukkan jumlah cabang waktu (digunakan ketika memulihkan dari cadangan), sisanya sesuai dengan digit LSN tertinggi (dan digit LSN yang lebih rendah lainnya menunjukkan offset). <br><br>  File log dapat dilihat pada sistem file dalam direktori $ PGDATA / pg_wal /, tetapi dimulai dengan PostgreSQL 10 mereka juga dapat dilihat dengan fungsi khusus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_ls_waldir() <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'000000010000000000000033'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> name | size | modification --------------------------+----------+------------------------ 000000010000000000000033 | 16777216 | 2019-07-08 20:24:13+03 (1 row)</code> </pre><br><h1>  Maju menulis </h1><br>  Mari kita lihat bagaimana jurnal terjadi dan bagaimana rekaman proaktif disediakan.  Buat tabel: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> wal(id <span class="hljs-type"><span class="hljs-type">integer</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  Kami akan melihat header dari halaman tabel.  Untuk melakukan ini, kita memerlukan ekstensi yang sudah akrab: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Mari kita mulai transaksi dan ingat posisi penyisipan dalam log: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F377C (1 row)</code> </pre><br>  Sekarang mari kita lakukan beberapa operasi, misalnya, perbarui baris: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> wal <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> id = id + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Perubahan ini dicatat dalam log, posisi penyisipan telah berubah: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37C4 (1 row)</code> </pre><br>  Untuk memastikan bahwa halaman data yang dimodifikasi tidak didorong ke disk sebelum entri jurnal, LSN dari entri jurnal terakhir yang terkait dengan halaman ini disimpan di header halaman: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lsn <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lsn ------------ 0/331F37C4 (1 row)</code> </pre><br>  Ingatlah bahwa jurnal itu umum untuk seluruh kluster, dan entri baru masuk ke dalamnya setiap saat.  Oleh karena itu, LSN pada halaman mungkin kurang dari nilai yang baru saja dikembalikan fungsi pg_current_wal_insert_lsn.  Tapi tidak ada yang terjadi di sistem kami, jadi angkanya sama. <br><br>  Sekarang selesaikan transaksi. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Catatan komit juga masuk ke log, dan posisinya berubah lagi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_insert_lsn --------------------------- 0/331F37E8 (1 row)</code> </pre><br>  Komit mengubah status transaksi dalam struktur yang disebut XACT (kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sudah membicarakannya</a> ).  Status disimpan dalam file, tetapi mereka juga menggunakan cache mereka sendiri, yang menempati 128 halaman dalam memori bersama.  Oleh karena itu, untuk halaman XACT, LSN dari entri jurnal terakhir harus dilacak.  Tetapi informasi ini tidak disimpan di halaman itu sendiri, tetapi di RAM. <br><br>  Pada titik tertentu, entri jurnal yang dibuat akan ditulis ke disk.  Di mana - kita akan berbicara lain waktu, tetapi dalam kasus kami ini sudah terjadi: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_current_wal_lsn(), pg_current_wal_insert_lsn();</code> </pre><pre> <code class="plaintext hljs"> pg_current_wal_lsn | pg_current_wal_insert_lsn --------------------+--------------------------- 0/331F37E8 | 0/331F37E8 (1 row)</code> </pre><br>  Setelah titik ini, data dan halaman XACT dapat didorong keluar dari cache.  Tetapi jika diminta untuk memaksa mereka keluar lebih awal, itu akan terdeteksi dan entri jurnal akan direkam secara paksa terlebih dahulu. <br><br>  Mengetahui dua posisi LSN, Anda bisa mendapatkan ukuran entri jurnal di antara mereka (dalam byte) dengan hanya mengurangi satu posisi dari yang lain.  Anda hanya perlu memberikan posisi ke tipe pg_lsn: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'0/331F37E8'</span></span>::pg_lsn - <span class="hljs-string"><span class="hljs-string">'0/331F377C'</span></span>::pg_lsn;</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- 108 (1 row)</code> </pre><br>  Dalam hal ini, pembaruan baris dan komit diperlukan 108 byte dalam log. <br><br>  Dengan cara yang sama, Anda dapat memperkirakan berapa banyak entri jurnal yang dihasilkan oleh server per unit waktu pada beban tertentu.  Ini adalah informasi penting yang akan diperlukan selama pengaturan (yang akan kita bicarakan lain kali). <br><br>  Sekarang kita akan menggunakan utilitas pg_waldump untuk melihat entri log yang dibuat. <br><br>  Utilitas dapat bekerja dengan rentang LSN (seperti dalam contoh ini) dan memilih catatan untuk transaksi yang ditentukan.  Itu harus dijalankan atas nama pengguna OS postgres, karena dia membutuhkan akses ke file log pada disk. <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_waldump -p /var/lib/postgresql/11/main/pg_wal -s 0/331F377C -e 0/331F37E8 000000010000000000000033</code> </pre><pre> <code class="plaintext hljs">rmgr: Heap len (rec/tot): 69/ 69, tx: 101085, lsn: 0/331F377C, prev 0/331F3014, desc: HOT_UPDATE off 1 xmax 101085 ; new off 2 xmax 0, blkref #0: rel 1663/16386/33081 blk 0</code> </pre><pre> <code class="plaintext hljs">rmgr: Transaction len (rec/tot): 34/ 34, tx: 101085, lsn: 0/331F37C4, prev 0/331F377C, desc: COMMIT 2019-07-08 20:24:13.945435 MSK</code> </pre><br>  Di sini kita melihat tajuk dari dua entri. <br><br>  Yang pertama adalah operasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HOT_UPDATE</a> , terkait dengan manajer sumber daya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan</a> .  Nama file dan nomor halaman ditunjukkan dalam bidang blkref dan cocok dengan halaman tabel yang diperbarui: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'wal'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/16386/33081 (1 row)</code> </pre><br>  Entri kedua adalah COMMIT, terkait dengan Manajer Sumber Daya Transaksi. <br><br>  Bukan format yang paling mudah dibaca, tetapi Anda bisa mengetahuinya jika perlu. <br><br><h1>  Pemulihan </h1><br>  Ketika kita memulai server, proses postmaster dimulai terlebih dahulu, dan pada gilirannya, memulai proses startup, tugasnya adalah memastikan pemulihan jika terjadi kegagalan. <br><br>  Untuk menentukan apakah pemulihan diperlukan, startup melihat ke file kontrol khusus $ PGDATA / global / pg_control dan melihat status cluster.  Kami dapat memeriksa status kami sendiri menggunakan utilitas pg_controldata: <br><br><pre> <code class="plaintext hljs">postgres$ /usr/lib/postgresql/11/bin/pg_controldata -D /var/lib/postgresql/11/main | grep state</code> </pre><pre> <code class="plaintext hljs">Database cluster state: in production</code> </pre><br>  Server yang berhenti dengan rapi akan memiliki status "shut down".  Jika server tidak berfungsi, dan statusnya tetap "dalam produksi", ini berarti bahwa DBMS telah turun dan kemudian pemulihan akan dilakukan secara otomatis. <br><br>  Untuk pemulihan, proses startup akan secara berurutan membaca log dan menerapkan entri ke halaman, jika perlu.  Anda dapat memverifikasi kebutuhan dengan membandingkan LSN halaman pada disk dengan LSN dari entri jurnal.  Jika LSN halaman lebih besar, maka catatan tidak perlu.  Tetapi pada kenyataannya - itu bahkan tidak mungkin, karena catatan dirancang untuk aplikasi yang sangat konsisten. <br><br><blockquote>  Ada beberapa pengecualian.  Beberapa catatan dibentuk sebagai gambar halaman penuh (FPI, gambar halaman penuh), dan jelas bahwa gambar seperti itu dapat diterapkan ke halaman dalam keadaan apa pun - itu masih akan menghapus semua yang ada di sana.  Perubahan lain dalam status transaksi dapat diterapkan ke versi halaman XACT mana pun - oleh karena itu, di dalam halaman tersebut tidak perlu menyimpan LSN. <br></blockquote><br>  Mengubah halaman selama pemulihan terjadi dalam cache buffer, seperti pada saat kerja normal - untuk postmaster ini memulai proses latar belakang yang diperlukan. <br><br>  Demikian pula, entri jurnal berlaku untuk file: misalnya, jika catatan mengatakan bahwa file tersebut harus ada, tetapi tidak ada, file dibuat. <br><br>  Nah, pada akhir proses pemulihan, semua tabel non-jurnal ditimpa dengan "boneka" dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lapisan init</a> mereka. <br><br>  Ini adalah presentasi algoritma yang sangat sederhana.  Secara khusus, kami belum mengatakan apa pun tentang di mana harus mulai membaca entri jurnal (percakapan ini harus ditunda sampai pos pemeriksaan dipertimbangkan). <br><br>  Dan klarifikasi terakhir.  Proses pemulihan "klasik" terdiri dari dua fase.  Pada fase pertama (roll forward), entri jurnal digulung, dan server mengulangi semua pekerjaan yang hilang selama kegagalan.  Pada yang kedua (roll back), transaksi yang tidak dilakukan pada saat kegagalan dibatalkan.  Tetapi PostgreSQL tidak membutuhkan fase kedua.  Seperti yang kita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahas sebelumnya</a> , karena kekhasan pelaksanaan transaksi multi-versi tidak perlu digulirkan kembali secara fisik;  sudah cukup bahwa bit perbaikan tidak akan diatur dalam XACT. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Untuk dilanjutkan</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459250/">https://habr.com/ru/post/id459250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459240/index.html">10 tahun di IT yang didiagnosis menderita skizofrenia, kiat bertahan hidup</a></li>
<li><a href="../id459242/index.html">Mengikuti konferensi T + Conf 2019</a></li>
<li><a href="../id459244/index.html">Catatan manajer produk: perilaku pengguna pada halaman game di app store. Berapa lama untuk mengunduh game</a></li>
<li><a href="../id459246/index.html">Mengapa konversi situs menurun? Contoh 60 desain dan kesalahan penggunaan</a></li>
<li><a href="../id459248/index.html">Acara digital di Moskow dari 09 Juli hingga 14 Juli</a></li>
<li><a href="../id459252/index.html">Minggu Keamanan 28: meretas rumah pintar</a></li>
<li><a href="../id459254/index.html">Bom pos yang lebih baik</a></li>
<li><a href="../id459256/index.html">Bagaimana kami mengoptimalkan Rumah Sakit Tema kami untuk platform yang berbeda</a></li>
<li><a href="../id459258/index.html">14.000 mil tidak terhubung</a></li>
<li><a href="../id459262/index.html">Pensiun pada 22</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>