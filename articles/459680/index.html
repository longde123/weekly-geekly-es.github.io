<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏿 🖕🏽 👹 Después de Highload ++ Siberia 2019 - 8 tareas de Oracle 👩🏿‍🤝‍👨🏻 🍡 👩🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola 

 Del 24 al 25 de junio, se celebró la conferencia Highload ++ Siberia 2019 en Novosibirsk. Nuestros muchachos también estuvieron allí en el inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Después de Highload ++ Siberia 2019 - 8 tareas de Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/459680/">  Hola <br><br>  Del 24 al 25 de junio, se celebró la conferencia Highload ++ Siberia 2019 en Novosibirsk. Nuestros muchachos también estuvieron allí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el informe</a> "Bases de contenedores de Oracle (CDB / PDB) y su uso práctico para el desarrollo de software", publicaremos una versión de texto un poco más tarde.  Fue genial, gracias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">olegbunin</a> por organizar, así como a todos los que vinieron. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-7/k4/u1/-7k4u1btcjxquu515qeoyxnxigu.jpeg" width="350"></div><br>  En esta publicación, nos gustaría compartir con usted las tareas que estaban en nuestro stand para que pueda probar sus conocimientos en Oracle.  Bajo el corte: 8 tareas, opciones de respuesta y explicación. <br><a name="habracut"></a><br><h3>  ¿Cuál es el valor máximo de la secuencia que veremos como resultado del siguiente script? </h3><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.currval, s.nextval, s.currval, s.nextval, s.currval <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><ul><li>  1 </li><li>  5 5 </li><li>  10 </li><li>  25 </li><li>  No, habrá un error. </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentación de Oracle (citado en 8.1.6): <br>  Dentro de una sola instrucción SQL, Oracle incrementará la secuencia solo una vez por fila.  Si una declaración contiene más de una referencia a NEXTVAL para una secuencia, Oracle incrementa la secuencia una vez y devuelve el mismo valor para todas las ocurrencias de NEXTVAL.  Si una declaración contiene referencias a CURRVAL y NEXTVAL, Oracle incrementa la secuencia y devuelve el mismo valor para CURRVAL y NEXTVAL, independientemente de su orden dentro de la declaración. <br><br>  Por lo tanto, el <b>valor máximo corresponderá al número de filas, es decir, 5</b> . <br></div></div><br><h3>  ¿Cuántas filas habrá en la tabla como resultado del siguiente script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> p(p_from <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, p_to <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p_from .. p_to <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / exec p(1, 3); exec p(4, 6); exec p(7, 9);</code> </pre> <br><ul><li>  0 0 </li><li>  3 </li><li>  4 4 </li><li>  5 5 </li><li>  6 6 </li><li>  9 9 </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentación de Oracle (citada en 11.2): <br><br>  Antes de ejecutar cualquier instrucción SQL, Oracle marca un punto de rescate implícito (no disponible para usted).  Luego, si la declaración falla, Oracle la revierte automáticamente y devuelve el código de error aplicable a SQLCODE en el SQLCA.  Por ejemplo, si una instrucción INSERT provoca un error al intentar insertar un valor duplicado en un índice único, la instrucción se revierte. <br><br>  Una llamada del cliente también se considera y procesa como una sola declaración.  Por lo tanto, la primera llamada a HP se completa con éxito al insertar tres registros;  la segunda llamada a HP finaliza con un error y revierte el cuarto registro, que logré insertar;  la tercera llamada falla <b>y aparecen tres entradas en la tabla</b> . <br></div></div><br><h3>  ¿Cuántas filas habrá en la tabla como resultado del siguiente script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> i_ch <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>); exception when others then dbms_output.put_line('Oops!'); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; /</code> </pre> <br><ul><li>  1 </li><li>  2 </li><li>  3 </li><li>  4 4 </li><li>  5 5 </li><li>  6 6 </li><li>  7 7 </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentación de Oracle (citada en 11.2): <br><br>  Una restricción de verificación le permite especificar una condición que cada fila de la tabla debe cumplir.  Para satisfacer la restricción, cada fila de la tabla debe hacer que la condición sea VERDADERA o desconocida (debido a un valor nulo).  Cuando Oracle evalúa una condición de restricción de verificación para una fila en particular, cualquier nombre de columna en la condición se refiere a los valores de la columna en esa fila. <br><br>  Por lo tanto, el valor nulo pasará la prueba y el bloque anónimo se ejecutará con éxito hasta que se intente insertar el valor 3. Después de esto, el bloque de procesamiento de errores arrojará la excepción, no se producirá la reversión y <b>la tabla tendrá cuatro filas</b> con los valores 1, nulo, 2 y nulo nuevamente. <br></div></div><br><h3>  ¿Qué pares de valores ocuparán la misma cantidad de espacio en el bloque? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), i <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), j <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">14</span></span>), k <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>), x varchar2(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), y varchar2(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), z varchar2(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t (a, b, i, j, x, y) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br><ul><li>  A y X </li><li>  B e Y </li><li>  C y K </li><li>  C y Z </li><li>  K y Z </li><li>  Yo y j </li><li>  J y X </li><li>  Todos enumerados </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  Aquí hay extractos de la documentación (12.1.0.2) para almacenar varios tipos de datos en Oracle. <br><br>  <b>Tipo de datos Char</b> <br>  El tipo de datos CHAR especifica una cadena de caracteres de longitud fija en el conjunto de caracteres de la base de datos.  Usted especifica el juego de caracteres de la base de datos cuando crea su base de datos.  Oracle garantiza que todos los valores almacenados en una columna CHAR tengan la longitud especificada por tamaño en la semántica de longitud seleccionada.  Si inserta un valor que es más corto que la longitud de la columna, Oracle vacía el valor a la longitud de la columna. <br><br>  <b>Tipo de datos VARCHAR2</b> <br>  El tipo de datos VARCHAR2 especifica una cadena de caracteres de longitud variable en el juego de caracteres de la base de datos.  Usted especifica el juego de caracteres de la base de datos cuando crea su base de datos.  Oracle almacena un valor de carácter en una columna VARCHAR2 exactamente como lo especifica, sin ningún espacio en blanco, siempre que el valor no exceda la longitud de la columna. <br><br>  <b>NÚMERO Tipo de datos</b> <br>  El tipo de datos NUMBER almacena números fijos cero y positivos con valores absolutos desde 1.0 x 10-130 hasta 1.0 x 10126, pero sin incluirlos. Si especifica una expresión aritmética cuyo valor tiene un valor absoluto mayor o igual a 1.0 x 10126, luego Oracle devuelve un error.  Cada valor NUMBER requiere de 1 a 22 bytes.  Teniendo esto en cuenta, el tamaño de la columna en bytes para un valor de datos numéricos particular NÚMERO (p), donde p es la precisión de un valor dado, se puede calcular utilizando la siguiente fórmula: <i>REDONDEAR ((longitud (p) + s) / 2)) + 1</i> donde s es igual a cero si el número es positivo, y s es igual a 1 si el número es negativo. <br><br>  Además, tomamos un extracto de la documentación sobre el almacenamiento de valores nulos. <br><br>  Un nulo es la ausencia de un valor en una columna.  Los valores nulos indican datos faltantes, desconocidos o inaplicables.  Los nulos se almacenan en la base de datos si caen entre columnas con valores de datos.  En estos casos, requieren 1 byte para almacenar la longitud de la columna (cero).  Los nulos finales en una fila no requieren almacenamiento porque un nuevo encabezado de fila indica que las columnas restantes en la fila anterior son nulas.  Por ejemplo, si las últimas tres columnas de una tabla son nulas, no se almacenan datos para estas columnas. <br><br>  En base a estos datos, construimos razonamiento.  Creemos que la base de datos utiliza la codificación AL32UTF8.  En esta codificación, las letras rusas ocuparán 2 bytes. <br><br>  1) A y X, el valor del campo a 'Y' es 1 byte, el valor del campo x 'D' es 2 bytes <br>  2) B e Y, 'Vasya' en el valor b se complementará con espacios de hasta 10 caracteres y ocupará 14 bytes, 'Vasya' en d - tomará 8 bytes. <br>  3) C y K. Ambos campos son NULL, después de ellos hay campos significativos, por lo que ocupan 1 byte. <br>  4) C y Z. Ambos campos son NULL, pero el campo Z es el último en la tabla, por lo que no ocupa espacio (0 bytes).  El campo C ocupa 1 byte. <br>  5) K y Z. Similar al caso anterior.  El valor en el campo K es 1 byte, en Z - 0. <br>  6) I y J. Según la documentación, ambos valores tomarán 2 bytes cada uno.  Consideramos la longitud de acuerdo con la fórmula tomada de la documentación: round ((1 + 0) / 2) +1 = 1 + 1 = 2. <br>  7) J y X. El valor en el campo J tomará 2 bytes, el valor en el campo X tomará 2 bytes. <br><br>  <b>En total, las opciones correctas son: C y K, I y J, J y X.</b> <br></div></div><br><br><h3>  ¿Cuál será aproximadamente el factor de agrupación del índice T_I? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t (i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(i);</code> </pre><br><ul><li>  Sobre docenas </li><li>  Sobre cientos </li><li>  Del orden de miles </li><li>  Del orden de decenas de miles </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentación de Oracle (citada en 12.1): <br><br>  Para un índice de árbol B, el factor de agrupación de índice mide la agrupación física de filas en relación con un valor de índice. <br><br>  El factor de agrupación de índice ayuda al optimizador a decidir si una exploración de índice o una exploración de tabla completa es más eficiente para ciertas consultas).  Un factor de agrupación bajo indica un escaneo de índice eficiente. <br><br>  Un factor de agrupación cercano al número de bloques en una tabla indica que las filas están físicamente ordenadas en los bloques de la tabla por la clave de índice.  Si la base de datos realiza un escaneo completo de la tabla, la base de datos tiende a recuperar las filas a medida que se almacenan en el disco ordenado por la clave de índice.  Un factor de agrupación cercano al número de filas indica que las filas están dispersas aleatoriamente entre los bloques de la base de datos en relación con la clave de índice.  Si la base de datos realiza una exploración completa de la tabla, entonces la base de datos no recuperaría filas en ningún orden ordenado por esta clave de índice. <br><br>  En este caso, los datos se ordenan idealmente, por lo que el factor de agrupación será igual o cercano al número de bloques ocupados en la tabla.  Para un tamaño de bloque estándar de 8 kilobytes, puede esperar que alrededor de mil valores de números estrechos quepan en un bloque, por lo que el número de bloques, y como resultado el factor de agrupación, será del <b>orden de las decenas</b> . <br></div></div><br><h3>  ¿A qué valores de N se ejecutará con éxito el siguiente script en una base de datos normal con configuración estándar? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), d varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t (a, b, c, d);</code> </pre><br><ul><li>  100 </li><li>  200 </li><li>  400 </li><li>  800 </li><li>  1600 </li><li>  3200 </li><li>  6400 </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentación de Oracle (citada en 11.2): <br><br>  Límites lógicos de la base de datos. <br><br><div class="scrollable-table"><table><thead><tr><td>  <strong>Artículo</strong> </td><td>  <strong>Tipo de límite</strong> </td><td>  <strong>Valor límite</strong> </td></tr></thead><tbody><tr><td>  Índices </td><td>  Tamaño total de columna indexada </td><td>  75% del tamaño del bloque de la base de datos menos algunos gastos generales </td></tr></tbody></table></div><br>  Por lo tanto, el tamaño total de las columnas indexadas no debe exceder los 6Kb.  Además depende de la base de codificación seleccionada.  Para la codificación AL32UTF8, un carácter puede ocupar un máximo de 4 bytes, por lo que, en el peor de los casos, 6 kilobytes caben aproximadamente 1.500 caracteres.  Por lo tanto, Oracle prohibirá la creación de un índice en N = 400 (cuando la longitud de la clave en el peor de los casos es 1600 caracteres * 4 bytes + longitud de fila), mientras que <b>en N = 200 (o menos) la</b> creación del índice funcionará sin problemas. <br></div></div><br><h3>  La instrucción INSERT con la sugerencia APPEND está diseñada para cargar datos en modo directo.  ¿Qué sucede si se aplica a la tabla en la que se cuelga el gatillo? </h3><br><ul><li>  Los datos se cargarán en modo directo, el disparador funcionará como debería </li><li>  Los datos se cargarán en modo directo, pero el disparador no se ejecutará. </li><li>  Los datos se cargarán en modo convencional, el disparador funcionará como debería </li><li>  Los datos se cargarán en modo convencional, pero el disparador no se ejecutará </li><li>  Los datos no se cargarán, se solucionará el error </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  En principio, esto es más una cuestión de lógica.  Para encontrar la respuesta correcta, sugeriría el siguiente modelo de razonamiento: <br><br><ol><li>  La inserción en modo directo se realiza mediante la formación directa de un bloque de datos, más allá del motor SQL, que garantiza una alta velocidad.  Por lo tanto, garantizar la ejecución del disparador es muy difícil, si es posible, y no tiene sentido, ya que de todos modos ralentizará drásticamente la inserción. </li><li>  Si no se dispara, el hecho de que, con los mismos datos en la tabla, el estado de la base de datos en su conjunto (de otras tablas) dependerá del modo en que se inserten los datos.  Obviamente, esto destruirá la integridad de los datos y no se puede aplicar como solución en la producción. </li><li>  La imposibilidad de realizar la operación solicitada, en general, se trata como un error.  Pero aquí debe recordarse que APPEND es una pista, y la lógica general de las pistas es que se tienen en cuenta si es posible, si no, el operador se ejecuta sin tener en cuenta la pista. </li></ol><br>  Por lo tanto, la respuesta esperada es que los <b>datos se cargarán en modo normal (SQL), el disparador se disparará.</b> <br><br>  De acuerdo con la documentación de Oracle (citado desde 8.04): <br><br>  Las violaciones de las restricciones harán que la declaración se ejecute en serie, utilizando la ruta de inserción convencional, sin advertencias ni mensajes de error.  Una excepción es la restricción en las declaraciones que acceden a la misma tabla más de una vez en una transacción, lo que puede causar mensajes de error. <br>  Por ejemplo, si los desencadenantes o la integridad referencial están presentes en la tabla, la sugerencia APPEND se ignorará cuando intente utilizar INSERT de carga directa (serie o paralelo), así como la sugerencia o cláusula PARALLEL, si corresponde. </div></div><br><h3>  ¿Qué sucede al ejecutar el siguiente script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, j <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> t); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> t_a_i <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pragma</span></span> autonomous_transaction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (:new.i + <span class="hljs-number"><span class="hljs-number">1</span></span>, :new.i); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><ul><li>  Ejecución exitosa </li><li>  Error de sintaxis fallido </li><li>  Error de transacción fuera de línea no válido </li><li>  Error relacionado con exceder el anidamiento máximo de llamadas </li><li>  Error de violación de clave externa </li><li>  Error de bloqueo </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  La tabla y el desencadenador se crean correctamente y esta operación no debería generar problemas.  Las transacciones autónomas en el activador también están permitidas, de lo contrario sería imposible, por ejemplo, el registro. <br><br>  Después de insertar la primera línea, un activador exitoso conduciría a la inserción de la segunda línea, en relación con la cual el activador funcionaría nuevamente, inserte la tercera línea, y así sucesivamente hasta que la instrucción caiga debido a que excede el máximo de anidamiento de llamadas.  Sin embargo, se desencadena otro punto sutil.  En el momento en que se ejecuta el desencadenador, la confirmación aún no se ejecuta para el primer registro insertado.  Por lo tanto, un desencadenador que funciona en una transacción autónoma intenta insertar una fila en la tabla que hace referencia mediante una clave externa a un registro que aún no se ha confirmado.  Esto lleva a una espera (una transacción autónoma está esperando que el compromiso principal comprenda si es posible insertar datos) y, al mismo tiempo, la transacción principal está esperando que el compromiso autónomo continúe funcionando después del desencadenante.  <b>Se produce un punto muerto y, como resultado, se devuelve una transacción autónoma por el motivo asociado con los bloqueos</b> . <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459680/">https://habr.com/ru/post/459680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459662/index.html">PVS-Studio quería, pero no pudo encontrar errores en robots.txt</a></li>
<li><a href="../459668/index.html">Cómo reconocer el texto de una foto: nuevas características del marco Vision</a></li>
<li><a href="../459670/index.html">Ir a amsterdam</a></li>
<li><a href="../459672/index.html">Subrayar en Python</a></li>
<li><a href="../459674/index.html">Inteligencia de amenazas Epic Saga</a></li>
<li><a href="../459682/index.html">Calidad de datos en almacenamiento</a></li>
<li><a href="../459684/index.html">Mapa del metro de Moscú y el mundo entero para Android</a></li>
<li><a href="../459688/index.html">Urbanismo en China: menos inconformistas, más ciencia e informática</a></li>
<li><a href="../459692/index.html">Cómo descubrimos modificaciones materiales que contradicen los principios químicos establecidos</a></li>
<li><a href="../459694/index.html">Datos del museo Art. Desembale y lance Radio 86RK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>