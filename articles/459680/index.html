<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë®üèø üñïüèΩ üëπ Despu√©s de Highload ++ Siberia 2019 - 8 tareas de Oracle üë©üèø‚Äçü§ù‚Äçüë®üèª üç° üë©üèª‚Äçüíª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola 

 Del 24 al 25 de junio, se celebr√≥ la conferencia Highload ++ Siberia 2019 en Novosibirsk. Nuestros muchachos tambi√©n estuvieron all√≠ en el inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Despu√©s de Highload ++ Siberia 2019 - 8 tareas de Oracle</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sportmaster_lab/blog/459680/">  Hola <br><br>  Del 24 al 25 de junio, se celebr√≥ la conferencia Highload ++ Siberia 2019 en Novosibirsk. Nuestros muchachos tambi√©n estuvieron all√≠ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el informe</a> "Bases de contenedores de Oracle (CDB / PDB) y su uso pr√°ctico para el desarrollo de software", publicaremos una versi√≥n de texto un poco m√°s tarde.  Fue genial, gracias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">olegbunin</a> por organizar, as√≠ como a todos los que vinieron. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-7/k4/u1/-7k4u1btcjxquu515qeoyxnxigu.jpeg" width="350"></div><br>  En esta publicaci√≥n, nos gustar√≠a compartir con usted las tareas que estaban en nuestro stand para que pueda probar sus conocimientos en Oracle.  Bajo el corte: 8 tareas, opciones de respuesta y explicaci√≥n. <br><a name="habracut"></a><br><h3>  ¬øCu√°l es el valor m√°ximo de la secuencia que veremos como resultado del siguiente script? </h3><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sequence</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> s.currval, s.nextval, s.currval, s.nextval, s.currval <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><ul><li>  1 </li><li>  5 5 </li><li>  10 </li><li>  25 </li><li>  No, habr√° un error. </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentaci√≥n de Oracle (citado en 8.1.6): <br>  Dentro de una sola instrucci√≥n SQL, Oracle incrementar√° la secuencia solo una vez por fila.  Si una declaraci√≥n contiene m√°s de una referencia a NEXTVAL para una secuencia, Oracle incrementa la secuencia una vez y devuelve el mismo valor para todas las ocurrencias de NEXTVAL.  Si una declaraci√≥n contiene referencias a CURRVAL y NEXTVAL, Oracle incrementa la secuencia y devuelve el mismo valor para CURRVAL y NEXTVAL, independientemente de su orden dentro de la declaraci√≥n. <br><br>  Por lo tanto, el <b>valor m√°ximo corresponder√° al n√∫mero de filas, es decir, 5</b> . <br></div></div><br><h3>  ¬øCu√°ntas filas habr√° en la tabla como resultado del siguiente script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> p(p_from <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, p_to <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> p_from .. p_to <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (i); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / exec p(1, 3); exec p(4, 6); exec p(7, 9);</code> </pre> <br><ul><li>  0 0 </li><li>  3 </li><li>  4 4 </li><li>  5 5 </li><li>  6 6 </li><li>  9 9 </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentaci√≥n de Oracle (citada en 11.2): <br><br>  Antes de ejecutar cualquier instrucci√≥n SQL, Oracle marca un punto de rescate impl√≠cito (no disponible para usted).  Luego, si la declaraci√≥n falla, Oracle la revierte autom√°ticamente y devuelve el c√≥digo de error aplicable a SQLCODE en el SQLCA.  Por ejemplo, si una instrucci√≥n INSERT provoca un error al intentar insertar un valor duplicado en un √≠ndice √∫nico, la instrucci√≥n se revierte. <br><br>  Una llamada del cliente tambi√©n se considera y procesa como una sola declaraci√≥n.  Por lo tanto, la primera llamada a HP se completa con √©xito al insertar tres registros;  la segunda llamada a HP finaliza con un error y revierte el cuarto registro, que logr√© insertar;  la tercera llamada falla <b>y aparecen tres entradas en la tabla</b> . <br></div></div><br><h3>  ¬øCu√°ntas filas habr√° en la tabla como resultado del siguiente script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> i_ch <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> (i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">5</span></span>); exception when others then dbms_output.put_line('Oops!'); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; /</code> </pre> <br><ul><li>  1 </li><li>  2 </li><li>  3 </li><li>  4 4 </li><li>  5 5 </li><li>  6 6 </li><li>  7 7 </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentaci√≥n de Oracle (citada en 11.2): <br><br>  Una restricci√≥n de verificaci√≥n le permite especificar una condici√≥n que cada fila de la tabla debe cumplir.  Para satisfacer la restricci√≥n, cada fila de la tabla debe hacer que la condici√≥n sea VERDADERA o desconocida (debido a un valor nulo).  Cuando Oracle eval√∫a una condici√≥n de restricci√≥n de verificaci√≥n para una fila en particular, cualquier nombre de columna en la condici√≥n se refiere a los valores de la columna en esa fila. <br><br>  Por lo tanto, el valor nulo pasar√° la prueba y el bloque an√≥nimo se ejecutar√° con √©xito hasta que se intente insertar el valor 3. Despu√©s de esto, el bloque de procesamiento de errores arrojar√° la excepci√≥n, no se producir√° la reversi√≥n y <b>la tabla tendr√° cuatro filas</b> con los valores 1, nulo, 2 y nulo nuevamente. <br></div></div><br><h3>  ¬øQu√© pares de valores ocupar√°n la misma cantidad de espacio en el bloque? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), i <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>), j <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">14</span></span>), k <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>(<span class="hljs-number"><span class="hljs-number">24</span></span>), x varchar2(<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), y varchar2(<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), z varchar2(<span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t (a, b, i, j, x, y) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Y'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>);</code> </pre><br><ul><li>  A y X </li><li>  B e Y </li><li>  C y K </li><li>  C y Z </li><li>  K y Z </li><li>  Yo y j </li><li>  J y X </li><li>  Todos enumerados </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  Aqu√≠ hay extractos de la documentaci√≥n (12.1.0.2) para almacenar varios tipos de datos en Oracle. <br><br>  <b>Tipo de datos Char</b> <br>  El tipo de datos CHAR especifica una cadena de caracteres de longitud fija en el conjunto de caracteres de la base de datos.  Usted especifica el juego de caracteres de la base de datos cuando crea su base de datos.  Oracle garantiza que todos los valores almacenados en una columna CHAR tengan la longitud especificada por tama√±o en la sem√°ntica de longitud seleccionada.  Si inserta un valor que es m√°s corto que la longitud de la columna, Oracle vac√≠a el valor a la longitud de la columna. <br><br>  <b>Tipo de datos VARCHAR2</b> <br>  El tipo de datos VARCHAR2 especifica una cadena de caracteres de longitud variable en el juego de caracteres de la base de datos.  Usted especifica el juego de caracteres de la base de datos cuando crea su base de datos.  Oracle almacena un valor de car√°cter en una columna VARCHAR2 exactamente como lo especifica, sin ning√∫n espacio en blanco, siempre que el valor no exceda la longitud de la columna. <br><br>  <b>N√öMERO Tipo de datos</b> <br>  El tipo de datos NUMBER almacena n√∫meros fijos cero y positivos con valores absolutos desde 1.0 x 10-130 hasta 1.0 x 10126, pero sin incluirlos. Si especifica una expresi√≥n aritm√©tica cuyo valor tiene un valor absoluto mayor o igual a 1.0 x 10126, luego Oracle devuelve un error.  Cada valor NUMBER requiere de 1 a 22 bytes.  Teniendo esto en cuenta, el tama√±o de la columna en bytes para un valor de datos num√©ricos particular N√öMERO (p), donde p es la precisi√≥n de un valor dado, se puede calcular utilizando la siguiente f√≥rmula: <i>REDONDEAR ((longitud (p) + s) / 2)) + 1</i> donde s es igual a cero si el n√∫mero es positivo, y s es igual a 1 si el n√∫mero es negativo. <br><br>  Adem√°s, tomamos un extracto de la documentaci√≥n sobre el almacenamiento de valores nulos. <br><br>  Un nulo es la ausencia de un valor en una columna.  Los valores nulos indican datos faltantes, desconocidos o inaplicables.  Los nulos se almacenan en la base de datos si caen entre columnas con valores de datos.  En estos casos, requieren 1 byte para almacenar la longitud de la columna (cero).  Los nulos finales en una fila no requieren almacenamiento porque un nuevo encabezado de fila indica que las columnas restantes en la fila anterior son nulas.  Por ejemplo, si las √∫ltimas tres columnas de una tabla son nulas, no se almacenan datos para estas columnas. <br><br>  En base a estos datos, construimos razonamiento.  Creemos que la base de datos utiliza la codificaci√≥n AL32UTF8.  En esta codificaci√≥n, las letras rusas ocupar√°n 2 bytes. <br><br>  1) A y X, el valor del campo a 'Y' es 1 byte, el valor del campo x 'D' es 2 bytes <br>  2) B e Y, 'Vasya' en el valor b se complementar√° con espacios de hasta 10 caracteres y ocupar√° 14 bytes, 'Vasya' en d - tomar√° 8 bytes. <br>  3) C y K. Ambos campos son NULL, despu√©s de ellos hay campos significativos, por lo que ocupan 1 byte. <br>  4) C y Z. Ambos campos son NULL, pero el campo Z es el √∫ltimo en la tabla, por lo que no ocupa espacio (0 bytes).  El campo C ocupa 1 byte. <br>  5) K y Z. Similar al caso anterior.  El valor en el campo K es 1 byte, en Z - 0. <br>  6) I y J. Seg√∫n la documentaci√≥n, ambos valores tomar√°n 2 bytes cada uno.  Consideramos la longitud de acuerdo con la f√≥rmula tomada de la documentaci√≥n: round ((1 + 0) / 2) +1 = 1 + 1 = 2. <br>  7) J y X. El valor en el campo J tomar√° 2 bytes, el valor en el campo X tomar√° 2 bytes. <br><br>  <b>En total, las opciones correctas son: C y K, I y J, J y X.</b> <br></div></div><br><br><h3>  ¬øCu√°l ser√° aproximadamente el factor de agrupaci√≥n del √≠ndice T_I? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t (i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t(i);</code> </pre><br><ul><li>  Sobre docenas </li><li>  Sobre cientos </li><li>  Del orden de miles </li><li>  Del orden de decenas de miles </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentaci√≥n de Oracle (citada en 12.1): <br><br>  Para un √≠ndice de √°rbol B, el factor de agrupaci√≥n de √≠ndice mide la agrupaci√≥n f√≠sica de filas en relaci√≥n con un valor de √≠ndice. <br><br>  El factor de agrupaci√≥n de √≠ndice ayuda al optimizador a decidir si una exploraci√≥n de √≠ndice o una exploraci√≥n de tabla completa es m√°s eficiente para ciertas consultas).  Un factor de agrupaci√≥n bajo indica un escaneo de √≠ndice eficiente. <br><br>  Un factor de agrupaci√≥n cercano al n√∫mero de bloques en una tabla indica que las filas est√°n f√≠sicamente ordenadas en los bloques de la tabla por la clave de √≠ndice.  Si la base de datos realiza un escaneo completo de la tabla, la base de datos tiende a recuperar las filas a medida que se almacenan en el disco ordenado por la clave de √≠ndice.  Un factor de agrupaci√≥n cercano al n√∫mero de filas indica que las filas est√°n dispersas aleatoriamente entre los bloques de la base de datos en relaci√≥n con la clave de √≠ndice.  Si la base de datos realiza una exploraci√≥n completa de la tabla, entonces la base de datos no recuperar√≠a filas en ning√∫n orden ordenado por esta clave de √≠ndice. <br><br>  En este caso, los datos se ordenan idealmente, por lo que el factor de agrupaci√≥n ser√° igual o cercano al n√∫mero de bloques ocupados en la tabla.  Para un tama√±o de bloque est√°ndar de 8 kilobytes, puede esperar que alrededor de mil valores de n√∫meros estrechos quepan en un bloque, por lo que el n√∫mero de bloques, y como resultado el factor de agrupaci√≥n, ser√° del <b>orden de las decenas</b> . <br></div></div><br><h3>  ¬øA qu√© valores de N se ejecutar√° con √©xito el siguiente script en una base de datos normal con configuraci√≥n est√°ndar? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t ( a varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), b varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), c varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>), d varchar2(N <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> t_i <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t (a, b, c, d);</code> </pre><br><ul><li>  100 </li><li>  200 </li><li>  400 </li><li>  800 </li><li>  1600 </li><li>  3200 </li><li>  6400 </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  De acuerdo con la documentaci√≥n de Oracle (citada en 11.2): <br><br>  L√≠mites l√≥gicos de la base de datos. <br><br><div class="scrollable-table"><table><thead><tr><td>  <strong>Art√≠culo</strong> </td><td>  <strong>Tipo de l√≠mite</strong> </td><td>  <strong>Valor l√≠mite</strong> </td></tr></thead><tbody><tr><td>  √çndices </td><td>  Tama√±o total de columna indexada </td><td>  75% del tama√±o del bloque de la base de datos menos algunos gastos generales </td></tr></tbody></table></div><br>  Por lo tanto, el tama√±o total de las columnas indexadas no debe exceder los 6Kb.  Adem√°s depende de la base de codificaci√≥n seleccionada.  Para la codificaci√≥n AL32UTF8, un car√°cter puede ocupar un m√°ximo de 4 bytes, por lo que, en el peor de los casos, 6 kilobytes caben aproximadamente 1.500 caracteres.  Por lo tanto, Oracle prohibir√° la creaci√≥n de un √≠ndice en N = 400 (cuando la longitud de la clave en el peor de los casos es 1600 caracteres * 4 bytes + longitud de fila), mientras que <b>en N = 200 (o menos) la</b> creaci√≥n del √≠ndice funcionar√° sin problemas. <br></div></div><br><h3>  La instrucci√≥n INSERT con la sugerencia APPEND est√° dise√±ada para cargar datos en modo directo.  ¬øQu√© sucede si se aplica a la tabla en la que se cuelga el gatillo? </h3><br><ul><li>  Los datos se cargar√°n en modo directo, el disparador funcionar√° como deber√≠a </li><li>  Los datos se cargar√°n en modo directo, pero el disparador no se ejecutar√°. </li><li>  Los datos se cargar√°n en modo convencional, el disparador funcionar√° como deber√≠a </li><li>  Los datos se cargar√°n en modo convencional, pero el disparador no se ejecutar√° </li><li>  Los datos no se cargar√°n, se solucionar√° el error </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  En principio, esto es m√°s una cuesti√≥n de l√≥gica.  Para encontrar la respuesta correcta, sugerir√≠a el siguiente modelo de razonamiento: <br><br><ol><li>  La inserci√≥n en modo directo se realiza mediante la formaci√≥n directa de un bloque de datos, m√°s all√° del motor SQL, que garantiza una alta velocidad.  Por lo tanto, garantizar la ejecuci√≥n del disparador es muy dif√≠cil, si es posible, y no tiene sentido, ya que de todos modos ralentizar√° dr√°sticamente la inserci√≥n. </li><li>  Si no se dispara, el hecho de que, con los mismos datos en la tabla, el estado de la base de datos en su conjunto (de otras tablas) depender√° del modo en que se inserten los datos.  Obviamente, esto destruir√° la integridad de los datos y no se puede aplicar como soluci√≥n en la producci√≥n. </li><li>  La imposibilidad de realizar la operaci√≥n solicitada, en general, se trata como un error.  Pero aqu√≠ debe recordarse que APPEND es una pista, y la l√≥gica general de las pistas es que se tienen en cuenta si es posible, si no, el operador se ejecuta sin tener en cuenta la pista. </li></ol><br>  Por lo tanto, la respuesta esperada es que los <b>datos se cargar√°n en modo normal (SQL), el disparador se disparar√°.</b> <br><br>  De acuerdo con la documentaci√≥n de Oracle (citado desde 8.04): <br><br>  Las violaciones de las restricciones har√°n que la declaraci√≥n se ejecute en serie, utilizando la ruta de inserci√≥n convencional, sin advertencias ni mensajes de error.  Una excepci√≥n es la restricci√≥n en las declaraciones que acceden a la misma tabla m√°s de una vez en una transacci√≥n, lo que puede causar mensajes de error. <br>  Por ejemplo, si los desencadenantes o la integridad referencial est√°n presentes en la tabla, la sugerencia APPEND se ignorar√° cuando intente utilizar INSERT de carga directa (serie o paralelo), as√≠ como la sugerencia o cl√°usula PARALLEL, si corresponde. </div></div><br><h3>  ¬øQu√© sucede al ejecutar el siguiente script? </h3><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> t(i <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> primary <span class="hljs-keyword"><span class="hljs-keyword">key</span></span>, j <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">references</span></span> t); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span> t_a_i <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> <span class="hljs-keyword"><span class="hljs-keyword">row</span></span> <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pragma</span></span> autonomous_transaction; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (:new.i + <span class="hljs-number"><span class="hljs-number">1</span></span>, :new.i); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><ul><li>  Ejecuci√≥n exitosa </li><li>  Error de sintaxis fallido </li><li>  Error de transacci√≥n fuera de l√≠nea no v√°lido </li><li>  Error relacionado con exceder el anidamiento m√°ximo de llamadas </li><li>  Error de violaci√≥n de clave externa </li><li>  Error de bloqueo </li></ul><br><div class="spoiler">  <b class="spoiler_title">La respuesta</b> <div class="spoiler_text">  La tabla y el desencadenador se crean correctamente y esta operaci√≥n no deber√≠a generar problemas.  Las transacciones aut√≥nomas en el activador tambi√©n est√°n permitidas, de lo contrario ser√≠a imposible, por ejemplo, el registro. <br><br>  Despu√©s de insertar la primera l√≠nea, un activador exitoso conducir√≠a a la inserci√≥n de la segunda l√≠nea, en relaci√≥n con la cual el activador funcionar√≠a nuevamente, inserte la tercera l√≠nea, y as√≠ sucesivamente hasta que la instrucci√≥n caiga debido a que excede el m√°ximo de anidamiento de llamadas.  Sin embargo, se desencadena otro punto sutil.  En el momento en que se ejecuta el desencadenador, la confirmaci√≥n a√∫n no se ejecuta para el primer registro insertado.  Por lo tanto, un desencadenador que funciona en una transacci√≥n aut√≥noma intenta insertar una fila en la tabla que hace referencia mediante una clave externa a un registro que a√∫n no se ha confirmado.  Esto lleva a una espera (una transacci√≥n aut√≥noma est√° esperando que el compromiso principal comprenda si es posible insertar datos) y, al mismo tiempo, la transacci√≥n principal est√° esperando que el compromiso aut√≥nomo contin√∫e funcionando despu√©s del desencadenante.  <b>Se produce un punto muerto y, como resultado, se devuelve una transacci√≥n aut√≥noma por el motivo asociado con los bloqueos</b> . <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459680/">https://habr.com/ru/post/459680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459662/index.html">PVS-Studio quer√≠a, pero no pudo encontrar errores en robots.txt</a></li>
<li><a href="../459668/index.html">C√≥mo reconocer el texto de una foto: nuevas caracter√≠sticas del marco Vision</a></li>
<li><a href="../459670/index.html">Ir a amsterdam</a></li>
<li><a href="../459672/index.html">Subrayar en Python</a></li>
<li><a href="../459674/index.html">Inteligencia de amenazas Epic Saga</a></li>
<li><a href="../459682/index.html">Calidad de datos en almacenamiento</a></li>
<li><a href="../459684/index.html">Mapa del metro de Mosc√∫ y el mundo entero para Android</a></li>
<li><a href="../459688/index.html">Urbanismo en China: menos inconformistas, m√°s ciencia e inform√°tica</a></li>
<li><a href="../459692/index.html">C√≥mo descubrimos modificaciones materiales que contradicen los principios qu√≠micos establecidos</a></li>
<li><a href="../459694/index.html">Datos del museo Art. Desembale y lance Radio 86RK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>