<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🎓 👨‍👦‍👦 💊 Top 10 Fehler von C ++ - Projekten im Jahr 2018 gefunden 🖖🏻 🚶🏻 🚷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seit dem Ende des Jahres 2018 sind drei Monate vergangen. Für viele ist es gerade vorbei geflogen, aber für uns PVS-Studio-Entwickler war es ein zieml...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Top 10 Fehler von C ++ - Projekten im Jahr 2018 gefunden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/444568/">  Seit dem Ende des Jahres 2018 sind drei Monate vergangen.  Für viele ist es gerade vorbei geflogen, aber für uns PVS-Studio-Entwickler war es ein ziemlich ereignisreiches Jahr.  Wir haben uns ins Schwitzen gebracht, furchtlos um die Verbreitung der statischen Analyse konkurriert und nach Fehlern in Open-Source-Projekten gesucht, die in den Sprachen C, C ++, C # und Java geschrieben wurden.  In diesem Artikel haben wir die 10 interessantesten für Sie zusammengestellt! <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7b/72a/054/f7b72a054c744397f8c8c1830253ae2a.png"></div><a name="habracut"></a><br>  Um die faszinierendsten Orte zu finden, haben wir den statischen Code-Analysator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PVS-Studio</a> verwendet.  Es kann Fehler und potenzielle Schwachstellen im Code erkennen, der in den oben aufgeführten Sprachen geschrieben ist. <br><br>  Wenn Sie begeistert sind, selbst nach Fehlern zu suchen, können Sie jederzeit unseren Analysator herunterladen und ausprobieren.  Wir bieten die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlose Analyseversion</a> für Studenten und begeisterte Entwickler, die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kostenlose Lizenz</a> für Entwickler von Open-Source-Projekten sowie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Testversion</a> für die ganze Welt und seinen Hund.  Wer weiß, vielleicht können Sie im nächsten Jahr Ihre eigenen Top 10 erstellen?  :) :) <br><br>  <b>Hinweis:</b> Ich lade Sie ein, sich selbst zu überprüfen und, bevor Sie sich die Warnung des Analysators ansehen, selbst Fehler aufzudecken.  Wie viele Fehler können Sie finden? <br><br><h2>  Zehnter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wieder ins All: Wie das Einhorn das Stellarium besuchte</a> <br><br>  Dieser Fehler wurde bei der Überprüfung eines virtuellen Planetariums namens Stellarium festgestellt. <br><br>  Das obige Codefragment ist zwar klein, weist jedoch einen ziemlich kniffligen Fehler auf: <br><br><pre><code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br>  Gefunden? <br><br>  <b>PVS-Studio-Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V603</a> Das Objekt wurde erstellt, wird jedoch nicht verwendet.  Wenn Sie den Konstruktor aufrufen möchten, sollte 'this-&gt; Plane :: Plane (....)' verwendet werden.  Plane.cpp 29 <br><br>  Der Code-Autor beabsichtigte, die Felder eines Objekts mithilfe eines anderen Konstruktors zu initialisieren, der im Hauptkonstruktor verschachtelt ist.  Stattdessen gelang es ihm nur, ein temporäres Objekt zu erstellen, das beim Verlassen seines Bereichs zerstört wurde.  Auf diese Weise bleiben die Felder mehrerer Objekte nicht initialisiert. <br><br>  Der Autor sollte anstelle eines verschachtelten Konstruktoraufrufs einen in C ++ 11 eingeführten Delegatenkonstruktor verwenden.  Zum Beispiel hätte er so schreiben können: <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f&amp; v1, Vec3f&amp; v2, Vec3f&amp; v3) : Plane(v1, v2, v3, SPolygon::CCW) { distance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; sDistance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; }</code> </pre> <br>  Auf diese Weise wären alle erforderlichen Felder korrekt initialisiert worden.  Ist es nicht wunderbar? <br><br><h2>  Neunter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Perl 5: So verbergen Sie Fehler in Makros</a> <br><br>  Auf dem neunten Platz sticht ein sehr bemerkenswertes Makro in seiner ganzen Schönheit hervor. <br><br>  Beim Sammeln von Fehlern beim Schreiben eines Artikels stieß mein Kollege Svyatoslav auf eine Warnung des Analysators, die sich auf die Verwendung von Makros bezog.  Hier ist es: <br><br><pre> <code class="cpp hljs">PP(pp_match) { .... MgBYTEPOS_set(mg, TARG, truebase, RXp_OFFS(prog)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end); .... }</code> </pre> <br>  Um herauszufinden, was los war, grub Svyatoslav tiefer.  Er öffnete die Makrodefinition und stellte fest, dass sie mehrere verschachtelte Makros enthielt, von denen einige wiederum auch verschachtelte Makros enthielten.  Es war so schwer, daraus einen Sinn zu machen, deshalb musste er eine vorverarbeitete Datei verwenden.  Leider hat es nicht geholfen.  Dies ist, was Svyatoslav in der vorherigen Codezeile gefunden hat: <br><br><pre> <code class="cpp hljs">(((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x00000400</span></span>) &amp;&amp; (!((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x00200000</span></span>) || S_sv_only_taint_gmagic(targ)) ? (mg)-&gt;mg_len = ((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end), (mg)-&gt;mg_flags |= <span class="hljs-number"><span class="hljs-number">0x40</span></span> : ((mg)-&gt;mg_len = (((targ)-&gt;sv_flags &amp; <span class="hljs-number"><span class="hljs-number">0x20000000</span></span>) &amp;&amp; !__builtin_expect(((((PL_curcop)-&gt;cop_hints + <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x00000008</span></span>) ? (<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span> :(<span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>),(<span class="hljs-number"><span class="hljs-number">0</span></span>))) ? (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span>)Perl_utf8_length( (U8 *)(truebase), (U8 *)(truebase)+((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end)) : (<span class="hljs-keyword"><span class="hljs-keyword">ssize_t</span></span>)((prog-&gt;offs)[<span class="hljs-number"><span class="hljs-number">0</span></span>].end), (mg)-&gt;mg_flags &amp;= ~<span class="hljs-number"><span class="hljs-number">0x40</span></span>));</code> </pre> <br>  <b>PVS-Studio-Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V502</a> Möglicherweise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert</a> der Operator '?:' Anders als erwartet.  Der Operator '?:' Hat eine niedrigere Priorität als der Operator '&amp;&amp;'.  pp_hot.c 3036 <br><br>  Ich denke, es wäre schwierig, einen solchen Fehler einfach zu bemerken.  Wir haben lange über diesen Code nachgedacht, aber ehrlich gesagt haben wir keinen Fehler darin gefunden.  Auf jeden Fall ist es ein amüsantes Beispiel für schlecht lesbaren Code. <br><br>  Sie sagen, dass Makros böse sind.  Sicher, es gibt Fälle, in denen Makros unverzichtbar sind, aber wenn Sie ein Makro durch eine Funktion ersetzen können, sollten Sie dies auf jeden Fall tun. <br><br>  Verschachtelte Makros sind besonders voller Fallstricke.  Nicht nur, weil es schwierig ist, sie zu verstehen, sondern auch, weil sie unvorhersehbare Ergebnisse liefern können.  Wenn ein Programmierer in einem solchen Makro einen Fehler macht, ist es viel schwieriger, ihn in einem Makro zu finden als in einer Funktion. <br><br><h2>  Achter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Andere Fehler</a> <br><br>  Das nächste Beispiel stammt aus der Artikelserie zur Analyse des Chromium-Projekts.  Der Fehler wurde in der WebRTC-Bibliothek ausgeblendet. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;SdpVideoFormat&gt; StereoDecoderFactory::GetSupportedFormats() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;SdpVideoFormat&gt; formats = ....; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; format : formats) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cricket::CodecNamesEq(....)) { .... formats.push_back(stereo_format); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> formats; }</code> </pre> <br>  <b>PVS-Studio-Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V789</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-672</a> Iteratoren für den Container 'Formate', die in der bereichsbasierten for-Schleife verwendet werden, werden beim Aufruf der Funktion 'push_back' ungültig.  stereocodecfactory.cc 89 <br><br>  Der Fehler besteht darin, dass die Größe des Formatvektors innerhalb der bereichsbasierten for-Schleife variiert.  Bereichsbasierte Schleifen basieren auf Iteratoren. Daher kann eine Änderung der Containergröße innerhalb solcher Schleifen zur Ungültigmachung dieser Iteratoren führen. <br><br>  Dieser Fehler bleibt bestehen, wenn die Schleife unter expliziter Verwendung von Iteratoren neu geschrieben wird.  Der Klarheit halber kann ich den folgenden Code zitieren: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> format = begin(formats), __end = end(formats); format != __end; ++format) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cricket::CodecNamesEq(....)) { .... formats.push_back(stereo_format); } }</code> </pre> <br>  Bei Verwendung der <i>push_back-</i> Methode kann beispielsweise eine <i>Vektorumverteilung</i> auftreten. Auf diese Weise adressieren die Iteratoren einen ungültigen Speicherort. <br><br>  Um solche Fehler zu vermeiden, befolgen Sie die Regel: Ändern Sie niemals eine Containergröße innerhalb einer Schleife mit Bedingungen, die an diesen Container gebunden sind.  Es bezieht sich auch auf bereichsbasierte Schleifen und Schleifen, die Iteratoren verwenden.  Sie können gerne diese <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Diskussion</a> über StackOverflow lesen, die das Thema Operationen behandelt, die zur Ungültigmachung von Iteratoren führen. <br><br><h2>  Siebter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Godot: Zur regelmäßigen Verwendung statischer Analysegeräte</a> <br><br>  Das erste Beispiel aus der Spielebranche wird ein Code-Snippet sein, das wir in der Godot-Game-Engine gefunden haben.  Wahrscheinlich wird es einige Arbeit erfordern, um den Fehler zu bemerken, aber ich bin sicher, dass unsere vertrauten Leser damit fertig werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnimationNodeBlendSpace1D::add_blend_point( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Ref&lt;AnimationRootNode&gt; &amp;p_node, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> p_position, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p_at_index) { ERR_FAIL_COND(blend_points_used &gt;= MAX_BLEND_POINTS); ERR_FAIL_COND(p_node.is_null()); ERR_FAIL_COND(p_at_index &lt; <span class="hljs-number"><span class="hljs-number">-1</span></span> || p_at_index &gt; blend_points_used); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p_at_index == <span class="hljs-number"><span class="hljs-number">-1</span></span> || p_at_index == blend_points_used) { p_at_index = blend_points_used; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = blend_points_used - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt; p_at_index; i++) { blend_points[i] = blend_points[i - <span class="hljs-number"><span class="hljs-number">1</span></span>]; } } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V621</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-835</a> Überprüfen Sie den ' <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">for'</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">-</a> Operator.  Es ist möglich, dass die Schleife falsch oder gar nicht ausgeführt wird.  animation_blend_space_1d.cpp 113 <br><br>  Schauen wir uns die Schleifenbedingung genauer an.  Die <i>Zählervariable</i> wird mit dem Wert <i>blend_points_used - 1</i> initialisiert.  Aus zwei vorherigen Überprüfungen (in <i>ERR_FAIL_COND</i> und in <i>if</i> ) geht außerdem hervor, dass zum Zeitpunkt der Ausführung der <i>Blend_points_used-</i> Schleife <i>blend_points_used</i> immer größer als <i>p_at_index ist</i> .  Somit ist entweder die Schleifenbedingung immer wahr oder die Schleife wird überhaupt nicht ausgeführt. <br><br>  Wenn <i>blend_points_used - 1 == p_at_index ist</i> , wird die Schleife nicht ausgeführt. <br><br>  In allen anderen Fällen ist die Prüfung <i>i&gt; p_at_index</i> immer wahr, da der <i>i-</i> Zähler bei jeder Schleifeniteration nach oben geht. <br><br>  Es scheint, dass die Schleife ewig ist, aber es ist nicht so. <br><br>  Erstens tritt ein ganzzahliger Überlauf der <i>i-</i> Variablen (was ein undefiniertes Verhalten ist) auf.  Das heißt, wir sollten uns nicht darauf verlassen. <br><br>  Wenn <i>ich</i> <i>int ohne Vorzeichen</i> wäre, würde der Operator <i>i ++</i> den Zähler in <i>0</i> <i>umwandeln</i> , nachdem er den größtmöglichen Wert erreicht hat.  Ein solches Verhalten wird durch den Standard definiert und als "vorzeichenlose Umhüllung" bezeichnet.  Sie sollten sich jedoch bewusst sein, dass die Verwendung eines solchen Mechanismus ebenfalls <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">keine gute Idee ist</a> . <br><br>  Es war der erste Punkt, aber wir haben immer noch den zweiten!  Der Fall ist, dass wir nicht einmal zu einem ganzzahligen Überlauf kommen.  Der Array-Index wird viel früher außerhalb der Grenzen liegen.  Dies bedeutet, dass versucht wird, auf Speicher außerhalb des für das Array zugewiesenen Blocks zuzugreifen.  Welches ist auch undefiniertes Verhalten.  Ein klassisches Beispiel :) <br><br>  Ich kann Ihnen einige Empfehlungen geben, um ähnliche Fehler leichter zu vermeiden: <br><br><ol><li>  Schreiben Sie einfachen und verständlichen Code </li><li>  Überprüfen Sie den Code gründlicher und schreiben Sie weitere Tests für neu geschriebenen Code </li><li>  Verwenden Sie statische Analysegeräte;) </li></ol><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e24/4d8/f8b/e244d8f8b0062e5c822e3630b50b26bc.png"></div><br><br><h2>  Sechster Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Amazon Lumberyard: Ein Schrei der Angst</a> <br><br>  Hier ist ein weiteres Beispiel aus der Gamedev-Branche, nämlich aus dem Quellcode der AAA-Engine von Amazon Lumberyard. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TranslateVariableNameByOperandType</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Igor: yet another Qualcomm's special case // GLSL compiler thinks that -2147483648 is // an integer overflow which is not if (*((int*)(&amp;psOperand-&gt;afImmediates[0])) == 2147483648) { bformata(glsl, "-2147483647-1"); } else { // Igor: this is expected to fix // paranoid compiler checks such as Qualcomm's if (*((unsigned int*)(&amp;psOperand-&gt;afImmediates[0])) &gt;= 2147483648) { bformata(glsl, "%d", *((int*)(&amp;psOperand-&gt;afImmediates[0]))); } else { bformata(glsl, "%d", *((int*)(&amp;psOperand-&gt;afImmediates[0]))); } } bcatcstr(glsl, ")"); .... }</span></span></code> </pre> <br>  <b>PVS-Studio-Warnung</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V523</a> Die Anweisung 'then' entspricht der Anweisung 'else'.  toglsloperand.c 700 <br><br>  Amazon Lumberyard wurde als plattformübergreifende Engine entwickelt.  Aus diesem Grund versuchen Entwickler, so viele Compiler wie möglich zu unterstützen.  Wie wir den Kommentaren entnehmen können, kam ein Programmierer Igor gegen den Qualcomm-Compiler. <br><br>  Wir wissen nicht, ob er es geschafft hat, seine Aufgabe auszuführen und durch "paranoide" Compilerprüfungen zu waten, aber er hat sehr seltsamen Code hinterlassen.  Das Seltsame daran ist, dass sowohl die <i>damaligen</i> als auch die <i>anderen</i> Zweige der <i>if-</i> Anweisung absolut identischen Code enthalten.  Ein solcher Fehler ist höchstwahrscheinlich auf die Verwendung einer schlampigen Copy-Paste-Methode zurückzuführen. <br><br>  Ich weiß nicht einmal, was ich hier raten soll.  Ich wünsche den Entwicklern von Amazon Lumberyard nur alles Gute bei der Behebung von Fehlern und viel Glück für den Entwickler Igor! <br><br><h2>  Fünfter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der PVS-Studio-Analysator hat sich erneut als aufmerksamer als eine Person erwiesen</a> <br><br>  Eine interessante Geschichte ereignete sich mit dem nächsten Beispiel.  Mein Kollege Andrey Karpov bereitete einen Artikel über eine weitere Überprüfung des Qt-Frameworks vor.  Beim Schreiben einiger bemerkenswerter Fehler stieß er auf die Warnung des Analysators, die er für falsch hielt.  Hier ist das Codefragment und die Warnung dafür: <br><br><pre> <code class="cpp hljs">QWindowsCursor::CursorState QWindowsCursor::cursorState() { <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> { cursorShowing = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, cursorSuppressed = <span class="hljs-number"><span class="hljs-number">0x2</span></span> }; CURSORINFO cursorInfo; cursorInfo.cbSize = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(CURSORINFO); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GetCursorInfo(&amp;cursorInfo)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cursorInfo.flags &amp; CursorShowing) <span class="hljs-comment"><span class="hljs-comment">// &lt;= V616 .... }</span></span></code> </pre> <br>  <b>PVS-Studio-Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V616</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-480</a> Die benannte Konstante 'CursorShowing' mit dem Wert 0 wird in der bitweisen Operation verwendet.  qwindowscursor.cpp 669 <br><br>  Was bedeutet, dass sich PVS-Studio vor Ort beschwert hat, was offensichtlich keinen Fehler hatte!  Es ist unmöglich, dass die <i>CursorShowing-</i> Konstante <i>0 ist</i> , da nur ein paar Zeilen darüber mit <i>1</i> initialisiert werden. <br><br>  Da Andrey eine instabile Analysatorversion verwendete, stellte er die Richtigkeit der Warnung in Frage.  Er sah sich diesen Code sorgfältig an und fand immer noch keinen Fehler.  Er gab es schließlich im Bugtracker falsch positiv, damit andere Kollegen Abhilfe schaffen konnten. <br><br>  Nur eine detaillierte Analyse ergab, dass PVS-Studio wieder vorsichtiger war als eine Person.  Der Wert <i>0x1</i> wird einer benannten Konstante namens <i>cursorShowing</i> zugewiesen, während <i>CursorShowing</i> an einer bitweisen "und" <i>-Operation</i> teilnimmt.  Dies sind zwei völlig unterschiedliche Konstanten, die erste beginnt mit einem Kleinbuchstaben, die zweite mit einem Großbuchstaben. <br><br>  Der Code wird erfolgreich kompiliert, da die Klasse <i>QWindowsCursor</i> wirklich eine Konstante mit diesem Namen enthält.  Hier ist seine Definition: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QWindowsCursor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QPlatformCursor { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CursorState { CursorShowing, CursorHidden, CursorSuppressed }; .... }</code> </pre> <br>  Wenn Sie einer Enum-Konstante keinen Wert explizit zuweisen, wird dieser standardmäßig initialisiert.  Da <i>CursorShowing</i> das erste Element in der Aufzählung ist, wird ihm <i>0</i> zugewiesen. <br><br>  Um solche Fehler zu vermeiden, sollten Sie Entitäten keine zu ähnlichen Namen geben.  Sie sollten diese Regel besonders genau befolgen, wenn Entitäten vom gleichen Typ sind oder implizit ineinander umgewandelt werden können.  Wie in solchen Fällen ist es fast unmöglich, den Fehler zu bemerken, aber der falsche Code wird trotzdem kompiliert und befindet sich in einer einfachen Straße innerhalb Ihres Projekts. <br><br><h2>  Vierter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schießen Sie sich beim Umgang mit Eingabedaten in den Fuß</a> <br><br>  Wir nähern uns den drei besten Finalisten und der nächste in der Reihe ist der Fehler aus dem FreeSWITCH-Projekt. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">basic_gets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cnt)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = getchar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fgets(command_buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(command_buf) - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>) != command_buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } command_buf[<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(command_buf)<span class="hljs-number"><span class="hljs-number">-1</span></span>] = <span class="hljs-string"><span class="hljs-string">'\0'</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* remove endline */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  <b>PVS-Studio-Warnung: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1010</a></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-20</a> Im Index 'strlen (command_buf)' werden nicht aktivierte fehlerhafte Daten verwendet. <br><br>  Der Analysator warnt Sie, dass einige ungeprüfte Daten im Ausdruck <i>strlen (command_buf) - 1 verwendet werden</i> .  In der Tat: Wenn <i>command_buf</i> eine leere Zeichenfolge in Bezug auf die C-Sprache ist (die das einzige Zeichen enthält - '\ 0'), gibt <i>strlen (command_buf)</i> <i>0 zurück</i> .  In einem solchen Fall wird auf <i>command_buf [-1]</i> zugegriffen, was ein undefiniertes Verhalten ist.  Das ist schlecht! <br><br>  Die eigentliche Lust an diesem Fehler ist nicht, <b>warum</b> er auftritt, sondern <b>wie</b> .  Dieser Fehler ist eines der schönsten Beispiele, die Sie selbst "berühren" und reproduzieren.  Sie können FreeSwitch ausführen, einige Aktionen ausführen, die zur Ausführung des oben genannten Codefragments führen, und eine leere Zeichenfolge an die Eingabe des Programms übergeben. <br><br>  Infolgedessen wird ein Arbeitsprogramm mit einer subtilen Bewegung der Hand zu einem nicht funktionierenden!  Einzelheiten zur Reproduktion dieses Fehlers finden Sie im Quellartikel unter dem oben angegebenen Link.  Lassen Sie mich Ihnen in der Zwischenzeit ein aussagekräftiges Ergebnis liefern: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jSYJirPIK8E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Denken Sie daran, dass Ausgabedaten alles sein können, daher sollten Sie sie immer überprüfen.  Auf diese Weise beschwert sich der Analysator nicht und das Programm wird zuverlässiger. <br><br>  Jetzt ist es Zeit für unseren Gewinner: Wir sind jetzt im Endspiel!  Übrigens haben Bugs-Finalisten schon lange gewartet, sich dann gelangweilt und sogar angefangen, kitschig zu werden.  Schauen Sie, was sie inszeniert haben, während wir weg waren! <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c7/d5f/39e/2c7d5f39edfa5e07639ef95520889b09.png"></div><br><br><h2>  Dritter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NCBI Genome Workbench: Wissenschaftliche Forschung unter Bedrohung</a> <br><br>  Ein Code-Snippet aus dem NCBI Genome Workbench-Projekt, bei dem es sich um eine Reihe von Tools zum Studieren und Analysieren genetischer Daten handelt, eröffnet die drei besten Gewinner.  Auch wenn Sie kein gentechnisch veränderter Übermensch sein müssen, um diesen Fehler zu finden, wissen nur wenige, wie wichtig es ist, hier einen Fehler zu machen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ntlm_v == <span class="hljs-number"><span class="hljs-number">1</span></span>) { .... <span class="hljs-comment"><span class="hljs-comment">/* with security is best be pedantic */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(hash, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(hash)); <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(passwd_buf, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(passwd_buf)); ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... } }</code> </pre> <br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der 'Hash'-Puffer geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Challenge.c 365 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V597</a> Der Compiler könnte den Funktionsaufruf 'memset' löschen, mit dem der Puffer 'passwd_buf' geleert wird.  Die Funktion memset_s () sollte verwendet werden, um die privaten Daten zu löschen.  Herausforderung.c 366 </li></ul><br>  Hast du einen Fehler gefunden?  Wenn ja, sind Sie ein Attaboy! .. oder ein genetisch veränderter Übermensch. <br><br>  Tatsache ist, dass moderne Optimierungs-Compiler viel tun können, damit ein erstelltes Programm schneller funktioniert.  Einschließlich der Tatsache, dass Compiler jetzt verfolgen können, dass ein an <i>memset übergebener</i> Puffer nirgendwo anders verwendet wird. <br><br>  In diesem Fall können sie den "unnötigen" Aufruf von <i>memset entfernen</i> und haben alle Rechte dafür.  Dann kann der Puffer, in dem wichtige Daten gespeichert sind, zur Freude der Angreifer im Speicher verbleiben. <br><br>  Vor diesem Hintergrund klingt dieser Geek-Kommentar "Mit Sicherheit ist am besten pedantisch" noch lustiger.  Nach einer kleinen Anzahl von Warnungen für dieses Projekt zu urteilen, haben die Entwickler ihr Bestes getan, um präzise zu sein und sicheren Code zu schreiben.  Wie wir jedoch sehen können, kann man einen solchen Sicherheitsmangel leicht übersehen.  Gemäß der Common Weakness Enumeration wird dieser Fehler als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-14</a> : Compiler-Entfernung von Code zum Löschen von Puffern klassifiziert. <br><br>  Sie sollten die Funktion <i>memset_s ()</i> verwenden, damit die Speicherfreigabe sicher ist.  Die Funktion ist sicherer als <i>memset ()</i> und kann von einem Compiler nicht ignoriert werden. <br><br><h2>  Zweiter Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie sich PVS-Studio als aufmerksamer als dreieinhalb Programmierer erwies</a> <br><br>  Ein Silbermedaillengewinner wurde uns freundlicherweise von einem unserer Kunden zugesandt.  Er war sich sicher, dass der Analysator einige falsch positive Ergebnisse ausgab. <br><br>  Evgeniy bekam die E-Mail, sah sie sich an und schickte sie an Svyatoslav.  Svyatoslav sah sich den vom Kunden gesendeten Code genau an und dachte: "Wie ist es möglich, dass der Analysator einen solchen Fehler gemacht hat?".  Also bat er Andrey um Rat.  Er überprüfte auch diesen Ort und stellte fest: In der Tat erzeugte der Analysator falsch positive Ergebnisse. <br><br>  So geht es, das musste repariert werden.  Erst als Svyatoslav anfing, synthetische Beispiele zu erstellen, um die Aufgabe in unserem Bug-Tracker zu erstellen, bekam er, was falsch war. <br><br>  Keiner der Programmierer konnte die Fehler finden, aber sie waren wirklich im Code.  Ehrlich gesagt konnte der Autor dieses Artikels sie auch nicht finden, obwohl der Analysator eindeutig Warnungen für fehlerhafte Stellen ausgegeben hat! <br><br>  Wirst du so einen schlauen Käfer finden?  Testen Sie sich auf Wachsamkeit und Aufmerksamkeit. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/002/b12/75b/002b1275be55e7c96131de9f44d02ef7.png"></div><br>  <b>PVS-Studio Warnung:</b> <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> Ein Teil des bedingten Ausdrucks ist immer falsch: (ch&gt; = 0x0FF21).  decodew.cpp 525 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> Ein Teil des bedingten Ausdrucks ist immer wahr: (ch &lt;= 0x0FF3A).  decodew.cpp 525 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> Ein Teil des bedingten Ausdrucks ist immer falsch: (ch&gt; = 0x0FF41).  decodew.cpp 525 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V560</a> Ein Teil des bedingten Ausdrucks ist immer wahr: (ch &lt;= 0x0FF5A).  decodew.cpp 525 </li></ul><br>  Wenn du es getan hast - ein großes Lob an dich! <br><br>  Der Fehler liegt in der Tatsache, dass der logische Negationsoperator (!) Nicht auf die gesamte Bedingung angewendet wird, sondern nur auf ihren ersten Unterausdruck: <br><br><pre> <code class="cpp hljs">!((ch &gt;= <span class="hljs-number"><span class="hljs-number">0x0FF10</span></span>) &amp;&amp; (ch &lt;= <span class="hljs-number"><span class="hljs-number">0x0FF19</span></span>))</code> </pre> <br>  Wenn diese Bedingung erfüllt ist, liegt der Wert der Variablen <i>ch</i> im Bereich [0x0FF10 ... 0x0FF19].  Somit sind vier weitere Vergleiche bereits bedeutungslos: Sie werden immer entweder wahr oder falsch sein. <br><br>  Um solche Fehler zu vermeiden, sollten Sie sich an einige Regeln halten.  Erstens ist es sehr praktisch und informativ, den Code wie eine Tabelle auszurichten.  Zweitens sollten Sie die Ausdrücke nicht mit Klammern überladen.  Dieser Code könnte beispielsweise folgendermaßen umgeschrieben werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isLetterOrDigit = (ch &gt;= <span class="hljs-number"><span class="hljs-number">0x0FF10</span></span> &amp;&amp; ch &lt;= <span class="hljs-number"><span class="hljs-number">0x0FF19</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 0..9 || (ch &gt;= 0x0FF21 &amp;&amp; ch &lt;= 0x0FF3A) // A..Z || (ch &gt;= 0x0FF41 &amp;&amp; ch &lt;= 0x0FF5A); // a..z if (!isLetterOrDigit)</span></span></code> </pre> <br>  Auf diese Weise werden weniger Klammern angezeigt, und andererseits werden Sie mit größerer Wahrscheinlichkeit einen gelegentlichen Fehler bemerken. <br><br>  Hier kommt die Kirsche an die Spitze - gehen wir zum ersten Platz! <br><br><h2>  Erster Platz </h2><br>  Quelle: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schockiertes System: Interessante Fehler im Quellcode des legendären Systemschocks</a> <br><br>  Der heutige Top-Finalist ist ein Fehler des legendären System Shock!  Es ist ein Spiel, das vor langer Zeit im Jahr 1994 veröffentlicht wurde und Vorgänger und Inspiration für legendäre Spiele wie Dead Space, BioShock und Deus Ex wurde. <br><br>  Aber zuerst muss ich etwas gestehen.  Was ich Ihnen jetzt zeigen werde, enthält keine Fehler.  Eigentlich ist es nicht einmal ein Stück Code, aber ich konnte einfach nicht anders, als es mit Ihnen zu teilen! <br><br>  Die Sache ist, dass meine Kollegin Victoria bei der Analyse des Quellcodes des Spiels viele faszinierende Kommentare entdeckt hat.  In verschiedenen Fragmenten fand sie einige witzige und ironische Bemerkungen und sogar Gedichte. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// I'll give you fish, I'll give you candy, // I'll give you, everything I have in my hand // that kid from the wrong side came over my house again, // decapitated all my dolls // and if you bore me, you lose your soul to me // - "Gepetto", Belly, _Star_ // And here, ladies and gentlemen, // is a celebration of C and C++ and their untamed passion... // ================== TerrainData terrain_info; // Now the actual stuff... // ======================= // this is all outrageously horrible, as we dont know what // we really need to deal with here // And if you thought the hack for papers was bad, // wait until you see the one for datas... - X // Returns whether or not in the humble opinion of the // sound system, the sample should be politely obliterated // out of existence // it's a wonderful world, with a lot of strange men // who are standing around, and they all wearing towels</span></span></code> </pre><br>  So sehen die Kommentare aus, die Entwickler in den letzten 90ern in Spielen hinterlassen haben ... Doug Church - ein Chefdesigner des Systemschocks - war übrigens auch damit beschäftigt, Code zu schreiben.  Wer weiß, vielleicht wurden einige dieser Kommentare von ihm geschrieben?  Hoffe, Männer in Handtüchern Zeug ist nicht seine Handarbeit :) <br><br><h2>  Fazit </h2><br>  Abschließend möchte ich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinen Kollegen</a> dafür danken, dass sie nach neuen Fehlern gesucht und in Artikeln darüber geschrieben haben.  Danke Jungs!  Ohne dich wäre dieser Artikel nicht so interessant. <br><br>  Außerdem möchte ich ein wenig über unsere Erfolge erzählen, da wir das ganze Jahr nicht nur mit der Suche nach Fehlern beschäftigt waren.  Wir haben auch den Analysator entwickelt und verbessert, was zu erheblichen Änderungen führte. <br><br>  Beispielsweise haben wir die Unterstützung mehrerer neuer Compiler hinzugefügt und die Liste der Diagnoseregeln erweitert.  Außerdem haben wir die erste Unterstützung der Standards <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MISRA C und MISRA C ++</a> implementiert.  Die wichtigste und zeitaufwändigste neue Funktion war die Unterstützung einer neuen Sprache.  Ja, wir können jetzt Code in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Java</a> analysieren!  Und außerdem haben wir ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">neues Symbol</a> :) <br><br>  Ich möchte auch unseren Lesern danken.  Vielen Dank, dass Sie unsere Artikel gelesen und uns geschrieben haben!  Sie sind so reaktionsschnell und für uns so wichtig! <br><br>  Unsere Top 10 C ++ - Fehler von 2018 sind zu Ende gegangen.  Welche Fragmente haben dir am besten gefallen und warum?  Sind Sie 2018 auf einige interessante Beispiele gestoßen? <br><br>  Alles Gute, bis zum nächsten Mal! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444568/">https://habr.com/ru/post/de444568/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444558/index.html">Was ist neu in CUBA 7?</a></li>
<li><a href="../de444560/index.html">Wir laden Sie zur Konferenz „Clouds. Modetrends ”26. März 2019</a></li>
<li><a href="../de444562/index.html">Modernisierung von GHIDRA. Lader für Rum Sega Mega Drive</a></li>
<li><a href="../de444564/index.html">Digitale Produktentwicklung mit mentalen Modellen</a></li>
<li><a href="../de444566/index.html">Sikorsky führte eine Demonstration eines unbemannten Hubschraubers mit einem Mann an Bord durch</a></li>
<li><a href="../de444570/index.html">Top 10 Fehler in C ++ - Projekten für 2018</a></li>
<li><a href="../de444572/index.html">Blinkende LED</a></li>
<li><a href="../de444574/index.html">Miniatur-Macintosh Plus</a></li>
<li><a href="../de444576/index.html">Wie das Typsystem Ihren JavaScript-Code verbessert</a></li>
<li><a href="../de444578/index.html">Referenten Top 3D Expo 2019: Yousef Hesuani von 3dbio - 3D-Druck von Organen und Geweben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>