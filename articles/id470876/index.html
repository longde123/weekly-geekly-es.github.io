<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔊 🌦️ 👨🏿‍🤝‍👨🏽 Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 1 🤵 👩🏼‍🚒 🔞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hari ini kami menerbitkan bagian pertama dari terjemahan materi, yang didedikasikan untuk membuat konstruksi sintaks Anda sendiri untuk JavaScript men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/470876/">  Hari ini kami menerbitkan bagian pertama dari terjemahan materi, yang didedikasikan untuk membuat konstruksi sintaks Anda sendiri untuk JavaScript menggunakan Babel. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/af/mm/2j/afmm2jwbgwm7bzi3nwdf3namowg.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ulasan</font> </h2><br>  Pertama, mari kita lihat apa yang akan kita capai ketika kita sampai pada akhir materi ini: <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  '@@'   `foo`   function @@ foo(a, b, c) {   return a + b + c; } console.log(foo(1, 2)(3)); // 6</span></span></code> </pre> <br>  Kami akan mengimplementasikan sintaks <code>@@</code> yang memungkinkan fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">currying</a> .  Sintaks ini mirip dengan yang digunakan untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi generator</a> , tetapi dalam kasus kami, alih-alih tanda <code>*</code> , urutan karakter <code>@@</code> ditempatkan antara kata kunci <code>function</code> dan nama <code>function</code> .  Akibatnya, saat mendeklarasikan fungsi, Anda bisa menggunakan konstruksi dari form <code>function @@ name(arg1, arg2)</code> . <br><br>  Dalam contoh di atas, ketika bekerja dengan fungsi <code>foo</code> , Anda dapat menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi parsialnya</a> .  Memanggil fungsi <code>foo</code> dengan melewatkannya begitu banyak parameter yang kurang dari jumlah argumen yang dibutuhkan, akan mengembalikan fungsi baru yang dapat mengambil argumen yang tersisa: <br><br><pre> <code class="javascript hljs">foo(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 6 const bar = foo(1, 2); // (n) =&gt; 1 + 2 + n bar(3); // 6</span></span></code> </pre> <br>  Saya memilih urutan karakter <code>@@</code> karena simbol <code>@</code> tidak dapat digunakan dalam nama variabel.  Ini berarti bahwa konstruk <code>function@@foo(){}</code> form <code>function@@foo(){}</code> juga akan benar secara sintaksis.  Selain itu, "operator" <code>@</code> digunakan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi dekorator</a> , dan saya ingin menggunakan sesuatu yang sama sekali baru.  Akibatnya, saya memilih konstruksi <code>@@</code> . <br><br>  Untuk mencapai tujuan kami, kami perlu melakukan tindakan berikut: <br><br><ul><li>  Buat garpu parser Babel. </li><li>  Buat plugin Babel Anda sendiri untuk transformasi kode. </li></ul><br>  Sepertinya ada yang mustahil? <br>  Faktanya, tidak ada yang mengerikan di sini, kami akan menganalisis semuanya secara detail bersama.  Saya harap ketika Anda membaca ini, Anda akan dengan ahli menguasai seluk-beluk Babel. <br><br><h2>  <font color="#3AC1EF">Membuat garpu Babel</font> </h2><br>  Pergi ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gudang</a> Babel di GitHub dan klik tombol <code>Fork</code> , yang terletak di kiri atas halaman. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adb/5d3/eff/adb5d3effaecdfaead72747dd75f6991.png"></div><br>  <i><font color="#999999">Membuat garpu Babel ( <a href="">gambar ukuran penuh</a> )</font></i> <br><br>  Dan omong-omong, jika Anda baru saja membuat garpu proyek open source populer untuk pertama kalinya - selamat! <br><br>  Sekarang kloning garpu Babel di komputer Anda dan <a href="">persiapkan untuk bekerja</a> . <br><br><pre> <code class="javascript hljs">$ git clone https:<span class="hljs-comment"><span class="hljs-comment">//github.com/tanhauhau/babel.git # set up $ cd babel $ make bootstrap $ make build</span></span></code> </pre> <br>  Sekarang izinkan saya berbicara secara singkat tentang pengaturan repositori Babel. <br><br>  Babel menggunakan monorepositori.  Semua paket (mis. <code>@babel/core</code> , <code>@babel/parser</code> , <code>@babel/plugin-transform-react-jsx</code> dan sebagainya) berada di <code>packages/</code> folder.  Ini terlihat seperti ini: <br><br><pre> <code class="javascript hljs">- doc - packages  - babel-core  - babel-parser  - babel-plugin-transform-react-jsx  - ... - Gulpfile.js - Makefile - ...</code> </pre> <br>  Saya perhatikan bahwa Babel menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Makefile</a> untuk mengotomatisasi tugas.  Saat membangun proyek dengan perintah <code>make build</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gulp</a> digunakan sebagai task manager. <br><br><h2>  <font color="#3AC1EF">Konversi Kode ke Kursus Singkat AST</font> </h2><br>  Jika Anda tidak terbiasa dengan konsep-konsep seperti "parser" dan "Pohon Sintaksis Abstrak" (AST), maka sebelum Anda melanjutkan membaca, saya sangat menyarankan Anda melihat materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> . <br><br>  Jika Anda berbicara dengan sangat singkat tentang apa yang terjadi ketika parsing (parsing) kode, Anda mendapatkan yang berikut ini: <br><br><ul><li>  Kode yang disajikan sebagai string (tipe <code>string</code> ) terlihat seperti daftar panjang karakter: <code>f, u, n, c, t, i, o, n, , @, @, f, ...</code> </li><li>  Pada awalnya, Babel melakukan tokenization kode.  Pada langkah ini, Babel memindai kode dan membuat token.  Misalnya, sesuatu seperti <code>function, @@, foo, (, a, ...</code> </li><li>  Kemudian token dilewatkan melalui parser untuk parsing mereka.  Di sini Babel, berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spesifikasi</a> bahasa JavaScript, membuat pohon sintaksis abstrak. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> sumber yang bagus untuk mereka yang ingin belajar lebih banyak tentang kompiler. <br><br>  Jika Anda berpikir bahwa "kompiler" adalah sesuatu yang sangat kompleks dan tidak dapat dipahami, maka ketahuilah bahwa pada kenyataannya semuanya tidak begitu misterius.  Kompilasi hanya menguraikan kode dan membuat kode baru atas dasar, yang akan kita sebut XXX.  Kode XXX dapat diwakili oleh kode mesin (mungkin, kode mesin adalah yang pertama kali muncul di benak sebagian besar dari kita ketika kita berpikir tentang kompiler).  Ini mungkin kode JavaScript yang kompatibel dengan browser lawas.  Sebenarnya, salah satu fungsi utama Babel adalah kompilasi JS-code modern menjadi kode yang dapat dimengerti oleh browser yang sudah ketinggalan zaman. <br><br><h2>  <font color="#3AC1EF">Mengembangkan parser Anda sendiri untuk Babel</font> </h2><br>  Kita akan bekerja di <code>packages/babel-parser/</code> folder: <br><br><pre> <code class="javascript hljs">- src/  - tokenizer/  - parser/  - plugins/    - jsx/    - typescript/    - flow/    - ... - test/</code> </pre> <br>  Kita sudah bicara tentang tokenization dan parsing.  Anda dapat menemukan kode yang mengimplementasikan proses ini di folder dengan nama yang sesuai.  <code>plugins/</code> folder berisi plugins (plug-in) yang memperluas kemampuan parser dasar dan menambahkan dukungan untuk sintaks tambahan ke dalam sistem.  Itulah tepatnya, misalnya, dukungan <code>jsx</code> dan <code>flow</code> diimplementasikan. <br><br>  Mari kita selesaikan masalah kita menggunakan teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengembangan melalui pengujian</a> (Test-driven development, TDD).  Menurut pendapat saya, yang paling mudah adalah menulis tes terlebih dahulu, dan kemudian, secara bertahap bekerja pada sistem, buat tes ini berjalan tanpa kesalahan.  Pendekatan ini sangat baik ketika bekerja di basis kode yang tidak dikenal.  TDD memudahkan untuk memahami di mana Anda perlu membuat perubahan pada kode untuk mengimplementasikan fungsi yang Anda inginkan. <br><br><pre> <code class="javascript hljs">packages/babel-parser/test/curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import</span></span></span><span class="hljs-function"> </span></span>{ parse } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../lib'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getParser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">code</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> parse(code, { <span class="hljs-attr"><span class="hljs-attr">sourceType</span></span>: <span class="hljs-string"><span class="hljs-string">'module'</span></span> }); } describe(<span class="hljs-string"><span class="hljs-string">'curry function syntax'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  it(<span class="hljs-string"><span class="hljs-string">'should parse'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{    expect(getParser(<span class="hljs-string"><span class="hljs-string">`function @@ foo() {}`</span></span>)()).toMatchSnapshot();  }); });</code> </pre> <br>  Anda dapat menjalankan tes untuk <code>babel-parser</code> seperti ini: <code>TEST_ONLY=babel-parser TEST_GREP="curry function" make test-only</code> .  Ini memungkinkan Anda melihat kesalahan: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">SyntaxError</span></span>: Unexpected token (<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>) at Parser.raise (packages/babel-parser/src/parser/location.js:<span class="hljs-number"><span class="hljs-number">39</span></span>:<span class="hljs-number"><span class="hljs-number">63</span></span>) at Parser.raise [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> unexpected] (packages/babel-parser/src/parser/util.js:<span class="hljs-number"><span class="hljs-number">133</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span>) at Parser.unexpected [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> parseIdentifierName] (packages/babel-parser/src/parser/expression.js:<span class="hljs-number"><span class="hljs-number">2090</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span>) at Parser.parseIdentifierName [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> parseIdentifier] (packages/babel-parser/src/parser/expression.js:<span class="hljs-number"><span class="hljs-number">2052</span></span>:<span class="hljs-number"><span class="hljs-number">23</span></span>) at Parser.parseIdentifier (packages/babel-parser/src/parser/statement.js:<span class="hljs-number"><span class="hljs-number">1096</span></span>:<span class="hljs-number"><span class="hljs-number">52</span></span>)</code> </pre> <br>  Jika Anda merasa bahwa melihat semua tes terlalu banyak waktu, Anda dapat, untuk menjalankan tes yang diinginkan, langsung menelepon <code>jest</code> : <br><br><pre> <code class="javascript hljs">BABEL_ENV=test node_modules/.bin/jest -u packages/babel-parser/test/curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span></span></code> </pre> <br>  Pengurai kami menemukan 2 <code>@</code> token, yang tampaknya sama sekali tidak bersalah, di mana seharusnya tidak. <br><br>  Bagaimana saya tahu itu?  Jawaban atas pertanyaan ini akan membantu kami menemukan penggunaan mode pemantauan kode yang diluncurkan oleh perintah <code>make watch</code> . <br><br>  Melihat tumpukan panggilan membawa kita ke <a href="">paket / babel-parser / src / parser / expression.js</a> , di mana pengecualian <code>this.unexpected()</code> dilemparkan. <br><br>  Tambahkan beberapa perintah masuk ke file ini: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/parser/expression.js parseIdentifierName(pos: number, liberal?: boolean): string {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.match(tt.name)) {    <span class="hljs-comment"><span class="hljs-comment">// ...  } else {    console.log(this.state.type); //      console.log(this.lookahead().type); //      throw this.unexpected();  } }</span></span></code> </pre> <br>  Seperti yang Anda lihat, kedua token adalah <code>@</code> : <br><br><pre> <code class="javascript hljs">TokenType {  <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">'@'</span></span>,  <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br>  Bagaimana saya mengetahui bahwa konstruksi <code>this.state.type</code> dan <code>this.lookahead().type</code> akan memberi saya token saat ini dan selanjutnya? <br>  Saya akan membicarakan hal ini di bagian materi yang dikhususkan untuk fungsi <code>this.eat</code> , <code>this.match</code> dan <code>this.next</code> . <br><br>  Sebelum melanjutkan, mari rangkum: <br><br><ul><li>  Kami menulis tes untuk <code>babel-parser</code> . </li><li>  Kami menjalankan tes menggunakan <code>make test-only</code> . </li><li>  Kami menggunakan mode pemantauan kode menggunakan <code>make watch</code> . </li><li>  Kami belajar tentang status pengurai dan <code>this.state.type</code> informasi tentang jenis token saat ini ( <code>this.state.type</code> ) di konsol. </li></ul><br>  Dan sekarang kami akan memastikan bahwa 2 <code>@</code> karakter tidak dianggap sebagai token terpisah, tetapi sebagai token <code>@@</code> baru, yang kami putuskan untuk digunakan untuk fungsi kari. <br><br><h2>  <font color="#3AC1EF">Token baru: "@@"</font> </h2><br>  Pertama, mari kita lihat di mana jenis token ditentukan.  Ini adalah <a href="">paket</a> file <a href="">/ babel-parser / src / tokenizer / types.js</a> . <br><br>  Di sini Anda dapat menemukan daftar token.  Tambahkan di sini definisi <code>atat</code> baru: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/tokenizer/types.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> types: { [name: string]: TokenType } = {  <span class="hljs-comment"><span class="hljs-comment">// ...  at: new TokenType('@'),  atat: new TokenType('@@'), };</span></span></code> </pre> <br>  Sekarang mari kita mencari tempat di kode di mana, dalam proses tokenization, token dibuat.  Mencari urutan karakter <code>tt.at</code> di <code>babel-parser/src/tokenizer</code> membawa kita ke file: <a href="">paket / babel-parser / src / tokenizer / index.js</a> .  Dalam <code>babel-parser</code> tipe token diimpor sebagai <code>tt</code> . <br><br>  Sekarang, jika setelah simbol <code>@</code> saat ini datang <code>@</code> lain, buat token <code>tt.atat</code> alih- <code>tt.at</code> token <code>tt.at</code> : <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/tokenizer/index.js getTokenFromCode(code: number): <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (code) {    <span class="hljs-comment"><span class="hljs-comment">// ...    case charCodes.atSign:      //    -  `@`      if (this.input.charCodeAt(this.state.pos + 1) === charCodes.atSign) {        //  `tt.atat`  `tt.at`        this.finishOp(tt.atat, 2);      } else {        this.finishOp(tt.at, 1);      }      return;    // ...  } }</span></span></code> </pre> <br>  Jika Anda menjalankan tes lagi, Anda akan melihat bahwa informasi tentang token saat ini dan selanjutnya telah berubah: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   TokenType {  label: '@@',  // ... } //   TokenType {  label: 'name',  // ... }</span></span></code> </pre> <br>  Itu sudah terlihat cukup bagus.  Kami akan melanjutkan pekerjaan. <br><br><h2>  <font color="#3AC1EF">Parser baru</font> </h2><br>  Sebelum melanjutkan, lihat bagaimana fungsi generator diwakili dalam AST. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ea/cc0/a9f/3eacc0a9fe1c5f780013f7d1d3d1ebe3.png"></div><br>  <i><font color="#999999">AST untuk fungsi generator ( <a href="">gambar ukuran penuh</a> )</font></i> <br><br>  Seperti yang Anda lihat, <code>generator: true</code> atribut <code>generator: true</code> dari entitas <code>FunctionDeclaration</code> menunjukkan bahwa ini adalah <code>FunctionDeclaration</code> generator. <br><br>  Kita dapat mengambil pendekatan serupa untuk menggambarkan fungsi yang mendukung currying.  Yaitu, kita dapat menambahkan atribut <code>curry: true</code> ke <code>FunctionDeclaration</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a6/056/e68/3a6056e68a6cd80fc136c6e010444d0b.png"></div><br>  <i><font color="#999999">AST untuk fungsi currying ( <a href="">gambar ukuran penuh</a> )</font></i> <br><br>  Sebenarnya, sekarang kami punya rencana.  Mari kita hadapi implementasinya. <br><br>  Jika Anda melihat kode untuk kata <code>FunctionDeclaration</code> , Anda dapat pergi ke fungsi <code>parseFunction</code> , yang dideklarasikan dalam <a href="">paket / babel-parser / src / parser / statement.js</a> .  Di sini Anda dapat menemukan garis tempat atribut <code>generator</code> diatur.  Tambahkan baris lain ke kode: <br><br><pre> <code class="javascript hljs">packages/babel-parser/src/parser/statement.js <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatementParser</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionParser</span></span></span><span class="hljs-class"> </span></span>{  <span class="hljs-comment"><span class="hljs-comment">// ...  parseFunction&lt;T: N.NormalFunction&gt;(    node: T,    statement?: number = FUNC_NO_FLAGS,    isAsync?: boolean = false  ): T {    // ...    node.generator = this.eat(tt.star);    node.curry = this.eat(tt.atat);  } }</span></span></code> </pre> <br>  Jika kita menjalankan tes lagi, kejutan yang menyenangkan akan menunggu kita.  Kode berhasil diuji! <br><br><pre> <code class="javascript hljs">PASS packages/babel-parser/test/curry-<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">js</span></span></span><span class="hljs-function">  </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">curry</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">syntax</span></span></span><span class="hljs-function">    ✓ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">should</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">12</span></span></span></span><span class="hljs-function"><span class="hljs-params">ms</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br>  Hanya itu semua  Apa yang telah kami lakukan untuk membuat ujian lulus secara ajaib? <br><br>  Untuk mengetahuinya, mari kita bicara tentang cara kerja parsing.  Dalam perjalanan percakapan ini, saya harap Anda akan mengerti bagaimana garis <code>node.curry = this.eat(tt.atat);</code>  . <br><br>  Dilanjutkan ... <br><br>  <b>Pembaca yang budiman!</b>  Apakah Anda menggunakan babel? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id470876/">https://habr.com/ru/post/id470876/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id470864/index.html">Tentang kelezatan beralih ke panel dan tidak hanya</a></li>
<li><a href="../id470868/index.html">Waktu untuk byte pertama: apa itu dan mengapa itu penting</a></li>
<li><a href="../id470870/index.html">Prapemuat Font</a></li>
<li><a href="../id470872/index.html">Metrik kinerja untuk meneliti aplikasi web yang sangat cepat</a></li>
<li><a href="../id470874/index.html">Mengoptimalkan pemuatan JavaScript di Wikipedia</a></li>
<li><a href="../id470878/index.html">Buat konstruksi sintaks JavaScript khusus menggunakan Babel. Bagian 2</a></li>
<li><a href="../id470880/index.html">Mekanik game. Petualangan, konsep terapi bicara nol dan menarik</a></li>
<li><a href="../id470882/index.html">Mengapa Anda menangkap mouse saya, atau permainan papan sebagai model interaksi sosial</a></li>
<li><a href="../id470884/index.html">Menulis dan membaca data dalam blockchain Bitcoin</a></li>
<li><a href="../id470888/index.html">Undang-undang Rusia dan internasional di bidang perlindungan data pribadi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>