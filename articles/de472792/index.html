<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê∞ ‚úåüèª üê® Computer basierend auf NOR-Ventilen: im integrierten Bordcomputer von Apollo ‚ú≥Ô∏è üåª üë®üèº‚Äçüéì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor kurzem haben wir uns mit der Wiederherstellung des Apollo-Bordsteuerungscomputers befasst, der f√ºr die Steuerung, Navigation und √úberwachung an Bo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Computer basierend auf NOR-Ventilen: im integrierten Bordcomputer von Apollo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472792/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vor kurzem haben wir uns mit der Wiederherstellung des</a> Apollo-Bordsteuerungscomputers befasst, der f√ºr die Steuerung, Navigation und √úberwachung an Bord von Apollo-Missionen verantwortlich war, die zum Mond fliegen.  Dieser historische Computer war einer der ersten, der integrierte Schaltkreise (ICs) verwendete, und sein Prozessor war vollst√§ndig auf NOR-Ventilen aufgebaut (der zweite IC-Typ, ein Ausleseverst√§rker, wurde im Speicher des Computers verwendet).  In diesem Artikel werde ich die Architektur und das Design der CPU beschreiben. <br><br><h2>  Apollo Control Computer Architektur </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/f69/7d2/d2b/f697d2d2bad17f528a245a0043e2ce90.jpg"><br>  <i>Getrennte F√§cher des Apollo-Steuercomputers.</i>  <i>Das linke Fach enth√§lt Logik basierend auf NOR-Gattern.</i>  <i>Rechts - Speicher- und Hilfskomponenten.</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der</a> Apollo Guidance Computer (AGC) wurde in den 1960er Jahren entwickelt, damit Apollo-Missionen zum Mond fliegen k√∂nnen.  Zu einer Zeit, als die meisten Computer Platz von einem gro√üen K√ºhlschrank bis zu einem ganzen Raum beanspruchten, war die AGC etwas Einzigartiges - sie war klein genug, um an Bord des Apollo-Raumfahrzeugs zu passen, wog 32 kg und nahm nicht mehr als 0,03 m ein <sup>3</sup> (30 Liter). <br><a name="habracut"></a><br>  Der AGC-Computer ist 15-Bit.  Es ist seltsam, eine Wortgr√∂√üe zu treffen, die keine Zweierpotenz ist, aber in den 1960er Jahren, noch bevor Bytes popul√§r wurden, verwendeten Computer eine Vielzahl von Wortgr√∂√üen.  15 Bit lieferten eine ausreichende Genauigkeit f√ºr die Landung auf dem Mond (und verwendeten Daten bei Bedarf mit doppelter und dreifacher Genauigkeit), sodass 16 Bit die Gr√∂√üe und das Gewicht des Computers einfach unn√∂tig erh√∂hen w√ºrden. <br><br>  Der AGC-Befehl befand sich in einem 15-Bit-Wort und bestand aus 3 Bits, die den Operationscode angaben, und 12 Bits, die die Adresse im Speicher angaben.  Leider reichten diese Volumes immer noch nicht aus, sodass der Computer zahlreiche Tricks und Problemumgehungen verwendete und sich die Architektur als ziemlich umst√§ndlich herausstellte.  Eine 12-Bit-Speicheradresse konnte nur auf 4K-W√∂rter zugreifen.  Zur gleichen Zeit hatte AGC 2K W√∂rter im Hauptspeicher und 36K W√∂rter im Kernspeicher.  Um auf den gesamten Speicher zuzugreifen, verwendete AGC ein ausgekl√ºgeltes Speicherbank-Schaltsystem und mehrere Register.  Mit anderen Worten, auf den Speicher konnte nur in Teilen von 256 W√∂rtern und auf den ROM zugegriffen werden - in Teilen von etwas gr√∂√üerer Gr√∂√üe. <br><br>  3 Bits f√ºr den Operationscode reichten nicht aus, um 34 m√∂gliche Befehle direkt anzuzeigen. Daher verwendete AGC Tricks mit der Erweiterung des Befehlswertes und der Tatsache, dass einige Befehle sinnvoll waren, nur mit bestimmten Speicherzellen ausgef√ºhrt zu werden.  Dar√ºber hinaus wurden Tricks wie "magische" Adressen im Speicher verwendet. Beispielsweise wurde beim Schreiben in die Zelle "Rechtsverschiebung" eine bitweise Verschiebung durchgef√ºhrt, sodass keine separate Anweisung "Rechtsverschiebung" erforderlich war.  Es gab auch Anweisungen, die mehrere Aktionen gleichzeitig kombinierten. <br><br>  Die AGC-Architektur war selbst f√ºr die Standards der 1960er Jahre ziemlich einfach.  Obwohl es in einer Zeit komplexer und leistungsf√§higer Mainframes entwickelt wurde, waren die F√§higkeiten von AGC sehr begrenzt.  In Bezug auf Leistung und Architektur ist es vergleichbar mit fr√ºhen Mikroprozessoren.  Seine St√§rken waren seine kompakte Gr√∂√üe und die gro√üartigen M√∂glichkeiten zur Eingabe und Ausgabe von Daten in Echtzeit. <br><br>  Das folgende Architekturdiagramm zeigt die Hauptkomponenten der AGC.  Ich habe die Teile, auf die ich n√§her eingehen m√∂chte, farblich hervorgehoben.  AGC hatte einen kleinen Satz von Registern und ein einfaches Arithmetikmodul, das sich nur mit Addition befasste.  Er hatte nur 36K W√∂rter ROM und 2K W√∂rter RAM.  Der ‚ÄûSchreibbus‚Äú war die Hauptmethode f√ºr die Daten√ºbertragung zwischen Komponenten.  Decodierungsanweisungen und ein Sequenzgenerator erzeugten Steuerimpulse f√ºr die AGC. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/60b/5fa/3e1/60b5fa3e19a473055f9364fac1df8e88.jpg"><br>  <i>AGC-Blockdiagramm</i> <br><br>  Etwa die H√§lfte des Diagramms ist mit Speicher belegt, was die Tatsache widerspiegelt, dass die AGC-Architektur in vielerlei Hinsicht um ihren Speicher herum entwickelt wurde.  Wie die meisten Computer in den 1960er Jahren verwendete AGC Kernspeicher und speicherte jedes Bit in einem winzigen Ferritring (Kern), der auf einem Drahtgeflecht aufgereiht war.  Da jedes Bit einen separaten physikalischen Kern ben√∂tigte, war die Menge eines solchen Speichers radikal geringer als die eines modernen Halbleiters.  Ein charakteristisches Merkmal des Speichers auf den Kernen war, dass das Lesen eines Wortes aus dem Speicher es l√∂schte, sodass dieser Wert nach jedem Zugriff neu geschrieben werden musste.  AGC hatte auch einen festen ROM-Speicher, die ber√ºhmten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusammengef√ºgten Kerne</a> - sie wurden zum Speichern von Programmen verwendet und physisch mit Dr√§hten zusammengef√ºgt (siehe unten). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef2/724/d84/ef2724d84b9c6240b02427fc24ef3a83.jpg"><br>  <i>Nahaufnahme Speicher auf gen√§hten Kernen</i> <br><br><h2>  NOR-Ventile </h2><br>  AGC war einer der ersten Computer, die IP verwendeten.  Die M√∂glichkeiten dieser ersten IPs waren sehr begrenzt;  Auf AGC-Chips (unten) gab es nur sechs Transistoren und acht Widerst√§nde, und zusammen implementierten sie ein NOR-Gatter mit drei Eing√§ngen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/258/c26/1f6/258c261f6d06ff7537280d6205631ec3.jpg"><br>  <i>Doppel-NOR-Ventil mit drei Eing√§ngen von AGC.</i>  <i>Zehn Dr√§hte au√üerhalb des Kristalls sind mit den externen Kontakten des IC verbunden.</i> <br><br>  Die schematische Bezeichnung des NOR-Ventils ist unten gezeigt.  Dies ist das einfachste Logikgatter: Wenn alle Eing√§nge gleich Null sind, ist der Ausgang gleich Eins.  Sie werden √ºberrascht sein, aber ein NOR-Gatter reicht aus, um einen Computer zu erstellen.  NOR ist ein Universalventil: Jedes andere logische Ventil kann auf seiner Basis hergestellt werden.  Wenn wir zum Beispiel alle NOR-Eing√§nge kombinieren, erhalten wir einen Inverter.  Nachdem wir den Wechselrichter am Ausgang des NOR platziert haben, erhalten wir ein ODER-Ventil.  Durch Platzieren der Inverter an den Eing√§ngen des NOR-Gatters erhalten wir ein UND-Gatter.  Und aus diesen Toren k√∂nnen Sie eine komplexere Logik erstellen: Trigger, Addierer und Z√§hler. <br><br>  Das NAND-Ventil hat die gleiche Vielseitigkeit.  In modernen Schaltungen werden aus technischen Gr√ºnden NANDs h√§ufiger verwendet als NORs.  Im beliebten Kurs " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Von NAND zu Tetris</a> " wird beschrieben, wie man einen Computer aus NAND-Ventilen bis zur Implementierung des Spiels "Tetris" erstellt.  Zun√§chst wird ein Satz von Logikgattern aus NAND aufgebaut (NOT, AND, OR, XOR, Multiplexer, Demultiplexer).  Dann werden gr√∂√üere Bausteine ‚Äã‚Äãaus ihnen (Trigger, Addierer, Z√§hler, ALU, Register) und aus ihnen - einem Computer - erstellt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/508/de6/6ef/508de66ef3b9b88d05adc5f216b91be1.jpg"><br>  <i>Das NOR-Gatter gibt 1, wenn es an allen Eing√§ngen 0 hat. Wenn mindestens einer der Eing√§nge 1 hat, gibt das NOR 0.</i> <br><br>  Sehr h√§ufig st√∂√üt AGC auf eine Komponente wie den RS-Trigger (Set-Reset, Set / Reset).  Diese Schaltung besteht aus zwei NOR-Gattern und speichert ein Datenbit.  Bit 1 wird am gesetzten Eingang gespeichert, und Bit 0 wird am zur√ºckgesetzten Eingang gespeichert. Das hei√üt, Impuls 1, der an den eingestellten Eingang angelegt wird, schaltet das obere Ventil aus und das untere ein, so dass Ausgang 1 ausf√§llt. Impuls 1, der an den zur√ºckgesetzten Eingang angelegt wird, bewirkt das Gegenteil .  Wenn an beiden Eing√§ngen 0 angewendet wird, merkt sich der Trigger seinen vorherigen Zustand und spielt die Rolle eines Laufwerks.  Im n√§chsten Abschnitt zeigen wir, wie Register aus einem Trigger erstellt werden. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0a/0a2/0b4/e0a0a20b41a43e4e9ceb701b27d6719b.jpg"><br>  <i>RS-Trigger von zwei NOR-Gattern.</i>  <i>Wenn ein Ventil eingeschaltet ist, schaltet es das andere aus.</i>  <i>Eine Linie √ºber einem der Ausg√§nge zeigt an, dass sie den anderen erg√§nzt.</i> <br><br><h2>  Register </h2><br>  AGC verf√ºgt √ºber einen kleinen Registersatz zur tempor√§ren Speicherung von Werten au√üerhalb des Hauptspeichers.  Das Hauptregister ist das Laufwerk (A), das in vielen arithmetischen Operationen verwendet wird.  Es hat auch ein Z√§hlerregister Z, arithmetische Blockregister X und Y, Puffer B, R√ºcksprungadresse Q und einige andere (in modernen Computern wird der Stapel verwendet, um Routinen aufzurufen und von diesen zur√ºckzukehren, aber in dieser √Ñra mussten Programmierer den Stapel selbst f√ºr die Rekursion schreiben )  F√ºr den Zugriff auf den Speicher gibt es ein Speicheradressregister S und f√ºr Daten ein Speicherpufferregister G. Au√üerdem hat die AGC Register im Hauptspeicher - zum Beispiel Eingabe- / Ausgabez√§hler. <br><br>  Das folgende Diagramm zeigt das f√ºr den Fall mit einem Bit und zwei Registern vereinfachte AGC-Registerschema.  Jedes Registerbit hat einen Trigger unter Verwendung des zuvor beschriebenen Schemas (blau und lila).  Daten werden √ºber den Schreibbus (rot) zu und von den Registern √ºbertragen.  Um in das Register zu schreiben, wird der Trigger durch ein L√∂schsignal (CQG oder CZG, gr√ºn) zur√ºckgesetzt.  Dann erm√∂glicht das "Schreib" -Signal (WQG oder WZG, orange) den Daten, die entlang des Schreibbusses gehen, den entsprechenden Registerausl√∂ser zu setzen.  Zum Lesen des Registers leitet das Lesesignal (RQG oder RZG, Cyan) den Triggerausgang √ºber den Aufzeichnungsverst√§rker an den Aufzeichnungsbus weiter und wird in anderen Teilen der AGC verwendet.  Das vollst√§ndige Registerschema ist komplexer, es hat mehrere 16-Bit-Register, aber das Grundschema ist wie folgt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/574/2d6/2dd5742d6a82569618121f3a6382fefc.jpg"><br>  <i>Vereinfachte AGC-Registeroperation</i> <br><br>  Das Registerdiagramm zeigt drei wichtige Punkte.  Erstens wird die Registerschaltung aus NOR-Gattern aufgebaut.  Zweitens wird die Datenbewegung um den Schreibbus herum aufgebaut.  Schlie√ülich h√§ngen die Aktionen der Register von bestimmten Steuersignalen ab, die zum richtigen Zeitpunkt eintreffen. <br><br><h2>  Rechenmodul </h2><br>  Die meisten Computer verf√ºgen √ºber ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">arithmetisches Logikger√§t</a> , das arithmetische und boolesche Operationen ausf√ºhrt.  Im Vergleich zu modernen Computern ist das arithmetische Modul von AGC sehr begrenzt: Es addiert nur 16-Bit-Gr√∂√üen, daher wird es als arithmetisches Modul und nicht als arithmetisch-logisches Modul bezeichnet (der Rest der Operationen wird durch verschiedene Tricks ausgef√ºhrt, zum Beispiel wird die Subtraktion durch Addition durchgef√ºhrt, bevor f√ºr eines der Argumente werden die Bits umgekehrt usw.). <br><br>  Das folgende Diagramm zeigt ein Bit des AGC-Arithmetikmoduls.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Volladdierer</a> (rot) berechnet die Summe von zwei Bits und √úbertrag.  Die √úbertragung wird an den n√§chsten Addierer √ºbertragen. Auf diese Weise k√∂nnen sie kombiniert werden, um l√§ngere W√∂rter hinzuzuf√ºgen (um die √úbertragung von √úbertragungen in F√§llen wie 111111111111111 + 1 zu beschleunigen, verwendet AGC einen Addierer mit einem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√úbertragungssprung</a> ). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a7/a6d/054/4a7a6d0548b3ea363789cbe7fb49e63c.jpg"><br><br>  Die Register X und Y (lila und gr√ºn) stellen dem Addierer zwei Eingangsbits zur Verf√ºgung.  Sie werden mit den bereits an NOR-Ventilen beschriebenen Triggern implementiert.  Die blaue Schleife schreibt die Werte gem√§√ü den Steuersignalen in die X- und Y-Register.  Das Schema ist ziemlich kompliziert, da es Ihnen erm√∂glicht, Konstanten und Werte mit einer Verschiebung der Register zu speichern, aber ich werde nicht auf dieses Thema eingehen.  Achten Sie auf das Steuersignal A2X, das den Wert von Register A an Register X √ºbertr√§gt;  Wir werden sp√§ter auf ihn zur√ºckkommen. <br><br>  Das Foto unten zeigt die physikalische Implementierung der AGC-Schaltung.  Dieses Modul implementiert vier Bits f√ºr Register und ein Arithmetikmodul.  Schwarze Rechtecke sind flache IPs.  Jedes Modul verf√ºgt √ºber zwei Karten mit jeweils 60 Chips und insgesamt 240 NOR-Gattern.  Das arithmetische Modul und die Register sind aus vier identischen Modulen zusammengesetzt, von denen jedes vier Bits verarbeitet;  Dies √§hnelt dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mikroprozessorabschnitt</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec2/b20/51a/ec2b2051a591e1444a970d0c6eb21a3b.jpg"><br>  <i>Das Rechenmodul und die Register bestehen aus vier identischen Modulen.</i>  <i>Module werden in Steckpl√§tzen von A8 bis A11 installiert.</i> <br><br><h2>  Befehlsausf√ºhrung </h2><br>  Dieser Abschnitt beschreibt die Abfolge von Operationen, die die AGC ausf√ºhrt, um die Anweisung auszuf√ºhren.  Insbesondere werde ich zeigen, wie die Anweisung ADS (Add to Storage) funktioniert.  Dieser Befehl liest den Wert aus dem Speicher, f√ºgt ihn dem Laufwerk hinzu (Register A) und speichert die Summe sowohl im Addierer als auch im Speicher.  Dies ist eine einzelne Anweisung, aber f√ºr ihre Ausf√ºhrung unternimmt AGC mehrere Schritte und viele Werte werden hier und da verschoben. <br><br>  Der Befehlszeitgeber ist aufgrund des Speichersubsystems auf Magnetkernen implementiert.  Insbesondere beim Lesen eines Werts aus dem Speicher wird der gespeicherte Wert gel√∂scht, sodass der Wert nach jedem Lesen zur√ºckgeschrieben werden muss.  Auch beim Zugriff auf den Speicher gibt es eine Verz√∂gerung zwischen der Angabe der Adresse und dem Empfang von Daten.  Infolgedessen ben√∂tigt jeder Taktzyklus 12 Schritte zum Lesen und anschlie√üenden Aufzeichnen.  Jedes Zeitintervall (von T1 bis T12) dauert etwas weniger als Mikrosekunden, und der gesamte Zyklus dauert 11,7 Œºs und wird als Speicherzykluszeit (MCT) bezeichnet. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d96/839/08a/d9683908aea50b1f70485d0e787cdfb5.jpg"><br>  <i>L√∂schbares Magnetkern-Speichermodul von AGC.</i>  <i>Es speichert 2 Kilobl√§tter, jedes Bit wird unter Verwendung eines separaten winzigen Ferritrings gespeichert.</i> <br><br>  MCT ist die grundlegende Speichereinheit f√ºr die Ausf√ºhrung von Anweisungen.  Ein typischer Befehl erfordert zwei Taktzyklen: einen zum Extrahieren des Befehls aus dem Speicher, den zweiten zum Ausf√ºhren der Operation.  Daher ben√∂tigt ein typischer Befehl zwei MCTs (23,4 Œºs), was 43.000 Anweisungen pro Sekunde ergibt (im Vergleich zu modernen Prozessoren und ihren Milliarden von Anweisungen pro Sekunde ist dies extrem langsam). <br><br>  AGC verarbeitet Anweisungen und unterteilt sie in Unterbefehle, von denen jeder einen Taktzyklus des Speichers ben√∂tigt.  Ein ADS-Befehl besteht beispielsweise aus zwei Unterbefehlen: ADS0 (Addition) und STD2 (Aufruf des n√§chsten Befehls).  Das folgende Diagramm zeigt die Bewegung von Daten innerhalb der AGC, um den ADS0-Befehl auszuf√ºhren.  12 Takte gehen von links nach rechts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/48f/cca/d82/48fccad826389951d668d809754c5fcf.jpg"><br><br>  Die wichtigsten Schritte sind wie folgt: <br>  T1: Die Operandenadresse wird aus dem Befehlsregister B in das Speicheradressregister S kopiert, um mit dem Lesen aus dem Speicher zu beginnen. <br>  T4: Der Operand wird von Speicher zu Speicherdatenregister G gelesen. <br>  T5: Der Operand wird von G auf Addierer Y kopiert. Der Wert von Laufwerk A wird auf Addierer X kopiert. <br>  T6: Der Addierer berechnet die Summe U und kopiert sie in das Datenregister des Speichers G. <br>  T8: Der Programmz√§hler Z wird in Vorbereitung auf den Empfang des n√§chsten Befehls aus dem Speicher in das Speicheradressregister S kopiert. <br>  T10: Die Summe aus dem Datenregister des Speichers G wird in den Speicher zur√ºckgeschrieben. <br>  T11: Betrag U wird auf Laufwerk A kopiert. <br><br>  Obwohl dies eine einfache Summierungsanweisung ist, werden hier √ºber 12 Zeitschlitze immer wieder viele Daten √ºbertragen.  Und jeder dieser Aktionen ist ein bestimmtes Steuersignal zugeordnet;  Beispielsweise kopiert das Signal A2X im Intervall T5 den Wert von Antrieb A in Register X. Um Register G in Register Y zu kopieren, sind zwei Steuerimpulse erforderlich: RG (Lesen von G) und WY (Schreiben von Y).  Im n√§chsten Abschnitt werde ich erkl√§ren, wie das AGC-Steuermodul die erforderlichen Steuersignale f√ºr jeden Befehl erzeugt. <br><br><h2>  Steuermodul </h2><br>  Wie die meisten Computer decodiert das AGC-Steuermodul jeden Befehl und erzeugt Steuersignale, die dem Rest des Prozessors mitteilen, was zu tun ist.  Die AGC verwendet ein vorprogrammiertes Steuermodul, das aus NOR-Ventilen besteht, um Signale zu erzeugen.  AGC verwendet keinen Mikrocode.  Er hat keine Mikrobefehle und kein Kontrollged√§chtnis, da dies zu viel physischen Platz beanspruchen w√ºrde. <br><br>  Das Herzst√ºck des AGC-Steuermoduls wird als Crosspoint-Generator bezeichnet.  Es ben√∂tigt einen Unterbefehl und einen der Zeitr√§ume und generiert Steuersignale f√ºr diese Kombination.  Man kann es sich in Form eines Gitters vorstellen, auf dem Unterbefehle in eine Richtung und Zeitsegmente in die andere Richtung verlaufen und jeder der Schnittpunkte sein eigenes Steuersignal hat. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/823/4c6/65d/8234c665d5ef9aa344ac6b36aa34ac03.jpg"><br>  <i>Der Kreuzungsgenerator ben√∂tigt viele Komponenten und ist in drei Module unterteilt.</i>  <i>Dies ist das A6-Modul.</i>  <i>Achten Sie auf die hinzugef√ºgten Dr√§hte, die den Stromkreis ver√§ndern.</i>  <i>Dies ist eine fr√ºhe Version eines Moduls zum Testen vor Ort.</i>  <i>Flugmodule hatten bereits keine Dr√§hte.</i> <br><br>  Aus Effizienzgr√ºnden ist das Stellgliedmodul stark optimiert.  Anweisungen mit √§hnlichem Verhalten werden vom Kreuzungsgenerator kombiniert und verarbeitet, wodurch die Gr√∂√üe der erforderlichen Schaltung verringert wird.  Zum Beispiel hat AGC die Anweisung "Hinzuf√ºgen zu einem Laufwerk mit doppelter Genauigkeit" (DAS).  Da dies ungef√§hr zwei Additionen einzelner W√∂rter entspricht, haben die Unterbefehle DAS1 und ADS0 im Schnittstellengenerator eine gemeinsame Logik.  Das folgende Diagramm zeigt die Kreuzungsgeneratorschaltung f√ºr das Zeitintervall T5, und die Logik des ADS0-Unterbefehls (unter Verwendung des Signals DAS1) ist hervorgehoben.  Beispielsweise wird ein 5K-Signal aus einer Kombination von DAS1 und T5 erzeugt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2fa/632/0c8/2fa6320c814c37539e39b105502c520c.jpg"><br><br>  Aber was sind 5K- und 5L-Signale?  Dies ist eine weitere Optimierung.  Viele Steuerimpulse werden h√§ufig zusammengef√ºhrt. Anstatt sie direkt zu erzeugen, erzeugt der Kreuzungsgenerator Zwischensignale f√ºr Kreuzungen.  Beispielsweise erzeugt 5K Steuerimpulse A2X und RG und 5L erzeugt Steuerimpulse WY.  Das folgende Diagramm zeigt, wie das A2X-Signal erzeugt wird: Jedes der 8 verschiedenen Signale (einschlie√ülich 5K) erzeugt A2X.  √Ñhnliche Schaltungen erzeugen andere Steuersignale.  Diese Optimierungen erm√∂glichten es, die Gr√∂√üe des Kreuzungsgenerators zu reduzieren, aber er blieb immer noch gro√ü und wuchs auf bis zu drei Module an. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6f/1eb/3fe/f6f1eb3fef7bf5a9501721d41fbf0384.jpg"><br><br>  Zusammenfassend k√∂nnen wir sagen, dass das Steuermodul daf√ºr verantwortlich ist, der CPU mitzuteilen, was zu tun ist, um die Anweisung auszuf√ºhren.  Zun√§chst werden Anweisungen in Unterbefehle unterteilt.  Der Kreuzungsgenerator erzeugt die erforderlichen Steuerimpulse f√ºr jedes Zeitintervall und jeden Unterbefehl und teilt den Registern, dem Rechenmodul und dem Speicher mit, was sie tun m√ºssen. <br><br>  Normalerweise bestanden Anweisungen aus zwei Unterbefehlen, es gab jedoch Ausnahmen.  Einige der Anweisungen, wie Multiplikation oder Division, erforderten die Verwendung vieler Unterbefehle, da sie aus vielen Schritten bestanden.  Umgekehrt verwendete der Sprungbefehl bei TC einen Unterbefehl, da nur der n√§chste Befehl aufgerufen werden musste. <br><br>  Andere Prozessoren verwendeten andere Ans√§tze zur Erzeugung von Steuersignalen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6502 und viele andere fr√ºhe Mikroprozessoren decodierten Anweisungen unter Verwendung eines programmierbaren Logikarrays (PLA), das UND / ODER-Logik √ºber einen Nur-Lese-Speicher implementiert. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/7f2/5cc/744/7f25cc7445e19ed5166871137f09ef45.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mikroprozessor 6502.</font></font></i> <br><br><h2>  Fazit </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war eine aufregende Tour durch den Apollo-Bordsteuerungscomputer. Um es nicht zu stark zu dehnen, konzentrierte ich mich auf die ADS-Additionsanweisungen und einige Steuerimpulse (A2X, RG und WY). Ich hoffe, Sie haben eine Idee, wie Sie einen Computer aus so primitiven Elementen wie NOR-Ventilen zusammenbauen k√∂nnen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der sichtbarste Teil der Architektur ist der Datenpfad: ein Rechenmodul, Register und ein Datenbus. AGC-Register basieren auf einfachen Triggern von NOR-Gattern. Und obwohl das AGC-Arithmetikmodul nur Additionen ausf√ºhren kann, kann der Computer dennoch den gesamten Satz von Operationen verarbeiten, einschlie√ülich Multiplikations-, Divisions- und Boolescher Operationen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Datenpfad ist jedoch nur ein Teil des Computers. </font><font style="vertical-align: inherit;">Neben anderen kritischen Komponenten gibt es ein Steuermodul, das den Komponenten mitteilt, was sie tun m√ºssen. </font><font style="vertical-align: inherit;">Der in AGC verwendete Ansatz basiert auf einem Kreuzungsgenerator, der eine hochoptimierte und fest codierte Logik verwendet, um die richtigen Steuerimpulse f√ºr bestimmte Unterbefehle und Zeitintervalle zu erzeugen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit diesen F√§higkeiten lieferte die AGC F√ºhrung, Navigation und Kontrolle an Bord von Apollo-Missionen und erm√∂glichte die Landung auf dem Mond. </font><font style="vertical-align: inherit;">Er spornte auch die fr√ºhe Industrie f√ºr integrierte Schaltkreise an, die 1963 60% der in den USA hergestellten ICs verwendeten. Daher haben moderne Computer AGC und seinen einfachen NOR-Komponenten viel zu verdanken. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4a0/698/fe2/4a0698fe2f8ad8f4717d966bffc3a3e4.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AGC arbeitet in einem Labor, das an ein altes Tektronix-Oszilloskop angeschlossen ist</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472792/">https://habr.com/ru/post/de472792/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472776/index.html">Backup Teil 7: Schlussfolgerungen</a></li>
<li><a href="../de472778/index.html">5 M√∂glichkeiten, den Raspberry Pi zu verwenden</a></li>
<li><a href="../de472780/index.html">Warum Freunde meiden oder wie ich alle meine Vorteile verloren habe?</a></li>
<li><a href="../de472782/index.html">Warum 3D-Kopfschmerzen / Teil 8 Defokussierung und die Zukunft von 3D</a></li>
<li><a href="../de472790/index.html">Antiquit√§ten: i-Mate Jasjar, ein Kommunikator f√ºr Unternehmen</a></li>
<li><a href="../de472796/index.html">JA zuckt FAANG * oder [praktischer Leitfaden] bei der Jobsuche in den USA / Europa f√ºr IT-Spezialisten zusammen</a></li>
<li><a href="../de472798/index.html">Yandex-Karten f√ºr Taxi-Anwendung</a></li>
<li><a href="../de472802/index.html">MIRO ist eine offene Indoor-Roboterplattform. Teil 2 - Roboterdesign</a></li>
<li><a href="../de472810/index.html">An den Anfang Systemadministrator: Wie man Ordnung aus dem Chaos macht</a></li>
<li><a href="../de472812/index.html">L√∂scht der Server, wenn der Rauchtest des Rechenzentrums ‚ÄûFeuer gefangen‚Äú hat?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>