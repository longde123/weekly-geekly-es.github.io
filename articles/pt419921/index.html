<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûï üö£üèº üèçÔ∏è Como perder 10 milh√µes de pacotes por segundo üèµÔ∏è üë©üèº‚Äçü§ù‚Äçüë®üèª üë®üèº‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na empresa, nossa equipe para combater ataques DDoS √© chamada de "conta-gotas de pacotes". Enquanto todas as outras equipes est√£o fazendo coisas legai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como perder 10 milh√µes de pacotes por segundo</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419921/"> Na empresa, nossa equipe para combater ataques DDoS √© chamada de "conta-gotas de pacotes".  Enquanto todas as outras equipes est√£o fazendo coisas legais com o tr√°fego que passa pela nossa rede, nos divertimos encontrando novas maneiras de nos livrarmos dele. <br><br><img src="https://habrastorage.org/webt/s-/3y/un/s-3yun8pllqd7-e077fuxbk9jiw.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Brian Evans</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CC BY-SA 2.0</a></i> <br><br>  A capacidade de descartar pacotes rapidamente √© muito importante na oposi√ß√£o a ataques DDoS. <br><br>  Os pacotes descartados que chegam aos nossos servidores podem ser executados em v√°rios n√≠veis.  Cada m√©todo tem seus pr√≥s e contras.  Sob o corte, olhamos para tudo o que testamos. <br><a name="habracut"></a><br><blockquote>  <i>Nota do tradutor: na sa√≠da de alguns dos comandos apresentados, foram removidos espa√ßos extras para manter a legibilidade.</i> </blockquote><h1>  Site de teste </h1><br>  Para a conveni√™ncia de comparar os m√©todos, forneceremos alguns n√∫meros, no entanto, n√£o os leve muito literalmente, devido √† artificialidade dos testes.  Usaremos uma de nossas placas de rede Intel 10Gb / s.  As caracter√≠sticas restantes do servidor n√£o s√£o t√£o importantes, porque queremos nos concentrar nas limita√ß√µes do sistema operacional, n√£o no hardware. <br><br>  Nossos testes ter√£o a seguinte apar√™ncia: <br><br><ul><li>  Criamos uma carga enorme de pacotes UDP pequenos, atingindo um valor de 14 milh√µes de pacotes por segundo; </li><li>  Todo esse tr√°fego √© direcionado para um n√∫cleo de processador do servidor selecionado; </li><li>  Medimos o n√∫mero de pacotes processados ‚Äã‚Äãpelo kernel em um √∫nico n√∫cleo do processador. </li></ul><br>  O tr√°fego artificial √© gerado de forma a criar carga m√°xima: endere√ßo IP aleat√≥rio e porta do remetente s√£o usados.  Isto √© o que parece no tcpdump: <br><br><pre><code class="bash hljs">$ tcpdump -ni vlan100 -c 10 -t udp and dst port 1234 IP 198.18.40.55.32059 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.51.16.30852 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.35.51.61823 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.44.42.30344 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.106.227.38592 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.48.67.19533 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.49.38.40566 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.50.73.22989 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.43.204.37895 &gt; 198.18.0.12.1234: UDP, length 16 IP 198.18.104.128.1543 &gt; 198.18.0.12.1234: UDP, length 16</code> </pre> <br>  No servidor selecionado, todos os pacotes se tornar√£o em uma fila RX e, portanto, ser√£o processados ‚Äã‚Äãpor um n√∫cleo.  Conseguimos isso com o controle de fluxo de hardware: <br><br><pre> <code class="bash hljs">ethtool -N ext0 flow-type udp4 dst-ip 198.18.0.12 dst-port 1234 action 2</code> </pre><br>  O teste de desempenho √© um processo complexo.  Quando preparamos os testes, percebemos que a presen√ßa de soquetes brutos ativos afeta negativamente o desempenho. Portanto, antes de executar os testes, √© necess√°rio garantir que nenhum <code>tcpdump</code> esteja em execu√ß√£o.  Existe uma maneira f√°cil de verificar se h√° processos incorretos: <br><br><pre> <code class="bash hljs">$ ss -A raw,packet_raw -l -p|cat Netid State Recv-Q Send-Q Local Address:Port p_raw UNCONN 525157 0 *:vlan100 users:((<span class="hljs-string"><span class="hljs-string">"tcpdump"</span></span>,pid=23683,fd=3))</code> </pre><br>  E, finalmente, desligamos o Intel Turbo Boost em nosso servidor: <br><br><pre> <code class="hljs pgsql">echo <span class="hljs-number"><span class="hljs-number">1</span></span> | sudo tee /sys/devices/<span class="hljs-keyword"><span class="hljs-keyword">system</span></span>/cpu/intel_pstate/no_turbo</code> </pre> <br>  Apesar de o Turbo Boost ser excelente e aumentar a taxa de transfer√™ncia em pelo menos 20%, estraga significativamente o desvio padr√£o em nossos testes.  Com o turbo ligado, o desvio atinge ¬± 1,5%, enquanto sem ele apenas 0,25%. <br><br><img src="https://habrastorage.org/webt/ic/ik/jq/icikjqda_ztydjswe8xjq07u5sa.png"><br><br><h3>  Etapa 1. Solte pacotes no aplicativo </h3><br>  Vamos come√ßar com a id√©ia de entregar todos os pacotes para o aplicativo e ignor√°-los l√°.  Para a honestidade do experimento, verifique se o iptables n√£o afeta o desempenho de forma alguma: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t mangle -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT iptables -I INPUT -t filter -d 198.18.0.12 -p udp --dport 1234 -j ACCEPT</code> </pre><br>  O aplicativo √© um ciclo simples no qual os dados recebidos s√£o descartados imediatamente: <br><br><pre> <code class="python hljs">s = socket.socket(AF_INET, SOCK_DGRAM) s.bind((<span class="hljs-string"><span class="hljs-string">"0.0.0.0"</span></span>, <span class="hljs-number"><span class="hljs-number">1234</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: s.recvmmsg([...])</code> </pre><br>  J√° preparamos o <a href="">c√≥digo</a> , execute: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=171261 bytes=1940176</code> </pre><br>  Essa solu√ß√£o permite que o kernel retire apenas 175 mil pacotes da fila de hardware, conforme foi medido pelo <code>ethtool</code> e <code>mmwatch</code> : <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|grep rx_2'</span></span> rx2_packets: 174.0k/s</code> </pre><br>  Tecnicamente, 14 milh√µes de pacotes por segundo chegam ao servidor; no entanto, um n√∫cleo de processador n√£o pode lidar com esse volume.  <code>mpstat</code> confirma isso: <br><br><pre> <code class="bash hljs">$ watch <span class="hljs-string"><span class="hljs-string">'mpstat -u -I SUM -P ALL 1 1|egrep -v Aver'</span></span> 01:32:05 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 01:32:06 PM 0 0.00 0.00 0.00 2.94 0.00 3.92 0.00 0.00 0.00 93.14 01:32:06 PM 1 2.17 0.00 27.17 0.00 0.00 0.00 0.00 0.00 0.00 70.65 01:32:06 PM 2 0.00 0.00 0.00 0.00 0.00 100.00 0.00 0.00 0.00 0.00 01:32:06 PM 3 0.95 0.00 1.90 0.95 0.00 3.81 0.00 0.00 0.00 92.38</code> </pre><br><br>  Como podemos ver, o aplicativo n√£o √© um gargalo: a CPU n¬∫ 1 √© usada em 27,17% + 2,17%, enquanto a manipula√ß√£o de interrup√ß√£o ocupa 100% na CPU n¬∫ 2. <br><br>  O uso de <code>recvmessagge(2)</code> desempenha um papel importante.  Depois que a vulnerabilidade Spectre foi descoberta, as chamadas do sistema ficaram ainda mais caras devido ao <abbr title="Isolamento da tabela de p√°ginas do kernel">KPTI</abbr> e √† <abbr title="Trampolim de retorno">retpoline</abbr> usada no kernel <br><br><pre> <code class="hljs ruby">$ tail -n +<span class="hljs-number"><span class="hljs-number">1</span></span> /sys/devices/system/cpu/vulnerabilities/* ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/meltdown</span></span> &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> PTI ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v1 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> __user pointer sanitization ==&gt; <span class="hljs-regexp"><span class="hljs-regexp">/sys/devices</span></span><span class="hljs-regexp"><span class="hljs-regexp">/system/cpu</span></span><span class="hljs-regexp"><span class="hljs-regexp">/vulnerabilities/spectre</span></span>_v2 &lt;== <span class="hljs-symbol"><span class="hljs-symbol">Mitigation:</span></span> Full generic retpoline, IBPB, IBRS_FW</code> </pre><br><br><h3>  Etapa 2. Matando o conntrack </h3><br>  Realizamos essa carga especificamente com IP e porta remetente diferentes para carregar o conntrack o m√°ximo poss√≠vel.  O n√∫mero de entradas no conntrack durante o teste tende ao m√°ximo poss√≠vel e podemos verificar isso: <br><br><pre> <code class="bash hljs">$ conntrack -C 2095202 $ sysctl net.netfilter.nf_conntrack_max net.netfilter.nf_conntrack_max = 2097152</code> </pre><br>  Al√©m disso, no <code>dmesg</code> voc√™ tamb√©m pode ver os gritos do conntrack: <br><br><pre> <code class="bash hljs">[4029612.456673] nf_conntrack: nf_conntrack: table full, dropping packet [4029612.465787] nf_conntrack: nf_conntrack: table full, dropping packet [4029617.175957] net_ratelimit: 5731 callbacks suppressed</code> </pre><br>  Ent√£o, vamos deslig√°-lo: <br><br><pre> <code class="bash hljs">iptables -t raw -I PREROUTING -d 198.18.0.12 -p udp -m udp --dport 1234 -j NOTRACK</code> </pre><br>  E reinicie os testes: <br><br><pre> <code class="bash hljs">$ ./dropping-packets/recvmmsg-loop packets=331008 bytes=5296128</code> </pre><br><br>  Isso nos permitiu atingir a marca de 333 mil pacotes por segundo.  Viva! <br>  PS Usando SO_BUSY_POLL, podemos alcan√ßar at√© 470 mil por segundo; no entanto, este √© um t√≥pico para uma postagem separada. <br><br><h3>  Etapa 3. Filtro de lote de Berkeley </h3><br>  Vamos seguir em frente.  Por que precisamos entregar pacotes para o aplicativo?  Embora essa n√£o seja uma solu√ß√£o comum, podemos vincular o filtro de pacotes cl√°ssico de Berkeley ao soquete chamando <code>setsockopt(SO_ATTACH_FILTER)</code> e configurar o filtro para <code>setsockopt(SO_ATTACH_FILTER)</code> pacotes no kernel. <br>  Prepare o <a href="">c√≥digo</a> , execute: <br><br><pre> <code class="bash hljs">$ ./bpf-drop packets=0 bytes=0</code> </pre><br>  Usando um filtro de pacotes (os filtros cl√°ssicos e avan√ßados de Berkeley oferecem desempenho aproximadamente semelhante), chegamos a cerca de 512 mil pacotes por segundo.  Al√©m disso, soltar um pacote durante uma interrup√ß√£o libera o processador de ter que ativar o aplicativo. <br><br><h3>  Etapa 4. iptables DROP ap√≥s o roteamento </h3><br>  Agora podemos descartar pacotes adicionando a seguinte regra ao iptables na cadeia INPUT: <br><br><pre> <code class="bash hljs">iptables -I INPUT -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre><br>  Deixe-me lembr√°-lo de que j√° desativamos o conntrack com a regra <code>-j NOTRACK</code> .  Essas duas regras nos d√£o 608 mil pacotes por segundo. <br><br>  Vejamos os n√∫meros no iptables: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'iptables -L -v -n -x | head'</span></span> Chain INPUT (policy DROP 0 packets, 0 bytes) pkts bytes target prot opt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> out <span class="hljs-built_in"><span class="hljs-built_in">source</span></span> destination 605.9k/s 26.7m/s DROP udp -- * * 0.0.0.0/0 198.18.0.12 udp dpt:1234</code> </pre><br>  Bem, n√£o √© ruim, mas podemos fazer melhor. <br><br><h3>  Etapa 5. iptabes DROP em PREROUTING </h3><br>  Uma t√©cnica mais r√°pida √© descartar pacotes antes de rotear usando esta regra: <br><br><pre> <code class="bash hljs">iptables -I PREROUTING -t raw -d 198.18.0.12 -p udp --dport 1234 -j DROP</code> </pre> <br>  Isso nos permite eliminar 1,68 milh√£o de pacotes por segundo. <br><br>  De fato, este √© um salto ligeiramente surpreendente no desempenho.  Ainda n√£o entendo os motivos, talvez o nosso roteamento seja complicado ou talvez apenas um bug na configura√ß√£o do servidor. <br><br>  De qualquer forma, as tabelas de ip brutas s√£o muito mais r√°pidas. <br><br><h3>  Etapa 6. nftables DROP </h3><br>  O utilit√°rio iptables agora √© um pouco antigo.  Ela foi substitu√≠da por nftables.  Confira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta explica√ß√£o em v√≠deo sobre</a> por que o nftables √© o melhor.  O Nftables promete ser mais r√°pido que o iptables acinzentado por v√°rios motivos, incluindo rumores de que as retpolinas desaceleram muito o iptables. <br><br>  Mas nosso artigo ainda n√£o trata de comparar iptables e nftables, ent√£o vamos tentar o mais r√°pido que pude: <br><br><pre> <code class="bash hljs">nft add table netdev filter nft -- add chain netdev filter input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500 \; policy accept \; } nft add rule netdev filter input ip daddr 198.18.0.0/24 udp dport 1234 counter drop nft add rule netdev filter input ip6 daddr fd00::/64 udp dport 1234 counter drop</code> </pre><br>  Os contadores podem ser vistos assim: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'nft --handle list chain netdev filter input'</span></span> table netdev filter { chain input { <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> filter hook ingress device vlan100 priority -500; policy accept; ip daddr 198.18.0.0/24 udp dport 1234 counter packets 1.6m/s bytes 69.6m/s drop <span class="hljs-comment"><span class="hljs-comment"># handle 2 ip6 daddr fd00::/64 udp dport 1234 counter packets 0 bytes 0 drop # handle 3 } }</span></span></code> </pre><br>  O gancho de entrada nftables mostrou valores de cerca de 1,53 milh√£o de pacotes.  Isso √© um pouco menos que a cadeia PREROUTING no iptables.  Mas h√° um mist√©rio nisso: teoricamente, o gancho nftables √© anterior ao PREROUTING iptables e, portanto, deve ser processado mais rapidamente. <br><br>  Em nosso teste, o nftables √© um pouco mais lento que o iptables, mas o nftables √© mais legal de qualquer maneira.  : P <br><br><h3>  Etapa 7. tc DROP </h3><br>  De maneira inesperada, o gancho tc (controle de tr√°fego) acontece antes do iptables PREROUTING.  O tc nos permite selecionar pacotes de acordo com crit√©rios simples e, √© claro, descart√°-los.  A sintaxe √© um pouco incomum, por isso sugerimos o uso <a href="">desse script</a> para configura√ß√£o.  E precisamos de uma regra bastante complicada que se parece com isso: <br><br><pre> <code class="bash hljs">tc qdisc add dev vlan100 ingress tc filter add dev vlan100 parent ffff: prio 4 protocol ip u32 match ip protocol 17 0xff match ip dport 1234 0xffff match ip dst 198.18.0.0/24 flowid 1:1 action drop tc filter add dev vlan100 parent ffff: protocol ipv6 u32 match ip6 dport 1234 0xffff match ip6 dst fd00::/64 flowid 1:1 action drop</code> </pre><br>  E podemos verificar em a√ß√£o: <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'tc -s filter show dev vlan100 ingress'</span></span> filter parent ffff: protocol ip pref 4 u32 filter parent ffff: protocol ip pref 4 u32 fh 800: ht divisor 1 filter parent ffff: protocol ip pref 4 u32 fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1 (rule hit 1.8m/s success 1.8m/s) match 00110000/00ff0000 at 8 (success 1.8m/s ) match 000004d2/0000ffff at 20 (success 1.8m/s ) match c612000c/ffffffff at 16 (success 1.8m/s ) action order 1: gact action drop random <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> none pass val 0 index 1 ref 1 <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span> 1 installed 1.0/s sec Action statistics: Sent 79.7m/s bytes 1.8m/s pkt (dropped 1.8m/s, overlimits 0 requeues 0)</code> </pre><br>  O gancho tc nos permitiu lan√ßar at√© 1,8 milh√£o de pacotes por segundo em um √∫nico n√∫cleo.  Isso √© √≥timo! <br>  Mas podemos faz√™-lo ainda mais r√°pido ... <br><br><h3>  Etapa 8. XDP_DROP </h3><br>  E, finalmente, a nossa arma mais forte: XDP - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">eXpress Data Path</a> .  Usando o XDP, podemos executar o c√≥digo estendido do Berkley Packet Filter (eBPF) diretamente no contexto do driver de rede e, o mais importante, mesmo antes de alocar mem√≥ria para o <code>skbuff</code> , o que nos promete um aumento na velocidade. <br><br>  Normalmente, um projeto XDP consiste em duas partes: <br><br><ul><li>  c√≥digo eBPF para download </li><li>  carregador de inicializa√ß√£o que coloca o c√≥digo na interface de rede correta </li></ul><br>  Escrever seu gerenciador de inicializa√ß√£o √© uma tarefa dif√≠cil, portanto, basta usar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">novo chip iproute2</a> e carregar o c√≥digo com um comando simples: <br><br><pre> <code class="bash hljs">ip link <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> dev ext0 xdp obj xdp-drop-ebpf.o</code> </pre><br>  Ta Dam! <br><br>  O c√≥digo fonte do <a href="">programa eBPF</a> para <a href="">download est√° dispon√≠vel aqui</a> .  O programa analisa caracter√≠sticas de pacotes IP como o protocolo UDP, sub-rede do remetente e porta de destino: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (h_proto == htons(<span class="hljs-type"><span class="hljs-type">ETH_P_IP</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (iph-&gt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IPPROTO_UDP</span></span></span><span class="hljs-class"> &amp;&amp; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htonl</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">daddr</span></span></span><span class="hljs-class">) &amp; 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xFFFFFF00</span></span></span><span class="hljs-class">) == 0</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xC6120000</span></span></span><span class="hljs-class"> // 198.18.0.0/24 &amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udph</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dest</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">htons</span></span></span><span class="hljs-class">(1234)) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">XDP_DROP</span></span>; } }</code> </pre><br>  O programa XDP deve ser constru√≠do usando clang moderno, que pode gerar bytecode BPF.  Depois disso, podemos baixar e testar a funcionalidade do programa BFP: <br><br><pre> <code class="bash hljs">$ ip link show dev ext0 4: ext0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc fq state UP mode DEFAULT group default qlen 1000 link/ether 24:8a:07:8a:59:8e brd ff:ff:ff:ff:ff:ff prog/xdp id 5 tag aedc195cc0471f51 jited</code> </pre><br>  E ent√£o veja as estat√≠sticas no <code>ethtool</code> : <br><br><pre> <code class="bash hljs">$ mmwatch <span class="hljs-string"><span class="hljs-string">'ethtool -S ext0|egrep "rx"|egrep -v ": 0"|egrep -v "cache|csum"'</span></span> rx_out_of_buffer: 4.4m/s rx_xdp_drop: 10.1m/s rx2_xdp_drop: 10.1m/s</code> </pre><br>  Yoo hoo!  Com o XDP, podemos perder at√© 10 milh√µes de pacotes por segundo! <br><br><img src="https://habrastorage.org/webt/fq/mf/e5/fqmfe5jgs1qylz7fpwryoeey0ag.png"><br>  <i>Foto: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Andrew Filer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CC BY-SA 2.0</a></i> <br><br><h3>  Conclus√µes </h3><br>  Repetimos o experimento para IPv4 e IPv6 e preparamos este diagrama: <br><br><img src="https://habrastorage.org/webt/dl/sc/qa/dlscqatdfii2rihttytjnfvtfea.png"><br>  Em geral, pode-se argumentar que nossa configura√ß√£o para o IPv6 √© um pouco mais lenta.  Mas como os pacotes IPv6 s√£o um pouco maiores, √© esperada a diferen√ßa de velocidade. <br><br>  O Linux tem muitas maneiras de filtrar pacotes, cada um com sua pr√≥pria velocidade e complexidade. <br><br>  Para se proteger contra DDoS, √© bastante razo√°vel dar pacotes ao aplicativo e process√°-los l√°.  Um aplicativo bem ajustado pode mostrar bons resultados. <br><br>  Para ataques DDoS com IP aleat√≥rio ou falsificado, pode ser √∫til desativar o conntrack para obter um pequeno aumento na velocidade, mas tenha cuidado: h√° ataques contra os quais o conntrack √© muito √∫til. <br><br>  Em outros casos, faz sentido adicionar o firewall do Linux como uma das maneiras de mitigar o ataque DDoS.  Em alguns casos, √© melhor usar a tabela "-t raw PREROUTING", pois √© muito mais r√°pida que a tabela de filtros. <br><br>  Para os casos mais avan√ßados, sempre usamos XDP.  E sim, isso √© uma coisa muito poderosa.  Aqui est√° um gr√°fico como acima, apenas com XDP: <br><br><img src="https://habrastorage.org/webt/o4/un/dm/o4undm-syfgavdxop6izkvpckyk.png"><br>  Se voc√™ deseja repetir o experimento, aqui est√° o <a href="">README, no qual documentamos tudo</a> . <br><br>  N√≥s da CloudFlare usamos ... quase todas essas t√©cnicas.  Alguns truques no espa√ßo do usu√°rio s√£o integrados aos nossos aplicativos.  A t√©cnica iptables √© encontrada em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Gatebot</a> .  Finalmente, substitu√≠mos nossa pr√≥pria solu√ß√£o principal por XDP. <br><br>  Muito obrigado a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Jesper Dangaard Brouer</a> por sua ajuda. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt419921/">https://habr.com/ru/post/pt419921/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt419911/index.html">Construindo √≥rbitas de corpos celestes usando Python</a></li>
<li><a href="../pt419913/index.html">IKEA e casa inteligente. Parte 2</a></li>
<li><a href="../pt419915/index.html">Servidor de liga√ß√£o e SSH no initramfs</a></li>
<li><a href="../pt419917/index.html">Redes neurais: implementa√ß√£o da tarefa sobre cogumelos em Tensor Flow e Python</a></li>
<li><a href="../pt419919/index.html">Controle de vers√£o dentro do SQL Server</a></li>
<li><a href="../pt419923/index.html">Meu trabalho tempor√°rio, rel√≥gios da placa-m√£e</a></li>
<li><a href="../pt419925/index.html">Controle de vers√£o de arquivos individuais usando o GitHub Gist</a></li>
<li><a href="../pt419927/index.html">Exce√ß√µes [DotNetBook]: arquitetura de sistema de tipos</a></li>
<li><a href="../pt419929/index.html">[DotNetBook] Eventos de exce√ß√£o e como obter StackOverflow e ExecutionEngineException do zero</a></li>
<li><a href="../pt419931/index.html">[DotNetBook] Hora de hist√≥rias divertidas: situa√ß√µes excepcionalmente excepcionais</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>