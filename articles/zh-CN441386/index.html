<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧤 🍐 📔 Spring Data JPA：好的和坏的是什么 🧑🏽‍🤝‍🧑🏽 👩🏽‍🔧 👩🏻‍🏫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="小儿子来到他父亲 
 并问婴儿 
 -什么好 
 还有什么不好 
 
 弗拉基米尔·玛雅科夫斯基 


 本文是关于Spring Data JPA的，即我在途中遇到的水下耙，当然还有一些性能方面的知识。 


 本文中描述的示例可以在测试环境中运行，可以通过引用进行访问。 
 对于尚未迁移到Spri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Spring Data JPA：好的和坏的是什么</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441386/"><p> <em>小儿子来到他父亲</em> <em><br></em>  <em>并问婴儿</em> <em><br></em>  <em>-什么好</em> <em><br></em>  <em>还有什么不好</em> <em><br></em> <br> 弗拉基米尔·玛雅科夫斯基 </p><br><p> 本文是关于Spring Data JPA的，即我在途中遇到的水下耙，当然还有一些性能方面的知识。 </p><a name="habracut"></a><br><p> 本文中描述的示例可以在测试环境中运行，可以通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">引用进行</a>访问。 </p><br><div class="spoiler">  <b class="spoiler_title">对于尚未迁移到Spring Boot 2的用户的说明</b> <div class="spoiler_text"><p>在Spring Data JPA 2的版本中，用于处理存储库的主要接口，即<code>CrudRepository</code> ，从中继承<code>JpaRepository</code> ，已经<code>JpaRepository</code> 。 在版本1.中，主要方法如下所示： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> <br><p> 在新版本中： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CrudRepository</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ID</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-function">Optional&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID id)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">List&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAllById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iterable&lt;ID&gt; ids)</span></span></span></span>; }</code> </pre> </div></div><br><p> 因此，让我们开始吧。 </p><br><h4 id="select-t-from-t-where-tid-in-"> 从t中选择t。*，其中（。）中的t.id </h4><br><p> 最常见的查询之一是以下形式的查询：“选择键落入传输集中的所有记录”。 我敢肯定你们几乎所有人都写过或看到过类似的东西 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> List&lt;Long&gt; ids)</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p> 这些是可行的，合适的请求，没有捕获或性能问题，但是存在一个很小的，完全不明显的缺点。 </p><br><div class="spoiler">  <b class="spoiler_title">在打开衬管之前，请尝试自己考虑一下。</b> <div class="spoiler_text"><p> 缺点是接口太窄而无法传输密钥。  “那又怎样？”  -你说。  “好了，列表好了，我在这里没有问题。” 但是，如果我们查看具有许多值的根接口方法，那么到处都会看到<code>Iterable</code> ： </p><br><p>  “那又怎样？我想要一张清单。为什么它更糟？” <br> 更糟的是，只需为应用程序中更高级别的相似代码的出现做好准备： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Long&gt; userIds)</span></span></span><span class="hljs-function"> </span></span>{ Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(userIds); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repository.findByUserIds(ids); } <span class="hljs-comment"><span class="hljs-comment">// public List&lt;BankAccount&gt; findByUserIds(Set&lt;Long&gt; userIds) { List&lt;Long&gt; ids = new ArrayList&lt;&gt;(userIds); return repository.findByUserIds(ids); }</span></span></code> </pre> <br><p> 这段代码除了反转集合外什么也不做。 该方法的参数可能是一个列表，并且存储库方法接受该集合（反之亦然），您可能只需要重新调用它即可通过编译。 当然，在请求本身产生间接费用的背景下，这不会成为问题，更多的是不必要的手势。 </p><br><p> 因此，使用<code>Iterable</code>是一个好习惯： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p>  Z.Y. 如果我们正在谈论<code>*RepositoryCustom</code>的方法，那么使用<code>Collection</code>来简化实现内部大小的计算是有意义的： </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryCustom</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccountRepositoryImpl</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">anyMoneyAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection&lt;Long&gt; accountIds)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ids.isEmpty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> </div></div><br><h4 id="lishniy-kod-nepovtoryayuschiesya-klyuchi"> 额外的代码：非重复密钥 </h4><br><p> 在上一节的继续中，我想提请大家注意一个常见的误解： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Set&lt;Long&gt; ids)</span></span>;</code> </pre> <br><p> 相同错误的其他表现形式： </p><br><pre> <code class="java hljs">Set&lt;Long&gt; ids = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashSet&lt;&gt;(notUniqueIds); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); List&lt;Long&gt; ids = ts.stream().map(T::id).distinct().collect(toList()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids); Set&lt;Long&gt; ids = ts.stream().map(T::id).collect(toSet()); List&lt;BankAccount&gt; accounts = repository.findByUserIds(ids);</code> </pre> <br><p> 乍一看，没有什么不寻常的，对吧？ </p><br><div class="spoiler">  <b class="spoiler_title">慢慢来，为自己思考；）</b> <div class="spoiler_text"><p> 形式<code>select t from t where t.field in ...</code> HQL / JPQL查询<code>select t from t where t.field in ...</code>最终将变为查询 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> BankAccount b <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> b.user_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (?, ?, ?, ?, ?, …)</code> </pre> <br><p> 无论参数中是否存在重复，它都会始终返回相同的内容。 因此，不必确保键的唯一性。 有一种特殊情况-Oracle，按&gt; 1000键<code>in</code>将导致错误。 但是，如果您尝试通过排除重复来减少键的数量，那么您应该考虑一下它们出现的原因。 该错误最有可能在上方。 </p><br><p> 因此，在良好的代码中使用<code>Iterable</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select ba from BankAccount ba where ba.user.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findByUserIds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> </div></div><br><h4 id="samopis"> 沙门氏菌 </h4><br><p> 仔细看一下这段代码，在这里发现三个缺陷和一个可能的错误： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"from User u where u.id in :ids"</span></span>) <span class="hljs-function"><span class="hljs-function">List&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"ids"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Iterable&lt;Long&gt; ids)</span></span>;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">再想一想</b> <div class="spoiler_text"><ul><li> 一切都已经在<code>SimpleJpaRepository::findAllById</code> </li><li> 传递空列表时的空闲请求（在<code>SimpleJpaRepository::findAllById</code>有相应的检查） </li><li> 使用<code>@Query</code>描述的所有查询都在生成上下文的阶段进行检查，这需要花费时间（与<code>SimpleJpaRepository::findAllById</code>不同） </li><li> 如果使用Oracle，则当键集合为空时，我们将收到错误<code>ORA-00936: missing expression</code> （使用<code>SimpleJpaRepository::findAllById</code>时不会发生，请参见第2点） </li></ul></div></div><br><h4 id="garri-potter-i-sostavnoy-klyuch"> 哈利·波特与复合键 </h4><br><p> 看两个示例，然后选择您喜欢的一个： </p><br><p> 方法次数 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@EmbeddedId</span></span> CompositeKey key; }</code> </pre> <br><p> 方法二 </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Embeddable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializable</span></span></span><span class="hljs-class"> </span></span>{ Long key1; Long key2; } <span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-meta"><span class="hljs-meta">@IdClass</span></span>(value = CompositeKey.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompositeKeyEntity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key1; <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long key2; }</code> </pre> <br><p> 乍一看，没有区别。 现在尝试第一种方法并运行一个简单的测试： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @EmbeddedId @Test public void findAll() { int size = entityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p> 在查询日志中（保留它，对吧？），我们将看到以下内容： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ? <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> e.key1 = ? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2 = ?</code> </pre> <br><p> 现在第二个例子 </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//case for @Id @Id @Test public void _findAll() { int size = anotherEntityWithCompositeKeyRepository.findAllById(compositeKeys).size(); assertEquals(size, 5); }</span></span></code> </pre> <br><p> 查询日志看起来不同： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=? <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e.key1, e.key2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> CompositeKeyEntity e <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> e.key1=? <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> e.key2=?</code> </pre> <br><p> 这就是整个区别：在第一种情况下，我们总是收到1个请求，在第二种情况下，我们总是收到n个请求。 <br> 此行为的原因在于<code>SimpleJpaRepository::findAllById</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ... if (entityInfo.hasCompositeId()) { List&lt;T&gt; results = new ArrayList&lt;&gt;(); for (ID id : ids) { findById(id).ifPresent(results::add); } return results; } // ...</span></span></code> </pre> <br><p> 哪种方法最好，是您根据请求数量的重要性来确定的。 </p><br><h4 id="lishniy-crudrepositorysave">  Extra CrudRepository ::保存 </h4><br><p> 通常在代码中有这样的反模式： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p> 读者感到困惑：反模式在哪里？ 这段代码看起来非常合乎逻辑：我们得到了实体-更新-保存。 一切都像在圣彼得堡最好的房子里。 我敢说在这里调用<code>CrudRepository::save</code>是多余的。 </p><br><p> 首先： <code>updateRate</code>方法<code>updateRate</code>事务性的，因此，Hibernate会跟踪受管实体中的所有更改，并在执行<code>Session::flush</code>时将其转换为请求，该代码在方法结束时发生。 </p><br><p> 其次， <code>CrudRepository::save</code>看一下<code>CrudRepository::save</code>方法。 如您所知，所有存储库都基于<code>SimpleJpaRepository</code> 。 这是<code>CrudRepository::save</code>的实现<code>CrudRepository::save</code> ： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;S extends T&gt; <span class="hljs-function"><span class="hljs-function">S </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(S entity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (entityInformation.isNew(entity)) { em.persist(entity); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.merge(entity); } }</code> </pre> <br><p> 有一个微妙之处，并非所有人都记得：Hibernate通过事件进行工作。 换句话说，每个用户操作都会生成一个事件，该事件将考虑到同一队列中的其他事件进行排队和处理。 在这种情况下，对<code>EntityManager::merge</code>的调用<code>EntityManager::merge</code>生成一个<code>MergeEvent</code> ，默认情况下，将在<code>DefaultMergeEventListener::onMerge</code> 。 对于实体参数的每个状态，它包含一个相当分支但简单的逻辑。 在我们的案例中，实体是从事务方法内部的存储库中获得的，并且处于PERSISTENT状态（即，基本上由框架控制）： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityIsPersistent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MergeEvent event, Map copyCache)</span></span></span><span class="hljs-function"> </span></span>{ LOG.trace(<span class="hljs-string"><span class="hljs-string">"Ignoring persistent instance"</span></span>); Object entity = event.getEntity(); EventSource source = event.getSession(); EntityPersister persister = source.getEntityPersister(event.getEntityName(), entity); ((MergeContext)copyCache).put(entity, entity, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cascadeOnMerge(source, persister, entity, copyCache); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- this.copyValues(persister, entity, entity, source, copyCache); //&lt;---- event.setResult(entity); }</span></span></code> </pre> <br><p> 细节在于细节，即方法<code>DefaultMergeEventListener::cascadeOnMerge</code>和<code>DefaultMergeEventListener::copyValues</code> 。 让我们听听Hibernate的主要开发人员之一<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Vlad Mikhalche</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">直接讲话</a> ： </p><br><blockquote> 在copyValues方法调用中，再次复制了水合状态，因此冗余创建了一个新数组，因此浪费了CPU周期。 如果实体具有子关联，并且合并操作也从父实体级联到子实体，则开销会更大，因为每个子实体都将传播MergeEvent，并且循环继续。 </blockquote><p> 换句话说，正在完成您无法完成的工作。 结果，可以简化我们的代码，同时提高其性能： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, BigDecimal rate)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setRate(rate); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> account; }</code> </pre> <br><p> 当然，在开发和校对其他人的代码时记住这一点<code>JpaRepository::save</code> ，因此我们希望在线框级别进行更改，以使<code>JpaRepository::save</code>方法<code>JpaRepository::save</code>失去其有害的属性。 这可能吗？ </p><br><div class="spoiler">  <b class="spoiler_title">是的也许</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else { return em.merge(entity); } } // @Transactional public &lt;S extends T&gt; S save(S entity) { if (entityInformation.isNew(entity)) { em.persist(entity); return entity; } else if (!em.contains(entity)) { return em.merge(entity); } return entity; }</span></span></code> </pre> <br><p> 实际上，这些更改是在2017年12月进行的： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://jira.spring.io/browse/DATAJPA-931</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/spring-projects/spring-data-jpa/pull/237</a> </p></div></div><br><p> 但是，老练的读者可能已经感觉到有些不对劲。 确实，此更改不会破坏任何内容，仅在没有子实体的简单情况下才起作用： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; }</code> </pre> <br><p> 现在假设其所有者已绑定到该帐户： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span> BigDecimal rate = BigDecimal.ZERO; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; }</code> </pre> <br><p> 有一种方法可以让您断开用户与帐户的连接，并将其转移到新用户： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id, User newUser)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = repo.findById(id).orElseThrow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); account.setUser(newUser); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repo.save(account); }</code> </pre> <br><p> 现在会发生什么？ 检查<code>em.contains(entity)</code>将返回true，这意味着将不会调用<code>em.merge(entity)</code> 。 如果<code>User</code>实体键是根据序列创建的（最常见的情况之一），则只有在交易完成（或手动调用<code>Session::flush</code> ）后才会创建，即用户将处于DETACHED状态，并且其父实体（帐户）-处于PERSISTENT状态。 在某些情况下，这可能会破坏应用程序的逻辑，这就是发生的情况： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">02/03/2018 DATAJPA-931中断与RepositoryItemWriter的合并</a> </p><br><p> 在这方面， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">创建了为CrudRepository :: save中现有实体进行的还原优化</a>任务，并进行了更改： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">还原DATAJPA-931</a> 。 </p><br><h4 id="slepoy-crudrepositoryfindbyid">  Blind CrudRepository :: findById </h4><br><p> 我们继续考虑相同的数据模型： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-comment"><span class="hljs-comment">// ... } @Entity public class BankAccount { @Id Long id; @ManyToOne @JoinColumn(name = "user_id") User user; }</span></span></code> </pre> <br><p> 该应用程序具有一种为指定用户创建新帐户的方法： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); userRepository.findById(userId).ifPresent(account::setUser); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p> 对于版本2，*箭头所示的反模式并不那么醒目-在较旧的版本中更清楚地看到： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.findOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">如果您看不到“目测”缺陷，请查看以下查询：</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> u.id, u.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ? <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*…*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*…*/</span></span>)</code> </pre> </div></div><br><p> 我们通过键获取用户的第一个请求。 接下来，我们从数据库中获取新生儿帐户的密钥，并将其插入表中。 我们从用户那里获得的唯一东西就是密钥，它已经作为方法参数存在。 另一方面， <code>BankAccount</code>包含“用户”字段，我们不能将其保留为空（由于体面的人，我们在方案中设置了限制）。 经验丰富的开发人员可能已经发现了一种方法 <del> 吃鱼和骑马 </del> 让用户和请求都不要： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> BankAccount </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newForUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long userId)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount account = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BankAccount(); account.setUser(userRepository.getOne(userId)); <span class="hljs-comment"><span class="hljs-comment">//&lt;---- return accountRepository.save(account); }</span></span></code> </pre> <br><p>  <code>JpaRepository::getOne</code>返回与活动“实体”具有相同类型的键的包装器。 此代码仅给出两个请求： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">next</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> hibernate_sequence <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> bank_account (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*…*/</span></span> user_id) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-comment"><span class="hljs-comment">/*…*/</span></span>)</code> </pre> <br><p> 当要创建的实体包含具有多对一/一对一关系的许多字段时，此技术将有助于加快保存速度并减少数据库的负载。 </p><br><h4 id="ispolnenie-hql-zaprosov"> 执行HQL查询 </h4><br><p> 这是一个单独且有趣的主题：）。 域模型是相同的，并且有这样的请求： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" join ba.user user "</span></span> + <span class="hljs-string"><span class="hljs-string">" where user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p> 考虑“纯” HQL： </p><br><pre> <code class="plaintext hljs">select count(ba) from BankAccount ba join ba.user user where user.id = :id</code> </pre> <br><p> 执行后，将创建此SQL查询： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">inner</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> u <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ba.user_id = u.id <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> u.id = ?</code> </pre> <br><p> 即使通过明智的生活和对SQL开发人员的充分了解，这里的问题也不会立即显现出来：通过用户键进行<code>inner join</code>联接将从选择中排除缺少<code>user_id</code>帐户（并且以很好的方式，应该在模式级别禁止插入这些帐户），这意味着通常不希望加入<code>user</code>表需要。 该请求可以简化（并加速）： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p> 有一种方法可以使用HQL在c中轻松实现此行为： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select count(ba) "</span></span> + <span class="hljs-string"><span class="hljs-string">" from BankAccount ba "</span></span> + <span class="hljs-string"><span class="hljs-string">" where ba.user.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countUserAccounts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p> 此方法创建“精简”请求。 </p><br><h4 id="annotaciya-query-protiv-metoda"> 查询与方法摘要 </h4><br><p>  Spring Data的主要功能之一是能够从方法名称创建查询，这非常方便，尤其是与IntelliJ IDEA的智能插件结合使用时。 上一个示例中描述的查询可以很容易地重写： </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// @Query("select count(ba) " + " from BankAccount ba " + " where ba.user.id = :id") long countUserAccounts(@Param("id") Long id); // long countByUserAccount_Id(Long id);</span></span></code> </pre> <br><p> 它似乎更简单，更短，更易读，而且最重要的是-您无需查看请求本身。 我读了方法的名称-现在已经清楚了选择的方法和方式。 但是细节在这里。 我们已经看到了用<code>@Query</code>标记的方法的最终查询。 在第二种情况下会发生什么？ </p><br><div class="spoiler">  <b class="spoiler_title">b！</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">left</span></span> <span class="hljs-keyword"><span class="hljs-keyword">outer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> // &lt;<span class="hljs-comment"><span class="hljs-comment">--- !!!!!!! user u on ba.user_id = u.id where u.id = ?</span></span></code> </pre> </div></div><br><p>  “什么鬼！！”  -开发人员会惊呼。 毕竟，我们已经看到了 <del> 小提琴家 </del> 不需要<code>join</code> 。 </p><br><p> 原因是平淡无奇的： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JPADATAJPA-729产生不必要的外部联接，用于对一个表进行计数</a> </li><li><del>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DATAJPA-1238可以使用WHERE时不必要的左外连接</a> </del></li></ul><br><p> 如果您尚未升级到补丁程序版本，并且现在加入表会减慢请求的速度，那么请不要失望：有两种方法可以减轻痛苦： </p><br><ul><li><p> 一个好方法是添加<code>optional = false</code> （如果电路允许）： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, optional = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) User user; }</code> </pre> <br></li><li><p> 关键的方法是添加与<code>User</code>实体键相同类型的列，并在查询而不是<code>user</code>字段中使用它： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Entity</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BankAccount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Id</span></span> Long id; <span class="hljs-meta"><span class="hljs-meta">@ManyToOne</span></span> <span class="hljs-meta"><span class="hljs-meta">@JoinColumn</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>) User user; <span class="hljs-meta"><span class="hljs-meta">@Column</span></span>(name = <span class="hljs-string"><span class="hljs-string">"user_id"</span></span>, insertable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, updatable = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) Long userId; }</code> </pre> <br><p> 现在，来自方法的请求会更好： </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">countByUserId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span></span>;</code> </pre> <br><p> 给 </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ba.id) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ba.user_id = ?</code> </pre> <br><p> 我们取得了什么成就。 </p><br></li></ul><br><h4 id="ogranichenie-vyborki"> 采样极限 </h4><br><p> 出于我们的目的，我们需要限制选择（例如，我们想从<code>*RepositoryCustom</code>方法返回<code>Optional</code> ）： </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> ba.* <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> bank_account ba <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> ba.rate <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> ?</code> </pre> <br><p> 现在的Java： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; BankAccount account = em .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .getSingleResult(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Optional.ofNullable(bankAccount); }</code> </pre> <br><p> 指定的代码具有一个令人不快的功能：如果请求返回一个空选择，则将引发异常 </p><br><pre> <code class="plaintext hljs">Caused by: javax.persistence.NoResultException: No entity found for query</code> </pre> <br><p> 在我看到的项目中，可以通过两种主要方法解决此问题： </p><br><ul><li> 尝试捕获具有从直截了当<code>Optonal.empty()</code>异常并返回<code>Optonal.empty()</code>到更高级的方式的变体，例如将带有请求的lambda传递给实用程序方法 </li><li> 仓库方法包装返回<code>Optional</code> </li></ul><br><p> 而且很少见到正确的解决方案： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Optional&lt;BankAccount&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findWithHighestRate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String query = <span class="hljs-string"><span class="hljs-string">"select b from BankAccount b order by b.rate"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> em.unwrap(Session.class) .createQuery(query, BankAccount.class) .setFirstResult(<span class="hljs-number"><span class="hljs-number">0</span></span>) .setMaxResults(<span class="hljs-number"><span class="hljs-number">1</span></span>) .uniqueResultOptional(); }</code> </pre> <br><p>  <code>EntityManager</code>是JPA标准的一部分，而<code>Session</code>属于Hibernate，并且是恕我直言，IMHO是一种更高级的工具，通常被遗忘。 </p><br><h4 id="inogda-vrednoe-uluchshenie">  [有时]有害的改善 </h4><br><p> 当您需要从“厚”实体中获取一个小字段时，我们可以这样做： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Query</span></span>(<span class="hljs-string"><span class="hljs-string">"select a.available from BankAccount a where a.id = :id"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findIfAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Param(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"id"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> Long id)</span></span>;</code> </pre> <br><p> 该请求使您可以获取<code>boolean</code>类型的一个字段而无需加载整个实体（添加了一级缓存，在会话结束时检查更改以及其他费用）。 有时，这不仅不能提高性能，反之亦然-它会从头开始创建不必要的查询。 想象一下执行一些检查的代码： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findIfAvailable(id); }</span></span></code> </pre> <br><p> 这段代码至少发出了2个请求，尽管可以避免第二个请求： </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-meta"><span class="hljs-meta">@Transactional</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Long id)</span></span></span><span class="hljs-function"> </span></span>{ BankAccount acc = repository.findById(id).orElseThow(NPE::<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ... return repository.findById(id) //    .map(BankAccount::isAvailable) .orElseThrow(IllegalStateException::new); }</span></span></code> </pre> <br><p> 结论很简单：在一个事务的框架内，不要忽略第一级的缓存，只有第一个<code>JpaRepository::findById</code>引用数据库， <code>JpaRepository::findById</code>第一级<code>JpaRepository::findById</code>缓存始终处于打开状态并与会话相关联，而会话通常与当前事务相关联。 </p><br><p> 进行测试（在本文开头提供了到存储库的链接）： </p><br><ul><li> 窄接口测试： <code>InterfaceNarrowingTest</code> </li><li> 使用组合键测试示例： <code>EntityWithCompositeKeyRepositoryTest</code> </li><li> 测试多余的<code>CrudRepository::save</code> ： <code>ModifierTest.java</code> </li><li> 盲测<code>CrudRepository::findById</code> ： <code>ChildServiceImplTest</code> </li><li> 不必要的<code>left join</code> <code>BankAccountControlRepositoryTest</code>测试： <code>BankAccountControlRepositoryTest</code> </li></ul><br><p> 可以使用<code>RedundantSaveBenchmark</code>计算额外调用<code>CrudRepository::save</code>的成本。 它是使用<code>BenchmarkRunner</code>类启动的。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN441386/">https://habr.com/ru/post/zh-CN441386/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN441376/index.html">超越纯度：什么可以和什么不能逆渗透膜</a></li>
<li><a href="../zh-CN441378/index.html">Google研究人员：为了防止Spectre发生变化，需要更改处理器架构，软件补丁无济于事</a></li>
<li><a href="../zh-CN441380/index.html">转化增长的7点或如何提高按钮的可点击性</a></li>
<li><a href="../zh-CN441382/index.html">中国科学家开发了用于起搏器的压电发电机</a></li>
<li><a href="../zh-CN441384/index.html">Windows中的批量打印</a></li>
<li><a href="../zh-CN441388/index.html">斑马条纹-这是蝇类的禁飞区</a></li>
<li><a href="../zh-CN441390/index.html">不仅仅是可折叠手机：三星已经更新了其整个可穿戴设备系列</a></li>
<li><a href="../zh-CN441392/index.html">RDRAND和RDSEED CPU功能现在可用</a></li>
<li><a href="../zh-CN441394/index.html">“应用”的ASCII艺术</a></li>
<li><a href="../zh-CN441398/index.html">Cruise打开Worldview源代码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>