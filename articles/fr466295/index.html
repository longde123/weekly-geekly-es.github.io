<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏼 🛏️ 🔮 Cache de secours indolore sur Scala 💇🏻 🐊 🚣🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les grandes architectures ou microservices, le service le plus important n'est pas toujours le plus productif et n'est parfois pas destiné à une ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache de secours indolore sur Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/466295/"> Dans les grandes architectures ou microservices, le service le plus important n'est pas toujours le plus productif et n'est parfois pas destiné à une charge élevée.  Nous parlons du backend.  Il fonctionne lentement - il perd du temps sur le traitement des données et l'attente d'une réponse entre celui-ci et le SGBD, et n'est pas évolutif.  Même si l'application elle-même évolue facilement, ce goulot d'étranglement ne se modifie pas du tout.  Comment résoudre ce problème et garantir des performances élevées?  Comment fournir une réponse système lorsque des sources d'informations importantes sont silencieuses? <br><br><img src="https://habrastorage.org/webt/tw/3o/ti/tw3otiqpnki3jcwa8ittvdrpzoc.jpeg"><br><br>  Si votre architecture est entièrement conforme au manifeste réactif, les composants de l'application évoluent indéfiniment avec une charge croissante indépendamment les uns des autres et résistent à la chute de n'importe quel nœud - vous connaissez la réponse.  <b>Sinon</b> , <b>Oleg Nizhnikov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Odomontois</a> ) expliquera comment le problème d'évolutivité a été résolu chez Tinkoff en construisant son cache de secours indolore sur Scala sans réécrire l'application. <br><br>  <i>Remarque</i>  <i>L'article aura un minimum de code Scala et un maximum de principes et d'idées générales.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p9j6_nOP4Kk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Backend instable ou lent </h2><br>  Lors de l'interaction avec le backend, l'application moyenne est rapide.  Mais le backend fait la majeure partie du travail et broie la plupart des données en interne - cela prend plus de temps.  Du temps supplémentaire est perdu à attendre une réponse du backend et du SGBD.  Même si l'application elle-même évolue facilement, ce goulot d'étranglement ne se modifie pas du tout.  Comment alléger la charge sur le backend et résoudre le problème? <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Votre service</b> <br></td><td>  <b>Backend</b> <br></td></tr><tr><td>  Temps de travail net dans chaque réponse: (dé) sérialisation, contrôles, logique, coûts asynchrones <br></td><td>  53 ms <br></td><td>  785ms <br></td></tr><tr><td>  En attente de backend et de SGBD <br></td><td>  3015 ms <br></td><td>  1932 ms <br></td></tr><tr><td>  Nombre de nœuds <br></td><td>  32 <br></td><td>  2 <br></td></tr><tr><td>  Réponse sommaire <br></td><td>  3070 ms <br></td><td>  2702 ms <br></td></tr></tbody></table></div><br><h3>  Cache intégré </h3><br>  La première idée est de prendre des données à lire, des requêtes qui reçoivent des données et de configurer le cache au niveau de chaque nœud en mémoire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/e7d/18f/e98e7d18f9f43d97f36941011d82b3b4.jpg"><br><br>  Le cache dure jusqu'à ce que le nœud redémarre et stocke uniquement la dernière donnée.  Si l'application se bloque et que de nouveaux utilisateurs qui n'ont pas été dans la dernière heure, le jour ou la semaine arrivent, l'application ne peut rien y faire. <br><br><h3>  Proxy </h3><br>  La deuxième option est un proxy, qui prend en charge une partie des demandes ou modifie l'application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ff/817/a49/7ff817a49b919c269c55e9995eaca4f0.jpg"><br><br>  Mais par proxy, vous ne pouvez pas faire tout le travail pour l'application elle-même. <br><br><h3>  Base de données de mise en cache </h3><br>  La troisième option est délicate lorsque la partie des données renvoyées par le backend peut être stockée pendant une longue période.  Lorsqu'elles sont nécessaires, nous montrons le client, même si elles ne sont plus pertinentes.  C'est mieux que rien. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/024/8a3/72f/0248a372f78828298f116a711321a55f.jpg"><br><br>  Cette décision sera discutée. <br><br><h2>  Cache de secours </h2><br>  Voici notre bibliothèque.  Il est intégré à l'application et communique avec le backend.  Avec un raffinement minimal, il analyse la structure des données, génère des formats de sérialisation et, à l'aide de l'algorithme du disjoncteur, augmente la tolérance aux pannes.  Une sérialisation efficace peut être implémentée dans n'importe quelle langue où les types peuvent être analysés à l'avance s'ils sont définis de manière suffisamment stricte. <br><br><h3>  Composants </h3><br>  Notre bibliothèque ressemble à ceci. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/57c/ce0/90657cce0e43cbaf09ba1a38b3e8eaff.jpg"><br><br>  La partie gauche est consacrée à l'interaction avec ce référentiel, qui comprend deux composants importants: <br><br><ul><li>  le composant qui est responsable du processus d'initialisation - actions préliminaires avec le SGBD avant d'utiliser Fallback Cache; <br></li><li>  module de génération de sérialisation automatique. <br></li></ul><br>  Le côté droit est la fonctionnalité générale qui se rapporte à Fallback. <br><br>  Comment ça marche?  Il existe des requêtes au milieu de l'application et des types intermédiaires pour le stockage de l'état.  Ce formulaire exprime les données que nous avons reçues du backend pour une ou plusieurs demandes.  Nous envoyons les paramètres à notre méthode et nous en obtenons les données.  Ces données doivent être sérialisées d'une manière ou d'une autre pour être stockées, nous les enveloppons donc dans du code.  Un module distinct en est responsable.  Nous avons utilisé le modèle de disjoncteur. <br><br><h3>  Exigences de stockage </h3><br>  <b>Longue durée de conservation - 30-500 jours</b> .  Certaines actions peuvent prendre du temps et pendant tout ce temps, il est nécessaire de stocker des données.  Par conséquent, nous voulons un stockage capable de stocker des données pendant une longue période.  En mémoire ne convient pas pour cela. <br><br>  <b>Grand volume de données - 100 Go-20 To</b> .  Nous voulons stocker des dizaines de téraoctets de données dans le cache, et encore plus en raison de la croissance.  Garder tout cela en mémoire est inefficace - la plupart des données ne sont pas constamment demandées.  Ils mentent depuis longtemps, attendant leur utilisateur, qui entrera et demandera.  En mémoire ne relève pas de ces exigences. <br><br>  <b>Haute disponibilité des données</b> .  Tout peut arriver au service, mais nous voulons que le SGBD reste disponible tout le temps. <br><br>  <b>Coûts de stockage réduits</b> .  Nous envoyons des données supplémentaires au cache.  En conséquence, des frais généraux se produisent.  Lors de la mise en œuvre de notre solution, nous voulons la minimiser. <br><br>  <b>Prise en charge des requêtes à intervalles</b> .  Notre base de données aurait dû être en mesure d'extraire une donnée non seulement dans son intégralité, mais à intervalles réguliers: une liste d'actions, l'historique d'un utilisateur pendant une certaine période.  Par conséquent, une valeur de clé pure ne convient pas. <br><br><h3>  Hypothèses </h3><br>  Les exigences réduisent la liste des candidats.  Nous supposons que nous avons implémenté le reste et faisons les hypothèses suivantes, sachant exactement pourquoi nous avons besoin de Fallback Cache. <br><br>  <b>L'intégrité des données entre deux demandes GET différentes n'est pas requise</b> .  Par conséquent, s'ils affichent deux états différents qui ne sont pas cohérents l'un avec l'autre, nous accepterons cela. <br><br>  <b>La pertinence et l'invalidation des données ne sont pas nécessaires</b> .  Au moment de la demande, il est supposé que nous avons la dernière version que nous montrons. <br><br>  Nous envoyons et recevons des données du backend.  <b>La structure de ces données est connue à l'avance</b> . <br><br><h2>  Sélection de stockage </h2><br>  Comme alternatives, nous avons considéré trois options principales. <br><br>  Le premier est <b>Cassandra</b> .  Avantages: haute disponibilité, évolutivité facile et mécanisme de sérialisation intégré avec la collection UDT. <br><br>  <b>UDT</b> ou <b>User Defined Types</b> , signifie un certain type.  Ils vous permettent d'empiler efficacement les types structurés.  Les champs de type sont connus à l'avance.  Ces champs de sérialisation sont marqués avec des balises distinctes comme dans les tampons de protocole.  Après avoir lu cette structure, il est possible de comprendre quels champs y sont basés sur des balises.  Assez de métadonnées pour connaître leur nom et leur type. <br><br>  Un autre avantage de Cassandra est qu'en plus de la clé de partition, il a une <b>clé de clustering</b> supplémentaire.  Il s'agit d'une clé spéciale, grâce à laquelle les données sont ordonnées sur un nœud.  Cela vous permet d'implémenter une option telle que les requêtes d'intervalle. <br><br>  Cassandra existe depuis relativement longtemps, il existe de <b>nombreuses solutions de surveillance pour elle</b> , et <b>un inconvénient est la JVM</b> .  Ce n'est pas l'option la plus productive pour les plates-formes sur lesquelles vous pouvez écrire un SGBD.  La machine virtuelle Java a des problèmes avec la récupération de place et la surcharge. <br><br>  La deuxième option est <b>CouchBase</b> .  Avantages: accessibilité des données, évolutivité et Schemaless. <br><br>  Avec CouchBase, vous devez penser moins à la sérialisation.  C'est à la fois un plus et un moins - nous n'avons pas besoin de contrôler le schéma de données.  Il existe des index globaux qui vous permettent d'exécuter des requêtes d'intervalle globalement sur un cluster. <br><br>  CouchBase est un hybride où <b>Memcache est</b> ajouté à un <b>cache</b> SGBD habituel <b>- rapide</b> .  Il vous permet de mettre automatiquement en cache toutes les données sur le nœud - les plus chaudes, avec une très haute disponibilité.  Grâce à son cache, CouchBase peut être rapide si les mêmes données sont demandées très souvent. <br><br>  <b>Schemaless</b> et <b>JSON</b> peuvent également être un inconvénient.  Les données peuvent être stockées si longtemps que l'application a le temps de changer.  Dans ce cas, la structure de données que CouchBase va stocker et lire changera également.  La version précédente n'est peut-être pas compatible.  Vous ne l'apprendrez que lors de la lecture, et non lors du développement des données, quand elles se situent quelque part dans la production.  Nous devons penser à une migration appropriée, et c'est exactement ce que nous ne voulons pas faire. <br><br>  La troisième option est <b>Tarantool</b> .  Il est célèbre pour sa super vitesse.  Il a un merveilleux moteur LUA qui vous permet d'écrire un tas de logique qui s'exécutera directement sur le serveur sur LuaJit. <br><br>  En revanche, il s'agit d'une valeur de clé modifiée.  Les données sont stockées dans des tuples.  Nous devons penser par nous-mêmes à la sérialisation correcte, ce n'est pas toujours une tâche évidente.  Tarantool a également une approche spécifique de l' <b>évolutivité</b> .  Ce qui ne va pas avec lui, nous en discuterons plus loin. <br><br><h3>  Partage / réplication </h3><br>  Peut-être que notre application aura besoin de <b>Sharding / Replication</b> .  Trois référentiels les implémentent différemment. <br><br>  Cassandra suggère une structure qui est généralement appelée un «anneau». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/b22/828/387b228289ece281dd70ecea2ded8890.jpg"><br><br>  De nombreux nœuds sont disponibles.  Chacun d'entre eux stocke ses données et les données des nœuds les plus proches sous forme de répliques.  Si l'un abandonne, les nœuds à côté de lui peuvent servir une partie de ses données jusqu'à ce que le décrochage augmente. <br><br>  Sharding \ Replication est responsable de la même structure.  Pour décompresser en 10 pièces et facteur de réplication 3, 10 nœuds suffisent.  Chacun des nœuds stockera 2 répliques des voisins. <br><br>  Dans CouchBase, la structure d'interaction entre les nœuds est structurée de manière similaire: <br><br><ul><li>  il existe des données marquées comme actives, dont le nœud lui-même est responsable; <br></li><li>  Il existe des répliques de nœuds voisins que CouchBase stocke. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/296/09a/1c8/29609a1c8391653566cb36ab9434da21.jpg"><br><br>  Si un nœud tombe en panne, les voisins, partagés, prennent la responsabilité de la maintenance de cette partie des clés. <br><br>  Dans Tarantool, l'architecture est similaire à MongoDB.  Mais avec une nuance: il existe des groupes de partitionnement qui sont répliqués les uns avec les autres. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/5f8/5a5/e815f85a59d330b8250071def6cc0d25.jpg"><br><br>  Pour les deux architectures précédentes, si nous voulons créer 4 fragments et le facteur de réplication 3, 4 nœuds sont nécessaires.  Pour Tarantool - 12!  Mais l'inconvénient est compensé par la vitesse garantie par Tarantool. <br><br><h2>  Cassandra </h2><br>  Des modules optionnels pour le sharding dans Tarantool sont apparus récemment.  Par conséquent, nous avons choisi le SGBD Cassandra comme candidat principal.  Rappelons que nous avons parlé de sa sérialisation spécifique. <br><br><h3>  Sérialisation automatique </h3><br><blockquote>  Le protocole SQL suppose que vous définissez le schéma de données assez librement. </blockquote><br>  Vous pouvez utiliser cela comme un avantage.  Par exemple, sérialisez les données afin que les noms de champs longs de nos structures feuillues ne soient pas stockés à chaque fois dans nos valeurs.  Dans ce cas, nous aurons des métadonnées qui décrivent le périphérique de données.  Les UDT eux-mêmes indiquent également quels champs correspondent aux étiquettes et aux balises. <br><br>  Par conséquent, la sérialisation générée automatiquement se déroule approximativement de la même manière.  Si nous avons l'un des types de base qui peut correspondre au type de la base de données un à un, nous le faisons.  Un ensemble de types Int, Long, String, Double est également dans Cassandra. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de données d'application</b> <br></td><td>  <b>Type de données dans Cassandra</b> <br></td></tr><tr><td>  Type primitif <br>  (Int, Long, String, Double, BigDecimal) <br></td><td>  Type primitif <br>  (int, biging, texte, double, décimal) <br></td></tr></tbody></table></div><br>  Si un champ facultatif est rencontré dans une certaine structure, nous ne faisons rien de plus.  Nous lui indiquons le type vers lequel ce champ doit se transformer.  La structure stockera null.  Si nous trouvons nul dans la structure au niveau de la désérialisation, nous supposons que c'est l'absence de valeur. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de données d'application</b> <br></td><td>  <b>Type de données dans Cassandra</b> <br></td></tr><tr><td>  Option [A] <br></td><td>  un <br></td></tr></tbody></table></div><br>  Tous les types de collection de la collection dans Scala sont convertis en liste de types.  Ce sont des collections ordonnées qui ont un élément correspondant à un index. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de données d'application</b> <br></td><td>  <b>Type de données dans Cassandra</b> <br></td></tr><tr><td>  Seq [A], List [A], Stream [A], Vector [A] <br></td><td>  &lt;liste "a"&gt; figée <br></td></tr></tbody></table></div><br>  Les collections Set non ordonnées garantissent qu'il y a exactement un élément avec chaque valeur.  Cassandra a également un type de jeu spécial pour eux. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de données d'application</b> <br></td><td>  <b>Type de données dans Cassandra</b> <br></td></tr><tr><td>  Définir [A] <br></td><td>  figé &lt;set "a"&gt; <br></td></tr></tbody></table></div><br>  Très probablement, nous aurons beaucoup de mapping (), en particulier avec les clés de chaîne.  Cassandra a un type de carte spécial pour eux.  Il est également tapé et possède deux paramètres de type.  Afin que nous puissions créer un type approprié pour n'importe quelle clé <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de données d'application</b> <br></td><td>  <b>Type de données dans Cassandra</b> <br></td></tr><tr><td>  Carte [K, V] <br></td><td>  &lt;map "k, v"&gt; figé <br></td></tr></tbody></table></div><br>  Il existe des types de données que nous définissons nous-mêmes dans notre application.  Dans de nombreuses langues, ils sont appelés <b>types de données algébriques</b> .  Ils sont définis en définissant un produit nommé de types, c'est-à-dire une structure.  Nous attribuons cette structure au type défini par l'utilisateur.  Chaque champ de la structure correspondra à un champ de l'UDT. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de données d'application</b> <br></td><td>  <b>Type de données dans Cassandra</b> <br></td></tr><tr><td>  Type de produit: classe de cas <br></td><td>  UDT <br></td></tr></tbody></table></div><br>  Le deuxième type est la <b>somme algébrique des types</b> .  Dans ce cas, le type correspond à plusieurs sous-types ou sous-espèces précédemment connus.  Aussi, d'une certaine manière, nous lui attribuons une structure. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de données d'application</b> <br></td><td>  <b>Type de données dans Cassandra</b> <br></td></tr><tr><td>  Type Sum: trait scellé \ classe <br></td><td>  UDT <br></td></tr></tbody></table></div><br><h3>  Type de données abstrait traduit en UDT </h3><br>  Nous avons une structure que nous affichons une à une - pour chaque champ, nous définissons le champ dans l'UDT créé à Cassandra: <br><br><pre><code class="plaintext hljs">case class Account ( id: Long, tags: List[String], user: User, finData: Option[FinData] ) create type account ( id bigint, tags: frozen&lt;list&lt;text&gt;&gt;, user frozen&lt;user&gt;, fin_data frozen&lt;fin_data&gt; )</code> </pre> <br>  Les types primitifs se transforment en types primitifs.  Un lien vers un type prédéfini avant qu'il ne soit gelé.  Il s'agit d'un emballage spécial dans Cassandra, ce qui signifie que vous ne pouvez pas lire ce champ morceau par morceau.  L'encapsuleur est «figé» dans cet état.  Nous pouvons uniquement lire ou enregistrer l'utilisateur, ou la liste, comme dans le cas des tags. <br><br>  Si nous rencontrons un champ facultatif, nous rejetons cette caractéristique.  Nous prenons uniquement le type de données correspondant au type de champ qui le sera.  Si nous rencontrons non ici - l'absence de valeur - nous écrivons null dans le champ correspondant.  Lors de la lecture, nous prendrons également la correspondance non nulle. <br><br>  Si nous rencontrons un type qui a plusieurs alternatives pré-connues, nous définissons également un nouveau type de données dans Cassandra.  Pour chaque alternative, un champ dans notre type de données en UDT. <br><br>  Par conséquent, dans cette structure, un seul des champs à un moment donné ne sera pas nul.  Si vous avez rencontré un type d'utilisateur et qu'il s'est avéré être une instance d'un modérateur lors de l'exécution, le champ modérateur contiendra une valeur, le reste sera nul.  Pour admin - admin, le reste - null. <br><br>  Cela vous permet d'encoder la structure comme suit: nous avons 4 champs optionnels, nous garantissons qu'un seul sera écrit à partir d'eux.  Cassandra utilise une seule balise pour identifier la présence d'un champ particulier dans la structure.  Grâce à cela, nous obtenons une structure de stockage sans frais généraux. <br><br>  En fait, pour enregistrer le type d'utilisateur, s'il s'agit d'un modérateur, il faudra le même nombre d'octets nécessaires pour stocker le modérateur.  Plus un octet pour montrer quelle alternative particulière est présente ici. <br><br><h3>  Initialisation </h3><br><blockquote>  L'initialisation est une procédure préliminaire qui doit être terminée avant de pouvoir utiliser notre solution de repli. </blockquote><br>  Comment fonctionne ce processus? <br><br><ul><li>  Sur chaque nœud, nous générons des définitions de tables, de types et de textes de requête en fonction des types présentés. <br></li><li>  Lisez le schéma actuel du SGBD.  À Cassandra, cela est facile à faire en se connectant simplement à elle.  Lorsqu'il est connecté, dans presque tous les pilotes, l'objet «session» proprement dit pompe les métadonnées de l'espace clé auxquelles il est connecté.  Ensuite, vous pouvez voir ce qu'ils ont. <br></li><li>  Nous parcourons les métadonnées, comparons et vérifions que tout ce que nous voulons créer est autorisé et qu'une migration incrémentielle est possible. <br></li><li>  Si tout est normal et que l'initialisation est possible, nous effectuons la migration. <br></li><li>  Nous préparons des demandes. <br></li></ul><br><pre> <code class="plaintext hljs">sealed trait User case class Anonymous extends User case class Registered extends User case class Moderator extends User case class Admin extends User create type user ( anonymous frozen&lt;anonymous&gt;, registered frozen&lt;registered&gt;, moderator frozen&lt;moderator&gt;, admin frozen&lt;admin&gt; )</code> </pre> <br>  Ça se passe comme ça.  Nous avons des <b>types</b> , des <b>tables</b> et des <b>requêtes</b> .  Les types dépendent d'autres types, ceux des autres.  Les tableaux dépendent de ces types.  Les requêtes dépendent déjà des tables à partir desquelles elles lisent les données.  L'initialisation vérifiera toutes ces dépendances et créera dans le SGBD tout ce qu'il peut créer, selon certaines règles. <br><br><h3>  Type de migration </h3><br>  Comment déterminer qu'un type peut être migré de manière incrémentielle? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/eeb/554/105eeb554bcc5eadaf10753f8c150531.jpg"><br><br><ul><li>  Nous lisons comment ce type est défini dans le SGBD. <br></li><li>  S'il n'y a pas un tel type, c'est que nous en avons trouvé un nouveau - nous le créons. <br></li><li>  Si un tel type existe déjà, nous essayons de comparer champ par champ la définition existante avec celle que nous voulons donner à ce type. <br></li><li>  S'il s'avère que nous voulons ajouter seulement quelques champs qui n'existent plus, nous le faisons.  Créez une liste d'opérations ALTER TYPE en mutation et lancez-les. <br></li><li>  S'il s'avère que nous avons une sorte de champ qui était d'un type différent - nous générons une erreur.  Par exemple, il y avait list - est devenu map, ou il y avait un lien vers un type défini par l'utilisateur, et nous essayons de le rendre différent. <br></li></ul><br>  Le développeur peut voir cette erreur avant même de commencer la fonctionnalité en production.  Je suppose que le même schéma de données exact est dans son environnement de développement.  Il voit qu'il a en quelque sorte créé un schéma de données non migrable, et pour éviter ces erreurs, il peut remplacer la sérialisation générée automatiquement, ajouter des options, renommer des champs ou tous les types et tables dans leur ensemble. <br><br><h3>  Initialisation: types </h3><br>  Imaginez qu'il existe plusieurs types de définitions: <br><br><pre> <code class="plaintext hljs">case class Product (id: Long, name: ctring, price: BigDecimal) case class UserOffers (valiDate: LocalDate, offers: Seq[Products]) case class UserProducts (user User, products: Map[Date, Product]) case class UserInfo: UserOffers, products: UserProducts)</code> </pre> <br>  <b>Classe de cas</b> - une classe qui contient un ensemble de champs.  Il s'agit d'un analogue de struct dans Rust. <br><br>  Nous générerons approximativement de telles définitions de données pour chacun des 4 types - ce que nous voulons éventuellement augmenter: <br><br><pre> <code class="plaintext hljs">CREATE TYPE product (id bigint, name text, price decimal); CREATE TYPE user_offers (valid_date date, offers frozen&lt;list&lt;frozen&lt;offer&gt;&gt;&gt;); CREATE TYPE user_products (user frozen&lt;user&gt;, products frozen&lt;map&lt;date, frozen&lt;product&gt;&gt;); CREATE TYPE user_jnfo (offers: frozen&lt;user_offers&gt;, products: frozen&lt;user_products&gt;);</code> </pre> <br>  Le type de user_offers dépend du type d'offre, user_products dépend du type de produit, user_info sur les deuxième et troisième types. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5bb/e3b/e9d/5bbe3be9d2694677b42b59613305752b.jpg"><br><br>  Nous avons une telle dépendance entre les types et nous voulons l'initialiser correctement.  Le diagramme montre que nous initialiserons en parallèle user_offers et user_products.  Cela ne signifie pas que nous lancerons deux opérations parallèles.  Non, nous démarrons toutes les instructions, toutes les analyses de manière séquentielle, afin de ne pas créer accidentellement le même type dans deux threads parallèles. <br><br>  Mais il existe un certain parallélisme au niveau de la correction d'erreur.  Si une erreur de type se produit, tout ce qui en dépend extraira l'erreur d'origine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/122/93f/0ba/12293f0bab8bd0a8b7e12d092380a5c5.jpg"><br><br>  Si une erreur est générée par l'une des branches parallèles, tout ce qui dépend des données normalement migrées sera généré sans erreur.  S'il existe d'autres définitions de tables, des instructions préparées à partir de celles-ci, nous pouvons initialiser en toute sécurité cette partie de notre cache de secours.  La communication sera perdue uniquement avec une partie des backends ou avec certaines fonctionnalités.  Les restes sont initialisés. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/5ec/3a2/a8d5ec3a2483d899c7db16ac56974fe9.jpg"><br><br>  Il peut arriver que deux types initialisés simultanément génèrent des erreurs différentes.  Dans ce cas, une fonctionnalité qui dépend des deux types produira un type d'erreur de sommation.  Le développeur, initialisant son Fallback dans l'environnement de développement, recevra une liste complète des données avec des erreurs.  Naturellement, il peut le corriger ici et aller plus loin.  Mais il ne sera pas tel qu'une branche complètement indépendante ferme les erreurs que nous pourrions obtenir, quelle que soit cette branche. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/e94/4ba/d08e944ba9b210d16f6f6c0b57048051.jpg"><br><br><h3>  Initialisation: tableaux </h3><br>  Ensuite, nous créons les tables. <br><br><pre> <code class="plaintext hljs">def getOffer (user: User, number: Long): Future[OfferData] create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt;PRIMARY KEY, value frozen&lt;friend_data&gt; )</code> </pre> <br>  Une telle demande peut lancer directement une demande REST ou SOAP, créer des opérations supplémentaires à l'intérieur ou même exécuter plusieurs demandes.  Tout dépend de votre code - comment vous avez organisé le code.  Fallback n'analyse pas complètement ce qui se passe à l'intérieur de la méthode à laquelle vous accrochez un tel talon. <br><br><blockquote>  La méthode doit être asynchrone, car Fallback est identique. </blockquote><br>  À Scala, cela est étiqueté avec un type spécial de Future.  Cela signifie que le résultat reviendra un jour.  Quand exactement - c'est inconnu: peut-être tout de suite, ou peut-être pas. <br><br>  Pour la méthode, créez une table.  La clé du tableau est un tuple de tous types correspondant aux paramètres de cette méthode.  La valeur non clé est le résultat, qui est renvoyé de manière asynchrone.  Pour chacune de ces tables, nous préparons à l'avance deux requêtes paramétriques: insérer des données et lire des données. <br><br><pre> <code class="plaintext hljs">insert into get_offer(key, value) values (?key, ?value); select value from get_offer where key = ?key;</code> </pre> <br>  Tout est prêt à interagir avec le SGBD.  Reste à savoir comment nous lirons les données de Fallback. <br><br><h3>  Disjoncteur </h3><br>  Ici, la responsabilité passe dans la zone du fameux modèle de disjoncteur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c0/de1/91c/5c0de191c5c1699cc8f324f38d62b6ee.jpg"><br><br>  Un disjoncteur typique comprend trois états. <br><br>  <b>Closed - l'état fermé par défaut</b> qui ferme notre backend.  Le principe est que nous lisons d'abord les données depuis le backend, et seulement si nous ne pouvons pas les obtenir, allez à Fallback.  Si nous avons réussi à obtenir les données, nous ne regardons pas dans Fallback, mais nous y enregistrons les données et rien ne se passe. <br><br>  Si les problèmes se succèdent, nous supposons que le backend ment.  Afin de ne pas le spammer avec une quantité gigantesque de nouvelles requêtes, nous passons à <b>Open - dans un état déchiré</b> .  Dans ce document, nous essayons de lire uniquement les données de Fallback.  Si cela ne fonctionne pas, nous renvoyons immédiatement une erreur et ne touchons même pas le backend principal. <br><br>  Après un certain temps, nous décidons de savoir si le backend s'est réveillé et essayons de réinitialiser l'état <b>Half-Open - un état de courte durée</b> .  Sa durée de vie est une demande. <br><br>  Dans l'état de courte durée, nous choisissons de refermer ou d'ouvrir encore plus longtemps.  Si dans l'état semi-ouvert, nous atteignons avec succès Fallback et recevons la prochaine demande, nous passons à l'état fermé.  Si nous ne pouvions pas passer, nous retournons à Open, mais pour longtemps. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ad/92e/4a4/9ad92e4a417201c8655ed4785ae21dfc.jpg"><br><br>  Nous avons ajouté deux états supplémentaires qui ne sont clairement pas liés au circuit du disjoncteur: <br><br><ul><li>  Forcé - état fermé de force; <br></li><li>  Inversé - priorité pour l'état ouvert, fermé inversé. <br></li></ul><br>  Voyons voir ce qu'ils font. <br><br><h3>  Le principe de fonctionnement des États </h3><br>  <b>Fermé</b>  Le schéma est vaste, mais il suffit d'en comprendre le principe général.  Nous gardons Fallback en parallèle avec la façon dont nous renvoyons le résultat du backend, si tout s'est bien passé et lu à partir de Fallback.  Si c'est mauvais partout, nous renvoyons la priorité d'erreur. <br><br><blockquote>  Parmi les deux erreurs, sélectionnez l'erreur de backend. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/541/f99/5b7541f99197cc1730c6a934cebe6516.jpg"><br><br>  S'il n'y a pas d'erreur, nous incrémentons le compteur en parallèle et passons à l'état ouvert lorsqu'il y a trop de requêtes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/182/18f/25d/18218f25de112cf7f6a88291fccbe72f.jpg"><br><br>  <b>Ouverte</b>  L'état ouvert d'Open est plus simple - nous lisons constamment dans Fallback, quoi qu'il arrive, et après un certain temps, nous essayons de passer à l'état semi-ouvert. <br><br>  <b>Demi-ouvert</b> .  L'état dans la structure ressemble à fermé.  La différence est que dans le cas d'une réponse réussie, nous entrons dans un état fermé.  En cas d'échec - nous revenons à l'ouverture avec un intervalle prolongé. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/a1e/7c8/b82a1e7c89774bbe327613b51f50f5c0.jpg"><br><br>  <b>Forcé est un état supplémentaire pour réchauffer le cache</b> .  Lorsque nous le remplissons de données, il n'essaie jamais de lire à partir de Fallback, mais ajoute uniquement des enregistrements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdc/8e3/b33/bdc8e3b335750b826fdd21db6c0f0ac7.jpg"><br><br>  <b>Inversé est un deuxième état farfelu</b> .  Cela fonctionne comme un cache persistant.  Nous activons l'état lorsque nous voulons supprimer définitivement la charge du backend, même si les données peuvent ne pas être pertinentes.  Inversé les premières recherches dans Fallback, et si la recherche a échoué, elle va au backend et la traite. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/618/0da/8ed/6180da8edf69398780bd37fae9bc8ba7.jpg"><br><br><h3>  Les problèmes </h3><br>  Avec tout ce schéma, nous avons eu plusieurs problèmes.  Le plus grave est de comprendre comment fonctionnent les <b>déclarations préparées</b> à Cassandra.  Ce problème a été corrigé dans la version 4.0, qui n'a pas encore été publiée, donc je vais vous le dire. <br><br>  Cassandra est conçue pour y connecter des millions de clients en même temps, et tout le monde essaie de préparer ses relevés préparés.  Naturellement, Cassandra ne prépare pas chaque instruction préparée, sinon elle manquera de mémoire.  Il calcule le paramètre MD5 en fonction du texte, de l'espace clé et des options de requête.  Si elle reçoit exactement la même demande avec exactement le même MD5, elle prend la demande déjà préparée.  Il contient déjà des informations sur les métadonnées et comment les gérer. <br><br>  Mais il y a des problèmes de version.  Nous publions une nouvelle version, elle a réussi les migrations, ajouté des champs dans les types et exécuté des instructions préparées.  Ils reviennent avec la version précédente de notre état et de nos métadonnées - avec des types sans champs.  Au moment de la lecture des données, nous essayons d'écrire leurs nouvelles colonnes obligatoires, et sommes confrontés au fait qu'elles n'existent tout simplement pas!  Cassandra dit que c'est généralement un type différent qu'elle ne connaît pas. <br><br>  Nous avons traité ce problème comme suit: nous avons <b>ajouté un texte unique à chacune de nos demandes préparées</b> . <br><br><pre> <code class="plaintext hljs">create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt; PRIMARY KEY, value frozen&lt;friend_data&gt;, query_tag text ) insert into get_offer (key, value, query_tag) values (?key, ?value, 'tag_123'); select value as tag_123 from get_offer where key = ?key;</code> </pre> <br>  Nous n'aurons pas des millions de clients connectés, mais une seule session pour chaque nœud qui détient plusieurs connexions.  Pour chaque préparation de déclaration une fois.  Nous supposons que tout va bien si pour chaque version de l'application ou pour chaque début de nœud, un texte unique est généré, qui sera clairement dans le texte de notre demande. <br><br>  Nous avons ajouté un champ spécial pour le tromper.  Lors de l'insertion, nous écrivons une constante dans ce champ.  Il est unique pour chaque lancement ou version d'application - il est configuré dans la bibliothèque.  Lors de la lecture, nous utilisons ce nom comme alias pour la valeur que nous obtenons.  La demande est exactement la même, nous faisons toujours une sélection de valeur, mais le texte est différent.  Cassandra ne se rend pas compte qu'il s'agit de la même demande, calcule un autre MD5 et prépare à nouveau la demande avec de nouvelles métadonnées. <br><br>  Le deuxième problème est la <b>course à</b> la <b>migration</b> .  Par exemple, nous voulons effectuer plusieurs migrations parallèles.  Commençons quelques notes et en même temps ils commenceront les calculs, ils exécuteront créer des tables, créer des types.  Cela peut conduire au fait que sur chaque nœud ou dans chacun des threads parallèles, tout réussira et que deux tables semblent avoir été créées avec succès.  Mais à l'intérieur, Cassandra est confuse et nous recevrons des délais pour écrire et lire. <br><br><blockquote>  Vous pouvez casser Cassandra si vous essayez de paralléliser des processus à partir de plusieurs threads ou de plusieurs nœuds. </blockquote><br>  Si nous savons que nous devons avoir la migration de secours, nous <b>migrons à partir d'un nœud spécial avant la publication</b> .  Ce n'est qu'alors que nous démarrerons tous nos nœuds lors de la publication.  Nous avons donc résolu ce problème. <br><br>  Le troisième problème est le <b>manque de données dans Fallback Cache</b> .  Il se peut que nous ayons «soutenu» la méthode, elle devrait stocker les données historiques d'il y a un an, mais en réalité nous l'avons lancée hier. <br><br>  <b>Le problème a été résolu par l'échauffement</b> .  Nous avons utilisé l'état Forced et lancé des nœuds spéciaux qui ne communiqueront pas avec de vrais utilisateurs.  Ils prendront toutes les clés possibles que nous supposons et réchaufferont le cache en cercle.  L'échauffement va si vite pour ne pas tuer le backend que nous lisons. <br><br><blockquote>  Mise à l'échelle des applications, du backend, du big data et du frontend - Scala convient à tout cela.  Le 26 novembre, nous organisons une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conférence</a> professionnelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour les développeurs Scala</a> .  Styles, approches, des dizaines de solutions pour le même problème, les nuances de l'utilisation d'approches anciennes et éprouvées, la pratique de la programmation fonctionnelle, la théorie de la cosmonautique fonctionnelle radicale - nous parlerons de tout cela lors de la conférence.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Demandez</a> un rapport si vous souhaitez partager votre expérience Scala avant le 26 septembre ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">réservez vos billets</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466295/">https://habr.com/ru/post/fr466295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466283/index.html">Opencartforum et amis</a></li>
<li><a href="../fr466285/index.html">Un petit cadeau: combo dvr et détecteur de radar</a></li>
<li><a href="../fr466287/index.html">Rapport et recherche sur la fiabilité des segments Internet nationaux 2019</a></li>
<li><a href="../fr466289/index.html">Initiatives législatives. Étrange, mais présenté à la Douma d'État</a></li>
<li><a href="../fr466291/index.html">Enquête de durabilité des segments Internet nationaux pour 2019</a></li>
<li><a href="../fr466299/index.html">Des sociologues russes ont mené le premier sondage mondial sur les chatbots</a></li>
<li><a href="../fr466301/index.html">Autre chose: des packages d'application Haiku?</a></li>
<li><a href="../fr466305/index.html">Takashi Kokubun: comment accélérer l'exécution des applications Ruby</a></li>
<li><a href="../fr466307/index.html">Comment concevoir SCS</a></li>
<li><a href="../fr466311/index.html">Atelier SLS 6 septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>