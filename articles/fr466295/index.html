<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≥üèº üõèÔ∏è üîÆ Cache de secours indolore sur Scala üíáüèª üêä üö£üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les grandes architectures ou microservices, le service le plus important n'est pas toujours le plus productif et n'est parfois pas destin√© √† une ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cache de secours indolore sur Scala</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/466295/"> Dans les grandes architectures ou microservices, le service le plus important n'est pas toujours le plus productif et n'est parfois pas destin√© √† une charge √©lev√©e.  Nous parlons du backend.  Il fonctionne lentement - il perd du temps sur le traitement des donn√©es et l'attente d'une r√©ponse entre celui-ci et le SGBD, et n'est pas √©volutif.  M√™me si l'application elle-m√™me √©volue facilement, ce goulot d'√©tranglement ne se modifie pas du tout.  Comment r√©soudre ce probl√®me et garantir des performances √©lev√©es?  Comment fournir une r√©ponse syst√®me lorsque des sources d'informations importantes sont silencieuses? <br><br><img src="https://habrastorage.org/webt/tw/3o/ti/tw3otiqpnki3jcwa8ittvdrpzoc.jpeg"><br><br>  Si votre architecture est enti√®rement conforme au manifeste r√©actif, les composants de l'application √©voluent ind√©finiment avec une charge croissante ind√©pendamment les uns des autres et r√©sistent √† la chute de n'importe quel n≈ìud - vous connaissez la r√©ponse.  <b>Sinon</b> , <b>Oleg Nizhnikov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Odomontois</a> ) expliquera comment le probl√®me d'√©volutivit√© a √©t√© r√©solu chez Tinkoff en construisant son cache de secours indolore sur Scala sans r√©√©crire l'application. <br><br>  <i>Remarque</i>  <i>L'article aura un minimum de code Scala et un maximum de principes et d'id√©es g√©n√©rales.</i> <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/p9j6_nOP4Kk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Backend instable ou lent </h2><br>  Lors de l'interaction avec le backend, l'application moyenne est rapide.  Mais le backend fait la majeure partie du travail et broie la plupart des donn√©es en interne - cela prend plus de temps.  Du temps suppl√©mentaire est perdu √† attendre une r√©ponse du backend et du SGBD.  M√™me si l'application elle-m√™me √©volue facilement, ce goulot d'√©tranglement ne se modifie pas du tout.  Comment all√©ger la charge sur le backend et r√©soudre le probl√®me? <br><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Votre service</b> <br></td><td>  <b>Backend</b> <br></td></tr><tr><td>  Temps de travail net dans chaque r√©ponse: (d√©) s√©rialisation, contr√¥les, logique, co√ªts asynchrones <br></td><td>  53 ms <br></td><td>  785ms <br></td></tr><tr><td>  En attente de backend et de SGBD <br></td><td>  3015 ms <br></td><td>  1932 ms <br></td></tr><tr><td>  Nombre de n≈ìuds <br></td><td>  32 <br></td><td>  2 <br></td></tr><tr><td>  R√©ponse sommaire <br></td><td>  3070 ms <br></td><td>  2702 ms <br></td></tr></tbody></table></div><br><h3>  Cache int√©gr√© </h3><br>  La premi√®re id√©e est de prendre des donn√©es √† lire, des requ√™tes qui re√ßoivent des donn√©es et de configurer le cache au niveau de chaque n≈ìud en m√©moire. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e98/e7d/18f/e98e7d18f9f43d97f36941011d82b3b4.jpg"><br><br>  Le cache dure jusqu'√† ce que le n≈ìud red√©marre et stocke uniquement la derni√®re donn√©e.  Si l'application se bloque et que de nouveaux utilisateurs qui n'ont pas √©t√© dans la derni√®re heure, le jour ou la semaine arrivent, l'application ne peut rien y faire. <br><br><h3>  Proxy </h3><br>  La deuxi√®me option est un proxy, qui prend en charge une partie des demandes ou modifie l'application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ff/817/a49/7ff817a49b919c269c55e9995eaca4f0.jpg"><br><br>  Mais par proxy, vous ne pouvez pas faire tout le travail pour l'application elle-m√™me. <br><br><h3>  Base de donn√©es de mise en cache </h3><br>  La troisi√®me option est d√©licate lorsque la partie des donn√©es renvoy√©es par le backend peut √™tre stock√©e pendant une longue p√©riode.  Lorsqu'elles sont n√©cessaires, nous montrons le client, m√™me si elles ne sont plus pertinentes.  C'est mieux que rien. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/024/8a3/72f/0248a372f78828298f116a711321a55f.jpg"><br><br>  Cette d√©cision sera discut√©e. <br><br><h2>  Cache de secours </h2><br>  Voici notre biblioth√®que.  Il est int√©gr√© √† l'application et communique avec le backend.  Avec un raffinement minimal, il analyse la structure des donn√©es, g√©n√®re des formats de s√©rialisation et, √† l'aide de l'algorithme du disjoncteur, augmente la tol√©rance aux pannes.  Une s√©rialisation efficace peut √™tre impl√©ment√©e dans n'importe quelle langue o√π les types peuvent √™tre analys√©s √† l'avance s'ils sont d√©finis de mani√®re suffisamment stricte. <br><br><h3>  Composants </h3><br>  Notre biblioth√®que ressemble √† ceci. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/906/57c/ce0/90657cce0e43cbaf09ba1a38b3e8eaff.jpg"><br><br>  La partie gauche est consacr√©e √† l'interaction avec ce r√©f√©rentiel, qui comprend deux composants importants: <br><br><ul><li>  le composant qui est responsable du processus d'initialisation - actions pr√©liminaires avec le SGBD avant d'utiliser Fallback Cache; <br></li><li>  module de g√©n√©ration de s√©rialisation automatique. <br></li></ul><br>  Le c√¥t√© droit est la fonctionnalit√© g√©n√©rale qui se rapporte √† Fallback. <br><br>  Comment √ßa marche?  Il existe des requ√™tes au milieu de l'application et des types interm√©diaires pour le stockage de l'√©tat.  Ce formulaire exprime les donn√©es que nous avons re√ßues du backend pour une ou plusieurs demandes.  Nous envoyons les param√®tres √† notre m√©thode et nous en obtenons les donn√©es.  Ces donn√©es doivent √™tre s√©rialis√©es d'une mani√®re ou d'une autre pour √™tre stock√©es, nous les enveloppons donc dans du code.  Un module distinct en est responsable.  Nous avons utilis√© le mod√®le de disjoncteur. <br><br><h3>  Exigences de stockage </h3><br>  <b>Longue dur√©e de conservation - 30-500 jours</b> .  Certaines actions peuvent prendre du temps et pendant tout ce temps, il est n√©cessaire de stocker des donn√©es.  Par cons√©quent, nous voulons un stockage capable de stocker des donn√©es pendant une longue p√©riode.  En m√©moire ne convient pas pour cela. <br><br>  <b>Grand volume de donn√©es - 100 Go-20 To</b> .  Nous voulons stocker des dizaines de t√©raoctets de donn√©es dans le cache, et encore plus en raison de la croissance.  Garder tout cela en m√©moire est inefficace - la plupart des donn√©es ne sont pas constamment demand√©es.  Ils mentent depuis longtemps, attendant leur utilisateur, qui entrera et demandera.  En m√©moire ne rel√®ve pas de ces exigences. <br><br>  <b>Haute disponibilit√© des donn√©es</b> .  Tout peut arriver au service, mais nous voulons que le SGBD reste disponible tout le temps. <br><br>  <b>Co√ªts de stockage r√©duits</b> .  Nous envoyons des donn√©es suppl√©mentaires au cache.  En cons√©quence, des frais g√©n√©raux se produisent.  Lors de la mise en ≈ìuvre de notre solution, nous voulons la minimiser. <br><br>  <b>Prise en charge des requ√™tes √† intervalles</b> .  Notre base de donn√©es aurait d√ª √™tre en mesure d'extraire une donn√©e non seulement dans son int√©gralit√©, mais √† intervalles r√©guliers: une liste d'actions, l'historique d'un utilisateur pendant une certaine p√©riode.  Par cons√©quent, une valeur de cl√© pure ne convient pas. <br><br><h3>  Hypoth√®ses </h3><br>  Les exigences r√©duisent la liste des candidats.  Nous supposons que nous avons impl√©ment√© le reste et faisons les hypoth√®ses suivantes, sachant exactement pourquoi nous avons besoin de Fallback Cache. <br><br>  <b>L'int√©grit√© des donn√©es entre deux demandes GET diff√©rentes n'est pas requise</b> .  Par cons√©quent, s'ils affichent deux √©tats diff√©rents qui ne sont pas coh√©rents l'un avec l'autre, nous accepterons cela. <br><br>  <b>La pertinence et l'invalidation des donn√©es ne sont pas n√©cessaires</b> .  Au moment de la demande, il est suppos√© que nous avons la derni√®re version que nous montrons. <br><br>  Nous envoyons et recevons des donn√©es du backend.  <b>La structure de ces donn√©es est connue √† l'avance</b> . <br><br><h2>  S√©lection de stockage </h2><br>  Comme alternatives, nous avons consid√©r√© trois options principales. <br><br>  Le premier est <b>Cassandra</b> .  Avantages: haute disponibilit√©, √©volutivit√© facile et m√©canisme de s√©rialisation int√©gr√© avec la collection UDT. <br><br>  <b>UDT</b> ou <b>User Defined Types</b> , signifie un certain type.  Ils vous permettent d'empiler efficacement les types structur√©s.  Les champs de type sont connus √† l'avance.  Ces champs de s√©rialisation sont marqu√©s avec des balises distinctes comme dans les tampons de protocole.  Apr√®s avoir lu cette structure, il est possible de comprendre quels champs y sont bas√©s sur des balises.  Assez de m√©tadonn√©es pour conna√Ætre leur nom et leur type. <br><br>  Un autre avantage de Cassandra est qu'en plus de la cl√© de partition, il a une <b>cl√© de clustering</b> suppl√©mentaire.  Il s'agit d'une cl√© sp√©ciale, gr√¢ce √† laquelle les donn√©es sont ordonn√©es sur un n≈ìud.  Cela vous permet d'impl√©menter une option telle que les requ√™tes d'intervalle. <br><br>  Cassandra existe depuis relativement longtemps, il existe de <b>nombreuses solutions de surveillance pour elle</b> , et <b>un inconv√©nient est la JVM</b> .  Ce n'est pas l'option la plus productive pour les plates-formes sur lesquelles vous pouvez √©crire un SGBD.  La machine virtuelle Java a des probl√®mes avec la r√©cup√©ration de place et la surcharge. <br><br>  La deuxi√®me option est <b>CouchBase</b> .  Avantages: accessibilit√© des donn√©es, √©volutivit√© et Schemaless. <br><br>  Avec CouchBase, vous devez penser moins √† la s√©rialisation.  C'est √† la fois un plus et un moins - nous n'avons pas besoin de contr√¥ler le sch√©ma de donn√©es.  Il existe des index globaux qui vous permettent d'ex√©cuter des requ√™tes d'intervalle globalement sur un cluster. <br><br>  CouchBase est un hybride o√π <b>Memcache est</b> ajout√© √† un <b>cache</b> SGBD habituel <b>- rapide</b> .  Il vous permet de mettre automatiquement en cache toutes les donn√©es sur le n≈ìud - les plus chaudes, avec une tr√®s haute disponibilit√©.  Gr√¢ce √† son cache, CouchBase peut √™tre rapide si les m√™mes donn√©es sont demand√©es tr√®s souvent. <br><br>  <b>Schemaless</b> et <b>JSON</b> peuvent √©galement √™tre un inconv√©nient.  Les donn√©es peuvent √™tre stock√©es si longtemps que l'application a le temps de changer.  Dans ce cas, la structure de donn√©es que CouchBase va stocker et lire changera √©galement.  La version pr√©c√©dente n'est peut-√™tre pas compatible.  Vous ne l'apprendrez que lors de la lecture, et non lors du d√©veloppement des donn√©es, quand elles se situent quelque part dans la production.  Nous devons penser √† une migration appropri√©e, et c'est exactement ce que nous ne voulons pas faire. <br><br>  La troisi√®me option est <b>Tarantool</b> .  Il est c√©l√®bre pour sa super vitesse.  Il a un merveilleux moteur LUA qui vous permet d'√©crire un tas de logique qui s'ex√©cutera directement sur le serveur sur LuaJit. <br><br>  En revanche, il s'agit d'une valeur de cl√© modifi√©e.  Les donn√©es sont stock√©es dans des tuples.  Nous devons penser par nous-m√™mes √† la s√©rialisation correcte, ce n'est pas toujours une t√¢che √©vidente.  Tarantool a √©galement une approche sp√©cifique de l' <b>√©volutivit√©</b> .  Ce qui ne va pas avec lui, nous en discuterons plus loin. <br><br><h3>  Partage / r√©plication </h3><br>  Peut-√™tre que notre application aura besoin de <b>Sharding / Replication</b> .  Trois r√©f√©rentiels les impl√©mentent diff√©remment. <br><br>  Cassandra sugg√®re une structure qui est g√©n√©ralement appel√©e un ¬´anneau¬ª. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/387/b22/828/387b228289ece281dd70ecea2ded8890.jpg"><br><br>  De nombreux n≈ìuds sont disponibles.  Chacun d'entre eux stocke ses donn√©es et les donn√©es des n≈ìuds les plus proches sous forme de r√©pliques.  Si l'un abandonne, les n≈ìuds √† c√¥t√© de lui peuvent servir une partie de ses donn√©es jusqu'√† ce que le d√©crochage augmente. <br><br>  Sharding \ Replication est responsable de la m√™me structure.  Pour d√©compresser en 10 pi√®ces et facteur de r√©plication 3, 10 n≈ìuds suffisent.  Chacun des n≈ìuds stockera 2 r√©pliques des voisins. <br><br>  Dans CouchBase, la structure d'interaction entre les n≈ìuds est structur√©e de mani√®re similaire: <br><br><ul><li>  il existe des donn√©es marqu√©es comme actives, dont le n≈ìud lui-m√™me est responsable; <br></li><li>  Il existe des r√©pliques de n≈ìuds voisins que CouchBase stocke. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/296/09a/1c8/29609a1c8391653566cb36ab9434da21.jpg"><br><br>  Si un n≈ìud tombe en panne, les voisins, partag√©s, prennent la responsabilit√© de la maintenance de cette partie des cl√©s. <br><br>  Dans Tarantool, l'architecture est similaire √† MongoDB.  Mais avec une nuance: il existe des groupes de partitionnement qui sont r√©pliqu√©s les uns avec les autres. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e81/5f8/5a5/e815f85a59d330b8250071def6cc0d25.jpg"><br><br>  Pour les deux architectures pr√©c√©dentes, si nous voulons cr√©er 4 fragments et le facteur de r√©plication 3, 4 n≈ìuds sont n√©cessaires.  Pour Tarantool - 12!  Mais l'inconv√©nient est compens√© par la vitesse garantie par Tarantool. <br><br><h2>  Cassandra </h2><br>  Des modules optionnels pour le sharding dans Tarantool sont apparus r√©cemment.  Par cons√©quent, nous avons choisi le SGBD Cassandra comme candidat principal.  Rappelons que nous avons parl√© de sa s√©rialisation sp√©cifique. <br><br><h3>  S√©rialisation automatique </h3><br><blockquote>  Le protocole SQL suppose que vous d√©finissez le sch√©ma de donn√©es assez librement. </blockquote><br>  Vous pouvez utiliser cela comme un avantage.  Par exemple, s√©rialisez les donn√©es afin que les noms de champs longs de nos structures feuillues ne soient pas stock√©s √† chaque fois dans nos valeurs.  Dans ce cas, nous aurons des m√©tadonn√©es qui d√©crivent le p√©riph√©rique de donn√©es.  Les UDT eux-m√™mes indiquent √©galement quels champs correspondent aux √©tiquettes et aux balises. <br><br>  Par cons√©quent, la s√©rialisation g√©n√©r√©e automatiquement se d√©roule approximativement de la m√™me mani√®re.  Si nous avons l'un des types de base qui peut correspondre au type de la base de donn√©es un √† un, nous le faisons.  Un ensemble de types Int, Long, String, Double est √©galement dans Cassandra. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de donn√©es d'application</b> <br></td><td>  <b>Type de donn√©es dans Cassandra</b> <br></td></tr><tr><td>  Type primitif <br>  (Int, Long, String, Double, BigDecimal) <br></td><td>  Type primitif <br>  (int, biging, texte, double, d√©cimal) <br></td></tr></tbody></table></div><br>  Si un champ facultatif est rencontr√© dans une certaine structure, nous ne faisons rien de plus.  Nous lui indiquons le type vers lequel ce champ doit se transformer.  La structure stockera null.  Si nous trouvons nul dans la structure au niveau de la d√©s√©rialisation, nous supposons que c'est l'absence de valeur. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de donn√©es d'application</b> <br></td><td>  <b>Type de donn√©es dans Cassandra</b> <br></td></tr><tr><td>  Option [A] <br></td><td>  un <br></td></tr></tbody></table></div><br>  Tous les types de collection de la collection dans Scala sont convertis en liste de types.  Ce sont des collections ordonn√©es qui ont un √©l√©ment correspondant √† un index. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de donn√©es d'application</b> <br></td><td>  <b>Type de donn√©es dans Cassandra</b> <br></td></tr><tr><td>  Seq [A], List [A], Stream [A], Vector [A] <br></td><td>  &lt;liste "a"&gt; fig√©e <br></td></tr></tbody></table></div><br>  Les collections Set non ordonn√©es garantissent qu'il y a exactement un √©l√©ment avec chaque valeur.  Cassandra a √©galement un type de jeu sp√©cial pour eux. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de donn√©es d'application</b> <br></td><td>  <b>Type de donn√©es dans Cassandra</b> <br></td></tr><tr><td>  D√©finir [A] <br></td><td>  fig√© &lt;set "a"&gt; <br></td></tr></tbody></table></div><br>  Tr√®s probablement, nous aurons beaucoup de mapping (), en particulier avec les cl√©s de cha√Æne.  Cassandra a un type de carte sp√©cial pour eux.  Il est √©galement tap√© et poss√®de deux param√®tres de type.  Afin que nous puissions cr√©er un type appropri√© pour n'importe quelle cl√© <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de donn√©es d'application</b> <br></td><td>  <b>Type de donn√©es dans Cassandra</b> <br></td></tr><tr><td>  Carte [K, V] <br></td><td>  &lt;map "k, v"&gt; fig√© <br></td></tr></tbody></table></div><br>  Il existe des types de donn√©es que nous d√©finissons nous-m√™mes dans notre application.  Dans de nombreuses langues, ils sont appel√©s <b>types de donn√©es alg√©briques</b> .  Ils sont d√©finis en d√©finissant un produit nomm√© de types, c'est-√†-dire une structure.  Nous attribuons cette structure au type d√©fini par l'utilisateur.  Chaque champ de la structure correspondra √† un champ de l'UDT. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de donn√©es d'application</b> <br></td><td>  <b>Type de donn√©es dans Cassandra</b> <br></td></tr><tr><td>  Type de produit: classe de cas <br></td><td>  UDT <br></td></tr></tbody></table></div><br>  Le deuxi√®me type est la <b>somme alg√©brique des types</b> .  Dans ce cas, le type correspond √† plusieurs sous-types ou sous-esp√®ces pr√©c√©demment connus.  Aussi, d'une certaine mani√®re, nous lui attribuons une structure. <br><div class="scrollable-table"><table><tbody><tr><td>  <b>Type de donn√©es d'application</b> <br></td><td>  <b>Type de donn√©es dans Cassandra</b> <br></td></tr><tr><td>  Type Sum: trait scell√© \ classe <br></td><td>  UDT <br></td></tr></tbody></table></div><br><h3>  Type de donn√©es abstrait traduit en UDT </h3><br>  Nous avons une structure que nous affichons une √† une - pour chaque champ, nous d√©finissons le champ dans l'UDT cr√©√© √† Cassandra: <br><br><pre><code class="plaintext hljs">case class Account ( id: Long, tags: List[String], user: User, finData: Option[FinData] ) create type account ( id bigint, tags: frozen&lt;list&lt;text&gt;&gt;, user frozen&lt;user&gt;, fin_data frozen&lt;fin_data&gt; )</code> </pre> <br>  Les types primitifs se transforment en types primitifs.  Un lien vers un type pr√©d√©fini avant qu'il ne soit gel√©.  Il s'agit d'un emballage sp√©cial dans Cassandra, ce qui signifie que vous ne pouvez pas lire ce champ morceau par morceau.  L'encapsuleur est ¬´fig√©¬ª dans cet √©tat.  Nous pouvons uniquement lire ou enregistrer l'utilisateur, ou la liste, comme dans le cas des tags. <br><br>  Si nous rencontrons un champ facultatif, nous rejetons cette caract√©ristique.  Nous prenons uniquement le type de donn√©es correspondant au type de champ qui le sera.  Si nous rencontrons non ici - l'absence de valeur - nous √©crivons null dans le champ correspondant.  Lors de la lecture, nous prendrons √©galement la correspondance non nulle. <br><br>  Si nous rencontrons un type qui a plusieurs alternatives pr√©-connues, nous d√©finissons √©galement un nouveau type de donn√©es dans Cassandra.  Pour chaque alternative, un champ dans notre type de donn√©es en UDT. <br><br>  Par cons√©quent, dans cette structure, un seul des champs √† un moment donn√© ne sera pas nul.  Si vous avez rencontr√© un type d'utilisateur et qu'il s'est av√©r√© √™tre une instance d'un mod√©rateur lors de l'ex√©cution, le champ mod√©rateur contiendra une valeur, le reste sera nul.  Pour admin - admin, le reste - null. <br><br>  Cela vous permet d'encoder la structure comme suit: nous avons 4 champs optionnels, nous garantissons qu'un seul sera √©crit √† partir d'eux.  Cassandra utilise une seule balise pour identifier la pr√©sence d'un champ particulier dans la structure.  Gr√¢ce √† cela, nous obtenons une structure de stockage sans frais g√©n√©raux. <br><br>  En fait, pour enregistrer le type d'utilisateur, s'il s'agit d'un mod√©rateur, il faudra le m√™me nombre d'octets n√©cessaires pour stocker le mod√©rateur.  Plus un octet pour montrer quelle alternative particuli√®re est pr√©sente ici. <br><br><h3>  Initialisation </h3><br><blockquote>  L'initialisation est une proc√©dure pr√©liminaire qui doit √™tre termin√©e avant de pouvoir utiliser notre solution de repli. </blockquote><br>  Comment fonctionne ce processus? <br><br><ul><li>  Sur chaque n≈ìud, nous g√©n√©rons des d√©finitions de tables, de types et de textes de requ√™te en fonction des types pr√©sent√©s. <br></li><li>  Lisez le sch√©ma actuel du SGBD.  √Ä Cassandra, cela est facile √† faire en se connectant simplement √† elle.  Lorsqu'il est connect√©, dans presque tous les pilotes, l'objet ¬´session¬ª proprement dit pompe les m√©tadonn√©es de l'espace cl√© auxquelles il est connect√©.  Ensuite, vous pouvez voir ce qu'ils ont. <br></li><li>  Nous parcourons les m√©tadonn√©es, comparons et v√©rifions que tout ce que nous voulons cr√©er est autoris√© et qu'une migration incr√©mentielle est possible. <br></li><li>  Si tout est normal et que l'initialisation est possible, nous effectuons la migration. <br></li><li>  Nous pr√©parons des demandes. <br></li></ul><br><pre> <code class="plaintext hljs">sealed trait User case class Anonymous extends User case class Registered extends User case class Moderator extends User case class Admin extends User create type user ( anonymous frozen&lt;anonymous&gt;, registered frozen&lt;registered&gt;, moderator frozen&lt;moderator&gt;, admin frozen&lt;admin&gt; )</code> </pre> <br>  √áa se passe comme √ßa.  Nous avons des <b>types</b> , des <b>tables</b> et des <b>requ√™tes</b> .  Les types d√©pendent d'autres types, ceux des autres.  Les tableaux d√©pendent de ces types.  Les requ√™tes d√©pendent d√©j√† des tables √† partir desquelles elles lisent les donn√©es.  L'initialisation v√©rifiera toutes ces d√©pendances et cr√©era dans le SGBD tout ce qu'il peut cr√©er, selon certaines r√®gles. <br><br><h3>  Type de migration </h3><br>  Comment d√©terminer qu'un type peut √™tre migr√© de mani√®re incr√©mentielle? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/105/eeb/554/105eeb554bcc5eadaf10753f8c150531.jpg"><br><br><ul><li>  Nous lisons comment ce type est d√©fini dans le SGBD. <br></li><li>  S'il n'y a pas un tel type, c'est que nous en avons trouv√© un nouveau - nous le cr√©ons. <br></li><li>  Si un tel type existe d√©j√†, nous essayons de comparer champ par champ la d√©finition existante avec celle que nous voulons donner √† ce type. <br></li><li>  S'il s'av√®re que nous voulons ajouter seulement quelques champs qui n'existent plus, nous le faisons.  Cr√©ez une liste d'op√©rations ALTER TYPE en mutation et lancez-les. <br></li><li>  S'il s'av√®re que nous avons une sorte de champ qui √©tait d'un type diff√©rent - nous g√©n√©rons une erreur.  Par exemple, il y avait list - est devenu map, ou il y avait un lien vers un type d√©fini par l'utilisateur, et nous essayons de le rendre diff√©rent. <br></li></ul><br>  Le d√©veloppeur peut voir cette erreur avant m√™me de commencer la fonctionnalit√© en production.  Je suppose que le m√™me sch√©ma de donn√©es exact est dans son environnement de d√©veloppement.  Il voit qu'il a en quelque sorte cr√©√© un sch√©ma de donn√©es non migrable, et pour √©viter ces erreurs, il peut remplacer la s√©rialisation g√©n√©r√©e automatiquement, ajouter des options, renommer des champs ou tous les types et tables dans leur ensemble. <br><br><h3>  Initialisation: types </h3><br>  Imaginez qu'il existe plusieurs types de d√©finitions: <br><br><pre> <code class="plaintext hljs">case class Product (id: Long, name: ctring, price: BigDecimal) case class UserOffers (valiDate: LocalDate, offers: Seq[Products]) case class UserProducts (user User, products: Map[Date, Product]) case class UserInfo: UserOffers, products: UserProducts)</code> </pre> <br>  <b>Classe de cas</b> - une classe qui contient un ensemble de champs.  Il s'agit d'un analogue de struct dans Rust. <br><br>  Nous g√©n√©rerons approximativement de telles d√©finitions de donn√©es pour chacun des 4 types - ce que nous voulons √©ventuellement augmenter: <br><br><pre> <code class="plaintext hljs">CREATE TYPE product (id bigint, name text, price decimal); CREATE TYPE user_offers (valid_date date, offers frozen&lt;list&lt;frozen&lt;offer&gt;&gt;&gt;); CREATE TYPE user_products (user frozen&lt;user&gt;, products frozen&lt;map&lt;date, frozen&lt;product&gt;&gt;); CREATE TYPE user_jnfo (offers: frozen&lt;user_offers&gt;, products: frozen&lt;user_products&gt;);</code> </pre> <br>  Le type de user_offers d√©pend du type d'offre, user_products d√©pend du type de produit, user_info sur les deuxi√®me et troisi√®me types. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5bb/e3b/e9d/5bbe3be9d2694677b42b59613305752b.jpg"><br><br>  Nous avons une telle d√©pendance entre les types et nous voulons l'initialiser correctement.  Le diagramme montre que nous initialiserons en parall√®le user_offers et user_products.  Cela ne signifie pas que nous lancerons deux op√©rations parall√®les.  Non, nous d√©marrons toutes les instructions, toutes les analyses de mani√®re s√©quentielle, afin de ne pas cr√©er accidentellement le m√™me type dans deux threads parall√®les. <br><br>  Mais il existe un certain parall√©lisme au niveau de la correction d'erreur.  Si une erreur de type se produit, tout ce qui en d√©pend extraira l'erreur d'origine. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/122/93f/0ba/12293f0bab8bd0a8b7e12d092380a5c5.jpg"><br><br>  Si une erreur est g√©n√©r√©e par l'une des branches parall√®les, tout ce qui d√©pend des donn√©es normalement migr√©es sera g√©n√©r√© sans erreur.  S'il existe d'autres d√©finitions de tables, des instructions pr√©par√©es √† partir de celles-ci, nous pouvons initialiser en toute s√©curit√© cette partie de notre cache de secours.  La communication sera perdue uniquement avec une partie des backends ou avec certaines fonctionnalit√©s.  Les restes sont initialis√©s. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a8d/5ec/3a2/a8d5ec3a2483d899c7db16ac56974fe9.jpg"><br><br>  Il peut arriver que deux types initialis√©s simultan√©ment g√©n√®rent des erreurs diff√©rentes.  Dans ce cas, une fonctionnalit√© qui d√©pend des deux types produira un type d'erreur de sommation.  Le d√©veloppeur, initialisant son Fallback dans l'environnement de d√©veloppement, recevra une liste compl√®te des donn√©es avec des erreurs.  Naturellement, il peut le corriger ici et aller plus loin.  Mais il ne sera pas tel qu'une branche compl√®tement ind√©pendante ferme les erreurs que nous pourrions obtenir, quelle que soit cette branche. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d08/e94/4ba/d08e944ba9b210d16f6f6c0b57048051.jpg"><br><br><h3>  Initialisation: tableaux </h3><br>  Ensuite, nous cr√©ons les tables. <br><br><pre> <code class="plaintext hljs">def getOffer (user: User, number: Long): Future[OfferData] create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt;PRIMARY KEY, value frozen&lt;friend_data&gt; )</code> </pre> <br>  Une telle demande peut lancer directement une demande REST ou SOAP, cr√©er des op√©rations suppl√©mentaires √† l'int√©rieur ou m√™me ex√©cuter plusieurs demandes.  Tout d√©pend de votre code - comment vous avez organis√© le code.  Fallback n'analyse pas compl√®tement ce qui se passe √† l'int√©rieur de la m√©thode √† laquelle vous accrochez un tel talon. <br><br><blockquote>  La m√©thode doit √™tre asynchrone, car Fallback est identique. </blockquote><br>  √Ä Scala, cela est √©tiquet√© avec un type sp√©cial de Future.  Cela signifie que le r√©sultat reviendra un jour.  Quand exactement - c'est inconnu: peut-√™tre tout de suite, ou peut-√™tre pas. <br><br>  Pour la m√©thode, cr√©ez une table.  La cl√© du tableau est un tuple de tous types correspondant aux param√®tres de cette m√©thode.  La valeur non cl√© est le r√©sultat, qui est renvoy√© de mani√®re asynchrone.  Pour chacune de ces tables, nous pr√©parons √† l'avance deux requ√™tes param√©triques: ins√©rer des donn√©es et lire des donn√©es. <br><br><pre> <code class="plaintext hljs">insert into get_offer(key, value) values (?key, ?value); select value from get_offer where key = ?key;</code> </pre> <br>  Tout est pr√™t √† interagir avec le SGBD.  Reste √† savoir comment nous lirons les donn√©es de Fallback. <br><br><h3>  Disjoncteur </h3><br>  Ici, la responsabilit√© passe dans la zone du fameux mod√®le de disjoncteur. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5c0/de1/91c/5c0de191c5c1699cc8f324f38d62b6ee.jpg"><br><br>  Un disjoncteur typique comprend trois √©tats. <br><br>  <b>Closed - l'√©tat ferm√© par d√©faut</b> qui ferme notre backend.  Le principe est que nous lisons d'abord les donn√©es depuis le backend, et seulement si nous ne pouvons pas les obtenir, allez √† Fallback.  Si nous avons r√©ussi √† obtenir les donn√©es, nous ne regardons pas dans Fallback, mais nous y enregistrons les donn√©es et rien ne se passe. <br><br>  Si les probl√®mes se succ√®dent, nous supposons que le backend ment.  Afin de ne pas le spammer avec une quantit√© gigantesque de nouvelles requ√™tes, nous passons √† <b>Open - dans un √©tat d√©chir√©</b> .  Dans ce document, nous essayons de lire uniquement les donn√©es de Fallback.  Si cela ne fonctionne pas, nous renvoyons imm√©diatement une erreur et ne touchons m√™me pas le backend principal. <br><br>  Apr√®s un certain temps, nous d√©cidons de savoir si le backend s'est r√©veill√© et essayons de r√©initialiser l'√©tat <b>Half-Open - un √©tat de courte dur√©e</b> .  Sa dur√©e de vie est une demande. <br><br>  Dans l'√©tat de courte dur√©e, nous choisissons de refermer ou d'ouvrir encore plus longtemps.  Si dans l'√©tat semi-ouvert, nous atteignons avec succ√®s Fallback et recevons la prochaine demande, nous passons √† l'√©tat ferm√©.  Si nous ne pouvions pas passer, nous retournons √† Open, mais pour longtemps. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ad/92e/4a4/9ad92e4a417201c8655ed4785ae21dfc.jpg"><br><br>  Nous avons ajout√© deux √©tats suppl√©mentaires qui ne sont clairement pas li√©s au circuit du disjoncteur: <br><br><ul><li>  Forc√© - √©tat ferm√© de force; <br></li><li>  Invers√© - priorit√© pour l'√©tat ouvert, ferm√© invers√©. <br></li></ul><br>  Voyons voir ce qu'ils font. <br><br><h3>  Le principe de fonctionnement des √âtats </h3><br>  <b>Ferm√©</b>  Le sch√©ma est vaste, mais il suffit d'en comprendre le principe g√©n√©ral.  Nous gardons Fallback en parall√®le avec la fa√ßon dont nous renvoyons le r√©sultat du backend, si tout s'est bien pass√© et lu √† partir de Fallback.  Si c'est mauvais partout, nous renvoyons la priorit√© d'erreur. <br><br><blockquote>  Parmi les deux erreurs, s√©lectionnez l'erreur de backend. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/5b7/541/f99/5b7541f99197cc1730c6a934cebe6516.jpg"><br><br>  S'il n'y a pas d'erreur, nous incr√©mentons le compteur en parall√®le et passons √† l'√©tat ouvert lorsqu'il y a trop de requ√™tes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/182/18f/25d/18218f25de112cf7f6a88291fccbe72f.jpg"><br><br>  <b>Ouverte</b>  L'√©tat ouvert d'Open est plus simple - nous lisons constamment dans Fallback, quoi qu'il arrive, et apr√®s un certain temps, nous essayons de passer √† l'√©tat semi-ouvert. <br><br>  <b>Demi-ouvert</b> .  L'√©tat dans la structure ressemble √† ferm√©.  La diff√©rence est que dans le cas d'une r√©ponse r√©ussie, nous entrons dans un √©tat ferm√©.  En cas d'√©chec - nous revenons √† l'ouverture avec un intervalle prolong√©. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b82/a1e/7c8/b82a1e7c89774bbe327613b51f50f5c0.jpg"><br><br>  <b>Forc√© est un √©tat suppl√©mentaire pour r√©chauffer le cache</b> .  Lorsque nous le remplissons de donn√©es, il n'essaie jamais de lire √† partir de Fallback, mais ajoute uniquement des enregistrements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bdc/8e3/b33/bdc8e3b335750b826fdd21db6c0f0ac7.jpg"><br><br>  <b>Invers√© est un deuxi√®me √©tat farfelu</b> .  Cela fonctionne comme un cache persistant.  Nous activons l'√©tat lorsque nous voulons supprimer d√©finitivement la charge du backend, m√™me si les donn√©es peuvent ne pas √™tre pertinentes.  Invers√© les premi√®res recherches dans Fallback, et si la recherche a √©chou√©, elle va au backend et la traite. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/618/0da/8ed/6180da8edf69398780bd37fae9bc8ba7.jpg"><br><br><h3>  Les probl√®mes </h3><br>  Avec tout ce sch√©ma, nous avons eu plusieurs probl√®mes.  Le plus grave est de comprendre comment fonctionnent les <b>d√©clarations pr√©par√©es</b> √† Cassandra.  Ce probl√®me a √©t√© corrig√© dans la version 4.0, qui n'a pas encore √©t√© publi√©e, donc je vais vous le dire. <br><br>  Cassandra est con√ßue pour y connecter des millions de clients en m√™me temps, et tout le monde essaie de pr√©parer ses relev√©s pr√©par√©s.  Naturellement, Cassandra ne pr√©pare pas chaque instruction pr√©par√©e, sinon elle manquera de m√©moire.  Il calcule le param√®tre MD5 en fonction du texte, de l'espace cl√© et des options de requ√™te.  Si elle re√ßoit exactement la m√™me demande avec exactement le m√™me MD5, elle prend la demande d√©j√† pr√©par√©e.  Il contient d√©j√† des informations sur les m√©tadonn√©es et comment les g√©rer. <br><br>  Mais il y a des probl√®mes de version.  Nous publions une nouvelle version, elle a r√©ussi les migrations, ajout√© des champs dans les types et ex√©cut√© des instructions pr√©par√©es.  Ils reviennent avec la version pr√©c√©dente de notre √©tat et de nos m√©tadonn√©es - avec des types sans champs.  Au moment de la lecture des donn√©es, nous essayons d'√©crire leurs nouvelles colonnes obligatoires, et sommes confront√©s au fait qu'elles n'existent tout simplement pas!  Cassandra dit que c'est g√©n√©ralement un type diff√©rent qu'elle ne conna√Æt pas. <br><br>  Nous avons trait√© ce probl√®me comme suit: nous avons <b>ajout√© un texte unique √† chacune de nos demandes pr√©par√©es</b> . <br><br><pre> <code class="plaintext hljs">create table get_offer( key frozen&lt;tuple&lt;frozen&lt;user&gt;, bigint&gt;&gt; PRIMARY KEY, value frozen&lt;friend_data&gt;, query_tag text ) insert into get_offer (key, value, query_tag) values (?key, ?value, 'tag_123'); select value as tag_123 from get_offer where key = ?key;</code> </pre> <br>  Nous n'aurons pas des millions de clients connect√©s, mais une seule session pour chaque n≈ìud qui d√©tient plusieurs connexions.  Pour chaque pr√©paration de d√©claration une fois.  Nous supposons que tout va bien si pour chaque version de l'application ou pour chaque d√©but de n≈ìud, un texte unique est g√©n√©r√©, qui sera clairement dans le texte de notre demande. <br><br>  Nous avons ajout√© un champ sp√©cial pour le tromper.  Lors de l'insertion, nous √©crivons une constante dans ce champ.  Il est unique pour chaque lancement ou version d'application - il est configur√© dans la biblioth√®que.  Lors de la lecture, nous utilisons ce nom comme alias pour la valeur que nous obtenons.  La demande est exactement la m√™me, nous faisons toujours une s√©lection de valeur, mais le texte est diff√©rent.  Cassandra ne se rend pas compte qu'il s'agit de la m√™me demande, calcule un autre MD5 et pr√©pare √† nouveau la demande avec de nouvelles m√©tadonn√©es. <br><br>  Le deuxi√®me probl√®me est la <b>course √†</b> la <b>migration</b> .  Par exemple, nous voulons effectuer plusieurs migrations parall√®les.  Commen√ßons quelques notes et en m√™me temps ils commenceront les calculs, ils ex√©cuteront cr√©er des tables, cr√©er des types.  Cela peut conduire au fait que sur chaque n≈ìud ou dans chacun des threads parall√®les, tout r√©ussira et que deux tables semblent avoir √©t√© cr√©√©es avec succ√®s.  Mais √† l'int√©rieur, Cassandra est confuse et nous recevrons des d√©lais pour √©crire et lire. <br><br><blockquote>  Vous pouvez casser Cassandra si vous essayez de parall√©liser des processus √† partir de plusieurs threads ou de plusieurs n≈ìuds. </blockquote><br>  Si nous savons que nous devons avoir la migration de secours, nous <b>migrons √† partir d'un n≈ìud sp√©cial avant la publication</b> .  Ce n'est qu'alors que nous d√©marrerons tous nos n≈ìuds lors de la publication.  Nous avons donc r√©solu ce probl√®me. <br><br>  Le troisi√®me probl√®me est le <b>manque de donn√©es dans Fallback Cache</b> .  Il se peut que nous ayons ¬´soutenu¬ª la m√©thode, elle devrait stocker les donn√©es historiques d'il y a un an, mais en r√©alit√© nous l'avons lanc√©e hier. <br><br>  <b>Le probl√®me a √©t√© r√©solu par l'√©chauffement</b> .  Nous avons utilis√© l'√©tat Forced et lanc√© des n≈ìuds sp√©ciaux qui ne communiqueront pas avec de vrais utilisateurs.  Ils prendront toutes les cl√©s possibles que nous supposons et r√©chaufferont le cache en cercle.  L'√©chauffement va si vite pour ne pas tuer le backend que nous lisons. <br><br><blockquote>  Mise √† l'√©chelle des applications, du backend, du big data et du frontend - Scala convient √† tout cela.  Le 26 novembre, nous organisons une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">conf√©rence</a> professionnelle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour les d√©veloppeurs Scala</a> .  Styles, approches, des dizaines de solutions pour le m√™me probl√®me, les nuances de l'utilisation d'approches anciennes et √©prouv√©es, la pratique de la programmation fonctionnelle, la th√©orie de la cosmonautique fonctionnelle radicale - nous parlerons de tout cela lors de la conf√©rence.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Demandez</a> un rapport si vous souhaitez partager votre exp√©rience Scala avant le 26 septembre ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©servez vos billets</a> . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466295/">https://habr.com/ru/post/fr466295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466283/index.html">Opencartforum et amis</a></li>
<li><a href="../fr466285/index.html">Un petit cadeau: combo dvr et d√©tecteur de radar</a></li>
<li><a href="../fr466287/index.html">Rapport et recherche sur la fiabilit√© des segments Internet nationaux 2019</a></li>
<li><a href="../fr466289/index.html">Initiatives l√©gislatives. √âtrange, mais pr√©sent√© √† la Douma d'√âtat</a></li>
<li><a href="../fr466291/index.html">Enqu√™te de durabilit√© des segments Internet nationaux pour 2019</a></li>
<li><a href="../fr466299/index.html">Des sociologues russes ont men√© le premier sondage mondial sur les chatbots</a></li>
<li><a href="../fr466301/index.html">Autre chose: des packages d'application Haiku?</a></li>
<li><a href="../fr466305/index.html">Takashi Kokubun: comment acc√©l√©rer l'ex√©cution des applications Ruby</a></li>
<li><a href="../fr466307/index.html">Comment concevoir SCS</a></li>
<li><a href="../fr466311/index.html">Atelier SLS 6 septembre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>