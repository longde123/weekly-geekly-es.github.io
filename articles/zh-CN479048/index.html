<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔴 🤳 🤚 用于假人的Node.js流或如何使用流 🍯 💇🏼 🙋🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我认为许多人不止一次听说过Node js Streams，但是从未使用过它，或者在不考虑它们如何工作，管道化流和规范的情况下使用了它。 让我们找出什么是流，管道（管道），块（块（数据的一部分）以及所有这些）） 



 为什么了解流在Node js中的工作原理为何很重要？ 答案很简单：Node js...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>用于假人的Node.js流或如何使用流</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479048/"> 我认为许多人不止一次听说过Node js Streams，但是从未使用过它，或者在不考虑它们如何工作，管道化流和规范的情况下使用了它。 让我们找出什么是流，管道（管道），块（块（数据的一部分）以及所有这些）） <br><br><img src="https://habrastorage.org/webt/m8/iv/cp/m8ivcpkrvfaq1vfm53mhxafmzna.jpeg"><br><a name="habracut"></a><br> 为什么了解流在Node js中的工作原理为何很重要？ 答案很简单：Node js中的许多内置模块都实现了流，例如HTTP请求/响应，fs读/写，zlib，crypto，TCP套接字等。 您还需要流，例如，在处理大文件，处理图片时。 您可能没有在编写自己的流，但是了解它的工作原理将使您变得更有能力。 <br><br> 因此，什么是流（在下文中，我将代替流（流）使用）。 流是一个概念，您可以用它来处理小部分的数据，从而可以使用少量的RAM。 同样，在它的帮助下，我们可以将每个部分的处理分成彼此独立的模块（函数或类）。 例如，我们可以立即压缩部分数据，然后加密并写入文件。 主要思想不是处理整个数据，而是一个接一个地处理部分数据。 <br><br>  Node js中有4种流： <br><br><ul><li> 可读的 </li><li> 可写-写作 </li><li> 双面-读写 </li><li> 转换-一种可以修改数据的双工流 </li></ul><br> 您可以在官方网站上找到更多详细信息，现在让我们继续练习。 <br><br><h3> 简单的例子 </h3><br> 我认为许多人甚至没有意识到就已经使用了流。 在此示例中，我们仅将文件发送给客户端。 <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 - ( )      ,         const getFile = async (req, res, next) =&gt; { const fileStream = fs.createReadStream('path to file'); res.contentType('application/pdf'); fileStream.pipe(res); }; // 2 - (  )         const getFile = async (req, res, next) =&gt; { const file = fs.readFileSync('path to file'); res.contentType('application/pdf'); res.send(file); };</span></span></code> </pre> <br> 唯一的区别是，在第一种情况下，我们下载了文件的一部分并发送，因此没有加载服务器的RAM。 在第二种情况下，我们立即将整个文件加载到RAM中，然后再发送。 <br><br> 在本文的进一步部分，我们将分别分析每个流。 您可以使用继承或使用构造函数创建流。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Readable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 -   const myReadable = new Readable(opt); // 2 -   class myReadable extends Readable { constructor(opt) { super(opt); } }</span></span></code> </pre><br> 在所有示例中，我将使用2方法。 <br><br><h3> 可读流 </h3><br> 让我们看看如何在NodeJS中创建Readable流。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Readable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myReadable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _read(size) {} }</code> </pre><br> 从上面的示例中可以看到，该类接受一组参数。 我们将只考虑对Readable流具有一般理解所必需的那些，其余的您可以在文档中看到。 我们对highWaterMark参数和_read方法感兴趣。 <br><br>  highWaterMark是内部流缓冲区的最大字节数（默认为16kb），达到该值时，将从资源中读取的数据将被挂起。 为了继续阅读，我们需要释放内部缓冲区。 我们可以通过调用管道，恢复或订阅数据事件来做到这一点。 <br><br>  _read是私有方法的实现，该方法由Readable类的内部方法调用。 连续调用它，直到数据大小达到highWaterMark。 <br><br> 好吧，我们感兴趣的最后一个方法是可读。 它返回true，但是一旦缓冲区已满，对此方法的调用将开始返回false。 可以由可读._read方法控制。 <br><br> 现在让我们看一个例子来澄清这种情况。 <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Added: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">. Could be added? `</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf)); } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${counter.read().toString()}</span></span></span><span class="hljs-string">`</span></span>);</code> </pre><br> 首先，我要说counter.read（）不是我们在该类中实现的_read。 该方法是私有的，而该方法是公共的，它从内部缓冲区返回数据。 当我们执行此代码时，在控制台中，我们将看到以下内容： <br><br><img src="https://habrastorage.org/webt/lg/yt/ih/lgytihuwtk4wpqbwz2p5xz2iudo.jpeg"><br><br> 发生什么事了 当创建新的Counter（{highWaterMark：2}）流时，我们表示内部缓冲区的大小为2个字节，即 可以存储2个字符（1个字符= 1个字节）。 调用counter.read（）之后，流开始读取，将“ 1”写入内部缓冲区并返回。 然后他继续阅读，写为“ 2”。 当它写为“ 3”时，缓冲区将已满，可读性。push将返回false，流将等待直到内部缓冲区被释放。 因为 在我们的示例中，没有释放缓冲区的逻辑，脚本将结束。 <br><br> 如前所述，为了确保读取不被中断，我们需要不断清除内部缓冲区。 为此，我们订阅了data事件。 用以下代码替换最后两行。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); counter.on(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, chunk =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${chunk.toString()}</span></span></span><span class="hljs-string">`</span></span>); });</code> </pre><br> 现在，如果运行此示例，我们将看到一切正常运行，并且控制台中显示了1到1000之间的数字。 <br><br><h3> 书面流 </h3><br> 实际上，它与Readable流非常相似，仅用于写入数据。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myWritable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _write(chunk, encoding, callback) {} }</code> </pre><br> 它接受类似的参数，例如Readable Stream。 我们对highWaterMark和_write感兴趣。 <br><br>  _write是一个私有方法，由Writable类的内部方法调用以写入一段数据。 它包含3个参数：块（数据的一部分），编码（如果块是字符串，则进行编码），回调（在成功或不成功写入之后调用的函数）。 <br><br>  highWaterMark是内部流缓冲区的最大字节数（默认为16kb），达到该值时stream.write将开始返回false。 <br><br> 让我们用计数器重写前面的示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { counter.write(Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); }</code> </pre><br> 实际上，一切都很简单，但是有一个有趣的细微差别值得记住！ 当创建新的Counter（{highWaterMark：2}）流时，我们表示内部缓冲区的大小为2个字节，即 可以存储2个字符（1个字符= 1个字节）。 当计数器达到10时，每次写调用都会填充缓冲区；因此，如果写是针对慢速源的，则在调用write时所有其他数据将保存到RAM，这可能导致其溢出（在此示例中，当然没关系，因为我们的缓冲区是2个字节，但是对于大文件，您需要记住这一点）。 当出现这种情况时，我们需要等到流写入数据的当前部分，释放内部缓冲区（触发耗用事件），然后才能恢复记录数据。 让我们重写我们的示例。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Writable } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { once } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>; i += <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canWrite = counter.write(Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${i}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Can we write bunch of data? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${canWrite}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canWrite) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> events.once(counter, <span class="hljs-string"><span class="hljs-string">'drain'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'drain event fired.'</span></span>); } } })();</code> </pre><br> 在v11.13.0中添加了events.once方法，该方法使您可以创建promise并等待特定事件执行一次。 在此示例中，我们检查是否可以将数据写入流，否则，请等待直到缓冲区释放后继续记录。 <br><br> 乍一看，这似乎是不必要的操作，但是当处理大量数据（例如，文件大小超过10GB的文件）而忘记执行此操作时，可能会遇到内存泄漏。 <br><br><h3> 双工流 </h3><br> 它结合了Readable和Writable流，也就是说，我们必须编写_read和_write两个方法的实现。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Duplex } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myDuplex</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); } _read(size) {} _write(chunk, encoding, callback) {} }</code> </pre><br> 在这里，我们对可传递给构造函数的2个参数感兴趣，它们是可读高水位标记和可写高水位标记，这两个参数使我们可以分别为可读流和可写流指定内部缓冲区的大小。 这就是在Duplex流的帮助下前两个示例的实现的样子。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Duplex } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> events = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Duplex</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf); } } _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter({ <span class="hljs-attr"><span class="hljs-attr">readableHighWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">writableHighWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">async</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chunk = counter.read(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (chunk !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> canWrite = counter.write(chunk); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Can we write bunch of data? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${canWrite}</span></span></span><span class="hljs-string">`</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!canWrite) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> events.once(counter, <span class="hljs-string"><span class="hljs-string">'drain'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'drain event fired.'</span></span>); } chunk = counter.read(); } })();</code> </pre><br> 我认为此代码不需要解释，因为它与以前相同，仅在一个类中。 <br><br><h3> 转换流 </h3><br> 该流是双工流。 需要转换数据块并将其进一步发送到链下。 可以与流的其余部分相同的方式来实现它。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Transform } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'stream'</span></span>); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">myTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ _ transform(chunk, encoding, callback) {} }</code> </pre><br> 我们对_transform方法感兴趣。 <br><br>  _transform是一个私有方法，由Transform类的内部方法调用以转换数据块。 它包含3个参数：块（数据的一部分），编码（如果块是字符串，则进行编码），回调（在成功或不成功写入后调用的函数）。 <br><br> 使用此方法，数据部分将发生变化。 在此方法内部，我们可以调用transform.push（）零次或多次，以提交更改。 完成数据转换后，我们需要调用一个回调，该回调将发送添加到transform.push（）中的所有内容。 此回调函数的第一个参数是错误。 另外，我们不能使用transform.push（），而是将更改后的数据作为第二个参数发送到回调函数（例如：callback（空，数据））。 为了了解如何使用这种类型的流，让我们分析stream.pipe方法。 <br><br>  stream.pipe-此方法用于将Readable流连接到Writable流，并创建流链。 这意味着我们可以读取部分数据并将其传输到下一个流进行处理，然后再传输到下一个流，依此类推。 <br><br> 让我们编写一个Transform流，它将在每个数据的开头和结尾添加*字符。 <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterReader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Readable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(opt) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(opt); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max = <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index = <span class="hljs-number"><span class="hljs-number">0</span></span>; } _read() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index += <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._index &gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._max) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buf = Buffer.from(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._index}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.push(buf); } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterWriter</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writable</span></span></span><span class="hljs-class"> </span></span>{ _write(chunk, encoding, callback) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(chunk.toString()); callback(); } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterTransform</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Transform</span></span></span><span class="hljs-class"> </span></span>{ _transform(chunk, encoding, callback) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> resultString = <span class="hljs-string"><span class="hljs-string">`*</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${chunk.toString(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'utf8'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">*`</span></span>; callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, resultString); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { callback(err); } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterReader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterReader({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterWriter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterWriter({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> counterTransform = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CounterTransform({ <span class="hljs-attr"><span class="hljs-attr">highWaterMark</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }); counterReader.pipe(counterTransform).pipe(counterWriter);</code> </pre><br> 在此示例中，我使用了先前示例中的Readable和Writable流，还添加了Transform。 如您所见，结果非常简单。 <br><br> 因此，我们研究了流的排列方式。 它们的主要概念是部分处理数据，这非常方便并且不需要大量资源。 而且，流可以与迭代器一起使用，这使它们使用起来更加方便，但这是一个完全不同的故事。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN479048/">https://habr.com/ru/post/zh-CN479048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN479036/index.html">英特尔无法满足对处理器的需求。 惠普和戴尔因此而受苦</a></li>
<li><a href="../zh-CN479038/index.html">数字转换Leroy Merlin：设计用于处理客户呼叫的接口</a></li>
<li><a href="../zh-CN479040/index.html">视觉回归测试。 重新开机</a></li>
<li><a href="../zh-CN479042/index.html">Y方法是构建魔方的一种非常简单的方法</a></li>
<li><a href="../zh-CN479044/index.html">我在NOR Flash中实现环形缓冲区</a></li>
<li><a href="../zh-CN479050/index.html">IT领域的专利研究。 年轻战士的历程。 第二部分 专利研究的信息来源</a></li>
<li><a href="../zh-CN479052/index.html">[Supercomputing 2019]。 多云存储作为新金士顿DC1000M驱动器的应用程序</a></li>
<li><a href="../zh-CN479054/index.html">星期五手机投票</a></li>
<li><a href="../zh-CN479056/index.html">谈人生？ DREAM团队参加Alexa奖Socialbot挑战赛3</a></li>
<li><a href="../zh-CN479058/index.html">作为事件管理过程进行监视</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>