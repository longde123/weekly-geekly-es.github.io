<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👧🏿 👩🏾‍🤝‍👨🏼 👩‍❤️‍💋‍👩 Tests in C ++ ohne Makros und dynamischen Speicher 👩🏻‍🤝‍👨🏿 🙆 🧤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele beliebte Bibliotheken zum Testen, z. B. Google Test, Catch2, Boost.Test, sind stark an die Verwendung von Makros gebunden. Als Beispiel für Test...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests in C ++ ohne Makros und dynamischen Speicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434906/"><p> Viele beliebte Bibliotheken zum Testen, z. B. Google Test, Catch2, Boost.Test, sind stark an die Verwendung von Makros gebunden. Als Beispiel für Tests dieser Bibliotheken sehen Sie normalerweise ein Bild wie das folgende: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Tests the default c'tor. TEST(MyString, DefaultConstructor) { const MyString s; EXPECT_STREQ(nullptr, s.c_string()); EXPECT_EQ(0u, s.Length()); } const char kHelloString[] = "Hello, world!"; // Tests the c'tor that accepts a C string. TEST(MyString, ConstructorFromCString) { const MyString s(kHelloString); EXPECT_EQ(0, strcmp(s.c_string(), kHelloString)); EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1, s.Length()); } // Tests the copy c'tor. TEST(MyString, CopyConstructor) { const MyString s1(kHelloString); const MyString s2 = s1; EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString)); } } // namespace</span></span></code> </pre> <br><p>  Makros in C ++ sind vorsichtig. Warum gedeihen sie in Bibliotheken zum Erstellen von Tests so gut? </p><a name="habracut"></a><br><p>  Die Unit-Test-Bibliothek sollte ihren Benutzern die Möglichkeit bieten, Tests zu schreiben, damit die Testlaufzeit sie irgendwie finden und ausführen kann.  Wenn Sie darüber nachdenken, wie dies zu tun ist, scheint die Verwendung von Makros am einfachsten zu sein.  Das TEST () -Makro definiert normalerweise irgendwie eine Funktion (im Fall von Google Test erstellt das Makro auch eine Klasse) und stellt sicher, dass die Adresse dieser Funktion in einen globalen Container gelangt. </p><br><p>  Die bekannte Bibliothek, in der der Ansatz ohne ein einziges Makro implementiert ist, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tut-Framework</a> .  Schauen wir uns ihr Beispiel aus dem Tutorial an: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tut/tut.hpp&gt; namespace tut { struct basic{}; typedef test_group&lt;basic&gt; factory; typedef factory::object object; } namespace { tut::factory tf("basic test"); } namespace tut { template&lt;&gt; template&lt;&gt; void object::test&lt;1&gt;() { ensure_equals("2+2=?", 2+2, 4); } }</span></span></span></span></code> </pre> <br><p>  Die Idee, die zugrunde liegt, ist sehr interessant und funktioniert, es ist nicht sehr schwierig.  Kurz gesagt, Sie haben eine Basisklasse, die eine Vorlagenfunktion implementiert, die die Parametrisierung mit einer Ganzzahl umfasst: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_object</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Data { <span class="hljs-comment"><span class="hljs-comment">/** * Default do-nothing test. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ called_method_was_a_dummy_test_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Wenn Sie jetzt einen solchen Test schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { ensure_equals(<span class="hljs-string"><span class="hljs-string">"2+2=?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Sie erstellen tatsächlich eine Testmethoden-Spezialisierung für eine bestimmte Zahl N = 1 (genau dafür steht <code>template&lt;&gt;template&lt;&gt;</code> ).  Durch Aufrufen von <code>test&lt;N&gt;()</code> die Testlaufzeit nachvollziehen, ob es sich um einen echten Test oder um einen Stub handelt, der nach Ausführung des Tests den <code>called_method_was_a_dummy_test_</code> überprüft. </p><br><p>  Als nächstes, wenn Sie eine Testgruppe deklarieren: </p><br><pre> <code class="cpp hljs">tut::<span class="hljs-function"><span class="hljs-function">factory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"basic test"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  Erstens listen Sie alle <code>test&lt;N&gt;</code> bis zu einer bestimmten Konstante auf, die mit der Bibliothek verbunden ist, und zweitens fügen Sie nebenbei dem globalen Container Informationen über die Gruppe hinzu (Gruppenname und Adressen aller Testfunktionen). </p><br><p>  Ausnahmen werden in tut als Testbedingungen verwendet, daher <code>tut::ensure_equals()</code> Funktion <code>tut::ensure_equals()</code> einfach eine Ausnahme aus, wenn die beiden übergebenen Werte nicht gleich sind, und die Testlaufumgebung <code>tut::ensure_equals()</code> eine Ausnahme und betrachtet den Test als fehlgeschlagen.  Ich mag diesen Ansatz, es wird jedem C ++ - Entwickler sofort klar, wo solche Behauptungen verwendet werden können.  Wenn mein Test beispielsweise einen Hilfsthread erstellt hat, ist es sinnlos, dort Aussagen zu platzieren, die niemand abfangen kann.  Außerdem ist mir klar, dass mein Test im Falle einer Ausnahme in der Lage sein sollte, Ressourcen freizugeben, als wäre es gewöhnlicher ausnahmesicherer Code. </p><br><p>  Im Prinzip sieht die Tut-Framework-Bibliothek ziemlich gut aus, aber ihre Implementierung weist einige Nachteile auf.  In meinem Fall möchte ich beispielsweise, dass der Test nicht nur eine Nummer, sondern auch andere Attribute, insbesondere den Namen, sowie die "Größe" des Tests enthält (z. B. handelt es sich um einen Integrationstest oder um einen Komponententest).  Dies kann im Rahmen des API-Tuts gelöst werden, und es ist sogar bereits etwas vorhanden, und etwas kann implementiert werden, wenn Sie der Bibliotheks-API eine Methode hinzufügen und sie im Testkörper aufrufen, um einen ihrer Parameter festzulegen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { set_name(<span class="hljs-string"><span class="hljs-string">"2+2"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set test name to be shown in test report ensure_equals("2+2=?", 2+2, 4); }</span></span></code> </pre> <br><p>  Ein weiteres Problem besteht darin, dass die Tut-Testlaufumgebung nichts über ein solches Ereignis wie den Beginn eines Tests weiß.  Die Umgebung führt <code>object::test&lt;N&gt;()</code> und weiß nicht im Voraus, ob der Test für ein bestimmtes N implementiert ist oder nur ein Stub.  Sie <code>called_method_was_a_dummy_test_</code> nur <code>called_method_was_a_dummy_test_</code> wann der Test beendet ist, indem sie den Wert <code>called_method_was_a_dummy_test_</code> analysiert.  Diese Funktion zeigt sich in CI-Systemen nicht sehr gut, die in der Lage sind, die Ausgabe zu gruppieren, die das Programm zwischen dem Beginn und dem Ende des Tests erstellt hat. </p><br><p>  Meiner Meinung nach ist die Hauptsache, die verbessert werden kann (ein "schwerwiegender Fehler"), das Vorhandensein von zusätzlichem Hilfscode, der zum Schreiben von Tests erforderlich ist.  Das Tutorial-Tutorial-Framework enthält eine Menge Dinge: Es wird vorgeschlagen, zuerst eine bestimmte Klassenstruktur <code>struct basic{}</code> zu erstellen und die Tests als damit verbundene Objektmethoden zu beschreiben.  In dieser Klasse können Sie die Methoden und Daten definieren, die Sie in der Testgruppe verwenden möchten, und der Konstruktor und der Destruktor rahmen die Ausführung des Tests ein und erstellen so etwas wie ein Fixture aus jUnit.  In meiner Praxis mit tut ist dieses Objekt fast immer leer, aber es zieht sich entlang einer bestimmten Anzahl von Codezeilen. </p><br><p>  Also gehen wir in die Fahrradwerkstatt und versuchen, die Idee in Form einer kleinen Bibliothek zu arrangieren. </p><br><p>  So sieht die minimale Testdatei in der getesteten Bibliothek aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Test group for std::vector (illustrative purposes) #include "tested.h" #include &lt;vector&gt; template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("emptiness"); std::vector&lt;int&gt; vec; tested::Is(vec.empty(), "Vector must be empty by default"); } template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("AddElement"); std::vector&lt;int&gt; vec; vec.push_back(1); tested::Is(vec.size() == 1); tested::Is(vec[0] == 1); tested::FailIf(vec.empty()); } void LinkVectorTests() { static tested::Group&lt;CASE_COUNTER&gt; x("std.vector", __FILE__); }</span></span></code> </pre> <br><p>  Zusätzlich zum Fehlen von Makros ist der Bonus das Fehlen der Verwendung von dynamischem Speicher innerhalb der Bibliothek. </p><br><h3 id="opredelenie-test-keysov">  Definition von Testfällen </h3><br><p>  Für die Registrierung von Tests wird die elementare Magie des Einstiegs nach dem gleichen Prinzip wie tut verwendet.  Irgendwo in getestet.h gibt es eine Boilerplate-Funktion dieser Art: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Case</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IRuntime* runtime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TheCaseIsAStub(); }</code> </pre> <br><p>  Von Bibliotheksbenutzern geschriebene Testfälle sind lediglich Spezialisierungen dieser Methode.  Die Funktion wird als statisch deklariert, d.h.  In jeder Übersetzungseinheit erstellen wir Spezialisierungen, die sich beim Verknüpfen nicht namentlich überschneiden. </p><br><p>  Es gibt eine solche Regel, dass Sie zuerst <code>StartCase()</code> aufrufen <code>StartCase()</code> , an die Sie Dinge wie den Namen des Tests und möglicherweise einige andere Dinge übergeben können, die sich noch in der Entwicklung befinden. </p><br><p>  Wenn ein Test <code>runtime-&gt;StartTest()</code> , können interessante Dinge passieren.  Erstens, wenn sich die Tests jetzt im Ausführungsmodus befinden, können Sie irgendwo feststellen, dass der Test mit der Ausführung begonnen hat.  Zweitens, wenn es einen Modus zum Sammeln von Informationen über verfügbare Tests gibt, <code>StartTest()</code> eine spezielle Art von Ausnahme aus, die bedeutet, dass der Test echt ist und kein Stub. </p><br><h3 id="registraciya">  Registrierung </h3><br><p>  Irgendwann müssen Sie die Adressen aller Testfälle sammeln und irgendwo ablegen.  Im Test erfolgt dies mit Gruppen.  Der Konstruktor der getesteten :: Group-Klasse tut dies als Nebeneffekt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__);</code> </pre> <br><p>  Der Konstruktor erstellt eine Gruppe mit dem angegebenen Namen und fügt alle Fälle <code>Case&lt;N&gt;</code> , die er in der aktuellen Übersetzungseinheit findet.  Es stellt sich heraus, dass Sie in einer Übersetzungseinheit nicht zwei Gruppen haben können.  Dies bedeutet auch, dass Sie eine Gruppe nicht in mehrere Übersetzungseinheiten aufteilen können. </p><br><p>  Der Parameter der Vorlage gibt an, nach wie vielen Testfällen in der aktuellen Übersetzungseinheit für die erstellte Gruppe gesucht werden soll. </p><br><h3 id="linkovka">  Link </h3><br><p>  Im obigen Beispiel erfolgt die Erstellung des getesteten :: Group () -Objekts innerhalb der Funktion, die wir von unserer Anwendung aus aufrufen müssen, um die Tests zu registrieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  Eine Funktion ist nicht immer erforderlich. Manchmal können Sie einfach ein Objekt der <code>tested::Group</code> Klasse in einer Datei deklarieren.  Ich habe jedoch die Erfahrung gemacht, dass der Linker manchmal die gesamte Datei "optimiert", wenn sie in der Bibliothek zusammengestellt ist, und keine der Hauptanwendungen Zeichen aus dieser CPP-Datei verwendet: </p><br><pre> <code class="plaintext hljs">calc.lib &lt;- calc_test.lib(calc_test.cpp) ^ ^ | | app.exe run_test.exe</code> </pre> <br><p>  Wenn calc_test.cpp nicht mit der Quelle run_test.exe verknüpft ist, entfernt der Linker diese Datei einfach vollständig aus der Betrachtung, zusammen mit der Erstellung eines statischen Objekts, obwohl sie die von uns benötigten Nebenwirkungen hat. </p><br><p>  Wenn welche Kette aus run_test.exe resultiert, wird das statische Objekt in der ausführbaren Datei angezeigt.  Und es spielt keine Rolle, wie dies genau gemacht wird, wie im Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  oder so: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  Die erste Option ist meiner Meinung nach besser, da der Konstruktor nach dem Start von main () aufgerufen wird und die Anwendung eine gewisse Kontrolle über diesen Prozess hat. </p><br><p>  Ich denke, diese Einstellung von Krücken ist für jede Unit-Test-Bibliothek erforderlich, die globale Variablen und Nebenwirkungen des Konstruktors verwendet, um eine Testdatenbank zu erstellen.  Dies kann jedoch wahrscheinlich vermieden werden, indem die Testbibliothek mit dem Schlüssel --whole-archive verknüpft wird (ein Analogon in MSVC wurde nur in Visual Studio 2015.3 angezeigt). </p><br><h3 id="makrosy">  Makros </h3><br><p>  Ich habe versprochen, dass es keine Makros geben wird, aber es ist - <code>CASE_COUNTER</code> .  Die Arbeitsoption besteht darin, dass es von <code>__COUNTER__</code> verwendet wird, einem Makro, das der Compiler bei jeder Verwendung in der Übersetzungseinheit um eins erhöht. <br>  Unterstützt von GCC, CLANG, MSVC, aber nicht vom Standard.  Wenn dies frustrierend ist, sind hier einige Alternativen: </p><br><ul><li>  Verwenden Sie die Nummern 0, 1, 2 </li><li>  Verwenden Sie Standard <code>__LINE__</code> . </li><li>  Verwende die Constexpr-Magie der Stufe 80.  Sie können nach "constexpr counter" suchen und versuchen, den Compiler zu finden, auf dem er funktioniert. </li></ul><br><p>  Das Problem mit <code>__LINE__</code> besteht darin, dass durch die Verwendung großer Zahlen in den Vorlagenoptionen eine große Größe der ausführbaren Datei erstellt wird.  Aus diesem Grund habe ich den Typ des signierten Zeichenmusters auf 128 als maximale Anzahl von Tests in der Gruppe beschränkt. </p><br><h3 id="otkaz-ot-dinamicheskoy-pamyati">  Ausfall des dynamischen Speichers </h3><br><p>  Es stellte sich heraus, dass Sie bei der Registrierung von Tests keinen dynamischen Speicher verwenden können, den ich verwendet habe.  Es ist möglich, dass Ihre Umgebung keinen dynamischen Speicher hat oder Sie in Testfällen die Suche nach Speicherlecks verwenden, sodass das Eingreifen in die Testausführungsumgebung nicht das ist, was Sie benötigen.  Google Test hat damit zu kämpfen. Hier ist ein Ausschnitt von dort: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use the RAII idiom to flag mem allocs that are intentionally never // deallocated. The motivation is to silence the false positive mem leaks // that are reported by the debug version of MS's CRT which can only detect // if an alloc is missing a matching deallocation. // Example: // MemoryIsNotDeallocated memory_is_not_deallocated; // critical_section_ = new CRITICAL_SECTION; class MemoryIsNotDeallocated</span></span></code> </pre> <br><p>  Und wir können einfach keine Schwierigkeiten schaffen. </p><br><p>  Wie bekommen wir dann eine Liste von Tests?  Dies sind eher technische Interna, die im Quellcode leichter zu erkennen sind, aber ich werde es Ihnen trotzdem sagen. </p><br><p>  Beim Erstellen einer Gruppe erhält ihre Klasse einen Zeiger auf die Funktion <code>tested::CaseCollector&lt;CASE_COUNTER&gt;::collect</code> , mit der alle Tests von Übersetzungseinheiten in einer Liste zusammengefasst werden.  So funktioniert es: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the anonymouse namespace to have instances be hidden to specific translation unit namespace { template &lt;Ordinal_t N&gt; struct CaseCollector { // Test runtime that collects the test case struct CollectorRuntime final : IRuntime { void StartCase(const char* caseName, const char* description = nullptr) final { // the trick is exit from test case function into the collector via throw throw CaseIsReal(); } }; // Finds the Case&lt;N&gt; function in current translation unit and adds into the static list. It uses the // reverse order, so the case executed in order of appearance in C++ file. static CaseListEntry* collect(CaseListEntry* tail) { CaseListEntry* current = nullptr; CollectorRuntime collector; try { Case&lt;N&gt;(&amp;collector); } catch (CaseIsStub) { current = tail; } catch (CaseIsReal) { s_caseListEntry.CaseProc = Case&lt;N&gt;; s_caseListEntry.Next = tail; s_caseListEntry.Ordinal = N; current = &amp;s_caseListEntry; } return CaseCollector&lt;N - 1&gt;::collect(current); } private: static CaseListEntry s_caseListEntry; }; // This static storage will be instantiated in any cpp file template &lt;Ordinal_t N&gt; CaseListEntry CaseCollector&lt;N&gt;::s_caseListEntry; }</span></span></code> </pre> <br><p>  Es stellt sich heraus, dass in jeder Übersetzungseinheit viele statische Variablen vom Typ CaseListEntry CaseCollector \ :: s_caseListEntry erstellt werden, die Elemente der Testliste sind, und die Methode collect () sammelt diese Elemente in einer einzeln verbundenen Liste.  In etwa der gleichen Weise bildet die Liste Gruppen von Tests, jedoch ohne Muster und Rekursion. <br></p><br><h3 id="struktura">  Struktur </h3><br><p>  Tests benötigen eine andere Bindung, z. B. Ausgabe in roten Buchstaben an die Konsole. Fehlgeschlagen. Erstellen von Testberichten in einem für CI oder GUI verständlichen Format, in dem Sie die Liste der Tests anzeigen und die ausgewählten Tests ausführen können - im Allgemeinen viele Dinge.  Ich habe eine Vision davon, wie dies getan werden kann, die sich von der unterscheidet, die ich zuvor in der Testbibliothek gesehen habe.  Der Anspruch bezieht sich hauptsächlich auf Bibliotheken, die sich "nur Header" nennen und gleichzeitig eine große Menge Code enthalten, was im Wesentlichen nicht für Header-Dateien gilt. </p><br><p>  Ich gehe davon aus, dass wir die Bibliothek in Front-End-Bibliotheken aufteilen - dies wird getestet. H- und Back-End-Bibliotheken selbst.  Um Tests zu schreiben, benötigen Sie nur getestete.h, die jetzt C ++ 17 ist (aufgrund der std :: std :: string_view), aber es wird angenommen, dass es C ++ 98 geben wird.  Tested.h führt tatsächlich die Registrierung und Suche nach Tests durch, eine minimal bequeme Startoption sowie die Möglichkeit, Tests (Gruppen, Adressen von Testfallfunktionen) zu exportieren.  Noch nicht vorhandene Back-End-Bibliotheken können alles tun, was sie für die Ausgabe von Ergebnissen und den Start mithilfe der Exportfunktion benötigen.  Auf die gleiche Weise können Sie den Start an die Anforderungen Ihres Projekts anpassen. </p><br><h3 id="itog">  Zusammenfassung </h3><br><p>  Die getestete Bibliothek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Code</a> ) muss noch stabilisiert werden.  Fügen Sie in naher Zukunft die Möglichkeit hinzu, asynchrone Tests auszuführen (die für Integrationstests in WebAssembly erforderlich sind), und geben Sie die Größe der Tests an.  Meiner Meinung nach ist die Bibliothek noch nicht ganz produktionsbereit, aber ich habe plötzlich viel Zeit verbracht und die Bühne ist stehen geblieben, um Luft zu holen und um Feedback von der Community zu bitten.  Möchten Sie diese Art von Bibliothek nutzen?  Vielleicht gibt es noch andere Ideen im C ++ - Arsenal, da es möglich wäre, eine Bibliothek ohne Makros zu erstellen?  Ist eine solche Erklärung des Problems überhaupt interessant? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434906/">https://habr.com/ru/post/de434906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434892/index.html">Zeichnungscode in Swift, PaintCode</a></li>
<li><a href="../de434894/index.html">Die Kunst des Schamanismus oder der benutzerdefinierten Firmware für Olinuxino. Teil 1</a></li>
<li><a href="../de434896/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Geräte der letzten 50 Jahre, Teil 1</a></li>
<li><a href="../de434898/index.html">Grasp2Vec: Lernen, Objekte durch selbstlernende Erfassung darzustellen</a></li>
<li><a href="../de434902/index.html">Erstellen eines benutzerdefinierten Abfragegenerators in Spring Data Neo4j (Teil 1)</a></li>
<li><a href="../de434908/index.html">Programmiererausbildung - Was? Wo? Wann?</a></li>
<li><a href="../de434912/index.html">Der jährliche Bestand von Porsche Taycan ist bereits reserviert, hauptsächlich von Tesla-Besitzern</a></li>
<li><a href="../de434924/index.html">Was Sie über die Organisation von Arbeitsplätzen, Coworking und die Gestaltung von Räumen für Fernarbeit lesen sollten</a></li>
<li><a href="../de434928/index.html">Methoden der Anwendung und Verzerrung der Genauigkeit in Spielen. Visuelle Diagramme zum Vergleich</a></li>
<li><a href="../de434930/index.html">Videoanzeige heute: muss ein erfolgreiches Geschäft haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>