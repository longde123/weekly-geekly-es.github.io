<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëßüèø üë©üèæ‚Äçü§ù‚Äçüë®üèº üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë© Tests in C ++ ohne Makros und dynamischen Speicher üë©üèª‚Äçü§ù‚Äçüë®üèø üôÜ üß§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Viele beliebte Bibliotheken zum Testen, z. B. Google Test, Catch2, Boost.Test, sind stark an die Verwendung von Makros gebunden. Als Beispiel f√ºr Test...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests in C ++ ohne Makros und dynamischen Speicher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434906/"><p> Viele beliebte Bibliotheken zum Testen, z. B. Google Test, Catch2, Boost.Test, sind stark an die Verwendung von Makros gebunden. Als Beispiel f√ºr Tests dieser Bibliotheken sehen Sie normalerweise ein Bild wie das folgende: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Tests the default c'tor. TEST(MyString, DefaultConstructor) { const MyString s; EXPECT_STREQ(nullptr, s.c_string()); EXPECT_EQ(0u, s.Length()); } const char kHelloString[] = "Hello, world!"; // Tests the c'tor that accepts a C string. TEST(MyString, ConstructorFromCString) { const MyString s(kHelloString); EXPECT_EQ(0, strcmp(s.c_string(), kHelloString)); EXPECT_EQ(sizeof(kHelloString)/sizeof(kHelloString[0]) - 1, s.Length()); } // Tests the copy c'tor. TEST(MyString, CopyConstructor) { const MyString s1(kHelloString); const MyString s2 = s1; EXPECT_EQ(0, strcmp(s2.c_string(), kHelloString)); } } // namespace</span></span></code> </pre> <br><p>  Makros in C ++ sind vorsichtig. Warum gedeihen sie in Bibliotheken zum Erstellen von Tests so gut? </p><a name="habracut"></a><br><p>  Die Unit-Test-Bibliothek sollte ihren Benutzern die M√∂glichkeit bieten, Tests zu schreiben, damit die Testlaufzeit sie irgendwie finden und ausf√ºhren kann.  Wenn Sie dar√ºber nachdenken, wie dies zu tun ist, scheint die Verwendung von Makros am einfachsten zu sein.  Das TEST () -Makro definiert normalerweise irgendwie eine Funktion (im Fall von Google Test erstellt das Makro auch eine Klasse) und stellt sicher, dass die Adresse dieser Funktion in einen globalen Container gelangt. </p><br><p>  Die bekannte Bibliothek, in der der Ansatz ohne ein einziges Makro implementiert ist, ist das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tut-Framework</a> .  Schauen wir uns ihr Beispiel aus dem Tutorial an: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;tut/tut.hpp&gt; namespace tut { struct basic{}; typedef test_group&lt;basic&gt; factory; typedef factory::object object; } namespace { tut::factory tf("basic test"); } namespace tut { template&lt;&gt; template&lt;&gt; void object::test&lt;1&gt;() { ensure_equals("2+2=?", 2+2, 4); } }</span></span></span></span></code> </pre> <br><p>  Die Idee, die zugrunde liegt, ist sehr interessant und funktioniert, es ist nicht sehr schwierig.  Kurz gesagt, Sie haben eine Basisklasse, die eine Vorlagenfunktion implementiert, die die Parametrisierung mit einer Ganzzahl umfasst: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">test_object</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Data { <span class="hljs-comment"><span class="hljs-comment">/** * Default do-nothing test. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ called_method_was_a_dummy_test_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br><p>  Wenn Sie jetzt einen solchen Test schreiben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { ensure_equals(<span class="hljs-string"><span class="hljs-string">"2+2=?"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); }</code> </pre> <br><p>  Sie erstellen tats√§chlich eine Testmethoden-Spezialisierung f√ºr eine bestimmte Zahl N = 1 (genau daf√ºr steht <code>template&lt;&gt;template&lt;&gt;</code> ).  Durch Aufrufen von <code>test&lt;N&gt;()</code> die Testlaufzeit nachvollziehen, ob es sich um einen echten Test oder um einen Stub handelt, der nach Ausf√ºhrung des Tests den <code>called_method_was_a_dummy_test_</code> √ºberpr√ºft. </p><br><p>  Als n√§chstes, wenn Sie eine Testgruppe deklarieren: </p><br><pre> <code class="cpp hljs">tut::<span class="hljs-function"><span class="hljs-function">factory </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"basic test"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><p>  Erstens listen Sie alle <code>test&lt;N&gt;</code> bis zu einer bestimmten Konstante auf, die mit der Bibliothek verbunden ist, und zweitens f√ºgen Sie nebenbei dem globalen Container Informationen √ºber die Gruppe hinzu (Gruppenname und Adressen aller Testfunktionen). </p><br><p>  Ausnahmen werden in tut als Testbedingungen verwendet, daher <code>tut::ensure_equals()</code> Funktion <code>tut::ensure_equals()</code> einfach eine Ausnahme aus, wenn die beiden √ºbergebenen Werte nicht gleich sind, und die Testlaufumgebung <code>tut::ensure_equals()</code> eine Ausnahme und betrachtet den Test als fehlgeschlagen.  Ich mag diesen Ansatz, es wird jedem C ++ - Entwickler sofort klar, wo solche Behauptungen verwendet werden k√∂nnen.  Wenn mein Test beispielsweise einen Hilfsthread erstellt hat, ist es sinnlos, dort Aussagen zu platzieren, die niemand abfangen kann.  Au√üerdem ist mir klar, dass mein Test im Falle einer Ausnahme in der Lage sein sollte, Ressourcen freizugeben, als w√§re es gew√∂hnlicher ausnahmesicherer Code. </p><br><p>  Im Prinzip sieht die Tut-Framework-Bibliothek ziemlich gut aus, aber ihre Implementierung weist einige Nachteile auf.  In meinem Fall m√∂chte ich beispielsweise, dass der Test nicht nur eine Nummer, sondern auch andere Attribute, insbesondere den Namen, sowie die "Gr√∂√üe" des Tests enth√§lt (z. B. handelt es sich um einen Integrationstest oder um einen Komponententest).  Dies kann im Rahmen des API-Tuts gel√∂st werden, und es ist sogar bereits etwas vorhanden, und etwas kann implementiert werden, wenn Sie der Bibliotheks-API eine Methode hinzuf√ºgen und sie im Testk√∂rper aufrufen, um einen ihrer Parameter festzulegen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> object::test&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;() { set_name(<span class="hljs-string"><span class="hljs-string">"2+2"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Set test name to be shown in test report ensure_equals("2+2=?", 2+2, 4); }</span></span></code> </pre> <br><p>  Ein weiteres Problem besteht darin, dass die Tut-Testlaufumgebung nichts √ºber ein solches Ereignis wie den Beginn eines Tests wei√ü.  Die Umgebung f√ºhrt <code>object::test&lt;N&gt;()</code> und wei√ü nicht im Voraus, ob der Test f√ºr ein bestimmtes N implementiert ist oder nur ein Stub.  Sie <code>called_method_was_a_dummy_test_</code> nur <code>called_method_was_a_dummy_test_</code> wann der Test beendet ist, indem sie den Wert <code>called_method_was_a_dummy_test_</code> analysiert.  Diese Funktion zeigt sich in CI-Systemen nicht sehr gut, die in der Lage sind, die Ausgabe zu gruppieren, die das Programm zwischen dem Beginn und dem Ende des Tests erstellt hat. </p><br><p>  Meiner Meinung nach ist die Hauptsache, die verbessert werden kann (ein "schwerwiegender Fehler"), das Vorhandensein von zus√§tzlichem Hilfscode, der zum Schreiben von Tests erforderlich ist.  Das Tutorial-Tutorial-Framework enth√§lt eine Menge Dinge: Es wird vorgeschlagen, zuerst eine bestimmte Klassenstruktur <code>struct basic{}</code> zu erstellen und die Tests als damit verbundene Objektmethoden zu beschreiben.  In dieser Klasse k√∂nnen Sie die Methoden und Daten definieren, die Sie in der Testgruppe verwenden m√∂chten, und der Konstruktor und der Destruktor rahmen die Ausf√ºhrung des Tests ein und erstellen so etwas wie ein Fixture aus jUnit.  In meiner Praxis mit tut ist dieses Objekt fast immer leer, aber es zieht sich entlang einer bestimmten Anzahl von Codezeilen. </p><br><p>  Also gehen wir in die Fahrradwerkstatt und versuchen, die Idee in Form einer kleinen Bibliothek zu arrangieren. </p><br><p>  So sieht die minimale Testdatei in der getesteten Bibliothek aus: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Test group for std::vector (illustrative purposes) #include "tested.h" #include &lt;vector&gt; template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("emptiness"); std::vector&lt;int&gt; vec; tested::Is(vec.empty(), "Vector must be empty by default"); } template&lt;&gt; void tested::Case&lt;CASE_COUNTER&gt;(tested::IRuntime* runtime) { runtime-&gt;StartCase("AddElement"); std::vector&lt;int&gt; vec; vec.push_back(1); tested::Is(vec.size() == 1); tested::Is(vec[0] == 1); tested::FailIf(vec.empty()); } void LinkVectorTests() { static tested::Group&lt;CASE_COUNTER&gt; x("std.vector", __FILE__); }</span></span></code> </pre> <br><p>  Zus√§tzlich zum Fehlen von Makros ist der Bonus das Fehlen der Verwendung von dynamischem Speicher innerhalb der Bibliothek. </p><br><h3 id="opredelenie-test-keysov">  Definition von Testf√§llen </h3><br><p>  F√ºr die Registrierung von Tests wird die elementare Magie des Einstiegs nach dem gleichen Prinzip wie tut verwendet.  Irgendwo in getestet.h gibt es eine Boilerplate-Funktion dieser Art: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Case</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IRuntime* runtime)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> TheCaseIsAStub(); }</code> </pre> <br><p>  Von Bibliotheksbenutzern geschriebene Testf√§lle sind lediglich Spezialisierungen dieser Methode.  Die Funktion wird als statisch deklariert, d.h.  In jeder √úbersetzungseinheit erstellen wir Spezialisierungen, die sich beim Verkn√ºpfen nicht namentlich √ºberschneiden. </p><br><p>  Es gibt eine solche Regel, dass Sie zuerst <code>StartCase()</code> aufrufen <code>StartCase()</code> , an die Sie Dinge wie den Namen des Tests und m√∂glicherweise einige andere Dinge √ºbergeben k√∂nnen, die sich noch in der Entwicklung befinden. </p><br><p>  Wenn ein Test <code>runtime-&gt;StartTest()</code> , k√∂nnen interessante Dinge passieren.  Erstens, wenn sich die Tests jetzt im Ausf√ºhrungsmodus befinden, k√∂nnen Sie irgendwo feststellen, dass der Test mit der Ausf√ºhrung begonnen hat.  Zweitens, wenn es einen Modus zum Sammeln von Informationen √ºber verf√ºgbare Tests gibt, <code>StartTest()</code> eine spezielle Art von Ausnahme aus, die bedeutet, dass der Test echt ist und kein Stub. </p><br><h3 id="registraciya">  Registrierung </h3><br><p>  Irgendwann m√ºssen Sie die Adressen aller Testf√§lle sammeln und irgendwo ablegen.  Im Test erfolgt dies mit Gruppen.  Der Konstruktor der getesteten :: Group-Klasse tut dies als Nebeneffekt: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__);</code> </pre> <br><p>  Der Konstruktor erstellt eine Gruppe mit dem angegebenen Namen und f√ºgt alle F√§lle <code>Case&lt;N&gt;</code> , die er in der aktuellen √úbersetzungseinheit findet.  Es stellt sich heraus, dass Sie in einer √úbersetzungseinheit nicht zwei Gruppen haben k√∂nnen.  Dies bedeutet auch, dass Sie eine Gruppe nicht in mehrere √úbersetzungseinheiten aufteilen k√∂nnen. </p><br><p>  Der Parameter der Vorlage gibt an, nach wie vielen Testf√§llen in der aktuellen √úbersetzungseinheit f√ºr die erstellte Gruppe gesucht werden soll. </p><br><h3 id="linkovka">  Link </h3><br><p>  Im obigen Beispiel erfolgt die Erstellung des getesteten :: Group () -Objekts innerhalb der Funktion, die wir von unserer Anwendung aus aufrufen m√ºssen, um die Tests zu registrieren: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  Eine Funktion ist nicht immer erforderlich. Manchmal k√∂nnen Sie einfach ein Objekt der <code>tested::Group</code> Klasse in einer Datei deklarieren.  Ich habe jedoch die Erfahrung gemacht, dass der Linker manchmal die gesamte Datei "optimiert", wenn sie in der Bibliothek zusammengestellt ist, und keine der Hauptanwendungen Zeichen aus dieser CPP-Datei verwendet: </p><br><pre> <code class="plaintext hljs">calc.lib &lt;- calc_test.lib(calc_test.cpp) ^ ^ | | app.exe run_test.exe</code> </pre> <br><p>  Wenn calc_test.cpp nicht mit der Quelle run_test.exe verkn√ºpft ist, entfernt der Linker diese Datei einfach vollst√§ndig aus der Betrachtung, zusammen mit der Erstellung eines statischen Objekts, obwohl sie die von uns ben√∂tigten Nebenwirkungen hat. </p><br><p>  Wenn welche Kette aus run_test.exe resultiert, wird das statische Objekt in der ausf√ºhrbaren Datei angezeigt.  Und es spielt keine Rolle, wie dies genau gemacht wird, wie im Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); }</code> </pre> <br><p>  oder so: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tested::Group&lt;CASE_COUNTER&gt; x(<span class="hljs-string"><span class="hljs-string">"std.vector"</span></span>, __FILE__); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LinkStdVectorTests</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br><p>  Die erste Option ist meiner Meinung nach besser, da der Konstruktor nach dem Start von main () aufgerufen wird und die Anwendung eine gewisse Kontrolle √ºber diesen Prozess hat. </p><br><p>  Ich denke, diese Einstellung von Kr√ºcken ist f√ºr jede Unit-Test-Bibliothek erforderlich, die globale Variablen und Nebenwirkungen des Konstruktors verwendet, um eine Testdatenbank zu erstellen.  Dies kann jedoch wahrscheinlich vermieden werden, indem die Testbibliothek mit dem Schl√ºssel --whole-archive verkn√ºpft wird (ein Analogon in MSVC wurde nur in Visual Studio 2015.3 angezeigt). </p><br><h3 id="makrosy">  Makros </h3><br><p>  Ich habe versprochen, dass es keine Makros geben wird, aber es ist - <code>CASE_COUNTER</code> .  Die Arbeitsoption besteht darin, dass es von <code>__COUNTER__</code> verwendet wird, einem Makro, das der Compiler bei jeder Verwendung in der √úbersetzungseinheit um eins erh√∂ht. <br>  Unterst√ºtzt von GCC, CLANG, MSVC, aber nicht vom Standard.  Wenn dies frustrierend ist, sind hier einige Alternativen: </p><br><ul><li>  Verwenden Sie die Nummern 0, 1, 2 </li><li>  Verwenden Sie Standard <code>__LINE__</code> . </li><li>  Verwende die Constexpr-Magie der Stufe 80.  Sie k√∂nnen nach "constexpr counter" suchen und versuchen, den Compiler zu finden, auf dem er funktioniert. </li></ul><br><p>  Das Problem mit <code>__LINE__</code> besteht darin, dass durch die Verwendung gro√üer Zahlen in den Vorlagenoptionen eine gro√üe Gr√∂√üe der ausf√ºhrbaren Datei erstellt wird.  Aus diesem Grund habe ich den Typ des signierten Zeichenmusters auf 128 als maximale Anzahl von Tests in der Gruppe beschr√§nkt. </p><br><h3 id="otkaz-ot-dinamicheskoy-pamyati">  Ausfall des dynamischen Speichers </h3><br><p>  Es stellte sich heraus, dass Sie bei der Registrierung von Tests keinen dynamischen Speicher verwenden k√∂nnen, den ich verwendet habe.  Es ist m√∂glich, dass Ihre Umgebung keinen dynamischen Speicher hat oder Sie in Testf√§llen die Suche nach Speicherlecks verwenden, sodass das Eingreifen in die Testausf√ºhrungsumgebung nicht das ist, was Sie ben√∂tigen.  Google Test hat damit zu k√§mpfen. Hier ist ein Ausschnitt von dort: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Use the RAII idiom to flag mem allocs that are intentionally never // deallocated. The motivation is to silence the false positive mem leaks // that are reported by the debug version of MS's CRT which can only detect // if an alloc is missing a matching deallocation. // Example: // MemoryIsNotDeallocated memory_is_not_deallocated; // critical_section_ = new CRITICAL_SECTION; class MemoryIsNotDeallocated</span></span></code> </pre> <br><p>  Und wir k√∂nnen einfach keine Schwierigkeiten schaffen. </p><br><p>  Wie bekommen wir dann eine Liste von Tests?  Dies sind eher technische Interna, die im Quellcode leichter zu erkennen sind, aber ich werde es Ihnen trotzdem sagen. </p><br><p>  Beim Erstellen einer Gruppe erh√§lt ihre Klasse einen Zeiger auf die Funktion <code>tested::CaseCollector&lt;CASE_COUNTER&gt;::collect</code> , mit der alle Tests von √úbersetzungseinheiten in einer Liste zusammengefasst werden.  So funktioniert es: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make the anonymouse namespace to have instances be hidden to specific translation unit namespace { template &lt;Ordinal_t N&gt; struct CaseCollector { // Test runtime that collects the test case struct CollectorRuntime final : IRuntime { void StartCase(const char* caseName, const char* description = nullptr) final { // the trick is exit from test case function into the collector via throw throw CaseIsReal(); } }; // Finds the Case&lt;N&gt; function in current translation unit and adds into the static list. It uses the // reverse order, so the case executed in order of appearance in C++ file. static CaseListEntry* collect(CaseListEntry* tail) { CaseListEntry* current = nullptr; CollectorRuntime collector; try { Case&lt;N&gt;(&amp;collector); } catch (CaseIsStub) { current = tail; } catch (CaseIsReal) { s_caseListEntry.CaseProc = Case&lt;N&gt;; s_caseListEntry.Next = tail; s_caseListEntry.Ordinal = N; current = &amp;s_caseListEntry; } return CaseCollector&lt;N - 1&gt;::collect(current); } private: static CaseListEntry s_caseListEntry; }; // This static storage will be instantiated in any cpp file template &lt;Ordinal_t N&gt; CaseListEntry CaseCollector&lt;N&gt;::s_caseListEntry; }</span></span></code> </pre> <br><p>  Es stellt sich heraus, dass in jeder √úbersetzungseinheit viele statische Variablen vom Typ CaseListEntry CaseCollector \ :: s_caseListEntry erstellt werden, die Elemente der Testliste sind, und die Methode collect () sammelt diese Elemente in einer einzeln verbundenen Liste.  In etwa der gleichen Weise bildet die Liste Gruppen von Tests, jedoch ohne Muster und Rekursion. <br></p><br><h3 id="struktura">  Struktur </h3><br><p>  Tests ben√∂tigen eine andere Bindung, z. B. Ausgabe in roten Buchstaben an die Konsole. Fehlgeschlagen. Erstellen von Testberichten in einem f√ºr CI oder GUI verst√§ndlichen Format, in dem Sie die Liste der Tests anzeigen und die ausgew√§hlten Tests ausf√ºhren k√∂nnen - im Allgemeinen viele Dinge.  Ich habe eine Vision davon, wie dies getan werden kann, die sich von der unterscheidet, die ich zuvor in der Testbibliothek gesehen habe.  Der Anspruch bezieht sich haupts√§chlich auf Bibliotheken, die sich "nur Header" nennen und gleichzeitig eine gro√üe Menge Code enthalten, was im Wesentlichen nicht f√ºr Header-Dateien gilt. </p><br><p>  Ich gehe davon aus, dass wir die Bibliothek in Front-End-Bibliotheken aufteilen - dies wird getestet. H- und Back-End-Bibliotheken selbst.  Um Tests zu schreiben, ben√∂tigen Sie nur getestete.h, die jetzt C ++ 17 ist (aufgrund der std :: std :: string_view), aber es wird angenommen, dass es C ++ 98 geben wird.  Tested.h f√ºhrt tats√§chlich die Registrierung und Suche nach Tests durch, eine minimal bequeme Startoption sowie die M√∂glichkeit, Tests (Gruppen, Adressen von Testfallfunktionen) zu exportieren.  Noch nicht vorhandene Back-End-Bibliotheken k√∂nnen alles tun, was sie f√ºr die Ausgabe von Ergebnissen und den Start mithilfe der Exportfunktion ben√∂tigen.  Auf die gleiche Weise k√∂nnen Sie den Start an die Anforderungen Ihres Projekts anpassen. </p><br><h3 id="itog">  Zusammenfassung </h3><br><p>  Die getestete Bibliothek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Github-Code</a> ) muss noch stabilisiert werden.  F√ºgen Sie in naher Zukunft die M√∂glichkeit hinzu, asynchrone Tests auszuf√ºhren (die f√ºr Integrationstests in WebAssembly erforderlich sind), und geben Sie die Gr√∂√üe der Tests an.  Meiner Meinung nach ist die Bibliothek noch nicht ganz produktionsbereit, aber ich habe pl√∂tzlich viel Zeit verbracht und die B√ºhne ist stehen geblieben, um Luft zu holen und um Feedback von der Community zu bitten.  M√∂chten Sie diese Art von Bibliothek nutzen?  Vielleicht gibt es noch andere Ideen im C ++ - Arsenal, da es m√∂glich w√§re, eine Bibliothek ohne Makros zu erstellen?  Ist eine solche Erkl√§rung des Problems √ºberhaupt interessant? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434906/">https://habr.com/ru/post/de434906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434892/index.html">Zeichnungscode in Swift, PaintCode</a></li>
<li><a href="../de434894/index.html">Die Kunst des Schamanismus oder der benutzerdefinierten Firmware f√ºr Olinuxino. Teil 1</a></li>
<li><a href="../de434896/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Ger√§te der letzten 50 Jahre, Teil 1</a></li>
<li><a href="../de434898/index.html">Grasp2Vec: Lernen, Objekte durch selbstlernende Erfassung darzustellen</a></li>
<li><a href="../de434902/index.html">Erstellen eines benutzerdefinierten Abfragegenerators in Spring Data Neo4j (Teil 1)</a></li>
<li><a href="../de434908/index.html">Programmiererausbildung - Was? Wo? Wann?</a></li>
<li><a href="../de434912/index.html">Der j√§hrliche Bestand von Porsche Taycan ist bereits reserviert, haupts√§chlich von Tesla-Besitzern</a></li>
<li><a href="../de434924/index.html">Was Sie √ºber die Organisation von Arbeitspl√§tzen, Coworking und die Gestaltung von R√§umen f√ºr Fernarbeit lesen sollten</a></li>
<li><a href="../de434928/index.html">Methoden der Anwendung und Verzerrung der Genauigkeit in Spielen. Visuelle Diagramme zum Vergleich</a></li>
<li><a href="../de434930/index.html">Videoanzeige heute: muss ein erfolgreiches Gesch√§ft haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>