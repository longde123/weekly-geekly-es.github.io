<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎁 🚭 🚙 Réagir et fractionner le code 🍫 📌 🚏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai rencontré le fractionnement de code il y a très longtemps, en 2008, lorsque Yandex était un peu suspendu, et les scripts Yandex.Direct connectés ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Réagir et fractionner le code</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442046/"><p>  J'ai rencontré le fractionnement de code il y a très longtemps, en 2008, lorsque Yandex était un peu suspendu, et les scripts Yandex.Direct connectés de manière synchrone au site ont simplement tué ce site.  En général, il était normal à cette époque que vos «scripts» soient 10 fichiers que vous connectez dans le seul ordre correct, ce qui (avec différé) fonctionne toujours très bien. <br>  Ensuite, j'ai commencé à travailler activement avec les cartes, et elles sont toujours connectées en tant que scripts externes, bien sûr paresseux.  Ensuite, en tant que membre de l'équipe Yandex.Mart, j'ai activement utilisé la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction d'</a> arborescence <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ymodules</a> sur le client, qui a fourni le fractionnement de code parfait. </p><br><p> Et puis je suis allé à <code>webpack</code> et <code>React</code> , au pays des idiots effrayés qui regardaient <code>require.ensure</code> comme un bélier à une nouvelle porte, et le font toujours. </p><br><p>  Le fractionnement de code n'est pas une fonctionnalité sensationnelle, c'est un must have.  La <code>SSR</code> n'interférerait toujours pas ... </p><br><p><img src="https://habrastorage.org/webt/47/7y/ay/477yayld6xtgc06hmgfejbrfpxc.jpeg"></p><a name="habracut"></a><br><h3 id="malenkoe-vvedenie">  Petite introduction </h3><br><p>  De nos jours, lorsque les bundles grossissent chaque jour, le fractionnement de code devient plus important que jamais.  Au tout début, les gens sont sortis de cette situation simplement en créant des points d’entrée distincts pour chaque page de leur application, ce qui est généralement bien, mais cela ne fonctionnera pas pour SPA. <br>  Puis est venue la fonction <code>require.ensure</code> , aujourd'hui connue sous le nom d' <code>dynamic import</code> (juste importation), à travers laquelle vous pouvez simplement demander un module, que vous recevrez un peu plus tard. </p><br><p>  La première bibliothèque sur ce cas pour React était <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">téléchargeable</a> , le battage médiatique autour duquel je ne suis toujours pas très clair et qui est déjà mort (il a juste cessé de plaire à l'auteur). </p><br><p>  <code>React.lazy</code> et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">composants chargeables</a> (juste <code>@loadable</code> ) seront le choix plus ou moins «officiel», et le choix entre eux est évident: </p><br><ul><li>  React.lazy est complètement incapable de SSR (Server Side Rendering), du mot en général.  Même dans les tests, il tombera sans danses spéciales avec un tambourin, comme les "promesses synchrones". </li><li>  Un SSR chargeable peut, et tout en prenant en charge Suspense, n'est pas pire que React.Lazy. </li></ul><br><p>  En particulier, loadable prend en charge de magnifiques wrappers pour le chargement des bibliothèques (loadable.lib, vous pouvez prendre moment.js dans React renderProp), et aide le webpack côté serveur à collecter une liste des scripts, styles et ressources utilisés pour la prélecture (ce que webpack lui-même ne connaît pas vraiment).  En général, lisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation officielle</a> . </p><br><h3 id="ssr">  SSR </h3><br><p>  En général, tout le problème est dans le SSR.  Pour CSR (Client Side Render), React.lazy ou un petit script de 10 lignes conviendra - ce sera certainement suffisant, et cela n'a aucun sens de connecter une grande bibliothèque externe.  Mais sur le serveur, cela ne sera pas suffisant.  Et si vous n'avez pas vraiment besoin d'un SSR, vous pouvez ignorer la lecture.  Vous n'avez aucun problème qui doit être résolu longtemps et durement. </p><br><p>  La RSS est une douleur.  Je (en quelque sorte) est l'un des mainteneurs des composants chargeables et c'est juste horrible combien de bogues sortent de différents endroits.  Et à chaque mise à jour, le webpack vole encore plus. </p><br><h3 id="ssr--css">  SSR + CSS </h3><br><p>  CSS est une source encore plus importante de problèmes avec les SSR. <br>  Si vous avez des composants stylés - cela ne fait pas trop mal - ils sont livrés avec un <code>transform-stream</code> qui ajoutera lui-même ce qui est nécessaire au code final.  L'essentiel est qu'il doit y avoir une version de SC partout, sinon le focus ne fonctionnera pas - une version de SC ne pourra rien dire d'autre sur elle-même, et SC aime se multiplier (vérifiez votre bundle).  Pour être honnête, c'est précisément à cause de cette limitation que la mise au point <strong>échoue</strong> généralement. </p><br><p>  L'émotion C est plus simple - leur adaptateur de <code>styled</code> crache simplement <code>&lt;style&gt;</code> devant le composant lui-même, et le problème est résolu.  Simple, bon marché et joyeux.  En principe, il est très convivial pour les mobiles et optimise considérablement la toute première vue.  Mais gâche un peu la seconde.  Et personnellement, ma conscience ne me permet pas d'insérer des styles comme ça. </p><br><p>  Avec le CSS ordinaire (y compris celui obtenu à partir de diverses bibliothèques CSS-in-JS avec une magie différente), c'est encore plus facile - il y a des informations à leur sujet dans la colonne webpack, et il est "connu" quel CSS doit être connecté. </p><br><h3 id="poryadok-podklyucheniya">  Ordre de connexion </h3><br><p>  Ici, le chien s'est enterré.  Quand dois-je me connecter? <br>  Le fractionnement de code convivial SSR signifie qu'avant d'appeler <code>ReactDOM.hydrate</code> vous devez télécharger tous les "composants" qui sont déjà présents dans la réponse du serveur, mais les scripts actuellement chargés sur le client ne peuvent pas se le permettre. </p><br><p>  Par conséquent, toutes les bibliothèques offrent un certain rappel qui sera appelé lorsque tout-tout-ce qui doit être chargé, et vous pouvez démarrer le <em>cerveau</em> .  C'est le sens du travail des bibliothèques de découpage de codes SSR. </p><br><p>  JS peut être chargé à tout moment, et généralement leur liste est ajoutée à la fin du HTML, mais CSS, pour qu'il n'y ait pas de FOUC, doit être ajouté au début. <br>  Toutes les bibliothèques peuvent le faire pour l'ancien <code>renderToString</code> , et toutes les bibliothèques <strong>ne</strong> peuvent pas le faire pour <code>renderToNodeStream</code> . <br>  Peu importe si vous n'avez que JS (cela ne se produit pas) ou SC / Emotion (qui s'ajoutera).  Mais - si vous avez "juste CSS" - c'est tout.  Soit ils seront à la fin, soit ils devront utiliser <code>renderToString</code> , ou une autre mise en mémoire tampon, qui fournira un retard TTFB (Time To First Byte) et réduira légèrement le sentiment d'avoir ce SSR en général. </p><br><p>  Et bien sûr - tout cela est lié au webpack et d'aucune autre manière.  Par conséquent, avec tout le respect que je dois à Greg, l'auteur des composants chargeables, je propose d'envisager d'autres options. </p><br><blockquote>  Ensuite, un programme en trois parties, dont l'idée principale est de faire quelque chose qui n'est pas tué et ne dépend pas du bundler. </blockquote><br><h3 id="1-react-imported-component">  1. Composant importé par React </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">React-Imported-Component</a> n'est pas un mauvais "chargeur", avec une interface plus ou moins standard, très similaire aux composants chargeables, qui peuvent SSR pour tout ce qui bouge. </p><br><p>  L'idée est très simple. </p><br><ul><li>  les codes source sont analysés, toutes les <code>import</code> sont trouvées et <strong>copiées</strong> dans un fichier séparé </li><li>  utiliser le <code>babel plugin</code> chaque appel pour <code>import</code> se transforme en sucre <br><pre> <code class="plaintext hljs">const AsyncComponent1 = imported(() =&gt; import('./MyComponent')); ///// const AsyncComponent1 = imported(() =&gt; importedWrapper("imported_18g2v0c_component", import('./MyComponent')));</code> </pre> </li><li>  lors de l'appel de la fonction "import". toString se fait simplement et le nombre magique est retiré.  Ainsi, il devient clair ce qui a été causé.  (Oui - cela impose certaines restrictions sur le code, mais moins que les autres chargeurs qui ne peuvent pas "pas du tout" importer) </li><li>  sur le client, nous avons un fichier où toutes les importations possibles sont collectées, et toute importation peut être <em>répétée</em> . </li></ul><br><p>  Pas besoin d' <code>stats.json</code> , de s'adapter à l'optimisation du webpack (concaténation ou code commun) - il vous suffit de faire correspondre le "label" d'une importation dans la clé du tableau et d'importer à nouveau.  Comment cela sera effectué dans le cadre d'un bundle spécifique, combien de fichiers seront réellement téléchargés et d'où n'est pas son problème. </p><br><p>  Moins - le début du chargement des morceaux "utilisés" se produit après le chargement du paquet principal, qui stocke le mappage, qui est un peu "plus tard" que dans le cas des composants chargeables, qui ajouteront ces informations directement au HTML. </p><br><p>  Oui, avec CCS, cela ne fonctionne en aucune façon à partir du mot. </p><br><h3 id="2-used-styles">  2. styles utilisés </h3><br><p>  Mais les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">styles utilisés</a> ne fonctionnent qu'avec CSS, mais de la même manière que les composants importés par réaction. </p><br><ul><li>  analyse tous les css (dans le répertoire de construction) </li><li>  se souvient où la classe est définie </li><li>  analyse la sortie renderToNodeStream (ou la réponse <code>renderToString</code> ) </li><li>  trouve class = 'XXX', correspond au fichier et le recrache dans la réponse du serveur. </li><li>  (enfin, puis téléporte tous ces styles à la tête pour ne pas casser l'hydrate).  Les composants de style fonctionnent de la même façon. </li></ul><br><p>  Il n'y a pas de retard TTBT, il n'est pas lié au bundler - un conte de fées.  Fonctionne comme une montre si les styles sont bien écrits. </p><br><p>  <a href="">React-import-component + used-styles + parcel</a> working example. </p><br><blockquote>  Ce n'est pas le bonus le plus évident - sur le serveur, les deux bibliothèques feront "tout ce qui est nécessaire" pendant le démarrage, jusqu'à ce que le serveur express puisse recevoir le premier client, et seront complètement synchronisées à la fois sur le serveur et pendant les tests. </blockquote><br><h3 id="3-react-prerendered-component">  3. composant réactif pré-rendu </h3><br><p>  Et la bibliothèque ferme le trio de tête, qui fait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"réhydratation partielle"</a> , et le fait de manière si grand-père que je me le demande tout de suite.  Elle ajoute vraiment des "divas". </p><br><ul><li>  sur le serveur: <br><ul><li>  enveloppe un morceau de bois dans une div avec un "id célèbre" </li></ul></li><li>  sur le client: <br><ul><li>  le constructeur du composant trouve sa propre div </li><li>  copie son innerHTML avant que React ne le prenne. </li><li>  utilise ce code HTML jusqu'à ce que le client soit prêt à l' <code>hydrate</code> </li><li>  techniquement, cela permet d'utiliser le SSR hybride (Rendertron) </li></ul></li></ul><br><pre> <code class="plaintext hljs">const AsyncLoadedComponent = loadable(() =&gt; import('./deferredComponent')); const AsyncLoadedComponent = imported(() =&gt; import('./deferredComponent')); &lt;PrerenderedComponent live={AsyncLoadedComponent.preload()} // when Promise got resolve - component will go "live" &gt; &lt;AsyncLoadedComponent /&gt; // meanwhile you will see "preexisting" content &lt;/PrerenderedComponent&gt;</code> </pre> <br><p>  Ce focus ne fonctionne pas avec les composants chargeables, car il <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne revient pas d'une promesse de préchargement</a> .  Ceci est particulièrement important pour les bibliothèques comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">react-snap</a> (et autres "prerender") qui ont du "contenu" mais qui ne sont pas passées par un "vrai" SSR. </p><br><p><img src="https://habrastorage.org/webt/av/oa/uy/avoauymgvrxzwyo18-8skc69cws.png"></p><br><p>  Du point de vue du code, c'est 10 lignes, plus un peu plus pour obtenir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des UID SSR-CSR stables</a> en tenant compte de l'ordre aléatoire de chargement et d'exécution du code. </p><br><p>  Bonus: </p><br><ul><li>  vous n'avez pas à attendre le «chargement de tous les scripts» avant de démarrer le <em>cerveau</em> - les cerveaux démarreront dès qu'ils seront prêts </li><li>  vous <strong>n'avez</strong> pas du tout à charger de cerveaux, laissant des données SSR (s'il n'y a pas de version SSR, les cerveaux seront toujours chargés).  Tout comme au temps jQuery. </li><li>  Vous pouvez également implémenter la <strong>mise en cache de</strong> flux <strong>de</strong> grands blocs de rendu (théoriquement compatibles avec la suspension) - à nouveau en utilisant le flux de transformation. </li><li>  et sérialiser / désérialiser l'état vers / depuis HTML, comme lors de jQuery </li></ul><br><p>  En principe, la sérialisation et la désérialisation étaient l'idée principale de créer une bibliothèque pour résoudre le problème de duplication de l'état (photo de l'article sur la SSR).  Caching est arrivé plus tard. <br><img src="https://habrastorage.org/webt/wb/9q/ni/wb9qniykqfav6ouzmjkrtpjhy5w.png"></p><br><h3 id="itogo">  Total </h3><br><p>  Au total, trois approches peuvent changer votre vision de la SSR et du fractionnement de code.  Le premier fonctionne avec le découpage de code JS et ne casse pas.  Le second fonctionne avec le fractionnement de code CSS et ne se casse pas.  Le troisième fonctionne au niveau HTML en simplifiant et en accélérant certains processus, et là encore, il ne casse pas. </p><br><p>  Liens vers les bibliothèques: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/theKashey/react-imported-component/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/theKashey/react-prerendered-component</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/theKashey/used-styles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/smooth-code/loadable-components/</a> </li><li>  (pour ceux qui sont dans le réservoir) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://reactjs.org/blog/2018/10/23/react-v-16-6.html#reactlazy-code-splitting-with-suspense</a> </li></ul><br><p>  Articles (en anglais) </p><br><ul><li>  (sur importé) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://hackernoon.com/react-and-code-splitting-made-easy-f118befb5168</a> </li><li>  (à propos de pré-rendu) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://medium.com/@antonkorzunov/react-server-side-code-splitting-made-again-a61f8cbbd64b</a> </li><li>  (à propos de SSR) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://developers.google.com/web/updates/2019/02/rendering-on-the-web#partial-rehydration</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442046/">https://habr.com/ru/post/fr442046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442034/index.html">Contournement de ReCaptcha dans les tests au sélénium</a></li>
<li><a href="../fr442036/index.html">Runtime de conteneur mature: containerd devient diplômé de la CNCF</a></li>
<li><a href="../fr442038/index.html">Le condensé des événements pour les professionnels RH dans le domaine de l'informatique en mars 2019</a></li>
<li><a href="../fr442040/index.html">Le partenariat comme outil efficace de développement commercial</a></li>
<li><a href="../fr442044/index.html">Comment nous utilisons le système de surveillance de détail Zabbix</a></li>
<li><a href="../fr442048/index.html">Comment Google Programmer résout les problèmes courants</a></li>
<li><a href="../fr442050/index.html">Que faire si vous souhaitez collecter des fonds pour la réparation de l'échec, et que seul Wikipédia est à portée de main</a></li>
<li><a href="../fr442052/index.html">La nouvelle technologie peut décupler la résolution des images des tissus biologiques</a></li>
<li><a href="../fr442054/index.html">Février 2019 Joomla Digest</a></li>
<li><a href="../fr442056/index.html">Résumé des événements informatiques de mars (première partie)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>