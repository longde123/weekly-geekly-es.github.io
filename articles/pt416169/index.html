<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👇 💇🏾 🧀 Contentores para adultos (parte 01): um guia prático de terminologia 🐘 🈚️ 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você pode perguntar: por que lidar com terminologia se o conceito de contêiner parece bastante simples e direto? No entanto, muitas vezes o uso incorr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contentores para adultos (parte 01): um guia prático de terminologia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416169/">  Você pode perguntar: por que lidar com terminologia se o conceito de contêiner parece bastante simples e direto?  No entanto, muitas vezes o uso incorreto de termos cria obstáculos ao desenvolvimento de contêineres.  Por exemplo, as pessoas geralmente pensam que os termos “contêineres” e “imagens” são usados ​​de forma intercambiável, embora, de fato, haja importantes diferenças conceituais entre eles.  Outro exemplo: no mundo dos contêineres, um "repositório" não significa o que você pensa.  Além disso, a tecnologia de contêiner é muito mais do que apenas estivador. <br><br><img src="https://habrastorage.org/webt/ze/ev/2e/zeev2e5kfluh5uhoj-bpkgc6km8.png" width="100%"><br><br>  Portanto, sem conhecer a terminologia, será difícil entender como o docker difere do CRI-O, rkt ou lxc / lxd;  ou avaliar o papel da Open Container Initiative na padronização de tecnologias de contêineres. <br><a name="habracut"></a><br><h3>  1. Introdução </h3><br>  A introdução aos contêineres Linux é muito simples, mas logo se descobre que essa simplicidade é enganosa.  Isso geralmente acontece assim: depois de passar apenas alguns minutos instalando uma janela de encaixe ou outro mecanismo de contêiner, você já insere seus primeiros comandos.  Apenas alguns minutos - e você já criou sua primeira imagem do contêiner e a colocou em domínio público.  Em seguida, você costuma seguir para a arquitetura do ambiente de produção e, de repente, percebe que, para isso, precisa primeiro lidar com a massa de termos e tecnologias que estão por trás de tudo isso.  Pior, muitos dos termos listados abaixo são usados ​​de forma intercambiável, o que cria muita confusão para iniciantes. <br><br><ul><li>  Container </li><li>  Imagem </li><li>  Imagem do container </li><li>  Camada de imagem </li><li>  Registo </li><li>  Repositório </li><li>  Tag </li><li>  Imagem Base </li><li>  Imagem da plataforma </li><li>  Camada </li></ul><br>  Tendo dominado a terminologia estabelecida neste documento, você entenderá melhor a base tecnológica dos contêineres.  Além disso, ajudará você e seus colegas a falarem o mesmo idioma, bem como o design consciente e intencional da arquitetura de ambientes de contêineres, de acordo com as especificidades das tarefas que estão sendo resolvidas.  Por sua vez, do ponto de vista da comunidade de TI e da indústria como um todo, um aumento geral no entendimento das tecnologias de contêineres contribui para o surgimento de novas arquiteturas e soluções.  Observe que este artigo é destinado a um leitor que já tenha uma idéia de como executar contêineres. <br><br><h3>  Contentores: Básico </h3><br>  Antes de prosseguir com a terminologia dos contêineres, determinaremos o que é, de fato, o próprio contêiner.  O termo "contêiner" significa duas coisas ao mesmo tempo.  Como um programa Linux normal, um contêiner pode estar em um dos dois estados: funcionando e não funcionando.  No estado inativo, o contêiner é um arquivo ou um conjunto de arquivos armazenados no disco.  É nesse estado que os termos Imagem do contêiner e Repositório do contêiner se referem.  Quando você insere o comando de inicialização do contêiner, o mecanismo do contêiner descompacta os arquivos e metadados necessários e os transfere para o kernel do Linux.  Iniciar um contêiner é muito semelhante a iniciar um processo normal do Linux e requer uma chamada de API para o kernel do Linux.  Essa chamada de API geralmente inicia um isolamento adicional e monta uma cópia dos arquivos que estão na imagem do contêiner.  Após o lançamento do contêiner, é apenas um processo do Linux.  O procedimento para iniciar contêineres, bem como o formato das imagens dos contêineres armazenados em disco, são definidos e regulamentados por padrões. <br><br>  Existem vários formatos para imagens de contêiner ( <a href="">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Appc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LXD</a> ), mas o setor está gradualmente se movendo em direção a um único padrão da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open Container Initiative</a> , às vezes chamado de Open Containers ou simplesmente OCI.  Esse padrão define a <a href="">especificação do formato da imagem do contêiner</a> , que define o formato do disco para armazenar imagens do contêiner, bem como os metadados, que, por sua vez, definem coisas como a arquitetura de hardware e o sistema operacional (Linux, Windows, etc.).  Um único formato de imagem em todo o setor é a chave para criar um ecossistema de software que permite que desenvolvedores, projetos de código aberto e fornecedores de software criem imagens compatíveis e várias ferramentas, como assinatura eletrônica, varredura, montagem, lançamento, movimentação e gerenciamento de imagens de contêiner. <br><br>  Além disso, existem vários motores de contêiner, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRI-O</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Railcar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RKT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LXC</a> .  O mecanismo de contêiner obtém uma imagem do contêiner e o transforma em um contêiner (isto é, um processo em execução).  O processo de conversão também é definido pelo padrão OCI, que inclui uma especificação de tempo de execução do contêiner e uma implementação de referência de tempo de execução chamada RunC, que é um modelo de código aberto que é regulado pela comunidade de desenvolvimento apropriada.  Muitos mecanismos de contêiner usam esse modelo para interagir com o kernel host ao criar contêineres. <br><br>  As ferramentas que suportam as especificações do <a href="">formato de imagem do contêiner</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o ambiente de execução do contêiner</a> do padrão OCI fornecem portabilidade no ecossistema de várias plataformas de contêineres, mecanismos de contêiner e ferramentas de suporte em várias plataformas em nuvem e arquiteturas locais.  Compreender a terminologia, os padrões e a arquitetura dos sistemas de contêineres permitirá que você se comunique com outros especialistas e projete aplicativos e ambientes em contêineres escalonáveis ​​e suportados que garantam o uso eficiente dos contêineres nos próximos anos. <br><br><h3>  Vocabulário básico </h3><br><h4>  Imagem do contêiner </h4><br>  Em sua definição mais simples, uma imagem de contêiner é um arquivo baixado do servidor de registro e usado localmente como um ponto de montagem quando o contêiner é iniciado.  Apesar de o termo "imagem de contêiner" ser usado com bastante frequência, ele pode significar coisas diferentes.  O fato é que, embora o Docker, o RKT e até o LXD funcionem de acordo com o princípio descrito, ou seja, eles baixam arquivos excluídos e os executam como contêineres, cada uma dessas tecnologias interpreta a imagem do contêiner de sua própria maneira.  O LXD opera com imagens monolíticas (camada única), enquanto o docker e o RKT usam imagens OCI, que podem conter várias camadas. <br><br>  A rigor, uma imagem de contêiner em um servidor de registro está longe de ser um único arquivo.  Quando as pessoas usam o termo "imagem do contêiner", geralmente significam o repositório e um conjunto de várias camadas da imagem do contêiner, além de metadados que contêm informações adicionais sobre essas camadas. <br><br>  Além disso, o conceito de uma imagem de contêiner implica implicitamente a existência de um formato para essa imagem. <br><br><h4>  Formato de imagem do contêiner </h4><br>  Inicialmente, cada mecanismo de contêiner, incluindo LXD, RKT e Docker, tinha seu próprio formato de imagem.  Alguns desses formatos permitem apenas uma camada, enquanto outros suportam uma estrutura em árvore de várias camadas.  Hoje, quase todas as principais ferramentas e mecanismos de contêiner mudaram para o formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OCI</a> , que determina como as camadas e os metadados devem ser organizados na imagem do contêiner.  Em essência, o formato OCI define uma imagem de contêiner que consiste em arquivos tar separados para cada camada e um arquivo manifest.json comum contendo metadados. <br><br>  O padrão <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open Container Initiative (OCI)</a> , originalmente baseado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">formato de imagem Docker V2</a> , combinou com sucesso um grande ecossistema de mecanismos de contêiner, plataformas e ferramentas em nuvem (scanners de segurança, ferramentas de assinatura, criação e movimentação de contêineres) e permite proteger seu investimento em conhecimento e ferramentas <br><br><h4>  Motor para contêiner </h4><br>  O mecanismo de contêiner é a parte do software que aceita solicitações de usuário, incluindo parâmetros de linha de comando, baixa imagens e, da perspectiva do usuário final, lança contêineres.  Existem muitos mecanismos de contêiner, incluindo docker, RKT, CRI-O e LXD.  Além disso, muitas plataformas em nuvem, serviços de PaaS e plataformas de contêineres têm seus próprios mecanismos que entendem imagens no formato Docker ou OCI.  Ter um padrão do setor para o formato de imagem garante a interoperabilidade de todas essas plataformas. <br><br>  Ao descer um nível, podemos dizer que a maioria dos mecanismos de contêineres não inicia os contêineres, mas através de um tempo de execução compatível com OCI, como runc.  Normalmente, um tempo de execução do contêiner faz o seguinte: <br><br><ul><li>  Lida com parâmetros, entrada do usuário </li><li>  Manipula os parâmetros passados ​​pela API (geralmente o sistema de orquestração de contêiner) </li><li>  Baixe imagens de contêiner do servidor de registro </li><li>  Descompacta e salva a imagem do contêiner em disco usando o Driver Gráfico (bloco ou arquivo, dependendo do driver) </li><li>  Prepara um ponto de montagem para o contêiner, geralmente no armazenamento de copiar na gravação (novamente, em bloco ou arquivo, dependendo do driver) </li><li>  Prepara os metadados que serão passados ​​para o tempo de execução para executar o contêiner corretamente usando: <br><ul><li>  Configurações padrão específicas implícitas para a imagem do contêiner (por exemplo, <a href="">ArchX86</a> ) </li><li>  Entrada do usuário para substituir os valores padrão contidos na imagem do contêiner (por exemplo, CMD, ENTRYPOINT) </li><li>  Parâmetros padrão especificados pela imagem do contêiner (por exemplo, regras <a href="">SECCOM</a> ) </li></ul></li><li>  Invoca o tempo de execução do contêiner </li></ul><br><h4>  Container </h4><br>  Os contêineres existem nos sistemas operacionais há algum tempo, porque na verdade essa é apenas uma instância em execução de uma imagem de contêiner.  Um contêiner é um processo Linux padrão que geralmente é criado usando a chamada do sistema clone () em vez de fork () ou exec ().  Além disso, medidas adicionais de isolamento são frequentemente aplicadas a contêineres usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cgroups</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SELinux</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppArmor</a> . <br><br><h4>  Host do contêiner </h4><br>  Um host de contêiner é um sistema no qual os processos em contêiner são executados, geralmente chamados de contêineres por simplicidade.  Pode ser, por exemplo, uma máquina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RHEL Atomic Host</a> localizada em uma nuvem pública ou executando bare metal em um data center corporativo.  Quando a imagem do contêiner (em outras palavras, o repositório) do servidor de registro é baixada para o host do contêiner local, eles dizem que ela cai no cache local. <br><br>  Você pode determinar quais repositórios são sincronizados com o cache local usando o seguinte comando: <br><br><pre>  [root @ rhel7 ~] # imagens do docker -a<font></font>
<font></font>
 ID DE IMAGEM DE REPOSITÓRIO IDENTIFICADO TAMANHO VIRTUAL
 registry.access.redhat.com/rhel7 mais recente 6883d5422f4e 3 semanas atrás 201,7 MB </pre><br><h4>  Servidor de registro </h4><br>  Um servidor de registro é essencialmente um servidor de arquivos usado para armazenar repositórios de janela de encaixe.  Como regra, o servidor de registro é especificado pelo nome DNS e, opcionalmente, pelo número da porta.  A maioria dos benefícios do ecossistema docker é impulsionada pela capacidade de baixar e carregar repositórios nos servidores de registro. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/mw/m4/rumwm4l9pkgmpglcy4xdu3rfb5q.png"></div><br>  Se o daemon do docker não encontrar uma cópia do repositório no cache local, ele fará o download automaticamente do servidor de registro.  Na maioria das distribuições Linux, o daemon docker usará o site docker.io para isso, mas em algumas distribuições ele pode ser configurado da sua maneira.  Por exemplo, o Red Hat Enterprise Linux tenta primeiro fazer o download do registry.access.redhat.com e somente depois do docker.io (Docker Hub). <br><br>  Deve-se enfatizar aqui que o servidor de registro é implicitamente considerado confiável.  Portanto, você deve decidir quanto confia no conteúdo de um registro e, respectivamente, permitir ou negar.  Além da segurança, há outros aspectos que devem ser abordados com antecedência, por exemplo, problemas de licenciamento de software ou monitoramento de conformidade.  A simplicidade com a qual o docker permite que os usuários baixem software torna a questão da confiança extremamente importante. <br><br>  O Red Hat Enterprise Linux permite que você configure o registro do docker padrão.  Além disso, o RHEL7 e o RHEL7 Atomic permitem adicionar ou bloquear servidores de registro por meio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivo de configuração</a> : <br><br><pre>  vi / etc / sysconfig / docker
</pre><br>  RHEL7 e RHEL 7 Atomic usam o servidor de registro Red Hat por padrão: <br><br><pre>  ADD_REGISTRY = '- adicione o registro registry.access.redhat.com'
</pre><br>  Em alguns casos, por motivos de segurança, faz sentido bloquear registros públicos de janelas de encaixe, como o DockerHub: <br><br><pre>  # BLOCK_REGISTRY = '- registro de bloco'
</pre><br>  A Red Hat também oferece seu servidor de registro integrado como parte da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenShift Container Platform</a> , bem como o servidor de registro corporativo independente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quay Enterprise</a> e repositórios em nuvem, públicos e privados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quay.io.</a> <br><br><h4>  Orquestração de contêineres </h4><br>  As pessoas geralmente começam instalando um host de contêiner e primeiro baixando as imagens de contêiner de que precisam.  Em seguida, eles criam suas próprias imagens e as carregam no servidor de registro para disponibilizar para o restante da equipe.  Depois de algum tempo, é necessário combinar vários contêineres para que eles possam ser implantados como uma unidade.  E, finalmente, em algum momento, essas unidades devem fazer parte do transportador de produção (development-QA-production).  É assim que as pessoas geralmente percebem que precisam de um sistema de orquestração. <br><br>  <b>O sistema de orquestração de contêiner implementa apenas duas coisas:</b> <br><br><ol><li>  Despachar dinamicamente cargas de contêiner entre computadores de cluster (geralmente chamado de "computação distribuída") </li><li>  Fornece um arquivo de descrição de aplicativo padrão (kube yaml, composição do docker, etc.) </li></ol><br>  Essas duas coisas realmente oferecem uma série de benefícios: <br><br><ol><li>  A capacidade de gerenciar os contêineres que compõem o aplicativo, independentemente um do outro, o que permite resolver efetivamente as seguintes tarefas: <br><ul><li>  Eliminação de grandes clusters de hosts de contêiner </li><li>  Falha no nível de contêineres individuais (não há mais processos de resposta, exaustão de memória) </li><li>  Failover no nível do host do contêiner (unidades, rede, reinicialização) </li><li>  Failover no nível do mecanismo do contêiner (dano, reinicialização) </li><li>  Escalonamento individual de contêineres para cima e para baixo </li></ul></li><li>  Fácil de implantar novas instâncias do mesmo aplicativo em novos ambientes, tanto na nuvem quanto na tradicional, por exemplo: <br><ul><li>  Em máquinas de desenvolvedor controladas por um sistema de orquestração </li><li>  Em um ambiente de desenvolvimento compartilhado em um espaço para nome privado </li><li>  Em um ambiente de desenvolvimento comum em um espaço para nome público interno para garantir a visibilidade e o desempenho do teste </li><li>  No ambiente interno do controle de qualidade </li><li>  Em um ambiente de carga de teste fornecido dinamicamente e revogado na nuvem </li><li>  Em um ambiente de referência para verificar a compatibilidade com o ambiente de produção </li><li>  No ambiente de produção </li><li>  Em um ambiente de recuperação de desastre </li><li>  Em um novo ambiente de produção contendo hosts de contêiner atualizados, mecanismos de contêiner ou ferramentas de orquestração </li><li>  No novo ambiente de produção, que não é diferente do principal, mas localizado em uma região diferente </li></ul></li></ol><br>  Comunidades de código aberto e fornecedores de software oferecem muitas ferramentas diferentes de orquestração.  Inicialmente, as três grandes ferramentas incluíam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Swarm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mesos</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> , mas hoje o Kubernetes se tornou o padrão do setor, porque até o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mesosphere</a> anunciaram seu apoio, sem mencionar quase todos os principais provedores de serviços.  No entanto, se você estiver procurando por um sistema de orquestração corporativo, recomendamos que você analise mais de perto o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat OpenShift</a> . <br><br><h3>  Dicionário Avançado </h3><br><h4>  Tempo de execução do contêiner </h4><br>  O tempo de execução do contêiner é um componente de baixo nível que normalmente é usado como parte de um mecanismo de contêiner, mas também pode ser usado manualmente para testar contêineres.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O padrão OCI</a> define uma implementação de referência do tempo de execução conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">runc</a> .  Essa é a implementação mais usada, mas existem outros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempos de execução</a> compatíveis com OCI, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">railcar</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">katacontainers</a> .  Docker, CRI-O e muitos outros mecanismos de contêiner usam runc. <br><br>  O tempo de execução do contêiner é responsável pelos seguintes itens: <br><br><ul><li>  Obtém o ponto de montagem do contêiner fornecido pelo mecanismo de contêiner (para teste, poderia ser apenas um diretório) </li><li>  Obtém os metadados do contêiner fornecidos pelo mecanismo de contêiner (durante o teste, pode ser um arquivo config.json montado manualmente) </li><li>  Comunica-se com o kernel do SO para iniciar processos em contêiner (via chamada de sistema clone) </li><li>  Configura cgroups </li><li>  Configura a política do SELinux </li><li>  Configura regras da armadura de aplicativo </li></ul><br>  Um pouco de digressão histórica: quando o mecanismo do Docker apareceu pela primeira vez, ele usou o LXC como um ambiente de tempo de execução.  Os desenvolvedores do Docker então criaram sua própria biblioteca para executar contêineres chamados libcontainer.  Foi escrito no idioma Golang e tornou-se parte do mecanismo do Docker.  Após o estabelecimento da organização OCI, o Docker introduziu o código-fonte libcontainer nesse projeto e lançou esta biblioteca como um utilitário separado chamado runc, que se tornou a implementação de referência do tempo de execução do contêiner dentro do padrão OCI e é usado em outros mecanismos de contêiner, como o CRI-O .  Runc é um utilitário muito simples que apenas espera que um ponto de montagem (diretório) e metadados (config.json) sejam passados ​​para ele.  Mais informações sobre runc podem ser encontradas <a href="">aqui</a> . <br><br>  Para um entendimento mais aprofundado, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Noções básicas sobre padrões de contêiner</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempo de execução</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contêiner</a> . <br><br><h4>  Camadas de imagem </h4><br>  Os repositórios são frequentemente referidos como imagens ou imagens de contêineres, embora na verdade os repositórios consistam em uma ou mais camadas.  As camadas de imagem no repositório são interconectadas pelos relacionamentos pai-filho e cada camada de imagem contém diferenças da camada pai. <br><br>  Vejamos as camadas do repositório no host do contêiner local.  Desde o início da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versão 1.7, o Docker não possui uma ferramenta</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interna</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para exibir camadas de imagem</a> no repositório local (mas existem ferramentas para registros online), usaremos o utilitário <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dockviz</a> .  Observe que cada camada possui uma tag e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">identificador exclusivo universal (UUID)</a> .  Para visualizar UUIDs abreviados que geralmente são únicos na mesma máquina, usamos o seguinte comando (se você precisar de um UUID completo, use o mesmo comando com a opção -no-trunc): <br><br>  docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock nate / dockviz images -t <br><br><pre>  ├─2332d8973c93 Tamanho virtual: 187.7 MB
  Virtual └─ea358092da77 Tamanho virtual: 187,9 MB
  │ └─a467a7c6794f Tamanho virtual: 187,9 MB
  │ └─ca4d7b1b9a51 Tamanho virtual: 187,9 MB
  │ └─4084976dd96d Tamanho virtual: 384,2 MB
  Virtual └─943128b20e28 Tamanho virtual: 386,7 MB
  Virtual └─db20cc018f56 Tamanho virtual: 386,7 MB
  Virtual └─45b3c59b9130 Tamanho virtual: 398.2 MB
  Virtual └─91275de1a5d7 Tamanho virtual: 422,8 MB
  Virtual └─e7a97058d51f Tamanho virtual: 422,8 MB
  Virtual └─d5c963edfcb2 Tamanho virtual: 422.8 MB
  Virtual └─5cfc0ce98e02 Tamanho virtual: 422,8 MB
  Virtual └─7728f71a4bcd Tamanho virtual: 422,8 MB
  Virtual └─0542f67da01b Tamanho virtual: 422,8 MB Tags: docker.io/registry:latest
</pre><br>  Como você pode ver, o repositório docker.io/registry na verdade consiste em várias camadas.  No entanto, mais importante, o usuário pode, em princípio, "iniciar" o contêiner a partir de qualquer etapa dessa escada, por exemplo, digitando o comando abaixo (está completamente correto, mas ninguém pode garantir que foi testado ou que funcionará corretamente).  Como regra, o coletor de imagens identifica (cria nomes) as camadas que devem ser usadas como ponto de partida: <br><br><pre>  docker run -it 45b3c59b9130 bash
</pre><br>  Os repositórios são organizados de maneira semelhante, porque sempre que o coletor cria uma nova imagem, as diferenças são salvas como outra camada.  Existem duas maneiras principais de criar novas camadas no repositório.  Primeiro, ao criar uma imagem manualmente, cada confirmação de alteração cria uma nova camada.  Se o coletor criar uma imagem usando um arquivo Docker, cada diretiva no arquivo criará uma nova camada.  Portanto, é sempre útil poder ver o que mudou no repositório entre as camadas. <br><br><h4>  Tags </h4><br>  Embora o próprio usuário possa especificar a camada inicial para montar e iniciar o contêiner no repositório, ele não precisa fazer isso.  Quando o coletor de imagens cria um novo repositório, eles geralmente marcam as camadas mais adequadas para essa função.  Esses marcadores são chamados de tags e representam uma ferramenta com a qual o coletor de imagens pode informar ao consumidor de imagens quais camadas são melhor usadas.  Normalmente, as tags são usadas para indicar versões de software em um repositório.   OCI,  -       ,          .      ,         . <br><br>  ,     – latest,     ,      .       ,     ,      . <br><br>       ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> jq</a>    ): <br><br><pre> curl -s registry.access.redhat.com/v1/repositories/rhel7/tags | jq<font></font>
 {<font></font>
 "7.0-21": "e1f5733f050b2488a17b7630cb038bfbea8b7bdfa9bdfb99e63a33117e28d02f",<font></font>
 "7.0-23": "bef54b8f8a2fdd221734f1da404d4c0a7d07ee9169b1443a338ab54236c8c91a",<font></font>
 "7.0-27": "8e6704f39a3d4a0c82ec7262ad683a9d1d9a281e3c1ebbb64c045b9af39b3940",<font></font>
 "7.1-11": "d0a516b529ab1adda28429cae5985cab9db93bfd8d301b3a94d22299af72914b",<font></font>
 "7.1-12": "275be1d3d0709a06ff1ae38d0d5402bc8f0eeac44812e5ec1df4a9e99214eb9a",<font></font>
 "7.1-16": "82ad5fa11820c2889c60f7f748d67aab04400700c581843db0d1e68735327443",<font></font>
 "7.1-24": "c4f590bbcbe329a77c00fea33a3a960063072041489012061ec3a134baba50d6",<font></font>
 "7.1-4": "10acc31def5d6f249b548e01e8ffbaccfd61af0240c17315a7ad393d022c5ca2",<font></font>
 "7.1-6": "65de4a13fc7cf28b4376e65efa31c5c3805e18da4eb01ad0c8b8801f4a10bc16",<font></font>
 "7.1-9": "e3c92c6cff3543d19d0c9a24c72cd3840f8ba3ee00357f997b786e8939efef2f",<font></font>
 "7.2": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "7.2-2": "58958c7fafb7e1a71650bc7bdbb9f5fd634f3545b00ec7d390b2075db511327d",<font></font>
 "7.2-35": "6883d5422f4ec2810e1312c0e3e5a902142e2a8185cd3a1124b459a7c38dc55b",<font></font>
 "7.2-38": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "latest": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e"<font></font>
  }
</pre><br><h4>  </h4><br>    docker     ,   . ,     «rhel7» –  . <br><br><pre> docker pull rhel7
</pre><br>         : <br><br><pre> docker pull registry.access.redhat.com/rhel7:latest
</pre><br>   ,      .    ,  ,      ,   docker images.        ,      ,            ,      «» (manifest.json): <br><br><pre> docker images<font></font>
<font></font>
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE<font></font>
 registry.access.redhat.com/rhel7 latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel6 latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
 registry.access.redhat.com/rhel6/rhel latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
  ...
</pre><br>     ,            .      docker ( ,    )      ,      «rhel7»    . <br><br>         ,    docker     URL.  ,   ,   URL   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/7s/lc/v27slcdbibwowtrbi7ebbv7dutw.png"></div><br><br>  ,    : <br><br><pre> REGISTRY/NAMESPACE/REPOSITORY[:TAG]
</pre><br>  URL    ,   , , .      URL   ,      docker  ,      .  ,    :            : <br><br><pre> docker pull registry.access.redhat.com/rhel7/rhel:latest<font></font>
 docker pull registry.access.redhat.com/rhel7/rhel<font></font>
 docker pull registry.access.redhat.com/rhel7<font></font>
 docker pull rhel7/rhel:latest<font></font>
</pre><br><h4>   </h4><br>   –       .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DockerHub</a>       ,     ,         . <br><br> Red Hat         ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat Federated Registry</a> .     registry.access.redhat.com  .  ,            .    ,  Red Hat   ,     -  : <br><br><pre> registry.access.redhat.com/rhel7/rhel<font></font>
registry.access.redhat.com/openshift3/mongodb-24-rhel7<font></font>
registry.access.redhat.com/rhscl/mongodb-26-rhel7<font></font>
registry.access.redhat.com/rhscl_beta/mongodb-26-rhel7<font></font>
registry-mariadbcorp.rhcloud.com/rhel7/mariadb-enterprise-server:10.0<font></font>
</pre><br>  ,    URL    .           .       fedora,         latest.           : <br><br><pre> docker pull fedora<font></font>
docker pull docker.io/fedora<font></font>
docker pull docker.io/library/fedora:latest<font></font>
</pre><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>     ,    ,       .       , ,    ,     ,   ,    .          ,  ,  ,    . . <br><br>       Bash   Enter, Bash     Linux-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exec()</a> .    ,       ,  docker,   docker          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">clone()</a> .   clone ()     ,          ,  ,  ,  ,    .. <br><br> ,   Linux   -      ,            clone (). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/mp/t7/5ompt7ole83_ucaorlj2fzj3nv4.png"></div><br> <b> …</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416169/">https://habr.com/ru/post/pt416169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416157/index.html">Nos braços de Python (somente mulheres)</a></li>
<li><a href="../pt416159/index.html">Como fomos encarregados de comparar um ouriço</a></li>
<li><a href="../pt416161/index.html">10 razões para não usar o k8s</a></li>
<li><a href="../pt416163/index.html">Aprenda o OpenGL. Lição 5.6 - Mapeamento de paralaxe</a></li>
<li><a href="../pt416167/index.html">Peter Norwig: Aprenda Programação em ... 10 Anos</a></li>
<li><a href="../pt416171/index.html">Testes de UI codificados do Visual Studio: teoria e prática da aplicação em nossa empresa</a></li>
<li><a href="../pt416175/index.html">Resultados da competição de jovens desenvolvedores de aplicativos AR Epson Moverio BT-300</a></li>
<li><a href="../pt416177/index.html">Fórmula de Tupper e implementação do algoritmo em Python</a></li>
<li><a href="../pt416179/index.html">Uma porta que nos recebe pelo nome e se abre apenas para funcionários do departamento</a></li>
<li><a href="../pt416181/index.html">Modulação de amplitude nos dedos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>