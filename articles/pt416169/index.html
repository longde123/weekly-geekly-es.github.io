<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘‡ ğŸ’‡ğŸ¾ ğŸ§€ Contentores para adultos (parte 01): um guia prÃ¡tico de terminologia ğŸ˜ ğŸˆšï¸ ğŸ§‘ğŸ¿â€ğŸ¤â€ğŸ§‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="VocÃª pode perguntar: por que lidar com terminologia se o conceito de contÃªiner parece bastante simples e direto? No entanto, muitas vezes o uso incorr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contentores para adultos (parte 01): um guia prÃ¡tico de terminologia</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416169/">  VocÃª pode perguntar: por que lidar com terminologia se o conceito de contÃªiner parece bastante simples e direto?  No entanto, muitas vezes o uso incorreto de termos cria obstÃ¡culos ao desenvolvimento de contÃªineres.  Por exemplo, as pessoas geralmente pensam que os termos â€œcontÃªineresâ€ e â€œimagensâ€ sÃ£o usados â€‹â€‹de forma intercambiÃ¡vel, embora, de fato, haja importantes diferenÃ§as conceituais entre eles.  Outro exemplo: no mundo dos contÃªineres, um "repositÃ³rio" nÃ£o significa o que vocÃª pensa.  AlÃ©m disso, a tecnologia de contÃªiner Ã© muito mais do que apenas estivador. <br><br><img src="https://habrastorage.org/webt/ze/ev/2e/zeev2e5kfluh5uhoj-bpkgc6km8.png" width="100%"><br><br>  Portanto, sem conhecer a terminologia, serÃ¡ difÃ­cil entender como o docker difere do CRI-O, rkt ou lxc / lxd;  ou avaliar o papel da Open Container Initiative na padronizaÃ§Ã£o de tecnologias de contÃªineres. <br><a name="habracut"></a><br><h3>  1. IntroduÃ§Ã£o </h3><br>  A introduÃ§Ã£o aos contÃªineres Linux Ã© muito simples, mas logo se descobre que essa simplicidade Ã© enganosa.  Isso geralmente acontece assim: depois de passar apenas alguns minutos instalando uma janela de encaixe ou outro mecanismo de contÃªiner, vocÃª jÃ¡ insere seus primeiros comandos.  Apenas alguns minutos - e vocÃª jÃ¡ criou sua primeira imagem do contÃªiner e a colocou em domÃ­nio pÃºblico.  Em seguida, vocÃª costuma seguir para a arquitetura do ambiente de produÃ§Ã£o e, de repente, percebe que, para isso, precisa primeiro lidar com a massa de termos e tecnologias que estÃ£o por trÃ¡s de tudo isso.  Pior, muitos dos termos listados abaixo sÃ£o usados â€‹â€‹de forma intercambiÃ¡vel, o que cria muita confusÃ£o para iniciantes. <br><br><ul><li>  Container </li><li>  Imagem </li><li>  Imagem do container </li><li>  Camada de imagem </li><li>  Registo </li><li>  RepositÃ³rio </li><li>  Tag </li><li>  Imagem Base </li><li>  Imagem da plataforma </li><li>  Camada </li></ul><br>  Tendo dominado a terminologia estabelecida neste documento, vocÃª entenderÃ¡ melhor a base tecnolÃ³gica dos contÃªineres.  AlÃ©m disso, ajudarÃ¡ vocÃª e seus colegas a falarem o mesmo idioma, bem como o design consciente e intencional da arquitetura de ambientes de contÃªineres, de acordo com as especificidades das tarefas que estÃ£o sendo resolvidas.  Por sua vez, do ponto de vista da comunidade de TI e da indÃºstria como um todo, um aumento geral no entendimento das tecnologias de contÃªineres contribui para o surgimento de novas arquiteturas e soluÃ§Ãµes.  Observe que este artigo Ã© destinado a um leitor que jÃ¡ tenha uma idÃ©ia de como executar contÃªineres. <br><br><h3>  Contentores: BÃ¡sico </h3><br>  Antes de prosseguir com a terminologia dos contÃªineres, determinaremos o que Ã©, de fato, o prÃ³prio contÃªiner.  O termo "contÃªiner" significa duas coisas ao mesmo tempo.  Como um programa Linux normal, um contÃªiner pode estar em um dos dois estados: funcionando e nÃ£o funcionando.  No estado inativo, o contÃªiner Ã© um arquivo ou um conjunto de arquivos armazenados no disco.  Ã‰ nesse estado que os termos Imagem do contÃªiner e RepositÃ³rio do contÃªiner se referem.  Quando vocÃª insere o comando de inicializaÃ§Ã£o do contÃªiner, o mecanismo do contÃªiner descompacta os arquivos e metadados necessÃ¡rios e os transfere para o kernel do Linux.  Iniciar um contÃªiner Ã© muito semelhante a iniciar um processo normal do Linux e requer uma chamada de API para o kernel do Linux.  Essa chamada de API geralmente inicia um isolamento adicional e monta uma cÃ³pia dos arquivos que estÃ£o na imagem do contÃªiner.  ApÃ³s o lanÃ§amento do contÃªiner, Ã© apenas um processo do Linux.  O procedimento para iniciar contÃªineres, bem como o formato das imagens dos contÃªineres armazenados em disco, sÃ£o definidos e regulamentados por padrÃµes. <br><br>  Existem vÃ¡rios formatos para imagens de contÃªiner ( <a href="">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Appc</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LXD</a> ), mas o setor estÃ¡ gradualmente se movendo em direÃ§Ã£o a um Ãºnico padrÃ£o da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open Container Initiative</a> , Ã s vezes chamado de Open Containers ou simplesmente OCI.  Esse padrÃ£o define a <a href="">especificaÃ§Ã£o do formato da imagem do contÃªiner</a> , que define o formato do disco para armazenar imagens do contÃªiner, bem como os metadados, que, por sua vez, definem coisas como a arquitetura de hardware e o sistema operacional (Linux, Windows, etc.).  Um Ãºnico formato de imagem em todo o setor Ã© a chave para criar um ecossistema de software que permite que desenvolvedores, projetos de cÃ³digo aberto e fornecedores de software criem imagens compatÃ­veis e vÃ¡rias ferramentas, como assinatura eletrÃ´nica, varredura, montagem, lanÃ§amento, movimentaÃ§Ã£o e gerenciamento de imagens de contÃªiner. <br><br>  AlÃ©m disso, existem vÃ¡rios motores de contÃªiner, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CRI-O</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Railcar</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RKT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LXC</a> .  O mecanismo de contÃªiner obtÃ©m uma imagem do contÃªiner e o transforma em um contÃªiner (isto Ã©, um processo em execuÃ§Ã£o).  O processo de conversÃ£o tambÃ©m Ã© definido pelo padrÃ£o OCI, que inclui uma especificaÃ§Ã£o de tempo de execuÃ§Ã£o do contÃªiner e uma implementaÃ§Ã£o de referÃªncia de tempo de execuÃ§Ã£o chamada RunC, que Ã© um modelo de cÃ³digo aberto que Ã© regulado pela comunidade de desenvolvimento apropriada.  Muitos mecanismos de contÃªiner usam esse modelo para interagir com o kernel host ao criar contÃªineres. <br><br>  As ferramentas que suportam as especificaÃ§Ãµes do <a href="">formato de imagem do contÃªiner</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o ambiente de execuÃ§Ã£o do contÃªiner</a> do padrÃ£o OCI fornecem portabilidade no ecossistema de vÃ¡rias plataformas de contÃªineres, mecanismos de contÃªiner e ferramentas de suporte em vÃ¡rias plataformas em nuvem e arquiteturas locais.  Compreender a terminologia, os padrÃµes e a arquitetura dos sistemas de contÃªineres permitirÃ¡ que vocÃª se comunique com outros especialistas e projete aplicativos e ambientes em contÃªineres escalonÃ¡veis â€‹â€‹e suportados que garantam o uso eficiente dos contÃªineres nos prÃ³ximos anos. <br><br><h3>  VocabulÃ¡rio bÃ¡sico </h3><br><h4>  Imagem do contÃªiner </h4><br>  Em sua definiÃ§Ã£o mais simples, uma imagem de contÃªiner Ã© um arquivo baixado do servidor de registro e usado localmente como um ponto de montagem quando o contÃªiner Ã© iniciado.  Apesar de o termo "imagem de contÃªiner" ser usado com bastante frequÃªncia, ele pode significar coisas diferentes.  O fato Ã© que, embora o Docker, o RKT e atÃ© o LXD funcionem de acordo com o princÃ­pio descrito, ou seja, eles baixam arquivos excluÃ­dos e os executam como contÃªineres, cada uma dessas tecnologias interpreta a imagem do contÃªiner de sua prÃ³pria maneira.  O LXD opera com imagens monolÃ­ticas (camada Ãºnica), enquanto o docker e o RKT usam imagens OCI, que podem conter vÃ¡rias camadas. <br><br>  A rigor, uma imagem de contÃªiner em um servidor de registro estÃ¡ longe de ser um Ãºnico arquivo.  Quando as pessoas usam o termo "imagem do contÃªiner", geralmente significam o repositÃ³rio e um conjunto de vÃ¡rias camadas da imagem do contÃªiner, alÃ©m de metadados que contÃªm informaÃ§Ãµes adicionais sobre essas camadas. <br><br>  AlÃ©m disso, o conceito de uma imagem de contÃªiner implica implicitamente a existÃªncia de um formato para essa imagem. <br><br><h4>  Formato de imagem do contÃªiner </h4><br>  Inicialmente, cada mecanismo de contÃªiner, incluindo LXD, RKT e Docker, tinha seu prÃ³prio formato de imagem.  Alguns desses formatos permitem apenas uma camada, enquanto outros suportam uma estrutura em Ã¡rvore de vÃ¡rias camadas.  Hoje, quase todas as principais ferramentas e mecanismos de contÃªiner mudaram para o formato <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OCI</a> , que determina como as camadas e os metadados devem ser organizados na imagem do contÃªiner.  Em essÃªncia, o formato OCI define uma imagem de contÃªiner que consiste em arquivos tar separados para cada camada e um arquivo manifest.json comum contendo metadados. <br><br>  O padrÃ£o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open Container Initiative (OCI)</a> , originalmente baseado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">formato de imagem Docker V2</a> , combinou com sucesso um grande ecossistema de mecanismos de contÃªiner, plataformas e ferramentas em nuvem (scanners de seguranÃ§a, ferramentas de assinatura, criaÃ§Ã£o e movimentaÃ§Ã£o de contÃªineres) e permite proteger seu investimento em conhecimento e ferramentas <br><br><h4>  Motor para contÃªiner </h4><br>  O mecanismo de contÃªiner Ã© a parte do software que aceita solicitaÃ§Ãµes de usuÃ¡rio, incluindo parÃ¢metros de linha de comando, baixa imagens e, da perspectiva do usuÃ¡rio final, lanÃ§a contÃªineres.  Existem muitos mecanismos de contÃªiner, incluindo docker, RKT, CRI-O e LXD.  AlÃ©m disso, muitas plataformas em nuvem, serviÃ§os de PaaS e plataformas de contÃªineres tÃªm seus prÃ³prios mecanismos que entendem imagens no formato Docker ou OCI.  Ter um padrÃ£o do setor para o formato de imagem garante a interoperabilidade de todas essas plataformas. <br><br>  Ao descer um nÃ­vel, podemos dizer que a maioria dos mecanismos de contÃªineres nÃ£o inicia os contÃªineres, mas atravÃ©s de um tempo de execuÃ§Ã£o compatÃ­vel com OCI, como runc.  Normalmente, um tempo de execuÃ§Ã£o do contÃªiner faz o seguinte: <br><br><ul><li>  Lida com parÃ¢metros, entrada do usuÃ¡rio </li><li>  Manipula os parÃ¢metros passados â€‹â€‹pela API (geralmente o sistema de orquestraÃ§Ã£o de contÃªiner) </li><li>  Baixe imagens de contÃªiner do servidor de registro </li><li>  Descompacta e salva a imagem do contÃªiner em disco usando o Driver GrÃ¡fico (bloco ou arquivo, dependendo do driver) </li><li>  Prepara um ponto de montagem para o contÃªiner, geralmente no armazenamento de copiar na gravaÃ§Ã£o (novamente, em bloco ou arquivo, dependendo do driver) </li><li>  Prepara os metadados que serÃ£o passados â€‹â€‹para o tempo de execuÃ§Ã£o para executar o contÃªiner corretamente usando: <br><ul><li>  ConfiguraÃ§Ãµes padrÃ£o especÃ­ficas implÃ­citas para a imagem do contÃªiner (por exemplo, <a href="">ArchX86</a> ) </li><li>  Entrada do usuÃ¡rio para substituir os valores padrÃ£o contidos na imagem do contÃªiner (por exemplo, CMD, ENTRYPOINT) </li><li>  ParÃ¢metros padrÃ£o especificados pela imagem do contÃªiner (por exemplo, regras <a href="">SECCOM</a> ) </li></ul></li><li>  Invoca o tempo de execuÃ§Ã£o do contÃªiner </li></ul><br><h4>  Container </h4><br>  Os contÃªineres existem nos sistemas operacionais hÃ¡ algum tempo, porque na verdade essa Ã© apenas uma instÃ¢ncia em execuÃ§Ã£o de uma imagem de contÃªiner.  Um contÃªiner Ã© um processo Linux padrÃ£o que geralmente Ã© criado usando a chamada do sistema clone () em vez de fork () ou exec ().  AlÃ©m disso, medidas adicionais de isolamento sÃ£o frequentemente aplicadas a contÃªineres usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cgroups</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SELinux</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">AppArmor</a> . <br><br><h4>  Host do contÃªiner </h4><br>  Um host de contÃªiner Ã© um sistema no qual os processos em contÃªiner sÃ£o executados, geralmente chamados de contÃªineres por simplicidade.  Pode ser, por exemplo, uma mÃ¡quina virtual <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RHEL Atomic Host</a> localizada em uma nuvem pÃºblica ou executando bare metal em um data center corporativo.  Quando a imagem do contÃªiner (em outras palavras, o repositÃ³rio) do servidor de registro Ã© baixada para o host do contÃªiner local, eles dizem que ela cai no cache local. <br><br>  VocÃª pode determinar quais repositÃ³rios sÃ£o sincronizados com o cache local usando o seguinte comando: <br><br><pre>  [root @ rhel7 ~] # imagens do docker -a<font></font>
<font></font>
 ID DE IMAGEM DE REPOSITÃ“RIO IDENTIFICADO TAMANHO VIRTUAL
 registry.access.redhat.com/rhel7 mais recente 6883d5422f4e 3 semanas atrÃ¡s 201,7 MB </pre><br><h4>  Servidor de registro </h4><br>  Um servidor de registro Ã© essencialmente um servidor de arquivos usado para armazenar repositÃ³rios de janela de encaixe.  Como regra, o servidor de registro Ã© especificado pelo nome DNS e, opcionalmente, pelo nÃºmero da porta.  A maioria dos benefÃ­cios do ecossistema docker Ã© impulsionada pela capacidade de baixar e carregar repositÃ³rios nos servidores de registro. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ru/mw/m4/rumwm4l9pkgmpglcy4xdu3rfb5q.png"></div><br>  Se o daemon do docker nÃ£o encontrar uma cÃ³pia do repositÃ³rio no cache local, ele farÃ¡ o download automaticamente do servidor de registro.  Na maioria das distribuiÃ§Ãµes Linux, o daemon docker usarÃ¡ o site docker.io para isso, mas em algumas distribuiÃ§Ãµes ele pode ser configurado da sua maneira.  Por exemplo, o Red Hat Enterprise Linux tenta primeiro fazer o download do registry.access.redhat.com e somente depois do docker.io (Docker Hub). <br><br>  Deve-se enfatizar aqui que o servidor de registro Ã© implicitamente considerado confiÃ¡vel.  Portanto, vocÃª deve decidir quanto confia no conteÃºdo de um registro e, respectivamente, permitir ou negar.  AlÃ©m da seguranÃ§a, hÃ¡ outros aspectos que devem ser abordados com antecedÃªncia, por exemplo, problemas de licenciamento de software ou monitoramento de conformidade.  A simplicidade com a qual o docker permite que os usuÃ¡rios baixem software torna a questÃ£o da confianÃ§a extremamente importante. <br><br>  O Red Hat Enterprise Linux permite que vocÃª configure o registro do docker padrÃ£o.  AlÃ©m disso, o RHEL7 e o RHEL7 Atomic permitem adicionar ou bloquear servidores de registro por meio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">arquivo de configuraÃ§Ã£o</a> : <br><br><pre>  vi / etc / sysconfig / docker
</pre><br>  RHEL7 e RHEL 7 Atomic usam o servidor de registro Red Hat por padrÃ£o: <br><br><pre>  ADD_REGISTRY = '- adicione o registro registry.access.redhat.com'
</pre><br>  Em alguns casos, por motivos de seguranÃ§a, faz sentido bloquear registros pÃºblicos de janelas de encaixe, como o DockerHub: <br><br><pre>  # BLOCK_REGISTRY = '- registro de bloco'
</pre><br>  A Red Hat tambÃ©m oferece seu servidor de registro integrado como parte da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OpenShift Container Platform</a> , bem como o servidor de registro corporativo independente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quay Enterprise</a> e repositÃ³rios em nuvem, pÃºblicos e privados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quay.io.</a> <br><br><h4>  OrquestraÃ§Ã£o de contÃªineres </h4><br>  As pessoas geralmente comeÃ§am instalando um host de contÃªiner e primeiro baixando as imagens de contÃªiner de que precisam.  Em seguida, eles criam suas prÃ³prias imagens e as carregam no servidor de registro para disponibilizar para o restante da equipe.  Depois de algum tempo, Ã© necessÃ¡rio combinar vÃ¡rios contÃªineres para que eles possam ser implantados como uma unidade.  E, finalmente, em algum momento, essas unidades devem fazer parte do transportador de produÃ§Ã£o (development-QA-production).  Ã‰ assim que as pessoas geralmente percebem que precisam de um sistema de orquestraÃ§Ã£o. <br><br>  <b>O sistema de orquestraÃ§Ã£o de contÃªiner implementa apenas duas coisas:</b> <br><br><ol><li>  Despachar dinamicamente cargas de contÃªiner entre computadores de cluster (geralmente chamado de "computaÃ§Ã£o distribuÃ­da") </li><li>  Fornece um arquivo de descriÃ§Ã£o de aplicativo padrÃ£o (kube yaml, composiÃ§Ã£o do docker, etc.) </li></ol><br>  Essas duas coisas realmente oferecem uma sÃ©rie de benefÃ­cios: <br><br><ol><li>  A capacidade de gerenciar os contÃªineres que compÃµem o aplicativo, independentemente um do outro, o que permite resolver efetivamente as seguintes tarefas: <br><ul><li>  EliminaÃ§Ã£o de grandes clusters de hosts de contÃªiner </li><li>  Falha no nÃ­vel de contÃªineres individuais (nÃ£o hÃ¡ mais processos de resposta, exaustÃ£o de memÃ³ria) </li><li>  Failover no nÃ­vel do host do contÃªiner (unidades, rede, reinicializaÃ§Ã£o) </li><li>  Failover no nÃ­vel do mecanismo do contÃªiner (dano, reinicializaÃ§Ã£o) </li><li>  Escalonamento individual de contÃªineres para cima e para baixo </li></ul></li><li>  FÃ¡cil de implantar novas instÃ¢ncias do mesmo aplicativo em novos ambientes, tanto na nuvem quanto na tradicional, por exemplo: <br><ul><li>  Em mÃ¡quinas de desenvolvedor controladas por um sistema de orquestraÃ§Ã£o </li><li>  Em um ambiente de desenvolvimento compartilhado em um espaÃ§o para nome privado </li><li>  Em um ambiente de desenvolvimento comum em um espaÃ§o para nome pÃºblico interno para garantir a visibilidade e o desempenho do teste </li><li>  No ambiente interno do controle de qualidade </li><li>  Em um ambiente de carga de teste fornecido dinamicamente e revogado na nuvem </li><li>  Em um ambiente de referÃªncia para verificar a compatibilidade com o ambiente de produÃ§Ã£o </li><li>  No ambiente de produÃ§Ã£o </li><li>  Em um ambiente de recuperaÃ§Ã£o de desastre </li><li>  Em um novo ambiente de produÃ§Ã£o contendo hosts de contÃªiner atualizados, mecanismos de contÃªiner ou ferramentas de orquestraÃ§Ã£o </li><li>  No novo ambiente de produÃ§Ã£o, que nÃ£o Ã© diferente do principal, mas localizado em uma regiÃ£o diferente </li></ul></li></ol><br>  Comunidades de cÃ³digo aberto e fornecedores de software oferecem muitas ferramentas diferentes de orquestraÃ§Ã£o.  Inicialmente, as trÃªs grandes ferramentas incluÃ­am <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Swarm</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mesos</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kubernetes</a> , mas hoje o Kubernetes se tornou o padrÃ£o do setor, porque atÃ© o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Docker</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mesosphere</a> anunciaram seu apoio, sem mencionar quase todos os principais provedores de serviÃ§os.  No entanto, se vocÃª estiver procurando por um sistema de orquestraÃ§Ã£o corporativo, recomendamos que vocÃª analise mais de perto o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat OpenShift</a> . <br><br><h3>  DicionÃ¡rio AvanÃ§ado </h3><br><h4>  Tempo de execuÃ§Ã£o do contÃªiner </h4><br>  O tempo de execuÃ§Ã£o do contÃªiner Ã© um componente de baixo nÃ­vel que normalmente Ã© usado como parte de um mecanismo de contÃªiner, mas tambÃ©m pode ser usado manualmente para testar contÃªineres.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O padrÃ£o OCI</a> define uma implementaÃ§Ã£o de referÃªncia do tempo de execuÃ§Ã£o conhecido como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">runc</a> .  Essa Ã© a implementaÃ§Ã£o mais usada, mas existem outros <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempos de execuÃ§Ã£o</a> compatÃ­veis com OCI, como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">crun</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">railcar</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">katacontainers</a> .  Docker, CRI-O e muitos outros mecanismos de contÃªiner usam runc. <br><br>  O tempo de execuÃ§Ã£o do contÃªiner Ã© responsÃ¡vel pelos seguintes itens: <br><br><ul><li>  ObtÃ©m o ponto de montagem do contÃªiner fornecido pelo mecanismo de contÃªiner (para teste, poderia ser apenas um diretÃ³rio) </li><li>  ObtÃ©m os metadados do contÃªiner fornecidos pelo mecanismo de contÃªiner (durante o teste, pode ser um arquivo config.json montado manualmente) </li><li>  Comunica-se com o kernel do SO para iniciar processos em contÃªiner (via chamada de sistema clone) </li><li>  Configura cgroups </li><li>  Configura a polÃ­tica do SELinux </li><li>  Configura regras da armadura de aplicativo </li></ul><br>  Um pouco de digressÃ£o histÃ³rica: quando o mecanismo do Docker apareceu pela primeira vez, ele usou o LXC como um ambiente de tempo de execuÃ§Ã£o.  Os desenvolvedores do Docker entÃ£o criaram sua prÃ³pria biblioteca para executar contÃªineres chamados libcontainer.  Foi escrito no idioma Golang e tornou-se parte do mecanismo do Docker.  ApÃ³s o estabelecimento da organizaÃ§Ã£o OCI, o Docker introduziu o cÃ³digo-fonte libcontainer nesse projeto e lanÃ§ou esta biblioteca como um utilitÃ¡rio separado chamado runc, que se tornou a implementaÃ§Ã£o de referÃªncia do tempo de execuÃ§Ã£o do contÃªiner dentro do padrÃ£o OCI e Ã© usado em outros mecanismos de contÃªiner, como o CRI-O .  Runc Ã© um utilitÃ¡rio muito simples que apenas espera que um ponto de montagem (diretÃ³rio) e metadados (config.json) sejam passados â€‹â€‹para ele.  Mais informaÃ§Ãµes sobre runc podem ser encontradas <a href="">aqui</a> . <br><br>  Para um entendimento mais aprofundado, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NoÃ§Ãµes bÃ¡sicas sobre padrÃµes de contÃªiner</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tempo de execuÃ§Ã£o</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">contÃªiner</a> . <br><br><h4>  Camadas de imagem </h4><br>  Os repositÃ³rios sÃ£o frequentemente referidos como imagens ou imagens de contÃªineres, embora na verdade os repositÃ³rios consistam em uma ou mais camadas.  As camadas de imagem no repositÃ³rio sÃ£o interconectadas pelos relacionamentos pai-filho e cada camada de imagem contÃ©m diferenÃ§as da camada pai. <br><br>  Vejamos as camadas do repositÃ³rio no host do contÃªiner local.  Desde o inÃ­cio da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">versÃ£o 1.7, o Docker nÃ£o possui uma ferramenta</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interna</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">para exibir camadas de imagem</a> no repositÃ³rio local (mas existem ferramentas para registros online), usaremos o utilitÃ¡rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dockviz</a> .  Observe que cada camada possui uma tag e um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">identificador exclusivo universal (UUID)</a> .  Para visualizar UUIDs abreviados que geralmente sÃ£o Ãºnicos na mesma mÃ¡quina, usamos o seguinte comando (se vocÃª precisar de um UUID completo, use o mesmo comando com a opÃ§Ã£o -no-trunc): <br><br>  docker run --rm --privileged -v /var/run/docker.sock:/var/run/docker.sock nate / dockviz images -t <br><br><pre>  â”œâ”€2332d8973c93 Tamanho virtual: 187.7 MB
  Virtual â””â”€ea358092da77 Tamanho virtual: 187,9 MB
  â”‚ â””â”€a467a7c6794f Tamanho virtual: 187,9 MB
  â”‚ â””â”€ca4d7b1b9a51 Tamanho virtual: 187,9 MB
  â”‚ â””â”€4084976dd96d Tamanho virtual: 384,2 MB
  Virtual â””â”€943128b20e28 Tamanho virtual: 386,7 MB
  Virtual â””â”€db20cc018f56 Tamanho virtual: 386,7 MB
  Virtual â””â”€45b3c59b9130 Tamanho virtual: 398.2 MB
  Virtual â””â”€91275de1a5d7 Tamanho virtual: 422,8 MB
  Virtual â””â”€e7a97058d51f Tamanho virtual: 422,8 MB
  Virtual â””â”€d5c963edfcb2 Tamanho virtual: 422.8 MB
  Virtual â””â”€5cfc0ce98e02 Tamanho virtual: 422,8 MB
  Virtual â””â”€7728f71a4bcd Tamanho virtual: 422,8 MB
  Virtual â””â”€0542f67da01b Tamanho virtual: 422,8 MB Tags: docker.io/registry:latest
</pre><br>  Como vocÃª pode ver, o repositÃ³rio docker.io/registry na verdade consiste em vÃ¡rias camadas.  No entanto, mais importante, o usuÃ¡rio pode, em princÃ­pio, "iniciar" o contÃªiner a partir de qualquer etapa dessa escada, por exemplo, digitando o comando abaixo (estÃ¡ completamente correto, mas ninguÃ©m pode garantir que foi testado ou que funcionarÃ¡ corretamente).  Como regra, o coletor de imagens identifica (cria nomes) as camadas que devem ser usadas como ponto de partida: <br><br><pre>  docker run -it 45b3c59b9130 bash
</pre><br>  Os repositÃ³rios sÃ£o organizados de maneira semelhante, porque sempre que o coletor cria uma nova imagem, as diferenÃ§as sÃ£o salvas como outra camada.  Existem duas maneiras principais de criar novas camadas no repositÃ³rio.  Primeiro, ao criar uma imagem manualmente, cada confirmaÃ§Ã£o de alteraÃ§Ã£o cria uma nova camada.  Se o coletor criar uma imagem usando um arquivo Docker, cada diretiva no arquivo criarÃ¡ uma nova camada.  Portanto, Ã© sempre Ãºtil poder ver o que mudou no repositÃ³rio entre as camadas. <br><br><h4>  Tags </h4><br>  Embora o prÃ³prio usuÃ¡rio possa especificar a camada inicial para montar e iniciar o contÃªiner no repositÃ³rio, ele nÃ£o precisa fazer isso.  Quando o coletor de imagens cria um novo repositÃ³rio, eles geralmente marcam as camadas mais adequadas para essa funÃ§Ã£o.  Esses marcadores sÃ£o chamados de tags e representam uma ferramenta com a qual o coletor de imagens pode informar ao consumidor de imagens quais camadas sÃ£o melhor usadas.  Normalmente, as tags sÃ£o usadas para indicar versÃµes de software em um repositÃ³rio.   OCI,  -       ,          .      ,         . <br><br>  ,     â€“ latest,     ,      .       ,     ,      . <br><br>       ,    ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> jq</a>    ): <br><br><pre> curl -s registry.access.redhat.com/v1/repositories/rhel7/tags | jq<font></font>
 {<font></font>
 "7.0-21": "e1f5733f050b2488a17b7630cb038bfbea8b7bdfa9bdfb99e63a33117e28d02f",<font></font>
 "7.0-23": "bef54b8f8a2fdd221734f1da404d4c0a7d07ee9169b1443a338ab54236c8c91a",<font></font>
 "7.0-27": "8e6704f39a3d4a0c82ec7262ad683a9d1d9a281e3c1ebbb64c045b9af39b3940",<font></font>
 "7.1-11": "d0a516b529ab1adda28429cae5985cab9db93bfd8d301b3a94d22299af72914b",<font></font>
 "7.1-12": "275be1d3d0709a06ff1ae38d0d5402bc8f0eeac44812e5ec1df4a9e99214eb9a",<font></font>
 "7.1-16": "82ad5fa11820c2889c60f7f748d67aab04400700c581843db0d1e68735327443",<font></font>
 "7.1-24": "c4f590bbcbe329a77c00fea33a3a960063072041489012061ec3a134baba50d6",<font></font>
 "7.1-4": "10acc31def5d6f249b548e01e8ffbaccfd61af0240c17315a7ad393d022c5ca2",<font></font>
 "7.1-6": "65de4a13fc7cf28b4376e65efa31c5c3805e18da4eb01ad0c8b8801f4a10bc16",<font></font>
 "7.1-9": "e3c92c6cff3543d19d0c9a24c72cd3840f8ba3ee00357f997b786e8939efef2f",<font></font>
 "7.2": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "7.2-2": "58958c7fafb7e1a71650bc7bdbb9f5fd634f3545b00ec7d390b2075db511327d",<font></font>
 "7.2-35": "6883d5422f4ec2810e1312c0e3e5a902142e2a8185cd3a1124b459a7c38dc55b",<font></font>
 "7.2-38": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e",<font></font>
 "latest": "6c3a84d798dc449313787502060b6d5b4694d7527d64a7c99ba199e3b2df834e"<font></font>
  }
</pre><br><h4>  </h4><br>    docker     ,   . ,     Â«rhel7Â» â€“  . <br><br><pre> docker pull rhel7
</pre><br>         : <br><br><pre> docker pull registry.access.redhat.com/rhel7:latest
</pre><br>   ,      .    ,  ,      ,   docker images.        ,      ,            ,      Â«Â» (manifest.json): <br><br><pre> docker images<font></font>
<font></font>
REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE<font></font>
 registry.access.redhat.com/rhel7 latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel latest 6883d5422f4e 4 weeks ago 201.7 MB<font></font>
 registry.access.redhat.com/rhel6 latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
 registry.access.redhat.com/rhel6/rhel latest 05c3d56ba777 4 weeks ago 166.1 MB<font></font>
  ...
</pre><br>     ,            .      docker ( ,    )      ,      Â«rhel7Â»    . <br><br>         ,    docker     URL.  ,   ,   URL   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v2/7s/lc/v27slcdbibwowtrbi7ebbv7dutw.png"></div><br><br>  ,    : <br><br><pre> REGISTRY/NAMESPACE/REPOSITORY[:TAG]
</pre><br>  URL    ,   , , .      URL   ,      docker  ,      .  ,    :            : <br><br><pre> docker pull registry.access.redhat.com/rhel7/rhel:latest<font></font>
 docker pull registry.access.redhat.com/rhel7/rhel<font></font>
 docker pull registry.access.redhat.com/rhel7<font></font>
 docker pull rhel7/rhel:latest<font></font>
</pre><br><h4>   </h4><br>   â€“       .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">DockerHub</a>       ,     ,         . <br><br> Red Hat         ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Red Hat Federated Registry</a> .     registry.access.redhat.com  .  ,            .    ,  Red Hat   ,     -  : <br><br><pre> registry.access.redhat.com/rhel7/rhel<font></font>
registry.access.redhat.com/openshift3/mongodb-24-rhel7<font></font>
registry.access.redhat.com/rhscl/mongodb-26-rhel7<font></font>
registry.access.redhat.com/rhscl_beta/mongodb-26-rhel7<font></font>
registry-mariadbcorp.rhcloud.com/rhel7/mariadb-enterprise-server:10.0<font></font>
</pre><br>  ,    URL    .           .       fedora,         latest.           : <br><br><pre> docker pull fedora<font></font>
docker pull docker.io/fedora<font></font>
docker pull docker.io/library/fedora:latest<font></font>
</pre><br><h4>    </h4><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>     ,    ,       .       , ,    ,     ,   ,    .          ,  ,  ,    . . <br><br>       Bash   Enter, Bash     Linux-     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exec()</a> .    ,       ,  docker,   docker          ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">clone()</a> .   clone ()     ,          ,  ,  ,  ,    .. <br><br> ,   Linux   -      ,            clone (). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/mp/t7/5ompt7ole83_ucaorlj2fzj3nv4.png"></div><br> <b> â€¦</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt416169/">https://habr.com/ru/post/pt416169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt416157/index.html">Nos braÃ§os de Python (somente mulheres)</a></li>
<li><a href="../pt416159/index.html">Como fomos encarregados de comparar um ouriÃ§o</a></li>
<li><a href="../pt416161/index.html">10 razÃµes para nÃ£o usar o k8s</a></li>
<li><a href="../pt416163/index.html">Aprenda o OpenGL. LiÃ§Ã£o 5.6 - Mapeamento de paralaxe</a></li>
<li><a href="../pt416167/index.html">Peter Norwig: Aprenda ProgramaÃ§Ã£o em ... 10 Anos</a></li>
<li><a href="../pt416171/index.html">Testes de UI codificados do Visual Studio: teoria e prÃ¡tica da aplicaÃ§Ã£o em nossa empresa</a></li>
<li><a href="../pt416175/index.html">Resultados da competiÃ§Ã£o de jovens desenvolvedores de aplicativos AR Epson Moverio BT-300</a></li>
<li><a href="../pt416177/index.html">FÃ³rmula de Tupper e implementaÃ§Ã£o do algoritmo em Python</a></li>
<li><a href="../pt416179/index.html">Uma porta que nos recebe pelo nome e se abre apenas para funcionÃ¡rios do departamento</a></li>
<li><a href="../pt416181/index.html">ModulaÃ§Ã£o de amplitude nos dedos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>