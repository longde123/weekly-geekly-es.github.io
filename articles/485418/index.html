<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚵🏼 🌍 👨🏿‍🤝‍👨🏼 PHPUnit. "¿Cómo pruebo mi maldito controlador?", O prueba de dudas 🎗️ 🌏 🌿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr 



 Sí, esta es otra publicación sobre el tema de las pruebas. Parece que aquí ya es posible discutir? Todos los que lo necesitan, escriben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "¿Cómo pruebo mi maldito controlador?", O prueba de dudas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Hola Habr <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="imagen"><br><br>  Sí, esta es otra publicación sobre el tema de las pruebas.  Parece que aquí ya es posible discutir?  Todos los que lo necesitan, escriben exámenes, quienes no lo necesitan, no escriben, ¡todos están felices!  El hecho es que la mayoría de las publicaciones sobre pruebas unitarias tienen ... cómo ofender a nadie ... ¡ejemplos idiotas!  No, de verdad!  Hoy intentaré arreglarlo.  Pido gato. <br><a name="habracut"></a><br>  Por lo tanto, buscar rápidamente en Google sobre el tema de las pruebas encuentra muchos artículos, que en su mayoría se dividen en dos categorías: <br><br>  1) La felicidad de un redactor.  Primero vemos una larga introducción, luego la historia de las pruebas unitarias en la Antigua Rusia, luego diez trucos de vida con pruebas, y al final un ejemplo.  Con pruebas de código como esta: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  Y no estoy bromeando en este momento.  Realmente vi artículos con una "calculadora" como guía de estudio.  Sí, sí, entiendo que para empezar es necesario simplificar todo, abstracciones, de ida y vuelta ... ¡Pero aquí es donde todo termina!  Y luego terminar el búho, como dicen <br><br>  2) Ejemplos excesivamente sofisticados.  Y escribamos una prueba, y métala en Gitlab CI, y luego la repararemos automáticamente si la prueba pasa, y aplicaremos Infección PHP a las pruebas, pero conectaremos todo a Hudson.  Y así sucesivamente en ese estilo.  Parece ser útil, pero parece que no es lo que estás buscando.  Pero solo desea aumentar ligeramente la estabilidad de su proyecto.  Y todas estas continuidades, bueno, no todas a la vez. <br><br>  Como resultado, la gente duda: "¿Pero lo necesito?"  Yo, a su vez, quiero tratar de explicar más claramente sobre las pruebas.  Y haga una reserva de inmediato: soy desarrollador, no soy probador.  Estoy seguro de que yo mismo no sé mucho, y mi primera palabra en mi vida no fue la palabra "mok".  ¡Nunca he trabajado en TDD!  Pero estoy seguro de que incluso mi nivel actual de habilidades me ha permitido cubrir varios proyectos con pruebas, y estas mismas pruebas ya han detectado una docena de errores.  Y si me ayudó, entonces podría ayudar a alguien más.  Algunos errores atrapados serían difíciles de atrapar manualmente. <br><br>  Para comenzar, un breve programa educativo en el formato de preguntas y respuestas: <br><br>  P: ¿Tengo que usar algún tipo de marco?  ¿Qué pasa si tengo Yii?  ¿Qué pasa si Kohana?  ¿Qué pasa si% one_more_framework_name%? <br>  R: No, PHPUnit es un marco de prueba independiente, incluso puede atornillarlo al código heredado en un marco de fabricación propia. <br><br>  P: Y ahora paso rápidamente por el sitio con mis manos, y es normal.  ¿Por qué lo necesito? <br>  R: La "ejecución" de varias docenas de pruebas dura varios segundos.  Las pruebas automáticas siempre son más rápidas que las manuales, y con pruebas de alta calidad también es más confiable, ya que cubre todos los escenarios. <br><br>  P: Tengo un código heredado con funciones de 2000 líneas.  ¿Puedo probar esto? <br>  A: sí y no.  En teoría, sí, cualquier código puede ser cubierto con una prueba.  En la práctica, el código debe escribirse con una base para futuras pruebas.  Una función de línea 2000 tendrá demasiadas dependencias, ramas, casos de borde.  Puede resultar que lo cubra todo al final, pero lo más probable es que te lleve un tiempo inaceptablemente largo.  Cuanto mejor sea el código, más fácil será probarlo.  Cuanto mejor se respete la responsabilidad individual, más fáciles serán las pruebas.  Para probar los proyectos antiguos con mayor frecuencia, primero debe refactorizarlos fríamente. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="imagen"><br><br>  P: Tengo métodos (funciones) muy simples, ¿qué hay para probar?  ¡Todo es confiable allí, no hay margen de error! <br>  R: Debe entenderse que no prueba la implementación correcta de la función (si no tiene TDD), simplemente "arregla" su estado actual de trabajo.  En el futuro, cuando necesite cambiarlo, puede determinar rápidamente si rompió su comportamiento utilizando la prueba.  Ejemplo: hay una función que valida el correo electrónico.  Ella lo hace un habitual. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Todo su código espera que si pasa un correo electrónico válido a esta función, se devolverá verdadero.  Una serie de correos electrónicos válidos también es cierto.  Una matriz con al menos una dirección de correo electrónico no válida es falsa.  Bueno, etc., el código es claro.  Pero llegó el día y decidiste reemplazar la monstruosa temporada regular con una API externa.  Pero, ¿cómo garantizar que la función reescrita no haya cambiado el principio de funcionamiento?  ¿De repente no maneja bien la matriz?  ¿O volverá no booleano?  Y las pruebas pueden mantener esto bajo control.  Una prueba bien escrita indicará inmediatamente un comportamiento de la función diferente al esperado. <br><br>  P: ¿Cuándo comenzaré a ver algo de sentido en las pruebas? <br>  R: En primer lugar, tan pronto como cubra una parte significativa del código.  Cuanto más cercana sea la cobertura al 100%, más confiables serán las pruebas.  En segundo lugar, tan pronto como tenga que hacer cambios globales, o cambios en la parte compleja del código.  Las pruebas pueden detectar problemas que pueden perderse fácilmente manualmente (casos límite).  En tercer lugar, al escribir las pruebas ellos mismos!  A menudo hay una situación en la que escribir una prueba revela fallas en el código que no son visibles a primera vista. <br><br>  P: Bueno, tengo un sitio web en laravel.  El sitio no es una función, es una montaña de código de mierda.  ¿Cómo probar aquí? <br>  A: Esto es lo que se discutirá más adelante.  En resumen: probamos por separado los métodos de los controladores, separamos el middleware, separamos los servicios, etc. <br><br>  Una de las ideas de las pruebas unitarias es aislar la sección de código probada.  Cuanto menos código pruebe con una prueba, mejor.  Veamos un ejemplo lo más cercano posible a la vida real: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Este es un método muy típico para iniciar sesión en el sistema en pequeños proyectos.  Todo lo que esperamos son los mensajes de error correctos y el correo electrónico enviado en caso de un inicio de sesión exitoso.  ¿Cómo probar este método?  Primero, necesita identificar dependencias externas.  En nuestro caso, hay dos de ellos: $ userService y $ emailService.  Se pasan a través del constructor de clase, lo que facilita enormemente nuestra tarea.  Pero, como se mencionó anteriormente, cuanto menos código probamos en una pasada, mejor. <br><br>  La emulación, sustitución de objetos se llama mokanem (del inglés. Mock object, literalmente: "object-parody").  Nadie se molesta en escribir tales objetos manualmente, pero todo ya se ha inventado antes que nosotros, por lo que una biblioteca tan maravillosa como <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> viene al rescate.  Creemos mokas para los servicios. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Ahora cree el objeto $ request.  Para comenzar, probaremos la lógica de verificar los campos de inicio de sesión y contraseña.  Queremos asegurarnos de que si no hay ninguno, nuestro método manejará correctamente este caso y devolverá el mensaje deseado (!). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Nada complicado, ¿verdad?  Creamos stubs para los parámetros de clase necesarios, creamos una instancia de la clase deseada y "extrajimos" el método deseado, pasando una solicitud deliberadamente incorrecta.  Tengo una respuesta  ¿Pero cómo comprobarlo ahora?  Esta es la parte más importante de la prueba: la llamada afirmación.  PHPUnit tiene docenas de <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">aserciones</a> listas para <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">usar</a> .  Solo usa uno de ellos. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Esta prueba garantiza lo siguiente: si el argumento de inicio de sesión llega al objeto del método que no tiene el campo de inicio de sesión o contraseña, el método devolverá la cadena "Error de autenticación".  Eso, en general, es todo.  Tan simple, pero tan útil, porque ahora podemos editar el método de inicio de sesión sin temor a romper algo.  Nuestro frontend puede estar seguro de que si sucede algo, recibirá un error de este tipo.  Y si alguien interrumpe este comportamiento (por ejemplo, decide cambiar el texto del error), ¡la prueba lo indicará de inmediato!  Agregamos los cheques restantes para cubrir tantos escenarios posibles como sea posible. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Observe los métodos shouldReceive y andReturn?  Nos permiten crear métodos en trozos que devuelven solo lo que necesitamos.  ¿Necesita probar el error de contraseña incorrecta?  Escribimos un stub $ userService que siempre devuelve la contraseña incorrecta.  Y eso es todo. <br><br>  Y qué hay de las dependencias, preguntas.  Luego los "ahogamos", ¿y si se rompen?  Pero esto es exactamente para lo que es la máxima cobertura de código con pruebas.  No verificaremos el funcionamiento de estos servicios en el contexto del inicio de sesión; lo probaremos con la esperanza de que funcionen correctamente.  Y luego escribimos las mismas pruebas aisladas para estos servicios.  Y luego prueba sus dependencias.  Y así sucesivamente.  Como resultado, cada prueba individual garantiza <b>solo el</b> funcionamiento correcto de un pequeño fragmento de código, siempre que todas sus dependencias funcionen correctamente.  Y dado que todas las dependencias también están cubiertas por pruebas, su funcionamiento correcto también está garantizado.  Como resultado, cualquier cambio en el sistema que rompa la lógica del trabajo de incluso el código más pequeño aparecerá inmediatamente en una prueba en particular.  Cómo ejecutar específicamente la ejecución de prueba: no lo diré, la documentación en PHPUnit es bastante buena.  Y en Laravel, por ejemplo, es suficiente ejecutar vendor / bin / phpunit desde la raíz del proyecto para ver un mensaje como este <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="imagen">  - Todas las pruebas fueron exitosas.  O algo como esto <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="imagen">  Una de las siete afirmaciones falló. <br><br>  "Esto, por supuesto, es genial, pero ¿qué pasa con esto que no puedo tener en mis manos?", Preguntas.  Y imaginemos el siguiente código para esto <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Vemos un modelo simplificado de trabajo con una API externa.  La función utiliza alguna clase para trabajar con la API y, en caso de error, devuelve nulo.  Si, al usar esta función, quedamos nulos, deberíamos "aumentar el pánico" (enviar un mensaje a la holgura, o enviar un correo electrónico al desarrollador, o arrojar un error en la kibana. Sí, un montón de opciones).  Todo parece ser simple, ¿verdad?  Pero imagine que después de algún tiempo otro desarrollador decidió "arreglar" esta función.  Decidió que regresar nulo es el siglo pasado, y debería lanzar una excepción. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  ¡E incluso reescribió todas las secciones del código donde se llamó esta función!  Todos menos uno.  El lo extrañaba.  Distraído, cansado, simplemente equivocado, pero nunca se sabe.  El hecho es que una pieza de código todavía está esperando el viejo comportamiento de la función.  Y PHP no es Java para nosotros: no obtendremos un error de compilación debido a que la función de lanzamiento no está envuelta en try-catch.  Como resultado, en uno de los 100 escenarios para usar el sitio, en el caso de un bloqueo de API, no recibiremos un mensaje del sistema.  Además, con las pruebas manuales, lo más probable es que no capturemos esta versión del evento.  La API es externa, no depende de nosotros, funciona bien, y lo más probable es que no la tengamos en caso de falla de la API y manejo incorrecto de excepciones.  Pero si tenemos pruebas, captarán este caso muy bien, porque la clase ExternalApi está "amortiguada" en varias pruebas, y emula tanto el comportamiento normal como el bloqueo.  Y la próxima prueba caerá <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Esta información es realmente suficiente.  Si no tienes fideos heredados, después de 20-30 minutos puedes escribir tu primera prueba.  Y unas semanas más tarde, para aprender algo nuevo, genial, vuelva a los comentarios en esta publicación y escriba qué autor el govnokoder no conoce% framework_name%, y escribe malas pruebas, pero debe hacer% this_way%.  Y estaré muy feliz en ese caso.  Esto significará que mi objetivo se ha logrado: ¡alguien más descubrió las pruebas por sí mismo y aumentó un poco el nivel general de profesionalismo en nuestro campo! <br><br>  La crítica razonada es bienvenida. </div></div><p>Source: <a href="https://habr.com/ru/post/485418/">https://habr.com/ru/post/485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485394/index.html">Como nació la infraestructura de Internet</a></li>
<li><a href="../485396/index.html">Control de salud del equipo: medición de la salud del equipo</a></li>
<li><a href="../485398/index.html">PostgreSQL Antipatterns: hit dictionary on heavy JOIN</a></li>
<li><a href="../485404/index.html">Nos damos cuenta del efecto visual de la película "The Matrix"</a></li>
<li><a href="../485416/index.html">Formas prácticas de mapear datos en Kotlin</a></li>
<li><a href="../485424/index.html">Cómo enseño a los niños Python</a></li>
<li><a href="../485426/index.html">Coches en los Países Bajos: estadísticas e información para 2019</a></li>
<li><a href="../485428/index.html">El misterioso programa LyX. Parte 5</a></li>
<li><a href="../485430/index.html">Editor de texto simple para múltiples usuarios con encriptación de extremo a extremo</a></li>
<li><a href="../485438/index.html">Prueba de componentes de la interfaz de usuario de React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>