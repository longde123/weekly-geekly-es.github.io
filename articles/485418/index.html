<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöµüèº üåç üë®üèø‚Äçü§ù‚Äçüë®üèº PHPUnit. "¬øC√≥mo pruebo mi maldito controlador?", O prueba de dudas üéóÔ∏è üåè üåø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Habr 



 S√≠, esta es otra publicaci√≥n sobre el tema de las pruebas. Parece que aqu√≠ ya es posible discutir? Todos los que lo necesitan, escriben...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PHPUnit. "¬øC√≥mo pruebo mi maldito controlador?", O prueba de dudas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485418/">  Hola Habr <br><br><img src="https://habrastorage.org/webt/do/li/as/doliasx6rmfzgqhvfc-7jdazq-w.jpeg" alt="imagen"><br><br>  S√≠, esta es otra publicaci√≥n sobre el tema de las pruebas.  Parece que aqu√≠ ya es posible discutir?  Todos los que lo necesitan, escriben ex√°menes, quienes no lo necesitan, no escriben, ¬°todos est√°n felices!  El hecho es que la mayor√≠a de las publicaciones sobre pruebas unitarias tienen ... c√≥mo ofender a nadie ... ¬°ejemplos idiotas!  No, de verdad!  Hoy intentar√© arreglarlo.  Pido gato. <br><a name="habracut"></a><br>  Por lo tanto, buscar r√°pidamente en Google sobre el tema de las pruebas encuentra muchos art√≠culos, que en su mayor√≠a se dividen en dos categor√≠as: <br><br>  1) La felicidad de un redactor.  Primero vemos una larga introducci√≥n, luego la historia de las pruebas unitarias en la Antigua Rusia, luego diez trucos de vida con pruebas, y al final un ejemplo.  Con pruebas de c√≥digo como esta: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Calculator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($a, $b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $a + $b; } }</code> </pre> <br>  Y no estoy bromeando en este momento.  Realmente vi art√≠culos con una "calculadora" como gu√≠a de estudio.  S√≠, s√≠, entiendo que para empezar es necesario simplificar todo, abstracciones, de ida y vuelta ... ¬°Pero aqu√≠ es donde todo termina!  Y luego terminar el b√∫ho, como dicen <br><br>  2) Ejemplos excesivamente sofisticados.  Y escribamos una prueba, y m√©tala en Gitlab CI, y luego la repararemos autom√°ticamente si la prueba pasa, y aplicaremos Infecci√≥n PHP a las pruebas, pero conectaremos todo a Hudson.  Y as√≠ sucesivamente en ese estilo.  Parece ser √∫til, pero parece que no es lo que est√°s buscando.  Pero solo desea aumentar ligeramente la estabilidad de su proyecto.  Y todas estas continuidades, bueno, no todas a la vez. <br><br>  Como resultado, la gente duda: "¬øPero lo necesito?"  Yo, a su vez, quiero tratar de explicar m√°s claramente sobre las pruebas.  Y haga una reserva de inmediato: soy desarrollador, no soy probador.  Estoy seguro de que yo mismo no s√© mucho, y mi primera palabra en mi vida no fue la palabra "mok".  ¬°Nunca he trabajado en TDD!  Pero estoy seguro de que incluso mi nivel actual de habilidades me ha permitido cubrir varios proyectos con pruebas, y estas mismas pruebas ya han detectado una docena de errores.  Y si me ayud√≥, entonces podr√≠a ayudar a alguien m√°s.  Algunos errores atrapados ser√≠an dif√≠ciles de atrapar manualmente. <br><br>  Para comenzar, un breve programa educativo en el formato de preguntas y respuestas: <br><br>  P: ¬øTengo que usar alg√∫n tipo de marco?  ¬øQu√© pasa si tengo Yii?  ¬øQu√© pasa si Kohana?  ¬øQu√© pasa si% one_more_framework_name%? <br>  R: No, PHPUnit es un marco de prueba independiente, incluso puede atornillarlo al c√≥digo heredado en un marco de fabricaci√≥n propia. <br><br>  P: Y ahora paso r√°pidamente por el sitio con mis manos, y es normal.  ¬øPor qu√© lo necesito? <br>  R: La "ejecuci√≥n" de varias docenas de pruebas dura varios segundos.  Las pruebas autom√°ticas siempre son m√°s r√°pidas que las manuales, y con pruebas de alta calidad tambi√©n es m√°s confiable, ya que cubre todos los escenarios. <br><br>  P: Tengo un c√≥digo heredado con funciones de 2000 l√≠neas.  ¬øPuedo probar esto? <br>  A: s√≠ y no.  En teor√≠a, s√≠, cualquier c√≥digo puede ser cubierto con una prueba.  En la pr√°ctica, el c√≥digo debe escribirse con una base para futuras pruebas.  Una funci√≥n de l√≠nea 2000 tendr√° demasiadas dependencias, ramas, casos de borde.  Puede resultar que lo cubra todo al final, pero lo m√°s probable es que te lleve un tiempo inaceptablemente largo.  Cuanto mejor sea el c√≥digo, m√°s f√°cil ser√° probarlo.  Cuanto mejor se respete la responsabilidad individual, m√°s f√°ciles ser√°n las pruebas.  Para probar los proyectos antiguos con mayor frecuencia, primero debe refactorizarlos fr√≠amente. <br><br><img src="https://habrastorage.org/webt/c5/oa/ze/c5oaze8gmau8ticskgu44o5wyza.jpeg" alt="imagen"><br><br>  P: Tengo m√©todos (funciones) muy simples, ¬øqu√© hay para probar?  ¬°Todo es confiable all√≠, no hay margen de error! <br>  R: Debe entenderse que no prueba la implementaci√≥n correcta de la funci√≥n (si no tiene TDD), simplemente "arregla" su estado actual de trabajo.  En el futuro, cuando necesite cambiarlo, puede determinar r√°pidamente si rompi√≥ su comportamiento utilizando la prueba.  Ejemplo: hay una funci√≥n que valida el correo electr√≥nico.  Ella lo hace un habitual. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($email)</span></span></span><span class="hljs-function"> </span></span>{ $regex = <span class="hljs-string"><span class="hljs-string">"very_complex_regex_here"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_array($email)) { $result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> ($email <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $item) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (preg_match($regex, $item) === <span class="hljs-number"><span class="hljs-number">0</span></span>) { $result = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $result = preg_match($regex, $emai) ==! <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $result; }</code> </pre><br>  Todo su c√≥digo espera que si pasa un correo electr√≥nico v√°lido a esta funci√≥n, se devolver√° verdadero.  Una serie de correos electr√≥nicos v√°lidos tambi√©n es cierto.  Una matriz con al menos una direcci√≥n de correo electr√≥nico no v√°lida es falsa.  Bueno, etc., el c√≥digo es claro.  Pero lleg√≥ el d√≠a y decidiste reemplazar la monstruosa temporada regular con una API externa.  Pero, ¬øc√≥mo garantizar que la funci√≥n reescrita no haya cambiado el principio de funcionamiento?  ¬øDe repente no maneja bien la matriz?  ¬øO volver√° no booleano?  Y las pruebas pueden mantener esto bajo control.  Una prueba bien escrita indicar√° inmediatamente un comportamiento de la funci√≥n diferente al esperado. <br><br>  P: ¬øCu√°ndo comenzar√© a ver algo de sentido en las pruebas? <br>  R: En primer lugar, tan pronto como cubra una parte significativa del c√≥digo.  Cuanto m√°s cercana sea la cobertura al 100%, m√°s confiables ser√°n las pruebas.  En segundo lugar, tan pronto como tenga que hacer cambios globales, o cambios en la parte compleja del c√≥digo.  Las pruebas pueden detectar problemas que pueden perderse f√°cilmente manualmente (casos l√≠mite).  En tercer lugar, al escribir las pruebas ellos mismos!  A menudo hay una situaci√≥n en la que escribir una prueba revela fallas en el c√≥digo que no son visibles a primera vista. <br><br>  P: Bueno, tengo un sitio web en laravel.  El sitio no es una funci√≥n, es una monta√±a de c√≥digo de mierda.  ¬øC√≥mo probar aqu√≠? <br>  A: Esto es lo que se discutir√° m√°s adelante.  En resumen: probamos por separado los m√©todos de los controladores, separamos el middleware, separamos los servicios, etc. <br><br>  Una de las ideas de las pruebas unitarias es aislar la secci√≥n de c√≥digo probada.  Cuanto menos c√≥digo pruebe con una prueba, mejor.  Veamos un ejemplo lo m√°s cercano posible a la vida real: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($userService, $emailService)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService = $userService; <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService = $emailService; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">login</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;login) || <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($request-&gt;password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error"</span></span>; } $password = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;userService-&gt;getPasswordFor($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($password)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Auth error - no password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($password !== $request-&gt;password) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Incorrect password"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;emailService-&gt;sendEmail($request-&gt;login); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Success"</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// .... /* somewhere in project core */ $controller = new Controller($userService, $emailService); $controller-&gt;login($request);</span></span></code> </pre> <br>  Este es un m√©todo muy t√≠pico para iniciar sesi√≥n en el sistema en peque√±os proyectos.  Todo lo que esperamos son los mensajes de error correctos y el correo electr√≥nico enviado en caso de un inicio de sesi√≥n exitoso.  ¬øC√≥mo probar este m√©todo?  Primero, necesita identificar dependencias externas.  En nuestro caso, hay dos de ellos: $ userService y $ emailService.  Se pasan a trav√©s del constructor de clase, lo que facilita enormemente nuestra tarea.  Pero, como se mencion√≥ anteriormente, cuanto menos c√≥digo probamos en una pasada, mejor. <br><br>  La emulaci√≥n, sustituci√≥n de objetos se llama mokanem (del ingl√©s. Mock object, literalmente: "object-parody").  Nadie se molesta en escribir tales objetos manualmente, pero todo ya se ha inventado antes que nosotros, por lo que una biblioteca tan maravillosa como <a href="https://github.com/mockery/mockery" rel="nofollow">Mockery</a> viene al rescate.  Creemos mokas para los servicios. <br><br><pre> <code class="php hljs">$userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>);</code> </pre> <br>  Ahora cree el objeto $ request.  Para comenzar, probaremos la l√≥gica de verificar los campos de inicio de sesi√≥n y contrase√±a.  Queremos asegurarnos de que si no hay ninguno, nuestro m√©todo manejar√° correctamente este caso y devolver√° el mensaje deseado (!). <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); }</code> </pre><br>  Nada complicado, ¬øverdad?  Creamos stubs para los par√°metros de clase necesarios, creamos una instancia de la clase deseada y "extrajimos" el m√©todo deseado, pasando una solicitud deliberadamente incorrecta.  Tengo una respuesta  ¬øPero c√≥mo comprobarlo ahora?  Esta es la parte m√°s importante de la prueba: la llamada afirmaci√≥n.  PHPUnit tiene docenas de <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">aserciones</a> listas para <a href="https://phpunit.readthedocs.io/ru/latest/assertions.html" rel="nofollow">usar</a> .  Solo usa uno de ellos. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); $emailService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'email_service'</span></span>); $controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Controller($userService, $emailService); $request = (object) []; $result = $controller-&gt;login($request); <span class="hljs-comment"><span class="hljs-comment">// vv assertion here! vv $this-&gt;assertEquals("Auth error", $result); }</span></span></code> </pre><br>  Esta prueba garantiza lo siguiente: si el argumento de inicio de sesi√≥n llega al objeto del m√©todo que no tiene el campo de inicio de sesi√≥n o contrase√±a, el m√©todo devolver√° la cadena "Error de autenticaci√≥n".  Eso, en general, es todo.  Tan simple, pero tan √∫til, porque ahora podemos editar el m√©todo de inicio de sesi√≥n sin temor a romper algo.  Nuestro frontend puede estar seguro de que si sucede algo, recibir√° un error de este tipo.  Y si alguien interrumpe este comportamiento (por ejemplo, decide cambiar el texto del error), ¬°la prueba lo indicar√° de inmediato!  Agregamos los cheques restantes para cubrir tantos escenarios posibles como sea posible. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testEmptyPassword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $userService = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'user_service'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// $userService-&gt;getPasswordFor(__any__arg__); // '' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn(''); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Auth error - no password", $result); } function testUncorrectPassword() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '4321' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('4321'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Incorrect password", $result); } function testSuccessfullLogin() { $userService = Mockery::mock('user_service'); // $userService-&gt;getPasswordFor(__any__arg__); // '1234' $userService-&gt;shouldReceive('getPasswordFor')-&gt;andReturn('1234'); $emailService = Mockery::mock('email_service'); $request = (object) [ 'login' =&gt; 'john', 'pass' =&gt; '1234' ]; $result = (new Controller($userService, $emailService))-&gt;login($request); $this-&gt;assertEquals("Success", $result); }</span></span></code> </pre><br>  Observe los m√©todos shouldReceive y andReturn?  Nos permiten crear m√©todos en trozos que devuelven solo lo que necesitamos.  ¬øNecesita probar el error de contrase√±a incorrecta?  Escribimos un stub $ userService que siempre devuelve la contrase√±a incorrecta.  Y eso es todo. <br><br>  Y qu√© hay de las dependencias, preguntas.  Luego los "ahogamos", ¬øy si se rompen?  Pero esto es exactamente para lo que es la m√°xima cobertura de c√≥digo con pruebas.  No verificaremos el funcionamiento de estos servicios en el contexto del inicio de sesi√≥n; lo probaremos con la esperanza de que funcionen correctamente.  Y luego escribimos las mismas pruebas aisladas para estos servicios.  Y luego prueba sus dependencias.  Y as√≠ sucesivamente.  Como resultado, cada prueba individual garantiza <b>solo el</b> funcionamiento correcto de un peque√±o fragmento de c√≥digo, siempre que todas sus dependencias funcionen correctamente.  Y dado que todas las dependencias tambi√©n est√°n cubiertas por pruebas, su funcionamiento correcto tambi√©n est√° garantizado.  Como resultado, cualquier cambio en el sistema que rompa la l√≥gica del trabajo de incluso el c√≥digo m√°s peque√±o aparecer√° inmediatamente en una prueba en particular.  C√≥mo ejecutar espec√≠ficamente la ejecuci√≥n de prueba: no lo dir√©, la documentaci√≥n en PHPUnit es bastante buena.  Y en Laravel, por ejemplo, es suficiente ejecutar vendor / bin / phpunit desde la ra√≠z del proyecto para ver un mensaje como este <br><br><img src="https://habrastorage.org/webt/va/bc/co/vabccob2dpo9xiqk7ek9syxinmo.jpeg" alt="imagen">  - Todas las pruebas fueron exitosas.  O algo como esto <br><br><img src="https://habrastorage.org/webt/bh/mc/pu/bhmcpuar0iluxa8nxxmwrkdgvqs.jpeg" alt="imagen">  Una de las siete afirmaciones fall√≥. <br><br>  "Esto, por supuesto, es genial, pero ¬øqu√© pasa con esto que no puedo tener en mis manos?", Preguntas.  Y imaginemos el siguiente c√≥digo para esto <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; } <span class="hljs-comment"><span class="hljs-comment">// ... somewhere in system $api = new ExternalApi(); $info = getInfo($api, 'John'); if ($info === null) { die('Api is down'); } echo $info;</span></span></code> </pre><br>  Vemos un modelo simplificado de trabajo con una API externa.  La funci√≥n utiliza alguna clase para trabajar con la API y, en caso de error, devuelve nulo.  Si, al usar esta funci√≥n, quedamos nulos, deber√≠amos "aumentar el p√°nico" (enviar un mensaje a la holgura, o enviar un correo electr√≥nico al desarrollador, o arrojar un error en la kibana. S√≠, un mont√≥n de opciones).  Todo parece ser simple, ¬øverdad?  Pero imagine que despu√©s de alg√∫n tiempo otro desarrollador decidi√≥ "arreglar" esta funci√≥n.  Decidi√≥ que regresar nulo es el siglo pasado, y deber√≠a lanzar una excepci√≥n. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($infoApi, $userName)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ $response = $infoApi-&gt;getInfo($userName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($response-&gt;status === <span class="hljs-string"><span class="hljs-string">"API Error"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ApiException($response); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $response-&gt;result; }</code> </pre><br>  ¬°E incluso reescribi√≥ todas las secciones del c√≥digo donde se llam√≥ esta funci√≥n!  Todos menos uno.  El lo extra√±aba.  Distra√≠do, cansado, simplemente equivocado, pero nunca se sabe.  El hecho es que una pieza de c√≥digo todav√≠a est√° esperando el viejo comportamiento de la funci√≥n.  Y PHP no es Java para nosotros: no obtendremos un error de compilaci√≥n debido a que la funci√≥n de lanzamiento no est√° envuelta en try-catch.  Como resultado, en uno de los 100 escenarios para usar el sitio, en el caso de un bloqueo de API, no recibiremos un mensaje del sistema.  Adem√°s, con las pruebas manuales, lo m√°s probable es que no capturemos esta versi√≥n del evento.  La API es externa, no depende de nosotros, funciona bien, y lo m√°s probable es que no la tengamos en caso de falla de la API y manejo incorrecto de excepciones.  Pero si tenemos pruebas, captar√°n este caso muy bien, porque la clase ExternalApi est√° "amortiguada" en varias pruebas, y emula tanto el comportamiento normal como el bloqueo.  Y la pr√≥xima prueba caer√° <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testApiFail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $api = Mockery::mock(<span class="hljs-string"><span class="hljs-string">'api'</span></span>); $api-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getInfo'</span></span>)-&gt;andReturn((object) [ <span class="hljs-string"><span class="hljs-string">'status'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'API Error'</span></span> ]); $result = getInfo($api, <span class="hljs-string"><span class="hljs-string">'name'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertNull($result); }</code> </pre><br>  Esta informaci√≥n es realmente suficiente.  Si no tienes fideos heredados, despu√©s de 20-30 minutos puedes escribir tu primera prueba.  Y unas semanas m√°s tarde, para aprender algo nuevo, genial, vuelva a los comentarios en esta publicaci√≥n y escriba qu√© autor el govnokoder no conoce% framework_name%, y escribe malas pruebas, pero debe hacer% this_way%.  Y estar√© muy feliz en ese caso.  Esto significar√° que mi objetivo se ha logrado: ¬°alguien m√°s descubri√≥ las pruebas por s√≠ mismo y aument√≥ un poco el nivel general de profesionalismo en nuestro campo! <br><br>  La cr√≠tica razonada es bienvenida. </div></div><p>Source: <a href="https://habr.com/ru/post/485418/">https://habr.com/ru/post/485418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485394/index.html">Como naci√≥ la infraestructura de Internet</a></li>
<li><a href="../485396/index.html">Control de salud del equipo: medici√≥n de la salud del equipo</a></li>
<li><a href="../485398/index.html">PostgreSQL Antipatterns: hit dictionary on heavy JOIN</a></li>
<li><a href="../485404/index.html">Nos damos cuenta del efecto visual de la pel√≠cula "The Matrix"</a></li>
<li><a href="../485416/index.html">Formas pr√°cticas de mapear datos en Kotlin</a></li>
<li><a href="../485424/index.html">C√≥mo ense√±o a los ni√±os Python</a></li>
<li><a href="../485426/index.html">Coches en los Pa√≠ses Bajos: estad√≠sticas e informaci√≥n para 2019</a></li>
<li><a href="../485428/index.html">El misterioso programa LyX. Parte 5</a></li>
<li><a href="../485430/index.html">Editor de texto simple para m√∫ltiples usuarios con encriptaci√≥n de extremo a extremo</a></li>
<li><a href="../485438/index.html">Prueba de componentes de la interfaz de usuario de React</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>