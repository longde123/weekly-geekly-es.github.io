<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏇🏼 🕣 😷 Conceptos básicos del motor de JavaScript: optimización de prototipos. Parte 1 🦊 👈🏾 🤴🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos Cada vez queda menos tiempo hasta el lanzamiento del curso "Seguridad de los sistemas de información" , por lo que hoy continuamos compar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceptos básicos del motor de JavaScript: optimización de prototipos. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/447870/">  Hola a todos  Cada vez queda menos tiempo hasta el lanzamiento del curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Seguridad de los sistemas de información"</a> , por lo que hoy continuamos compartiendo publicaciones dedicadas al lanzamiento de este curso.  Por cierto, esta publicación es una continuación de estos dos artículos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">“Fundamentos de los motores de JavaScript: formularios generales y almacenamiento en caché en línea.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">" Conceptos básicos de los motores de JavaScript: formularios generales y almacenamiento en caché en línea.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2 "</a> . <br><br>  El artículo describe los conceptos básicos clave.  Son comunes a todos los motores de JavaScript, y no solo al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">V8 en el</a> que están trabajando los autores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Benedict</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Matthias</a> ).  Como desarrollador de JavaScript, puedo decir que una comprensión más profunda de cómo funciona el motor de JavaScript lo ayudará a descubrir cómo escribir código eficiente. <br><br><img src="https://habrastorage.org/webt/sn/lh/zx/snlhzxtpzzs0ynrlywt0hvbfafw.png"><a name="habracut"></a><br><br>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo anterior,</a> discutimos cómo los motores JavaScript optimizan el acceso a objetos y matrices utilizando formularios y cachés en línea.  En este artículo, veremos cómo optimizar los compromisos de la tubería y acelerar el acceso a las propiedades del prototipo. <br><br><blockquote>  Nota: si prefiere ver presentaciones que leer artículos, mire <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este video</a> .  De lo contrario, sáltelo y siga leyendo. </blockquote><br><br>  <b>Niveles de optimización y compensaciones</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La última vez,</a> descubrimos que todos los motores JavaScript modernos, de hecho, tienen la misma tubería: <br><br><img src="https://habrastorage.org/webt/dv/ni/m_/dvnim_h74jp64e3w2hyxmm9h1tu.png"><br><br>  También nos dimos cuenta de que a pesar del hecho de que las tuberías de alto nivel de motor a motor son similares en estructura, hay una diferencia en la tubería de optimización.  ¿Por qué es esto así?  ¿Por qué algunos motores tienen más niveles de optimización que otros?  La cuestión es hacer un compromiso entre una transición rápida a la etapa de ejecución del código o pasar un poco más de tiempo para ejecutar el código con un rendimiento óptimo. <br><br><img src="https://habrastorage.org/webt/ry/m5/cv/rym5cvxm6b5pwiaibki4jrtjqdq.png"><br><br>  El intérprete puede generar rápidamente bytecode, pero bytecode por sí solo no es lo suficientemente eficiente en términos de velocidad.  Involucrar a un compilador de optimización en este proceso pasa una cierta cantidad de tiempo, pero permite un código de máquina más eficiente. <br>  Echemos un vistazo a cómo el V8 maneja esto.  Recuerde que en V8 el intérprete se llama Ignition y se considera el intérprete más rápido entre los motores existentes (en materia de velocidad de ejecución de bytecode sin formato).  El compilador de optimización en V8 se llama TurboFan, y es él quien genera un código de máquina altamente optimizado. <br><br><img src="https://habrastorage.org/webt/tr/jx/d7/trjxd74glsh5mmj9swifxkqukfk.png"><br><br>  La compensación entre el retraso de inicio y la velocidad de ejecución es la razón por la cual algunos motores de JavaScript prefieren agregar niveles de optimización adicionales entre los pasos.  Por ejemplo, SpiderMonkey agrega un nivel de línea de base entre su intérprete y el compilador de optimización completo de IonMonkey: <br><br><img src="https://habrastorage.org/webt/ey/ry/1w/eyry1w6rnodjaethbgmjhcfkjj4.png"><br><br>  El intérprete genera rápidamente bytecode, pero el bytecode en sí es relativamente lento.  La línea de base genera código un poco más, pero proporciona un rendimiento mejorado en tiempo de ejecución.  Finalmente, el compilador de optimización IonMonkey pasa la mayor cantidad de tiempo generando código de máquina, pero dicho código es extremadamente eficiente. <br>  Veamos un ejemplo específico y veamos cómo las tuberías de varios motores abordan este problema.  Aquí en el bucle activo, a menudo se repite el mismo código. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4242424242</span></span>; ++i) { result += i; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result);</code> </pre> <br><br>  V8 comienza iniciando el código de bytes en el intérprete de encendido.  En algún momento, el motor determina que el código está activo y lanza la interfaz TurboFan, que integra datos de creación de perfiles y crea una representación de máquina básica del código.  Luego se envía al optimizador TurboFan en otro hilo para una mejora adicional. <br><br><img src="https://habrastorage.org/webt/gy/zs/fb/gyzsfbelxi0ffbra0x2t-r6tm90.png"><br><br>  Mientras la optimización está en curso, V8 continúa ejecutando código en Ignition.  En algún momento, cuando el optimizador ha terminado y hemos recibido el código de máquina ejecutable, inmediatamente pasa a la etapa de ejecución. <br>  SpyderMonkey también comienza la ejecución de bytecode en el intérprete.  Pero tiene un nivel de línea de base adicional, lo que significa que primero se envía el código activo.  El compilador de línea de base genera código de línea de base en el hilo principal y continúa la ejecución al final de su generación. <br><br><img src="https://habrastorage.org/webt/xe/4k/oy/xe4koybmve5b33fwgwef87b1a_u.png"><br><br>  Si el código de línea de base se ha estado ejecutando durante algún tiempo, SpiderMonkey finalmente lanza la interfaz IonMonkey (interfaz IonMonkey) y ejecuta el optimizador, el proceso es muy similar al V8.  Todo esto continúa funcionando al mismo tiempo en Baseline, mientras que IonMonkey se dedica a la optimización.  Finalmente, cuando el optimizador termina su trabajo, se ejecuta el código optimizado en lugar del código de línea de base. <br><br>  La arquitectura de Chakra es muy similar a SpiderMonkey, pero Chakra está tratando de ejecutar más procesos al mismo tiempo para evitar bloquear el hilo principal.  En lugar de ejecutar cualquier parte del compilador en el hilo principal, Chakra copia el bytecode y los datos de perfil que necesita el compilador y los envía al proceso dedicado del compilador. <br><br><img src="https://habrastorage.org/webt/3n/8x/op/3n8xopdh2_b-iobjurabjd6vj7m.png"><br><br>  Cuando el código generado está listo, el motor ejecuta este código SimpleJIT en lugar del código de bytes.  Lo mismo sucede con FullJIT.  La ventaja de este enfoque es que la pausa que ocurre durante la copia suele ser mucho más corta que iniciar un compilador completo (frontend).  Por otro lado, este enfoque tiene un inconveniente.  Se basa en el hecho de que la copia heurística puede omitir alguna información que será necesaria para la optimización, por lo que podemos decir que, en cierta medida, la calidad del código se sacrifica en aras de acelerar el trabajo. <br><br>  En JavaScriptCore, todos los compiladores de optimización funcionan completamente en paralelo con la ejecución básica de JavaScript.  No hay fase de copia.  En cambio, el hilo principal simplemente comienza a compilarse en otro hilo.  Los compiladores utilizan un complejo esquema de bloqueo para acceder a los datos de creación de perfiles desde el hilo principal. <br><br><img src="https://habrastorage.org/webt/22/ih/lv/22ihlvsqxl_80pfo4qgivtksbqk.png"><br><br>  La ventaja de este enfoque es que reduce la cantidad de basura que aparece después de la optimización en el hilo principal.  La desventaja de este enfoque es que requiere resolver problemas complejos de subprocesos múltiples y algunos costos de bloqueo para diversas operaciones. <br>  Hablamos sobre las compensaciones entre la generación rápida de código mientras el intérprete está en ejecución y la generación rápida de código utilizando el compilador de optimización.  Pero hay un compromiso más, y se refiere al uso de la memoria.  Para ilustrarlo, escribí un programa simple de JavaScript que agrega dos números. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x, y</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; } add(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br><br>  Mire el código de bytes que genera el intérprete de encendido para la función de agregar en V8. <br><br><pre> <code class="javascript hljs">StackCheck Ldar a1 Add a0, [<span class="hljs-number"><span class="hljs-number">0</span></span>] Return</code> </pre> <br><br>  No se preocupe por el código de bytes, no es necesario que pueda leerlo.  Aquí es necesario prestar atención al hecho de que contiene <b>solo 4 instrucciones</b> . <br>  Cuando el código se calienta, TurboFan genera un código de máquina altamente optimizado, que se presenta a continuación: <br><br><pre> <code class="javascript hljs">leaq rcx,[rip+<span class="hljs-number"><span class="hljs-number">0x0</span></span>] movq rcx,[rcx<span class="hljs-number"><span class="hljs-number">-0x37</span></span>] testb [rcx+<span class="hljs-number"><span class="hljs-number">0xf</span></span>],<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz CompileLazyDeoptimizedCode push rbp movq rbp,rsp push rsi push rdi cmpq rsp,[r13+<span class="hljs-number"><span class="hljs-number">0xe88</span></span>] jna StackOverflow movq rax,[rbp+<span class="hljs-number"><span class="hljs-number">0x18</span></span>] test al,<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz Deoptimize movq rbx,[rbp+<span class="hljs-number"><span class="hljs-number">0x10</span></span>] testb rbx,<span class="hljs-number"><span class="hljs-number">0x1</span></span> jnz Deoptimize movq rdx,rbx shrq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rcx,rax shrq rcx, <span class="hljs-number"><span class="hljs-number">32</span></span> addl rdx,rcx jo Deoptimize shlq rdx, <span class="hljs-number"><span class="hljs-number">32</span></span> movq rax,rdx movq rsp,rbp pop rbp ret <span class="hljs-number"><span class="hljs-number">0x18</span></span></code> </pre> <br><br>  Realmente hay muchos equipos aquí, especialmente en comparación con los cuatro que vimos en el código de bytes.  En general, el código de bytes es mucho más amplio que el código de máquina y, en particular, el código de máquina optimizado.  Bytecode, por otro lado, es ejecutado por el intérprete, mientras que el código optimizado puede ser ejecutado directamente por el procesador. <br>  Esta es una de las razones por las cuales los motores de JavaScript no solo "optimizan todo".  Como vimos anteriormente, generar código de máquina optimizado lleva mucho tiempo y, por lo tanto, requiere más memoria. <br><br><img src="https://habrastorage.org/webt/dn/h5/sm/dnh5smq1qva1g8udg583xeve85y.png"><br><br>  <b>Para resumir:</b> La razón por la cual los motores de JavaScript tienen diferentes niveles de optimización es para encontrar un compromiso entre la generación rápida de código usando el intérprete y la generación rápida de código usando el compilador de optimización.  Agregar más niveles de optimización le permite tomar decisiones más informadas, en función del costo de la complejidad y los gastos generales adicionales durante la ejecución.  Además, existe una compensación entre el nivel de optimización y el uso de memoria.  Es por eso que los motores de JavaScript intentan optimizar solo las funciones activas. <br><br>  <b>Optimizar el acceso a las propiedades del prototipo</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La última vez</a> hablamos sobre cómo los motores JavaScript optimizan la carga de las propiedades de los objetos mediante formularios y cachés en línea.  Recuerde que los motores almacenan las formas de los objetos por separado de los valores del objeto. <br><br><img src="https://habrastorage.org/webt/mu/-x/t4/mu-xt4rt-iqzzutk8zaayg33acw.png"><br><br>  Los formularios le permiten utilizar la optimización utilizando cachés en línea o circuitos integrados abreviados.  Al trabajar juntos, los formularios y los circuitos integrados pueden acelerar el acceso repetido a las propiedades desde el mismo lugar en su código. <br><br><img src="https://habrastorage.org/webt/1i/sb/bh/1isbbh_xagsaucfsy5vjhmva1gs.png"><br><br>  Así que la primera parte de la publicación llegó a su fin, y sobre las clases y la programación de prototipos se puede encontrar en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">segunda parte</a> .  Tradicionalmente, estamos esperando sus comentarios y discusiones tormentosas, así como lo invitamos a una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jornada de puertas abiertas</a> en el curso "Seguridad de los sistemas de información". </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/447870/">https://habr.com/ru/post/447870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447856/index.html">Cómo vender una ventana sin emparejamiento o la importancia del posicionamiento antes de desarrollar un sitio</a></li>
<li><a href="../447860/index.html">Termodinámica de agujeros negros.</a></li>
<li><a href="../447862/index.html">Cisco Live 2019 EMEA. Sesiones técnicas: simplificación externa con complicación interna</a></li>
<li><a href="../447864/index.html">Noticias de la semana: principales eventos en informática y ciencia</a></li>
<li><a href="../447868/index.html">Módulo de telémetro ultrasónico submarino. Parte dos</a></li>
<li><a href="../447872/index.html">Alienware M15: portátil para juegos compacto con amplias opciones de actualización</a></li>
<li><a href="../447874/index.html">Entropía informativa del caos</a></li>
<li><a href="../447876/index.html">Todo es muy malo o un nuevo tipo de intercepción de tráfico.</a></li>
<li><a href="../447878/index.html">Comprobación de rdesktop y xrdp con PVS-Studio</a></li>
<li><a href="../447880/index.html">Validación de rdesktop y xrdp con el analizador PVS-Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>