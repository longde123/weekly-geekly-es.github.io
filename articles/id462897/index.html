<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèæ üëéüèΩ üë©üèª‚Äçüî¨ Pelajari OpenGL. Pelajaran 7.1 - Debugging üè¨ üë©üèª‚Äçüé§ üë®‚Äçüë®‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pemrograman grafis tidak hanya sumber kesenangan, tetapi juga frustrasi ketika sesuatu tidak ditampilkan sebagaimana dimaksud, atau tidak ada yang dit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pelajari OpenGL. Pelajaran 7.1 - Debugging</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462897/"><p><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="gambar" align="left" width="300">  Pemrograman grafis tidak hanya sumber kesenangan, tetapi juga frustrasi ketika sesuatu tidak ditampilkan sebagaimana dimaksud, atau tidak ada yang ditampilkan di layar sama sekali.  Melihat bahwa sebagian besar yang kami lakukan terkait dengan manipulasi piksel, mungkin sulit untuk mengetahui penyebab kesalahan ketika sesuatu tidak berfungsi sebagaimana mestinya.  Debugging jenis kesalahan ini lebih sulit daripada kesalahan debugging pada CPU.  Kami tidak memiliki konsol tempat kami dapat menampilkan teks, kami tidak dapat meletakkan breakpoint di shader dan kami tidak bisa hanya mengambil dan memeriksa status program pada GPU. </p><br><p>  Dalam tutorial ini, kami akan memperkenalkan Anda kepada beberapa metode dan teknik debugging untuk program OpenGL Anda.  Debugging di OpenGL tidak begitu sulit, dan mempelajari beberapa trik pasti akan membuahkan hasil. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text"><div class="spoiler">  <b class="spoiler_title">Bagian 1. Memulai</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembuatan jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo jendela</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Halo segitiga</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Transformasi</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sistem koordinat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kamera</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 2. Pencahayaan dasar</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dasar-dasar pencahayaan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Material</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta tekstur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber cahaya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berbagai Sumber Penerangan</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 3. Unduh model 3D</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perpustakaan Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Polygon Mesh</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kelas Model 3D</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 4. Fitur OpenGL Lanjutan</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes kedalaman</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tes stensil</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencampuran warna</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memotong wajah</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buffer bingkai</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu kubik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penanganan data tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GLSL tingkat lanjut</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Shader geometris</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Instancing</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menghaluskan</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 5. Pencahayaan Lanjut</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pencahayaan tingkat lanjut.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blinn Fong Model</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Koreksi gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kartu bayangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peta bayangan omnidirectional</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan normal</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pemetaan paralaks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Render yang ditangguhkan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SSAO</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 6. PBR</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Teori</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sumber Cahaya Analitik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Iradiasi difus</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Paparan specular</a> </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagian 7. Berlatih</b> <div class="spoiler_text"><ol><li>  <b>Debugging</b> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rendering teks</a> </li></ol></div></div></div></div><br><h1 id="glgeterror">  glGetError () </h1><br><p> Ketika Anda menggunakan OpenGL secara tidak benar (misalnya, ketika Anda mengatur buffer dan lupa untuk mengikatnya), OpenGL akan melihat dan membuat satu atau beberapa flag kesalahan khusus di belakang layar.  Kita dapat melacak kesalahan ini dengan memanggil fungsi <code>glGetError()</code> , yang hanya memeriksa flag kesalahan yang diatur dan mengembalikan nilai kesalahan jika terjadi kesalahan. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGetError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br><p>  Fungsi ini mengembalikan bendera kesalahan atau tidak ada kesalahan sama sekali.  Daftar Nilai Pengembalian: </p><br><div class="scrollable-table"><table><thead><tr><th>  Bendera </th><th>  Kode </th><th>  Deskripsi </th></tr></thead><tbody><tr><td> <code>GL_NO_ERROR</code> </td> <td>  0 </td><td>  Tidak ada kesalahan yang dihasilkan sejak panggilan glGetError terakhir </td></tr><tr><td> <code>GL_INVALID_ENUM</code> </td> <td>  1280 </td><td>  Setel saat parameter enumerasi tidak valid </td></tr><tr><td> <code>GL_INVALID_VALUE</code> </td> <td>  1281 </td><td>  Tetapkan kapan nilai tidak valid </td></tr><tr><td> <code>GL_INVALID_OPERATION</code> </td> <td>  1282 </td><td>  Setel saat perintah dengan parameter yang ditentukan tidak valid </td></tr><tr><td> <code>GL_STACK_OVERFLOW</code> </td> <td>  1283 </td><td>  Itu ditetapkan ketika operasi mendorong data ke stack (push) menyebabkan stack overflow. </td></tr><tr><td> <code>GL_STACK_UNDERFLOW</code> </td> <td>  1284 </td><td>  Itu ditetapkan ketika operasi popping data dari stack (pop) terjadi dari titik terkecil pada stack. </td></tr><tr><td> <code>GL_OUT_OF_MEMORY</code> </td> <td>  1285 </td><td>  Tetapkan kapan operasi alokasi memori tidak dapat mengalokasikan cukup memori. </td></tr><tr><td> <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </td> <td>  1286 </td><td>  Diatur ketika membaca / menulis ke / dari framebuffer yang tidak selesai </td></tr></tbody></table></div><br><p>  Di dalam dokumentasi untuk fungsi OpenGL, Anda dapat menemukan kode kesalahan yang dihasilkan oleh fungsi yang salah digunakan.  Misalnya, jika Anda melihat dokumentasi untuk fungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>glBindTexture()</code></a> , Anda dapat menemukan kode kesalahan yang dihasilkan oleh fungsi ini di bagian Kesalahan. <br>  Ketika bendera kesalahan diatur, tidak ada bendera kesalahan lain yang akan dihasilkan.  Selain itu, ketika <code>glGetError</code> dipanggil, fungsi menghapus semua flag kesalahan (atau hanya satu pada sistem terdistribusi, lihat di bawah).  Ini berarti bahwa jika Anda memanggil <code>glGetError</code> sekali setelah setiap frame dan mendapatkan kesalahan, ini tidak berarti bahwa ini adalah satu-satunya kesalahan dan Anda masih tidak tahu di mana kesalahan ini terjadi. </p><br><blockquote>  Perhatikan bahwa ketika OpenGL bekerja secara terdistribusi, seperti yang sering terjadi pada sistem dengan X11, kesalahan lain dapat dihasilkan ketika mereka memiliki kode yang berbeda.  Memanggil <code>glGetError</code> kemudian hanya <code>glGetError</code> salah satu flag kode kesalahan alih-alih semua.  Karena itu, mereka merekomendasikan untuk memanggil fungsi ini dalam satu lingkaran. </blockquote><br><pre> <code class="cpp hljs">glBindTexture(GL_TEXTURE_2D, tex); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; glGetError() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  0 ( ) glTexImage2D(GL_TEXTURE_3D, 0, GL_RGB, 512, 512, 0, GL_RGB, GL_UNSIGNED_BYTE, data); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1280 ( ) glGenTextures(-5, textures); std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  1281 (  std::cout &lt;&lt; glGetError() &lt;&lt; std::endl; //  0 ( )</span></span></code> </pre> <br><p>  Fitur khas <code>glGetError</code> adalah membuatnya relatif mudah untuk menentukan di mana kesalahan dapat terjadi dan memverifikasi bahwa OpenGL digunakan dengan benar.  Katakanlah Anda tidak menggambar apa pun, dan Anda tidak tahu apa alasannya: penyangga bingkai tidak disetel dengan benar?  Lupa mengatur tekstur?  Dengan memanggil <code>glGetError</code> mana-mana, Anda dapat dengan cepat mengetahui di mana kesalahan pertama terjadi. <br>  Secara default, <code>glGetError</code> melaporkan hanya nomor kesalahan, yang tidak mudah dimengerti sampai Anda mengingat nomor kode.  Seringkali masuk akal untuk menulis fungsi kecil untuk membantu mencetak string kesalahan bersama dengan lokasi dari mana fungsi dipanggil. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">GLenum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCheckError_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *file, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> line)</span></span></span><span class="hljs-function"> </span></span>{ GLenum errorCode; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((errorCode = glGetError()) != GL_NO_ERROR) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> error; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (errorCode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_ENUM: error = <span class="hljs-string"><span class="hljs-string">"INVALID_ENUM"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_VALUE: error = <span class="hljs-string"><span class="hljs-string">"INVALID_VALUE"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_OVERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_OVERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_STACK_UNDERFLOW: error = <span class="hljs-string"><span class="hljs-string">"STACK_UNDERFLOW"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_OUT_OF_MEMORY: error = <span class="hljs-string"><span class="hljs-string">"OUT_OF_MEMORY"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GL_INVALID_FRAMEBUFFER_OPERATION: error = <span class="hljs-string"><span class="hljs-string">"INVALID_FRAMEBUFFER_OPERATION"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; error &lt;&lt; <span class="hljs-string"><span class="hljs-string">" | "</span></span> &lt;&lt; file &lt;&lt; <span class="hljs-string"><span class="hljs-string">" ("</span></span> &lt;&lt; line &lt;&lt; <span class="hljs-string"><span class="hljs-string">")"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errorCode; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> glCheckError() glCheckError_(__FILE__, __LINE__)</span></span></code> </pre> <br><p>  Jika Anda memutuskan untuk membuat lebih banyak panggilan ke <code>glCheckError</code> , akan berguna untuk mengetahui di mana kesalahan terjadi. </p><br><pre> <code class="cpp hljs">glBindBuffer(GL_VERTEX_ARRAY, vbo); glCheckError();</code> </pre> <br><p>  Kesimpulan: </p><br><p><img src="https://habrastorage.org/webt/3h/yo/dn/3hyodngllw6-koljhvkkee3_lzi.png"><br>  Satu hal penting tetap ada: ada bug lama di GLEW: <code>glewInit()</code> selalu mengatur flag <code>GL_INVALID_ENUM</code> .  Untuk memperbaikinya, cukup panggil <code>glGetError</code> setelah <code>glewInit</code> untuk menghapus flag: </p><br><pre> <code class="cpp hljs">glewInit(); glGetError();</code> </pre> <br><p>  <code>glGetError</code> tidak banyak membantu, karena informasi yang dikembalikan relatif sederhana, tetapi sering membantu untuk menangkap kesalahan ketik atau menangkap tempat di mana kesalahan terjadi.  Ini adalah alat debugging yang sederhana namun efektif. </p><br><h1 id="otladochnyy-vyvod">  Output debug </h1><br><p>  Alat ini kurang dikenal, tetapi lebih bermanfaat daripada <code>glCheckError</code> , ekstensi "debug output" OpenGL, yang dimasukkan dalam Profil Inti OpenGL 4.3.  Dengan ekstensi ini, OpenGL akan mengirim pesan kesalahan kepada pengguna dengan detail kesalahan.  Ekstensi ini tidak hanya menyediakan lebih banyak informasi, tetapi juga memungkinkan Anda untuk menangkap kesalahan di mana mereka terjadi menggunakan debugger. </p><br><blockquote>  Output debug disertakan dalam OpenGL dimulai dengan versi 4.3, yang berarti Anda akan menemukan fungsionalitas ini pada mesin apa pun yang mendukung OpenGL 4.3 dan lebih tinggi.  Jika versi ini tidak tersedia, maka Anda dapat memeriksa ekstensi <code>ARB_debug_output</code> dan <code>AMD_debug_output</code> .  Ada juga informasi yang tidak diverifikasi bahwa hasil debug tidak didukung pada OS X (penulis asli dan penerjemah belum diuji, harap informasikan penulis asli atau kepada saya dalam pesan pribadi melalui mekanisme koreksi kesalahan, jika Anda menemukan konfirmasi atau bantahan atas fakta ini; <strong>UPD:</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Jeka178RUS</a> memeriksa ini fakta: di luar kotak, output debug tidak berfungsi, ia tidak memeriksa ekstensi). </blockquote><p>  Untuk mulai menggunakan output debug, kita perlu meminta konteks debug OpenGL selama proses inisialisasi.  Proses ini berbeda pada sistem jendela yang berbeda, tetapi di sini kita hanya akan membahas GLFW, tetapi pada akhir artikel di bagian "Bahan Tambahan" Anda dapat menemukan informasi tentang sistem jendela lainnya. </p><br><h4 id="otladochnyy-vyvod-v-glfw">  Output debug dalam GLFW </h4><br><p>  Meminta konteks debugging di GLFW ternyata sangat sederhana: yang perlu Anda lakukan hanyalah memberi GLFW petunjuk bahwa kami menginginkan konteks yang mendukung output debugging.  Kita perlu melakukan ini sebelum memanggil <code>glfwCreateWindow</code> : </p><br><pre> <code class="cpp hljs">glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);</code> </pre> <br><p>  Segera setelah kita menginisialisasi GLFW, kita harus memiliki konteks debugging jika kita menggunakan OpenGL 4.3 atau lebih tinggi, kalau tidak kita perlu mencoba keberuntungan kita dan berharap bahwa sistem masih dapat membuat konteks debugging.  Jika terjadi kegagalan, kita perlu meminta hasil debug melalui mekanisme ekstensi OpenGL. </p><br><blockquote>  Konteks debug OpenGL bisa lebih lambat dari biasanya, jadi Anda harus menghapus atau mengomentari baris ini saat mengerjakan optimasi atau sebelum rilis. </blockquote><p>  Untuk memeriksa hasil inisialisasi konteks debug, cukup dengan menjalankan kode berikut: </p><br><pre> <code class="cpp hljs">GLint flags; glGetIntegerv(GL_CONTEXT_FLAGS, &amp;flags); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { <span class="hljs-comment"><span class="hljs-comment">//  } else { //   }</span></span></code> </pre> <br><p>  Bagaimana cara kerja output debug?  Kami meneruskan fungsi panggilan balik ke penangan pesan di OpenGL (mirip dengan panggilan balik di GLFW) dan dalam fungsi ini kami dapat memproses data OpenGL sesuai keinginan, dalam kasus kami mengirim pesan kesalahan yang berguna ke konsol.  Prototipe fungsi ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span></span>;</code> </pre> <br><p>  Perhatikan bahwa pada beberapa sistem operasi jenis parameter terakhir mungkin tidak <code>const void*</code> . <br>  Dengan kumpulan data besar yang kami miliki, kami dapat membuat alat pencetakan kesalahan yang bermanfaat, seperti yang ditunjukkan di bawah ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> APIENTRY </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glDebugOutput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GLchar *message, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *userParam)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ignore non-significant error/warning codes if(id == 131169 || id == 131185 || id == 131218 || id == 131204) return; std::cout &lt;&lt; "---------------" &lt;&lt; std::endl; std::cout &lt;&lt; "Debug message (" &lt;&lt; id &lt;&lt; "): " &lt;&lt; message &lt;&lt; std::endl; switch (source) { case GL_DEBUG_SOURCE_API: std::cout &lt;&lt; "Source: API"; break; case GL_DEBUG_SOURCE_WINDOW_SYSTEM: std::cout &lt;&lt; "Source: Window System"; break; case GL_DEBUG_SOURCE_SHADER_COMPILER: std::cout &lt;&lt; "Source: Shader Compiler"; break; case GL_DEBUG_SOURCE_THIRD_PARTY: std::cout &lt;&lt; "Source: Third Party"; break; case GL_DEBUG_SOURCE_APPLICATION: std::cout &lt;&lt; "Source: Application"; break; case GL_DEBUG_SOURCE_OTHER: std::cout &lt;&lt; "Source: Other"; break; } std::cout &lt;&lt; std::endl; switch (type) { case GL_DEBUG_TYPE_ERROR: std::cout &lt;&lt; "Type: Error"; break; case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: std::cout &lt;&lt; "Type: Deprecated Behaviour"; break; case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR: std::cout &lt;&lt; "Type: Undefined Behaviour"; break; case GL_DEBUG_TYPE_PORTABILITY: std::cout &lt;&lt; "Type: Portability"; break; case GL_DEBUG_TYPE_PERFORMANCE: std::cout &lt;&lt; "Type: Performance"; break; case GL_DEBUG_TYPE_MARKER: std::cout &lt;&lt; "Type: Marker"; break; case GL_DEBUG_TYPE_PUSH_GROUP: std::cout &lt;&lt; "Type: Push Group"; break; case GL_DEBUG_TYPE_POP_GROUP: std::cout &lt;&lt; "Type: Pop Group"; break; case GL_DEBUG_TYPE_OTHER: std::cout &lt;&lt; "Type: Other"; break; } std::cout &lt;&lt; std::endl; switch (severity) { case GL_DEBUG_SEVERITY_HIGH: std::cout &lt;&lt; "Severity: high"; break; case GL_DEBUG_SEVERITY_MEDIUM: std::cout &lt;&lt; "Severity: medium"; break; case GL_DEBUG_SEVERITY_LOW: std::cout &lt;&lt; "Severity: low"; break; case GL_DEBUG_SEVERITY_NOTIFICATION: std::cout &lt;&lt; "Severity: notification"; break; } std::cout &lt;&lt; std::endl; std::cout &lt;&lt; std::endl; }</span></span></code> </pre> <br><p>  Ketika ekstensi mendeteksi kesalahan OpenGL, ia akan memanggil fungsi ini dan kami dapat mencetak sejumlah besar informasi kesalahan.  Perhatikan bahwa kami mengabaikan beberapa kesalahan, karena tidak berguna (misalnya, 131185 pada driver NVidia menunjukkan bahwa buffer telah berhasil dibuat). <br>  Sekarang kita memiliki panggilan balik yang diinginkan, sekarang saatnya untuk menginisialisasi output debug: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; GL_CONTEXT_FLAG_DEBUG_BIT) { glEnable(GL_DEBUG_OUTPUT); glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS); glDebugMessageCallback(glDebugOutput, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE); }</code> </pre> <br><p>  Jadi kami memberi tahu OpenGL bahwa kami ingin mengaktifkan hasil debug.  Panggilan ke <code>glEnable(GL_DEBUG_SYNCRHONOUS)</code> memberi tahu OpenGL bahwa kami menginginkan pesan kesalahan ketika baru saja terjadi. </p><br><h4 id="filtraciya-otladochnogo-vyvoda">  Penyaringan Output Debug </h4><br><p>  Dengan fungsi <code>glDebugMessageControl</code> Anda dapat memilih jenis kesalahan yang ingin Anda terima.  Dalam kasus kami, kami mendapatkan semua jenis kesalahan.  Jika kami hanya menginginkan kesalahan OpenGL API, seperti Kesalahan dan tingkat signifikansi Tinggi, kami akan menulis kode berikut: </p><br><pre> <code class="cpp hljs">glDebugMessageControl(GL_DEBUG_SOURCE_API, GL_DEBUG_TYPE_ERROR, GL_DEBUG_SEVERITY_HIGH, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, GL_TRUE);</code> </pre> <br><p>  Dengan konfigurasi dan konteks debugging ini, setiap perintah OpenGL yang salah akan mengirim banyak informasi berguna: </p><br><p><img src="https://habrastorage.org/webt/4r/su/ir/4rsuirzossc_jpcoldwi-t4s0ny.png"></p><br><h4 id="nahodim-istochnik-oshibki-cherez-stek-vyzovov">  Temukan sumber kesalahan melalui tumpukan panggilan </h4><br><p>  Trik lain dengan output debugging adalah Anda relatif dapat dengan mudah menentukan lokasi kesalahan dalam kode Anda.  Dengan mengatur breakpoint di fungsi <code>DebugOutput</code> pada jenis kesalahan yang diinginkan (atau di awal fungsi jika Anda ingin menangkap semua kesalahan), debugger akan menangkap kesalahan dan Anda dapat menavigasi tumpukan panggilan untuk mengetahui di mana kesalahan terjadi: </p><br><p><img src="https://habrastorage.org/webt/fw/sm/0s/fwsm0sr9tzjyl36kg0maj_rthz0.png"><br>  Ini memerlukan beberapa intervensi manual, tetapi jika Anda tahu kira-kira apa yang Anda cari, sangat berguna untuk dengan cepat menentukan panggilan mana yang menyebabkan kesalahan. </p><br><h4 id="svoi-oshibki">  Kesalahan sendiri </h4><br><p>  Seiring dengan kesalahan membaca, kami dapat mengirimkannya ke sistem keluaran debug menggunakan <code>glDebugMessageInsert</code> : </p><br><pre> <code class="cpp hljs">glDebugMessageInsert(GL_DEBUG_SOURCE_APPLICATION, GL_DEBUG_TYPE_ERROR, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEBUG_SEVERITY_MEDIUM, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-string"><span class="hljs-string">"error message here"</span></span>);</code> </pre> <br><p>  Ini sangat berguna jika Anda terhubung ke aplikasi lain atau kode OpenGL yang menggunakan konteks debugging.  Pengembang lain akan dapat dengan cepat mengetahui kesalahan yang dilaporkan yang terjadi pada kode OpenGL khusus Anda. <br>  Secara umum, output debugging (jika tersedia) sangat berguna untuk menangkap kesalahan dengan cepat dan pasti sepadan dengan usaha yang dihabiskan untuk penyetelan, karena menghemat waktu pengembangan yang signifikan.  Anda dapat menemukan salinan kode sumber di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> menggunakan <code>glGetError</code> dan hasil debug.  Ada kesalahan, coba perbaiki. </p><br><h1 id="otladochnyy-vyvod-sheydera">  Output debug Shader </h1><br><p>  Ketika datang ke GLSL, kami tidak memiliki akses ke fungsi-fungsi seperti <code>glGetError</code> atau kemampuan untuk berjalan melalui kode dalam langkah-langkah dalam debugger.  Ketika Anda menemukan layar hitam atau layar yang sama sekali tidak benar, bisa sangat sulit untuk memahami apa yang terjadi jika masalahnya ada di shader.  Ya, kesalahan kompilasi melaporkan kesalahan sintaks, tetapi menangkap kesalahan semantik adalah lagu itu. <br>  Salah satu metode yang umum digunakan untuk mencari tahu apa yang salah dengan shader adalah mengirim semua variabel yang relevan dalam program shader langsung ke saluran output dari shader fragmen.  Dengan mengeluarkan variabel shader langsung ke saluran output dengan warna, kita dapat menemukan informasi menarik dengan memeriksa gambar di output.  Sebagai contoh, kita perlu mencari tahu apakah normals sudah benar untuk model.  Kita dapat mengirim mereka (diubah atau tidak) dari vertex ke shader fragmen, di mana kita memperoleh sesuatu yang normals seperti ini: <br>  (note lane: mengapa tidak ada penyorotan sintaks untuk GLSL?) </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec3 Normal; [...] void main() { [...] FragColor.rgb = Normal; FragColor.a = 1.0f; }</span></span></code> </pre> <br><p>  Dengan mengeluarkan variabel non-warna ke saluran keluaran dengan warna seperti sekarang, kita dapat dengan cepat memeriksa nilai variabel.  Jika, misalnya, hasilnya adalah layar hitam, maka jelas bahwa normals salah ditransfer ke shader, dan ketika mereka ditampilkan, relatif mudah untuk memeriksa kebenarannya: </p><br><p><img src="https://habrastorage.org/webt/ga/5c/eq/ga5ceqfkwfcszqm75y6szggge-e.png"></p><br><p>  Dari hasil visual, kita dapat melihat bahwa normalnya benar, karena sisi kanan jas didominasi merah (yang berarti bahwa normalnya secara kasar menunjukkan ke arah sumbu pembilasan x) dan juga sisi depan setelan diwarnai ke arah sumbu z positif (biru). </p><br><p>  Pendekatan ini dapat diperluas ke variabel apa pun yang ingin Anda uji.  Setiap kali Anda macet dan menganggap bahwa kesalahan ada di shader, cobalah untuk menggambar beberapa variabel atau hasil antara dan cari tahu di bagian mana dari algoritma ada kesalahan. </p><br><h1 id="opengl-glsl-reference-compiler">  Kompiler referensi OpenGL GLSL </h1><br><p>  Setiap driver video memiliki kebiasaan sendiri.  Sebagai contoh, driver NVIDIA sedikit melunakkan persyaratan spesifikasi, dan driver AMD lebih baik memenuhi spesifikasi (yang lebih baik, menurut saya).  Masalahnya adalah shader yang beroperasi pada satu mesin mungkin tidak menghasilkan uang pada mesin lain karena perbedaan driver. </p><br><p>  Untuk beberapa tahun pengalaman, Anda dapat mempelajari semua perbedaan antara GPU yang berbeda, tetapi jika Anda ingin memastikan bahwa shader Anda akan bekerja di mana-mana, maka Anda dapat memverifikasi kode Anda dengan spesifikasi resmi menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kompiler referensi GLSL</a> .  Anda dapat mengunduh apa yang disebut <em>validator lang GLSL di</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber</a> ). </p><br><p>  Dengan program ini, Anda dapat menguji shader Anda dengan mengirimkannya sebagai argumen pertama ke program tersebut.  Ingat bahwa program menentukan jenis shader berdasarkan ekstensi: </p><br><ul><li>  <code>.vert</code> : vertex shader </li><li>  <code>.frag</code> : fragmen shader </li><li>  <code>.geom</code> : geometris shader </li><li>  <code>.tesc</code> : tessellation yang mengendalikan shader </li><li>  <code>.tese</code> : shader komputasi tessellation </li><li>  <code>.comp</code> : hitung shader </li></ul><br><p>  Menjalankan program itu mudah: </p><br><pre> <code class="bash hljs">glslangValidator shader.vert</code> </pre> <br><p>  Perhatikan bahwa jika tidak ada kesalahan, program tidak akan menghasilkan apa pun.  Pada vertex shader yang rusak, output akan terlihat seperti: </p><br><p><img src="https://habrastorage.org/webt/-l/x-/yi/-lx-yijcoqk4ehnnc5xentnjl5m.png"></p><br><p>  Program tidak akan menunjukkan perbedaan antara kompiler GLSL dari AMD, NVidia atau Intel, dan bahkan tidak dapat melaporkan semua bug di shader, tetapi setidaknya memeriksa shader untuk kepatuhan dengan standar. </p><br><h1 id="vyvod-bufera-kadra">  Output buffer bingkai </h1><br><p>  Metode lain untuk toolkit Anda adalah menampilkan konten buffer bingkai di bagian tertentu layar.  Kemungkinan besar, Anda sering menggunakan framebuffer, dan karena semua keajaiban terjadi di belakang layar, mungkin sulit untuk menentukan apa yang terjadi.  Output dari isi frame buffer adalah trik yang berguna untuk memverifikasi hal-hal yang benar. </p><br><blockquote>  Perhatikan bahwa isi buffer bingkai, seperti yang dijelaskan di sini, bekerja dengan tekstur, bukan dengan objek di buffer gambar </blockquote><p>  Menggunakan shader sederhana yang menggambar tekstur tunggal, kita dapat menulis fungsi kecil yang dengan cepat menggambar tekstur apa pun di sudut kanan atas layar: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// vertex shader #version 330 core layout (location = 0) in vec2 position; layout (location = 1) in vec2 texCoords; out vec2 TexCoords; void main() { gl_Position = vec4(position, 0.0f, 1.0f); TexCoords = texCoords; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//fragment shader #version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D fboAttachment; void main() { FragColor = texture(fboAttachment, TexCoords); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//main.cpp void DisplayFramebufferTexture(GLuint textureID) { if(!notInitialized) { // initialize shader and vao w/ NDC vertex coordinates at top-right of the screen [...] } glActiveTexture(GL_TEXTURE0); glUseProgram(shaderDisplayFBOOutput); glBindTexture(GL_TEXTURE_2D, textureID); glBindVertexArray(vaoDebugTexturedRect); glDrawArrays(GL_TRIANGLES, 0, 6); glBindVertexArray(0); glUseProgram(0); } int main() { [...] while (!glfwWindowShouldClose(window)) { [...] DisplayFramebufferTexture(fboAttachment0); glfwSwapBuffers(window); } }</span></span></code> </pre> <br><p>  Ini akan memberi Anda jendela kecil di sudut layar untuk men-debug output buffer bingkai.  Ini berguna, misalnya, ketika Anda mencoba memeriksa kebenaran normals: </p><br><p><img src="https://habrastorage.org/webt/zi/uw/ap/ziuwapmnertjaocm6cexhv8q5c8.png"></p><br><p>  Anda juga dapat memperluas fungsi ini sehingga menghasilkan lebih dari 1 tekstur.  Ini adalah cara cepat untuk mendapatkan umpan balik terus menerus dari apa pun di bingkai penyangga. </p><br><h1 id="vneshnie-programmy-otladchiki">  Program Debugger Eksternal </h1><br><p>  Ketika semuanya gagal, ada satu trik lagi: menggunakan program pihak ketiga.  Mereka dibangun ke dalam driver OpenGL dan dapat mencegat semua panggilan OpenGL untuk memberi Anda banyak data menarik tentang aplikasi Anda.  Aplikasi ini dapat membuat profil penggunaan fungsi OpenGL, mencari kemacetan, dan memonitor buffer bingkai, tekstur, dan memori.  Saat mengerjakan kode (besar), alat-alat ini bisa menjadi sangat berharga. </p><br><p>  Saya telah membuat daftar beberapa alat populer.  Cobalah masing-masing dan pilih yang paling cocok untuk Anda. </p><br><h4 id="renderdoc">  Renderderoc </h4><br><p>  RenderDoc adalah alat debugging terpisah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terbuka</a> penuh) yang bagus.  Untuk memulai penangkapan, pilih file yang dapat dieksekusi dan direktori kerja.  Aplikasi Anda berfungsi seperti biasa, dan ketika Anda ingin menonton satu frame, Anda mengizinkan RenderDoc untuk menangkap beberapa frame aplikasi Anda.  Di antara frame yang diambil, Anda dapat melihat status pipa, semua perintah OpenGL, penyimpanan buffer, dan tekstur yang digunakan. </p><br><p><img src="https://habrastorage.org/webt/oe/wj/zn/oewjznqytsjpfi6jbordzvph_ym.png"></p><br><h4 id="codexl">  Codexl </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CodeXL</a> - Alat debugging GPU, berfungsi sebagai aplikasi mandiri dan plugin untuk Visual Studio.  CodeXL Menyediakan banyak informasi dan bagus untuk membuat profil aplikasi grafis.  CodeXL juga berjalan pada kartu grafis dari NVidia dan Intel, tetapi tanpa dukungan debug OpenCL. </p><br><p><img src="https://habrastorage.org/webt/zk/ap/jw/zkapjwplwxnqm5z65qchaxdjd34.png"></p><br><p>  Saya tidak banyak menggunakan CodeXL, karena RenderDoc tampak lebih sederhana bagi saya, tetapi saya memasukkan CodeXL dalam daftar ini karena terlihat seperti alat yang cukup andal dan terutama dikembangkan oleh salah satu produsen utama GPU. </p><br><h4 id="nvidia-nsight">  NVIDIA Nsight </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nsight</a> adalah alat debugging GPU <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">NUIDIA yang</a> populer.  Ini bukan hanya plug-in untuk Visual Studio dan Eclipse, tetapi juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aplikasi terpisah</a> .  Plugin Nsight adalah hal yang sangat berguna bagi pengembang grafis karena ia mengumpulkan banyak statistik waktu nyata mengenai penggunaan GPU dan keadaan frame-by-frame GPU. </p><br><p>  Saat Anda meluncurkan aplikasi Anda melalui Visual Studio atau Eclipse menggunakan perintah debug atau profil Nsight, itu akan mulai di dalam aplikasi itu sendiri.  Suatu hal yang baik di Nsight: merender sistem GUI (GUI, antarmuka pengguna grafis) di atas aplikasi yang sedang berjalan yang dapat Anda gunakan untuk mengumpulkan semua jenis informasi tentang aplikasi Anda secara real time atau analisis frame-by-frame. </p><br><p><img src="https://habrastorage.org/webt/rx/1m/al/rx1malqwzriz6lhd8oxquerturu.png"></p><br><p>  Nsight adalah alat yang sangat berguna, yang, menurut saya, melampaui alat-alat di atas, tetapi memiliki satu kelemahan serius: Nsight <em>hanya</em> berfungsi pada kartu grafis NVIDIA.  Jika Anda menggunakan kartu grafis NVIDIA dan menggunakan Visual Studio, maka Nsight pasti patut dicoba. </p><br><p>  ,         ( , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">VOGL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">APItrace</a> ),   ,          .      ,     ,    ()          (  ,     ). </p><br><h1 id="dopolnitelnye-materialy">   </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    ?</a> ‚Äî           Reto Koradi. </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=http://web.archive.org/web/20150225171555/"> </a> ‚Äî            Vallentin Source. </li></ul><br><p> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Kami punya </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">telegram conf</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk koordinasi transfer. </font><font style="vertical-align: inherit;">Jika Anda memiliki keinginan serius untuk membantu penerjemahan, silakan!</font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id462897/">https://habr.com/ru/post/id462897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id462885/index.html">Jaringan IPoE yang toleran terhadap kesalahan sudah dekat</a></li>
<li><a href="../id462887/index.html">Pengalaman mempersonalisasi toko online menggunakan contoh rekomendasi dinamis</a></li>
<li><a href="../id462889/index.html">Kisah Lanjutan: Kompilator Pascal sendiri untuk Windows dari awal</a></li>
<li><a href="../id462893/index.html">Pengenalan Wajah di Kota-kota: Keamanan vs Privasi</a></li>
<li><a href="../id462895/index.html">Memecahkan pekerjaan dengan pwnable.kr 17 - memcpy. Penyelarasan data</a></li>
<li><a href="../id462903/index.html">Bagaimana kami merancang dan mengimplementasikan jaringan baru pada Huawei di kantor Moskow, bagian 3: pabrik server</a></li>
<li><a href="../id462905/index.html">Menulis bot telegram dengan python menggunakan library telebot bagian 2</a></li>
<li><a href="../id462907/index.html">mingguan ngFanatic</a></li>
<li><a href="../id462909/index.html">Buah dari evolusi ASIC: tentang produsen, penambang untuk SHA-256 dan keanehan hashrate astronomi</a></li>
<li><a href="../id462911/index.html">Setahun di belakang kemudi mobil listrik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>