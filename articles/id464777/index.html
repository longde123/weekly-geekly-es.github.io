<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè∑Ô∏è üë®üèø‚Äçüî¨ üí± Mengapa const tidak mempercepat kode C / C ++? üé∫ üå± üë©üèΩ‚Äçü§ù‚Äçüë®üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa bulan yang lalu, saya menyebutkan dalam satu posting bahwa ini adalah mitos, seolah-olah const membantu mengaktifkan optimisasi kompiler di C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengapa const tidak mempercepat kode C / C ++?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/464777/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ck/cw/48/ckcw48o0aqklzf10gzhfqx8w3rw.jpeg"></div><br>  Beberapa bulan yang lalu, saya menyebutkan dalam satu posting bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini adalah mitos, seolah-olah const membantu mengaktifkan optimisasi kompiler di C dan C ++</a> .  Saya memutuskan bahwa pernyataan ini harus dijelaskan, terutama karena saya sendiri percaya pada mitos ini sebelumnya.  Saya akan mulai dengan teori dan contoh buatan, kemudian beralih ke percobaan dan tolok ukur berdasarkan basis kode nyata - SQLite. <br><a name="habracut"></a><br><h2>  Tes sederhana </h2><br>  Mari kita mulai dengan, sepertinya bagi saya, contoh paling sederhana dan paling jelas untuk mempercepat kode C dengan <code>const</code> .  Katakanlah kita memiliki dua deklarasi fungsi: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span></span>;</code> </pre> <br>  Dan anggaplah ada dua versi kode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); func(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constByArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); constFunc(x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, *x); }</code> </pre> <br>  Untuk menjalankan <code>printf()</code> , prosesor harus mengambil <code>*x</code> dari memori melalui sebuah pointer.  Tentunya, eksekusi <code>constByArg()</code> bisa sedikit lebih cepat, karena kompiler tahu bahwa <code>*x</code> adalah konstanta, jadi tidak perlu memuat nilainya lagi setelah <code>constFunc()</code> melakukannya.  Benar?  Mari kita lihat kode assembler yang dihasilkan oleh GCC dengan optimisasi diaktifkan: <br><br><pre> <code class="bash hljs">$ gcc -S -Wall -O3 test.c $ view test.s</code> </pre> <br>  Dan berikut ini adalah hasil assembler lengkap untuk <code>byArg()</code> : <br><br><pre> <code class="plaintext hljs">byArg: .LFB23: .cfi_startproc pushq %rbx .cfi_def_cfa_offset 16 .cfi_offset 3, -16 movl (%rdi), %edx movq %rdi, %rbx leaq .LC0(%rip), %rsi movl $1, %edi xorl %eax, %eax call __printf_chk@PLT movq %rbx, %rdi call func@PLT # The only instruction that's different in constFoo movl (%rbx), %edx leaq .LC0(%rip), %rsi xorl %eax, %eax movl $1, %edi popq %rbx .cfi_def_cfa_offset 8 jmp __printf_chk@PLT .cfi_endproc</code> </pre> <br>  Satu-satunya perbedaan antara kode assembler yang dihasilkan oleh <code>byArg()</code> dan <code>constByArg()</code> adalah <code>constByArg()</code> memiliki <code>call constFunc@PLT</code> , seperti pada kode sumber.  <code>const</code> sendiri tidak ada bedanya. <br><br>  Oke, itu GCC.  Mungkin kita membutuhkan kompiler yang lebih pintar.  Katakan Dentang. <br><br><pre> <code class="cpp hljs">$ clang -S -Wall -O3 -emit-llvm test.c $ view test.ll</code> </pre> <br>  Ini adalah kode perantara.  Ini lebih kompak daripada assembler, dan saya akan menjatuhkan kedua fungsi, sehingga Anda mengerti apa yang saya maksud dengan "tidak ada perbedaan, kecuali untuk panggilan": <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @byArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @func(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> } ; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constByArg(i32*) local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">2</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">2</span></span>) tail call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">0</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br><h2>  Opsi yang (tipe) berfungsi </h2><br>  Dan di sini adalah kode di mana kehadiran <code>const</code> sangat penting: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">localVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); constFunc(&amp;x); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d\n"</span></span>, x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constLocalVar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-comment"><span class="hljs-comment">// const on the local variable printf("%d\n", x); constFunc(&amp;x); printf("%d\n", x); }</span></span></code> </pre> <br>  Kode assembler untuk <code>localVar()</code> , yang berisi dua instruksi yang dioptimalkan di luar <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">localVar: .LFB25: .cfi_startproc subq $<span class="hljs-number"><span class="hljs-number">24</span></span>, %rsp .cfi_def_cfa_offset <span class="hljs-number"><span class="hljs-number">32</span></span> movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, %edx movl $<span class="hljs-number"><span class="hljs-number">1</span></span>, %edi movq %fs:<span class="hljs-number"><span class="hljs-number">40</span></span>, %rax movq %rax, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rsp) xorl %eax, %eax leaq .LC0(%rip), %rsi movl $<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp) call __printf_chk@PLT leaq <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %rdi call constFunc@PLT movl <span class="hljs-number"><span class="hljs-number">4</span></span>(%rsp), %edx <span class="hljs-meta"><span class="hljs-meta"># not in constLocalVar() xorl %eax, %eax movl $1, %edi leaq .LC0(%rip), %rsi # not in constLocalVar() call __printf_chk@PLT movq 8(%rsp), %rax xorq %fs:40, %rax jne .L9 addq $24, %rsp .cfi_remember_state .cfi_def_cfa_offset 8 ret .L9: .cfi_restore_state call __stack_chk_fail@PLT .cfi_endproc</span></span></code> </pre> <br>  Middleware LLVM sedikit lebih bersih.  <code>load</code> sebelum panggilan kedua ke <code>printf()</code> dioptimalkan di luar <code>constLocalVar()</code> : <br><br><pre> <code class="cpp hljs">; Function Attrs: nounwind uwtable define dso_local <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @localVar() local_unnamed_addr #<span class="hljs-number"><span class="hljs-number">0</span></span> { %<span class="hljs-number"><span class="hljs-number">1</span></span> = alloca i32, align <span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">2</span></span> = bitcast i32* %<span class="hljs-number"><span class="hljs-number">1</span></span> to i8* call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.start.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> store i32 <span class="hljs-number"><span class="hljs-number">42</span></span>, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">3</span></span> = tail call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 <span class="hljs-number"><span class="hljs-number">42</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @constFunc(i32* nonnull %<span class="hljs-number"><span class="hljs-number">1</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> %<span class="hljs-number"><span class="hljs-number">4</span></span> = load i32, i32* %<span class="hljs-number"><span class="hljs-number">1</span></span>, align <span class="hljs-number"><span class="hljs-number">4</span></span>, !tbaa !<span class="hljs-number"><span class="hljs-number">2</span></span> %<span class="hljs-number"><span class="hljs-number">5</span></span> = call i32 (i8*, ...) @<span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(i8* getelementptr inbounds ([<span class="hljs-number"><span class="hljs-number">4</span></span> x i8], [<span class="hljs-number"><span class="hljs-number">4</span></span> x i8]* @.str, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>, i64 <span class="hljs-number"><span class="hljs-number">0</span></span>), i32 %<span class="hljs-number"><span class="hljs-number">4</span></span>) call <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> @llvm.lifetime.end.p0i8(i64 <span class="hljs-number"><span class="hljs-number">4</span></span>, i8* nonnull %<span class="hljs-number"><span class="hljs-number">2</span></span>) #<span class="hljs-number"><span class="hljs-number">4</span></span> ret <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> }</code> </pre> <br>  Jadi, <code>constLocalVar()</code> berhasil mengabaikan reboot <code>*x</code> , tetapi Anda mungkin melihat sesuatu yang aneh: di badan <code>localVar()</code> dan <code>constLocalVar()</code> panggilan yang sama ke <code>constFunc()</code> .  Jika kompiler dapat mengetahui bahwa <code>constFunc()</code> tidak mengubah <code>*x</code> di <code>constLocalVar()</code> , maka mengapa ia tidak bisa mengerti bahwa panggilan fungsi yang sama tidak mengubah <code>*x</code> di <code>localVar()</code> ? <br><br>  Penjelasannya adalah mengapa <code>const</code> dalam C tidak praktis untuk digunakan sebagai optimisasi.  Dalam C, <code>const</code> pada dasarnya memiliki dua kemungkinan makna: <br><br><ul><li>  itu mungkin berarti bahwa variabel adalah nama samaran read-only untuk beberapa data, yang mungkin atau mungkin tidak konstan. <br></li><li>  atau itu bisa berarti bahwa variabel tersebut benar-benar konstan.  Jika Anda melepaskan ikatan dari pointer ke nilai konstan, dan kemudian menulis untuk itu, Anda akan mendapatkan perilaku yang tidak terdefinisi.  Di sisi lain, tidak akan ada masalah jika <code>const</code> adalah pointer ke nilai yang bukan konstanta. <br></li></ul><br>  Berikut ini adalah contoh penerapan <code>constFunc()</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// x is just a read-only pointer to something that may or may not be a constant void constFunc(const int *x) { // local_var is a true constant const int local_var = 42; // Definitely undefined behaviour by C rules doubleIt((int*)&amp;local_var); // Who knows if this is UB? doubleIt((int*)x); } void doubleIt(int *x) { *x *= 2; }</span></span></code> </pre><br>  <code>localVar()</code> memberikan <code>constFunc()</code> pointer <code>const</code> ke variabel non- <code>const</code> .  Karena variabel awalnya bukan <code>const</code> , <code>constFunc()</code> dapat berubah menjadi pembohong dan secara paksa memodifikasi variabel tanpa memulai UB.  Oleh karena itu, kompilator tidak dapat mengasumsikan bahwa setelah mengembalikan <code>constFunc()</code> variabel akan memiliki nilai yang sama.  Variabel dalam <code>constLocalVar()</code> benar-benar adalah <code>const</code> , sehingga kompiler tidak dapat berasumsi bahwa itu tidak akan berubah, karena kali ini <i>akan menjadi</i> UB untuk <code>constFunc()</code> , sehingga kompiler akan melepaskan ikatan <code>const</code> dan menulis ke variabel. <br><br>  Fungsi <code>byArg()</code> dan <code>constByArg()</code> dari contoh pertama tidak ada harapan, karena kompiler tidak dapat <code>constByArg()</code> apakah <code>*x</code> adalah <code>const</code> . <br><br>  Tetapi dari mana datangnya ketidakkonsistenan?  Jika kompilator dapat menganggap bahwa <code>constFunc()</code> tidak mengubah argumennya ketika dipanggil dari <code>constLocalVar()</code> , maka ia dapat menerapkan optimisasi yang sama ke panggilan <code>constFunc()</code> , kan?  Tidak.  Compiler tidak dapat berasumsi bahwa <code>constLocalVar()</code> akan dipanggil sama sekali.  Dan jika tidak (misalnya, karena itu hanya beberapa hasil tambahan dari pembuat kode atau operasi makro), maka <code>constFunc()</code> dapat dengan tenang mengubah data tanpa memulai UB. <br><br>  Anda mungkin perlu membaca contoh dan penjelasan di atas beberapa kali.  Jangan khawatir kedengarannya tidak masuk akal - itu.  Sayangnya, menulis ke variabel <code>const</code> adalah jenis UB terburuk: paling sering, kompiler bahkan tidak tahu apakah itu UB.  Oleh karena itu, ketika kompilator melihat <code>const</code> , harus melanjutkan dari fakta bahwa seseorang dapat mengubahnya di suatu tempat, yang berarti bahwa kompiler tidak dapat menggunakan <code>const</code> untuk optimisasi.  Dalam praktiknya, ini benar, karena banyak kode C yang sebenarnya berisi penolakan <code>const</code> dengan gaya "Saya tahu apa yang saya lakukan." <br><br>  Singkatnya, ada banyak situasi di mana kompiler tidak diperbolehkan menggunakan <code>const</code> untuk optimisasi, termasuk mengambil data dari lingkup lain menggunakan pointer, atau menempatkan data di heap.  Atau bahkan lebih buruk, biasanya dalam situasi di mana kompiler tidak dapat menggunakan <code>const</code> , ini tidak perlu.  Sebagai contoh, setiap kompiler yang menghargai diri sendiri dapat memahami tanpa <code>const</code> bahwa dalam kode ini <code>x</code> adalah konstanta: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">42</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y); y += x; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d %d\n"</span></span>, x, y);</code> </pre> <br>  Jadi <code>const</code> hampir tidak berguna untuk optimasi, karena: <br><br><ol><li>  Dengan beberapa pengecualian, kompiler terpaksa mengabaikannya, karena beberapa kode dapat secara hukum melepaskan ikatan. <br></li><li>  Dalam sebagian besar pengecualian di atas, kompiler masih dapat memahami bahwa variabel adalah konstanta. <br></li></ol><br><h2>  C ++ </h2><br>  Jika Anda menulis dalam C ++, maka <code>const</code> dapat memengaruhi pembuatan kode melalui fungsi yang berlebihan.  Anda dapat memiliki kelebihan <code>const</code> dan non- <code>const</code> dari fungsi yang sama, dan non- <code>const</code> dapat dioptimalkan (oleh seorang programmer, bukan kompiler), misalnya, untuk menyalin lebih sedikit. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *p)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Needs to do more copying of data } void foo(const int *p) { // Doesn't need defensive copies } int main() { const int x = 42; // const-ness affects which overload gets called foo(&amp;x); return 0; }</span></span></code> </pre> <br>  Di satu sisi, saya tidak berpikir bahwa dalam praktiknya ini sering diterapkan dalam kode C ++.  Di sisi lain, agar benar-benar membuat perbedaan, seorang programmer harus membuat asumsi yang tidak tersedia untuk kompiler, karena mereka tidak dijamin oleh bahasa. <br><br><h2>  Eksperimen dengan SQLite3 </h2><br>  Teori yang cukup dan contoh-contoh yang dibuat-buat.  Apa efek <code>const</code> terhadap basis kode nyata?  Saya memutuskan untuk bereksperimen dengan SQLite DB (versi 3.30.0), karena: <br><br><ul><li>  Ini menggunakan <code>const.</code> </li><li>  Ini adalah basis kode nontrivial (lebih dari 200 KLOC). <br></li><li>  Sebagai basis data, ia mencakup sejumlah mekanisme, mulai dengan memproses nilai string dan berakhir dengan konversi angka hingga saat ini. <br></li><li>  Itu dapat diuji dengan beban prosesor yang terbatas. <br></li></ul><br>  Selain itu, penulis dan programmer yang terlibat dalam pengembangan telah menghabiskan waktu bertahun-tahun untuk meningkatkan produktivitas, sehingga kita dapat berasumsi bahwa mereka tidak melewatkan sesuatu yang jelas. <br><br><h3>  Persiapan </h3><br>  Saya membuat dua salinan <a href="">kode sumber</a> .  Satu dikompilasi dalam mode normal, dan yang kedua pra-diproses menggunakan hack untuk mengubah <code>const</code> menjadi perintah idle: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> const</span></span></code> </pre> <br>  (GNU) <code>sed</code> dapat menambahkan ini di atas setiap file dengan perintah <code>sed -i '1i#define const' *.c *.h</code> . <br><br>  SQLite sedikit memperumit masalah, menggunakan skrip untuk menghasilkan kode selama pembuatan.  Untungnya, kompiler memperkenalkan banyak noise ketika mencampur kode dengan <code>const</code> dan tanpa <code>const</code> , sehingga Anda dapat segera melihat dan mengkonfigurasi skrip untuk menambahkan kode anti- <code>const</code> saya. <br><br>  Perbandingan langsung dari kode yang dikompilasi tidak masuk akal, karena perubahan kecil dapat memengaruhi skema memori keseluruhan, yang akan mengarah pada perubahan pointer dan pemanggilan fungsi di seluruh kode.  Oleh karena itu, saya mengambil gips yang dibongkar ( <code>objdump -d libSQLite3.so.0.8.6</code> ) sebagai ukuran biner dan nama mnemonik dari setiap instruksi.  Misalnya, fungsi ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">000000000005</span></span>d570 &lt;SQLite3_blob_read&gt;: <span class="hljs-number"><span class="hljs-number">5</span></span>d570: <span class="hljs-number"><span class="hljs-number">4</span></span>c <span class="hljs-number"><span class="hljs-number">8</span></span>d <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">59</span></span> a2 ff ff lea <span class="hljs-number"><span class="hljs-number">-0x5da7</span></span>(%rip),%r8 # <span class="hljs-number"><span class="hljs-number">577</span></span>d0 &lt;SQLite3BtreePayloadChecked&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d577: e9 <span class="hljs-number"><span class="hljs-number">04</span></span> fe ff ff jmpq <span class="hljs-number"><span class="hljs-number">5</span></span>d380 &lt;blobReadWrite&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>d57c: <span class="hljs-number"><span class="hljs-number">0f</span></span> <span class="hljs-number"><span class="hljs-number">1f</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> nopl <span class="hljs-number"><span class="hljs-number">0x0</span></span>(%rax)</code> </pre> <br>  Berubah menjadi: <br><br><pre> <code class="cpp hljs">SQLite3_blob_read <span class="hljs-number"><span class="hljs-number">7l</span></span>ea <span class="hljs-number"><span class="hljs-number">5</span></span>jmpq <span class="hljs-number"><span class="hljs-number">4</span></span>nopl</code> </pre> <br>  Saat mengkompilasi, saya tidak mengubah pengaturan perakitan SQLite. <br><br><h3>  Analisis kode terkompilasi </h3><br>  Untuk libSQLite3.so, versi dengan <code>const</code> ditempati 4.740.704 byte, sekitar 0,1% lebih dari versi tanpa <code>const</code> dengan 4.736.712 byte.  Dalam kedua kasus, 1374 fungsi diekspor (tidak termasuk fungsi pembantu tingkat rendah di PLT), dan 13 memiliki perbedaan dalam gips. <br><br>  Beberapa perubahan terkait dengan peretasan preprocessing.  Sebagai contoh, berikut adalah salah satu fungsi yang diubah (saya menghapus beberapa definisi khusus untuk SQLite): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LARGEST_INT64 (0xffffffff|(((int64_t)0x7fffffff)</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;32)) #define SMALLEST_INT64 (((int64_t)-1) - LARGEST_INT64) static int64_t doubleToInt64(double r){ /* ** Many compilers we encounter do not define constants for the ** minimum and maximum 64-bit integers, or they define them ** inconsistently. And many do not understand the "LL" notation. ** So we define our own static constants here using nothing ** larger than a 32-bit integer constant. */ static const int64_t maxInt = LARGEST_INT64; static const int64_t minInt = SMALLEST_INT64; if( r&lt;=(double)minInt ){ return minInt; }else if( r&gt;=(double)maxInt ){ return maxInt; }else{ return (int64_t)r; } }</span></span></span></span></code> </pre> <br>  Jika kita menghapus <code>const</code> , maka konstanta ini berubah menjadi variabel <code>static</code> .  Saya tidak mengerti mengapa siapa pun yang tidak peduli tentang <code>const</code> membuat variabel ini <code>static</code> .  Jika kita menghapus <code>static</code> dan <code>const</code> , maka GCC akan kembali menganggapnya sebagai konstanta, dan kita akan mendapatkan hasil yang sama.  Karena variabel <code>static const</code> seperti itu, perubahan dalam tiga fungsi dari tiga belas ternyata salah, tetapi saya tidak memperbaikinya. <br><br>  SQLite menggunakan banyak variabel global, dan sebagian besar optimasi <code>const</code> terhubung dengan ini: seperti mengganti perbandingan dengan variabel dengan perbandingan dengan konstanta, atau memutar kembali sebagian loop dengan satu langkah (untuk memahami seperti apa optimasi yang dilakukan, saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Radare</a> ).  Beberapa perubahan tidak layak disebut.  <code>SQLite3ParseUri()</code> berisi 487 instruksi, tetapi <code>const</code> hanya membuat satu perubahan: ambil dua perbandingan ini: <br><br><pre> <code class="cpp hljs">test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br>  Dan bertukar: <br><br><pre> <code class="cpp hljs">cmp $<span class="hljs-number"><span class="hljs-number">0x23</span></span>, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt; test %al, %al je &lt;SQLite3ParseUri+<span class="hljs-number"><span class="hljs-number">0x717</span></span>&gt;</code> </pre> <br><h3>  Tingkatan yang dicapai </h3><br>  SQLite hadir dengan uji regresi untuk mengukur kinerja, dan saya menjalankannya ratusan kali untuk setiap versi kode menggunakan pengaturan standar SQLite.  Waktu pelaksanaan dalam detik: <br><br><div class="scrollable-table"><table><tbody><tr><td></td><td>  const <br></td><td>  Tanpa const <br></td></tr><tr><td>  Minimum <br></td><td>  10.658 <br></td><td>  10.803 <br></td></tr><tr><td>  Median <br></td><td>  11.571 <br></td><td>  11.519 <br></td></tr><tr><td>  Maksimum <br></td><td>  11.832 <br></td><td>  11.658 <br></td></tr><tr><td>  Rata-rata <br></td><td>  11.531 <br></td><td>  11.492 <br></td></tr></tbody></table></div><br>  Secara pribadi, saya tidak melihat banyak perbedaan.  Saya menghapus <code>const</code> dari seluruh program, jadi jika ada perbedaan yang nyata, maka mudah untuk diperhatikan.  Namun, jika kinerja sangat penting bagi Anda, maka akselerasi kecil pun dapat menyenangkan Anda.  Mari kita lakukan analisis statistik. <br><br>  Saya suka menggunakan tes Mann-Whitney U untuk tugas-tugas seperti itu. Ini mirip dengan uji t yang lebih terkenal, yang dirancang untuk menentukan perbedaan dalam kelompok, tetapi lebih tahan terhadap variasi acak kompleks yang terjadi ketika mengukur waktu di komputer (karena sakelar konteks yang tidak dapat diprediksi, kesalahan dalam halaman memori, dll.).  Inilah hasilnya: <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  const </th><th>  Tanpa const </th></tr><tr><td>  N </td><td>  100 </td><td>  100 </td></tr><tr><td>  Kategori tengah (Peringkat rata-rata) </td><td>  121.38 </td><td>  79.62 </td></tr><tr><td>  Mann-whitney u </td><td></td><td>  2912 </td></tr><tr><td>  Z </td><td></td><td>  -5.10 </td></tr><tr><td>  Nilai p 2 sisi </td><td></td><td>  &lt;10 <sup>-6</sup> <br></td></tr><tr><td>  Perbedaan rata-rata adalah HL <br></td><td></td><td>  -0,056 dtk. <br></td></tr><tr><td>  Interval kepercayaan 95 persen <br></td><td></td><td>  -0,077 ... -0,038 dtk. <br></td></tr></tbody></table></div><br>  Uji U menemukan perbedaan yang signifikan secara statistik dalam kinerja.  Tapi - kejutan!  - Versi tanpa <code>const</code> ternyata lebih cepat, sekitar 60 ms, yaitu 0,5%.  Tampaknya jumlah kecil "optimasi" yang dibuat tidak sebanding dengan peningkatan jumlah kode.  Tidak mungkin <code>const</code> mengaktifkan optimasi besar apa pun, seperti auto-vektorisasi.  Tentu saja, jarak tempuh Anda mungkin bergantung pada berbagai flag di kompiler, atau pada versinya, atau pada basis kode, atau pada hal lain.  Tapi sepertinya saya jujur ‚Äã‚Äãmengatakan bahwa bahkan jika <code>const</code> meningkatkan kinerja C, saya tidak memperhatikan ini. <br><br><h2>  Jadi untuk apa const? </h2><br>  Untuk semua kekurangannya, <code>const</code> di C / C ++ berguna untuk memberikan keamanan tipe.  Khususnya, jika Anda menggunakan <code>const</code> dalam kombinasi dengan pindahkan semantik dan <code>std::unique_pointer</code> , Anda bisa mengimplementasikan kepemilikan pointer eksplisit.  Ketidakpastian kepemilikan pointer adalah masalah besar dalam basis kode C ++ lama lebih dari 100 KLOC, jadi saya berterima kasih kepada <code>const</code> untuk menyelesaikannya. <br><br>  Namun, sebelum saya menggunakan <code>const</code> untuk memberikan keamanan tipe.  Saya mendengar bahwa dianggap benar untuk menggunakan <code>const</code> mungkin untuk meningkatkan kinerja.  Saya mendengar bahwa jika kinerja benar-benar penting, maka Anda harus memperbaiki kode untuk menambahkan lebih banyak <code>const</code> , bahkan jika kode menjadi kurang dapat dibaca.  Kedengarannya masuk akal pada saat itu, tetapi sejak itu saya menyadari bahwa ini tidak benar. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id464777/">https://habr.com/ru/post/id464777/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id464763/index.html">Tolok ukur untuk server di Linux: pilihan alat terbuka</a></li>
<li><a href="../id464765/index.html">Mengkonfigurasi FreePBX + GoIP</a></li>
<li><a href="../id464769/index.html">Bagaimana Badoo memungkinkan untuk memberikan 200 ribu foto per detik</a></li>
<li><a href="../id464773/index.html">Asinkron Naskah dalam Aplikasi Internet Kaya dan Dekorator untuk Memeranginya</a></li>
<li><a href="../id464775/index.html">21 September Badoo Rapat PHP # 3: Kinerja</a></li>
<li><a href="../id464779/index.html">Tentang lebah hedonis, cara orang membuatnya bekerja dan drone</a></li>
<li><a href="../id464781/index.html">Smart TV: CRT ke HDR</a></li>
<li><a href="../id464785/index.html">Manfaat Langsung Menuju Yang Tidak Kompetitif</a></li>
<li><a href="../id464787/index.html">Saya yakin pengembang senior ponsel hanya akan datang berdasarkan rekomendasi</a></li>
<li><a href="../id464791/index.html">Kubernetes untuk mobil: cara membuka akses pengembang ke komputer yang terpasang dan membuatnya aman</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>