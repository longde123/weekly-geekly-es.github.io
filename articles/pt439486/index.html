<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèø üë©‚Äçüëß‚Äçüëß üë©üèæ‚Äçüé§ Tipos de refer√™ncia do .NET vs tipos de valor. Parte 1 üßëüèø‚Äçü§ù‚Äçüßëüèø ‚öìÔ∏è üõ°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Primeiro, vamos falar sobre tipos de refer√™ncia e tipos de valor. Eu acho que as pessoas realmente n√£o entendem as diferen√ßas e os benef√≠cios de ambos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tipos de refer√™ncia do .NET vs tipos de valor. Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/439486/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="350" align="left" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png"></a>  Primeiro, vamos falar sobre tipos de refer√™ncia e tipos de valor.  Eu acho que as pessoas realmente n√£o entendem as diferen√ßas e os benef√≠cios de ambos.  Eles geralmente dizem que os tipos de refer√™ncia armazenam conte√∫do na pilha e os tipos de valor armazenam conte√∫do na pilha, o que est√° errado. </p><br><p>  Vamos discutir as diferen√ßas reais: </p><br><ul><li>  <em>Um tipo de valor</em> : seu valor √© <strong>uma estrutura inteira</strong> .  O valor de um tipo de refer√™ncia √© <strong>uma refer√™ncia</strong> a um objeto.  - Uma estrutura na mem√≥ria: os tipos de valor cont√™m apenas os dados que voc√™ indicou.  Os tipos de refer√™ncia tamb√©m cont√™m dois campos do sistema.  O primeiro armazena 'SyncBlockIndex', o segundo armazena as informa√ß√µes sobre um tipo, incluindo as informa√ß√µes sobre uma Tabela de m√©todos virtuais (VMT). </li><li>  Os tipos de refer√™ncia podem ter m√©todos que s√£o substitu√≠dos quando herdados.  Os tipos de valor n√£o podem ser herdados. </li><li>  Voc√™ deve alocar espa√ßo no heap para uma inst√¢ncia de um tipo de refer√™ncia.  Um tipo de valor <em>pode</em> ser alocado na pilha ou ele se torna parte de um tipo de refer√™ncia.  Isso aumenta suficientemente o desempenho de alguns algoritmos. </li></ul><br><p>  No entanto, existem recursos comuns: </p><br><ul><li>  Ambas as subclasses podem herdar o tipo de objeto e se tornar seus representantes. </li></ul><br><p>  Vamos examinar mais de perto cada recurso. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo foi traduzido do russo em conjunto pelo autor e por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar com a tradu√ß√£o do russo ou do ingl√™s para qualquer outro idioma, principalmente para chin√™s ou alem√£o. <br><br>  Al√©m disso, se voc√™ quiser nos agradecer, a melhor maneira de fazer isso √© nos dar uma estrela no github ou no fork do reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/z0/iq/m6/z0iqm6nihoilvykxs3el7zujlrk.jpeg"></a> </p><a name="habracut"></a><br><p>  Vamos examinar mais de perto cada recurso. </p><br><h2 id="copying">  Copiando </h2><br><p>  A principal diferen√ßa entre os dois tipos √© a seguinte: </p><br><ul><li>  Cada vari√°vel, campos de classe ou estrutura ou par√¢metros de m√©todo que usam um tipo de refer√™ncia armazenam <strong>uma refer√™ncia</strong> a um valor; </li><li>  Mas cada vari√°vel, classe ou campo de estrutura ou par√¢metro de m√©todo que utiliza um tipo de valor armazena um valor exatamente, isto √©, uma estrutura inteira. </li></ul><br><p>  Isso significa que atribuir ou passar um par√¢metro para um m√©todo copiar√° o valor.  Mesmo se voc√™ alterar a c√≥pia, o original permanecer√° o mesmo.  No entanto, se voc√™ alterar os campos do tipo de refer√™ncia, isso "afetar√°" todas as partes com uma refer√™ncia a uma inst√¢ncia de um tipo.  Vamos olhar para o <br>  exemplo: </p><br><pre><code class="cs hljs">DateTime dt = DateTime.Now; <span class="hljs-comment"><span class="hljs-comment">// Here, we allocate space for DateTime variable when calling a method, // but it will contain zeros. Next, let's copy all // values of the Now property to dt variable DateTime dt2 = dt; // Here, we copy the value once again object obj = new object(); // Here, we create an object by allocating memory on the Small Object Heap, // and put a pointer to the object in obj variable object obj2 = obj; // Here, we copy a reference to this object. Finally, // we have one object and two references.</span></span></code> </pre> <br><p>  Parece que essa propriedade produz constru√ß√µes de c√≥digo amb√≠guas, como o <br>  mudan√ßa de c√≥digo nas cole√ß√µes: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create an array of such structures and initialize the Data field = 5 var array = new [] { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field array[0].Data = 4; // Let's check the value Console.WriteLine(array[0].Data);</code> </pre> <br><p>  H√° um pequeno truque neste c√≥digo.  Parece que obtemos a inst√¢ncia da estrutura primeiro e depois atribu√≠mos um novo valor ao campo Dados da c√≥pia.  Isso significa que devemos obter <code>5</code> novamente ao verificar o valor.  No entanto, isso n√£o acontece.  O MSIL possui uma instru√ß√£o separada para definir os valores dos campos nas estruturas de uma matriz, o que aumenta o desempenho.  O c√≥digo funcionar√° como pretendido: o programa <br>  sa√≠da <code>4</code> para um console. </p><br><p>  Vamos ver o que acontecer√° se mudarmos este c√≥digo: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field list[0].Data = 4; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  A compila√ß√£o deste c√≥digo falhar√°, porque quando voc√™ escreve a <code>list[0].Data = 4</code> voc√™ obt√©m a c√≥pia da estrutura primeiro.  Na verdade, voc√™ est√° chamando um m√©todo de inst√¢ncia do tipo <code>List&lt;T&gt;</code> subjacente ao acesso por um √≠ndice.  Ele pega a c√≥pia de uma estrutura de uma matriz interna (a <code>List&lt;T&gt;</code> armazena dados em matrizes) e retorna essa c√≥pia para voc√™ do m√©todo de acesso usando um √≠ndice.  Em seguida, voc√™ tenta modificar a c√≥pia, que n√£o √© usada mais adiante.  Este c√≥digo √© in√∫til.  Um compilador pro√≠be esse comportamento, sabendo que as pessoas abusam dos tipos de valor.  Devemos reescrever este exemplo da seguinte maneira: </p><br><pre> <code class="plaintext hljs">// Let's declare a structure struct ValueHolder { public int Data; } // Let's create a list of such structures and initialize the Data field = 5 var list = new List&lt;ValueHolder&gt; { new ValueHolder { Data = 5 } }; // Let's use an index to get the structure and put 4 in the Data field. Then, let's save it again. var copy = list[0]; copy.Data = 4; list[0] = copy; // Let's check the value Console.WriteLine(list[0].Data);</code> </pre> <br><p>  Este c√≥digo est√° correto, apesar de sua aparente redund√¢ncia.  O programa ir√° <br>  sa√≠da <code>4</code> para um console. </p><br><p>  O pr√≥ximo exemplo mostra o que quero dizer com ‚Äúo valor de uma estrutura √© um <br>  estrutura inteira " </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } int x = 5; PersonInfo person; int y = 6; // Variant 2 int x = 5; int Height; int Width; int HairColor; int y = 6;</code> </pre> <br><p>  Ambos os exemplos s√£o semelhantes em termos de localiza√ß√£o de dados na mem√≥ria, pois o valor da estrutura √© toda a estrutura.  Aloca a mem√≥ria para si mesma onde est√°. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } class Employee { public int x; public PersonInfo person; public int y; } // Variant 2 class Employee { public int x; public int Height; public int Width; public int HairColor; public int y; }</code> </pre> <br><p>  Esses exemplos tamb√©m s√£o semelhantes em termos da localiza√ß√£o dos elementos na mem√≥ria, pois a estrutura ocupa um lugar definido entre os campos da classe.  Eu n√£o digo que eles s√£o totalmente semelhantes, pois voc√™ pode operar campos de estrutura usando m√©todos de estrutura. </p><br><p>  Obviamente, esse n√£o √© o caso dos tipos de refer√™ncia.  Uma inst√¢ncia em si est√° no Small Object Heap inacess√≠vel (SOH) ou no Large Object Heap (LOH).  Um campo de classe cont√©m apenas o valor de um ponteiro para uma inst√¢ncia: um n√∫mero de 32 ou 64 bits. </p><br><p>  Vejamos o √∫ltimo exemplo para fechar o problema. </p><br><pre> <code class="plaintext hljs">// Variant 1 struct PersonInfo { public int Height; public int Width; public int HairColor; } void Method(int x, PersonInfo person, int y); // Variant 2 void Method(int x, int HairColor, int Width, int Height, int y);</code> </pre> <br><p>  Em termos de mem√≥ria, ambas as variantes de c√≥digo funcionar√£o de maneira semelhante, mas n√£o em termos de arquitetura.  N√£o √© apenas uma substitui√ß√£o de um n√∫mero vari√°vel de argumentos.  A ordem muda porque os par√¢metros do m√©todo s√£o declarados um ap√≥s o outro.  Eles s√£o colocados na pilha da mesma maneira. </p><br><p>  No entanto, a pilha cresce de endere√ßos mais altos para mais baixos.  Isso significa que a ordem de empurrar uma estrutura pe√ßa por pe√ßa ser√° diferente de empurr√°-la como um todo. </p><br><h2 id="overridable-methods-and-inheritance">  M√©todos substitu√≠veis e heran√ßa </h2><br><p>  A pr√≥xima grande diferen√ßa entre os dois tipos √© a falta de virtual <br>  tabela de m√©todos em estruturas.  Isso significa que: </p><br><ol><li>  Voc√™ n√£o pode descrever e substituir m√©todos virtuais em estruturas. </li><li>  Uma estrutura n√£o pode herdar outra.  A √∫nica maneira de emular heran√ßa √© colocar uma estrutura de tipo base no primeiro campo.  Os campos de uma estrutura "herdada" ir√£o atr√°s dos campos de uma estrutura "base" e criar√£o heran√ßa l√≥gica.  Os campos de ambas as estruturas coincidir√£o com base no deslocamento. </li><li>  Voc√™ pode passar estruturas para c√≥digo n√£o gerenciado.  No entanto, voc√™ perder√° as informa√ß√µes sobre m√©todos.  Isso ocorre porque uma estrutura √© apenas espa√ßo na mem√≥ria, preenchida com dados sem as informa√ß√µes sobre um tipo.  Voc√™ pode pass√°-lo para m√©todos n√£o gerenciados, por exemplo, escritos em C ++, sem altera√ß√µes. </li></ol><br><p>  A falta de uma tabela de m√©todos virtuais subtrai uma certa parte da ‚Äúm√°gica‚Äù de heran√ßa das estruturas, mas oferece outras vantagens.  O primeiro √© que podemos passar inst√¢ncias dessa estrutura para ambientes externos (fora do .NET Framework).  Lembre-se, isso √© apenas uma mem√≥ria <br>  alcance!  Tamb√©m podemos pegar um intervalo de mem√≥ria de c√≥digo n√£o gerenciado e converter um tipo em nossa estrutura para tornar seus campos mais acess√≠veis.  Voc√™ n√£o pode fazer isso com as classes, pois elas t√™m dois campos inacess√≠veis.  Estes s√£o SyncBlockIndex e um endere√ßo de tabela de m√©todos virtuais.  Se esses dois campos passarem para c√≥digo n√£o gerenciado, ser√° perigoso.  Usando uma tabela de m√©todos virtuais, √© poss√≠vel acessar qualquer tipo e alter√°-lo para atacar um aplicativo. </p><br><p>  Vamos mostrar que √© apenas um intervalo de mem√≥ria sem l√≥gica adicional. </p><br><pre> <code class="plaintext hljs">unsafe void Main() { int secret = 666; HeightHolder hh; hh.Height = 5; WidthHolder wh; unsafe { // This cast wouldn't work if structures had the information about a type. // The CLR would check a hierarchy before casting a type and if it didn't find WidthHolder, // it would output an InvalidCastException exception. But since a structure is a memory range, // you can interpret it as any kind of structure. wh = *(WidthHolder*)&amp;hh; } Console.WriteLine("Width: " + wh.Width); Console.WriteLine("Secret:" + wh.Secret); } struct WidthHolder { public int Width; public int Secret; } struct HeightHolder { public int Height; }</code> </pre> <br><p>  Aqui, realizamos a opera√ß√£o que √© imposs√≠vel na digita√ß√£o forte.  Lan√ßamos um tipo para outro incompat√≠vel que cont√©m um campo extra.  Introduzimos uma vari√°vel adicional dentro do m√©todo Main.  Em teoria, seu valor √© secreto.  No entanto, o c√≥digo de exemplo produzir√° o valor de uma vari√°vel, n√£o encontrada em nenhuma das estruturas dentro do m√©todo <code>Main()</code> .  Voc√™ pode considerar uma viola√ß√£o de seguran√ßa, mas as coisas n√£o s√£o t√£o simples.  Voc√™ n√£o pode se livrar do c√≥digo n√£o gerenciado em um programa.  O principal motivo √© a estrutura da pilha de threads.  Pode-se us√°-lo para acessar c√≥digo n√£o gerenciado e brincar com vari√°veis ‚Äã‚Äãlocais.  Voc√™ pode defender seu c√≥digo desses ataques aleatoriamente o tamanho de um quadro de pilha.  Ou, voc√™ pode excluir as informa√ß√µes sobre o registro <code>EBP</code> para complicar o retorno de um quadro de pilha.  No entanto, isso n√£o importa para n√≥s agora.  O que estamos interessados ‚Äã‚Äãneste exemplo √© o seguinte.  A vari√°vel "secreta" vai <strong>antes</strong> da defini√ß√£o da vari√°vel hh e <strong>depois</strong> na estrutura WidthHolder (em lugares diferentes, na verdade).  Ent√£o, por que conseguimos facilmente esse valor?  A resposta √© que a pilha cresce da direita para a esquerda.  As vari√°veis ‚Äã‚Äãdeclaradas primeiro ter√£o endere√ßos muito mais altos e as declaradas posteriormente ter√£o endere√ßos mais baixos. </p><br><h2 id="the-behavior-when-calling-instance-methods">  O comportamento ao chamar m√©todos de inst√¢ncia </h2><br><p>  Ambos os tipos de dados t√™m outro recurso que n√£o √© f√°cil de ver e pode explicar a estrutura dos dois tipos.  Ele lida com a chamada de m√©todos de inst√¢ncia. </p><br><pre> <code class="plaintext hljs">// The example with a reference type class FooClass { private int x; public void ChangeTo(int val) { x = val; } } // The example with a value type struct FooStruct { private int x; public void ChangeTo(int val) { x = val; } } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); klass.ChangeTo(10); strukt.ChangeTo(10);</code> </pre> <br><p>  Logicamente, podemos decidir que o m√©todo possui um corpo compilado.  Em outras palavras, n√£o h√° inst√¢ncia de um tipo que tenha seu pr√≥prio conjunto compilado de m√©todos, semelhante aos conjuntos de outras inst√¢ncias.  No entanto, o m√©todo chamado sabe a qual inst√¢ncia pertence, como refer√™ncia √† inst√¢ncia de um tipo √© o primeiro par√¢metro.  Podemos reescrever nosso exemplo e ser√° id√™ntico ao que dissemos antes.  N√£o estou usando um exemplo deliberadamente com m√©todos virtuais, pois eles t√™m outro procedimento. </p><br><pre> <code class="plaintext hljs">// An example with a reference type class FooClass { public int x; } // An example with a value type struct FooStruct { public int x; } public void ChangeTo(FooClass klass, int val) { klass.x = val; } public void ChangeTo(ref FooStruct strukt, int val) { strukt.x = val; } FooClass klass = new FooClass(); FooStruct strukt = new FooStruct(); ChangeTo(klass, 10); ChangeTo(ref strukt, 10);</code> </pre> <br><p>  Eu devo explicar o uso da palavra-chave ref.  Se n√£o o usasse, obteria uma <strong>c√≥pia</strong> da estrutura como par√¢metro de m√©todo em vez do original.  Ent√£o eu mudaria, mas o original continuaria o mesmo.  Eu precisaria retornar uma c√≥pia alterada de um m√©todo para um chamador (outra c√≥pia), e o chamador salvaria esse valor novamente na vari√°vel (mais uma c√≥pia).  Em vez disso, um m√©todo de inst√¢ncia obt√©m um ponteiro e o utiliza para alterar o original imediatamente.  O uso de um ponteiro n√£o influencia o desempenho, pois qualquer opera√ß√£o no n√≠vel do processador usa ponteiros.  Ref √© uma parte do mundo C #, n√£o mais. </p><br><h2 id="the-capability-to-point-to-the-position-of-elements">  A capacidade de apontar para a posi√ß√£o dos elementos. </h2><br><p>  As estruturas e as classes t√™m outra capacidade de apontar para o deslocamento de um campo espec√≠fico em rela√ß√£o ao in√≠cio de uma estrutura na mem√≥ria.  Isso serve a v√°rios prop√≥sitos: </p><br><ul><li>  trabalhar com APIs externas no mundo n√£o gerenciado sem precisar inserir campos n√£o utilizados antes de um necess√°rio; </li><li>  para instruir um compilador a localizar um campo logo no in√≠cio do tipo ( <code>[FieldOffset(0)]</code> ).  Isso tornar√° o trabalho com esse tipo mais r√°pido.  Se for um campo usado com frequ√™ncia, podemos aumentar o desempenho do aplicativo.  No entanto, isso √© verdade apenas para tipos de valor.  Nos tipos de refer√™ncia, o campo com deslocamento zero cont√©m o endere√ßo de uma tabela de m√©todos virtuais, que leva 1 palavra de m√°quina.  Mesmo se voc√™ endere√ßar o primeiro campo de uma classe, ele usar√° endere√ßamento complexo (endere√ßo + deslocamento).  Isso ocorre porque o campo de classe mais usado √© o endere√ßo de uma tabela de m√©todos virtuais.  A tabela √© necess√°ria para chamar todos os m√©todos virtuais; </li><li>  para apontar para v√°rios campos usando um endere√ßo.  Nesse caso, o mesmo valor √© interpretado como tipos de dados diferentes.  Em C ++, esse tipo de dados √© chamado de uni√£o; </li><li>  para n√£o se preocupar em declarar nada: um compilador alocar√° os campos de maneira ideal.  Assim, a ordem final dos campos pode ser diferente. </li></ul><br><p>  <strong>Observa√ß√µes gerais</strong> </p><br><ul><li>  <strong>Autom√°tico</strong> : o ambiente de tempo de execu√ß√£o escolhe automaticamente um local e uma embalagem para todos os campos de classe ou estrutura.  As estruturas definidas marcadas por um membro dessa enumera√ß√£o n√£o podem passar para o c√≥digo n√£o gerenciado.  A tentativa de fazer isso produzir√° uma exce√ß√£o; </li><li>  <strong>Expl√≠cito</strong> : um programador controla explicitamente a localiza√ß√£o exata de cada campo de um tipo com o FieldOffsetAttribute; </li><li>  <strong>Sequencial</strong> : os membros do tipo v√™m em uma ordem sequencial, definida durante o design do tipo.  O valor StructLayoutAttribute.Pack de uma etapa de empacotamento indica sua localiza√ß√£o. </li></ul><br><p>  <strong>Usando FieldOffset para pular campos de estrutura n√£o utilizados</strong> </p><br><p>  As estruturas provenientes do mundo n√£o gerenciado podem conter campos reservados.  Pode-se us√°-los em uma vers√£o futura de uma biblioteca.  Em C / C ++, preenchemos essas lacunas adicionando campos, por exemplo, reservados1, reservados2, ... No entanto, no .NET apenas compensamos o in√≠cio de um campo usando o atributo FieldOffsetAttribute e <code>[StructLayout(LayoutKind.Explicit)]</code> . </p><br><pre> <code class="plaintext hljs">[StructLayout(LayoutKind.Explicit)] public struct SYSTEM_INFO { [FieldOffset(0)] public ulong OemId; // 92 bytes reserved [FieldOffset(100)] public ulong PageSize; [FieldOffset(108)] public ulong ActiveProcessorMask; [FieldOffset(116)] public ulong NumberOfProcessors; [FieldOffset(124)] public ulong ProcessorType; }</code> </pre> <br><p>  Uma lacuna √© ocupada, mas n√£o √© utilizada.  A estrutura ter√° o tamanho igual a 132 e n√£o 40 bytes, como pode parecer desde o in√≠cio. </p><br><p>  <strong>Uni√£o</strong> </p><br><p>  Usando o FieldOffsetAttribute, voc√™ pode emular o tipo C / C ++ chamado uni√£o.  Permite acessar os mesmos dados que as entidades de <br>  tipos diferentes.  Vejamos o exemplo: </p><br><pre> <code class="plaintext hljs">// If we read the RGBA.Value, we will get an Int32 value accumulating all // other fields. // However, if we try to read the RGBA.R, RGBA.G, RGBA.B, RGBA.Alpha, we // will get separate components of Int32. [StructLayout(LayoutKind.Explicit)] public struct RGBA { [FieldOffset(0)] public uint Value; [FieldOffset(0)] public byte R; [FieldOffset(1)] public byte G; [FieldOffset(2)] public byte B; [FieldOffset(3)] public byte Alpha; }</code> </pre> <br><p>  Voc√™ pode dizer que esse comportamento √© poss√≠vel apenas para tipos de valor.  No entanto, voc√™ pode simul√°-lo para tipos de refer√™ncia, usando um endere√ßo para sobrepor dois tipos de refer√™ncia ou um tipo de refer√™ncia e um tipo de valor: </p><br><pre> <code class="plaintext hljs">class Program { public static void Main() { Union x = new Union(); x.Reference.Value = "Hello!"; Console.WriteLine(x.Value.Value); } [StructLayout(LayoutKind.Explicit)] public class Union { public Union() { Value = new Holder&lt;IntPtr&gt;(); Reference = new Holder&lt;object&gt;(); } [FieldOffset(0)] public Holder&lt;IntPtr&gt; Value; [FieldOffset(0)] public Holder&lt;object&gt; Reference; } public class Holder&lt;T&gt; { public T Value; } }</code> </pre> <br><p>  Eu usei um tipo gen√©rico para sobrepor-se de prop√≥sito.  Se eu usasse o habitual <br>  sobreposto, esse tipo causaria a TypeLoadException quando carregada em um dom√≠nio de aplicativo.  Pode parecer uma viola√ß√£o de seguran√ßa na teoria (especialmente quando se trata de <strong>plug-ins de</strong> aplicativos), mas se tentarmos executar esse c√≥digo usando um dom√≠nio protegido, obteremos a mesma <code>TypeLoadException</code> . </p><br><h2 id="the-difference-in-allocation">  A diferen√ßa na aloca√ß√£o </h2><br><p>  Outro recurso que diferencia os dois tipos √© a aloca√ß√£o de mem√≥ria para objetos ou estruturas.  O CLR deve decidir sobre v√°rias coisas antes de alocar mem√≥ria para um objeto.  Qual √© o tamanho de um objeto?  √â mais ou menos que 85K?  Se for menor, h√° espa√ßo livre suficiente no SOH para alocar esse objeto?  Se for mais, o CLR ativa o Garbage Collector.  Ele percorre um gr√°fico de objetos, compacta os objetos, movendo-os para o espa√ßo livre.  Se ainda n√£o houver espa√ßo no SOH, a aloca√ß√£o de p√°ginas adicionais de mem√≥ria virtual ser√° iniciada.  S√≥ ent√£o √© que um objeto recebe espa√ßo alocado, limpo do lixo.  Posteriormente, o CLR estabelece SyncBlockIndex e VirtualMethodsTable.  Finalmente, a refer√™ncia a um objeto retorna ao usu√°rio. </p><br><p>  Se um objeto alocado for maior que 85K, ele ser√° direcionado para a Pilha de Objetos Grandes (LOH).  √â o caso de grandes seq√º√™ncias de caracteres e matrizes.  Aqui, devemos encontrar o espa√ßo mais adequado na mem√≥ria da lista de intervalos desocupados ou alocar um novo.  N√£o √© r√°pido, mas vamos lidar com objetos desse tamanho com cuidado.  Al√©m disso, n√£o vamos falar sobre eles aqui. </p><br><p>  Existem v√°rios cen√°rios poss√≠veis para RefTypes: </p><br><ul><li>  RefType &lt;85K, h√° espa√ßo no SOH: aloca√ß√£o r√°pida de mem√≥ria; </li><li>  RefType &lt;85K, o espa√ßo no SOH est√° acabando: aloca√ß√£o de mem√≥ria muito lenta; </li><li>  RefType&gt; 85K, aloca√ß√£o lenta de mem√≥ria. </li></ul><br><p>  Tais opera√ß√µes s√£o raras e n√£o podem competir com os ValTypes.  O algoritmo de aloca√ß√£o de mem√≥ria para tipos de valor n√£o existe.  A aloca√ß√£o de mem√≥ria para tipos de valor n√£o custa nada.  A √∫nica coisa que acontece ao alocar mem√≥ria para esse tipo √© definir os campos como nulos.  Vamos ver por que isso acontece: 1. Quando se declara uma vari√°vel no corpo de um m√©todo, o tempo de aloca√ß√£o de mem√≥ria para uma estrutura √© pr√≥ximo de zero.  Isso ocorre porque o tempo de aloca√ß√£o para vari√°veis ‚Äã‚Äãlocais n√£o depende do n√∫mero deles;  2. Se ValTypes forem alocados como campos, Reftypes aumentar√° o tamanho dos campos.  Um tipo de valor √© alocado inteiramente, tornando-se sua parte;  3. Como no caso de c√≥pia, se ValTypes s√£o passados ‚Äã‚Äãcomo par√¢metros de m√©todo, aparece uma diferen√ßa, dependendo do tamanho e do local de um par√¢metro. </p><br><p>  No entanto, isso n√£o leva mais tempo do que copiar uma vari√°vel para outra. </p><br><h2 id="the-choice-between-a-class-or-a-structure">  A escolha entre uma classe ou uma estrutura </h2><br><p>  Vamos discutir as vantagens e desvantagens de ambos os tipos e decidir sobre seus cen√°rios de uso.  Um princ√≠pio cl√°ssico diz que devemos escolher um tipo de valor se ele n√£o for maior que 16 bytes, permanecer inalterado durante sua vida √∫til e n√£o for herdado.  No entanto, escolher o tipo certo significa revis√°-lo de diferentes perspectivas, com base em cen√°rios de uso futuro.  Proponho tr√™s grupos de crit√©rios: </p><br><ul><li>  com base na arquitetura do sistema de tipos, na qual seu tipo ir√° interagir; </li><li>  com base em sua abordagem como programador de sistema para escolher um tipo com desempenho ideal; </li><li>  quando n√£o h√° outra escolha. </li></ul><br><p>  Cada recurso projetado deve refletir seu objetivo.  Isso n√£o trata apenas do nome ou da interface de intera√ß√£o (m√©todos, propriedades).  Pode-se usar considera√ß√µes arquitet√¥nicas para escolher entre os tipos de valor e refer√™ncia.  Vamos pensar por que uma estrutura e n√£o uma classe podem ser escolhidas do ponto de vista do sistema de tipos. </p><br><ol><li><p>  Se o seu tipo projetado for independente do estado, isso significa que o estado reflete um processo ou √© um valor de alguma coisa.  Em outras palavras, uma inst√¢ncia de um tipo √© constante e imut√°vel por natureza.  Podemos criar outra inst√¢ncia de um tipo com base nessa constante, indicando algum deslocamento.  Ou, podemos criar uma nova inst√¢ncia indicando suas propriedades.  No entanto, n√£o devemos mudar isso.  N√£o quero dizer que a estrutura seja do tipo imut√°vel.  Voc√™ pode alterar seus valores de campo.  Al√©m disso, voc√™ pode passar uma refer√™ncia a uma estrutura para um m√©todo usando o par√¢metro ref e obter√° campos alterados ap√≥s sair do m√©todo.  O que falo aqui √© sobre o sentido arquitet√¥nico.  Vou dar v√°rios exemplos. </p><br><ul><li>  DateTime √© uma estrutura que encapsula o conceito de um momento no tempo.  Ele armazena esses dados como um uint, mas fornece acesso a caracter√≠sticas separadas de um momento no tempo: ano, m√™s, dia, hora, minutos, segundos, milissegundos e at√© tiques de processador.  No entanto, √© imut√°vel, com base no que encapsula.  N√£o podemos mudar um momento no tempo.  N√£o posso viver o pr√≥ximo minuto como se fosse meu melhor anivers√°rio de inf√¢ncia.  Portanto, se escolhermos um tipo de dados, podemos escolher uma classe com uma interface somente leitura, que produz uma nova inst√¢ncia para cada altera√ß√£o de propriedades.  Ou, podemos escolher uma estrutura, que pode, mas n√£o deve, alterar os campos de suas inst√¢ncias: seu <em>valor</em> √© a descri√ß√£o de um momento no tempo, como um n√∫mero.  Voc√™ n√£o pode acessar a estrutura de um n√∫mero e alter√°-lo.  Se voc√™ deseja obter outro momento no tempo, que difere por um dia do original, voc√™ receber√° uma nova inst√¢ncia de uma estrutura. </li><li>  <code>KeyValuePair&lt;TKey, TValue&gt;</code> √© uma estrutura que encapsula o conceito de um par de valores-chave conectado.  Essa estrutura √© apenas para gerar o conte√∫do de um dicion√°rio durante a enumera√ß√£o.  Do ponto de vista arquitet√¥nico, uma chave e um valor s√£o conceitos insepar√°veis ‚Äã‚Äãno <code>Dictionary&lt;T&gt;</code> .  No entanto, por dentro, temos uma estrutura complexa, onde uma chave est√° separada de um valor.  Para um usu√°rio, um par de valores-chave √© um conceito insepar√°vel em termos de interface e o significado de uma estrutura de dados.  √â um <em>valor</em> inteiro em si.  Se algu√©m atribuir outro valor para uma chave, todo o par ser√° alterado.  Assim, eles representam uma √∫nica entidade.  Isso torna uma estrutura uma variante ideal nesse caso. </li></ul><br></li><li><p>  Se o seu tipo projetado √© uma parte insepar√°vel de um tipo externo, mas √© integralmente estrutural.  Isso significa que √© incorreto dizer que o tipo externo se refere a uma inst√¢ncia de um tipo encapsulado.  No entanto, √© correto dizer que um tipo encapsulado faz parte de um externo junto com todas as suas propriedades.  Isso √© √∫til ao projetar uma estrutura que faz parte de outra estrutura. </p><br><ul><li>  Por exemplo, se usarmos a estrutura de um cabe√ßalho de arquivo, n√£o ser√° apropriado passar uma refer√™ncia de um arquivo para outro, por exemplo, algum arquivo header.txt.  Isso seria apropriado ao inserir um documento em outro, n√£o incorporando um arquivo, mas usando uma refer√™ncia em um sistema de arquivos.  Um bom exemplo s√£o os arquivos de atalho no sistema operacional Windows.  No entanto, se falarmos sobre um cabe√ßalho de arquivo (por exemplo, cabe√ßalho de arquivo JPEG contendo metadados sobre tamanho de imagem, m√©todos de compress√£o, par√¢metros de fotografia, coordenadas GPS e outros), devemos usar estruturas para projetar tipos para analisar o cabe√ßalho.  Se voc√™ descrever todos os cabe√ßalhos das estruturas, obter√° a mesma posi√ß√£o dos campos na mem√≥ria que em um arquivo.  Utilizando uma transforma√ß√£o <code>*(Header *)readedBuffer</code> simples e n√£o segura <code>*(Header *)readedBuffer</code> sem desserializa√ß√£o, voc√™ obter√° estruturas de dados totalmente preenchidas. </li></ul><br></li></ol><br><ol><li>  Nenhum dos exemplos mostra a heran√ßa do comportamento.  Eles mostram que n√£o h√° necessidade de herdar o comportamento dessas entidades.  Eles s√£o independentes.  No entanto, se considerarmos a efic√°cia do c√≥digo, veremos a escolha de outro lado: </li><li>  Se precisarmos pegar alguns dados estruturados de c√≥digo n√£o gerenciado, devemos escolher estruturas.  Tamb√©m podemos passar a estrutura de dados para um m√©todo n√£o seguro.  Um tipo de refer√™ncia n√£o √© adequado para isso. </li><li>  Uma estrutura √© sua escolha se um tipo passa os dados em chamadas de m√©todo (como valores retornados ou como par√¢metro de m√©todo) e n√£o h√° necessidade de se referir ao mesmo valor de locais diferentes.  O exemplo perfeito √© tuplas.  Se um m√©todo retornar v√°rios valores usando tuplas, ele retornar√° um ValueTuple, declarado como uma estrutura.  O m√©todo n√£o alocar√° espa√ßo no heap, mas utilizar√° a pilha do encadeamento, onde a aloca√ß√£o de mem√≥ria n√£o custa nada. </li><li>  Se voc√™ criar um sistema que crie grande tr√°fego de inst√¢ncias com tamanho e vida √∫til pequenos, o uso de tipos de refer√™ncia levar√° a um conjunto de objetos ou, se sem o conjunto de objetos, a um ac√∫mulo de lixo n√£o controlado no heap.  Alguns objetos se transformar√£o em gera√ß√µes mais antigas, aumentando a carga no GC.  O uso de tipos de valor nesses locais (se poss√≠vel) aumentar√° o desempenho porque nada passar√° para o SOH.  Isso diminuir√° a carga no GC e o algoritmo funcionar√° mais rapidamente; </li></ol><br><p>  Baseando-se no que eu disse, aqui est√£o alguns conselhos sobre o uso de estruturas: </p><br><ol><li>  Ao escolher cole√ß√µes, voc√™ deve evitar grandes matrizes que armazenam grandes estruturas.  Isso inclui estruturas de dados baseadas em matrizes.  Isso pode levar a uma transi√ß√£o para o Heap de objetos grandes e sua fragmenta√ß√£o.  √â errado pensar que, se nossa estrutura tiver 4 campos do tipo byte, ser√£o necess√°rios 4 bytes.  Devemos entender que, nos sistemas de 32 bits, cada campo de estrutura √© alinhado nos limites de 4 bytes (cada campo de endere√ßo deve ser dividido exatamente por 4) e nos sistemas de 64 bits - nos limites de 8 bytes.  O tamanho de uma matriz deve depender do tamanho de uma estrutura e plataforma, executando um programa.  No nosso exemplo, com 4 bytes - 85K / (de 4 a 8 bytes por campo * o n√∫mero de campos = 4) menos o tamanho do cabe√ßalho de uma matriz √© igual a cerca de 2 600 elementos por matriz, dependendo da plataforma (isso deve ser arredondado para baixo )  Isso n√£o √© muito.  Pode parecer que podemos facilmente alcan√ßar uma constante m√°gica de 20.000 elementos </li><li>  √Äs vezes, voc√™ usa uma estrutura de tamanho grande como fonte de dados e a coloca como campo em uma classe, enquanto uma c√≥pia √© replicada para produzir milhares de inst√¢ncias.  Ent√£o voc√™ expande cada inst√¢ncia de uma classe para o tamanho de uma estrutura.  Isso levar√° ao aumento da gera√ß√£o zero e √† transi√ß√£o para a gera√ß√£o um e at√© dois.  Se as inst√¢ncias de uma classe tiverem um curto per√≠odo de vida e voc√™ achar que o GC as coletar√° na gera√ß√£o zero - por 1 ms, voc√™ ficar√° desapontado.  Eles j√° est√£o na gera√ß√£o um e at√© dois.  Isso faz a diferen√ßa.  Se o GC coletar a gera√ß√£o zero por 1 ms, as gera√ß√µes uma e duas ser√£o coletadas muito lentamente, o que levar√° a uma diminui√ß√£o na efici√™ncia; </li><li>  Pelo mesmo motivo, voc√™ deve evitar passar grandes estruturas por meio de uma s√©rie de chamadas de m√©todo.  Se todos os elementos se chamarem, essas chamadas ocupar√£o mais espa√ßo na pilha e matar√£o seu aplicativo por StackOverflowException.  O pr√≥ximo motivo √© o desempenho.  Quanto mais c√≥pias houver, mais lentamente tudo funcionar√°. </li></ol><br><p>  √â por isso que a escolha de um tipo de dados n√£o √© um processo √≥bvio.  Geralmente, isso pode se referir a uma otimiza√ß√£o prematura, o que n√£o √© recomendado.  No entanto, se voc√™ souber que sua situa√ß√£o se enquadra nos princ√≠pios mencionados acima, poder√° escolher facilmente um tipo de valor. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo foi traduzido do russo em conjunto pelo autor e por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar com a tradu√ß√£o do russo ou do ingl√™s para qualquer outro idioma, principalmente para chin√™s ou alem√£o. <br><br>  Al√©m disso, se voc√™ quiser nos agradecer, a melhor maneira de fazer isso √© nos dar uma estrela no github ou no fork do reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt439486/">https://habr.com/ru/post/pt439486/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt439476/index.html">G√≠ria de Cockney: hist√≥ria moderna e status social</a></li>
<li><a href="../pt439478/index.html">C # divertido. Cinco exemplos de coffee breaks</a></li>
<li><a href="../pt439480/index.html">Desista, ou por que seu CRM (e CRM) fica mais lento?</a></li>
<li><a href="../pt439482/index.html">devleads - (des) motiva√ß√£o financeira</a></li>
<li><a href="../pt439484/index.html">Obtendo dados de enumera√ß√£o em uma perspectiva do Automapper</a></li>
<li><a href="../pt439488/index.html">Grava√ß√£o de v√≠deo de controle de qualidade Meetup</a></li>
<li><a href="../pt439490/index.html">Tipos de refer√™ncia do .NET vs tipos de valor. Parte 2</a></li>
<li><a href="../pt439492/index.html">10 dicas para ser um bom l√≠der t√©cnico</a></li>
<li><a href="../pt439496/index.html">Como o faturamento √© feito l√°: quando o cliente e o desenvolvedor falam idiomas diferentes</a></li>
<li><a href="../pt439498/index.html">Em qual hardware analisar uma enorme quantidade de informa√ß√µes?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>