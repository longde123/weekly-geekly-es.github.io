<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíç üññüèæ üåú ¬øC√≥mo escrib√≠ la biblioteca est√°ndar de C ++ 11 o por qu√© boost es tan aterrador? Cap√≠tulo 4.3 üë®üèø‚Äçüéì üòï ü§´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Resumen de partes anteriores 
 Debido a las restricciones en la capacidad de usar compiladores de C ++ 11, y por la falta de alternativa, boost quer√≠a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øC√≥mo escrib√≠ la biblioteca est√°ndar de C ++ 11 o por qu√© boost es tan aterrador? Cap√≠tulo 4.3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418347/"><img src="https://habrastorage.org/webt/lr/zq/if/lrzqifvfeajppx2fdvqbxnwf4ce.png" alt="Seguimos la aventura." width="300" height="350" align="left"><h3>  Resumen de partes anteriores </h3><br>  Debido a las restricciones en la capacidad de usar compiladores de C ++ 11, y por la falta de alternativa, boost quer√≠a escribir su propia implementaci√≥n de la biblioteca est√°ndar de C ++ 11 sobre la biblioteca de C ++ 98 / C ++ 03 suministrada con el compilador. <br><br>  Se implementaron <b>Static_assert</b> , <b>noexcept</b> , <b>countof</b> , y tambi√©n, despu√©s de considerar todas las caracter√≠sticas de compilador y definiciones no est√°ndar, apareci√≥ informaci√≥n sobre la funcionalidad que es compatible con el compilador actual.  Se <b>incluye</b> su propia implementaci√≥n de <b>nullptr</b> , que se selecciona en la etapa de compilaci√≥n. <br><br>  Ha llegado el momento de <b>type_traits</b> y toda esta "plantilla m√°gica especial".  En las partes anteriores de este cap√≠tulo, examinamos mi implementaci√≥n de las plantillas b√°sicas de la biblioteca est√°ndar, y en esta parte hablaremos sobre la combinaci√≥n de la t√©cnica SFINAE con plantillas y un poco sobre la generaci√≥n de c√≥digo. <br><br>  Enlace a GitHub con el resultado de hoy para impacientes y no lectores: <br><blockquote>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Los compromisos y las cr√≠ticas constructivas son bienvenidos</a></b> </blockquote>  M√°s plantillas de C ++ en cat. <br><a name="habracut"></a><br><h4>  Tabla de contenidos </h4><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Introduccion</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 1. Viam supervadet vadens</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 2. #ifndef __CPP11_SUPPORT__ #define __COMPILER_SPECIFIC_BUILT_IN_AND_MACRO_HELL__ #endif</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 3. Encontrar la implementaci√≥n nullptr perfecta</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cap√≠tulo 4. Magia de plantilla de C ++</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.1 Comenzamos peque√±o</a> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.2 Acerca de cu√°ntos errores milagrosos compila el registro para nosotros</a> <br>  .... <b>4.3 Punteros y todo-todo-todo</b> <br>  .... <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">4.4 ¬øQu√© m√°s se necesita para la biblioteca de plantillas?</a> <br>  Capitulo 5 <br>  ... <br><br><h3>  Cap√≠tulo 4. Plantilla "m√°gica" C ++.  Continuaci√≥n </h3><br><h4>  4.3 Punteros y todo-todo-todo </h4><br>  En esta etapa, solo pude obtener informaci√≥n sobre si el tipo es una matriz para <i>std :: is_array</i> y fue posible iniciar plantillas para punteros.  La implementaci√≥n tambi√©n fue trivial, pero no sin supuestos. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_array template&lt;class&gt; struct is_array : public false_type { }; template&lt;class _Tp, std::size_t _Size&gt; struct is_array&lt;_Tp[_Size]&gt; : public true_type { }; /*template&lt;class _Tp&gt; struct is_array&lt;_Tp[]&gt;: public true_type { }; */</span></span></code> </pre> <br>  Una especializaci√≥n de plantilla simple para matrices de una longitud dada "captura" todos los tipos de matrices, sin embargo, el problema surge con el tipo incompleto <i>T []</i> (una matriz sin especificar la longitud).  El hecho es que este tipo no est√° definido por algunos compiladores (C ++ Builder) cuando se especializa una plantilla, y todav√≠a no he encontrado una soluci√≥n universal aqu√≠. <br><br>  Despu√©s de que la biblioteca fue "ense√±ada" a definir tipos incorporados, alineaci√≥n en la memoria de tipos, trabajar con modificadores de tipos y otras cosas b√°sicas a trav√©s de plantillas en tiempo de compilaci√≥n, lleg√≥ el momento de los punteros y las referencias. <br><br><img src="https://habrastorage.org/webt/ti/rp/mi/tirpmiwggsavcvlxyjbo8dlv5ee.png" alt="imagen" width="300" height="280" align="left">  En C ++, se pueden distinguir dos grupos de punteros: punteros a miembros de la clase y punteros a otros objetos.  ¬øPor qu√© es importante esta separaci√≥n para una mayor implementaci√≥n de la biblioteca est√°ndar?  El hecho es que los punteros a los miembros de la clase tienen una diferencia significativa de otros punteros por la presencia de <b>esto</b> , es decir.  puntero a un objeto de esta clase.  Y, de manera est√°ndar, los punteros a un miembro de la clase tienen una sintaxis separada para definir, son un tipo separado y no pueden representarse a trav√©s de un puntero regular.  En la pr√°ctica, esto se traduce en el hecho de que el tama√±o de un puntero a un miembro de la clase suele ser mayor que el tama√±o de un puntero regular (que <i>==</i> <b>sizeof (void *)</b> ), porque  Para implementar funciones de miembro virtuales de la clase, as√≠ como para almacenar <b>este</b> puntero, los compiladores generalmente implementan punteros a un miembro de clase como una estructura (lea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">sobre</a> las funciones y la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estructura</a> virtuales).  La forma de presentar punteros a los miembros de la clase se deja, seg√∫n el est√°ndar, a discreci√≥n del compilador, pero recordaremos esta diferencia de tama√±o y presentaci√≥n cuando consideremos m√°s c√≥digo. <br><br>  Para definir un puntero regular a un objeto, escribiremos una plantilla simple <i>is_pointer</i> , as√≠ como una plantilla <i>is_lvalue_reference</i> para referencias de objeto ( <i>dejamos de lado la</i> referencia is_rvalue_reference, porque hasta el und√©cimo est√°ndar no hab√≠a operador <i>&amp;&amp;</i> , as√≠ como toda la sem√°ntica de movimiento): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_pointer_helper</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_pointer_helper</span></span></span><span class="hljs-class">&lt;_Tp*&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type { }; } <span class="hljs-comment"><span class="hljs-comment">// is_pointer template&lt;class _Tp&gt; struct is_pointer : public detail::_is_pointer_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { }; // is_lvalue_reference template&lt;class&gt; struct is_lvalue_reference : public false_type { }; template&lt;class _Tp&gt; struct is_lvalue_reference&lt;_Tp&amp;&gt; : public true_type { };</span></span></code> </pre><br>  Ya no hay nada fundamentalmente nuevo aqu√≠, todo lo mismo se hizo en las partes anteriores de este cap√≠tulo.  Continuemos definiendo punteros a objetos; ahora veamos punteros a funciones. <br><blockquote>  Es importante comprender que una funci√≥n y una funci√≥n miembro de una clase son entidades completamente diferentes seg√∫n el est√°ndar: <br><br><ul><li>  El primer puntero ser√° normal (un puntero a un objeto), el segundo tendr√° un puntero a un miembro de la clase. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*func_ptr)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'func_ptr'    'void func(int){}' void (ClassType::*mem_func_ptr)(int); //  'mem_func_ptr'  -  'ClassType'  'void ClassType::func(int){}'</span></span></code> </pre><br><ul><li>  Puede crear un enlace al primero (enlace de objeto), pero no puede crear un segundo enlace. </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (&amp;func_ref)(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  'func_ref'    'void func(int){}' //-------------------- //   -    </span></span></code> </pre></blockquote>  Aqu√≠ solo mencionar√© un poco sobre la generaci√≥n de c√≥digo.  Como antes de C ++ 11 no hab√≠a plantillas con un n√∫mero variable de par√°metros, todas las plantillas donde podr√≠a haber un n√∫mero diferente de par√°metros se <a href="">determinaron mediante la especializaci√≥n de la plantilla principal con cualquier gran n√∫mero de par√°metros</a> en la entrada y su inicializaci√≥n por par√°metros ficticios predeterminados.  Lo mismo se aplica a las sobrecargas de funciones, como  Tampoco hubo macros con un n√∫mero variable de par√°metros.  Dado que escribir 60-70 l√≠neas del mismo tipo de especializaciones de plantillas con sus manos, la sobrecarga de funciones es una tarea bastante aburrida e in√∫til, y tambi√©n est√° cargada de la posibilidad de cometer un error. Escrib√≠ un generador simple de c√≥digo para plantillas y sobrecargas de funciones para estos fines.  Decid√≠ limitarme a definir funciones a 24 par√°metros y esto parece bastante engorroso en el c√≥digo, pero simple y claro: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class"> :</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)()&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(...)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0 ...)&gt; :</span></span> true_type {};</code> </pre><br>  <b>...</b> <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T6</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T7</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T8</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T9</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T10</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T11</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T12</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T13</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T14</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T15</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T16</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T17</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T18</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T19</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T20</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T21</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T22</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T23</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T24</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24)&gt; :</span></span> true_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T0</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T1</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T2</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T3</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T4</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T5</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T6</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T7</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T8</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T9</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T10</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T11</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T12</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T13</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T14</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T15</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T16</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T17</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T18</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T19</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T20</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T21</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T22</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T23</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T24</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_ptr_helper</span></span></span><span class="hljs-class">&lt;R(*)(T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24 ...)&gt; :</span></span> true_type {}; }</code> </pre><br>  Definimos los tipos que nos son familiares del cap√≠tulo anterior para la t√©cnica SFINAE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-comment"><span class="hljs-comment">// SFINAE magic typedef char _yes_type; struct _no_type { char padding[8]; }; }</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Algunas macros m√°s por conveniencia</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IS_MEM_FUN_PTR_CLR \ template </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS) const volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(T::*const volatile*)(ARGS...) const volatile); #ifdef _STDEX_CDECL _no_type _STDEX_CDECL _is_mem_function_ptr(...); #define _IS_MEM_FUN_CDECL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__cdecl T::*const volatile*)(ARGS) const volatile); #define _IS_MEM_FUN_STDCALL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__stdcall T::*const volatile*)(ARGS) const volatile); #define _IS_MEM_FUN_FASTCALL_PTR \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS)); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) const); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) volatile); \ template &lt;class R, class T TYPES &gt; \ _yes_type _is_mem_function_ptr(R(__fastcall T::*const volatile*)(ARGS) const volatile); #else _no_type _is_mem_function_ptr(...); #define _IS_MEM_FUN_CDECL_PTR #define _IS_MEM_FUN_STDCALL_PTR #define _IS_MEM_FUN_FASTCALL_PTR #endif #define _IS_MEM_FUN_PTR \ _IS_MEM_FUN_PTR_CLR \ _IS_MEM_FUN_CDECL_PTR \ _IS_MEM_FUN_STDCALL_PTR \ _IS_MEM_FUN_FASTCALL_PTR }</span></span></span></span></code> </pre><br></div></div><br>  Las macros se definen para que sea relativamente conveniente redefinir <b>TIPOS</b> y <b>ARGS las</b> defina como una lista de tipos y par√°metros, luego sustituya la macro <b>_IS_MEM_FUN_PTR para</b> generar definiciones para todos los tipos de funciones posibles por parte del preprocesador.  Tambi√©n vale la pena prestar atenci√≥n al hecho de que para los compiladores de Microsoft, los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acuerdos de llamadas</a> ( <b>__fastcall</b> , <b>__stdcall</b> y <b>__cdecl</b> ) tambi√©n son <b>importantes</b> , porque  con diferentes convenciones, las funciones ser√°n diferentes, aunque tengan el mismo conjunto de argumentos y valor de retorno.  Como resultado, todo este grandioso dise√±o macro se usa de manera bastante compacta: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0, class T1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0, T1 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS</span></span></code> </pre><br>  <b>...</b> <br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TYPES , class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> ARGS T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24 _IS_MEM_FUN_PTR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> TYPES #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> ARGS </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//      define  : #undef _IS_MEM_FUN_PTR #undef _IS_MEM_FUN_PTR_CLR #undef _IS_MEM_FUN_CDECL_PTR #undef _IS_MEM_FUN_STDCALL_PTR #undef _IS_MEM_FUN_FASTCALL_PTR }</span></span></span></span></code> </pre><br>  Y ahora por lo que estaba escrito: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsRef</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_impl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> _Tp *p; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(_is_mem_function_ptr(_is_mem_function_ptr_impl::p)) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(_yes_type)); <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, _is_mem_function_ptr_impl::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)&gt;::type type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_impl</span></span></span><span class="hljs-class">&lt;_Tp, true&gt;:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_mem_function_ptr_helper</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _is_mem_function_ptr_impl&lt;_Tp, is_reference&lt;_Tp&gt;::value&gt;::type {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMemberFunctionPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser_impl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser_impl</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _is_function_ptr_helper&lt;_Tp*&gt; { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsRef</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">true</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_function_chooser</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = _is_function_chooser_impl&lt;_Tp, _is_mem_function_ptr_helper&lt;_Tp&gt;::value&gt;::value; }; }</code> </pre><br>  Para verificar si un tipo es una funci√≥n miembro de una clase, primero se verifica para ver si el tipo es una referencia.  Luego se crea un puntero de este tipo y se sustituye en la funci√≥n de sonda.  Utilizando la t√©cnica SFINAE, el compilador selecciona la sobrecarga necesaria de las funciones de la sonda para dicho puntero y, en funci√≥n del resultado de la comparaci√≥n con <i>_yes_type,</i> forma el resultado. <br><br>  Basado en una verificaci√≥n de una funci√≥n miembro de una clase, se escribe una verificaci√≥n de tipo sobre si pertenece al tipo de funci√≥n.  Verificamos si el tipo es de referencia, de lo contrario, buscamos una especializaci√≥n adecuada de estructuras de sonda de plantilla para un puntero de este tipo, que ser√° <i>true_type</i> para cualquier puntero de funci√≥n con hasta 24 par√°metros. <br><br>  Y ahora usamos el resultado para implementar <i>is_function</i> .  Aqu√≠, por la misma raz√≥n que en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte anterior</a> , no pude heredar esta estructura de <i>integral_constant</i> , por lo que el comportamiento de <i>integral_constant se</i> "simula". <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_function template&lt;class _Tp&gt; struct is_function { static const bool value = detail::_is_function_chooser&lt;_Tp, is_reference&lt;_Tp&gt;::value&gt;::value; typedef const bool value_type; typedef integral_constant&lt;bool, is_function::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } };</span></span></code> </pre><br>  Y para implementar <i>is_member_function_pointer</i> todav√≠a es m√°s simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_member_function_pointer template&lt;class _Tp&gt; struct is_member_function_pointer : public detail::_is_mem_function_ptr_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { };</span></span></code> </pre><br>  Adem√°s, en base a estos patrones, podemos determinar si el tipo es un miembro de la clase en principio: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl1</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _not_&lt; _or_&lt;_is_function_ptr_helper&lt;_Tp&gt;, _is_mem_function_ptr_helper&lt;_Tp&gt; &gt; &gt;::type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl2</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> false_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_impl2</span></span></span><span class="hljs-class">&lt;_Tp _Cp::*&gt; :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> true_type { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_member_object_pointer_helper</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> _and_&lt;_is_member_object_pointer_impl1&lt;_Tp&gt;, _is_member_object_pointer_impl2&lt;_Tp&gt; &gt;::type {}; } <span class="hljs-comment"><span class="hljs-comment">// is_member_object_pointer template&lt;class _Tp&gt; struct is_member_object_pointer : public detail::_is_member_object_pointer_helper&lt;typename remove_cv&lt;_Tp&gt;::type&gt;::type { };</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Us√≥ operaciones l√≥gicas 'y', 'o', 'no' en tipos de la primera parte</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void_type</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//typedef void void_type; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _or_ : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _or_&lt;_B3, _B4&gt; &gt; &gt;::type { }; template&lt;&gt; struct _or_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _or_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _or_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B1, _B2&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _or_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _B1, _or_&lt;_B2, _B3&gt; &gt;::type { }; template&lt;class _B1 = void_type, class _B2 = void_type, class _B3 = void_type, class _B4 = void_type&gt; struct _and_; template&lt;&gt; struct _and_&lt;void_type, void_type, void_type, void_type&gt;; template&lt;class _B1&gt; struct _and_&lt;_B1, void_type, void_type, void_type&gt; : public _B1 { }; template&lt;class _B1, class _B2&gt; struct _and_&lt;_B1, _B2, void_type, void_type&gt; : public conditional&lt;_B1::value, _B2, _B1&gt;::type { }; template&lt;class _B1, class _B2, class _B3&gt; struct _and_&lt;_B1, _B2, _B3, void_type&gt; : public conditional&lt;_B1::value, _and_&lt;_B2, _B3&gt;, _B1&gt;::type { }; template&lt;class _Pp&gt; struct _not_ { static const bool value = !bool(_Pp::value); typedef const bool value_type; typedef integral_constant&lt;bool, _not_::value == bool(true)&gt; type; operator value_type() const { // return stored value return (value); } value_type operator()() const { // return stored value return (value); } }; }</span></span></code> </pre><br></div></div><br>  Aqu√≠ usamos operaciones l√≥gicas en tipos que, con la ayuda de la plantilla <i>condicional</i> , eventualmente seleccionan el tipo de plantilla apropiado.  La programaci√≥n de plantillas en todo su esplendor, como resultado, en la etapa de compilaci√≥n, ya tenemos informaci√≥n sobre si el tipo es miembro de la clase.  ¬°Muy "furioso", pero qu√© espectacular y efectivo! <br><br>  Una programaci√≥n de plantillas un poco m√°s pura en los mismos elementos l√≥gicos y tenemos <i>is_fundamental</i> , <i>is_compound</i> , etc.  Signos (esto me deleita, ¬øpero t√∫?): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// is_arithmetic template&lt;class _Tp&gt; struct is_arithmetic : public detail::_or_&lt;is_integral&lt;_Tp&gt;, is_floating_point&lt;_Tp&gt; &gt;::type { }; // is_fundamental template&lt;class _Tp&gt; struct is_fundamental : public detail::_or_&lt;is_arithmetic&lt;_Tp&gt;, is_void&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt; &gt;::type {}; // is_object template&lt;class _Tp&gt; struct is_object : public detail::_not_&lt; detail::_or_&lt; is_function&lt;_Tp&gt;, is_reference&lt;_Tp&gt;, is_void&lt;_Tp&gt; &gt; &gt;::type {}; // is_scalar template&lt;class _Tp&gt; struct is_scalar : public detail::_or_&lt;is_arithmetic&lt;_Tp&gt;, is_pointer&lt;_Tp&gt;, is_member_pointer&lt;_Tp&gt;, is_null_pointer&lt;_Tp&gt;/*, is_enum&lt;_Tp&gt;*/ &gt;::type {}; // is_compound template&lt;class _Tp&gt; struct is_compound: public detail::_not_&lt;is_fundamental&lt;_Tp&gt; &gt;::type { };</span></span></code> </pre><blockquote>  Un lector atento notar√° que la definici√≥n de <i>is_enum est√°</i> comentada.  El hecho es que no encontr√© formas de distinguir <b>enum</b> de otros tipos, pero creo que esto es factible sin el uso de macros dependientes del compilador.  Quiz√°s un lector atento y conocedor le dir√° su camino o tren de pensamiento al respecto. </blockquote>  Para determinar el hecho de que un tipo es una clase, ahora no se necesita nada m√°s: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> detail { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsReference</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_class_helper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>&gt; type; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tp</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_class_helper</span></span></span><span class="hljs-class">&lt;_Tp, false&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, (is_scalar&lt;_Tp&gt;::value == <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//&amp;&amp; !is_union&lt;_Tp&gt;::value &gt;::value &amp;&amp; (is_array&lt;_Tp&gt;::value == bool(false)) &amp;&amp; (is_void&lt;_Tp&gt;::value == bool(false)) &amp;&amp; (is_function&lt;_Tp&gt;::value == bool(false))&gt; type; }; } // is_class template&lt;class _Tp&gt; struct is_class : public detail::_is_class_helper&lt;typename remove_cv&lt;_Tp&gt;::type, is_reference&lt;_Tp&gt;::value&gt;::type { };</span></span></code> </pre><br>  Y todo estar√≠a bien, pero la <b>uni√≥n</b> en C ++ no se puede distinguir de una clase en el caso general.  Debido a que son muy similares en sus "manifestaciones externas", y no pude verificar las diferencias (por ejemplo, la incapacidad de heredar de la <b>uni√≥n</b> ) sin errores de compilaci√≥n.  Quiz√°s alguien le dir√° una maniobra dif√≠cil para determinar la <b>uni√≥n</b> en la compilaci√≥n, entonces <i>is_class</i> se corresponder√° exactamente con el est√°ndar. <br><br>  En la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">parte final de</a> este cap√≠tulo, hablar√© sobre c√≥mo <i>se implementaron</i> <i>std :: decay</i> y <i>std :: common_type</i> , as√≠ como sobre lo que queda por agregar a <b>type_traits</b> . <br><br>  Gracias por su atencion </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es418347/">https://habr.com/ru/post/es418347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es418335/index.html">Enfrentamiento en Positivo Hack Days 8: an√°lisis de cadenas de ataque</a></li>
<li><a href="../es418337/index.html">Hot, Summer DataGrip 2018.2</a></li>
<li><a href="../es418339/index.html">Manipulador "manual"</a></li>
<li><a href="../es418341/index.html">¬°Feliz d√≠a del administrador del sistema! Tarjeta de felicitaci√≥n con significado</a></li>
<li><a href="../es418345/index.html">Documentaci√≥n de formatos de intercambio de informaci√≥n: f√°cil y simple</a></li>
<li><a href="../es418349/index.html">Servicio Azure Kubernetes (AKS) y PowerShell</a></li>
<li><a href="../es418353/index.html">Mapa mental en lugar de un caso de prueba, o c√≥mo la visualizaci√≥n le permite probar la aplicaci√≥n m√°s r√°pido</a></li>
<li><a href="../es418355/index.html">Ordenar ... por una tabla hash (tambi√©n por un recuento de √°rboles y un HashMap)</a></li>
<li><a href="../es418357/index.html">DEFCON 23. "Confesiones de un acosador cibern√©tico profesional". Ken Westin</a></li>
<li><a href="../es418359/index.html">Fintech digest: identificaci√≥n de ciudadanos del supermercado financiero, ex empleado de QIWI extra√≠do 2.4% de bitcoins, BRICS y blockchain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>