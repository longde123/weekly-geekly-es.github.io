<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóûÔ∏è üôç üôÜüèº Kompilasi kebingungan waktu menggunakan NAND / NOR üÜó üìª ü§ò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 
 Setiap orang yang terbiasa dengan C ++ modern telah mendengar bahwa dimulai dengan C ++ 11, specifier constexpr diperkenalkan ke dalam s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kompilasi kebingungan waktu menggunakan NAND / NOR</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482734/"><h2>  Pendahuluan </h2><br>  Setiap orang yang terbiasa dengan C ++ modern telah mendengar bahwa dimulai dengan C ++ 11, specifier constexpr diperkenalkan ke dalam standar, yang memungkinkan untuk melakukan perhitungan waktu kompilasi yang terbatas.  <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0292r2.html" rel="nofollow">Jika constexpr</a> dan <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0170r1.pdf" rel="nofollow">constexpr lambdas</a> ditambahkan ke standar berikut, yang sedikit banyak menghapus pembatasan dan membantu menulis kode dengan perhitungan waktu kompilasi.  Hari ini kita akan berbicara tentang pembuatan kode acak pada waktu kompilasi. <br><a name="habracut"></a><br><h2>  Kami memilih pangkalan untuk menerima nilai waktu kompilasi ‚Äúacak‚Äù </h2><br>  Untuk memilih jalur spesifik untuk kode pada waktu kompilasi, Anda memerlukan PRNG constexpr dengan output yang baik, untuk ini saya memilih generator <a href="http://prng.di.unimi.it/" rel="nofollow">xorshift</a> , dengan cara <a href="https://en.wikipedia.org/wiki/Xorshift" rel="nofollow">xorshift</a> melewati tes empiris <a href="http://simul.iro.umontreal.ca/testu01/tu01.html" rel="nofollow">BigCrush (TestU01)</a> . <br><br><div class="spoiler">  <b class="spoiler_title">xorshift256 ++</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; /* This is xoshiro256++ 1.0, one of our all-purpose, rock-solid generators. It has excellent (sub-ns) speed, a state (256 bits) that is large enough for any parallel application, and it passes all tests we are aware of. For generating just floating-point numbers, xoshiro256+ is even faster. The state must be seeded so that it is not everywhere zero. If you have a 64-bit seed, we suggest to seed a splitmix64 generator and use its output to fill s. */ static inline uint64_t rotl(const uint64_t x, int k) { return (x &lt;&lt; k) | (x &gt;&gt; (64 - k)); } static uint64_t s[4]; uint64_t next(void) { const uint64_t result = rotl(s[0] + s[3], 23) + s[0]; const uint64_t t = s[1] &lt;&lt; 17; s[2] ^= s[0]; s[3] ^= s[1]; s[1] ^= s[2]; s[0] ^= s[3]; s[2] ^= t; s[3] = rotl(s[3], 45); return result; } /* This is the jump function for the generator. It is equivalent to 2^128 calls to next(); it can be used to generate 2^128 non-overlapping subsequences for parallel computations. */ void jump(void) { static const uint64_t JUMP[] = { 0x180ec6d33cfd0aba, 0xd5a61266f0c9392c, 0xa9582618e03fc9aa, 0x39abdc4529b1661c }; uint64_t s0 = 0; uint64_t s1 = 0; uint64_t s2 = 0; uint64_t s3 = 0; for(int i = 0; i &lt; sizeof JUMP / sizeof *JUMP; i++) for(int b = 0; b &lt; 64; b++) { if (JUMP[i] &amp; UINT64_C(1) &lt;&lt; b) { s0 ^= s[0]; s1 ^= s[1]; s2 ^= s[2]; s3 ^= s[3]; } next(); } s[0] = s0; s[1] = s1; s[2] = s2; s[3] = s3; } /* This is the long-jump function for the generator. It is equivalent to 2^192 calls to next(); it can be used to generate 2^64 starting points, from each of which jump() will generate 2^64 non-overlapping subsequences for parallel distributed computations. */ void long_jump(void) { static const uint64_t LONG_JUMP[] = { 0x76e15d3efefdcbbf, 0xc5004e441c522fb3, 0x77710069854ee241, 0x39109bb02acbe635 }; uint64_t s0 = 0; uint64_t s1 = 0; uint64_t s2 = 0; uint64_t s3 = 0; for(int i = 0; i &lt; sizeof LONG_JUMP / sizeof *LONG_JUMP; i++) for(int b = 0; b &lt; 64; b++) { if (LONG_JUMP[i] &amp; UINT64_C(1) &lt;&lt; b) { s0 ^= s[0]; s1 ^= s[1]; s2 ^= s[2]; s3 ^= s[3]; } next(); } s[0] = s0; s[1] = s1; s[2] = s2; s[3] = s3; }</span></span></span></span></code> </pre> <br></div></div><br>  Dari ini kita hanya perlu fungsi rotl dan next, agar tidak membuat perhitungan terlalu lama.  Saya mengirimkan salam tulus saya kepada para pengembang kompiler MSVC, mengingat bug kompiler yang ditemukan selama proses penulisan, ini akan dibahas di bawah ini. <br><br>  Seperti yang dapat Anda lihat dari kode di atas, kita membutuhkan empat variabel statis 64-bit untuk menyimpan status, agar kode ini dapat bekerja pada waktu kompilasi, kita perlu menghilangkannya dengan mengirimkan keadaan acak sebagai parameter.  Anda dapat mengatur ini menggunakan constexpr hash fnv1 dan __COUNTER__ makro, menulis ulang kode sesuai dengan ini dan mendapatkan yang berikut: <br><br><div class="spoiler">  <b class="spoiler_title">waktu kompilasi 'acak'</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdint&gt; #define STRING(s) #s // an enumeration can also be used here template &lt;typename T, T value&gt; constexpr T ensure_constexpr() { return value; } #define CONSTEXPR(x) ensure_constexpr&lt;decltype(x), x&gt;() constexpr uint64_t fnv1impl(uint64_t h, const char* s) { return (*s == 0) ? h : fnv1impl((h * 1099511628211ull) ^ static_cast&lt;uint64_t&gt;(*s), s + 1); } constexpr uint64_t fnv1(const char* s) { return fnv1impl(14695981039346656037ull, s); } template &lt;uint64_t n&gt; constexpr uint64_t get_seed(const uint64_t x, const uint64_t y = CONSTEXPR(fnv1(STRING(n)))) { return x ^ y * n; } #define SEED CONSTEXPR(get_seed&lt;__COUNTER__ + 1&gt;(fnv1(__TIME__))) //! Rotate left by constexpr uint64_t rotl(uint64_t x, int k) { return (x &lt;&lt; k) | (x &gt;&gt; (64 - k)); } //! XorShift 256 compile time random implementation template &lt;uint64_t a, uint64_t b, uint64_t c, uint64_t d&gt; constexpr uint64_t xorshift256_next() { uint64_t s[4] = {a, b, c, d}; const uint64_t t = s[1] &lt;&lt; 17; s[2] ^= s[0]; s[3] ^= s[1]; s[1] ^= s[2]; s[0] ^= s[3]; s[2] ^= t; s[3] = rotl(s[3], 45); return rotl(s[0] + s[3], 23) + s[0]; } #define RND \ xorshift256_next&lt; \ CONSTEXPR(SEED + __COUNTER__), CONSTEXPR(SEED + __COUNTER__), \ CONSTEXPR(SEED + __COUNTER__), CONSTEXPR(SEED + __COUNTER__)&gt;()</span></span></span></span></code> </pre><br></div></div><br><h2>  Di bawah tenda </h2><br>  Sekarang kita perlu memastikan bahwa kompiler benar-benar "menutup" kode pada waktu kompilasi. <br>  Kami mengkompilasi kode di bawah ini menggunakan GCC 9.2.1 di debug g ++ _.cpp -S -masm = intel <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"compile_random.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; int main() { std::cout &lt;&lt; RND &lt;&lt; std::endl; std::cout &lt;&lt; RND &lt;&lt; std::endl; }</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Saya ingin melihat cerita-cerita horor</b> <div class="spoiler_text"> <code>.file "_.cpp" <br> .intel_syntax noprefix <br> .text <br> .section .text._Z4rotlmi,"axG",@progbits,_Z4rotlmi,comdat <br> .weak _Z4rotlmi <br> .type _Z4rotlmi, @function <br> _Z4rotlmi: <br> .LFB4: <br> .cfi_startproc <br> push rbp <br> .cfi_def_cfa_offset 16 <br> .cfi_offset 6, -16 <br> mov rbp, rsp <br> .cfi_def_cfa_register 6 <br> mov QWORD PTR [rbp-8], rdi <br> mov DWORD PTR [rbp-12], esi <br> mov eax, DWORD PTR [rbp-12] <br> mov rdx, QWORD PTR [rbp-8] <br> mov ecx, eax <br> rol rdx, cl <br> mov rax, rdx <br> pop rbp <br> .cfi_def_cfa 7, 8 <br> ret <br> .cfi_endproc <br> .LFE4: <br> .size _Z4rotlmi, .-_Z4rotlmi <br> .section .rodata <br> .type _ZStL19piecewise_construct, @object <br> .size _ZStL19piecewise_construct, 1 <br> _ZStL19piecewise_construct: <br> .zero 1 <br> .local _ZStL8__ioinit <br> .comm _ZStL8__ioinit,1,1 <br> .text <br> .globl main <br> .type main, @function <br> main: <br> .LFB1528: <br> .cfi_startproc <br> push rbp <br> .cfi_def_cfa_offset 16 <br> .cfi_offset 6, -16 <br> mov rbp, rsp <br> .cfi_def_cfa_register 6 <br> <b>call _Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv</b> <br> mov rsi, rax <br> mov edi, OFFSET FLAT:_ZSt4cout <br> call _ZNSolsEm <br> mov esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ <br> mov rdi, rax <br> call _ZNSolsEPFRSoS_E <br> <b>call _Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv</b> <br> mov rsi, rax <br> mov edi, OFFSET FLAT:_ZSt4cout <br> call _ZNSolsEm <br> mov esi, OFFSET FLAT:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ <br> mov rdi, rax <br> call _ZNSolsEPFRSoS_E <br> mov eax, 0 <br> pop rbp <br> .cfi_def_cfa 7, 8 <br> ret <br> .cfi_endproc <br> .LFE1528: <br> .size main, .-main <br> .section .text._Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv,"axG",@progbits,_Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv,comdat <br> .weak _Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv <br> .type _Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv, @function <br> _Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv: <br> .LFB1790: <br> .cfi_startproc <br> push rbp <br> .cfi_def_cfa_offset 16 <br> .cfi_offset 6, -16 <br> mov rbp, rsp <br> .cfi_def_cfa_register 6 <br> sub rsp, 48 <br> movabs rax, 5485350875583313748 <br> mov QWORD PTR [rbp-48], rax <br> movabs rax, -1344488152466593804 <br> mov QWORD PTR [rbp-40], rax <br> movabs rax, -8102276183547423076 <br> mov QWORD PTR [rbp-32], rax <br> movabs rax, 2938160962983216444 <br> mov QWORD PTR [rbp-24], rax <br> mov rax, QWORD PTR [rbp-40] <br> sal rax, 17 <br> mov QWORD PTR [rbp-8], rax <br> mov rdx, QWORD PTR [rbp-32] <br> mov rax, QWORD PTR [rbp-48] <br> xor rax, rdx <br> mov QWORD PTR [rbp-32], rax <br> mov rdx, QWORD PTR [rbp-24] <br> mov rax, QWORD PTR [rbp-40] <br> xor rax, rdx <br> mov QWORD PTR [rbp-24], rax <br> mov rdx, QWORD PTR [rbp-40] <br> mov rax, QWORD PTR [rbp-32] <br> xor rax, rdx <br> mov QWORD PTR [rbp-40], rax <br> mov rdx, QWORD PTR [rbp-48] <br> mov rax, QWORD PTR [rbp-24] <br> xor rax, rdx <br> mov QWORD PTR [rbp-48], rax <br> mov rax, QWORD PTR [rbp-32] <br> xor rax, QWORD PTR [rbp-8] <br> mov QWORD PTR [rbp-32], rax <br> mov rax, QWORD PTR [rbp-24] <br> mov esi, 45 <br> mov rdi, rax <br> call _Z4rotlmi <br> mov QWORD PTR [rbp-24], rax <br> mov rdx, QWORD PTR [rbp-48] <br> mov rax, QWORD PTR [rbp-24] <br> add rax, rdx <br> mov esi, 23 <br> mov rdi, rax <br> call _Z4rotlmi <br> mov rdx, QWORD PTR [rbp-48] <br> add rax, rdx <br> leave <br> .cfi_def_cfa 7, 8 <br> ret <br> .cfi_endproc <br> .LFE1790: <br> .size _Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv, .-_Z16xorshift256_nextILm5485350875583313748ELm17102255921242957812ELm10344467890162128540ELm2938160962983216444EEmv <br> .section .text._Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv,"axG",@progbits,_Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv,comdat <br> .weak _Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv <br> .type _Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv, @function <br> _Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv: <br> .LFB1794: <br> .cfi_startproc <br> push rbp <br> .cfi_def_cfa_offset 16 <br> .cfi_offset 6, -16 <br> mov rbp, rsp <br> .cfi_def_cfa_register 6 <br> sub rsp, 48 <br> movabs rax, -3891678030706526748 <br> mov QWORD PTR [rbp-48], rax <br> movabs rax, 7653162274090525828 <br> mov QWORD PTR [rbp-40], rax <br> movabs rax, 823244081203417900 <br> mov QWORD PTR [rbp-32], rax <br> movabs rax, -6510995906087812148 <br> mov QWORD PTR [rbp-24], rax <br> mov rax, QWORD PTR [rbp-40] <br> sal rax, 17 <br> mov QWORD PTR [rbp-8], rax <br> mov rdx, QWORD PTR [rbp-32] <br> mov rax, QWORD PTR [rbp-48] <br> xor rax, rdx <br> mov QWORD PTR [rbp-32], rax <br> mov rdx, QWORD PTR [rbp-24] <br> mov rax, QWORD PTR [rbp-40] <br> xor rax, rdx <br> mov QWORD PTR [rbp-24], rax <br> mov rdx, QWORD PTR [rbp-40] <br> mov rax, QWORD PTR [rbp-32] <br> xor rax, rdx <br> mov QWORD PTR [rbp-40], rax <br> mov rdx, QWORD PTR [rbp-48] <br> mov rax, QWORD PTR [rbp-24] <br> xor rax, rdx <br> mov QWORD PTR [rbp-48], rax <br> mov rax, QWORD PTR [rbp-32] <br> xor rax, QWORD PTR [rbp-8] <br> mov QWORD PTR [rbp-32], rax <br> mov rax, QWORD PTR [rbp-24] <br> mov esi, 45 <br> mov rdi, rax <br> call _Z4rotlmi <br> mov QWORD PTR [rbp-24], rax <br> mov rdx, QWORD PTR [rbp-48] <br> mov rax, QWORD PTR [rbp-24] <br> add rax, rdx <br> mov esi, 23 <br> mov rdi, rax <br> call _Z4rotlmi <br> mov rdx, QWORD PTR [rbp-48] <br> add rax, rdx <br> leave <br> .cfi_def_cfa 7, 8 <br> ret <br> .cfi_endproc <br> .LFE1794: <br> .size _Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv, .-_Z16xorshift256_nextILm14555066043003024868ELm7653162274090525828ELm823244081203417900ELm11935748167621739468EEmv <br> .text <br> .type _Z41__static_initialization_and_destruction_0ii, @function <br> _Z41__static_initialization_and_destruction_0ii: <br> .LFB2042: <br> .cfi_startproc <br> push rbp <br> .cfi_def_cfa_offset 16 <br> .cfi_offset 6, -16 <br> mov rbp, rsp <br> .cfi_def_cfa_register 6 <br> sub rsp, 16 <br> mov DWORD PTR [rbp-4], edi <br> mov DWORD PTR [rbp-8], esi <br> cmp DWORD PTR [rbp-4], 1 <br> jne .L11 <br> cmp DWORD PTR [rbp-8], 65535 <br> jne .L11 <br> mov edi, OFFSET FLAT:_ZStL8__ioinit <br> call _ZNSt8ios_base4InitC1Ev <br> mov edx, OFFSET FLAT:__dso_handle <br> mov esi, OFFSET FLAT:_ZStL8__ioinit <br> mov edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev <br> call __cxa_atexit <br> .L11: <br> nop <br> leave <br> .cfi_def_cfa 7, 8 <br> ret <br> .cfi_endproc <br> .LFE2042: <br> .size _Z41__static_initialization_and_destruction_0ii, .-_Z41__static_initialization_and_destruction_0ii <br> .type _GLOBAL__sub_I_main, @function <br> _GLOBAL__sub_I_main: <br> .LFB2043: <br> .cfi_startproc <br> push rbp <br> .cfi_def_cfa_offset 16 <br> .cfi_offset 6, -16 <br> mov rbp, rsp <br> .cfi_def_cfa_register 6 <br> mov esi, 65535 <br> mov edi, 1 <br> call _Z41__static_initialization_and_destruction_0ii <br> pop rbp <br> .cfi_def_cfa 7, 8 <br> ret <br> .cfi_endproc <br> .LFE2043: <br> .size _GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main <br> .section .init_array,"aw" <br> .align 8 <br> .quad _GLOBAL__sub_I_main <br> .hidden __dso_handle <br> .ident "GCC: (GNU) 9.2.1 20190827 (Red Hat 9.2.1-1)" <br> .section .note.GNU-stack,"",@progbits <br></code> <br></div></div><br>  Seperti yang Anda lihat dari kode assembler di atas, fungsi rotl dan xorshift256_next ada dalam kode, tetapi sebenarnya ini adalah perilaku yang diharapkan, karena optimasi telah dinonaktifkan. <br><br>  Periksa dengan optimasi yang diaktifkan g ++ _.cpp -S -masm = intel -O2 <br><br><div class="spoiler">  <b class="spoiler_title">Saya tidak takut lagi, saya melihat segalanya</b> <div class="spoiler_text"> <code>.file "_.cpp" <br> .intel_syntax noprefix <br> .text <br> .section .text.startup,"ax",@progbits <br> .p2align 4 <br> .globl main <br> .type main, @function <br> main: <br> .LFB1550: <br> .cfi_startproc <br> sub rsp, 8 <br> .cfi_def_cfa_offset 16 <br> mov edi, OFFSET FLAT:_ZSt4cout <br> <b>movabs rsi, 6340608927850167019</b> <br> call _ZNSo9_M_insertImEERSoT_ <br> mov rdi, rax <br> call _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ <br> mov edi, OFFSET FLAT:_ZSt4cout <br> <b>movabs rsi, -1433878323375531419</b> <br> call _ZNSo9_M_insertImEERSoT_ <br> mov rdi, rax <br> call _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ <br> xor eax, eax <br> add rsp, 8 <br> .cfi_def_cfa_offset 8 <br> ret <br> .cfi_endproc <br> .LFE1550: <br> .size main, .-main <br> .p2align 4 <br> .type _GLOBAL__sub_I_main, @function <br> _GLOBAL__sub_I_main: <br> .LFB2064: <br> .cfi_startproc <br> sub rsp, 8 <br> .cfi_def_cfa_offset 16 <br> mov edi, OFFSET FLAT:_ZStL8__ioinit <br> call _ZNSt8ios_base4InitC1Ev <br> mov edx, OFFSET FLAT:__dso_handle <br> mov esi, OFFSET FLAT:_ZStL8__ioinit <br> mov edi, OFFSET FLAT:_ZNSt8ios_base4InitD1Ev <br> add rsp, 8 <br> .cfi_def_cfa_offset 8 <br> jmp __cxa_atexit <br> .cfi_endproc <br> .LFE2064: <br> .size _GLOBAL__sub_I_main, .-_GLOBAL__sub_I_main <br> .section .init_array,"aw" <br> .align 8 <br> .quad _GLOBAL__sub_I_main <br> .local _ZStL8__ioinit <br> .comm _ZStL8__ioinit,1,1 <br> .hidden __dso_handle <br> .ident "GCC: (GNU) 9.2.1 20190827 (Red Hat 9.2.1-1)" <br> .section .note.GNU-stack,"",@progbits <br></code> <br></div></div><br>  Hore!  kami mendapatkan apa yang kami harapkan, kompiler menyebarkan 2 panggilan dari RND macro ke 2 mov mov.  Perilaku dentang dan kompiler MSVC dalam RELEASE MODE serupa.  Anda dapat melanjutkan untuk mengkompilasi pembuatan kode waktu. <br><br>  Untuk pemahaman lebih lanjut, Anda perlu membiasakan diri dengan unsur-unsur logika universal. <br>  <a href="https://en.wikipedia.org/wiki/Logical_NOR" rel="nofollow">NOR</a> (Dermaga panah) <a href="https://en.wikipedia.org/wiki/Sheffer_stroke" rel="nofollow">NAND</a> (Schaeffer Bar) yang dapat digunakan untuk membangun semua logika secara absolut.  Saya tidak akan melampirkan semua kode untuk menerapkan &amp; |  ^ ++ -, kami hanya akan menganalisis satu contoh berdasarkan pengambilan sampel acak dari fungsi templat NAND, dalam instruksi lain yang ditiru prinsip seleksi adalah sama. <br><br>  Mari kita bayangkan bahwa kita memiliki 5 implementasi NAND template yang ingin kita acak. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//! (Not a) Or (Not b) template &lt;typename T&gt; FORCEINLINE T Nand_1(volatile T a, volatile T b) { return Or&lt;T&gt;(Not&lt;T&gt;(a), Not&lt;T&gt;(b)); } //! Not(a And b) template &lt;typename T&gt; FORCEINLINE T Nand_2(volatile T a, volatile T b) { return Not&lt;T&gt;(And&lt;T&gt;(a, b)); } //! Not ((Not a) Nor (Not b)) template &lt;typename T&gt; FORCEINLINE T Nand_3(volatile T a, volatile T b) { return Not&lt;T&gt;(Nor&lt;T&gt;(Not&lt;T&gt;(a), Not&lt;T&gt;(b))); } //! (Not a) Or (Not b) template &lt;typename T&gt; FORCEINLINE T Nand_4(volatile T a, volatile T b) { return Or&lt;T&gt;(Not&lt;T&gt;(a), Not&lt;T&gt;(b)); } //! ((Not a) And b) Xor (Not b) template &lt;typename T&gt; FORCEINLINE T Nand_5(volatile T a, volatile T b) { return Xor&lt;T&gt;(And&lt;T&gt;(Not&lt;T&gt;(a), b), Not&lt;T&gt;(b)); }</span></span></code> </pre><br>  Untuk melakukan ini, kita hanya perlu melakukan hal berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> n&gt; <span class="hljs-function"><span class="hljs-function">FORCEINLINE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NandR</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">volatile</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (n % <span class="hljs-number"><span class="hljs-number">5</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nand_1&lt;T&gt;(a, b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nand_2&lt;T&gt;(a, b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nand_3&lt;T&gt;(a, b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nand_4&lt;T&gt;(a, b); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nand_5&lt;T&gt;(a, b); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Nand_1&lt;T&gt;(a, b); } }</code> </pre><br>  Itu bisa disebut dalam kode seperti ini: <br><br><pre> <code class="cpp hljs">NandR&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>, RND&gt;(a,b)</code> </pre><br>  Kompiler hanya akan menyisakan 1 panggilan fungsi, yang akan dipilih sesuai dengan hasil dari RND makro, karena nomor tersebut diketahui pada saat kompilasi.  RND adalah makro menggunakan xorshift + fnv1 + __COUNTER__ yang telah dibahas di atas.  Juga untuk kenyamanan, kelas template primitif CNNInt &lt;&gt; ditulis yang berisi kelebihan operator yang diperlukan untuk meningkatkan keterbacaan kode. <br><br>  Pertimbangkan kode assembler yang dihasilkan dan DIFF dari dua kompilasi berbeda untuk fungsi berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> diff_me(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> x) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> u64 = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>; CNNInt&lt;u64&gt; r(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::system_clock::now().time_since_epoch().count()); CNNInt&lt;u64&gt; test(x); test++; test--; test|=r; test^=r; test&amp;=r; test^=r; test = ~test; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> test.value(); }</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/d8b/a58/3d9/d8ba583d9c369bf0ff73adce4ac76760.png" alt="gambar"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b6/704/2c3/2b67042c31b18efac480926eb4f13032.png" alt="gambar"><br><br>  Analisis dilakukan dengan menggunakan utilitas relize, DIFF dari dua binari menunjukkan hasil sebagai berikut: <br><br><pre> <code class="plaintext hljs">81.13% diff_me - diff_me</code> </pre> <br>  Mari kita lihat fungsi diff_me di bawah dekompiler: <br><br>  1. <a href="https://www.nsa.gov/resources/everyone/ghidra/" rel="nofollow">Ghidra</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ulong </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">diff_me</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ulong param_1)</span></span></span><span class="hljs-function"> </span></span>{ ulong uVar1; ulong uVar2; ulong uVar3; ulong uVar4; uVar1 = now(); uVar2 = ~uVar1; uVar3 = ~(param_1 &amp; ~param_1 &amp; uVar1) &amp; (param_1 | ~param_1 &amp; uVar1); uVar4 = ~uVar3; uVar3 = (~(uVar3 &amp; uVar2 | uVar4) | uVar3 &amp; uVar2 &amp; uVar4 | uVar2) &amp; (uVar1 &amp; uVar3 | uVar4) | uVar2; uVar4 = ~uVar3 &amp; uVar2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (uVar1 &amp; ~uVar3 | uVar3) &amp; (~(uVar4 | uVar3) | uVar4 &amp; uVar3 | uVar2); }</code> </pre><br>  Ada fungsi execut_code lain di proyek sebagai contoh, Ghidra tidak bisa mendekompilasi itu. <br><br>  2. <a href="https://www.hopperapp.com/" rel="nofollow">Hopper</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _Z7diff_mem(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> arg0) { rax = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::_V2::system_clock::now(); rax = (rax &amp; !((!(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax &amp; !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax)) | !rax) &amp; (rax &amp; !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !rax) | !!((!(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax &amp; !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax)) | !rax) &amp; (rax &amp; !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !rax)) &amp; (!(!((!(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax &amp; !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax)) | !rax) &amp; (rax &amp; !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !rax) &amp; !rax | !!((!(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax &amp; !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax)) | !rax) &amp; (rax &amp; !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !rax)) | !((!(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax &amp; !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax)) | !rax) &amp; (rax &amp; !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !rax) &amp; !rax &amp; !!((!(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) &amp; !rax &amp; !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax)) | !rax) &amp; (rax &amp; !(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax) | !(!(arg0 &amp; !arg0 &amp; rax) &amp; (arg0 | !arg0 &amp; rax))) | !rax) | !rax); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rax; }</code> </pre><br>  3. <a href="https://github.com/avast/retdec/releases" rel="nofollow">RetDec</a> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Address range: 0x401320 - 0x4013a3 // Demangled: diff_me(unsigned long) int64_t _Z7diff_mem(int64_t a1) { // 0x401320 g14 = a1; int64_t v1 = g14; // 0x401321 int64_t v2 = function_401030(); // 0x401324 _ZNSt6chrono3_V212system_clock3nowEv(); g14 = 0; return -1 - ((v2 &amp; -1 - v1 | v1) &amp; v2); }</span></span></code> </pre><br><h2>  Bonus </h2><br>  1. <a href="https://github.com/Deniskore/nand_nor" rel="nofollow">Repositori proyek</a> . <br><br>  2. Mari kita kembali ke kompiler MSVC (toolchain versi 16.4.2), mengkompilasi contoh dari proyek memakan banyak memori dan membutuhkan banyak waktu, saya <a href="https://developercommunity.visualstudio.com/content/problem/873112/extremely-long-compilation-time-when-using-compile.html" rel="nofollow">melaporkan bug ke tim kompiler MSVC</a> , saya akan senang jika Anda memilih untuk memperbaiki bug ini. <br><br>  Konsumsi memori saat menyusun proyek uji: <br><br><img src="https://habrastorage.org/webt/ct/eh/ma/ctehmabog83fvrgzmmzxaxgaelm.png"><br><br>  Perlu dicatat bahwa perakitan proyek uji menggunakan Dentang 9.0 dan GCC 9.2.1 terjadi hampir secara instan dan tidak memakan memori sebesar itu :) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482734/">https://habr.com/ru/post/id482734/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482718/index.html">Piramida terbalik sebagai akhir dari proyek Anda</a></li>
<li><a href="../id482722/index.html">Cerita yang fantastis "Project C. Vanity of vanities" (10 mnt)</a></li>
<li><a href="../id482726/index.html">Intisari materi menarik untuk pengembang seluler # 328 (23-29 Desember)</a></li>
<li><a href="../id482728/index.html">Jpeg. Algoritma kompresi</a></li>
<li><a href="../id482730/index.html">Polling liburan</a></li>
<li><a href="../id482736/index.html">Menggunakan TSDuck untuk Memantau Streaming IP (TS)</a></li>
<li><a href="../id482740/index.html">Wawancara untuk posisi seorang penyair</a></li>
<li><a href="../id482742/index.html">Memasuki Pasar Barat: Bagaimana Berinteraksi dengan Pelanggan</a></li>
<li><a href="../id482744/index.html">Menemukan Peluru Perak: Amunisi Tidak Biasa</a></li>
<li><a href="../id482748/index.html">Membuat bisnis pemesanan taksi di Dubai: Bagaimana cara meluncurkan aplikasi taksi yang berpusat pada pelanggan seperti Careem & Hala?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>