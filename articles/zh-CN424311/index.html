<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏷️ 👨🏿‍🎤 👌🏼 这些天的异步业务逻辑 👼🏾 ⛹🏾 🌶️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="简而言之： 


- 该证明已经在适用于Java的 C ++ ， JS和PHP中实现。 
- 比协程和Promise 更快 ，功能更多。 
- 它不需要单独的软件堆栈。 
- 与所有安全和调试工具成为朋友。 
- 它适用于任何体系结构，不需要特殊的编译器标志。 




- 回头看 
- FutoI...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>这些天的异步业务逻辑</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424311/"><p> 简而言之： </p><br><blockquote><ul><li> 该证明已经在适用于<strong>Java的</strong> <strong>C ++</strong> ， <strong>JS</strong>和<strong>PHP中</strong>实现。 </li><li>比协程和Promise <strong>更快</strong> ，功能更多。 </li><li> 它不需要单独的软件堆栈。 </li><li> 与所有安全和调试工具成为朋友。 </li><li> 它适用于任何体系结构，不需要特殊的编译器标志。 </li></ul><br></blockquote><a name="habracut"></a><br><hr><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">回头看</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FutoIn AsyncSteps-协程的替代品</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">到数字</a> </li></ul><br><h2 id="vzglyad-nazad"> 回头看 </h2><br><p> 在计算机诞生之初，只有一个控制流，但阻塞了输入输出。 然后铁中断添加到它。 现在，您可以有效地使用缓慢且不可预测的设备。 </p><br><p> 随着熨斗功能的增长和可用性的降低，必须同时执行多项任务，从而提供硬件支持。 因此，存在隔离的过程，其中中断以信号的形式从铁中抽象出来。 </p><br><p> 下一个演进阶段是多线程，它是在相同进程的基础上实现的，但是共享访问内存和其他资源。 这种方法有其局限性，而且切换到安全OS的开销也很大。 </p><br><p> 为了在流程甚至不同的机器之间进行通信，40年前就提出了Promise / Future抽象。 </p><br><p> 用户界面和当前可笑的10K客户端问题导致了事件循环，反应器和Proactor方法的鼎盛时期，它们比清晰，一致的业务逻辑更面向事件。 </p><br><p> 最后，我们介绍了现代协程（协程），本质上是在上述抽象之上对流程进行的仿真，具有相应的技术局限性和控制权的确定性转移。 </p><br><p> 为了传达事件，结果和异常，它们都回到了“承诺/未来”的相同概念。 一些办公室决定使用不同的名称-“任务”。 </p><br><p>最后，他们将所有内容都隐藏在漂亮的<code>async/await</code>包中，这取决于技术要求编译器或翻译器支持。 </p><br><h3 id="problemy-s-tekuschiy-situaciy-asinhronnoy-biznes-logiki"> 当前异步业务逻辑情况的问题 </h3><br><p> 仅考虑用<code>async/await</code>装饰的协程和Promise，作为 旧方法中问题的存在证实了进化过程本身。 </p><br><p> 这两个术语不相同。 例如，在ECMAScript中，没有协程，但是使用<code>Promise</code>减轻语法的负担，而<code>Promise</code>只能使用回调地狱来组织工作。 实际上，像V8这样的脚本引擎走得更远，并对纯<code>async/await</code>函数和调用进行了特殊的优化。 </p><br><p> 专家<code>co_async/co_await</code>并没有包含在C ++ 17中，但是来自软件巨头协程的压力可以完全以它们的形式出现在标准中。 同时，传统上公认的解决方案是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Boost.Context</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Boost.Fiber</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Boost.Coroutine2</a> 。 </p><br><p> 在Java中，在语言级别上仍然没有<code>async/await</code> ，但是有诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">EA Async之</a>类的解决方案，像Boost.Context一样，需要针对每个版本的JVM和代码字节进行自定义。 </p><br><p>  Go有其自己的协程，但是如果您仔细查看开放项目的文章和错误报告，事实证明这里的一切都不那么顺利。 也许失去协程接口作为托管实体不是一个好主意。 </p><br><h4 id="mnenie-avtora-soprogrammy-na-golom-zheleze-opasny"> 作者的意见：裸露的协程很危险 </h4><br><p> 就个人而言，作者很少反对使用动态语言编写的协程，但是他非常警惕任何在机器代码级别上对堆栈的调情。 </p><br><p> 几点： </p><br><ol><li> 需要堆叠： <br><ul><li> 堆上的堆栈有许多缺点：无法及时确定溢出，邻居损坏和其他可靠性/安全性问题的问题， </li><li> 一个安全堆栈至少需要一页物理内存，一个条件页以及每次调用<code>async</code>函数的额外开销：4 + KB（最小）+增加的系统限制， </li><li> 最终，可能是在协程停机期间未使用分配给堆栈的大部分内存。 </li></ul></li><li> 有必要实现一个复杂的逻辑来保存，恢复和删除协程状态： <br><ul><li> 对于处理器架构（甚至模型）和二进制接口（ABI）的每种情况： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">example</a> ， </li><li> 新的或可选的架构功能会带来潜在的潜在问题（例如，英特尔TSX，ARM协处理器或MIPS）， </li><li> 由于专有系统而导致的其他潜在问题已关闭文档（Boost文档是与此相关的文档）。 </li></ul></li><li> 动态分析工具和总体安全性方面的潜在问题： <br><ul><li> 例如，由于相同的跳跃堆栈，因此必须与Valgrind集成， </li><li> 杀毒软件很难说，但在过去的JVM问题示例中，它们可能并不十分喜欢它， </li><li> 我敢肯定，将会出现新的攻击类型，并且将揭示与实施协程相关的漏洞。 </li></ul></li></ol><br><h4 id="mnenie-avtora-generatory-i-yield-principialnoe-zlo"> 作者的观点：发电机和<code>yield</code>根本的邪恶 </h4><br><p> 这个看似第三方的主题与协程的概念和“ continue”属性直接相关。 </p><br><p> 简而言之，任何集合都必须存在完整的迭代器。 为什么创建裁剪的迭代器-生成器问题尚不清楚。 例如，在Python中带有<code>range()</code>的情况比技术复杂化的借口更像是排他性炫耀。 </p><br><p> 如果情况是无限生成器，则其实现的逻辑是基本的。 为什么要增加额外的技术难度以推动不断发展的周期。 </p><br><p> 协程的支持者后来提出的唯一明智的理由是，各种具有反向控制的流解析器。 实际上，这是在库级别解决单个问题的狭义专业案例，而不是应用程序的业务逻辑。 同时，通过有限状态机提供了一种优雅，简单且更具描述性的解决方案。 这些技术问题的范围比普通业务逻辑的范围小得多。 </p><br><p> 实际上，要解决的问题是从手指上获得的，并且需要相对认真的努力来进行初始实施和长期支持。 如此之多，以至于某些项目可能会在禁止使用<code>goto</code>或在各个行业中使用动态内存分配的示例后，禁止使用机器代码级协同程序。 </p><br><h4 id="mnenie-avtora-model-asyncawait-na-promise-iz-ecmascript-bolee-nadyozhna-no-trebuet-adaptacii"> 作者意见：ECMAScript的<code>async/await</code> Promise模型更可靠，但需要修改 </h4><br><p> 与连续协程不同，在此模型中，代码段被秘密地划分为设计为匿名函数的不可中断块。 在C ++中，由于内存管理的特殊性，这并不完全适合，例如： </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Value = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcPromise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolved(value_); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">funcCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::function&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">()&gt; &amp;&amp;cb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ somehow_call_later(cb); } Value value_; }; <span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([&amp;](SomeObject::value &amp;&amp;val){ return Promise([&amp;](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback(resolve, val); }); }); }</span></span></code> </pre> <br><p> 首先，退出<code>example()</code>以及调用lambda函数之前， <code>some_obj</code>将被销毁。 </p><br><p> 其次，具有捕获变量或引用的lambda函数是对象，并秘密地添加复制/移动，这可能会对具有大量捕获的性能产生负面影响，并且需要在通常的<code>std::function</code>在类型擦除期间在堆上分配内存。 </p><br><p> 第三， <code>Promise</code>接口本身是基于结果的“承诺”概念，而不是业务逻辑的一致执行。 </p><br><p> 原理图非最佳解决方案可能看起来像这样： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Promise </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocalContext</span></span></span><span class="hljs-class"> {</span></span> SomeObject some_obj; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ctx = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;LocalContext&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> some_obj.funcPromise() .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>([](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception &amp;e){ <span class="hljs-comment"><span class="hljs-comment">// ... }) .then([ctx](SomeObject::Value &amp;&amp;val){ struct LocalContext2 { LocalContext2(std::shared_ptr&lt;LocalContext&gt; &amp;&amp;ctx, SomeObject::Value &amp;&amp;val) : ctx(ctx), val(val) {} std::shared_ptr&lt;LocalContext&gt; ctx; SomeObject::Value val; }; auto ctx2 = std::make_shared&lt;LocalContext2&gt;( std::move(ctx), std::forward&lt;SomeObject::Value&gt;(val) ); return Promise([ctx2](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ ctx2-&gt;ctx-&gt;some_obj.funcCallback([ctx2, resolve](){ resolve(); }, val); }); }); }</span></span></code> </pre> <br><p>  <em>注意： <code>std::move</code>而不是<code>std::shared_ptr</code>不合适的，因为它无法一次转移到多个lambda，并且它们的大小会增加。</em> </p><br><p> 随着<code>async/await</code>异步恐怖进入了一种可消化的状态： </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">async </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">example</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SomeObject some_obj; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { SomeObject::Value val = await some_obj.func(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception&amp; e) ( <span class="hljs-comment"><span class="hljs-comment">// ... } // Capture "async context" return Promise([async](Resolve&amp;&amp; resolve, Reject&amp;&amp;){ some_obj.funcCallback([async](){ resolve(); }, val); }); }</span></span></code> </pre> <br><h4 id="mnenie-avtora-planirovschik-soprogramm---eto-perebor"> 作者观点：协程策划师是半身像 </h4><br><p> 一些批评家称缺少调度程序和对处理器资源的“不诚实”使用是一个问题。 也许更严重的问题是数据局部性和处理器缓存的有效利用。 </p><br><p> 关于第一个问题：在各个协程级别上进行优先级排序似乎开销很大。 相反，它们可以为特定的统一任务共同操作。 这就是流量的作用。 </p><br><p> 这可以通过使用其自己的“铁”线程创建单独的Event Loop实例并在操作系统级别进行计划来实现。 第二种选择是在竞争和/或性能方面将协程与相对原始的（Mutex，Throttle）原始同步。 </p><br><p> 异步编程不会使处理器资源具有弹性，并且需要对同时处理的任务数量和总执行时间进行绝对正常的限制。 </p><br><p> 防止在一个协程上长时间阻塞需要采取与回调相同的措施-避免阻塞系统调用和冗长的数据处理周期。 </p><br><p> 第二个问题需要研究，但至少协程本身会堆叠在一起，并且Future / Promise实现的详细信息已经违反了数据的局部性。 如果将来已经很重要，则有机会尝试继续执行相同的协程。 为了防止一个协程捕获整个处理器时间，需要某种机制来计算执行时间或这种连续的次数。 根据处理器缓存的大小和线程数的不同，这可能不会给出结果，或者给出非常双重的结果。 </p><br><p> 还有第三点-协程调度程序的许多实现允许您在不同的处理器内核上运行它们，相反，由于在访问共享资源时进行强制同步，因此增加了问题。 在单个事件循环流的情况下，仅在逻辑级别需要这种同步，因为 保证每个同步回调块都可以正常工作，而不会与其他组件竞争。 </p><br><h4 id="mnenie-avtora-vsyo-horosho-v-meru"> 作者的观点：一切都要适度 </h4><br><p> 现代操作系统中线程的存在不会否定单个进程的使用。 同样，在事件循环中处理大量客户端并不会否定将隔离的“铁”线程用于其他需求。 </p><br><p> 无论如何，协程和事件循环的各种变体在没有必要工具支持的情况下使调试过程复杂化，并且在协程堆栈上具有局部变量，一切都变得更加困难-几乎没有办法获得它们。 </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/2p/pp/lb/2ppplbzrvm8c0yvbasdwrojknss.png" width="326" height="326"></div><br><h2 id="futoin-asyncsteps---alternativa-soprogrammam">  FutoIn AsyncSteps-协程的替代品 </h2><br><p> 我们以已经建立的事件循环模式和根据ECMAScript（JavaScript）Promise类型的回调方案的组织为基础。 </p><br><p> 在执行计划方面，我们对Event Loop的以下活动感兴趣： </p><br><ol><li>  <code>Handle immediate(callack)</code>需要干净调用堆栈的<code>Handle immediate(callack)</code> 。 </li><li>  Deferred callback延迟<code>Handle deferred(delay, callback)</code> 。 </li><li> 取消回调<code>handle.cancel()</code> 。 </li></ol><br><p> 因此，我们获得了一个名为<code>AsyncTool</code>的接口，该接口可以通过多种方式实现，包括在现有的经过验证的开发之上。 他与编写业务逻辑没有直接关系，因此我们不再赘述。 </p><br><h3 id="derevo-shagov"> 步骤树： </h3><br><p> 在AsyncSteps概念中，通过深入创建序列来排列并执行同步步骤的抽象树。 完成这样的通道后，将动态设置每个更深层次的步骤。 </p><br><p> 所有交互都通过单个<code>AsyncSteps</code>接口进行，按照约定，该接口作为第一个参数传递到每个步骤。 按照惯例，参数名称为<code>asi</code>或不建议使用。 这种方法使您几乎可以完全打破特定实现之间的联系，并在插件和库中编写业务逻辑。 </p><br><p> 在规范的实现中，每个步骤都会收到自己的对象实例，该对象实现<code>AsyncSteps</code> ，该实例允许在使用接口时及时跟踪逻辑错误。 </p><br><p> 抽象示例： </p><br><pre> <code class="hljs lua"> asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func"</span></span> ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> func( asi ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func"</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) asi.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) } ) }, onerror( asi, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ){ // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> catch <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { asi.success( <span class="hljs-string"><span class="hljs-string">"Prm"</span></span>, <span class="hljs-number"><span class="hljs-number">123</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } } ) asi.add( // Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> func( asi, str_param, int_param, array_param ){ <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func2: "</span></span> + param ) } )</code> </pre> <br><p> 执行结果： </p><br><pre> <code class="hljs pgsql"> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> func <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: MyError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> onerror <span class="hljs-number"><span class="hljs-number">1</span></span>: NewError <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> func <span class="hljs-number"><span class="hljs-number">2</span></span>: Prm</code> </pre> <br><p> 同步显示如下： </p><br><pre> <code class="hljs coffeescript"> str_res, int_res, array_res, bool_res <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 func 1"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"MyError"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">1</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 1 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( error ){ <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 onerror 1: "</span></span> + error ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( error strequal <span class="hljs-string"><span class="hljs-string">"NewError"</span></span> ) { str_res = <span class="hljs-string"><span class="hljs-string">"Prm"</span></span> int_res = <span class="hljs-number"><span class="hljs-number">123</span></span> array_res = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] bool_res = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { re-<span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> } } { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Level <span class="hljs-number"><span class="hljs-number">0</span></span> step <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>( <span class="hljs-string"><span class="hljs-string">"Level 0 func 2: "</span></span> + str_res ) }</code> </pre> <br><p> 传统同步代码的最大模仿是立即可见的，这应该有助于提高可读性。 </p><br><p> 从业务逻辑的角度来看， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">大量需求</a>随时间增长，但是我们可以将其分为易于理解的部分。 如下所述，是实际运行四年的结果。 </p><br><h3 id="bazovye-api-vremeni-vypolneniya"> 核心运行时API： </h3><br><ol><li>  <code>add(func[, onerror])</code> -模仿<code>try-catch</code> 。 </li><li>  <code>success([args...])</code> -成功完成的明确指示： <br><ul><li> 默认暗示 </li><li> 可以将结果传递给下一步。 </li></ul></li><li>  <code>error(code[, reason)</code> -因错误而中断执行： <br><ul><li>  <code>code</code> -具有字符串类型，可以更好地与微服务架构中的网络协议集成， </li><li>  <code>reason</code> -对一个人的任意解释。 </li></ul></li><li>  <code>state()</code> -线程本地存储的模拟。 预定义的关联键： <br><ul><li>  <code>error_info</code>对一个人的最后一个错误的解释， </li><li>  <code>last_exception</code>指向最后一个异常的对象的指针， </li><li>  <code>async_stack</code>技术允许的异步调用堆栈， </li><li> 其余的由用户设置。 </li></ul></li></ol><br><p> 前面的示例已经具有真正的C ++代码和一些其他功能： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/iasyncsteps.hpp&gt; using namespace futoin; void some_api(IAsyncSteps&amp; asi) { asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 0 func 1" &lt;&lt; std::endl; asi.add( [](IAsyncSteps&amp; asi) { std::cout &lt;&lt; "Level 1 func 1" &lt;&lt; std::endl; asi.error("MyError"); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 1 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; asi.error("NewError", "Human-readable description"); } ); }, [](IAsyncSteps&amp; asi, ErrorCode code) { std::cout &lt;&lt; "Level 0 onerror 1: " &lt;&lt; code &lt;&lt; std::endl; if (code == "NewError") { // Human-readable error info assert(asi.state().error_info == "Human-readable description"); // Last exception thrown is also available in state std::exception_ptr e = asi.state().last_exception; // NOTE: smart conversion of "const char*" asi.success("Prm", 123, std::vector&lt;int&gt;({1, 2, 3}, true)); } } ); asi.add( [](IAsyncSteps&amp; asi, const futoin::string&amp; str_res, int int_res, std::vector&lt;int&gt;&amp;&amp; arr_res) { std::cout &lt;&lt; "Level 0 func 2: " &lt;&lt; str_res &lt;&lt; std::endl; } ); }</span></span></span></span></code> </pre> <br><h3 id="api-dlya-sozdaniya-ciklov"> 用于创建循环的API： </h3><br><ol><li>  <code>loop( func, [, label] )</code> -无限重复的步骤。 </li><li>  <code>forEach( map|list, func [, label] )</code> -集合对象的逐步迭代。 </li><li>  <code>repeat( count, func [, label] )</code> -逐步重复指定的次数。 </li><li>  <code>break( [label] )</code>是传统循环中断的类似物。 </li><li>  <code>continue( [label] )</code>是传统循环延续的类似形式，但有新的迭代。 </li></ol><br><p>  <em>规范提供备用名称<code>breakLoop</code> ， <code>continueLoop</code>等，以防与保留字冲突。</em> </p><br><p>  C ++示例： </p><br><pre> <code class="cpp hljs"> asi.loop([](IAsyncSteps&amp; asi) { <span class="hljs-comment"><span class="hljs-comment">// infinite loop asi.breakLoop(); }); asi.repeat(10, [](IAsyncSteps&amp; asi, size_t i) { // range loop from i=0 till i=9 (inclusive) asi.continueLoop(); }); asi.forEach( std::vector&lt;int&gt;{1, 2, 3}, [](IAsyncSteps&amp; asi, size_t i, int v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::list&lt;futoin::string&gt;{"1", "2", "3"}, [](IAsyncSteps&amp; asi, size_t i, const futoin::string&amp; v) { // Iteration of vector-like and list-like objects }); asi.forEach( std::map&lt;futoin::string, futoin::string&gt;(), [](IAsyncSteps&amp; asi, const futoin::string&amp; key, const futoin::string&amp; v) { // Iteration of map-like objects }); std::map&lt;std::string, futoin::string&gt; non_const_map; asi.forEach( non_const_map, [](IAsyncSteps&amp; asi, const std::string&amp; key, futoin::string&amp; v) { // Iteration of map-like objects, note the value reference type });</span></span></code> </pre> <br><h3 id="api-integracii-s-vneshnimi-sobytiyami"> 与外部事件集成的API： </h3><br><ol><li>  <code>setTimeout( timeout_ms )</code> -如果步骤及其子树尚未完成执行，则在<code>Timeout</code>后引发<code>Timeout</code>错误。 </li><li>  <code>setCancel( handler )</code> -设置取消处理程序，当完全取消线程以及在错误处理过程中扩展异步步骤堆栈时调用此处理程序。 </li><li>  <code>waitExternal()</code> -一个简单的等待外部事件。 <br><ul><li>  <em>注意：仅在带有垃圾收集器的技术中使用是安全的。</em> </li></ul></li></ol><br><p> 调用这些函数中的任何一个都需要显式调用<code>success()</code> 。 </p><br><p>  C ++示例： </p><br><pre> <code class="cpp hljs"> asi.add([](IAsyncSteps&amp; asi) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> handle = schedule_external_callback([&amp;](<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> err) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { asi.error(<span class="hljs-string"><span class="hljs-string">"ExternalError"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (...) { <span class="hljs-comment"><span class="hljs-comment">// pass } } else { asi.success(); } }); asi.setCancel([=](IAsyncSteps&amp; asi) { external_cancel(handle); }); }); asi.add( [](IAsyncSteps&amp; asi) { // Raises Timeout error after specified period asi.setTimeout(std::chrono::seconds{10}); asi.loop([](IAsyncSteps&amp; asi) { // infinite loop }); }, [](IAsyncSteps&amp; asi, ErrorCode code) { if (code == futoin::errors::Timeout) { asi(); } });</span></span></code> </pre> <br><p>  ECMAScript示例： </p><br><pre> <code class="javascript hljs">asi.add( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">asi</span></span></span><span class="hljs-function">) =&gt;</span></span> { asi.waitExternal(); <span class="hljs-comment"><span class="hljs-comment">// disable implicit success() some_obj.read( (err, data) =&gt; { if (!asi.state) { // ignore as AsyncSteps execution got canceled } else if (err) { try { asi.error( 'IOError', err ); } catch (_) { // ignore error thrown as there are no // AsyncSteps frames on stack. } } else { asi.success( data ); } } ); } );</span></span></code> </pre> <br><h3 id="api-integracii-s-futurepromise"> 未来/承诺集成API： </h3><br><ol><li>  <code>await(promise_future[, on_error])</code> -等待Future / Promise作为一个步骤。 </li><li>  <code>promise()</code> -将整个执行流程转换为Future / Promise，而不是<code>execute()</code> 。 </li></ol><br><p>  C ++示例： </p><br><pre> <code class="hljs pgsql"> [](IAsyncSteps&amp; asi) { // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> AsyncSteps instances // <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> hard dependency <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> implementation. auto new_steps = asi.newInstance(); new_steps-&gt;<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([](IAsyncSteps&amp; asi) {}); // Can be <span class="hljs-keyword"><span class="hljs-keyword">called</span></span> outside <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> AsyncSteps event <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> // new_steps.promise().wait(); // <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> // new_steps.promise&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(); // Proper way <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> wait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> standard std::future asi.await(new_steps-&gt;promise()); // Ensure instance lifetime asi.state()["some_obj"] = std::<span class="hljs-keyword"><span class="hljs-keyword">move</span></span>(new_steps); };</code> </pre> <br><h3 id="api-kontrolya-potoka-vypolneniya-biznes-logiki"> 业务逻辑流控制API： </h3><br><ol><li>  <code>AsyncSteps(AsyncTool&amp;)</code>是将执行线程绑定到特定事件循环的构造函数。 </li><li>  <code>execute()</code> -启动执行线程。 </li><li>  <code>cancel()</code> -取消执行线程。 </li></ol><br><p> 这里已经需要特定的接口实现。 </p><br><p>  C ++示例： </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/asyncsteps.hpp&gt; #include &lt;futoin/ri/asynctool.hpp&gt; void example() { futoin::ri::AsyncTool at; futoin::ri::AsyncSteps asi{at}; asi.loop([&amp;](futoin::IAsyncSteps &amp;asi){ // Some infinite loop logic }); asi.execute(); std::this_thread::sleep_for(std::chrono::seconds{10}); asi.cancel(); // called in d-tor by fact }</span></span></span></span></code> </pre> <br><h3 id="prochie-api"> 其他API： </h3><br><ol><li>  <code>newInstance()</code> -允许您创建新的执行线程，而无需直接依赖于实现。 </li><li>  <code>sync(object, func, onerror)</code> -相同，但是相对于实现相应接口的对象具有同步。 </li><li>  <code>parallel([on_error])</code> -特殊的<code>add()</code> ，其子步骤是单独的AsyncSteps流： <br><ul><li> 所有线程都有共同的<code>state()</code> ， </li><li> 父线程在所有子线程完成后继续执行 </li><li> 任何子级中未捕获的错误会立即取消所有其他子级线程。 </li></ul></li></ol><br><p>  C ++示例： </p><br><pre> <code class="cpp hljs"> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;futoin/ri/mutex.hpp&gt; using namespace futoin; ri::Mutex mtx_a; void sync_example(IAsyncSteps&amp; asi) { asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { // synchronized section asi.add([](IAsyncSteps&amp; asi) { // inner step in the section // This synchronization is NOOP for already // acquired Mutex. asi.sync(mtx_a, [](IAsyncSteps&amp; asi) { }); }); }); } void parallel_example(IAsyncSteps&amp; asi) { using OrderVector = std::vector&lt;int&gt;; asi.state("order", OrderVector{}); auto&amp; p = asi.parallel([](IAsyncSteps&amp; asi, ErrorCode) { // Overall error handler asi.success(); }); p.add([](IAsyncSteps&amp; asi) { // regular flow asi.state&lt;OrderVector&gt;("order").push_back(1); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(4); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(2); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(5); asi.error("SomeError"); }); }); p.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(3); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order").push_back(6); }); }); asi.add([](IAsyncSteps&amp; asi) { asi.state&lt;OrderVector&gt;("order"); // 1, 2, 3, 4, 5 }); };</span></span></span></span></code> </pre> <br><h3 id="standartnye-primitivy-dlya-sinhronizacii"> 同步的标准原语 </h3><br><ol><li>  <code>Mutex</code>限制同时在<code>Q</code>的队列中同时执行<code>N</code>线程，默认情况下<code>N=1, Q=unlimited</code> 。 </li><li>  <code>Throttle</code> -在周期<code>P</code>中限制<code>Q</code>的输入<code>P</code>的数量<code>N</code> ，默认情况下<code>N=1, P=1s, Q=0</code> 。 </li><li>  <code>Limiter</code>是<code>Mutex</code>和<code>Throttle</code>的组合，通常用于处理外部请求的输入以及在调用外部系统以在负载下稳定运行的目的。 </li></ol><br><p> 如果<code>DefenseRejected</code>队列限制，则会<code>DefenseRejected</code>错误，其含义从<code>Limiter</code>描述中可以清楚看出。 </p><br><h3 id="klyuchevye-preimuschestva"> 主要好处 </h3><br><p>  AsyncSteps的概念本身并不是目的，而是出于对时间的限制，取消和各个回调的整体连接性而需要对程序进行更受控的异步执行的需要而诞生的。 当时还没有通用解决方案提供相同的功能。 因此： </p><br><p> <strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> FTN12</a>   </strong> —           . </p><br><p> <strong>  <code>setCancel()</code></strong> —                    .       ,     .   RAII  <code>atexit()</code>   . </p><br><p> <strong>   <code>cancel()</code></strong> —     ,         .   <code>SIGTERM</code>  <code>pthread_cancel()</code> ,       . </p><br><p> <strong>   <code>setTimeout()</code></strong> —                 .    ,    "Timeout". </p><br><p> <strong>     </strong> —  FutoIn AsyncSteps             . </p><br><p> <strong>      </strong> —          ABI     ,    .    Embedded     MMU. </p><br><hr><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yj/8x/wv/yj8xwvibm7tjsj30qhojwbleige.jpeg"></div><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em> </em></a> </p><br><h2 id="k-cifram">   </h2><br><p>    Intel Xeon E3-1245v2/DDR1333  Debian Stretch    . </p><br><p>   : </p><br><ol><li> Boost.Fiber  <code>protected_fixedsize_stack</code> . </li><li> Boost.Fiber  <code>pooled_fixedsize_stack</code>     . </li><li> FutoIn AsyncSteps   . </li><li> FutoIn AsyncSteps      ( <code>FUTOIN_USE_MEMPOOL=false</code> ). <br><ul><li>      <code>futoin::IMemPool</code> . </li></ul></li><li> FutoIn NitroSteps&lt;&gt; —           . <br><ul><li>         . </li></ul></li></ol><br><p>    Boost.Fiber    : </p><br><ol><li>     1 . . </li><li>       30 .   1 . . <br><ul><li>   30 .     <code>mmap()/mprotect()</code>  <code>boost::fiber::protected_fixedsize_stack</code> . </li><li>          . </li></ul></li><li>   30 .   10 .     . <br><ul><li>    ""          . </li></ul></li></ol><br><p>      "" , ..     ,       .        .   . </p><br><p>    GCC 6.3.0.   lang  tcmalloc  ,     . </p><br><p>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitLab</a> . </p><br><h3 id="1-posledovatelnoe-sozdanie"> 1.   </h3><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 4.8s </td><td> 208333.333Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 0.23s </td><td> 4347826.086Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>0.21s</strong> </td><td> <strong>4761904.761Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 0.31s </td><td> 3225806.451Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 0.255s </td><td> 3921568.627Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qm/ur/y6/qmury65-mbkth_om8smkfi7vamq.png"></div><br><p> <em> — .</em> </p><br><p>     Boost.Fiber -      ,     <code>pooled_fixedsize_stack</code>   ,    AsyncSteps. </p><br><h3 id="2-parallelnoe-sozdanie-i-ispolnenie"> 2.     </h3><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 6.31s </td><td> 158478.605Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 1.558s </td><td> 641848.523Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1.13s</strong> </td><td> <strong>884955.752Hz</strong> </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 1.353s </td><td> 739098.300Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> 1.43s </td><td> 699300.699Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0s/gz/lu/0sgzlur2xsrlf-wo4mrcynvzhxi.png"></div><br><p> <em> — .</em> </p><br><p>    ,          .    ,        —            . </p><br><h3 id="3-parallelnye-cikly"> 3.   </h3><br><table><thead><tr><th>  </th><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 5.096s </td><td> 1962323.390Hz </td></tr><tr><td> Boost.Fiber pooled </td><td> 5.077s </td><td> 1969667.126Hz </td></tr><tr><td> FutoIn AsyncSteps </td><td> 5.361s </td><td> 1865323.633Hz </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> 8.288s </td><td> 1206563.706Hz </td></tr><tr><td> FutoIn NitroSteps </td><td> <strong>3.68s</strong> </td><td> <strong>2717391.304Hz</strong> </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/c1/17/pbc117djqds0d4twh5fzcklsmfc.png"></div><br><p> <em> — .</em> </p><br><p>   ,        Boost.Fiber      AsyncSteps,    NitroSteps. </p><br><h3 id="ispolzovanie-pamyati-po-rss">   ( RSS) </h3><br><table><thead><tr><th>  </th><th>  </th></tr></thead><tbody><tr><td> Boost.Fiber protected </td><td> 124M </td></tr><tr><td> Boost.Fiber pooled </td><td> 505M </td></tr><tr><td> FutoIn AsyncSteps </td><td> 124M </td></tr><tr><td> FutoIn AsyncSteps no mempool </td><td> <strong>84M</strong> </td></tr><tr><td> FutoIn NitroSteps </td><td> 115M </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/w0/6n/olw06nef5wj3ah1lo9u-pby9sfg.png"></div><br><p> <em> — .</em> </p><br><p>  , Boost.Fiber  . </p><br><h3 id="bonus-testy-na-nodejs"> :   Node.js </h3><br><p>      -  <code>Promise</code> : +    10 . .   10 .          JIT  <code>NODE_ENV=production</code> ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@futoin/optihelp</code></a> . </p><br><p>      <a href="">GitHub</a>  <a href="">GitLab</a> .   Node.js v8.12.0  v10.11.0,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">FutoIn CID</a> . </p><br><table><thead><tr><th> Tech </th><th> Simple </th><th> Loop </th></tr></thead><tbody><tr><td> <strong>Node.js v10</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>1342899.520Hz</strong> </td><td> 587.777Hz </td></tr><tr><td> async/await </td><td> 524983.234Hz </td><td> <strong>630.863Hz</strong> </td></tr><tr><td> <strong>Node.js v8</strong> </td><td></td><td></td></tr><tr><td> FutoIn AsyncSteps </td><td> <strong>682420.735Hz</strong> </td><td> <strong>588.336Hz</strong> </td></tr><tr><td> async/await </td><td> 365050.395Hz </td><td> 400.575Hz </td></tr></tbody></table><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x7/-n/b5/x7-nb5v9dfkwn1lttyg67w2b_tk.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gh/yj/9p/ghyj9pczw0smbfksq-aad_tltay.png"></div><br><p> <em> — .</em> </p><br><p>   <code>async/await</code> ? ,   V8  Node.js v10       . </p><br><p>  ,   Promise  <code>async/await</code> <strong></strong> Node.js Event Loop.          ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ),   FutoIn AsyncSteps   . </p><br><p> <em>   AsyncSteps  Node.js Event Loop      <code>async/await</code>  -  Node.js v10.</em> </p><br><p> <em>,      ++   —    .  ,    Node.js    10 .</em> </p><br><h3 id="vyvody"> 结论 </h3><br><p>   C++, FutoIn AsyncSteps  Boost.Fiber       ,     Boost.Fiber         <code>mmap()/mprotect</code> . </p><br><p>       ,      -      ,   .     . </p><br><p> FutoIn AsyncSteps  JavaScript  <code>async/await</code>       Node.js v10. </p><br><p>   ,       -,       .        . </p><br><p>   -                        ""  .     —   API. </p><br><hr><br><h2 id="zaklyuchenie"> 结论 </h2><br><p> ,  FutoIn AsyncSteps ,          "" <code>async/await</code> . ,         .      <code>Promise</code>  ECMAScript, AsyncSteps    ""           . </p><br><p>               .        AsyncSteps  NitroSteps   . </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> ,    - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a> . </p><br><p>       Java/JVM         —    .    . </p><br><p>      ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitLab</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN424311/">https://habr.com/ru/post/zh-CN424311/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN424297/index.html">麻省理工学院的课程“计算机系统安全”。 讲座9：Web应用程序安全性，第3部分</a></li>
<li><a href="../zh-CN424301/index.html">自适应神经网络图像滤波算法</a></li>
<li><a href="../zh-CN424305/index.html">Uber跨平台移动架构RIB</a></li>
<li><a href="../zh-CN424307/index.html">GitLab 11.3与Maven存储库和安全环境一起发布</a></li>
<li><a href="../zh-CN424309/index.html">DevCore：DevBoy项目的软件部分</a></li>
<li><a href="../zh-CN424313/index.html">EveryLang是一个几乎可以做所有事情的程序</a></li>
<li><a href="../zh-CN424315/index.html">新一轮进口替代。 在哪里跑步，怎么办？</a></li>
<li><a href="../zh-CN424319/index.html">网上商店的结构。 第二部分</a></li>
<li><a href="../zh-CN424321/index.html">让NetFlow便宜又生气</a></li>
<li><a href="../zh-CN424323/index.html">Google和Microsoft产品经理使用ICE方法的示例</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>