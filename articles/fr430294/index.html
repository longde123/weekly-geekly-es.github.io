<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🎓 👨🏾‍🤝‍👨🏼 🦂 10 avantages évidents de l'utilisation de Rust 🏪 👩🏾‍🔧 🈷️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust est un langage de programmation système jeune et ambitieux. Il implémente la gestion automatique de la mémoire sans un garbage collector et autre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 avantages évidents de l'utilisation de Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust est un langage de programmation système jeune et ambitieux.  Il implémente la gestion automatique de la mémoire sans un garbage collector et autres frais généraux de temps d'exécution.  De plus, la langue par défaut est utilisée dans la langue Rust, il existe des règles sans précédent pour accéder aux données mutables et les durées de vie des liens sont également prises en compte.  Cela lui permet de garantir la sécurité de la mémoire et facilite la programmation multi-thread, en raison du manque de course aux données. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> Tout cela est déjà bien connu de tous ceux qui suivent au moins un peu le développement des technologies de programmation modernes.  Mais que se passe-t-il si vous n'êtes pas programmeur système et qu'il n'y a pas beaucoup de code multithread dans vos projets, mais vous êtes toujours attiré par les performances de Rust.  Tirerez-vous des avantages supplémentaires de son utilisation dans les applications?  Ou tout ce qu'il vous donnera en plus est un combat acharné avec le compilateur, qui vous forcera à écrire le programme afin qu'il suive constamment les règles du langage sur l'emprunt et la propriété? </p><br><p>  Cet article a rassemblé une douzaine d'avantages non évidents et pas particulièrement annoncés de l'utilisation de Rust, ce qui, je l'espère, vous aidera à décider du choix de cette langue pour vos projets. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. L'universalité de la langue </h2><br><p>  Malgré le fait que Rust soit positionné comme un langage pour la programmation système, il convient également pour résoudre des problèmes appliqués de haut niveau.  Vous n'avez pas à travailler avec des pointeurs bruts, sauf si vous en avez besoin pour votre tâche.  La bibliothèque de langues standard a déjà implémenté la plupart des types et fonctions qui peuvent être nécessaires au développement d'applications.  Vous pouvez également connecter facilement des bibliothèques externes et les utiliser.  Le système de type et la programmation généralisée dans Rust permettent d'utiliser des abstractions d'un niveau assez élevé, bien qu'il n'y ait pas de support direct pour la POO dans le langage. </p><br><p>  Regardons quelques exemples simples d'utilisation de Rust. </p><br><p>  Un exemple de combinaison de deux itérateurs en un seul itérateur sur des paires d'éléments: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><blockquote>  Remarque: un appel au <code>name!(...)</code> format <code>name!(...)</code> est un appel à une macro fonctionnelle.  Les noms de ces macros dans Rust se terminent toujours par un symbole <code>!</code>  afin qu'ils puissent être distingués des noms de fonction et autres identifiants.  Les avantages de l'utilisation des macros seront discutés ci-dessous. </blockquote><p>  Un exemple d'utilisation de la bibliothèque d'expressions régulières pour travailler avec des expressions régulières: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Un exemple de l'implémentation du <code>Add</code> pour la propre structure <code>Point</code> pour surcharger l'opérateur d'addition: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Un exemple d'utilisation d'un type générique dans une structure: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Sur Rust, vous pouvez écrire des utilitaires système efficaces, de grandes applications de bureau, des microservices, des applications Web (y compris la partie client, car Rust peut être compilé dans Wasm), des applications mobiles (bien que l'écosystème linguistique soit encore mal développé dans cette direction).  Une telle polyvalence peut être un avantage pour les équipes multi-projets, car elle vous permet d'utiliser les mêmes approches et les mêmes modules dans de nombreux projets différents.  Si vous êtes habitué au fait que chaque outil est conçu pour son champ d'application étroit, essayez de considérer Rust comme une boîte à outils avec la même fiabilité et la même commodité.  C'est peut-être exactement ce qui vous manquait. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Outils de construction et de gestion des dépendances pratiques </h2><br><p>  Ce n'est clairement pas annoncé, mais beaucoup remarquent que Rust possède l'un des meilleurs systèmes de gestion de la construction et des dépendances disponibles aujourd'hui.  Si vous avez programmé en C ou C ++, et que la question de l'utilisation indolore des bibliothèques externes était assez aiguë pour vous, alors utiliser Rust avec son outil de construction et son gestionnaire de dépendance Cargo sera un bon choix pour vos nouveaux projets. </p><br><p>  En plus du fait que Cargo télécharge des dépendances pour vous et gère leurs versions, crée et exécute vos applications, exécute des tests et génère de la documentation, il peut également être étendu avec des plugins pour d'autres fonctions utiles.  Par exemple, il existe des extensions qui permettent à Cargo de déterminer les dépendances obsolètes de votre projet, d'effectuer une analyse statique du code source, de créer et de redéployer des parties clientes d'applications Web, et bien plus encore. </p><br><p>  Le fichier de configuration Cargo utilise le langage de balisage toml convivial et minimal pour décrire les paramètres du projet.  Voici un exemple de <code>Cargo.toml</code> configuration typique de <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  Et voici trois commandes typiques pour utiliser Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Avec leur aide, le code source sera vérifié pour les erreurs de compilation, l'assemblage du projet et le lancement des tests, l'assemblage et le lancement du programme pour l'exécution, respectivement. </p><br><h2 id="3-vstroennye-testy">  3. Tests intégrés </h2><br><p>  Écrire des tests unitaires dans Rust est si facile et simple que vous voulez le faire encore et encore.  :) Il sera souvent plus facile d'écrire un test unitaire que d'essayer de tester la fonctionnalité d'une autre manière.  Voici un exemple de fonctions et de tests pour eux: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Les fonctions du module de <code>test</code> , marquées de l'attribut <code>#[test]</code> , sont des tests unitaires.  Ils seront exécutés en parallèle lors de l'appel de la commande de <code>cargo test</code> .  L'attribut de compilation conditionnelle <code>#[cfg(test)]</code> , qui marque l'ensemble du module avec des tests, conduira au fait que le module sera compilé uniquement lorsque les tests seront exécutés et n'entrera pas dans l'assembly normal. </p><br><p>  Il est très pratique de placer les tests dans le même module que la fonctionnalité sous test, simplement en y ajoutant le sous-module de <code>test</code> .  Et si vous avez besoin de tests d'intégration, placez simplement vos tests dans le répertoire <code>tests</code> à la racine du projet et utilisez-y votre application comme package externe.  Dans ce cas, il n'est pas nécessaire d'ajouter un module de <code>test</code> séparé et des directives de compilation conditionnelle. </p><br><p>  Des exemples spéciaux de documentation exécutée en tant que tests méritent une attention particulière, mais cela sera discuté ci-dessous. </p><br><p>  Des tests de performances intégrés (benchmarks) sont également disponibles, mais ils ne sont pas encore stables, ils ne sont donc disponibles que dans les assemblys de nuit du compilateur.  Dans Rust stable, vous devrez utiliser des bibliothèques externes pour ce type de test. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Bonne documentation avec des exemples actuels </h2><br><p>  La bibliothèque Rust standard est très bien documentée.  La documentation HTML est automatiquement générée à partir du code source avec des descriptions de démarques dans les commentaires du dock.  De plus, les commentaires doc dans le code Rust contiennent un exemple de code qui s'exécute lorsque les tests sont exécutés.  Cela garantit la pertinence des exemples: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>La documentation</em></a> </p><br><p>  Voici un exemple d'utilisation de la méthode <code>as_bytes</code> de type <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  sera exécuté comme test lors du lancement des tests. </p><br><p>  De plus, la pratique de créer des exemples de leur utilisation sous la forme de petits programmes indépendants situés dans le répertoire d' <code>examples</code> à la racine du projet est courante pour les bibliothèques Rust.  Ces exemples sont également une partie importante de la documentation et ils sont également compilés et exécutés pendant l'exécution du test, mais ils peuvent être exécutés indépendamment des tests. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Auto-déduction intelligente des types </h2><br><p>  Dans un programme Rust, vous ne pouvez pas spécifier explicitement le type d'expression si le compilateur est capable de le générer automatiquement en fonction du contexte d'utilisation.  Et cela ne s'applique pas seulement aux endroits où les variables sont déclarées.  Regardons un exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Si nous organisons les annotations de type, cet exemple ressemblera à ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Autrement dit, nous avons un vecteur de tranches de chaîne et une variable de type tranche de chaîne.  Mais dans ce cas, la spécification des types est complètement redondante, car le compilateur peut les produire par lui-même (en utilisant la version étendue de l'algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hindley-Milner</a> ).  Le fait que <code>vec</code> est un vecteur est déjà clair par le type de la valeur de retour de <code>Vec::new()</code> , mais il n'est pas encore clair quel type de ses éléments seront.  Le fait que le type de <code>text</code> soit une tranche de chaîne est compréhensible par le fait qu'on lui affecte un littéral de ce type.  Ainsi, après <code>vec.push(text)</code> , le type d'éléments vectoriels devient évident.  Notez que le type de la variable <code>vec</code> été complètement déterminé par son utilisation dans le thread d'exécution, et non au stade de l'initialisation. </p><br><p>  Un tel système d'inférence de type élimine le bruit du code et le rend aussi concis que le code dans un langage de programmation typé dynamiquement.  Et cela tout en conservant une frappe statique stricte! </p><br><p>  Bien sûr, nous ne pouvons pas nous débarrasser complètement de la saisie dans une langue typée statiquement.  Le programme doit avoir des points auxquels les types d'objets sont garantis pour être connus, afin qu'à d'autres endroits ces types puissent être affichés.  De tels points dans Rust sont des déclarations de types de données définis par l'utilisateur et de signatures de fonctions, dans lesquelles on ne peut que spécifier les types utilisés.  Mais vous pouvez y entrer des "méta-variables de types", en utilisant une programmation généralisée. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Correspondance de modèle aux points de déclaration variables </h2><br><p>  <code>let</code> opération </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  pas vraiment limité à simplement déclarer de nouvelles variables.  Ce qu'elle fait, c'est faire correspondre l'expression à droite du signe égal avec le motif à gauche.  Et de nouvelles variables peuvent être introduites dans le cadre de l'échantillon (et seulement ainsi).  Jetez un œil à l'exemple suivant, et il deviendra plus clair pour vous: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  La déstructuration a été effectuée ici: une telle comparaison introduira les variables <code>x</code> et <code>y</code> , qui seront initialisées avec la valeur des champs <code>x</code> et <code>y</code> de l'objet de la structure <code>Point</code> , qui est retournée en appelant <code>Point::new()</code> .  Dans le même temps, la comparaison est correcte, car le type de l'expression à droite correspond au modèle de <code>Point</code> de type <code>Point</code> à gauche.  De la même manière, vous pouvez prendre, par exemple, les deux premiers éléments d'un tableau: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Et bien plus encore.  La chose la plus remarquable est que de telles comparaisons sont effectuées dans tous les endroits où de nouveaux noms de variables peuvent être saisis dans Rust, à savoir: dans la <code>match</code> , les <code>if let</code> <code>let</code> , <code>if let</code> , <code>while let</code> , dans l'en-tête de la boucle <code>for</code> , dans les arguments des fonctions et des fermetures.  Voici un exemple d'utilisation élégante de la correspondance de motifs dans une boucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  La méthode <code>enumerate</code> , appelée sur l'itérateur, construit un nouvel itérateur, qui itérera non pas sur les valeurs initiales, mais sur les tuples, les paires "index ordinal, valeur initiale".  Chacun de ces tuples pendant l'itération du cycle sera mappé sur le modèle spécifié <code>(i, ch)</code> , à la suite de quoi la variable <code>i</code> recevra la première valeur du tuple - l'index et la variable <code>ch</code> - la seconde, c'est-à-dire le caractère de la chaîne.  Plus loin dans le corps de la boucle, nous pouvons utiliser ces variables. </p><br><p>  Un autre exemple populaire d'utilisation d'un motif dans une boucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Ici, nous ignorons simplement la valeur de l'itérateur en utilisant le modèle <code>_</code> .  Parce que nous n'utilisons pas le numéro d'itération dans le corps de la boucle.  La même chose peut être faite, par exemple, avec un argument de fonction: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Ou lors d'une correspondance dans une déclaration de <code>match</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  La correspondance de motifs rend le code très compact et expressif, et dans l'énoncé de <code>match</code> , il est généralement irremplaçable.  L'opérateur de <code>match</code> est un opérateur d'analyse variée complète, vous ne pourrez donc pas accidentellement oublier de vérifier certaines des correspondances possibles pour l'expression analysée. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Extension de syntaxe et DSL personnalisé </h2><br><p>  La syntaxe de Rust est limitée, en grande partie à cause de la complexité du système de type utilisé dans le langage.  Par exemple, Rust n'a pas d'arguments de fonction nommés ou de fonctions avec un nombre variable d'arguments.  Mais vous pouvez contourner ces limitations et d'autres avec des macros.  Rust a deux types de macros: déclarative et procédurale.  Avec les macros déclaratives, vous n'aurez jamais les mêmes problèmes qu'avec les macros en C, car elles sont hygiéniques et ne fonctionnent pas au niveau du remplacement de texte, mais au niveau du remplacement dans l'arborescence de syntaxe abstraite.  Les macros vous permettent de créer des abstractions au niveau de la syntaxe du langage.  Par exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Outre le fait que cette macro étend les capacités syntaxiques d'appeler la "fonction" d'impression d'une chaîne formatée, elle vérifiera également dans son implémentation que les arguments d'entrée correspondent à la chaîne de format spécifiée au moment de la compilation et non au moment de l'exécution.  À l'aide de macros, vous pouvez entrer une syntaxe concise pour vos propres besoins de conception, créer et utiliser DSL.  Voici un exemple d'utilisation de code JavaScript dans un programme Rust compilé dans Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Macro <code>js!</code>  défini dans le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>stdweb</code></a> et il vous permet d'incorporer du code JavaScript à part entière dans votre programme (à l'exception des chaînes entre guillemets simples et des opérateurs non complétés par un point-virgule) et d'utiliser des objets du code Rust en utilisant la syntaxe <code>@{expr}</code> . </p><br><p>  Les macros offrent d'énormes possibilités pour adapter la syntaxe des programmes Rust aux tâches spécifiques d'un domaine particulier.  Ils vous feront gagner du temps et de l'attention lors du développement d'applications complexes.  Non pas en augmentant la surcharge d'exécution, mais en augmentant le temps de compilation.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Génération automatique de code dépendant </h2><br><p>  Les macros de dérivation procédurale de Rust sont largement utilisées pour implémenter automatiquement des traits et d'autres génération de code.  Voici un exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Étant donné que tous ces types ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> et <code>Eq</code> ) de la bibliothèque standard sont implémentés pour le type de champs de la structure <code>i32</code> , leur implémentation peut être affichée automatiquement pour l'ensemble de la structure dans son ensemble.  Un autre exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Ici, en utilisant les <code>Deserialize</code> et <code>Deserialize</code> de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>serde</code></a> pour la structure <code>Point</code> , les méthodes pour sa sérialisation et sa désérialisation sont générées automatiquement.  Vous pouvez ensuite transmettre une instance de cette structure à diverses fonctions de sérialisation, par exemple, la convertir en chaîne JSON. </p><br><p>  Vous pouvez créer vos propres macros procédurales qui généreront le code dont vous avez besoin.  Ou utilisez les nombreuses macros déjà créées par d'autres développeurs.  En plus d'économiser le programmeur de l'écriture de code passe-partout, les macros ont également l'avantage que vous n'avez pas besoin de maintenir différentes sections de code dans un état cohérent.  Par exemple, si un troisième champ <code>z</code> est ajouté à la structure <code>Point</code> , pour effectuer correctement sa sérialisation, si vous utilisez dériver, vous n'avez rien d'autre à faire.  Si nous mettons nous-mêmes en œuvre les traits nécessaires à la sérialisation de <code>Point</code> , alors nous devrons nous assurer que cette mise en œuvre est toujours cohérente avec les derniers changements dans la structure de <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Type de données algébrique </h2><br><p>  Pour le dire simplement, un type de données algébrique est un type de données composite qui est une union de structures.  Plus formellement, il s'agit d'une somme de types de produits.  Dans Rust, ce type est défini à l'aide du mot clé <code>enum</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  Le type d'une valeur particulière d'une variable de type <code>Message</code> ne peut être que l'un des types de structure répertoriés dans <code>Message</code> .  Il s'agit soit d'une structure <code>Quit</code> sans champ de type unité, de l'une des structures de tuple <code>ChangeColor</code> ou <code>Write</code> avec des champs sans nom, ou de la structure <code>Move</code> habituelle.  Un type énuméré traditionnel peut être représenté comme un cas particulier d'un type de données algébrique: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  Il est possible de savoir quel type a réellement pris de la valeur dans un cas particulier en utilisant la correspondance de modèles: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Sous la forme de types de données algébriques, Rust implémente des types importants tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Option</code></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Result</code></a> , qui sont utilisés pour représenter la valeur manquante et le résultat correct / erroné, respectivement.  Voici comment l' <code>Option</code> est définie dans la bibliothèque standard: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust n'a pas de valeur nulle, tout comme les erreurs gênantes d'un appel inattendu.  Au lieu de cela, lorsqu'il est vraiment nécessaire d'indiquer la possibilité d'une valeur manquante, <code>Option</code> utilisée: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Exécuter</em></a> </p><br><p>  Le type de données algébrique est un outil puissant et expressif qui ouvre la porte au développement piloté par type.  Un programme écrit avec compétence dans ce paradigme attribue la plupart des vérifications de l'exactitude de son travail au système de type.  Par conséquent, si vous manquez un peu de Haskell dans la programmation industrielle quotidienne, Rust peut être votre point de vente.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. Refactoring facile </h2><br><p>  Le système de type statique strict développé dans Rust et la tentative d'effectuer autant de vérifications que possible pendant la compilation, conduit au fait que la modification et la refactorisation du code deviennent assez simples et sûres.  Si, après les modifications, le programme a été compilé, cela signifie qu'il n'a laissé que des erreurs logiques qui n'étaient pas liées à la fonctionnalité dont la vérification a été affectée au compilateur.  Combiné à la facilité d'ajouter des tests unitaires à la logique de test, cela conduit à de sérieuses garanties de fiabilité des programmes et à une augmentation de la confiance du programmeur dans le bon fonctionnement de son code après avoir effectué des modifications. </p><br><hr><br><p>  C'est peut-être tout ce dont je voulais parler dans cet article.  Bien sûr, Rust présente de nombreux autres avantages, ainsi qu'un certain nombre d'inconvénients (une certaine humidité du langage, un manque d'idiomes de programmation familiers et une syntaxe «non littéraire»), qui ne sont pas mentionnés ici.  Si vous avez quelque chose à dire à leur sujet, écrivez dans les commentaires.  En général, essayez Rust dans la pratique.  Et peut-être que ses avantages pour vous l'emporteront sur toutes ses lacunes, comme cela s'est produit dans mon cas.  Et enfin, vous obtiendrez exactement l'ensemble d'outils dont vous aviez besoin pendant longtemps. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430294/">https://habr.com/ru/post/fr430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430282/index.html">9 personnes sur 10 acceptent de gagner moins pour un travail plus significatif</a></li>
<li><a href="../fr430284/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 275 (12 - 18 novembre)</a></li>
<li><a href="../fr430286/index.html">Détails du côté désordonné et sombre des jeux de pirates pour Nintendo Switch</a></li>
<li><a href="../fr430290/index.html">Une tentative de prédire la quatrième itération du projet SpaceX BFR</a></li>
<li><a href="../fr430292/index.html">Electronic Frontier Foundation: la performance du réseau de plaques d'immatriculation de la police américaine est de 0,5%</a></li>
<li><a href="../fr430296/index.html">Donnez vie à vos idées. Application sans serveur - instructions étape par étape</a></li>
<li><a href="../fr430300/index.html">Microservices on Go avec le kit Go: Introduction</a></li>
<li><a href="../fr430302/index.html">Une introduction à ptrace ou à l'injection de code dans sshd pour le plaisir</a></li>
<li><a href="../fr430304/index.html">Un merveilleux avant-poste en orbite</a></li>
<li><a href="../fr430306/index.html">Le premier tunnel de la société Boring foré par Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>