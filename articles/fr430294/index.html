<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüéì üë®üèæ‚Äçü§ù‚Äçüë®üèº ü¶Ç 10 avantages √©vidents de l'utilisation de Rust üè™ üë©üèæ‚Äçüîß üà∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust est un langage de programmation syst√®me jeune et ambitieux. Il impl√©mente la gestion automatique de la m√©moire sans un garbage collector et autre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 avantages √©vidents de l'utilisation de Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust est un langage de programmation syst√®me jeune et ambitieux.  Il impl√©mente la gestion automatique de la m√©moire sans un garbage collector et autres frais g√©n√©raux de temps d'ex√©cution.  De plus, la langue par d√©faut est utilis√©e dans la langue Rust, il existe des r√®gles sans pr√©c√©dent pour acc√©der aux donn√©es mutables et les dur√©es de vie des liens sont √©galement prises en compte.  Cela lui permet de garantir la s√©curit√© de la m√©moire et facilite la programmation multi-thread, en raison du manque de course aux donn√©es. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> Tout cela est d√©j√† bien connu de tous ceux qui suivent au moins un peu le d√©veloppement des technologies de programmation modernes.  Mais que se passe-t-il si vous n'√™tes pas programmeur syst√®me et qu'il n'y a pas beaucoup de code multithread dans vos projets, mais vous √™tes toujours attir√© par les performances de Rust.  Tirerez-vous des avantages suppl√©mentaires de son utilisation dans les applications?  Ou tout ce qu'il vous donnera en plus est un combat acharn√© avec le compilateur, qui vous forcera √† √©crire le programme afin qu'il suive constamment les r√®gles du langage sur l'emprunt et la propri√©t√©? </p><br><p>  Cet article a rassembl√© une douzaine d'avantages non √©vidents et pas particuli√®rement annonc√©s de l'utilisation de Rust, ce qui, je l'esp√®re, vous aidera √† d√©cider du choix de cette langue pour vos projets. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. L'universalit√© de la langue </h2><br><p>  Malgr√© le fait que Rust soit positionn√© comme un langage pour la programmation syst√®me, il convient √©galement pour r√©soudre des probl√®mes appliqu√©s de haut niveau.  Vous n'avez pas √† travailler avec des pointeurs bruts, sauf si vous en avez besoin pour votre t√¢che.  La biblioth√®que de langues standard a d√©j√† impl√©ment√© la plupart des types et fonctions qui peuvent √™tre n√©cessaires au d√©veloppement d'applications.  Vous pouvez √©galement connecter facilement des biblioth√®ques externes et les utiliser.  Le syst√®me de type et la programmation g√©n√©ralis√©e dans Rust permettent d'utiliser des abstractions d'un niveau assez √©lev√©, bien qu'il n'y ait pas de support direct pour la POO dans le langage. </p><br><p>  Regardons quelques exemples simples d'utilisation de Rust. </p><br><p>  Un exemple de combinaison de deux it√©rateurs en un seul it√©rateur sur des paires d'√©l√©ments: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><blockquote>  Remarque: un appel au <code>name!(...)</code> format <code>name!(...)</code> est un appel √† une macro fonctionnelle.  Les noms de ces macros dans Rust se terminent toujours par un symbole <code>!</code>  afin qu'ils puissent √™tre distingu√©s des noms de fonction et autres identifiants.  Les avantages de l'utilisation des macros seront discut√©s ci-dessous. </blockquote><p>  Un exemple d'utilisation de la biblioth√®que d'expressions r√©guli√®res pour travailler avec des expressions r√©guli√®res: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Un exemple de l'impl√©mentation du <code>Add</code> pour la propre structure <code>Point</code> pour surcharger l'op√©rateur d'addition: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Un exemple d'utilisation d'un type g√©n√©rique dans une structure: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Sur Rust, vous pouvez √©crire des utilitaires syst√®me efficaces, de grandes applications de bureau, des microservices, des applications Web (y compris la partie client, car Rust peut √™tre compil√© dans Wasm), des applications mobiles (bien que l'√©cosyst√®me linguistique soit encore mal d√©velopp√© dans cette direction).  Une telle polyvalence peut √™tre un avantage pour les √©quipes multi-projets, car elle vous permet d'utiliser les m√™mes approches et les m√™mes modules dans de nombreux projets diff√©rents.  Si vous √™tes habitu√© au fait que chaque outil est con√ßu pour son champ d'application √©troit, essayez de consid√©rer Rust comme une bo√Æte √† outils avec la m√™me fiabilit√© et la m√™me commodit√©.  C'est peut-√™tre exactement ce qui vous manquait. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Outils de construction et de gestion des d√©pendances pratiques </h2><br><p>  Ce n'est clairement pas annonc√©, mais beaucoup remarquent que Rust poss√®de l'un des meilleurs syst√®mes de gestion de la construction et des d√©pendances disponibles aujourd'hui.  Si vous avez programm√© en C ou C ++, et que la question de l'utilisation indolore des biblioth√®ques externes √©tait assez aigu√´ pour vous, alors utiliser Rust avec son outil de construction et son gestionnaire de d√©pendance Cargo sera un bon choix pour vos nouveaux projets. </p><br><p>  En plus du fait que Cargo t√©l√©charge des d√©pendances pour vous et g√®re leurs versions, cr√©e et ex√©cute vos applications, ex√©cute des tests et g√©n√®re de la documentation, il peut √©galement √™tre √©tendu avec des plugins pour d'autres fonctions utiles.  Par exemple, il existe des extensions qui permettent √† Cargo de d√©terminer les d√©pendances obsol√®tes de votre projet, d'effectuer une analyse statique du code source, de cr√©er et de red√©ployer des parties clientes d'applications Web, et bien plus encore. </p><br><p>  Le fichier de configuration Cargo utilise le langage de balisage toml convivial et minimal pour d√©crire les param√®tres du projet.  Voici un exemple de <code>Cargo.toml</code> configuration typique de <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  Et voici trois commandes typiques pour utiliser Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Avec leur aide, le code source sera v√©rifi√© pour les erreurs de compilation, l'assemblage du projet et le lancement des tests, l'assemblage et le lancement du programme pour l'ex√©cution, respectivement. </p><br><h2 id="3-vstroennye-testy">  3. Tests int√©gr√©s </h2><br><p>  √âcrire des tests unitaires dans Rust est si facile et simple que vous voulez le faire encore et encore.  :) Il sera souvent plus facile d'√©crire un test unitaire que d'essayer de tester la fonctionnalit√© d'une autre mani√®re.  Voici un exemple de fonctions et de tests pour eux: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Les fonctions du module de <code>test</code> , marqu√©es de l'attribut <code>#[test]</code> , sont des tests unitaires.  Ils seront ex√©cut√©s en parall√®le lors de l'appel de la commande de <code>cargo test</code> .  L'attribut de compilation conditionnelle <code>#[cfg(test)]</code> , qui marque l'ensemble du module avec des tests, conduira au fait que le module sera compil√© uniquement lorsque les tests seront ex√©cut√©s et n'entrera pas dans l'assembly normal. </p><br><p>  Il est tr√®s pratique de placer les tests dans le m√™me module que la fonctionnalit√© sous test, simplement en y ajoutant le sous-module de <code>test</code> .  Et si vous avez besoin de tests d'int√©gration, placez simplement vos tests dans le r√©pertoire <code>tests</code> √† la racine du projet et utilisez-y votre application comme package externe.  Dans ce cas, il n'est pas n√©cessaire d'ajouter un module de <code>test</code> s√©par√© et des directives de compilation conditionnelle. </p><br><p>  Des exemples sp√©ciaux de documentation ex√©cut√©e en tant que tests m√©ritent une attention particuli√®re, mais cela sera discut√© ci-dessous. </p><br><p>  Des tests de performances int√©gr√©s (benchmarks) sont √©galement disponibles, mais ils ne sont pas encore stables, ils ne sont donc disponibles que dans les assemblys de nuit du compilateur.  Dans Rust stable, vous devrez utiliser des biblioth√®ques externes pour ce type de test. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Bonne documentation avec des exemples actuels </h2><br><p>  La biblioth√®que Rust standard est tr√®s bien document√©e.  La documentation HTML est automatiquement g√©n√©r√©e √† partir du code source avec des descriptions de d√©marques dans les commentaires du dock.  De plus, les commentaires doc dans le code Rust contiennent un exemple de code qui s'ex√©cute lorsque les tests sont ex√©cut√©s.  Cela garantit la pertinence des exemples: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>La documentation</em></a> </p><br><p>  Voici un exemple d'utilisation de la m√©thode <code>as_bytes</code> de type <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  sera ex√©cut√© comme test lors du lancement des tests. </p><br><p>  De plus, la pratique de cr√©er des exemples de leur utilisation sous la forme de petits programmes ind√©pendants situ√©s dans le r√©pertoire d' <code>examples</code> √† la racine du projet est courante pour les biblioth√®ques Rust.  Ces exemples sont √©galement une partie importante de la documentation et ils sont √©galement compil√©s et ex√©cut√©s pendant l'ex√©cution du test, mais ils peuvent √™tre ex√©cut√©s ind√©pendamment des tests. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Auto-d√©duction intelligente des types </h2><br><p>  Dans un programme Rust, vous ne pouvez pas sp√©cifier explicitement le type d'expression si le compilateur est capable de le g√©n√©rer automatiquement en fonction du contexte d'utilisation.  Et cela ne s'applique pas seulement aux endroits o√π les variables sont d√©clar√©es.  Regardons un exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Si nous organisons les annotations de type, cet exemple ressemblera √† ceci: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Autrement dit, nous avons un vecteur de tranches de cha√Æne et une variable de type tranche de cha√Æne.  Mais dans ce cas, la sp√©cification des types est compl√®tement redondante, car le compilateur peut les produire par lui-m√™me (en utilisant la version √©tendue de l'algorithme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Hindley-Milner</a> ).  Le fait que <code>vec</code> est un vecteur est d√©j√† clair par le type de la valeur de retour de <code>Vec::new()</code> , mais il n'est pas encore clair quel type de ses √©l√©ments seront.  Le fait que le type de <code>text</code> soit une tranche de cha√Æne est compr√©hensible par le fait qu'on lui affecte un litt√©ral de ce type.  Ainsi, apr√®s <code>vec.push(text)</code> , le type d'√©l√©ments vectoriels devient √©vident.  Notez que le type de la variable <code>vec</code> √©t√© compl√®tement d√©termin√© par son utilisation dans le thread d'ex√©cution, et non au stade de l'initialisation. </p><br><p>  Un tel syst√®me d'inf√©rence de type √©limine le bruit du code et le rend aussi concis que le code dans un langage de programmation typ√© dynamiquement.  Et cela tout en conservant une frappe statique stricte! </p><br><p>  Bien s√ªr, nous ne pouvons pas nous d√©barrasser compl√®tement de la saisie dans une langue typ√©e statiquement.  Le programme doit avoir des points auxquels les types d'objets sont garantis pour √™tre connus, afin qu'√† d'autres endroits ces types puissent √™tre affich√©s.  De tels points dans Rust sont des d√©clarations de types de donn√©es d√©finis par l'utilisateur et de signatures de fonctions, dans lesquelles on ne peut que sp√©cifier les types utilis√©s.  Mais vous pouvez y entrer des "m√©ta-variables de types", en utilisant une programmation g√©n√©ralis√©e. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Correspondance de mod√®le aux points de d√©claration variables </h2><br><p>  <code>let</code> op√©ration </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  pas vraiment limit√© √† simplement d√©clarer de nouvelles variables.  Ce qu'elle fait, c'est faire correspondre l'expression √† droite du signe √©gal avec le motif √† gauche.  Et de nouvelles variables peuvent √™tre introduites dans le cadre de l'√©chantillon (et seulement ainsi).  Jetez un ≈ìil √† l'exemple suivant, et il deviendra plus clair pour vous: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  La d√©structuration a √©t√© effectu√©e ici: une telle comparaison introduira les variables <code>x</code> et <code>y</code> , qui seront initialis√©es avec la valeur des champs <code>x</code> et <code>y</code> de l'objet de la structure <code>Point</code> , qui est retourn√©e en appelant <code>Point::new()</code> .  Dans le m√™me temps, la comparaison est correcte, car le type de l'expression √† droite correspond au mod√®le de <code>Point</code> de type <code>Point</code> √† gauche.  De la m√™me mani√®re, vous pouvez prendre, par exemple, les deux premiers √©l√©ments d'un tableau: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Et bien plus encore.  La chose la plus remarquable est que de telles comparaisons sont effectu√©es dans tous les endroits o√π de nouveaux noms de variables peuvent √™tre saisis dans Rust, √† savoir: dans la <code>match</code> , les <code>if let</code> <code>let</code> , <code>if let</code> , <code>while let</code> , dans l'en-t√™te de la boucle <code>for</code> , dans les arguments des fonctions et des fermetures.  Voici un exemple d'utilisation √©l√©gante de la correspondance de motifs dans une boucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  La m√©thode <code>enumerate</code> , appel√©e sur l'it√©rateur, construit un nouvel it√©rateur, qui it√©rera non pas sur les valeurs initiales, mais sur les tuples, les paires "index ordinal, valeur initiale".  Chacun de ces tuples pendant l'it√©ration du cycle sera mapp√© sur le mod√®le sp√©cifi√© <code>(i, ch)</code> , √† la suite de quoi la variable <code>i</code> recevra la premi√®re valeur du tuple - l'index et la variable <code>ch</code> - la seconde, c'est-√†-dire le caract√®re de la cha√Æne.  Plus loin dans le corps de la boucle, nous pouvons utiliser ces variables. </p><br><p>  Un autre exemple populaire d'utilisation d'un motif dans une boucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Ici, nous ignorons simplement la valeur de l'it√©rateur en utilisant le mod√®le <code>_</code> .  Parce que nous n'utilisons pas le num√©ro d'it√©ration dans le corps de la boucle.  La m√™me chose peut √™tre faite, par exemple, avec un argument de fonction: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Ou lors d'une correspondance dans une d√©claration de <code>match</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  La correspondance de motifs rend le code tr√®s compact et expressif, et dans l'√©nonc√© de <code>match</code> , il est g√©n√©ralement irrempla√ßable.  L'op√©rateur de <code>match</code> est un op√©rateur d'analyse vari√©e compl√®te, vous ne pourrez donc pas accidentellement oublier de v√©rifier certaines des correspondances possibles pour l'expression analys√©e. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Extension de syntaxe et DSL personnalis√© </h2><br><p>  La syntaxe de Rust est limit√©e, en grande partie √† cause de la complexit√© du syst√®me de type utilis√© dans le langage.  Par exemple, Rust n'a pas d'arguments de fonction nomm√©s ou de fonctions avec un nombre variable d'arguments.  Mais vous pouvez contourner ces limitations et d'autres avec des macros.  Rust a deux types de macros: d√©clarative et proc√©durale.  Avec les macros d√©claratives, vous n'aurez jamais les m√™mes probl√®mes qu'avec les macros en C, car elles sont hygi√©niques et ne fonctionnent pas au niveau du remplacement de texte, mais au niveau du remplacement dans l'arborescence de syntaxe abstraite.  Les macros vous permettent de cr√©er des abstractions au niveau de la syntaxe du langage.  Par exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Outre le fait que cette macro √©tend les capacit√©s syntaxiques d'appeler la "fonction" d'impression d'une cha√Æne format√©e, elle v√©rifiera √©galement dans son impl√©mentation que les arguments d'entr√©e correspondent √† la cha√Æne de format sp√©cifi√©e au moment de la compilation et non au moment de l'ex√©cution.  √Ä l'aide de macros, vous pouvez entrer une syntaxe concise pour vos propres besoins de conception, cr√©er et utiliser DSL.  Voici un exemple d'utilisation de code JavaScript dans un programme Rust compil√© dans Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Macro <code>js!</code>  d√©fini dans le package <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>stdweb</code></a> et il vous permet d'incorporer du code JavaScript √† part enti√®re dans votre programme (√† l'exception des cha√Ænes entre guillemets simples et des op√©rateurs non compl√©t√©s par un point-virgule) et d'utiliser des objets du code Rust en utilisant la syntaxe <code>@{expr}</code> . </p><br><p>  Les macros offrent d'√©normes possibilit√©s pour adapter la syntaxe des programmes Rust aux t√¢ches sp√©cifiques d'un domaine particulier.  Ils vous feront gagner du temps et de l'attention lors du d√©veloppement d'applications complexes.  Non pas en augmentant la surcharge d'ex√©cution, mais en augmentant le temps de compilation.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. G√©n√©ration automatique de code d√©pendant </h2><br><p>  Les macros de d√©rivation proc√©durale de Rust sont largement utilis√©es pour impl√©menter automatiquement des traits et d'autres g√©n√©ration de code.  Voici un exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  √âtant donn√© que tous ces types ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> et <code>Eq</code> ) de la biblioth√®que standard sont impl√©ment√©s pour le type de champs de la structure <code>i32</code> , leur impl√©mentation peut √™tre affich√©e automatiquement pour l'ensemble de la structure dans son ensemble.  Un autre exemple: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Ici, en utilisant les <code>Deserialize</code> et <code>Deserialize</code> de la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>serde</code></a> pour la structure <code>Point</code> , les m√©thodes pour sa s√©rialisation et sa d√©s√©rialisation sont g√©n√©r√©es automatiquement.  Vous pouvez ensuite transmettre une instance de cette structure √† diverses fonctions de s√©rialisation, par exemple, la convertir en cha√Æne JSON. </p><br><p>  Vous pouvez cr√©er vos propres macros proc√©durales qui g√©n√©reront le code dont vous avez besoin.  Ou utilisez les nombreuses macros d√©j√† cr√©√©es par d'autres d√©veloppeurs.  En plus d'√©conomiser le programmeur de l'√©criture de code passe-partout, les macros ont √©galement l'avantage que vous n'avez pas besoin de maintenir diff√©rentes sections de code dans un √©tat coh√©rent.  Par exemple, si un troisi√®me champ <code>z</code> est ajout√© √† la structure <code>Point</code> , pour effectuer correctement sa s√©rialisation, si vous utilisez d√©river, vous n'avez rien d'autre √† faire.  Si nous mettons nous-m√™mes en ≈ìuvre les traits n√©cessaires √† la s√©rialisation de <code>Point</code> , alors nous devrons nous assurer que cette mise en ≈ìuvre est toujours coh√©rente avec les derniers changements dans la structure de <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Type de donn√©es alg√©brique </h2><br><p>  Pour le dire simplement, un type de donn√©es alg√©brique est un type de donn√©es composite qui est une union de structures.  Plus formellement, il s'agit d'une somme de types de produits.  Dans Rust, ce type est d√©fini √† l'aide du mot cl√© <code>enum</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  Le type d'une valeur particuli√®re d'une variable de type <code>Message</code> ne peut √™tre que l'un des types de structure r√©pertori√©s dans <code>Message</code> .  Il s'agit soit d'une structure <code>Quit</code> sans champ de type unit√©, de l'une des structures de tuple <code>ChangeColor</code> ou <code>Write</code> avec des champs sans nom, ou de la structure <code>Move</code> habituelle.  Un type √©num√©r√© traditionnel peut √™tre repr√©sent√© comme un cas particulier d'un type de donn√©es alg√©brique: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  Il est possible de savoir quel type a r√©ellement pris de la valeur dans un cas particulier en utilisant la correspondance de mod√®les: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Sous la forme de types de donn√©es alg√©briques, Rust impl√©mente des types importants tels que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Option</code></a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>Result</code></a> , qui sont utilis√©s pour repr√©senter la valeur manquante et le r√©sultat correct / erron√©, respectivement.  Voici comment l' <code>Option</code> est d√©finie dans la biblioth√®que standard: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust n'a pas de valeur nulle, tout comme les erreurs g√™nantes d'un appel inattendu.  Au lieu de cela, lorsqu'il est vraiment n√©cessaire d'indiquer la possibilit√© d'une valeur manquante, <code>Option</code> utilis√©e: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>Ex√©cuter</em></a> </p><br><p>  Le type de donn√©es alg√©brique est un outil puissant et expressif qui ouvre la porte au d√©veloppement pilot√© par type.  Un programme √©crit avec comp√©tence dans ce paradigme attribue la plupart des v√©rifications de l'exactitude de son travail au syst√®me de type.  Par cons√©quent, si vous manquez un peu de Haskell dans la programmation industrielle quotidienne, Rust peut √™tre votre point de vente.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. Refactoring facile </h2><br><p>  Le syst√®me de type statique strict d√©velopp√© dans Rust et la tentative d'effectuer autant de v√©rifications que possible pendant la compilation, conduit au fait que la modification et la refactorisation du code deviennent assez simples et s√ªres.  Si, apr√®s les modifications, le programme a √©t√© compil√©, cela signifie qu'il n'a laiss√© que des erreurs logiques qui n'√©taient pas li√©es √† la fonctionnalit√© dont la v√©rification a √©t√© affect√©e au compilateur.  Combin√© √† la facilit√© d'ajouter des tests unitaires √† la logique de test, cela conduit √† de s√©rieuses garanties de fiabilit√© des programmes et √† une augmentation de la confiance du programmeur dans le bon fonctionnement de son code apr√®s avoir effectu√© des modifications. </p><br><hr><br><p>  C'est peut-√™tre tout ce dont je voulais parler dans cet article.  Bien s√ªr, Rust pr√©sente de nombreux autres avantages, ainsi qu'un certain nombre d'inconv√©nients (une certaine humidit√© du langage, un manque d'idiomes de programmation familiers et une syntaxe ¬´non litt√©raire¬ª), qui ne sont pas mentionn√©s ici.  Si vous avez quelque chose √† dire √† leur sujet, √©crivez dans les commentaires.  En g√©n√©ral, essayez Rust dans la pratique.  Et peut-√™tre que ses avantages pour vous l'emporteront sur toutes ses lacunes, comme cela s'est produit dans mon cas.  Et enfin, vous obtiendrez exactement l'ensemble d'outils dont vous aviez besoin pendant longtemps. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr430294/">https://habr.com/ru/post/fr430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr430282/index.html">9 personnes sur 10 acceptent de gagner moins pour un travail plus significatif</a></li>
<li><a href="../fr430284/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 275 (12 - 18 novembre)</a></li>
<li><a href="../fr430286/index.html">D√©tails du c√¥t√© d√©sordonn√© et sombre des jeux de pirates pour Nintendo Switch</a></li>
<li><a href="../fr430290/index.html">Une tentative de pr√©dire la quatri√®me it√©ration du projet SpaceX BFR</a></li>
<li><a href="../fr430292/index.html">Electronic Frontier Foundation: la performance du r√©seau de plaques d'immatriculation de la police am√©ricaine est de 0,5%</a></li>
<li><a href="../fr430296/index.html">Donnez vie √† vos id√©es. Application sans serveur - instructions √©tape par √©tape</a></li>
<li><a href="../fr430300/index.html">Microservices on Go avec le kit Go: Introduction</a></li>
<li><a href="../fr430302/index.html">Une introduction √† ptrace ou √† l'injection de code dans sshd pour le plaisir</a></li>
<li><a href="../fr430304/index.html">Un merveilleux avant-poste en orbite</a></li>
<li><a href="../fr430306/index.html">Le premier tunnel de la soci√©t√© Boring for√© par Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>