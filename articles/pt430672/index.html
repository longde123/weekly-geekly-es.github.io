<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë∞üèæ ü•° ü§• Vers√£o em texto do relat√≥rio "Atores vs CSP x Tarefas ..." com C ++ CoreHard Outono de 2018 üë®üèø‚Äçüé§ üë®üèΩ üåâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No in√≠cio de novembro, Minsk organizou a pr√≥xima confer√™ncia C ++ CoreHard Outono de 2018. Ele entregou um relat√≥rio do capit√£o "Atores vs CSP x Taref...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Vers√£o em texto do relat√≥rio "Atores vs CSP x Tarefas ..." com C ++ CoreHard Outono de 2018</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430672/">  No in√≠cio de novembro, Minsk organizou a pr√≥xima confer√™ncia C ++ CoreHard Outono de 2018. Ele entregou um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rio do capit√£o "Atores vs CSP x Tarefas ..."</a> , que falou sobre como aplicativos de n√≠vel superior do que "podem parecer em C ++" multithreading bare ‚Äù, modelos de programa√ß√£o competitivos.  Sob a vers√£o recortada deste relat√≥rio, transformada em artigo.  Penteado, aparado em alguns lugares, suplementado em alguns lugares. <br><br>  Gostaria de aproveitar esta oportunidade para agradecer √† comunidade <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CoreHard</a> por organizar a pr√≥xima grande confer√™ncia em Minsk e pela oportunidade de falar.  E tamb√©m para a pronta publica√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relat√≥rios em v√≠deo de relat√≥rios no YouTube</a> . <br><br>  Ent√£o, vamos ao t√≥pico principal da conversa.  Ou seja, quais abordagens podemos usar para simplificar a programa√ß√£o multithread em C ++, como algumas dessas abordagens aparecer√£o no c√≥digo, quais recursos s√£o inerentes a abordagens espec√≠ficas, o que √© comum entre elas etc. <br><br>  Nota: foram encontrados erros e erros de digita√ß√£o na apresenta√ß√£o original do relat√≥rio, portanto, o artigo usar√° slides da vers√£o atualizada e editada, que podem ser encontrados no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Google Slides</a> ou no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SlideShare</a> . <br><br><h1>  Multithreading nu √© mau! </h1><br>  Voc√™ precisa come√ßar com a repetida banalidade, que, no entanto, ainda permanece relevante: <br><blockquote>  A programa√ß√£o C ++ multithread atrav√©s de threads simples, mutex e vari√°veis ‚Äã‚Äãde condi√ß√£o √© <b>suor</b> , <b>dor</b> e <b>sangue</b> . </blockquote><a name="habracut"></a><br>  Um bom exemplo foi recentemente descrito aqui neste artigo aqui no Habr√©: " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Arquitetura do meta-servidor do Tacticool, jogo para dispositivos m√≥veis online</a> ".  Nele, os caras falaram sobre como eles conseguiram coletar, aparentemente, uma gama completa de rakes relacionados ao desenvolvimento de c√≥digo multiencadeado em C e C ++.  Houve ‚Äúpasses de mem√≥ria‚Äù como resultado das corridas e baixo desempenho devido √† paraleliza√ß√£o malsucedida. <br><br>  Como resultado, tudo terminou naturalmente: <br><blockquote>  Depois de algumas semanas procurando e corrigindo os bugs mais cr√≠ticos, decidimos que era <u>mais f√°cil reescrever tudo do zero</u> do que tentar corrigir todas as defici√™ncias da solu√ß√£o atual. </blockquote><br>  As pessoas comiam C / C ++ enquanto trabalhavam na primeira vers√£o do servidor e reescreviam o servidor em outro idioma. <br><br>  Uma excelente demonstra√ß√£o de como, no mundo real, fora da nossa aconchegante comunidade C ++, os desenvolvedores se recusam a usar C ++ mesmo quando o uso de C ++ ainda √© apropriado e justificado. <br><br><h2>  Mas porque? </h2><br>  Mas por que, se √© dito repetidamente que ‚Äúmultithreading simples‚Äù em C ++ √© mau, as pessoas continuam a us√°-lo com perseveran√ßa digna de uma aplica√ß√£o melhor?  O que tem a culpa: <br><br><ul><li>  ignor√¢ncia? </li><li>  pregui√ßa? </li><li>  S√≠ndrome do NIH? </li></ul><br>  Afinal, h√° longe de uma abordagem testada pelo tempo e muitos projetos.  Em particular: <br><br><ul><li>  atores </li><li>  processos sequenciais de comunica√ß√£o (CSP) </li><li>  tarefas (ass√≠ncronas, promessas, futuros, ...) </li><li>  fluxos de dados </li><li>  programa√ß√£o reativa </li><li>  ... </li></ul><br>  Espera-se que o principal motivo ainda seja a ignor√¢ncia.  √â improv√°vel que isso seja ensinado nas universidades.  Ent√£o, os jovens profissionais, entrando na profiss√£o, usam o pouco que eles j√° sabem.  E se o reposit√≥rio de conhecimento n√£o for reabastecido, as pessoas continuar√£o usando threads simples, mutexes e vari√°veis ‚Äã‚Äãde condi√ß√£o. <br><br>  Hoje falaremos sobre as tr√™s primeiras abordagens desta lista.  E n√£o falaremos abstratamente, mas no exemplo de uma tarefa simples.  Vamos tentar mostrar como ser√° o c√≥digo que resolve esse problema usando o Actor, processos e canais de CSP, al√©m de usar a Tarefa. <br><br><h1>  Desafio para experimentos </h1><br>  √â necess√°rio implementar um servidor HTTP que: <br><br><ul><li>  aceita a solicita√ß√£o (ID da imagem, ID do usu√°rio); </li><li>  d√° uma imagem com "marcas d'√°gua" exclusivas para esse usu√°rio. </li></ul><br>  Por exemplo, esse servidor pode ser exigido por algum servi√ßo pago que distribui conte√∫do por assinatura.  Se a imagem deste servi√ßo "aparecer" em algum lugar, pelas "marcas d'√°gua" nele ser√° poss√≠vel entender quem precisa "bloquear o oxig√™nio". <br><br>  A tarefa √© abstrata, foi formulada especificamente para este relat√≥rio sob a influ√™ncia do nosso projeto de demonstra√ß√£o Camar√£o (j√° falamos sobre isso: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n¬∫ 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n¬∫ 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n¬∫ 3</a> ). <br><br>  Este nosso servidor HTTP funcionar√° da seguinte maneira: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/bq/qo/zk/bqqozkulonydk1ccnzog-kzv610.jpeg"></td></tr></tbody></table><br>  Ap√≥s receber uma solicita√ß√£o de um cliente, passamos a dois servi√ßos externos: <br><br><ul><li>  o primeiro nos retorna informa√ß√µes do usu√°rio.  Inclusive a partir da√≠, obtemos uma imagem com "marcas d'√°gua"; </li><li>  o segundo nos retorna a imagem original </li></ul><br>  Ambos os servi√ßos funcionam de forma independente e podemos acess√°-los simultaneamente. <br><br>  Como o processamento de solicita√ß√µes pode ser feito independentemente um do outro, e mesmo algumas a√ß√µes ao processar uma √∫nica solicita√ß√£o podem ser realizadas em paralelo, o uso da competitividade se sugere.  A coisa mais simples que vem √† mente √© criar um encadeamento separado para cada solicita√ß√£o recebida: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/g0/f9/ps/g0f9ps3vmq-osh-hy0i71ut_kfw.jpeg"></td></tr></tbody></table><br>  Mas o modelo de solicita√ß√£o √∫nica = fluxo de trabalho √© muito caro e n√£o tem uma escala adequada.  N√≥s n√£o precisamos disso. <br><br>  Mesmo se abordarmos o n√∫mero de fluxos de trabalho com desperd√≠cio, ainda precisaremos de um pequeno n√∫mero deles: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/ve/yl/vv/veylvvoaisqxod1-0nsp4vhh80e.jpeg"></td></tr></tbody></table><br>  Aqui, precisamos de um fluxo separado para receber solicita√ß√µes HTTP recebidas, um fluxo separado para nossas pr√≥prias solicita√ß√µes HTTP de sa√≠da, um fluxo separado para coordenar o processamento de solicita√ß√µes HTTP recebidas.  Al√©m de um conjunto de fluxos de trabalho para executar opera√ß√µes nas imagens (como as manipula√ß√µes nas imagens s√£o bem paralelas, o processamento de uma imagem por v√°rios fluxos ao mesmo tempo reduz o tempo de processamento). <br><br>  Portanto, nosso objetivo √© lidar com um grande n√∫mero de solicita√ß√µes de entrada simult√¢neas em um pequeno n√∫mero de threads de trabalho.  Vamos ver como conseguimos isso atrav√©s de v√°rias abordagens. <br><br><h2>  Algumas isen√ß√µes de responsabilidade importantes </h2><br>  Antes de passar para a hist√≥ria principal e analisar exemplos de c√≥digo, √© necess√°rio fazer algumas anota√ß√µes. <br><br>  Primeiro, todos os exemplos a seguir n√£o est√£o vinculados a nenhuma estrutura ou biblioteca espec√≠fica.  Quaisquer correspond√™ncias nos nomes das chamadas da API s√£o aleat√≥rias e n√£o intencionais. <br><br>  Em segundo lugar, n√£o h√° tratamento de erros nos exemplos abaixo.  Isso √© feito deliberadamente, para que os slides sejam compactos e vis√≠veis.  E tamb√©m para que o material caiba no tempo alocado para o relat√≥rio. <br><br>  Em terceiro lugar, os exemplos usam uma certa entidade entity_context, que cont√©m informa√ß√µes sobre o que mais existe dentro do programa.  O preenchimento dessa entidade depende da abordagem.  No caso de atores, Execution_context ter√° links para outros atores.  No caso de CSP, em Execution_context, haver√° canais de CSP para comunica√ß√£o com outros processos de CSP.  Etc. <br><br><h1>  Abordagem # 1: Atores </h1><br><h2>  Modelo de atores em poucas palavras </h2><br>  Ao usar o modelo de atores, a solu√ß√£o ser√° constru√≠da com objetos-atores separados, cada um com seu pr√≥prio estado privado e esse estado √© inacess√≠vel a qualquer pessoa, exceto o pr√≥prio ator. <br><br>  Os atores interagem entre si atrav√©s de mensagens ass√≠ncronas.  Cada ator possui sua pr√≥pria caixa de correio exclusiva (fila de mensagens), na qual as mensagens enviadas ao ator s√£o salvas e de onde s√£o recuperadas para processamento adicional. <br><br>  Os atores trabalham com princ√≠pios muito simples: <br><br><ul><li>  um ator √© uma entidade com comportamento; </li><li>  atores respondem a mensagens recebidas; </li><li>  Ap√≥s receber a mensagem, o ator pode: <br><ul><li>  envie um n√∫mero (final) de mensagens para outros atores; </li><li>  criar um n√∫mero (final) de novos atores; </li><li>  Defina um novo comportamento para o processamento de mensagens subseq√ºentes. </li></ul></li></ul><br>  Dentro de um aplicativo, os atores podem ser implementados de diferentes maneiras: <br><br><ul><li>  cada ator pode ser representado como um fluxo de SO separado (isso acontece, por exemplo, na biblioteca C :: Just :: Thread Pro Actor Edition); </li><li>  cada ator pode ser representado como uma rotineira empilh√°vel; </li><li>  cada ator pode ser representado como um objeto no qual algu√©m chama m√©todos de retorno de chamada. </li></ul><br>  Em nossa decis√£o, usaremos atores na forma de objetos com retornos de chamada e deixaremos rotinas para a abordagem CSP. <br><br><h2>  Esquema de decis√£o baseado no modelo de atores </h2><br>  Com base nos atores, o esquema geral para resolver nosso problema ter√° a seguinte apar√™ncia: <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/di/f7/pn/dif7pngijjde8aizja_skqy58oo.jpeg"></td></tr></tbody></table><br>  Teremos atores criados no in√≠cio do servidor HTTP e que existem o tempo todo enquanto o servidor HTTP est√° funcionando.  S√£o atores como: HttpSrv, UserChecker, ImageDownloader, ImageMixer. <br><br>  Ap√≥s o recebimento de uma nova solicita√ß√£o HTTP de entrada, criamos uma nova inst√¢ncia do ator RequestHandler, que ser√° destru√≠da ap√≥s emitir uma resposta √† solicita√ß√£o HTTP de entrada. <br><br><h2>  C√≥digo do ator RequestHandler </h2><br>  A implementa√ß√£o do ator request_handler, que coordena o processamento de uma solicita√ß√£o HTTP recebida, pode ser assim: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">request_handler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> some_basic_type { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> execution_context context_; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> request request_; optional&lt;user_info&gt; user_info_; optional&lt;image_loaded&gt; image_; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_user_info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(user_info info)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_image_loaded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image_loaded image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_mixed_image</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mixed_image image)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">send_mix_images_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//     . }; void request_handler::on_start() { send(context_.user_checker(), check_user{request_.user_id(), self()}); send(context_.image_downloader(), download_image{request_.image_id(), self()}); } void request_handler::on_user_info(user_info info) { user_info_ = std::move(info); if(image_) send_mix_images_request(); } void request_handler::on_image_loaded(image_loaded image) { image_ = std::move(image); if(user_info_) send_mix_images_request(); } void request_handler::send_mix_images_request() { send(context_.image_mixer(), mix_images{user_info-&gt;watermark_image(), *image_, self()}); } void request_handler::on_mixed_image(mixed_image image) { send(context_.http_srv(), reply{..., std::move(image), ...}); }</span></span></code> </pre> <br>  Vamos analisar esse c√≥digo. <br><br>  Temos uma classe nos atributos dos quais armazenamos ou vamos armazenar o que precisamos para processar a solicita√ß√£o.  Tamb√©m nesta classe, h√° um conjunto de retornos de chamada que ser√£o chamados uma vez ou outra. <br><br>  Primeiro, quando um ator acaba de ser criado, o retorno de chamada on_start () √© chamado.  Nele, enviamos duas mensagens para outros atores.  Primeiro, esta √© uma mensagem check_user para verificar o ID do cliente.  Em segundo lugar, esta √© uma mensagem de download_image para baixar a imagem original. <br><br>  Em cada uma das mensagens enviadas, passamos um link para n√≥s mesmos (uma chamada para o m√©todo self () retorna um link para o ator para o qual self () foi chamado).  Isso √© necess√°rio para que nosso ator possa enviar uma mensagem em resposta.  Se n√£o enviarmos um link para o nosso ator, por exemplo, na mensagem check_user, o ator do UserChecker n√£o saber√° para quem enviar as informa√ß√µes do usu√°rio. <br><br>  Quando uma mensagem user_info com informa√ß√µes do usu√°rio √© enviada para n√≥s em resposta, o retorno de chamada on_user_info () √© chamado.  E quando a mensagem image_loaded √© enviada para n√≥s, o retorno de chamada on_image_loaded () √© chamado ao nosso ator.  E agora, dentro desses dois retornos de chamada, vemos um recurso inerente ao Modelo de Atores: n√£o sabemos exatamente em que ordem receberemos as mensagens de resposta.  Portanto, devemos escrever nosso c√≥digo para que n√£o dependa da ordem em que as mensagens chegam.  Portanto, em cada um dos processadores, primeiro armazenamos as informa√ß√µes recebidas no atributo correspondente e depois verificamos se j√° coletamos todas as informa√ß√µes necess√°rias.  Se assim for, ent√£o podemos seguir em frente.  Caso contr√°rio, esperaremos mais. <br><br>  √â por isso que temos ifs on_user_info () e on_image_loaded () executados quando o send_mix_images_request () √© chamado. <br><br><blockquote>  Em princ√≠pio, nas implementa√ß√µes do Modelo de Atores, pode haver mecanismos como o recebimento seletivo de Erlang ou a oculta√ß√£o de Akka, atrav√©s dos quais voc√™ pode manipular a ordem de processamento das mensagens recebidas, mas n√£o falaremos sobre isso hoje, para n√£o investigar detalhes de v√°rias implementa√ß√µes do Modelo. Atores. </blockquote><br>  Portanto, se todas as informa√ß√µes que precisamos do UserChecker e ImageDownloader forem recebidas, o m√©todo send_mix_images_request () ser√° chamado, no qual a mensagem mix_images ser√° enviada ao ator do ImageMixer.  O retorno de chamada on_mixed_image () √© chamado quando recebemos uma mensagem de resposta com a imagem resultante.  Aqui, enviamos esta imagem ao ator HttpSrv e aguardamos at√© que o HttpSrv forme uma resposta HTTP e destrua o RequestHandler que se tornou desnecess√°rio (embora, em princ√≠pio, nada impe√ßa o ator RequestHandler de se autodestruir no retorno de chamada on_mixed_image ()). <br><br>  S√≥ isso. <br><br>  A implementa√ß√£o do ator RequestHandler acabou sendo bastante volumosa.  Mas isso se deve ao fato de precisarmos descrever uma classe com atributos e retornos de chamada e tamb√©m implementar retornos de chamada.  Mas a l√≥gica do trabalho do RequestHandler √© muito trivial e √© f√°cil entend√™-lo, apesar da quantidade de c√≥digo na classe request_handler. <br><br><h2>  Recursos inerentes aos atores </h2><br>  Agora podemos dizer algumas palavras sobre os recursos do Modelo de Atores. <br><br><h3>  Reatores </h3><br>  Como regra, os atores respondem apenas √†s mensagens recebidas.  H√° mensagens - o ator as processa.  Sem mensagens - o ator n√£o faz nada. <br><br>  Isso √© especialmente verdade para as implementa√ß√µes do Modelo de atores nos quais os atores s√£o representados como objetos com retornos de chamada.  A estrutura puxa o retorno de chamada do ator e, se o ator n√£o retornar o controle do retorno de chamada, a estrutura n√£o poder√° atender outros atores no mesmo contexto. <br><br><h3>  Os atores est√£o sobrecarregados </h3><br>  Sobre os atores, podemos facilmente fazer ator-produtor gerar mensagens para consumidor-ator em um ritmo muito mais r√°pido do que o ator-consumidor ser√° capaz de processar. <br><br>  Isso levar√° ao fato de que a fila de mensagens recebidas para o ator-consumidor crescer√° constantemente.  Crescimento da fila, ou seja,  o aumento do consumo de mem√≥ria no aplicativo reduzir√° a velocidade do aplicativo.  Isso levar√° a um crescimento ainda mais r√°pido da fila e, como resultado, o aplicativo poder√° se degradar para concluir a inoperabilidade. <br><br>  Tudo isso √© uma conseq√º√™ncia direta da intera√ß√£o ass√≠ncrona dos atores.  Como a opera√ß√£o de envio geralmente √© sem bloqueio.  E faz√™-lo bloquear n√£o √© f√°cil, porque  um ator pode enviar para si mesmo.  E se a fila do ator estiver cheia, no envio para si mesmo, o ator ser√° bloqueado e isso interromper√° o trabalho. <br><br>  Portanto, ao trabalhar com atores, deve-se prestar muita aten√ß√£o ao problema da sobrecarga. <br><br><h3>  Muitos atores nem sempre s√£o a solu√ß√£o. </h3><br>  Como regra, os atores s√£o entidades leves e existe uma tenta√ß√£o de cri√°-los em sua aplica√ß√£o em grandes n√∫meros.  Voc√™ pode criar dez mil atores, cem mil e um milh√£o.  E at√© cem milh√µes de atores, se o ferro permitir. <br><br>  Mas o problema √© que √© dif√≠cil rastrear o comportamento de um n√∫mero muito grande de atores.  I.e.  voc√™ pode ter alguns atores que claramente funcionam corretamente.  Alguns atores que obviamente trabalham incorretamente ou n√£o trabalham, e voc√™ tem certeza.  Mas pode haver um grande n√∫mero de atores sobre os quais voc√™ n√£o sabe nada: eles funcionam de alguma forma, funcionam corretamente ou incorretamente.  E tudo porque quando voc√™ tem cem milh√µes de entidades aut√¥nomas com sua pr√≥pria l√≥gica de comportamento em seu programa, monitorar isso √© muito dif√≠cil para todos. <br><br>  Portanto, pode ser que, ao criar um grande n√∫mero de atores no aplicativo, n√£o resolvamos nosso problema aplicado, mas tenhamos outro problema.  E, portanto, pode ser ben√©fico para n√≥s abandonarmos atores simples que resolvem uma √∫nica tarefa, em favor de atores mais complexos e pesados ‚Äã‚Äãque realizam v√°rias tarefas.  Mas haver√° menos atores "pesados" no aplicativo e ser√° mais f√°cil segui-los. <br><br><h2>  Onde procurar, o que levar? </h2><br>  Se algu√©m quiser tentar trabalhar com atores em C ++, n√£o h√° sentido em criar suas pr√≥prias bicicletas, existem v√°rias solu√ß√µes prontas, em particular: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> (suporte ao fabricante nacional!) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Estrutura do ator C ++ (CAF)</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">QP / C ++</a> </li></ul><br>  Essas tr√™s op√ß√µes s√£o animadas, em evolu√ß√£o, multiplataforma, documentadas.  Voc√™ tamb√©m pode experiment√°-los gratuitamente.  Al√©m disso, v√°rias outras op√ß√µes de graus variados de [n√£o] frescor podem ser encontradas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">na lista da Wikipedia</a> . <br><br>  O SObjectizer e o CAF foram projetados para uso em tarefas de alto n√≠vel, nas quais exce√ß√µes e mem√≥ria din√¢mica podem ser aplicadas.  E a estrutura QP / C ++ pode ser de interesse para os envolvidos no desenvolvimento incorporado, como  √© nesse nicho que ele √© "preso". <br><br><h1>  Abordagem # 2: CSP (comunicando processos sequenciais) </h1><br><h2>  CSP nos dedos e sem matan </h2><br>  O modelo CSP √© muito semelhante ao modelo de atores.  Tamb√©m constru√≠mos nossa solu√ß√£o a partir de um conjunto de entidades aut√¥nomas, cada uma com seu pr√≥prio estado privado e interage com outras entidades apenas atrav√©s de mensagens ass√≠ncronas. <br><br>  Somente essas entidades no modelo CSP s√£o chamadas de "processos". <br><br>  Os processos no CSP s√£o leves, sem paralelismo de seu trabalho interno.  Se precisarmos paralelizar algo, simplesmente iniciaremos v√°rios processos de CSP, dentro dos quais n√£o h√° mais paraleliza√ß√£o. <br><br>  Os processos CSP interagem entre si por meio de mensagens ass√≠ncronas, mas as mensagens s√£o enviadas n√£o para caixas de correio, como no Modelo de atores, mas para canais.  Os canais podem ser vistos como filas de mensagens, geralmente de tamanho fixo. <br><br>  Diferentemente do Modelo de atores, em que uma caixa de correio √© criada automaticamente para cada ator, os canais no CSP devem ser criados explicitamente.  E se precisamos que os dois processos interajam, devemos criar o canal por n√≥s mesmos e, em seguida, informar o primeiro processo "voc√™ escrever√° aqui" e o segundo processo dever√° dizer: "voc√™ ler√° aqui daqui". <br><br>  Ao mesmo tempo, os canais t√™m pelo menos duas opera√ß√µes que devem ser chamadas explicitamente.  A primeira √© a opera√ß√£o de grava√ß√£o (envio) para gravar uma mensagem no canal. <br><br>  Em segundo lugar, √© uma opera√ß√£o de leitura (recebimento) para ler uma mensagem de um canal.  E a necessidade de chamar explicitamente leitura / recebimento distingue CSP do Modelo de Atores, porque  no caso de atores, a opera√ß√£o de leitura / recebimento geralmente pode estar oculta do ator.  I.e.  A estrutura do ator pode recuperar mensagens da fila de atores e chamar um manipulador (retorno de chamada) para a mensagem recuperada. <br><br>  Enquanto o pr√≥prio processo CSP deve escolher o momento para a chamada de leitura / recebimento, o processo CSP deve determinar qual mensagem recebeu e processar a mensagem extra√≠da. <br><br>  Dentro de nosso aplicativo "grande", os processos de CSP podem ser implementados de diferentes maneiras: <br><br><ul><li>  O processo CSP-shny pode ser implementado como um SO de thread separado.  √â uma solu√ß√£o cara, mas com multitarefa preventiva; </li><li>  O processo de CSP pode ser implementado por corotina (corotina empilhada, fibra, fio verde, ...).  √â muito mais barato, mas a multitarefa √© apenas cooperativa. </li></ul><br>  Al√©m disso, assumimos que os processos CSP s√£o apresentados na forma de corotinas empilh√°veis ‚Äã‚Äã(embora o c√≥digo mostrado abaixo possa muito bem ser implementado em threads do SO). <br><br><h2>  Diagrama da solu√ß√£o baseada em CSP </h2><br>  O esquema de solu√ß√£o baseado no modelo CSP ser√° muito parecido com um esquema semelhante para o Modelo de Atores (e isso n√£o √© por acaso): <br><table border="1"><tbody><tr><td><img src="https://habrastorage.org/webt/96/oy/uu/96oyuu6mwhj4ot6fqpsiiv-f1h8.jpeg"></td></tr></tbody></table><br>  Tamb√©m haver√° entidades que ser√£o iniciadas quando o servidor HTTP iniciar e funcionar o tempo todo - esses s√£o os processos CSP HttpSrv, UserChecker, ImageDownloader e ImageMixer.  Para cada nova solicita√ß√£o de entrada, um novo processo de RequestHandler CSP ser√° criado.  Esse processo envia e recebe as mesmas mensagens que ao usar o modelo de atores. <br><br><h2>  C√≥digo do Processo RequestHandler CSP </h2><br>  Pode parecer o c√≥digo de uma fun√ß√£o que implementa o processo t√≠mido de CSP do RequestHandler: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ch = make_chain&lt;user_info&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_loaded_ch = make_chain&lt;image_loaded&gt;(); ctx.user_checker_ch().write(check_user{req.user_id(), user_info_ch}); ctx.image_downloader_ch().write(download_image{req.image_id(), image_loaded_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); ctx.image_mixer_ch().write( mix_image{user.watermark_image(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(original_image), image_mix_ch}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> result_image = image_mix_ch.read(); ctx.http_srv_ch().write(reply{..., <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(result_image), ...}); }</code> </pre> <br>  Aqui tudo √© bastante trivial e repete regularmente o mesmo padr√£o: <br><br><ul><li>  Primeiro, criamos um canal para receber mensagens de resposta.  Isso √© necess√°rio porque  o processo CSP n√£o possui sua pr√≥pria caixa de correio padr√£o, como atores.  Portanto, se o processo CSP-shny quiser receber algo, ele deve ficar confuso com a cria√ß√£o do canal onde esse "algo" ser√° escrito; </li><li>  ent√£o enviamos nossa mensagem para o processo mestre do CSP.  E nesta mensagem, indicamos o canal para a mensagem de resposta; </li><li>  ent√£o, realizamos a opera√ß√£o de leitura no canal para o qual devemos receber uma mensagem de resposta. </li></ul><br>  Isso √© visto com muita clareza no exemplo de comunica√ß√£o com o processo do ImageSPixer CSP: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> image_mix_ch = make_chain&lt;mixed_image&gt;(); <span class="hljs-comment"><span class="hljs-comment">//  . ctx.image_mixer_ch().write( //  . mix_image{..., image_mix_ch}); //     . auto result_image = image_mix_ch.read(); //  .</span></span></code> </pre> <br>  Mas separadamente vale a pena focar neste fragmento: <br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user = user_info_ch.read(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image = image_loaded_ch.read();</code> </pre> <br>  Aqui vemos outra diferen√ßa s√©ria em rela√ß√£o ao modelo de atores.  No caso do CSP, podemos receber mensagens de resposta na ordem que mais nos conv√©m. <br><br>  Deseja esperar primeiro por user_info?  N√£o tem problema, v√° dormir na leitura at√© que user_info apare√ßa.  Se image_loaded j√° tiver sido enviado para n√≥s nesse momento, ele simplesmente esperar√° no canal at√© lermos. <br><br>  Isso, de fato, √© tudo o que pode acompanhar o c√≥digo mostrado acima.  O c√≥digo baseado em CSP era mais compacto que seu equivalente baseado em ator.  O que n√£o √© surpreendente, j√° que  aqui n√£o precisamos descrever uma classe separada com m√©todos de retorno de chamada.  E parte do estado de nosso processo t√≠mido no CSP, RequestHandler, est√° presente implicitamente na forma dos argumentos ctx e req. <br><br><h2>  Recursos CSP </h2><br><h3>  Reatividade e proatividade de processos CSP </h3><br>  Diferentemente dos atores, os processos de CSP podem ser reativos, proativos ou ambos.  Digamos que o processo CSP verificou suas mensagens recebidas e, se houver alguma, processou-as.  E ent√£o, vendo que n√£o havia mensagens recebidas, ele se comprometeu a multiplicar as matrizes. <br><br>  Depois de algum tempo, o processo CSP da matriz estava cansado de se multiplicar, e ele mais uma vez verificou as mensagens recebidas.  N√£o h√° novos?  Bem, ok, vamos multiplicar ainda mais as matrizes. <br><br>  E essa capacidade dos processos CSP de realizar algum trabalho, mesmo na aus√™ncia de mensagens recebidas, torna o modelo CSP muito diferente do modelo de atores. <br><br><h3>  Mecanismos nativos de prote√ß√£o contra sobrecarga </h3><br>  Como, via de regra, os canais s√£o filas de mensagens de tamanho limitado e a tentativa de gravar uma mensagem em um canal cheio interrompe o remetente; ent√£o, no CSP, temos um mecanismo interno de prote√ß√£o contra sobrecarga. <br><br>  De fato, se tivermos um processo de produ√ß√£o √°gil e um processo de consumo lento, o processo de produ√ß√£o preencher√° rapidamente o canal e ser√° suspenso para a pr√≥xima opera√ß√£o de envio.  E o processo produtor ficar√° suspenso at√© que o processo consumidor libere espa√ßo no canal para novas mensagens.  Assim que o local aparece, o processo do produtor √© ativado e lan√ßa novas mensagens no canal. <br><br>  Assim, ao usar o CSP, podemos nos preocupar menos com o problema de sobrecarga do que no caso do Modelo de Atores.  √â verdade que h√° uma armadilha aqui, sobre a qual falaremos um pouco mais tarde. <br><br><h3>  Como os processos de CSP s√£o implementados </h3><br>  Precisamos decidir como nossos processos de CSP ser√£o implementados. <br><br>  Isso pode ser feito para que cada processo CSP-shny seja representado por um thread do SO separado.  Acontece uma solu√ß√£o cara e n√£o escal√°vel.  Mas, por outro lado, temos multitarefa preemptiva: se nosso processo CSP come√ßar a multiplicar matrizes ou fazer algum tipo de chamada de bloqueio, o SO acabar√° empurrando-o para fora do n√∫cleo computacional e possibilitando o funcionamento de outros processos CSP. <br><br>  √â poss√≠vel fazer com que cada processo CSP seja representado por uma corotina (corotina empilh√°vel).  Esta √© uma solu√ß√£o muito mais barata e escal√°vel.  Mas aqui teremos apenas multitarefa cooperativa.  Portanto, se de repente o processo CSP ocupar a multiplica√ß√£o de matrizes, o encadeamento de trabalho com esse processo CSP e outros processos CSP anexados a ele ser√° bloqueado. <br><br>  Pode haver outro truque.  Suponha que usamos uma biblioteca de terceiros, na qual n√£o podemos influenciar.  E dentro da biblioteca, as vari√°veis ‚Äã‚ÄãTLS s√£o usadas (ou seja, thread-local-storage).  Fazemos uma chamada para a fun√ß√£o de biblioteca e a biblioteca define o valor de alguma vari√°vel TLS.  Ent√£o a nossa rotina "move" para outro segmento de trabalho, e isso √© poss√≠vel, porque  em princ√≠pio, as corotinas podem migrar de um segmento de trabalho para outro.  Fazemos a seguinte chamada para a fun√ß√£o de biblioteca e a biblioteca tenta ler o valor da vari√°vel TLS.  Mas j√° pode haver um significado diferente!  E procurar esse bug ser√° muito dif√≠cil. <br><br>  Portanto, voc√™ precisa considerar cuidadosamente a escolha do m√©todo para implementar os processos CSP-shnyh.  Cada uma das op√ß√µes tem seus pr√≥prios pontos fortes e fracos. <br><br><h3>  Muitos processos nem sempre s√£o a solu√ß√£o. </h3><br>  Assim como os atores, a capacidade de criar muitos processos de CSP em seu programa nem sempre √© uma solu√ß√£o para um problema aplicado, mas cria problemas adicionais para si mesmo. <br><br>  Al√©m disso, a baixa visibilidade do que est√° acontecendo dentro do programa √© apenas uma parte do problema.  Eu gostaria de me concentrar em outra armadilha. <br><br>  O fato √© que, nos canais CSP-shnyh, voc√™ pode facilmente obter um an√°logo de impasse.  O processo A tenta gravar uma mensagem no canal C1 completo e o processo A est√° em pausa.  Do canal C1, o processo B, que tentou gravar no canal C2, que est√° cheio, deve ser lido e, portanto, o processo B foi suspenso.  E no canal C2, o processo A. era para ler, s√≥ isso, temos um impasse. <br><br>  Se tivermos apenas dois processos CSP, podemos encontrar esse conflito durante a depura√ß√£o ou mesmo com o procedimento de revis√£o de c√≥digo.  Mas se tivermos milh√µes de processos no programa, eles se comunicam ativamente, a probabilidade de tais impasses aumenta significativamente. <br><br><h2>  Onde procurar, o que levar? </h2><br>  Se algu√©m quiser trabalhar com CSP em C ++, a escolha aqui, infelizmente, n√£o √© t√£o grande quanto para os atores.  Bem, ou n√£o sei para onde procurar e como procurar.  Nesse caso, espero que os coment√°rios compartilhem outros links. <br><br>  Mas, se queremos usar o CSP, primeiro precisamos olhar para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Boost.Fiber</a> .  Existem fibras (ou seja, corotinas) e canais, e at√© mesmo primitivos de baixo n√≠vel como barreira mutex, vari√°vel_da_avalia√ß√£o.  Tudo isso pode ser tomado e usado. <br><br>  Se voc√™ estiver satisfeito com os processos CSP na forma de threads, poder√° ver o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SObjectizer</a> .  Tamb√©m existem an√°logos de canais CSP e aplicativos complexos de v√°rios segmentos no SObjectizer podem ser escritos sem nenhum ator. <br><br><h1>  Actors vs CSP </h1><br>  Atores e CSPs s√£o muito parecidos entre si.  Repetidamente, deparei-me com a afirma√ß√£o de que esses dois modelos s√£o equivalentes entre si.  I.e.  o que pode ser feito nos atores pode ser quase 1 em 1 repetido nos processos de CSP e vice-versa.  Eles dizem que isso √© provado matematicamente.  Mas aqui eu n√£o entendo nada, ent√£o n√£o posso dizer nada.  Mas, a partir de meus pr√≥prios pensamentos em algum lugar no n√≠vel do senso comum cotidiano, tudo isso parece bastante plaus√≠vel.  Em alguns casos, de fato, os atores podem ser substitu√≠dos por processos de CSP, e os processos de CSP por atores. <br><br>  No entanto, existem v√°rias diferen√ßas entre atores e CSPs que podem ajudar a determinar onde cada um desses modelos √© ben√©fico ou desvantajoso. <br><br><h2>  Canais vs caixa de correio </h2><br>  Um ator possui um √∫nico "canal" para receber mensagens recebidas - essa √© a caixa de correio dele, criada automaticamente para cada ator.  E o ator recupera as mensagens de l√° sequencialmente, exatamente na ordem em que as mensagens estavam na caixa de correio. <br><br>  E esta √© uma pergunta bastante s√©ria.  Digamos que haja tr√™s mensagens na caixa de correio do ator: M1, M2 e M3.  Atualmente, o ator est√° interessado apenas em M3.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas antes de chegar ao M3, o ator extrair√° primeiro M1, depois M2. </font><font style="vertical-align: inherit;">E o que ele far√° com eles?</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Novamente, como parte dessa conversa, n√£o abordaremos os mecanismos de recebimento seletivo de Erlang e os escondidos de Akka. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto o processo CSP-shny tem a capacidade de selecionar o canal do qual atualmente deseja ler as mensagens. </font><font style="vertical-align: inherit;">Portanto, um processo CSP pode ter tr√™s canais: C1, C2 e C3. </font><font style="vertical-align: inherit;">Atualmente, o processo CSP est√° interessado apenas em mensagens do C3. </font><font style="vertical-align: inherit;">√â esse canal que o processo l√™. </font><font style="vertical-align: inherit;">E ele retornar√° ao conte√∫do dos canais C1 e C2 quando estiver interessado nisso.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reatividade e Proatividade </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como regra, os atores s√£o reativos e s√≥ funcionam quando recebem mensagens. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enquanto os processos CSP podem fazer algum trabalho, mesmo na aus√™ncia de mensagens recebidas. </font><font style="vertical-align: inherit;">Em alguns cen√°rios, essa diferen√ßa pode desempenhar um papel importante.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> M√°quinas de estado </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De fato, os atores s√£o m√°quinas de estados finitos (KA). </font><font style="vertical-align: inherit;">Portanto, se houver muitas m√°quinas de estados finitos em sua √°rea de assunto e, mesmo que sejam complexas, m√°quinas hier√°rquicas de estados finitos, ser√° muito mais f√°cil implement√°-las com base no modelo de ator do que adicionar uma implementa√ß√£o de espa√ßonave a um processo CSP.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No C ++, ainda n√£o h√° suporte nativo ao CSP. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A experi√™ncia da linguagem Go mostra como √© f√°cil e conveniente usar o modelo CSP quando seu suporte √© implementado no n√≠vel de uma linguagem de programa√ß√£o e de sua biblioteca padr√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No Go, √© f√°cil criar "processos CSP" (tamb√©m conhecidos como goroutines), √© f√°cil criar e trabalhar com canais, existe uma sintaxe interna para trabalhar com v√°rios canais ao mesmo tempo (Go-shny select, que funciona n√£o apenas para leitura, mas tamb√©m para escrita), a biblioteca padr√£o conhece as goroutins e pode troc√°-las quando a goroutin faz uma chamada de bloqueio do stdlib. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No C ++, at√© o momento n√£o h√° suporte para corotinas empilhadas (no n√≠vel da linguagem). </font><font style="vertical-align: inherit;">Portanto, trabalhar com CSP em C ++ pode parecer, em alguns lugares, se n√£o uma muleta, ent√£o ... Isso certamente exige muito mais aten√ß√£o a si mesmo do que no caso do mesmo Go.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Abordagem n¬∫ 3: tarefas (ass√≠ncrono, futuro, wait_all, ...) </font></font></h1><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sobre a abordagem baseada em tarefas nas palavras mais comuns </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O significado da abordagem baseada em tarefas √© que, se tivermos uma opera√ß√£o complexa, dividimos essa opera√ß√£o em etapas de tarefa separadas, onde cada tarefa (√© uma tarefa) executa uma √∫nica subopera√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iniciamos essas tarefas com a opera√ß√£o especial ass√≠ncrona. </font><font style="vertical-align: inherit;">A opera√ß√£o ass√≠ncrona retorna um objeto futuro no qual, ap√≥s a conclus√£o da tarefa, o valor retornado pela tarefa ser√° colocado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois que lan√ßamos N tarefas e recebemos N objetos-futuro, precisamos de alguma forma tricotar tudo isso em uma cadeia. </font><font style="vertical-align: inherit;">Parece que, quando as tarefas 1 e 2 s√£o conclu√≠das, os valores retornados por elas devem cair na tarefa 3. </font><font style="vertical-align: inherit;">E quando a tarefa n¬∫ 3 for conclu√≠da, o valor retornado dever√° ser transferido para as tarefas n¬∫ 4, n¬∫ 5 e n¬∫ 6. </font><font style="vertical-align: inherit;">Etc., etc.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para tal "empate", s√£o usados ‚Äã‚Äãmeios especiais. </font><font style="vertical-align: inherit;">Como, por exemplo, o m√©todo .then () de um objeto futuro, bem como as fun√ß√µes wait_all (), wait_any (). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa explica√ß√£o "nos dedos" pode n√£o ser muito clara, ent√£o vamos ao c√≥digo. </font><font style="vertical-align: inherit;">Talvez em uma conversa sobre um c√≥digo espec√≠fico, a situa√ß√£o se torne mais clara (mas n√£o um fato).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C√≥digo Request_handler para abordagem baseada em tarefas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O c√≥digo para processar uma solicita√ß√£o HTTP recebida com base em tarefas pode ser assim: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> execution_context &amp; ctx, request req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); }); when_all(user_info_ft, original_image_ft).then( [&amp;ctx, req](tuple&lt;future&lt;user_info&gt;, future&lt;image_loaded&gt;&gt; data) { async(ctx.image_mixer_ctx(), [&amp;ctx, req, d=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(data)] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mix_image(get&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(d).get().watermark_image(), get&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>&gt;(d).get()); }) .then([req](future&lt;mixed_image&gt; mixed) { async(ctx.http_srv_ctx(), [req, im=<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mixed)] { make_reply(...); }); }); }); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos tentar descobrir o que est√° acontecendo aqui. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeiro, criamos uma tarefa que deve ser iniciada no contexto de nosso pr√≥prio cliente HTTP e que solicita informa√ß√µes sobre o usu√°rio. O objeto futuro retornado √© armazenado na vari√°vel user_info_ft. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, criamos uma tarefa semelhante, que tamb√©m deve ser executada no contexto de nosso pr√≥prio cliente HTTP e que carrega a imagem original. O objeto futuro retornado √© armazenado na vari√°vel original_image_ft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em seguida, precisamos aguardar a conclus√£o das duas primeiras tarefas. </font><font style="vertical-align: inherit;">O que escrevemos diretamente: when_all (user_info_ft, original_image_ft). </font><font style="vertical-align: inherit;">Quando os dois objetos futuros obtiverem seus valores, executaremos outra tarefa. </font><font style="vertical-align: inherit;">Esta tarefa pegar√° o bitmap com a marca d'√°gua e a imagem original e executar√° outra tarefa no contexto do ImageMixer. </font><font style="vertical-align: inherit;">Essa tarefa mescla imagens e, quando conclu√≠da, outra tarefa ser√° iniciada no contexto do servidor HTTP, o que gerar√° uma resposta HTTP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Talvez essa explica√ß√£o do que est√° acontecendo no c√≥digo n√£o esteja muito esclarecida. </font><font style="vertical-align: inherit;">Portanto, vamos numerar nossas tarefas:</font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/5k/c0/mr/5kc0mrvqnxdf6lp4-p0wgn1nj7w.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E vejamos as depend√™ncias entre elas (a partir das quais a ordem das tarefas flui): </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/zu/j4/g4/zuj4g4wwg0wxmhazj5k5rdb8pgu.jpeg"></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E se agora sobrepormos esta imagem ao nosso c√≥digo-fonte, espero que fique mais claro: </font></font><br><table><tbody><tr><td><img src="https://habrastorage.org/webt/sw/at/uz/swatuzio1z33-ei16gquj-ss5mg.jpeg"></td></tr></tbody></table><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursos da abordagem baseada em tarefas </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Visibilidade </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O primeiro recurso que j√° deveria ser √≥bvio √© a visibilidade do c√≥digo na tarefa. </font><font style="vertical-align: inherit;">Nem tudo est√° bem com ela. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui voc√™ pode mencionar o inferno de retorno de chamada. </font><font style="vertical-align: inherit;">Os programadores do Node.js est√£o muito familiarizados com isso. </font><font style="vertical-align: inherit;">Mas apelidos em C ++ que trabalham em estreita colabora√ß√£o com a Task tamb√©m mergulham nesse inferno de retorno de chamada.</font></font><br><br><h3>  Tratamento de erros </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro recurso interessante √© o tratamento de erros. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por um lado, no caso de uso ass√≠ncrono e futuro com a entrega de informa√ß√µes de erro √† parte interessada, pode ser ainda mais f√°cil do que no caso de atores ou CSP. </font><font style="vertical-align: inherit;">Afinal, se no processo CSP A enviar uma solicita√ß√£o para processar B e aguardar uma mensagem de resposta, quando B encontrar um erro ao executar a solicita√ß√£o, precisaremos decidir como enviar o erro ao processo A:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou criaremos um tipo separado de mensagem e um canal para receb√™-la; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou retornamos o resultado com uma √∫nica mensagem, que ser√° std :: variant para um resultado normal e incorreto. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E no caso do futuro, tudo √© mais simples: extra√≠mos do futuro um resultado normal ou uma exce√ß√£o √© lan√ßada para n√≥s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas, por outro lado, podemos facilmente encontrar uma cascata de erros. </font><font style="vertical-align: inherit;">Por exemplo, ocorreu uma exce√ß√£o na tarefa n¬∫ 1; essa exce√ß√£o caiu no objeto futuro, que foi passado para a tarefa n¬∫ 2. </font><font style="vertical-align: inherit;">Na tarefa n¬∫ 2, tentamos tirar o valor do futuro, mas recebemos uma exce√ß√£o. </font><font style="vertical-align: inherit;">E, provavelmente, lan√ßaremos a mesma exce√ß√£o. </font><font style="vertical-align: inherit;">Consequentemente, ele cair√° no futuro pr√≥ximo, que passar√° √† tarefa n¬∫ 3. </font><font style="vertical-align: inherit;">Tamb√©m haver√° uma exce√ß√£o, que, possivelmente, tamb√©m ser√° lan√ßada.</font></font> Etc. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se nossas exce√ß√µes forem registradas, no log, podemos ver a repeti√ß√£o repetida da mesma exce√ß√£o, que passa de uma tarefa na cadeia para outra. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cancelar tarefas e temporizadores / tempos limite </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E outra caracter√≠stica muito interessante da campanha baseada em tarefas √© o cancelamento de tarefas se algo der errado. </font><font style="vertical-align: inherit;">De fato, digamos que criamos 150 tarefas, conclu√≠mos as 10 primeiras e percebemos que n√£o havia sentido em continuar o trabalho. </font><font style="vertical-align: inherit;">Como cancelamos os 140 restantes? </font><font style="vertical-align: inherit;">Essa √© uma pergunta muito, muito boa :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra pergunta semelhante √© como fazer tarefas de amigos com temporizadores e tempos limite. </font><font style="vertical-align: inherit;">Suponha que estamos acessando algum sistema externo e desejamos limitar o tempo de espera para 50 milissegundos. </font><font style="vertical-align: inherit;">Como podemos definir o cron√¥metro, como reagir √† expira√ß√£o do tempo limite, como interromper a cadeia de tarefas se o tempo limite expirou? </font><font style="vertical-align: inherit;">Mais uma vez, perguntar √© mais f√°cil do que responder :)</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Trapa√ßa </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, e para falar sobre os recursos da abordagem baseada em tarefas. </font><font style="vertical-align: inherit;">No exemplo mostrado, um pouco de trapa√ßa foi aplicada:</font></font><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> user_info_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retrieve_user_info(req.user_id()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> original_image_ft = async(ctx.http_client_ctx(), [req] { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> download_image(req.image_id()); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui, enviei duas tarefas para o contexto de nosso pr√≥prio servidor HTTP, cada uma das quais executa uma opera√ß√£o de bloqueio no interior. </font><font style="vertical-align: inherit;">De fato, para poder processar duas solicita√ß√µes para servi√ßos de terceiros em paralelo, aqui voc√™ tinha que criar suas pr√≥prias cadeias de tarefas ass√≠ncronas. </font><font style="vertical-align: inherit;">Mas n√£o fiz isso para tornar a solu√ß√£o mais ou menos vis√≠vel e ajustada ao slide da apresenta√ß√£o.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atores / CSP vs Tarefas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinamos tr√™s abordagens e vimos que, se os atores e os processos de CSP s√£o semelhantes entre si, a abordagem baseada em tarefas n√£o √© como nenhuma delas. E pode parecer que os atores / CSP devam ser contrastados com a tarefa. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas, pessoalmente, eu gosto de um ponto de vista diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando falamos sobre o Modelo de Atores e CSP, estamos falando sobre a decomposi√ß√£o de nossa tarefa. Em nossa tarefa, destacamos entidades independentes separadas e descrevemos as interfaces dessas entidades: quais mensagens eles enviam, quais eles recebem, por quais canais as mensagens passam.</font></font><br><br>  I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabalhando com atores e CSP, estamos falando de interfaces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas suponha que dividamos a tarefa em atores separados e processos de CSP. Como exatamente eles fazem seu trabalho? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quando adotamos a abordagem baseada em tarefas, come√ßamos a falar sobre implementa√ß√£o. Sobre como um trabalho espec√≠fico √© executado, quais subopera√ß√µes s√£o executadas, em que ordem, como essas subopera√ß√µes s√£o conectadas de acordo com dados, etc.</font></font><br><br>  I.e.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trabalhando com a tarefa, estamos falando sobre implementa√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, atores / CSP e tarefas n√£o se op√µem muito, mas se complementam. </font><font style="vertical-align: inherit;">Atores / CSPs podem ser usados ‚Äã‚Äãpara decompor tarefas e definir interfaces entre componentes. </font><font style="vertical-align: inherit;">E as tarefas podem ser usadas para implementar componentes espec√≠ficos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por exemplo, ao usar o Actor, temos uma entidade como ImageMixer, que precisa ser manipulada com imagens no pool de threads. </font><font style="vertical-align: inherit;">Em geral, nada nos impede de usar o ator ImageMixer para usar a abordagem baseada em tarefas.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Onde procurar, o que levar? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ deseja trabalhar com Tarefas em C ++, pode olhar para a biblioteca padr√£o do pr√≥ximo C ++ 20. Eles j√° adicionaram o m√©todo .then () ao futuro, bem como as fun√ß√µes livres wait_all () e wait_any. Veja </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cppreference para detalhes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tamb√©m j√° est√° longe de uma nova </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biblioteca async ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em que, em princ√≠pio, h√° tudo o que voc√™ precisa, um pouco com um molho diferente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E existe uma biblioteca </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PPL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ainda mais antiga </font><font style="vertical-align: inherit;">. O que tamb√©m d√° tudo o que voc√™ precisa, mas com seu pr√≥prio molho.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adi√ß√£o separada sobre a biblioteca Intel TBB. </font><font style="vertical-align: inherit;">N√£o foi mencionado na hist√≥ria sobre a abordagem baseada em tarefas porque, na minha opini√£o, os gr√°ficos de tarefas do TBB j√° s√£o uma abordagem de fluxo de dados. </font><font style="vertical-align: inherit;">E, se este relat√≥rio continuar, a conversa sobre o Intel TBB certamente chegar√°, mas no contexto da hist√≥ria sobre o fluxo de dados.</font></font></blockquote><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mais interessante </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recentemente, aqui em Habr√©, houve um artigo de Anton Polukhin: "Estamos nos </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">preparando para o C ++ 20. Coroutines TS usando um exemplo real</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ele fala sobre como combinar uma abordagem baseada em tarefas com corotinas sem pilha do C ++ 20. </font><font style="vertical-align: inherit;">E descobriu-se que o c√≥digo com base na legibilidade da tarefa se aproximava da legibilidade do c√≥digo nos processos CSP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, se algu√©m estiver interessado na abordagem baseada em tarefas, faz sentido ler este artigo.</font></font><br><br><h1>  Conclus√£o </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bem, √© hora de avan√ßar para os resultados, j√° que n√£o existem muitos deles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A principal coisa que quero dizer √© que no mundo moderno voc√™ pode precisar de multithreading apenas se estiver desenvolvendo algum tipo de estrutura ou resolvendo alguma tarefa espec√≠fica e de baixo n√≠vel. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E se voc√™ estiver escrevendo o c√≥digo do aplicativo, dificilmente precisar√° de threads nus, primitivas de sincroniza√ß√£o de baixo n√≠vel ou algum tipo de algoritmo sem bloqueios junto com cont√™ineres sem bloqueios. </font><font style="vertical-align: inherit;">Por um longo tempo, existem abordagens testadas pelo tempo e que se provaram bem:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atores </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> processos sequenciais de comunica√ß√£o (CSP) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tarefas (ass√≠ncronas, promessas, futuros, ...) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fluxos de dados </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programa√ß√£o reativa </font></font></li><li>  ... </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E o mais importante, existem ferramentas prontas para eles em C ++. </font><font style="vertical-align: inherit;">Voc√™ n√£o precisa pedalar nada, pode pegar, experimentar e, se quiser, coloc√°-lo em opera√ß√£o. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T√£o simples: pegue, tente e coloque em opera√ß√£o.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt430672/">https://habr.com/ru/post/pt430672/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt430662/index.html">Monitorando servidores Windows em puro MS SQL e como eu o implementei secretamente</a></li>
<li><a href="../pt430664/index.html">O papel do l√≠der da equipe no recrutamento</a></li>
<li><a href="../pt430666/index.html">Como avaliar o desempenho da equipe</a></li>
<li><a href="../pt430668/index.html">Sozinho no campo n√£o √© um guerreiro. O caminho para o trabalho em equipe eficaz</a></li>
<li><a href="../pt430670/index.html">Gerenciamento de arranjos</a></li>
<li><a href="../pt430674/index.html">A l√≥gica da constru√ß√£o de hor√°rios de trabalho universais</a></li>
<li><a href="../pt430676/index.html">Antiguidades: shshshsh, sssssss, VOIP, BBS e outros amigos do modem</a></li>
<li><a href="../pt430678/index.html">Teste de dez dimmers com l√¢mpadas LED</a></li>
<li><a href="../pt430680/index.html">Escrevendo um processador e ambiente simples para ele</a></li>
<li><a href="../pt430682/index.html">Tr√™s anos do projeto de microssat√©lites lunares: est√°gios de crescimento</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>