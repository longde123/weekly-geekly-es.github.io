<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚒 🔱 〰️ Les transitions d'écran dans Legend of Zelda utilisent les fonctionnalités non documentées de NES 🕴🏽 👉 🧝🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour l'effet du défilement vertical dans la première partie de "The Legend of Zelda", des manipulations graphiques "matérielles" NES sont utilisées, p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les transitions d'écran dans Legend of Zelda utilisent les fonctionnalités non documentées de NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/">  Pour l'effet du défilement vertical dans la première partie de "The Legend of Zelda", des manipulations graphiques "matérielles" NES sont utilisées, probablement pas fournies par les développeurs de la console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  Je n'ai pas accès à la documentation officielle de l'unité de traitement d'image (PPU - puce graphique) de la console NES, donc mes déclarations sur le "comportement indéfini" sont plus susceptibles d'être des suppositions.  J'ai pris les spécifications du matériel graphique du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki NesDev</a> .  PPU est contrôlé en écrivant dans des registres avec mappage de mémoire.  Si vous utilisez ces registres de la manière qui (semble-t-il) a été conçue par les concepteurs, il serait impossible d'obtenir cet effet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  Lorsque vous faites défiler l'écran verticalement, tout l'écran doit défiler en même temps.  Le GIF précédent montre un exemple de défilement vertical partiel.  Une partie de l'écran reste immobile (éléments d'interface) et l'autre partie (zone de jeu) défile verticalement.  Le défilement vertical partiel est impossible à implémenter avec le travail "standard" avec PPU. <br><br>  En revanche, <em>le</em> défilement <em>horizontal</em> partiel est entièrement défini et possible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  L'écriture dans un registre PPU distinct au moment où l'image est tracée peut conduire à des artefacts graphiques.  La légende de Zelda provoque intentionnellement un artefact qui se manifeste par un défilement vertical partiel.  Dans cet article, je vais parler un peu du matériel graphique NES et expliquer comment fonctionne l'astuce de défilement vertical. <br><a name="habracut"></a><br><h2>  Types de graphiques </h2><br>  La console NES possède deux types de graphiques: <br><br><ul><li>  Les sprites sont des tuiles qui peuvent être placées à des endroits arbitraires sur l'écran et déplacées indépendamment les unes des autres. </li><li>  Arrière-plan - une grille de tuiles qui peut être défilée en douceur comme une seule image. </li></ul><br>  Pour démontrer la différence entre les deux, je vais montrer une scène composée de sprites et de fond: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  Et voici la même scène dans laquelle seuls les sprites sont visibles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  Et voici une scène dans laquelle seul l'arrière-plan est visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  Défilement </h2><br>  Le processeur d'image (NES Picture Processor) prend en charge le défilement des images d'arrière-plan.  Dans la mémoire graphique, le graphique d'arrière-plan est stocké sous la forme d'une grille bidimensionnelle de tuiles couvrant une zone deux fois la largeur et la hauteur de l'écran. <br><br>  Une «fenêtre» est affichée à l'écran dans cette grille de la taille d'un écran, et la position de cette fenêtre peut être contrôlée avec précision.  En déplaçant progressivement la fenêtre visible le long de la grille, un effet de défilement fluide est créé. <br><br>  Le signal vidéo de sortie NES a une taille de 256x240 pixels.  La grille de tuiles à l'intérieur de la mémoire est représentée comme une zone de 512x480 pixels et est divisée en quatre rectangles de taille d'écran appelés «tables de noms».  Les jeux peuvent configurer l'unité de traitement d'image (PPU) en indiquant la position de la fenêtre visible en sélectionnant les coordonnées des pixels dans la grille des tables de noms. <br><br>  Lorsque vous sélectionnez les coordonnées (0, 0), la totalité du tableau de noms supérieur gauche s'affiche à l'écran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Passant à (125, 181), nous verrons un peu de chaque table de noms: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  La fenêtre visible se réduit à l'arrière de la grille de tuiles en mémoire.  Passant à (342, 290), nous plaçons le coin supérieur gauche de l'écran visible à l'intérieur du tableau des noms en bas à droite, et grâce au pliage, des parties de chacun des tableaux des noms seront visibles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  Pas assez de mémoire! </h3><br>  Chaque table de noms a une taille de 1 Ko, mais NES alloue seulement 2 Ko de sa mémoire vidéo à ces tables, de sorte que seules deux tables de noms peuvent tenir en mémoire à la fois. <br><br>  Comment peut-il avoir quatre tables de noms? <br><br><h4>  Mise en miroir des tables de noms </h4><br>  La mémoire vidéo est connectée au PPU de telle manière que lorsque le PPU restitue une tuile de l'une des quatre tables de noms apparentes, en fait l'une des deux vraies tables est sélectionnée, et la lecture vient de là.  En substance, cela signifie que les quatre tables de noms visibles sont en fait constituées de deux paires de tables identiques. <br><br>  Cette image montre un instantané du contenu des quatre tableaux.  Le haut à gauche et le haut à droite sont les mêmes que les deux inférieurs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  Pourquoi alors ne pas garder deux tables de noms? <br><br>  Heureusement, la liaison exacte entre les tables apparente et réelle peut être configurée au moment de l'exécution.  Si le jeu souhaite effectuer un défilement horizontal, il ajuste l'équipement graphique de sorte que les tableaux supérieur gauche et supérieur droit soient différents, et ils peuvent être défilés sans duplication notable.  Dans cette configuration, les tableaux supérieur gauche et inférieur gauche feront référence au même tableau de nom réel;  de même pour les deux tableaux de droite.  Cette configuration est appelée mise en miroir verticale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  Il existe également une autre configuration possible - «Horizontal Mirroring», que les jeux utilisent pour le défilement vertical. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  En règle générale, les jeux ne défilent pas en diagonale, car cela crée des artefacts autour des bords de l'écran en raison de la mise en miroir des tables de noms. <br><br><h3>  Cartouches </h3><br>  La cartouche de chaque jeu possède un matériel qui vous permet de configurer la mise en miroir des tables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  Certains jeux n'ont pas du tout besoin de basculer la mise en miroir, de sorte que la mise en miroir horizontale ou verticale est codée en dur dans leurs cartouches.  D'autres jeux basculent dynamiquement entre ces deux modes, donc la mise en miroir dans leurs cartouches est configurée par programme.  La légende de Zelda appartient à la deuxième catégorie.  Enfin, les cartouches de certains jeux vraiment complexes ont une mémoire vidéo supplémentaire, c'est-à-dire qu'elles n'ont pas du tout besoin de mise en miroir: elles peuvent simultanément faire défiler verticalement et horizontalement sans artefacts de duplication visibles. <br><br><h3>  Exemple réel </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>Un exemple de défilement vertical qui s'affiche à l'écran.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Cela montre un enregistrement des tables de noms avec mise en miroir horizontale.</i>  <i>La fenêtre actuellement visible est mise en surbrillance.</i> <br><br>  N'oubliez pas que le défilement le plus vertical n'est pas inhabituel - ce qui est inhabituel est le défilement vertical avec <em>écran partagé</em> . <br><br><h2>  Écran partagé </h2><br>  Chaque image du signal vidéo généré par NES est rendue de haut en bas, une rangée de pixels à la fois.  Dans chaque ligne, les pixels sont dessinés un à la fois, de gauche à droite.  À mi-chemin lors du rendu de l'image, le jeu peut reconfigurer le PPU, ce qui affecte l'affichage des pixels qui n'ont pas encore été rendus.  L'un des changements les plus courants au milieu du cadre est la mise à jour de la position de défilement horizontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  Lors du défilement horizontal entre les pièces, The Legend of Zelda commence toujours à partir de la position de défilement (0, 0) et affiche les éléments d'interface en haut de l'écran.  Après avoir tracé la dernière ligne de pixels d'interface sur l'écran, le défilement horizontal change d'une valeur qui augmente avec chaque image, de sorte que la caméra se déplace en douceur. <br><br>  L'animation de l'affichage des tables de noms montre comment le jeu passe de la mise en miroir horizontale à la mise en miroir verticale avant le défilement, puis à nouveau à l'horizontale une fois la transition terminée.  De plus, pendant que le défilement se poursuit, les tables de noms en haut à gauche (et en bas à gauche) sont mises à jour et une copie de la pièce dans laquelle le joueur entre est enregistrée.  Une fois le défilement terminé, le jeu cesse de diviser l'écran et est à nouveau entièrement rendu à partir du tableau supérieur gauche. <br><br><h3>  Mesure de rendu </h3><br>  Pour diviser l'écran dans la position souhaitée, le jeu doit en quelque sorte savoir quelle partie de l'image actuelle a été dessinée.  Les chaînes de pixels sont rendues à une fréquence connue, de sorte que le nombre de chaînes de pixels rendues peut être déterminé en comptant le nombre de cycles de processeur qui se sont écoulés depuis le début de la trame. <br><br>  Il existe une autre technique plus précise appelée Sprite Zero Hit. <br><br>  NES peut rendre jusqu'à 64 images-objets à la fois.  Le premier sprite dans la mémoire vidéo est appelé Sprite Zero (zéro sprite).  Dans chaque image, dès qu'un pixel opaque d'un sprite zéro est superposé à un pixel d'arrière-plan opaque, l'événement Sprite Zero Hit se produit.  Il définit un bit dans l'un des registres PPU avec un mappage de mémoire, qui peut être vérifié par le processeur. <br><br>  Pour utiliser Sprite Zero Hit pour diviser l'écran, les jeux placent le sprite zéro en position verticale près de la bordure divisée, et pendant le rendu, ils vérifient constamment si l'événement Sprite Zero Hit s'est produit.  Si c'est le cas, le jeu passe du défilement horizontal pour implémenter la séparation. <br><br>  La transition horizontale entre les pièces avec et sans fond est illustrée ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  Le cercle brun qui apparaît au début de la transition et disparaît à sa fin est un sprite zéro.  Nous allons examiner de plus près l'interface avec et sans arrière-plan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  Un sprite zéro est un sprite de bombe blanchi qui correspond parfaitement au sprite de bombe ordinaire de l'interface de jeu.  Le sprite zéro est configuré pour apparaître sous l'arrière-plan, mais comme les pixels noirs de l'interface sont considérés comme transparents, la bombe zéro sprite serait visible si elle n'avait pas été stratégiquement cachée derrière la bombe de l'interface. <br><br>  Notez que Sprite Zero Hit apparaît quelques lignes de pixels avant la ligne inférieure de l'interface.  Il se produit au pixel supérieur du fusible de la bombe, à 16 pixels du bas de l'interface.  Lorsque Sprite Zero Hit se produit, le jeu commence à compter les cycles du processeur et, après avoir terminé le nombre de cycles requis, définit le défilement horizontal. <br><br><h2>  Suppression de faisceau </h2><br>  La plupart du temps, la console PPU dessine des pixels à l'écran.  Il y a un court temps d'arrêt entre les images pendant lequel le rendu n'est pas effectué.  Ce phénomène est appelé blanking (Vertical Blank ou vblank).  Certains types de changements de configuration PPU ne peuvent être effectués que pendant vblank. <br><br><h2>  Registre défilant </h2><br>  Les jeux changent la position du défilement en écrivant dans le registre PPU appelé <code>PPUSCROLL</code> , qui correspond à l'adresse mémoire <code>0x2005</code> .  La première opération d'écriture dans <code>PPUSCROLL</code> définit le composant X de la position de défilement et la deuxième opération définit le composant Y. De même, un enregistrement alternatif est effectué plus loin. <br><br>  Ce qui suit montre toutes les opérations d'écriture non nulles dans <code>PPUSCROLL</code> pendant cette lecture (au ralenti) 16 images de l'écran avec l'intrigue du jeu.  La composante de position de défilement Y est incrémentée toutes les deux images.  Toutes les opérations d'écriture dans <code>PPUSCROLL</code> dans cet exemple sont effectuées pendant vblank, ce qui entraîne le défilement de l'arrière-plan entier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Scrolling Screen Split </h3><br>  Les opérations d' <code>PPUSCROLL</code> dans <code>PPUSCROLL</code> pendant vblank prennent effet au début de la trame dessinée immédiatement après vblank.  Si la position de défilement change pendant le rendu du cadre (c'est-à-dire pas pendant vblank), alors ce changement prend effet lorsque le dessin atteint la rangée de pixels suivante.  Le défilement horizontal partiel est implémenté en écrivant dans <code>PPUSCROLL</code> pendant que le PPU dessine la dernière ligne de pixels avant le défilement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  Lors de la mise à jour de la position de défilement au milieu du cadre, seule la position X de la position de défilement est appliquée.  C'est-à-dire que le composant de position de défilement Y est ignoré.  Ainsi, si le jeu souhaite diviser l'écran et modifie la position de défilement d'une partie du cadre, il ne peut que défiler horizontalement. <br><br>  Et pourtant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  Croyez-le ou non, la valeur du registre <code>PPUSCROLL</code> pas changé pendant cette transition. <br><br>  Vous pouvez voir un artefact graphique d'un pixel de haut sous l'interface.  Il s'agit d'un bug de mon émulateur provoqué par le manque de synchronisation des cycles d'horloge du processeur avec le rendu pixel par pixel. <br><br><h3>  Intervention dans d'autres registres </h3><br>  Le second registre, appelé <code>PPUADDR</code> , mappé à l'adresse mémoire <code>0x2006</code> , est utilisé pour définir l'adresse mémoire vidéo actuelle.  Lorsqu'un jeu, par exemple, souhaite modifier l'une des tuiles de la table de noms, il écrit d'abord l'adresse de mémoire vidéo de la <code>PPUADDR</code> dans <code>PPUADDR</code> , puis écrit la nouvelle valeur de la <code>PPUDATA</code> dans <code>PPUDATA</code> - il s'agit du troisième registre mappé à l'adresse <code>0x2007</code> . <br><br>  L'écriture dans <code>PPUADDR</code> pas pendant vblank (c'est-à-dire lors du rendu d'une image) peut provoquer des artefacts graphiques.  Cela est dû au fait que la chaîne PPU, qui est affectée par l'écriture dans <code>PPUADDR</code> , est également directement contrôlée par le périphérique PPU dans le processus d'obtention de tuiles de la mémoire vidéo pour les dessiner.  Étant donné que le processus de rendu à l'écran est effectué de haut en bas et de gauche à droite dans la ligne, le PPU attribue essentiellement à <code>PPUADDR</code> valeur de l'adresse de la <code>PPUADDR</code> actuelle.  Lorsque le rendu se déplace d'une mosaïque à une autre, <code>PPUADDR</code> est incrémenté de la valeur actuelle. <br><br>  Ainsi, l'écriture dans <code>PPUADDR</code> au milieu de la trame peut changer les tuiles reçues par la PPU de la mémoire pendant la durée de la trame actuelle. <br><br>  <code>PPUADDR</code> opérations d'écriture dans <code>PPUADDR</code> pendant le saut vertical.  Étant donné que la table de noms est également mise à jour pendant la transition, la sortie de <em>toutes les</em> opérations d'écriture vers <code>PPUADDR</code> sera trop étendue.  Avec une transition horizontale, le défilement est défini pendant le rendu d'une ligne de pixels 63, par conséquent, nous ne considérerons les opérations d'écriture dans <code>PPUADDR</code> que pendant cette ligne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  Le motif est clairement visible.  Toutes les deux trames, l'adresse enregistrée dans la ligne de pixels 63 est réduite de 32 (0x20).  Mais comment cela conduit-il à une mise à jour de la position de défilement réelle? <br><br><h3>  Registre de défilement <i>réel</i> </h3><br>  À l'intérieur du PPU, il y a un registre de 15 bits non mappé au CPU.  Il est utilisé à la fois comme adresse actuelle pour accéder à la mémoire vidéo et comme configuration de défilement en arrière-plan. <br><br>  Lorsque vous travaillez avec cette valeur comme adresse, le bit 14 est ignoré et les bits 0-13 sont traités comme une adresse dans la mémoire vidéo. <br><br>  Lorsque vous travaillez avec cette valeur comme configuration de défilement, ses différentes parties ont des significations différentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>La sélection d'une table de noms</strong> est une valeur comprise entre 0 et 3 qui détermine la table de noms actuelle à partir de laquelle le dessin est créé. <br><br>  <strong>Le défilement grossier en X</strong> et le <strong>défilement grossier en Y</strong> déterminent les coordonnées de la tuile à l'intérieur du tableau de noms sélectionné.  Il s'agit de la tuile actuelle à dessiner. <br><br>  <strong>Le défilement exact le long de Y</strong> contient une valeur de 0 à 7, qui détermine le décalage vertical actuel de la ligne de pixels à l'intérieur de la mosaïque actuelle.  Les tuiles sont des carrés avec un côté de 8 pixels. <br><br>  <strong>Le défilement exact sur X</strong> est absent de ce registre.  Il existe un registre séparé contenant uniquement le décalage horizontal du pixel actuel, mais il n'est pas important d'expliquer comment le défilement vertical est effectué dans The Legend of Zelda. <br><br>  Qu'advient-il de ce registre lorsqu'un jeu écrit dans <code>PPUADDR</code> ?  Voici les trois premières opérations d'écriture de la démo ci-dessus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  En divisant les entrées de l'adresse en composants de défilement, vous pouvez clairement comprendre ce qui se passe ici.  Toutes les deux images, la valeur du <strong>défilement brut en Y</strong> diminue, ce qui entraîne un défilement vertical d'une tuile ou de 8 pixels. <br><br>  Tout au long de chaque trame, le décalage de défilement initial est de 0,0, après quoi l'enregistrement sur la ligne de pixels 63 est effectué à l'adresse.  Cela signifie que les 63 premières lignes de pixels sont dessinées à partir du haut de la table de noms sélectionnée contenant l'arrière-plan de l'interface.  Cependant, la 64e ligne de pixels est rendue davantage avec un défilement vertical appliqué à partir de cette adresse.  Étant donné que le défilement vertical diminue toutes les deux images, il donne la sensation de défilement vertical d'une partie de l'écran. <br><br><h3>  Faites défiler vers le bas pour faire défiler vers le haut </h3><br>  La légende de Zelda ne peut pas complètement cacher cette astuce aux joueurs.  Il crée un artefact visible sur les transitions verticales de l'écran, qui sont visibles si vous regardez de près.  Lorsque vous vous déplacez entre les pièces, la première image de l'animation de défilement défile vers le bas.  Voici l'animation au ralenti. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  Dans le tableau des noms, vous pouvez voir ce qui se passe réellement.  Bien qu'il puisse sembler aux joueurs que la zone visible défilera vers le haut en douceur, la transition de défilement commence en déplaçant la zone visible du tableau de noms supérieur gauche vers le tableau inférieur gauche, qui contient une copie de l'arrière-plan de la pièce.  Cela est nécessaire car l'interface en haut de l'écran fait également partie de la table des noms, et si la zone visible défilait de sa position d'origine, elle passerait par l'interface. <br><br>  Le défilement vertical est implémenté en écrivant dans le registre <code>PPUADDR</code> au milieu de la trame.  La toute première valeur à écrire est <code>0x2800</code> .  Deux images plus tard, <code>0x23A0</code> enregistré, puis la valeur commence à diminuer de 32 toutes les deux images. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  L'écriture de la valeur <code>0x2800</code> dans le registre <code>0x2800</code> <code>PPUADDR</code> <strong>table de</strong> <code>PPUADDR</code> sur 2, ce qui rend la table de noms en bas à gauche.  Étant donné que les deux valeurs de défilement sont 0, il commencera à partir de la tuile supérieure gauche de cette table de noms.  Cependant, le <strong>défilement exact dans Y</strong> est 2, il y a donc un décalage vertical de deux pixels par rapport au haut du tableau de noms en bas à gauche.  C'est pourquoi dans la toute première image de la transition, on voit une barre noire de 2 pixels de haut en bas de l'écran.  La valeur de défilement initiale de l'animation de transition est décalée de 2 pixels vers le bas pour rendre la transition transparente. <br><br>  Deux trames plus tard, la <code>PPUADDR</code> écrite dans <code>0x23A0</code> .  Cela nous ramène à la table des noms en haut à gauche, et nous effectuons le rendu à partir de la 29e rangée de tuiles, c'est-à-dire en bas.  <strong>Le défilement exact en Y</strong> contient toujours 2. <br><br>  Pourquoi est-il nécessaire de <strong>définir Exact Scrolling in Y</strong> sur 2?  Pourquoi le jeu n'écrit-il pas simplement <code>0x0800</code> et <code>0x03A0</code> pour ne pas souffrir d'un décalage de deux pixels? <br><br>  Quatre tables de noms occupent la zone de 4 Ko dans l'espace d'adressage PPU, de <code>0x2000</code> à <code>0x2FFF</code> .  Chaque tuile de la table occupe un octet de mémoire vidéo (en fait, ce ne sont que des index dans une autre table), et l'ordre des tuiles et des tables de noms dans la mémoire vidéo est tel que <strong>Sélection d'une table de noms</strong> , <strong>Défilement grossier par Y</strong> et <strong>Défilement grossier par X</strong> constituent le décalage de la tuile à l'intérieur zones de mémoire avec tables de noms.  Autrement dit, en prenant les 12 bits inférieurs du registre PPU interne et en les ajoutant à <code>0x2000</code> , vous pouvez trouver l'adresse de la <code>0x2000</code> dans la mémoire vidéo.  Et ce n'est pas un hasard!  C'est exactement la façon dont le registre doit être traité: à la fois comme registre d'adresse et comme registre de défilement. <br><br>  Mais il y a un défaut. <br><br>  Lors du traitement en tant que registre d'adresse, les bits 12 et 13 sont considérés comme faisant partie de l'adresse.  Pendant le rendu, le PPU écrase constamment le registre avec l'adresse de la tuile rendue actuelle.  Étant donné que les tuiles sont situées dans les tables de noms et que les tables sont situées dans la zone de mémoire de <code>0x2000</code> à <code>0x2FFF</code> , PPU attribue des valeurs de cet intervalle au registre. <br><br>  Lorsque le jeu écrit dans <code>PPUADDR</code> au milieu de la trame, s'il n'écrit pas l'adresse de la tuile dans la table des noms, alors le PPU essaiera de lire <em>ailleurs</em> dans la mémoire vidéo.  Tous les octets qu'il comptera seront perçus comme des tuiles, ce qui est susceptible de conduire à des résultats indésirables.  Par conséquent, toutes les valeurs enregistrées au milieu de la trame dans <code>PPUADDR</code> doivent être comprises entre <code>0x2000</code> et <code>0x2FFF</code> .  En prenant chaque nombre dans cet intervalle et en tenant compte de ses composantes de défilement, la valeur de <strong>défilement exacte en Y</strong> doit toujours être égale à 2. <br><br>  Cette limitation signifie que nous ne pouvons pas modifier le <strong>défilement exact dans la</strong> direction <strong>Y</strong> au milieu du cadre, c'est-à-dire que lorsque vous utilisez cette astuce pour implémenter le défilement vertical de la séparation d'écran, nous sommes limités au défilement de 8 pixels à la fois et avons toujours un décalage vertical de deux pixels par rapport à la bordure de la tuile.  La légende de Zelda se déplace de 4 pixels par image lors du défilement horizontal, mais de 8 pixels par image lors du défilement vertical, et nous savons maintenant pourquoi. <br><br>  L'artefact est également visible lors du défilement entre les pièces vers le bas, mais dans ce cas, il se produit à la fin de l'animation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Lecture complémentaire </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le wiki NesDev</a> est une ressource inestimable pour en savoir plus sur le matériel NES.  En particulier, le sujet de cet article sont des pages sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">défilement PPU</a> <br>  et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">registres PPU</a> . </li><li>  Mon émulateur NES encore très inachevé est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li></ul><br><h2>  Remarques </h2><br>  Jusqu'à ce que je découvre le registre interne de PPU, mon émulateur montrait l'effet d'effacement lors des transitions verticales de l'écran The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  L’image-objet de Link s'est déplacée vers le bas de l’écran, comme il se doit, mais l’arrière-plan n’a pas défilé.  L'effacement a été provoqué par le fait que le jeu a progressivement mis à jour la table des noms afin qu'elle contienne les graphiques de la nouvelle salle, mais n'a pas mis à jour le défilement pour garder les mises à jour hors écran. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460383/">https://habr.com/ru/post/fr460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460367/index.html">Chaos Engineering: l'art de la destruction intentionnelle. Partie 1</a></li>
<li><a href="../fr460373/index.html">Under the Hood Turbo Pages: Architecture de la technologie de téléchargement rapide des pages Web</a></li>
<li><a href="../fr460375/index.html">Livre "Machine Learning for Business and Marketing"</a></li>
<li><a href="../fr460377/index.html">Utilisation de Liquibase pour gérer la structure de la base de données dans une application Spring Boot. Partie 1</a></li>
<li><a href="../fr460381/index.html">Qu'est-ce que l'assertivité et pourquoi est-elle nécessaire</a></li>
<li><a href="../fr460387/index.html">Guide du débutant SELinux</a></li>
<li><a href="../fr460393/index.html">Contexte: à quoi s'attendre de Fedora Silverblue</a></li>
<li><a href="../fr460395/index.html">Analytics en tant que fonctionnalité: le processus d'utilisation des données dans Plesk</a></li>
<li><a href="../fr460397/index.html">Démarrage rapide avec WebComponents</a></li>
<li><a href="../fr460399/index.html">Indicateur de chargement SVG sur Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>