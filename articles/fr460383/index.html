<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüöí üî± „Ä∞Ô∏è Les transitions d'√©cran dans Legend of Zelda utilisent les fonctionnalit√©s non document√©es de NES üï¥üèΩ üëâ üßùüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pour l'effet du d√©filement vertical dans la premi√®re partie de "The Legend of Zelda", des manipulations graphiques "mat√©rielles" NES sont utilis√©es, p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Les transitions d'√©cran dans Legend of Zelda utilisent les fonctionnalit√©s non document√©es de NES</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460383/">  Pour l'effet du d√©filement vertical dans la premi√®re partie de "The Legend of Zelda", des manipulations graphiques "mat√©rielles" NES sont utilis√©es, probablement pas fournies par les d√©veloppeurs de la console. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/631/466/3d0/6314663d04d4e3ed0d86c7e6d9b8611a.png" width="512"></div><br>  Je n'ai pas acc√®s √† la documentation officielle de l'unit√© de traitement d'image (PPU - puce graphique) de la console NES, donc mes d√©clarations sur le "comportement ind√©fini" sont plus susceptibles d'√™tre des suppositions.  J'ai pris les sp√©cifications du mat√©riel graphique du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki NesDev</a> .  PPU est contr√¥l√© en √©crivant dans des registres avec mappage de m√©moire.  Si vous utilisez ces registres de la mani√®re qui (semble-t-il) a √©t√© con√ßue par les concepteurs, il serait impossible d'obtenir cet effet: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a5/b0e/51c/8a5b0e51c195fb1e9ba9ca282f54e61a.gif" width="512"></div><br>  Lorsque vous faites d√©filer l'√©cran verticalement, tout l'√©cran doit d√©filer en m√™me temps.  Le GIF pr√©c√©dent montre un exemple de d√©filement vertical partiel.  Une partie de l'√©cran reste immobile (√©l√©ments d'interface) et l'autre partie (zone de jeu) d√©file verticalement.  Le d√©filement vertical partiel est impossible √† impl√©menter avec le travail "standard" avec PPU. <br><br>  En revanche, <em>le</em> d√©filement <em>horizontal</em> partiel est enti√®rement d√©fini et possible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae7/c29/539/ae7c295393f6706e17e788e0a1cc39e7.gif" width="512"></div><br>  L'√©criture dans un registre PPU distinct au moment o√π l'image est trac√©e peut conduire √† des artefacts graphiques.  La l√©gende de Zelda provoque intentionnellement un artefact qui se manifeste par un d√©filement vertical partiel.  Dans cet article, je vais parler un peu du mat√©riel graphique NES et expliquer comment fonctionne l'astuce de d√©filement vertical. <br><a name="habracut"></a><br><h2>  Types de graphiques </h2><br>  La console NES poss√®de deux types de graphiques: <br><br><ul><li>  Les sprites sont des tuiles qui peuvent √™tre plac√©es √† des endroits arbitraires sur l'√©cran et d√©plac√©es ind√©pendamment les unes des autres. </li><li>  Arri√®re-plan - une grille de tuiles qui peut √™tre d√©fil√©e en douceur comme une seule image. </li></ul><br>  Pour d√©montrer la diff√©rence entre les deux, je vais montrer une sc√®ne compos√©e de sprites et de fond: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f75/f9b/138/f75f9b138db2e818cbdb9b2fb1e7b27b.gif" width="512"></div><br>  Et voici la m√™me sc√®ne dans laquelle seuls les sprites sont visibles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e8/26d/817/5e826d817b637fc450046aee1473abaf.gif" width="512"></div><br>  Et voici une sc√®ne dans laquelle seul l'arri√®re-plan est visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d81/b9c/bd7/d81b9cbd7bb5101f663d4decc5ebaef7.gif" width="512"></div><br><h2>  D√©filement </h2><br>  Le processeur d'image (NES Picture Processor) prend en charge le d√©filement des images d'arri√®re-plan.  Dans la m√©moire graphique, le graphique d'arri√®re-plan est stock√© sous la forme d'une grille bidimensionnelle de tuiles couvrant une zone deux fois la largeur et la hauteur de l'√©cran. <br><br>  Une ¬´fen√™tre¬ª est affich√©e √† l'√©cran dans cette grille de la taille d'un √©cran, et la position de cette fen√™tre peut √™tre contr√¥l√©e avec pr√©cision.  En d√©pla√ßant progressivement la fen√™tre visible le long de la grille, un effet de d√©filement fluide est cr√©√©. <br><br>  Le signal vid√©o de sortie NES a une taille de 256x240 pixels.  La grille de tuiles √† l'int√©rieur de la m√©moire est repr√©sent√©e comme une zone de 512x480 pixels et est divis√©e en quatre rectangles de taille d'√©cran appel√©s ¬´tables de noms¬ª.  Les jeux peuvent configurer l'unit√© de traitement d'image (PPU) en indiquant la position de la fen√™tre visible en s√©lectionnant les coordonn√©es des pixels dans la grille des tables de noms. <br><br>  Lorsque vous s√©lectionnez les coordonn√©es (0, 0), la totalit√© du tableau de noms sup√©rieur gauche s'affiche √† l'√©cran: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d3/b5d/47f/5d3b5d47f8efdfcac271a2a7e0222e57.png"></div><br>  Passant √† (125, 181), nous verrons un peu de chaque table de noms: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/78f/189/91278f1891416d9f15a69238e64d1422.png"></div><br>  La fen√™tre visible se r√©duit √† l'arri√®re de la grille de tuiles en m√©moire.  Passant √† (342, 290), nous pla√ßons le coin sup√©rieur gauche de l'√©cran visible √† l'int√©rieur du tableau des noms en bas √† droite, et gr√¢ce au pliage, des parties de chacun des tableaux des noms seront visibles: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e6/394/c93/6e6394c9325985807a97765ebe015bcf.png"></div><br><h3>  Pas assez de m√©moire! </h3><br>  Chaque table de noms a une taille de 1 Ko, mais NES alloue seulement 2 Ko de sa m√©moire vid√©o √† ces tables, de sorte que seules deux tables de noms peuvent tenir en m√©moire √† la fois. <br><br>  Comment peut-il avoir quatre tables de noms? <br><br><h4>  Mise en miroir des tables de noms </h4><br>  La m√©moire vid√©o est connect√©e au PPU de telle mani√®re que lorsque le PPU restitue une tuile de l'une des quatre tables de noms apparentes, en fait l'une des deux vraies tables est s√©lectionn√©e, et la lecture vient de l√†.  En substance, cela signifie que les quatre tables de noms visibles sont en fait constitu√©es de deux paires de tables identiques. <br><br>  Cette image montre un instantan√© du contenu des quatre tableaux.  Le haut √† gauche et le haut √† droite sont les m√™mes que les deux inf√©rieurs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/5b8/9b2/0515b89b2afcf122ce8df6e97e97a0a8.png" width="1024"></div><br>  Pourquoi alors ne pas garder deux tables de noms? <br><br>  Heureusement, la liaison exacte entre les tables apparente et r√©elle peut √™tre configur√©e au moment de l'ex√©cution.  Si le jeu souhaite effectuer un d√©filement horizontal, il ajuste l'√©quipement graphique de sorte que les tableaux sup√©rieur gauche et sup√©rieur droit soient diff√©rents, et ils peuvent √™tre d√©fil√©s sans duplication notable.  Dans cette configuration, les tableaux sup√©rieur gauche et inf√©rieur gauche feront r√©f√©rence au m√™me tableau de nom r√©el;  de m√™me pour les deux tableaux de droite.  Cette configuration est appel√©e mise en miroir verticale. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e3/d85/49d/1e3d8549d5427f7f7271595dc5c6f49b.png"></div><br>  Il existe √©galement une autre configuration possible - ¬´Horizontal Mirroring¬ª, que les jeux utilisent pour le d√©filement vertical. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/650/6a2/528/6506a2528cba5d758301f72c80f48e8b.png"></div><br>  En r√®gle g√©n√©rale, les jeux ne d√©filent pas en diagonale, car cela cr√©e des artefacts autour des bords de l'√©cran en raison de la mise en miroir des tables de noms. <br><br><h3>  Cartouches </h3><br>  La cartouche de chaque jeu poss√®de un mat√©riel qui vous permet de configurer la mise en miroir des tables. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a44/8ed/3dc/a448ed3dc3849ac558d39ba0bfc5309d.jpg" width="50%"></div><br>  Certains jeux n'ont pas du tout besoin de basculer la mise en miroir, de sorte que la mise en miroir horizontale ou verticale est cod√©e en dur dans leurs cartouches.  D'autres jeux basculent dynamiquement entre ces deux modes, donc la mise en miroir dans leurs cartouches est configur√©e par programme.  La l√©gende de Zelda appartient √† la deuxi√®me cat√©gorie.  Enfin, les cartouches de certains jeux vraiment complexes ont une m√©moire vid√©o suppl√©mentaire, c'est-√†-dire qu'elles n'ont pas du tout besoin de mise en miroir: elles peuvent simultan√©ment faire d√©filer verticalement et horizontalement sans artefacts de duplication visibles. <br><br><h3>  Exemple r√©el </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/d58/80e/d0ad5880e16ce58d53ee2eb922c4da04.gif" width="512"></div><br>  <i>Un exemple de d√©filement vertical qui s'affiche √† l'√©cran.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bb/ff0/b01/7bbff0b019dadb96e423ebc744aeb12c.gif" width="1024"></div><br>  <i>Cela montre un enregistrement des tables de noms avec mise en miroir horizontale.</i>  <i>La fen√™tre actuellement visible est mise en surbrillance.</i> <br><br>  N'oubliez pas que le d√©filement le plus vertical n'est pas inhabituel - ce qui est inhabituel est le d√©filement vertical avec <em>√©cran partag√©</em> . <br><br><h2>  √âcran partag√© </h2><br>  Chaque image du signal vid√©o g√©n√©r√© par NES est rendue de haut en bas, une rang√©e de pixels √† la fois.  Dans chaque ligne, les pixels sont dessin√©s un √† la fois, de gauche √† droite.  √Ä mi-chemin lors du rendu de l'image, le jeu peut reconfigurer le PPU, ce qui affecte l'affichage des pixels qui n'ont pas encore √©t√© rendus.  L'un des changements les plus courants au milieu du cadre est la mise √† jour de la position de d√©filement horizontal. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/873/536/98f/87353698fa1a10a55f37d5f56ebfaefd.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/502/8e9/c645028e950b7e202815d7c4ad560fac.gif" width="1024"></div><br>  Lors du d√©filement horizontal entre les pi√®ces, The Legend of Zelda commence toujours √† partir de la position de d√©filement (0, 0) et affiche les √©l√©ments d'interface en haut de l'√©cran.  Apr√®s avoir trac√© la derni√®re ligne de pixels d'interface sur l'√©cran, le d√©filement horizontal change d'une valeur qui augmente avec chaque image, de sorte que la cam√©ra se d√©place en douceur. <br><br>  L'animation de l'affichage des tables de noms montre comment le jeu passe de la mise en miroir horizontale √† la mise en miroir verticale avant le d√©filement, puis √† nouveau √† l'horizontale une fois la transition termin√©e.  De plus, pendant que le d√©filement se poursuit, les tables de noms en haut √† gauche (et en bas √† gauche) sont mises √† jour et une copie de la pi√®ce dans laquelle le joueur entre est enregistr√©e.  Une fois le d√©filement termin√©, le jeu cesse de diviser l'√©cran et est √† nouveau enti√®rement rendu √† partir du tableau sup√©rieur gauche. <br><br><h3>  Mesure de rendu </h3><br>  Pour diviser l'√©cran dans la position souhait√©e, le jeu doit en quelque sorte savoir quelle partie de l'image actuelle a √©t√© dessin√©e.  Les cha√Ænes de pixels sont rendues √† une fr√©quence connue, de sorte que le nombre de cha√Ænes de pixels rendues peut √™tre d√©termin√© en comptant le nombre de cycles de processeur qui se sont √©coul√©s depuis le d√©but de la trame. <br><br>  Il existe une autre technique plus pr√©cise appel√©e Sprite Zero Hit. <br><br>  NES peut rendre jusqu'√† 64 images-objets √† la fois.  Le premier sprite dans la m√©moire vid√©o est appel√© Sprite Zero (z√©ro sprite).  Dans chaque image, d√®s qu'un pixel opaque d'un sprite z√©ro est superpos√© √† un pixel d'arri√®re-plan opaque, l'√©v√©nement Sprite Zero Hit se produit.  Il d√©finit un bit dans l'un des registres PPU avec un mappage de m√©moire, qui peut √™tre v√©rifi√© par le processeur. <br><br>  Pour utiliser Sprite Zero Hit pour diviser l'√©cran, les jeux placent le sprite z√©ro en position verticale pr√®s de la bordure divis√©e, et pendant le rendu, ils v√©rifient constamment si l'√©v√©nement Sprite Zero Hit s'est produit.  Si c'est le cas, le jeu passe du d√©filement horizontal pour impl√©menter la s√©paration. <br><br>  La transition horizontale entre les pi√®ces avec et sans fond est illustr√©e ci-dessous. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71b/27a/076/71b27a0768844603020981c26b3f5124.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c4/4c1/95d/2c44c195dfac0b6c2d6b10aaf11674aa.gif" width="512"></div><br><br>  Le cercle brun qui appara√Æt au d√©but de la transition et dispara√Æt √† sa fin est un sprite z√©ro.  Nous allons examiner de plus pr√®s l'interface avec et sans arri√®re-plan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39b/373/83d/39b37383d425937e8e5cdb598656bac5.png" width="322"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7d/6f9/ebe/c7d6f9ebeb7c7e066e6d349eb8c57914.png" width="322"></div><br>  Un sprite z√©ro est un sprite de bombe blanchi qui correspond parfaitement au sprite de bombe ordinaire de l'interface de jeu.  Le sprite z√©ro est configur√© pour appara√Ætre sous l'arri√®re-plan, mais comme les pixels noirs de l'interface sont consid√©r√©s comme transparents, la bombe z√©ro sprite serait visible si elle n'avait pas √©t√© strat√©giquement cach√©e derri√®re la bombe de l'interface. <br><br>  Notez que Sprite Zero Hit appara√Æt quelques lignes de pixels avant la ligne inf√©rieure de l'interface.  Il se produit au pixel sup√©rieur du fusible de la bombe, √† 16 pixels du bas de l'interface.  Lorsque Sprite Zero Hit se produit, le jeu commence √† compter les cycles du processeur et, apr√®s avoir termin√© le nombre de cycles requis, d√©finit le d√©filement horizontal. <br><br><h2>  Suppression de faisceau </h2><br>  La plupart du temps, la console PPU dessine des pixels √† l'√©cran.  Il y a un court temps d'arr√™t entre les images pendant lequel le rendu n'est pas effectu√©.  Ce ph√©nom√®ne est appel√© blanking (Vertical Blank ou vblank).  Certains types de changements de configuration PPU ne peuvent √™tre effectu√©s que pendant vblank. <br><br><h2>  Registre d√©filant </h2><br>  Les jeux changent la position du d√©filement en √©crivant dans le registre PPU appel√© <code>PPUSCROLL</code> , qui correspond √† l'adresse m√©moire <code>0x2005</code> .  La premi√®re op√©ration d'√©criture dans <code>PPUSCROLL</code> d√©finit le composant X de la position de d√©filement et la deuxi√®me op√©ration d√©finit le composant Y. De m√™me, un enregistrement alternatif est effectu√© plus loin. <br><br>  Ce qui suit montre toutes les op√©rations d'√©criture non nulles dans <code>PPUSCROLL</code> pendant cette lecture (au ralenti) 16 images de l'√©cran avec l'intrigue du jeu.  La composante de position de d√©filement Y est incr√©ment√©e toutes les deux images.  Toutes les op√©rations d'√©criture dans <code>PPUSCROLL</code> dans cet exemple sont effectu√©es pendant vblank, ce qui entra√Æne le d√©filement de l'arri√®re-plan entier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cad/0d1/003/cad0d1003d55488a17d988e6607739f2.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1bc/ffb/c09/1bcffbc09db9bfe792ba85981acbe4b3.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kg/rz/fi/kgrzfigaydwrvo3qqth5bcmkecq.png"></div><br><h3>  Scrolling Screen Split </h3><br>  Les op√©rations d' <code>PPUSCROLL</code> dans <code>PPUSCROLL</code> pendant vblank prennent effet au d√©but de la trame dessin√©e imm√©diatement apr√®s vblank.  Si la position de d√©filement change pendant le rendu du cadre (c'est-√†-dire pas pendant vblank), alors ce changement prend effet lorsque le dessin atteint la rang√©e de pixels suivante.  Le d√©filement horizontal partiel est impl√©ment√© en √©crivant dans <code>PPUSCROLL</code> pendant que le PPU dessine la derni√®re ligne de pixels avant le d√©filement. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddf/e12/b49/ddfe12b49ce180cb921243f32e77351a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4be/38c/0bb/4be38c0bb335a414ce99a2c8d2145009.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cu/uu/1t/cuuu1twsw4wbeynzisaewszsqo8.png"></div><br>  Lors de la mise √† jour de la position de d√©filement au milieu du cadre, seule la position X de la position de d√©filement est appliqu√©e.  C'est-√†-dire que le composant de position de d√©filement Y est ignor√©.  Ainsi, si le jeu souhaite diviser l'√©cran et modifie la position de d√©filement d'une partie du cadre, il ne peut que d√©filer horizontalement. <br><br>  Et pourtant: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br>  Croyez-le ou non, la valeur du registre <code>PPUSCROLL</code> pas chang√© pendant cette transition. <br><br>  Vous pouvez voir un artefact graphique d'un pixel de haut sous l'interface.  Il s'agit d'un bug de mon √©mulateur provoqu√© par le manque de synchronisation des cycles d'horloge du processeur avec le rendu pixel par pixel. <br><br><h3>  Intervention dans d'autres registres </h3><br>  Le second registre, appel√© <code>PPUADDR</code> , mapp√© √† l'adresse m√©moire <code>0x2006</code> , est utilis√© pour d√©finir l'adresse m√©moire vid√©o actuelle.  Lorsqu'un jeu, par exemple, souhaite modifier l'une des tuiles de la table de noms, il √©crit d'abord l'adresse de m√©moire vid√©o de la <code>PPUADDR</code> dans <code>PPUADDR</code> , puis √©crit la nouvelle valeur de la <code>PPUDATA</code> dans <code>PPUDATA</code> - il s'agit du troisi√®me registre mapp√© √† l'adresse <code>0x2007</code> . <br><br>  L'√©criture dans <code>PPUADDR</code> pas pendant vblank (c'est-√†-dire lors du rendu d'une image) peut provoquer des artefacts graphiques.  Cela est d√ª au fait que la cha√Æne PPU, qui est affect√©e par l'√©criture dans <code>PPUADDR</code> , est √©galement directement contr√¥l√©e par le p√©riph√©rique PPU dans le processus d'obtention de tuiles de la m√©moire vid√©o pour les dessiner.  √âtant donn√© que le processus de rendu √† l'√©cran est effectu√© de haut en bas et de gauche √† droite dans la ligne, le PPU attribue essentiellement √† <code>PPUADDR</code> valeur de l'adresse de la <code>PPUADDR</code> actuelle.  Lorsque le rendu se d√©place d'une mosa√Øque √† une autre, <code>PPUADDR</code> est incr√©ment√© de la valeur actuelle. <br><br>  Ainsi, l'√©criture dans <code>PPUADDR</code> au milieu de la trame peut changer les tuiles re√ßues par la PPU de la m√©moire pendant la dur√©e de la trame actuelle. <br><br>  <code>PPUADDR</code> op√©rations d'√©criture dans <code>PPUADDR</code> pendant le saut vertical.  √âtant donn√© que la table de noms est √©galement mise √† jour pendant la transition, la sortie de <em>toutes les</em> op√©rations d'√©criture vers <code>PPUADDR</code> sera trop √©tendue.  Avec une transition horizontale, le d√©filement est d√©fini pendant le rendu d'une ligne de pixels 63, par cons√©quent, nous ne consid√©rerons les op√©rations d'√©criture dans <code>PPUADDR</code> que pendant cette ligne. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/93e/4b7/1a093e4b76c8382f08d33b4202391094.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/760/184/2b0/7601842b02f37dc10abd97b93e0a9ec2.gif" width="1024"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3b/w0/iw/3bw0iwoau9zl8frbuh-mgh78-ia.png"></div><br>  Le motif est clairement visible.  Toutes les deux trames, l'adresse enregistr√©e dans la ligne de pixels 63 est r√©duite de 32 (0x20).  Mais comment cela conduit-il √† une mise √† jour de la position de d√©filement r√©elle? <br><br><h3>  Registre de d√©filement <i>r√©el</i> </h3><br>  √Ä l'int√©rieur du PPU, il y a un registre de 15 bits non mapp√© au CPU.  Il est utilis√© √† la fois comme adresse actuelle pour acc√©der √† la m√©moire vid√©o et comme configuration de d√©filement en arri√®re-plan. <br><br>  Lorsque vous travaillez avec cette valeur comme adresse, le bit 14 est ignor√© et les bits 0-13 sont trait√©s comme une adresse dans la m√©moire vid√©o. <br><br>  Lorsque vous travaillez avec cette valeur comme configuration de d√©filement, ses diff√©rentes parties ont des significations diff√©rentes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ra/ot/-q/raot-qzjvlglrxraw3kyrpskouk.png"></div><br>  <strong>La s√©lection d'une table de noms</strong> est une valeur comprise entre 0 et 3 qui d√©termine la table de noms actuelle √† partir de laquelle le dessin est cr√©√©. <br><br>  <strong>Le d√©filement grossier en X</strong> et le <strong>d√©filement grossier en Y</strong> d√©terminent les coordonn√©es de la tuile √† l'int√©rieur du tableau de noms s√©lectionn√©.  Il s'agit de la tuile actuelle √† dessiner. <br><br>  <strong>Le d√©filement exact le long de Y</strong> contient une valeur de 0 √† 7, qui d√©termine le d√©calage vertical actuel de la ligne de pixels √† l'int√©rieur de la mosa√Øque actuelle.  Les tuiles sont des carr√©s avec un c√¥t√© de 8 pixels. <br><br>  <strong>Le d√©filement exact sur X</strong> est absent de ce registre.  Il existe un registre s√©par√© contenant uniquement le d√©calage horizontal du pixel actuel, mais il n'est pas important d'expliquer comment le d√©filement vertical est effectu√© dans The Legend of Zelda. <br><br>  Qu'advient-il de ce registre lorsqu'un jeu √©crit dans <code>PPUADDR</code> ?  Voici les trois premi√®res op√©rations d'√©criture de la d√©mo ci-dessus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nm/km/2b/nmkm2bpk5osxvd1ohc4kmne7ck4.png"></div><br>  En divisant les entr√©es de l'adresse en composants de d√©filement, vous pouvez clairement comprendre ce qui se passe ici.  Toutes les deux images, la valeur du <strong>d√©filement brut en Y</strong> diminue, ce qui entra√Æne un d√©filement vertical d'une tuile ou de 8 pixels. <br><br>  Tout au long de chaque trame, le d√©calage de d√©filement initial est de 0,0, apr√®s quoi l'enregistrement sur la ligne de pixels 63 est effectu√© √† l'adresse.  Cela signifie que les 63 premi√®res lignes de pixels sont dessin√©es √† partir du haut de la table de noms s√©lectionn√©e contenant l'arri√®re-plan de l'interface.  Cependant, la 64e ligne de pixels est rendue davantage avec un d√©filement vertical appliqu√© √† partir de cette adresse.  √âtant donn√© que le d√©filement vertical diminue toutes les deux images, il donne la sensation de d√©filement vertical d'une partie de l'√©cran. <br><br><h3>  Faites d√©filer vers le bas pour faire d√©filer vers le haut </h3><br>  La l√©gende de Zelda ne peut pas compl√®tement cacher cette astuce aux joueurs.  Il cr√©e un artefact visible sur les transitions verticales de l'√©cran, qui sont visibles si vous regardez de pr√®s.  Lorsque vous vous d√©placez entre les pi√®ces, la premi√®re image de l'animation de d√©filement d√©file vers le bas.  Voici l'animation au ralenti. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af8/a8c/79d/af8a8c79d1b4c50280c31fbf1540852a.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/e37/9a6/a52e379a6e5d6dd444fe115d484bb846.gif" width="1024"></div><br>  Dans le tableau des noms, vous pouvez voir ce qui se passe r√©ellement.  Bien qu'il puisse sembler aux joueurs que la zone visible d√©filera vers le haut en douceur, la transition de d√©filement commence en d√©pla√ßant la zone visible du tableau de noms sup√©rieur gauche vers le tableau inf√©rieur gauche, qui contient une copie de l'arri√®re-plan de la pi√®ce.  Cela est n√©cessaire car l'interface en haut de l'√©cran fait √©galement partie de la table des noms, et si la zone visible d√©filait de sa position d'origine, elle passerait par l'interface. <br><br>  Le d√©filement vertical est impl√©ment√© en √©crivant dans le registre <code>PPUADDR</code> au milieu de la trame.  La toute premi√®re valeur √† √©crire est <code>0x2800</code> .  Deux images plus tard, <code>0x23A0</code> enregistr√©, puis la valeur commence √† diminuer de 32 toutes les deux images. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pk/la/gh/pklagh4idqhd3jg_mfkojhfv0lq.png"></div><br>  L'√©criture de la valeur <code>0x2800</code> dans le registre <code>0x2800</code> <code>PPUADDR</code> <strong>table de</strong> <code>PPUADDR</code> sur 2, ce qui rend la table de noms en bas √† gauche.  √âtant donn√© que les deux valeurs de d√©filement sont 0, il commencera √† partir de la tuile sup√©rieure gauche de cette table de noms.  Cependant, le <strong>d√©filement exact dans Y</strong> est 2, il y a donc un d√©calage vertical de deux pixels par rapport au haut du tableau de noms en bas √† gauche.  C'est pourquoi dans la toute premi√®re image de la transition, on voit une barre noire de 2 pixels de haut en bas de l'√©cran.  La valeur de d√©filement initiale de l'animation de transition est d√©cal√©e de 2 pixels vers le bas pour rendre la transition transparente. <br><br>  Deux trames plus tard, la <code>PPUADDR</code> √©crite dans <code>0x23A0</code> .  Cela nous ram√®ne √† la table des noms en haut √† gauche, et nous effectuons le rendu √† partir de la 29e rang√©e de tuiles, c'est-√†-dire en bas.  <strong>Le d√©filement exact en Y</strong> contient toujours 2. <br><br>  Pourquoi est-il n√©cessaire de <strong>d√©finir Exact Scrolling in Y</strong> sur 2?  Pourquoi le jeu n'√©crit-il pas simplement <code>0x0800</code> et <code>0x03A0</code> pour ne pas souffrir d'un d√©calage de deux pixels? <br><br>  Quatre tables de noms occupent la zone de 4 Ko dans l'espace d'adressage PPU, de <code>0x2000</code> √† <code>0x2FFF</code> .  Chaque tuile de la table occupe un octet de m√©moire vid√©o (en fait, ce ne sont que des index dans une autre table), et l'ordre des tuiles et des tables de noms dans la m√©moire vid√©o est tel que <strong>S√©lection d'une table de noms</strong> , <strong>D√©filement grossier par Y</strong> et <strong>D√©filement grossier par X</strong> constituent le d√©calage de la tuile √† l'int√©rieur zones de m√©moire avec tables de noms.  Autrement dit, en prenant les 12 bits inf√©rieurs du registre PPU interne et en les ajoutant √† <code>0x2000</code> , vous pouvez trouver l'adresse de la <code>0x2000</code> dans la m√©moire vid√©o.  Et ce n'est pas un hasard!  C'est exactement la fa√ßon dont le registre doit √™tre trait√©: √† la fois comme registre d'adresse et comme registre de d√©filement. <br><br>  Mais il y a un d√©faut. <br><br>  Lors du traitement en tant que registre d'adresse, les bits 12 et 13 sont consid√©r√©s comme faisant partie de l'adresse.  Pendant le rendu, le PPU √©crase constamment le registre avec l'adresse de la tuile rendue actuelle.  √âtant donn√© que les tuiles sont situ√©es dans les tables de noms et que les tables sont situ√©es dans la zone de m√©moire de <code>0x2000</code> √† <code>0x2FFF</code> , PPU attribue des valeurs de cet intervalle au registre. <br><br>  Lorsque le jeu √©crit dans <code>PPUADDR</code> au milieu de la trame, s'il n'√©crit pas l'adresse de la tuile dans la table des noms, alors le PPU essaiera de lire <em>ailleurs</em> dans la m√©moire vid√©o.  Tous les octets qu'il comptera seront per√ßus comme des tuiles, ce qui est susceptible de conduire √† des r√©sultats ind√©sirables.  Par cons√©quent, toutes les valeurs enregistr√©es au milieu de la trame dans <code>PPUADDR</code> doivent √™tre comprises entre <code>0x2000</code> et <code>0x2FFF</code> .  En prenant chaque nombre dans cet intervalle et en tenant compte de ses composantes de d√©filement, la valeur de <strong>d√©filement exacte en Y</strong> doit toujours √™tre √©gale √† 2. <br><br>  Cette limitation signifie que nous ne pouvons pas modifier le <strong>d√©filement exact dans la</strong> direction <strong>Y</strong> au milieu du cadre, c'est-√†-dire que lorsque vous utilisez cette astuce pour impl√©menter le d√©filement vertical de la s√©paration d'√©cran, nous sommes limit√©s au d√©filement de 8 pixels √† la fois et avons toujours un d√©calage vertical de deux pixels par rapport √† la bordure de la tuile.  La l√©gende de Zelda se d√©place de 4 pixels par image lors du d√©filement horizontal, mais de 8 pixels par image lors du d√©filement vertical, et nous savons maintenant pourquoi. <br><br>  L'artefact est √©galement visible lors du d√©filement entre les pi√®ces vers le bas, mais dans ce cas, il se produit √† la fin de l'animation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/77d/13b/89a/77d13b89abce5200d348de0379f409e5.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/468/eb2/9c2/468eb29c2eb3a97d7e4dd2a62682f1b9.gif" width="1024"></div><br><h2>  Lecture compl√©mentaire </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le wiki NesDev</a> est une ressource inestimable pour en savoir plus sur le mat√©riel NES.  En particulier, le sujet de cet article sont des pages sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d√©filement PPU</a> <br>  et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">registres PPU</a> . </li><li>  Mon √©mulateur NES encore tr√®s inachev√© est disponible <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . </li></ul><br><h2>  Remarques </h2><br>  Jusqu'√† ce que je d√©couvre le registre interne de PPU, mon √©mulateur montrait l'effet d'effacement lors des transitions verticales de l'√©cran The Legend of Zelda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/932/2a0/a5a/9322a0a5a1522a0ae0f6fbd21080286e.gif" width="512"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1a/078/755/d1a0787558999dd61ec2ba9dc9ba9026.gif" width="1024"></div><br>  L‚Äôimage-objet de Link s'est d√©plac√©e vers le bas de l‚Äô√©cran, comme il se doit, mais l‚Äôarri√®re-plan n‚Äôa pas d√©fil√©.  L'effacement a √©t√© provoqu√© par le fait que le jeu a progressivement mis √† jour la table des noms afin qu'elle contienne les graphiques de la nouvelle salle, mais n'a pas mis √† jour le d√©filement pour garder les mises √† jour hors √©cran. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460383/">https://habr.com/ru/post/fr460383/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460367/index.html">Chaos Engineering: l'art de la destruction intentionnelle. Partie 1</a></li>
<li><a href="../fr460373/index.html">Under the Hood Turbo Pages: Architecture de la technologie de t√©l√©chargement rapide des pages Web</a></li>
<li><a href="../fr460375/index.html">Livre "Machine Learning for Business and Marketing"</a></li>
<li><a href="../fr460377/index.html">Utilisation de Liquibase pour g√©rer la structure de la base de donn√©es dans une application Spring Boot. Partie 1</a></li>
<li><a href="../fr460381/index.html">Qu'est-ce que l'assertivit√© et pourquoi est-elle n√©cessaire</a></li>
<li><a href="../fr460387/index.html">Guide du d√©butant SELinux</a></li>
<li><a href="../fr460393/index.html">Contexte: √† quoi s'attendre de Fedora Silverblue</a></li>
<li><a href="../fr460395/index.html">Analytics en tant que fonctionnalit√©: le processus d'utilisation des donn√©es dans Plesk</a></li>
<li><a href="../fr460397/index.html">D√©marrage rapide avec WebComponents</a></li>
<li><a href="../fr460399/index.html">Indicateur de chargement SVG sur Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>