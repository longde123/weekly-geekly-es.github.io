<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📳 🛬 👩‍❤️‍👩 Deteksi kerentanan dalam teori dan praktik, atau mengapa tidak ada penganalisa statis yang ideal 🕙 🏙️ 👩🏻‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, pengembangan perangkat lunak berkualitas tinggi sulit dibayangkan tanpa menggunakan metode analisis kode statis . Analisis statis kode progr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deteksi kerentanan dalam teori dan praktik, atau mengapa tidak ada penganalisa statis yang ideal</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/solarsecurity/blog/420337/"><img src="https://habrastorage.org/webt/4o/sp/ej/4ospejeehs7v_tobj7glemsmj_a.png"><br><br>  Saat ini, pengembangan perangkat lunak berkualitas tinggi sulit dibayangkan tanpa menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">metode analisis kode statis</a> .  Analisis statis kode program dapat dibangun ke dalam lingkungan pengembangan (dengan metode standar atau menggunakan plug-in), dapat dilakukan oleh perangkat lunak khusus sebelum kode dimasukkan ke dalam operasi komersial, atau "secara manual" oleh pakar reguler atau eksternal. <br><a name="habracut"></a><br>  Sering diperdebatkan bahwa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis kode dinamis</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">uji penetrasi</a> dapat menggantikan analisis statis, karena metode verifikasi ini akan mengungkapkan masalah nyata dan tidak akan ada kesalahan positif.  Namun, ini adalah poin yang diperdebatkan, karena analisis dinamis, tidak seperti analisis statis, tidak memeriksa semua kode, tetapi hanya memeriksa resistensi perangkat lunak terhadap serangkaian serangan yang meniru tindakan penyerang.  Penyerang mungkin lebih inventif daripada verifier, terlepas dari siapa yang melakukan verifikasi: seseorang atau mesin. <br><br>  Analisis dinamis akan lengkap hanya jika dilakukan pada cakupan uji penuh, yang, ketika diterapkan pada aplikasi nyata, adalah tugas yang sulit.  Bukti kelengkapan cakupan tes merupakan masalah yang secara algoritmik tidak dapat diselesaikan. <br><br>  Analisis statis wajib terhadap kode program adalah salah satu langkah yang diperlukan ketika menugaskan perangkat lunak dengan peningkatan persyaratan untuk keamanan informasi. <br><br>  Saat ini, ada banyak penganalisa kode statis yang berbeda di pasaran, dan semakin banyak yang baru terus muncul.  Dalam praktiknya, ada beberapa kasus ketika beberapa analisis statis digunakan bersama untuk meningkatkan kualitas verifikasi, karena analisis yang berbeda mencari cacat yang berbeda. <br><br>  Mengapa tidak ada penganalisa statis universal yang akan sepenuhnya memeriksa kode apa pun dan menemukan semua cacat di dalamnya tanpa kesalahan positif dan pada saat yang sama bekerja dengan cepat dan tidak memerlukan banyak sumber daya (waktu dan memori CPU)? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hv/sq/zt/hvsqztaqcgmhuw4x8l8-9xawgba.png"></div><br><br><h3>  Sedikit tentang arsitektur analisa statis <br></h3><br>  Jawaban atas pertanyaan ini terletak pada arsitektur alat analisis statis.  Hampir semua analisa statis dibangun berdasarkan prinsip kompiler, yaitu, dalam pekerjaan mereka terdapat tahapan konversi kode sumber - sama seperti yang dilakukan oleh kompiler. <br><br>  Semuanya dimulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis leksikal</a> , yang menerima teks program dalam bahasa tingkat tinggi sebagai input, dan aliran token ke output.  Selanjutnya, aliran token yang diterima ditransmisikan ke input <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ke parser</a> , yang mem-parsing konstruksi bahasa dan meneruskan hasil penguraian ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penganalisis semantik</a> , yang, sebagai akibat dari pekerjaannya, bersiap untuk membangun representasi internal.  Representasi internal ini adalah fitur dari setiap analisa statis.  Efisiensi penganalisis tergantung pada seberapa sukses itu. <br><br><img src="https://habrastorage.org/webt/gx/by/x1/gxbyx1fcaoktxglgx8g5wwmbbr8.jpeg"><br><br>  Banyak produsen penganalisa statis mengklaim menggunakan representasi internal universal untuk semua bahasa pemrograman yang didukung oleh penganalisa.  Dengan demikian, mereka dapat menganalisis kode program yang dikembangkan dalam beberapa bahasa secara keseluruhan, dan bukan sebagai komponen yang terpisah.  Suatu "pendekatan holistik" untuk analisis memungkinkan menghindari penghilangan cacat yang muncul pada antarmuka antara komponen individu dari produk perangkat lunak. <br><br>  Secara teori, ini benar, tetapi dalam praktiknya, representasi internal universal untuk semua bahasa pemrograman sulit dan tidak efisien.  Setiap bahasa pemrograman adalah khusus.  Tampilan internal biasanya pohon yang simpulnya menyimpan atribut.  Dengan melintasi pohon seperti itu, penganalisa mengumpulkan dan mengubah informasi.  Oleh karena itu, setiap simpul pohon harus berisi sekumpulan atribut yang seragam.  Karena setiap bahasa adalah unik, keseragaman atribut hanya dapat didukung oleh redundansi komponen.  Bahasa pemrograman yang lebih heterogen, komponen yang lebih heterogen dalam karakteristik setiap titik, dan oleh karena itu, representasi internal tidak efisien dari memori.  Sejumlah besar karakteristik heterogen juga mempengaruhi kerumitan pejalan kaki pohon, yang berarti bahwa hal itu mengarah pada inefisiensi dalam kinerja. <br><br><h3>  Konversi Optimasi untuk Analisis Statis <br></h3><br>  Agar penganalisa statis dapat bekerja secara efisien dalam memori dan waktu, Anda harus memiliki representasi internal universal yang ringkas, dan ini dapat dicapai dengan fakta bahwa representasi internal dibagi menjadi beberapa pohon, yang masing-masing dirancang untuk bahasa pemrograman terkait. <br><br>  Pekerjaan optimisasi tidak terbatas pada pembagian representasi internal ke dalam bahasa pemrograman terkait.  Lebih jauh, pabrikan menggunakan berbagai transformasi optimisasi - sama seperti pada teknologi kompiler, khususnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transformasi optimisasi siklus</a> .  Faktanya adalah bahwa tujuan analisis statis idealnya adalah untuk melakukan promosi data dalam program untuk mengevaluasi transformasi mereka selama pelaksanaan program.  Oleh karena itu, data harus "maju" melalui setiap putaran siklus.  Jadi, jika Anda menghemat belokan ini dan membuatnya lebih kecil, maka kami akan mendapatkan manfaat yang signifikan baik dalam memori maupun dalam kinerja.  Untuk maksud inilah transformasi semacam itu digunakan secara aktif sehingga, dengan beberapa kemungkinan, melakukan ekstrapolasi transformasi data ke semua putaran siklus dengan jumlah lintasan minimum. <br><br>  Anda juga dapat menghemat cabang dengan menghitung kemungkinan bahwa program akan berjalan di satu atau cabang lain.  Jika probabilitas melewati sepanjang cabang lebih rendah dari ini, maka cabang program ini tidak dipertimbangkan. <br><br>  Jelas, setiap transformasi ini "kehilangan" cacat yang harus dideteksi oleh penganalisa, tetapi ini adalah "biaya" untuk efisiensi dan kinerja memori. <br><br><h3>  Apa yang dicari oleh penganalisa kode statis? <br></h3><br>  Secara kondisional, cacat yang entah bagaimana tertarik pada penyusup, dan karenanya, auditor, dapat dibagi ke dalam kelompok berikut: <br><br><ul><li>  kesalahan validasi </li><li>  kesalahan kebocoran informasi, </li><li>  kesalahan otentikasi. </li></ul><br>  <b>Kesalahan validasi</b> terjadi karena fakta bahwa data input tidak cukup diperiksa untuk kebenarannya.  Seorang penyerang dapat menyelinap sebagai input apa yang bukan yang diharapkan oleh program, dan dengan demikian memperoleh akses tidak sah ke kontrol.  Kesalahan validasi data yang paling umum adalah suntikan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">XSS</a> .  Alih-alih data yang valid, penyerang mengajukan ke input program yang secara khusus menyiapkan data yang membawa program kecil.  Program ini, yang sedang diproses, dijalankan.  Hasil dari implementasinya mungkin transfer kontrol ke program lain, korupsi data dan banyak lagi.  Selain itu, sebagai akibat dari kesalahan validasi, situs tempat pengguna bekerja dapat diganti.  Kesalahan validasi dapat dideteksi secara kualitatif dengan metode analisis kode statis. <br><br>  Kesalahan <b>kebocoran informasi</b> adalah kesalahan yang terkait dengan fakta bahwa informasi sensitif dari pengguna sebagai hasil pemrosesan dicegat dan dikirim ke penyerang.  Bisa juga sebaliknya: informasi sensitif yang disimpan dalam sistem dicegat dan dikirim ke penyerang ketika bergerak ke pengguna. <br><br>  Kerentanan semacam itu sama sulitnya dideteksi dengan kesalahan validasi.  Deteksi kesalahan semacam ini membutuhkan pelacakan dalam statistik kemajuan dan konversi data di seluruh kode program.  Ini membutuhkan implementasi metode seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis noda</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">analisis data antar</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prosedur</a> .  Keakuratan analisis sangat tergantung pada seberapa baik metode ini dikembangkan, yaitu, meminimalkan kesalahan positif dan kesalahan yang terlewatkan. <br><br>  Perpustakaan aturan untuk mendeteksi cacat, khususnya, format untuk menggambarkan aturan-aturan ini, juga memainkan peran penting dalam akurasi penganalisa statis.  Semua ini merupakan keunggulan kompetitif dari masing-masing penganalisa dan dijaga ketat dari pesaing. <br><br>  <b>Kesalahan otentikasi</b> adalah <b>kesalahan</b> yang paling menarik bagi penyerang, karena mereka sulit dideteksi karena mereka muncul di persimpangan komponen dan sulit untuk diformalkan.  Penyerang mengeksploitasi kesalahan semacam ini untuk meningkatkan hak akses.  Kesalahan otentikasi tidak secara otomatis terdeteksi, karena tidak jelas apa yang harus dicari - ini adalah kesalahan dalam logika membangun program. <br><br><h3>  Kesalahan Memori <br></h3><br>  Mereka sulit dideteksi karena identifikasi yang akurat membutuhkan penyelesaian sistem persamaan yang rumit, yang mahal dalam memori dan kinerja.  Oleh karena itu, sistem persamaan berkurang, yang berarti keakuratannya hilang. <br><br>  Kesalahan memori yang umum termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penggunaan-setelah-bebas</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bebas-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ganda</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">null-pointer-dereference</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">variasinya</a> , misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">out-of-bounds-Read</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">out-of-bounds-Write</a> . <br><br>  Ketika penganalisa berikutnya gagal mendeteksi kebocoran memori, Anda dapat mendengar bahwa kerusakan seperti itu sulit untuk dieksploitasi.  Seorang penyerang harus sangat berkualitas dan menerapkan banyak keterampilan untuk, pertama, mencari tahu tentang adanya kerusakan seperti itu dalam kode, dan, kedua, untuk melakukan eksploitasi.  Nah, dan selanjutnya argumennya adalah: "Apakah Anda yakin bahwa produk perangkat lunak Anda menarik bagi seorang guru tingkat ini?" ... Namun, sejarah mengetahui kasus ketika kesalahan memori berhasil dieksploitasi dan menyebabkan kerusakan yang cukup besar.  Sebagai contoh, Anda dapat mengutip situasi terkenal seperti: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE-2014-0160</a> - kesalahan di perpustakaan openssl - potensi kompromi kunci pribadi diperlukan penerbitan ulang semua sertifikat dan regenerasi kata sandi. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE-2015-2712</a> - bug dalam implementasi js di mozilla firefox - cek batas. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE-2010-1117</a> - digunakan setelah gratis di internet explorer - dapat dieksploitasi dari jarak jauh. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CVE-2018-4913</a> - digunakan setelah bebas di Acrobat Reader - eksekusi kode. </li></ol><br>  Selain itu, penyerang suka mengeksploitasi cacat yang terkait dengan sinkronisasi utas atau proses yang tidak benar.  Cacat seperti itu sulit diidentifikasi dalam statika, karena mensimulasikan keadaan mesin tanpa konsep "waktu" bukanlah tugas yang mudah.  Ini merujuk pada kesalahan seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kondisi ras</a> .  Dan hari ini, concurrency digunakan di mana-mana, bahkan dalam aplikasi yang sangat kecil. <br><br>  Ringkasnya, perlu dicatat bahwa penganalisa statis berguna dalam proses pengembangan, jika digunakan dengan benar.  Selama operasi, perlu untuk memahami apa yang diharapkan dari itu dan apa yang harus dilakukan dengan cacat-kerusakan yang pada prinsipnya tidak dapat diidentifikasi oleh analisa statis.  Jika mereka mengatakan bahwa analisa statis tidak diperlukan selama proses pengembangan, itu berarti bahwa mereka tidak dapat mengoperasikannya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lu/90/kx/lu90kxj_uabzysjjxievhgctnpa.png"></div><br>  Cara mengoperasikan penganalisa statis dengan benar, untuk bekerja dengan benar dan efisien dengan informasi yang diberikannya, baca di blog kami. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420337/">https://habr.com/ru/post/id420337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420327/index.html">LLTR Bagian 1: Langkah Pertama di OMNeT ++ dan INET</a></li>
<li><a href="../id420329/index.html">"Realitas diragukan": poin utama buku karya Jane McGonigal tentang peran permainan dalam masyarakat modern</a></li>
<li><a href="../id420331/index.html">Demopati di Helsinki "Majelis 2018", laporan foto, hari kedua</a></li>
<li><a href="../id420333/index.html">Mesin penggilingan CNC gantry besar DIY</a></li>
<li><a href="../id420335/index.html">Gaya membaca buku Anda mengatakan banyak tentang kecerdasan Anda - dan itulah sebabnya</a></li>
<li><a href="../id420339/index.html">Video surveillance menggunakan smartphone - pro dan kontra</a></li>
<li><a href="../id420341/index.html">Berjalan di tempat dan pengembangan web</a></li>
<li><a href="../id420343/index.html">Lampu LED OK</a></li>
<li><a href="../id420345/index.html">Ikhtisar pusat data IXcellerate (ruang mesin terbesar di Federasi Rusia)</a></li>
<li><a href="../id420347/index.html">Pelajari cara membuat perintah bash Anda sendiri dalam waktu kurang dari 4 menit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>