<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòå üì± üè™ Fehler bei der Arbeit mit der Systemtastatur üïü ü§ñ üé™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Interaktion mit der Anwendung aktivieren wir irgendwann die Systemtastatur, um eine Nachricht einzugeben oder die erforderlichen Felder auszuf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fehler bei der Arbeit mit der Systemtastatur</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462515/">  <em>Bei der Interaktion mit der Anwendung aktivieren wir irgendwann die Systemtastatur, um eine Nachricht einzugeben oder die erforderlichen Felder auszuf√ºllen.</em>  <em>Sind Sie auf Situationen gesto√üen, in denen die Tastatur angezeigt wird, aber kein Feld f√ºr die Eingabe einer Nachricht vorhanden ist oder umgekehrt - die Tastatur ist dort, wo die Eingabe von Text nicht sichtbar ist?</em>  <em>Fehler k√∂nnen mit Problemen innerhalb einer bestimmten Anwendung sowie mit allgemeinen M√§ngeln der Systemtastatur zusammenh√§ngen.</em> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em>Konstantin Mordan</em></a> <em>, ein iOS-Entwickler von Mail.ru, sah alles in seiner Arbeit: Nachdem er die Tastatursteuerungsmethoden in iOS analysiert hatte, beschloss er, die wichtigsten Fehler und Ans√§tze zu teilen, mit denen er sie erkannte und behebte.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/wc/xg/fbwcxgdtopdtlj8_u7rkj1vnmne.jpeg" width="400"></div><br><br>  <i>Achtung: Unter dem Schnitt haben wir viele Gifs platziert, um Fehler deutlich zu machen.</i>  <i>Weitere Beispiele finden Sie im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Videobericht</a> von Konstantin auf AppsConf.</i> <br><a name="habracut"></a><br><h1>  Implementieren eines Systemtastaturaufrufs </h1><br>  Beginnen wir mit dem Verst√§ndnis, wie ein Tastaturaufruf im Allgemeinen implementiert wird. <br><br>  Stellen Sie sich vor, Sie entwickeln eine Anwendung, deren Aufgabe es ist, Aika (einen South Park-Charakter) √ºber die Tastatur zu einem ganzen Kanadier zusammenzusetzen.  Wenn Sie Aiku auf den Bauch dr√ºcken, geht die Tastatur und hebt dabei die Beine unseres Helden zum Kopf. <br><br>  Um die Aufgabe zu implementieren, k√∂nnen Sie <i>InputAccessoryView verwenden</i> oder Systembenachrichtigungen verarbeiten. <br><br><h2>  InputAccessoryView </h2><br>  Schauen wir uns die erste Option an. <br><br>  Erstellen Sie im ViewController eine Ansicht, die zusammen mit der Tastatur angezeigt wird, und geben Sie ihr einen Rahmen.  Es ist wichtig, dass diese Ansicht nicht als Unteransicht hinzugef√ºgt wird.  Als N√§chstes √ºberschreiben wir die Eigenschaften von <em>canBecomeFirstResponder</em> und geben true zur√ºck.  Nachdem wir die UIResponder-Eigenschaft - <em>inputAccessoryView</em> neu definiert und die Ansicht dort abgelegt haben.  Um die Tastatur zu schlie√üen, f√ºgen Sie <em>tapGesture hinzu</em> und setzen Sie in ihrem Handler <em>den ersten Antwortenden der von</em> uns erstellten Ansicht zur√ºck. <br><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tummyView: <span class="hljs-type"><span class="hljs-type">UIView</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> frame = <span class="hljs-type"><span class="hljs-type">CGRect</span></span>(x: x, y: y, width: width, height: height) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = <span class="hljs-type"><span class="hljs-type">TummyView</span></span>(frame: frame) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> canBecomeFirstResponder: <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input <span class="hljs-type"><span class="hljs-type">AccessoryView</span></span>: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tummyView } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tapHandler</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { tummyView.resignFirstResponder ( ) } }</code> </pre> <br>  Die Aufgabe ist abgeschlossen, und das System selbst verarbeitet √Ñnderungen des Tastaturstatus, zeigt sie an und l√∂st die Ansicht aus, die davon abh√§ngt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/mu/nd/ewmundnnrpbdgjgwvk_frx4qv6o.gif" width="200"></div><br><br><h2>  Systembenachrichtigungsverarbeitung </h2><br>  Bei der Verarbeitung von Benachrichtigungen m√ºssen wir Benachrichtigungen aus den folgenden Gruppen selbst verarbeiten: <br><br><ul><li>  wann die Tastatur angezeigt wird / wurde: keyboardWillShowNotification, keyboardDidShowNotification; </li><li>  wann die Tastatur ausgeblendet wird / wurde: keyboardWillHideNotification, keyboardDidHideNotification; </li><li>  Wann wird / wurde der Tastaturrahmen ge√§ndert: keyboardWilChangeFrameNotification, keyboardDidChangeFrameNotification. </li></ul><br>  Um unseren Fall zu implementieren, nehmen wir <em>keyboardWilChangeFrameNotification</em> , da diese Benachrichtigung sowohl gesendet wird, wenn die Tastatur angezeigt wird, als auch wenn sie ausgeblendet ist. <br><br>  Wir erstellen einen <em>tastaturtracker,</em> abonnieren darin eine Benachrichtigung √ºber <em>keyboardWillChangeFrame</em> und erhalten im Handler den Tastaturrahmen, konvertieren ihn vom Bildschirmkoordinatensystem in das Fensterkoordinatensystem, berechnen die Tastaturh√∂he und √§ndern den Y-Wert der Ansicht, die von der Tastatur angehoben werden soll, auf diese H√∂he. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.add0observer(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, seletor: #selector( keyboardWillChangeFrame), name: <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo [ <span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey ] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span> ) .cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY delegate.keyboardWillChange ( keyboardHeight ) } }</code> </pre> <br>  Damit ist unsere Aufgabe erledigt, die Tastatur steigt und sammelt Ike im Kanadier. <br><br>  Wie wir sehen k√∂nnen, ist die Implementierung der Arbeit mit der Tastatur in beiden F√§llen recht einfach, sodass jeder die geeignete Methode selbst ausw√§hlen kann.  In unserem Projekt haben wir uns f√ºr Benachrichtigungen entschieden, sodass weitere Beispiele und Erkenntnisse mit der Verarbeitung von Benachrichtigungen verbunden werden. <br><br><h2>  Auf der Suche nach Fehlern </h2><br>  Wenn die Art und Weise, die Tastatur aufzurufen, so einfach ist, woher kommen dann die Fehler?  Wenn die Anwendung nur das Skript zum √ñffnen und Schlie√üen der Tastatur reproduziert, gibt es nat√ºrlich keine Probleme.  Wenn Sie jedoch den √ºblichen Ablauf √§ndern, denken Sie daran, dass nicht nur unsere Anwendung die Tastatur verwenden kann, sondern auch andere, und der Benutzer auch zwischen ihnen wechseln kann. √úberraschungen k√∂nnen nicht vermieden werden. <br><br>  Schauen wir uns ein Beispiel an.  Verwenden Sie dazu unsere Anwendung mit Ike: √ñffnen Sie die Tastatur, wechseln Sie zu Notizen, drucken Sie etwas und kehren Sie zur Anwendung zur√ºck. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Welche Probleme sind bereits sichtbar?  Erstens gibt es im App Switcher keine Tastatur, obwohl beim Minimieren der Anwendung diese vorhanden war und stattdessen andere Inhalte sichtbar sind.  Zweitens, wenn Sie zur Anwendung zur√ºckkehren, ist die Tastatur immer noch nicht vorhanden, und Ikes Beine fallen √ºber den Bildschirm. <br><br>  Schauen wir uns die Gr√ºnde f√ºr dieses Verhalten an.  Wie wir uns alle aus dem Lebenszyklusdiagramm der Anwendung erinnern, dauert der √úbergang einer Anwendung von einem aktiven Zustand in einen inaktiven Zustand zuerst im Vordergrund und dann im Hintergrund einige Zeit. <br><br>  Was ist mit dem Tastaturlebenszyklus?  Unter iOS kann die Tastatur f√ºr jede Zeiteinheit nur einer der ausgef√ºhrten Anwendungen geh√∂ren, aber Benachrichtigungen √ºber √Ñnderungen des Tastaturstatus werden von allen darauf signierten Anwendungen empfangen. <br><br>  Beim Wechsel von einer Anwendung zu einer anderen setzt das System seinen ersten Antwortenden zur√ºck, der als Ausl√∂ser zum Ausblenden der Tastatur fungiert.  Das System sendet zuerst eine Benachrichtigung √ºber keyboardWillHide, damit die Tastatur verschwindet, und dann keyboardDidHideNotification.  Die Benachrichtigung fliegt zur zweiten Anwendung.  In der neuen Anwendung √∂ffnen wir die Tastatur: Das System sendet keyboardWillShowNotification, damit die Tastatur angezeigt wird, und sendet dann die keyboardDidShowNotification - eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Demo</a> mit den Phasen des Zyklus. <br><br><img src="https://habrastorage.org/webt/gk/th/5c/gkth5chvrkyewmvhdrpc7eito9q.jpeg"><br><br>  Wenn Sie sich einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug aus dem Bericht</a> ansehen (ab 8:39 Uhr), sehen Sie den Moment, in dem das System nach dem Ausblenden der Tastatur keyboardDidHideNotification sendet, um die erste Anwendung in einen inaktiven Zustand zu versetzen.  Wenn Sie zur Sport-App wechseln und die Tastatur starten, sendet das System keyboardWillShowNotification.  Da der Umschalt- und Startvorgang jedoch schnell ist und die √úbergangszeit zwischen den Phasen des Lebenszyklus l√§nger sein kann, wird in der erhaltenen Benachrichtigung nicht nur der Sportantrag bearbeitet, sondern auch der Bierantrag, der noch nicht in den Hintergrund getreten ist. <br><br>  Nachdem wir die Gr√ºnde herausgefunden haben, wollen wir nun eine L√∂sung f√ºr das Problem mit Ike finden. <br><br><h3>  Schlechte Entscheidung </h3><br>  Das erste, was mir in den Sinn kommt, ist die Idee, Benachrichtigungen abzubestellen / zu abonnieren, wenn eine Anwendung durch Aktivieren / Deaktivieren von KeyboardTracker minimiert / maximiert wird. <br><br>  Zum Abbestellen verwenden wir die applicationWillResignActive-Methode oder einen √§hnlichen Benachrichtigungshandler aus dem System. Zum Abonnieren verwenden wir applicationDidBecomeActive. Um jedoch nichts zu verpassen, benachrichtigen wir auch die applicationWillEnterForeground-Methode, die aufgerufen wird, wenn die Anwendung in den Vordergrund tritt, aber noch nicht aktiv wird. <br><br>  Wenn Sie die Tastatur in der Anwendung starten, ist h√∂chstwahrscheinlich alles erfolgreich. Bei komplexeren Tests, z. B. √ñffnen der Tastatur und Versuch, Sprachwahl aufzuzeichnen, funktioniert die L√∂sung jedoch nicht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/0b/_e/dy0b_eiomhqtkuqimnsdew_es-c.gif" width="200"></div><br><br>  Was ist passiert?  Nach dem Klicken auf die Schaltfl√§che zum W√§hlen von Sprachnachrichten wurde die Anwendung firstResponder zur√ºckgesetzt, die Tastatur wurde geschlossen, die applicationWillResignActive-Methode wurde aufgerufen und wir haben uns abgemeldet.  Nach dem Schlie√üen der Warnung stellte das System den Anwendungsstatus wieder her, jedoch bevor die applicationWillEnterForeground-Methode und insbesondere die applicationDidBecomeActive aufgerufen wurden. <br><br><h3>  Gute Entscheidung </h3><br>  Eine andere L√∂sung ist die Verwendung einer Schutzbr√ºhe (Bool). <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wasTummyViewFirstResponderBeforeApp0idEnterBackground <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { wasTextFieldFirstResponderBeforeAppDidEnterBackground = tummyView.isFirstResponder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> wasTextFieldFirstResponderBeforeAppDidEnterBackground { <span class="hljs-type"><span class="hljs-type">UIView</span></span>.performWithourAnimation { tummyView.becomeFirstResponder ( ) } } }</code> </pre> <br>  Wir erinnern uns, ob die Tastatur vor dem Thema ge√∂ffnet wurde, wie die Anwendung nicht mehr aktiv war und in der applicationWillEnterForeground-Methode den vorherigen Status wiederherstellen.  Das einzige, was noch behoben werden muss, ist das Loch im App-Umschalter. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jc/sl/oc/jcsloczny6akuricp8x0bzwvbxo.jpeg" width="400"></div><br><br><h2>  App-Umschalter </h2><br>  Der App-Umschalter zeigt App-Snapshots an, die das System erstellt, nachdem die App in den Hintergrund getreten ist.  Der Screenshot zeigt, dass der Schnappschuss unserer Anwendung zu einem Zeitpunkt erstellt wurde, als die Tastatur bereits von einer anderen Anwendung verwendet wird.  Dies ist nicht kritisch, aber es sind nur ein paar Klicks erforderlich, um das Problem zu beheben. <br><br><h3>  Gute L√∂sung </h3><br>  Die L√∂sung kann von Bankanwendungen ausgeliehen werden, die gelernt haben, vertrauliche Daten zu verbergen, und auch von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Apple</a> gelesen werden. <br><br>  Sie k√∂nnen die Daten in der applicationDidEnterBackground-Methode ausblenden, den Begr√º√üungsbildschirm verwischen und anzeigen und in der applicationWillEnterForeground-Methode zur √ºblichen Ansichtshierarchie zur√ºckkehren. <br><br>  Diese Option passt nicht zu uns, da unsere Anwendung zum Zeitpunkt des Aufrufs der applicationDidEnterBackground-Methode keine Tastatur mehr hat. <br><br><h3>  Gute Entscheidung </h3><br>  Wir werden die bekannten Methoden willResignActive, willEnterForeground und didBecomeActive verwenden. <br><br>  W√§hrend unsere Anwendung noch √ºber eine Tastatur verf√ºgt, m√ºssen Sie in der Methode willResignActive einen eigenen Snapshot der Anwendung erstellen und in die Hierarchie einf√ºgen. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willResignActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notificaton: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyWindow = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.keyWindow imageView = <span class="hljs-type"><span class="hljs-type">UIImageView</span></span>( frame: keyWindow.bounds) imageView.image = snapshot ( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lastSubview = keyWindow.subviews.last lastSubview( imageView) }</code> </pre> <br>  In den Methoden willEnterForeground und didBecomeActive stellen wir die Ansichtshierarchie wieder her und l√∂schen unseren Snapshot. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">willEnterForeground</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">didBecomeActive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { imageView.removeFromSuperview( ) }</code> </pre> <br>  Infolgedessen haben wir beide F√§lle behoben: Im App-Umschalter springen beim Umschalten ein sch√∂nes Bild und die Tastatur nicht mehr.  Es scheint, dass dies keine so wichtigen Dinge sind, aber f√ºr die Produktentwicklung sind diese Punkte √§u√üerst wichtig. <br><br><h2>  Schlechte Nachrichten </h2><br>  Unsere erfolgreiche L√∂sung des Ike-Problems betraf den Fall, dass die Tastatur ge√∂ffnet wurde, bevor die Anwendung minimiert wurde.  Wenn das Umschalten erfolgt, ohne die Tastatur zu erweitern, werden wir wieder sehen, dass die Beine unseres Ike nach unten gefallen sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br><br>  Dies ist nicht nur ein Problem f√ºr unsere Anwendung, dieses Verhalten wird auch bei Facebook beobachtet, das mit Benachrichtigungen arbeitet, und sogar bei iMessage, das inputAccessoryView zur Steuerung der Tastatur verwendet.  Dies liegt an der Tatsache, dass Anwendungen vor dem Wechsel in den Hintergrund die Tastaturbenachrichtigungen anderer Personen verarbeiten k√∂nnen. <br><br><h2>  interaktiv Tastaturentlassung </h2><br>  F√ºgen Sie unserer Anwendung mit Ike einige Funktionen hinzu und bringen Sie dem Programm bei, die Tastatur interaktiv auszublenden. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/cy/1g/g6cy1gparlfmqc0abfaz7rd_rr0.gif" width="200"></div><br><br><h3>  Schlechte Entscheidung </h3><br>  Eine M√∂glichkeit, diese Funktionalit√§t zu nutzen, besteht darin, den Rahmen der Tastaturansicht zu √§ndern.  Wir erstellen panGestureRecognizer, berechnen in seinem Handler den neuen Wert der Y-Koordinate f√ºr die Tastatur, abh√§ngig von der Position unseres Fingers, suchen die Tastaturansicht und aktualisieren sie mit dem Y-Koordinatenwert. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGestureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = value keyboardView( )?.frame.origin.y = yPosition }</code> </pre> <br>  Die Tastatur wird in einem separaten Fenster angezeigt. Sie m√ºssen also das gesamte Fensterarray in der Anwendung durchgehen, f√ºr jedes Element des Arrays pr√ºfen, ob es sich um ein Tastaturfenster handelt, und in diesem Fall eine Ansicht mit der Tastatur abrufen. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br>  Leider funktioniert diese L√∂sung auf dem iPhone X und h√∂her nicht normal, da Sie beim Bewegen des Fingers die untere Anzeige leicht ber√ºhren k√∂nnen, was f√ºr die Minimierung der Anwendung verantwortlich ist.  Danach funktioniert das interaktive Verstecken nicht mehr. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/-o/iv/eg-oiv8yrssufcejelvxqj4ksrq.gif" width="200"></div><br><br>  Das Problem liegt in der Anordnung der Fenster. <br><br><img src="https://habrastorage.org/webt/vc/u6/9o/vcu69oekot0zgl31iikyy_0refo.jpeg" width="600"><br><br>  Nach der Geste erstellt das System ein neues Tastaturfenster √ºber dem vorhandenen.  Es ist undenkbar, aber wahr.  Als Ergebnis stellt sich heraus, dass das Array zwei Tastaturfenster mit denselben Koordinaten enth√§lt, das erste jedoch ausgeblendet ist. <br><br><img src="https://habrastorage.org/webt/pp/0v/ha/pp0vhay6ionyekifnsg-9jvnpzg.jpeg"><br><br>  Es stellt sich heraus, dass wir beim Durchlaufen der Fensterreihe das erste finden, das die Bedingungen erf√ºllt, und damit beginnen, damit zu arbeiten, obwohl es verborgen ist. <br><br>  Wie ist das behoben?  Eine Reihe von Fenstern drehen. <br><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panGeastureHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> yPosition: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> = <span class="hljs-number"><span class="hljs-number">0.0</span></span> keyboardView( )?.frame.origin.y = yPosition } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windows = <span class="hljs-type"><span class="hljs-type">UIApplication</span></span>.shared.windows.reversed( ) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = windows.first { (window) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyboardView( fromWindow: window) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> view }</code> </pre> <br><h2>  Tastaturfunktionen auf dem iPad </h2><br>  Die Tastatur des iPad hat neben dem √ºblichen Zustand einen nicht angedockten Zustand.  Der Benutzer kann es auf dem Bildschirm bewegen, in zwei Teile teilen und die Anwendung sogar im Slide-Over-Modus (√ºbereinander) starten.  Nat√ºrlich ist es wichtig, dass in all diesen Modi die Tastatur fehlerfrei funktioniert. <br><br>  Schauen wir uns unseren Hayke an. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/4x/l5/y14xl5geuyxmkubopbkabplwbz4.gif"></div><br><br>  Leider ist dies jetzt nicht der Fall.  Nachdem der Benutzer die Tastatur auf dem Bildschirm bewegt hat, fliegen Ikes Beine √ºber seinem Kopf ab und erscheinen erst nach dem n√§chsten √ñffnen der Tastatur.  Versuchen wir, das Problem mit einer geteilten Tastatur zu beheben. <br><br><h3>  Gr√ºnde </h3><br>  Beginnen wir mit der Analyse von Benachrichtigungen.  Nach dem Klicken auf die Schaltfl√§che "Teilen" erhalten wir zwei Gruppen von Benachrichtigungen: "KeyboardWillChangeFrameNotification", "KeyboardWillHideNotification", "KeyboardDidChangeFrameNotification", "KeyboardDidHideNotification".  Der Unterschied zwischen Gruppen liegt nur in den Koordinaten der Tastatur. <br><br>  Wenn wir auf die Schaltfl√§che "Teilen" klicken, wird die Tastatur kleiner und die erste Gruppe von Benachrichtigungen wird angezeigt.  Als sich die Tastatur aufteilte und nach oben ging, erhielten wir ein zweites Paket mit Benachrichtigungen. <br><br>  Wichtig ist, dass wir Benachrichtigungen erhalten, dass die Tastatur verschwunden ist, aber nicht, dass sie angezeigt wird.  Dies ist √ºbrigens ein weiteres Plus f√ºr die Verwendung von keyboardWillChangeFrameNotification. <br><br>  Warum fliegen dann Ikes Beine weg, sobald wir die Tastatur √ºber den Bildschirm bewegen? <br><br>  In diesem Moment sendet uns das System eine keyboardWillChangeFrameNotification, aber die dort liegenden Koordinaten sind (0.0, 0.0, 0.0, 0.0), da das System nicht wei√ü, an welchem ‚Äã‚ÄãPunkt sich die Tastatur befindet, nachdem die Bewegung abgeschlossen ist. <br><br>  Wenn wir im aktuellen Code, der die √Ñnderung des Tastaturrahmens verarbeitet, Nullen einsetzen, stellt sich heraus, dass die H√∂he der Tastatur der H√∂he des Fensters entspricht.  Das ist der Grund, warum Ikes Beine vom Bildschirm fliegen. <br><br><h3>  Gute Entscheidung </h3><br>  Um unser Problem zu l√∂sen, lernen wir zun√§chst zu verstehen, wann sich die Tastatur im nicht angedockten Modus befindet und der Benutzer sie auf dem Bildschirm bewegen kann. <br><br>  Vergleichen Sie dazu einfach die H√∂he des Fensters und der maxY-Tastatur.  Wenn sie gleich sind, befindet sich die Tastatur im Normalzustand. Wenn maxY kleiner als die H√∂he des Fensters ist, bewegt der Benutzer die Tastatur.  Infolgedessen wird der folgende Code in keyboardTracker angezeigt: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { notificationCenter.addObserver( <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, selector:#selector( keyboardWillChangeFrame), name:<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardWillChangeFrameNotification, object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screenCoordinatedKeyboardFrame = (userInfo[<span class="hljs-type"><span class="hljs-type">UIResponder</span></span>.keyboardFrameEndUserInfoKey] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSValue</span></span>).cgRectValue <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> leyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> windowHeight = window.frame.height <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keyboardHeight = windowHeight - keyboardFrame.minY <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> isKeyboardUnlocked = isIPad ( ) &amp;&amp; keyboardFrame/maxY &lt; windowHeight <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isKeyboardUnlocked { keyboardHeight = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } delegate.keyboardWillChange ( keyboardHeight) } }</code> </pre> <br>  Wir haben die H√∂he benutzerdefiniert auf Null gesetzt, und jetzt, mit der Bewegung der Tastatur, gehen Ikes Beine nach unten und werden dort fixiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/uv/u_/txuvu_-lhk01nhlzbcyfxc8g3k4.gif" width="400"></div><br><br>  Das einzige verbleibende Missverst√§ndnis ist die Tatsache, dass Ikes Beine beim Teilen der Tastatur nicht sofort herunterfallen.  Wie kann ich das beheben? <br><br>  Wir werden keyboardTracker beibringen, nicht nur mit keyboardWillChangeFrameNotification, sondern auch mit keyboardDidChangeFrame zu arbeiten.  Sie m√ºssen keinen neuen Code schreiben, sondern m√ºssen nur √ºberpr√ºfen, ob es sich um ein iPad handelt, um keine unn√∂tigen Berechnungen durchzuf√ºhren. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardDidChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isIPad ( ) == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/-n/nv/jd-nnvrctruwlczh4ytw2ckfllu.gif" width="400"></div><br><br><h2>  Wie erkenne ich Fehler? </h2><br><h3>  Reichlich Protokollierung </h3><br>  In unserem Projekt werden Protokolle in folgendem Format geschrieben: in eckigen Klammern der Name des Moduls und des Submoduls, zu dem das Protokoll geh√∂rt, und dann der Text des Protokolls selbst.  Zum Beispiel so: <br> <code>[keyboard][tracker] keyboardWillChangeFrame: calculated height - 437.9</code> <br> <br>  Im Code sieht es wie folgt aus: Ein Logger wird mit einem Tag der obersten Ebene erstellt und an den Tracker √ºbertragen.  Im Tracker wird ein Logger mit einem Tag der zweiten Ebene, der zum Protokollieren innerhalb der Klasse verwendet wird, aus dem Logger ausgegliedert. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyboardTracker</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(with logger: <span class="hljs-type"><span class="hljs-type">Logger</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.trackerLogger = logger.dequeue(withTag: <span class="hljs-string"><span class="hljs-string">"[tracker]"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyboardWillChangeFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(notification: NSNotification)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> height = <span class="hljs-number"><span class="hljs-number">0.0</span></span> trackerLogger.debug(<span class="hljs-string"><span class="hljs-string">"\(#function): calculated height - \(height)"</span></span>) } }</code> </pre> <br>  Also habe ich den gesamten KeyboardTracker zugesagt, was gut ist.  Wenn Tester Probleme fanden, nahm ich die Protokolldatei und suchte genau, wo die Frames nicht passten.  Dies dauerte zu lange, daher wurden neben der Protokollierung auch andere Methoden angewendet. <br><br><h3>  Wachhund </h3><br>  In unserem Projekt wird Watchdog verwendet, um den UI-Stream zu optimieren.  Dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sagte Dmitry Kurkin auf einer der vergangenen AppsConf</a> . <br><br>  Ein Watchdog ist ein Prozess oder Thread, der einen anderen Prozess oder Thread √ºberwacht.  Mit diesem Mechanismus k√∂nnen Sie den Status der Tastatur und die davon abh√§ngigen Ansichten √ºberwachen und Probleme melden. <br><br>  Um diese Funktionalit√§t zu implementieren, erstellen wir einen Timer, der einmal pro Sekunde die korrekte Position der Ansicht mit Hayks Beinen √ºberpr√ºft oder diese protokolliert, wenn es sich um einen Fehler handelt. <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Watchdog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timer: <span class="hljs-type"><span class="hljs-type">Timer?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( )</span></span></span></span> { timer = <span class="hljs-type"><span class="hljs-type">Timer</span></span> ( timeInterval: <span class="hljs-number"><span class="hljs-number">1.0</span></span>, repeats: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, block: { ( timer ) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.woof ( ) } ) } }</code> </pre> <br>  √úbrigens k√∂nnen Sie nicht nur die Endergebnisse, sondern auch Zwischenberechnungen protokollieren. <br><br>  Infolgedessen lieferte die reichliche Protokollierung + Watchdog genaue Daten √ºber das Problem, den Zustand der Tastatur und verk√ºrzte die Zeit zur Behebung von Fehlern, half jedoch Beta-Benutzern, die Fehler bis zur n√§chsten Version ertragen mussten, nur wenig. <br><br>  Aber was ist, wenn Watchdog trainiert werden kann, um Probleme nicht nur zu finden, sondern auch zu beheben? <br><br>  In dem Code, in dem Watchdog die Schlussfolgerung zieht, dass die Koordinaten der Ansicht nicht konvergieren, f√ºgen wir die Methode fixTummyPosition hinzu und setzen die Koordinaten automatisch ein. <br><br>  Bei dieser Option werden viele n√ºtzliche Informationen in meinen Protokollen gesammelt, und Benutzer bemerken √ºberhaupt keine visuellen Probleme.  Das scheint gro√üartig zu sein, aber jetzt kann ich keine Probleme mit der Tastatur feststellen. <br><br>  Es ist hilfreich, der Watchdog-Methode die M√∂glichkeit hinzuzuf√ºgen, einen Testcache zu generieren, wenn ein Fehler erkannt wird.  Nat√ºrlich wird dieser Code unter der Remout-Konfiguration hinzugef√ºgt. <br><br>  Jetzt, nach der n√§chsten Version, k√∂nnen Sie die Testabsturzgenerierung aktivieren. Wenn ein Benutzer Probleme mit der Tastatur hat, st√ºrzt seine Anwendung ab und dank der gesammelten Protokolle k√∂nnen Sie Fehler beheben. <br><br><h3>  Dashboard </h3><br>  Der letzte Trick, den wir eingef√ºhrt haben, ist das Senden von Statistiken, sobald wahtchdog die Statistiken aufgezeichnet hat.  Basierend auf den erhaltenen Daten haben wir die Anzahl der erkannten Fehler aufgezeichnet und nach der ersten Iteration wurde die Anzahl der Operationen um das Vierfache reduziert.  Nat√ºrlich war es nicht m√∂glich, die Probleme auf Null zu reduzieren, aber die Hauptbeschwerden der Benutzer h√∂rten auf. <br><br><blockquote>  N√§chste Woche findet die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Saint AppsConf</a> in St. Petersburg statt, wo Sie nicht nur Konstantin, sondern auch zahlreichen Rednern des iOS-Tracks Fragen stellen k√∂nnen. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de462515/">https://habr.com/ru/post/de462515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de462505/index.html">Mach mir nichts vor mit deiner funktionalen Programmierung</a></li>
<li><a href="../de462507/index.html">Wenn E-Mails zugestellt werden: Bek√§mpfung des Verlusts von Push-Benachrichtigungen in iOS</a></li>
<li><a href="../de462509/index.html">Product Fest - IT-Produktmanagementkonferenz, an der Sie teilnehmen m√∂chten</a></li>
<li><a href="../de462511/index.html">Google Play Instant. Lebenslanges Refactoring</a></li>
<li><a href="../de462513/index.html">Umzug: Vorbereitung, Auswahl, Entwicklung des Territoriums</a></li>
<li><a href="../de462519/index.html">Das Buch "Microservices. Entwicklungs- und Refactoring-Muster ¬ª</a></li>
<li><a href="../de462523/index.html">LinOTP Zwei-Faktor-Autorisierungsserver</a></li>
<li><a href="../de462525/index.html">3CX bringt neue SIP-Softphones f√ºr iOS und Android mit End-to-End-Sprachverschl√ºsselung auf den Markt</a></li>
<li><a href="../de462527/index.html">Wie ein neuronales SincNet-Netzwerk durch R√ºckausbreitung signifikante Schallfrequenzen zuweist</a></li>
<li><a href="../de462529/index.html">Die Idee der NASA-Mondstation ist schlecht und gut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>