<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçü§ù‚Äçüë®üèº üê£ üëÜ GitOps: comparaci√≥n de los m√©todos Pull y Push üï≥Ô∏è üìî üêí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nota perev. : En la comunidad de Kubernetes, una tendencia llamada GitOps est√° ganando popularidad, como vimos personalmente al visitar KubeCon Europe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>GitOps: comparaci√≥n de los m√©todos Pull y Push</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/456754/">  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: En la comunidad de Kubernetes, una tendencia llamada GitOps est√° ganando popularidad, como vimos personalmente al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">visitar</a> KubeCon Europe 2019. Este t√©rmino fue <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">acu√±ado</a> relativamente recientemente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por el</a> jefe de Weaveworks, Alexis Richardson, y significa el uso de herramientas familiares para desarrolladores (principalmente Git, de ah√≠ el nombre mismo) para resolver problemas operativos.</i>  <i>En particular, estamos hablando de explotar Kubernetes mediante el almacenamiento de sus configuraciones en Git y la implementaci√≥n autom√°tica de cambios en el cl√∫ster.</i>  <i>Matthias Jg habla sobre dos enfoques para este lanzamiento en este art√≠culo.</i> <br><br><img src="https://habrastorage.org/webt/ex/dn/gg/exdnggi20gpsaezt2rokmb8xfz0.jpeg"><br><br>  El a√±o pasado <i>(de hecho, formalmente esto sucedi√≥ en agosto de 2017 - aprox. Transl.)</i> , Apareci√≥ un nuevo enfoque para implementar aplicaciones en Kubernetes.  Se llama GitOps y se basa en la idea b√°sica de que el seguimiento de la versi√≥n de implementaci√≥n se realiza en un entorno seguro de repositorio de Git. <a name="habracut"></a><br><br>  <b>Las principales ventajas de este enfoque son las siguientes</b> : <br><br><ol><li>  <b>Implementaciones de versiones e historial de cambios</b> .  El estado de todo el cl√∫ster se almacena en el repositorio de Git, y las implementaciones solo se actualizan mediante confirmaciones.  Adem√°s, todos los cambios se pueden rastrear utilizando el historial de confirmaci√≥n. </li><li>  <b>Contragolpes utilizando comandos familiares de Git</b> .  Un simple <code>git reset</code> permite descartar cambios en la implementaci√≥n;  los estados pasados ‚Äã‚Äãsiempre est√°n disponibles. </li><li>  <b>Listo control de acceso</b> .  Por lo general, un sistema Git contiene muchos datos confidenciales, por lo que la mayor√≠a de las empresas prestan especial atenci√≥n a su protecci√≥n.  En consecuencia, esta protecci√≥n se extiende a las operaciones con implementaciones. </li><li>  <b>Pol√≠ticas de despliegues</b> .  La mayor√≠a de los sistemas Git inicialmente admiten pol√≠ticas para diferentes sucursales; por ejemplo, solo las solicitudes de extracci√≥n pueden actualizar el maestro y otro miembro del equipo debe verificar y aceptar los cambios.  Al igual que con el control de acceso, se aplican las mismas pol√≠ticas a las actualizaciones de implementaci√≥n. </li></ol><br>  Como puede ver, el m√©todo GitOps tiene muchas ventajas.  Durante el a√±o pasado, dos enfoques han ganado particular popularidad.  Uno se basa en empujar, el otro en tirar.  Antes de mirarlos, veamos c√≥mo son las implementaciones t√≠picas de Kubernetes. <br><br><h2>  M√©todos de implementaci√≥n </h2><br>  En los √∫ltimos a√±os, se han establecido varios m√©todos y herramientas de implementaci√≥n en Kubernetes: <br><br><ol><li>  <b>Basado en plantillas nativas de Kubernetes / Kustomize</b> .  Esta es la forma m√°s f√°cil de implementar aplicaciones en Kubernetes.  El desarrollador crea los archivos YAML b√°sicos y los aplica.  Para deshacerse de la constante reescritura de los mismos patrones, se desarroll√≥ Kustomize (convierte los patrones de Kubernetes en m√≥dulos).  <i><b>Nota</b></i>  <i><b>perev.</b></i>  <i>: Kustomize se ha integrado en kubectl con el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">lanzamiento de Kubernetes 1.14</a> .</i> </li><li>  <b>Gr√°ficos Helm</b> .  Los gr√°ficos de tim√≥n le permiten crear conjuntos de plantillas, contenedores de inicio, sidecar'ov, etc., que se utilizan para implementar aplicaciones con opciones de configuraci√≥n m√°s flexibles que en el enfoque basado en plantillas.  Este m√©todo se basa en archivos YAML de plantilla.  Helm los llena con varios par√°metros y luego los env√≠a a Tiller, el componente del cl√∫ster, que los implementa en el cl√∫ster y permite actualizaciones y retrocesos.  Lo importante es que, de hecho, Helm simplemente inserta los valores necesarios en las plantillas y luego los aplica de la misma manera que en el enfoque tradicional <i>(para obtener m√°s detalles sobre c√≥mo funciona todo esto y c√≥mo puede usarlo, lea nuestro <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre Helm</a> - aprox. .)</i> .  Hay una gran variedad de gr√°ficos de Helm listos para usar que cubren una amplia gama de tareas. </li><li>  <b>Herramientas alternativas</b>  Hay muchas herramientas alternativas.  Todos ellos est√°n unidos por el hecho de que convierten algunos archivos de plantilla en archivos YAML amigables para Kubernetes y luego los aplican. </li></ol><br>  En nuestro trabajo, utilizamos constantemente gr√°ficos de Helm para herramientas importantes (ya que muchas de ellas ya est√°n listas, lo que simplifica enormemente la vida) y los archivos YAML "limpios" de Kubernetes para implementar nuestras propias aplicaciones. <br><br><h2>  Tirar y empujar </h2><br>  En una de mis publicaciones de blog recientes, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">present√© la</a> herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Weave Flux</a> , que le permite enviar plantillas al repositorio de Git y actualizar la implementaci√≥n despu√©s de cada confirmaci√≥n o contenedor de inserci√≥n.  Mi experiencia muestra que esta herramienta es una de las principales para promover el enfoque de extracci√≥n, por lo que a menudo me referir√© a ella.  Si desea saber m√°s sobre c√≥mo usarlo, aqu√≠ hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace al art√≠culo</a> . <br><br>  <i><b>NB!</b></i>  <i>Todos los beneficios de usar GitOps se conservan para ambos enfoques.</i> <br><br><h2>  Enfoque basado en tracci√≥n </h2><br><img src="https://habrastorage.org/webt/v-/a1/ob/v-a1obddnsnwhhvukh2iuzgmrkw.jpeg"><br><br>  El enfoque de extracci√≥n se basa en el hecho de que todos los cambios se aplican desde dentro del cl√∫ster.  Dentro del cl√∫ster, hay un operador que verifica regularmente los repositorios Git y Docker Registry asociados.  Si se produce alg√∫n cambio en ellos, el estado del cl√∫ster se actualiza internamente.  Por lo general, se considera que dicho proceso es muy seguro, ya que ning√∫n cliente externo tiene acceso a los derechos de administrador del cl√∫ster. <br><br>  <b>Pros:</b> <br><br><ol><li>  Ning√∫n cliente externo tiene derecho a realizar cambios en el cl√∫ster; todas las actualizaciones se env√≠an desde el interior. </li><li>  Algunas herramientas tambi√©n le permiten sincronizar las actualizaciones de los gr√°ficos Helm y vincularlas a un cl√∫ster. </li><li>  Docker Registry puede escanearse en busca de nuevas versiones.  Si aparece una nueva imagen, el repositorio y la implementaci√≥n de Git se actualizan a la nueva versi√≥n. </li><li>  Las herramientas de extracci√≥n se pueden distribuir en diferentes espacios de nombres con diferentes repositorios y permisos de Git.  Gracias a esto, es posible utilizar el modelo multiempresa.  Por ejemplo, el equipo A puede usar el espacio de nombres A, el equipo B puede usar el espacio de nombres B y un equipo de infraestructura puede usar el espacio global. </li><li>  Como regla general, las herramientas son muy livianas. </li><li>  En combinaci√≥n con herramientas como la declaraci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">secretos sellados de Bitnami</a> , los secretos se pueden almacenar cifrados en el repositorio de Git y recuperarse dentro del cl√∫ster. </li><li>  No hay comunicaci√≥n con las canalizaciones de CD, ya que las implementaciones ocurren dentro del cl√∫ster. </li></ol><br>  <b>Contras</b> : <br><br><ol><li>  La gesti√≥n de los secretos de implementaci√≥n de los gr√°ficos Helm es m√°s complicada de lo habitual, ya que primero tiene que generarlos, por ejemplo, en secretos sellados, luego descifrarlos con un operador interno y solo despu√©s de que est√©n disponibles para la herramienta de extracci√≥n.  Luego puede lanzar el lanzamiento en Helm con valores en secretos ya implementados.  La forma m√°s f√°cil es crear un secreto con todos los valores de Helm utilizados para la implementaci√≥n, descifrarlo y confirmar en Git. </li><li>  Usando el enfoque pull, te encuentras atado a herramientas que operan en pull.  Esto limita la capacidad de personalizar el proceso de implementaci√≥n de implementaci√≥n en el cl√∫ster.  Por ejemplo, trabajar con Kustomize es complicado por el hecho de que debe ejecutarse antes de que las plantillas finales lleguen a Git.  No digo que no pueda usar herramientas individuales, pero son m√°s dif√≠ciles de integrar en el proceso de implementaci√≥n. </li></ol><br><h2>  Enfoque basado en empuje </h2><br><img src="https://habrastorage.org/webt/1r/b_/qo/1rb_qoykirrwpkjjcnnd7ojrykk.jpeg"><br><br>  En el enfoque de inserci√≥n, un sistema externo (principalmente canalizaciones de CD) comienza a implementarse en el cl√∫ster despu√©s de comprometerse con el repositorio de Git o en caso de ejecuci√≥n exitosa de la canalizaci√≥n de CI anterior.  En este enfoque, el sistema tiene acceso al cl√∫ster. <br><br>  <b>Pros</b> : <br><br><ol><li>  La seguridad est√° determinada por el repositorio de Git y la canalizaci√≥n de compilaci√≥n. </li><li>  La implementaci√≥n de gr√°ficos de Helm es m√°s f√°cil; hay soporte para los complementos de Helm. </li><li>  Los secretos son m√°s f√°ciles de administrar, porque los secretos se pueden usar en canalizaciones, as√≠ como almacenarse en Git de forma encriptada (dependiendo de las preferencias del usuario). </li><li>  Falta de vinculaci√≥n a una herramienta espec√≠fica, ya que se puede usar cualquiera de sus tipos. </li><li>  Las actualizaciones de la versi√≥n del contenedor pueden ser activadas por la tuber√≠a de ensamblaje. </li></ol><br>  <b>Contras</b> : <br><br><ol><li>  Los datos para acceder al cl√∫ster se encuentran dentro del sistema de compilaci√≥n. </li><li>  La actualizaci√≥n de los contenedores de implementaci√≥n es a√∫n m√°s f√°cil de hacer con el proceso de extracci√≥n. </li><li>  Depende mucho del sistema de CD, porque las tuber√≠as que necesitamos probablemente est√©n escritas originalmente para Gitlab Runners, y luego el equipo decide cambiar a Azure DevOps o Jenkins ... y tendr√° que migrar una gran cantidad de tuber√≠as de compilaci√≥n. </li></ol><br><h2>  En pocas palabras: empujar o tirar? </h2><br>  Como de costumbre, cada enfoque tiene sus pros y sus contras.  Algunas tareas son m√°s f√°ciles de realizar con una y m√°s dif√≠ciles con la otra.  Al principio, pas√© las implementaciones manualmente, pero despu√©s de encontrar varios art√≠culos sobre Weave Flux, decid√≠ implementar procesos GitOps para todos los proyectos.  Para las plantillas b√°sicas, result√≥ ser f√°cil, pero luego comenc√© a encontrar dificultades para trabajar con los gr√°ficos de Helm.  En ese momento, Weave Flux solo ofrec√≠a una versi√≥n rudimentaria de Helm Chart Operator, pero incluso ahora algunas tareas son m√°s complicadas debido a la necesidad de crear manualmente secretos y aplicarlos.  Puede decir que el enfoque de extracci√≥n es mucho m√°s seguro, ya que las credenciales del cl√∫ster no est√°n disponibles fuera de √©l, y esto aumenta la seguridad tanto que cuesta un esfuerzo adicional. <br><br>  Despu√©s de pensar un poco, llegu√© a la conclusi√≥n inesperada de que esto no es as√≠.  Si hablamos de componentes que requieren la m√°xima protecci√≥n, esta lista incluir√° el almacenamiento de secretos y sistemas CI / CD, repositorios Git.  La informaci√≥n dentro de ellos es muy vulnerable y necesita la m√°xima protecci√≥n.  Adem√°s, si alguien ingresa a su repositorio Git y puede empujar el c√≥digo all√≠, podr√° desplegar lo que quiera (independientemente del enfoque elegido, ser√° jalar o empujar) e infiltrarse en los sistemas de cl√∫ster.  Por lo tanto, los componentes m√°s importantes que requieren protecci√≥n son el repositorio Git y los sistemas CI / CD, no las credenciales del cl√∫ster.  Si tiene pol√≠ticas y medidas de seguridad bien ajustadas para sistemas de este tipo, y las credenciales de cl√∫ster se recuperan en tuber√≠as solo como secretos, la seguridad adicional del enfoque de extracci√≥n puede no ser tan valiosa como se pretend√≠a originalmente. <br><br>  Entonces, si el enfoque de extracci√≥n requiere m√°s tiempo y no brinda una ganancia en seguridad, ¬øno es l√≥gico usar solo el enfoque de inserci√≥n?  Pero alguien puede decir que en el enfoque de inserci√≥n est√° demasiado vinculado al sistema de CD y, tal vez, es mejor no hacerlo para facilitar las migraciones en el futuro. <br><br>  En mi opini√≥n (como siempre), debe usar lo que sea m√°s adecuado para un caso particular o combinar.  Personalmente, utilizo ambos enfoques: Weave Flux para implementaciones basadas en extracci√≥n que incluyen principalmente nuestros propios servicios, y un enfoque de inserci√≥n con Helm y complementos que simplifica la aplicaci√≥n de cartas Helm al cl√∫ster y le permite crear f√°cilmente secretos.  Creo que nunca habr√° una soluci√≥n √∫nica que sea adecuada para todos los casos, porque siempre hay muchos matices y dependen de la aplicaci√≥n espec√≠fica.  Al mismo tiempo, recomiendo GitOps: simplifica enormemente la vida y mejora la seguridad. <br><br>  Espero que mi experiencia en este tema ayude a determinar qu√© m√©todo es m√°s adecuado para su tipo de implementaci√≥n, y me complacer√° saber su opini√≥n. <br><br><h2>  PD Nota del traductor </h2><br>  En las desventajas del modelo de extracci√≥n, hay un punto sobre el hecho de que es dif√≠cil poner manifiestos renderizados en Git, sin embargo, no hay menos que la tuber√≠a de CD en el modelo de extracci√≥n vive por separado del despliegue y, de hecho, se convierte en una <i>tuber√≠a de</i> categor√≠a de <i>Aplicaci√≥n Continua</i> .  Por lo tanto, se requerir√°n a√∫n m√°s esfuerzos para recopilar su estado de todas las implementaciones y de alguna manera dar acceso a los registros / estado, y preferiblemente con referencia al sistema de CD. <br><br>  En este sentido, el modelo de empuje le permite dar al menos un cierto despliegue de garant√≠a, ya que la vida √∫til de la tuber√≠a puede ser igual a la vida √∫til del despliegue. <br><br>  Probamos ambos modelos y llegamos a las mismas conclusiones que el autor del art√≠culo: <br><br><ol><li>  El modelo pull es adecuado para nosotros para organizar actualizaciones de componentes del sistema en una gran cantidad de cl√∫steres (consulte el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo sobre addon-operator</a> ). </li><li>  El modelo de inserci√≥n basado en CI de GitLab es muy adecuado para implementar aplicaciones que utilizan gr√°ficos Helm.  En este despliegue, el despliegue'ov dentro de las tuber√≠as se supervisa utilizando la herramienta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">werf</a> .  Por cierto, en el contexto de nuestro proyecto, escuchamos el constante "GitOps" cuando discutimos los problemas apremiantes de los ingenieros de DevOps en nuestro stand en KubeCon Europe'19. </li></ol><br><h2>  PPS del traductor </h2><br>  Lea tambi√©n en nuestro blog: <br><br><ul><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Presentaci√≥n de werf 1.0 estable: qu√© tiene que ver GitOps con √©l, estado y planes</a> "; </li><li>  ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© es GitOps?</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Consejos y trucos de Kubernetes: transferencia de recursos en un cl√∫ster a Helm 2</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ampliaci√≥n y expansi√≥n de Kubernetes (informe de revisi√≥n y video)</a> ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456754/">https://habr.com/ru/post/456754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456738/index.html">Redes neuronales y aprendizaje profundo, cap√≠tulo 1: uso de redes neuronales para reconocer n√∫meros escritos a mano</a></li>
<li><a href="../456740/index.html">Inmersi√≥n en redes neuronales convolucionales. Parte 5/1 - 9</a></li>
<li><a href="../456744/index.html">10 problemas que resolv√≠ con recordatorios en mi tel√©fono inteligente</a></li>
<li><a href="../456746/index.html">Big data: gran responsabilidad, gran estr√©s y mucho dinero</a></li>
<li><a href="../456748/index.html">Impresora t√©rmica 2003 de un mercado de pulgas: ¬øqu√© puede hacer en 2019?</a></li>
<li><a href="../456756/index.html">¬øPor qu√© CockroachDB cambia la licencia de c√≥digo abierto?</a></li>
<li><a href="../456760/index.html">Crowdsourcing en ML Boot Camp. Consideramos mIOU sin im√°genes para una nueva tarea de Odnoklassniki</a></li>
<li><a href="../456762/index.html">De Witcher 3 a Cyberpunk: la evoluci√≥n del dise√±o de CD Projekt Quest</a></li>
<li><a href="../456768/index.html">4 dificultades para localizar juegos m√≥viles usando Fishing Clash como ejemplo - traducci√≥n</a></li>
<li><a href="../456770/index.html">Carrera armamentista</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>