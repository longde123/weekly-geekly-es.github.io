<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üå∞ ‚òÉÔ∏è üë®‚Äçüíº C # √© uma linguagem de baixo n√≠vel? üïô üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø üåö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sou um grande f√£ de tudo o que Fabien Sanglard faz, gosto do blog dele e leio os dois livros de capa a capa (descritos em um recente podcast da Hansle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C # √© uma linguagem de baixo n√≠vel?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443804/"> Sou um grande f√£ de tudo o que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fabien Sanglard</a> faz, gosto do blog dele e leio os <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">livros de</a> capa a capa (descritos em um recente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">podcast da Hansleminutes</a> ). <br><br>  Fabien recentemente escreveu um √≥timo post onde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">descriptografou um pequeno</a> tra√ßador de raios, desobstruindo o c√≥digo e explicando a matem√°tica de maneira fant√°stica.  Eu realmente recomendo reservar um tempo para ler isso! <br><br>  Mas isso me fez pensar <i><b>se √© poss√≠vel portar esse c√≥digo C ++ para C #</b></i> ?  Como tenho escrito bastante C ++ no meu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trabalho principal</a> ultimamente, achei que poderia tentar. <br><br>  Mais importante, por√©m, eu queria ter uma id√©ia melhor de <b>se o C # √© uma linguagem de baixo n√≠vel</b> ? <br><a name="habracut"></a><br>  Uma pergunta um pouco diferente, mas relacionada: quanto o C # √© adequado para a "programa√ß√£o do sistema"?  Sobre esse assunto, eu realmente recomendo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o excelente post de Joe Duffy de 2013</a> . <br><br><h1>  Porta de linha </h1><br>  Comecei simplesmente portando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">c√≥digo C ++ desofuscado</a> linha por linha para C #.  Era bem simples: parece que a verdade ainda est√° sendo dita que C # √© C ++++ !!! <br><br>  O exemplo mostra a estrutura de dados principal - 'vetor', aqui est√° uma compara√ß√£o, C ++ √† esquerda, C # √† direita: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/f14/ecc/cbd/f14ecccbd0091486caf57fc43fb2ac7f.png"></a> <br><br>  Portanto, existem algumas diferen√ßas sint√°ticas, mas como o .NET permite que voc√™ defina <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">seus pr√≥prios tipos de valor</a> , consegui obter a mesma funcionalidade.  Isso √© importante porque tratar 'vetor' como uma estrutura significa que podemos obter uma melhor "localidade de dados" e n√£o precisamos envolver o coletor de lixo .NET, porque os dados ser√£o enviados para a pilha (sim, eu sei que este √© um detalhe de implementa√ß√£o). <br><br>  Para obter mais informa√ß√µes sobre <code>structs</code> ou "tipos de valor" no .NET, consulte aqui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pilha versus pilha, tipo de valor versus tipo de refer√™ncia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tipos de valor versus tipos de refer√™ncia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mem√≥ria no .NET: para onde</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A verdade sobre os tipos de valor</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A pilha √© um detalhe de implementa√ß√£o, parte um</a> </li></ul><br>  Em particular, no √∫ltimo post de Eric Lippert, encontramos uma cita√ß√£o t√£o √∫til que deixa claro o que realmente s√£o ‚Äútipos de valor‚Äù: <br><br><blockquote>  Obviamente, o fato mais importante sobre os tipos de valores <b>n√£o s√£o os detalhes da implementa√ß√£o, <i>como eles s√£o alocados</i></b> , mas o <i>significado sem√¢ntico original do</i> "tipo de valor", a <b>saber, que ele <i>sempre</i> √© <i>copiado "por valor"</i></b> .  Se as informa√ß√µes de aloca√ß√£o fossem importantes, as chamar√≠amos de "tipos de heap" e "tipos de pilha".  Mas na maioria dos casos isso n√£o importa.  Na maioria das vezes, a sem√¢ntica da c√≥pia e identifica√ß√£o √© relevante. </blockquote><br>  Agora vamos ver como s√£o outros m√©todos em compara√ß√£o (novamente C ++ √† esquerda, C # √† direita), primeiro <code>RayTracing(..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4d0/3c5/277/4d03c5277ffa4f1e73462dab4edc7dd0.png"></a> <br><br>  Em seguida, <code>QueryDatabase (..)</code> : <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/2fc/c17/839/2fcc17839a00bfc619e14c7323e28f52.png"></a> <br><br>  (veja <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o post de Fabian</a> para uma explica√ß√£o do que essas duas fun√ß√µes fazem) <br><br>  Mas, novamente, o fato √© que o C # facilita a grava√ß√£o de c√≥digo C ++!  Nesse caso, a palavra-chave <code>ref</code> ajuda-nos ao m√°ximo, o que nos permite passar um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">valor por refer√™ncia</a> .  Usamos <code>ref</code> em chamadas de m√©todo h√° bastante tempo, mas recentemente foram feitos esfor√ßos para resolver <code>ref</code> outros lugares: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ref retorno e ref local</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">S√©rie C # 7, parte 9: ref struct</a> </li></ul><br>  Agora, <i>√†s vezes,</i> usar <code>ref</code> melhorar√° o desempenho, porque a estrutura n√£o precisar√° ser copiada. Consulte os benchmarks no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">post de Adam Stinix</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúPerformance traps ref locals e ref</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">return</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">in C #‚Äù</a> para obter mais informa√ß√µes. <br><br>  Mas o mais importante √© que esse script forne√ßa √† nossa porta C # o mesmo comportamento que o c√≥digo-fonte C ++.  Embora eu queira observar que os chamados "links gerenciados" n√£o s√£o exatamente os mesmos que "ponteiros", em particular, voc√™ n√£o pode executar aritm√©tica neles, veja mais aqui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ref return n√£o √© um ponteiro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ponteiros gerenciados</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Links n√£o s√£o endere√ßos</a> </li></ul><br><h2>  Desempenho </h2><br>  Assim, o c√≥digo foi bem portado, mas o desempenho tamb√©m importa.  Especialmente no tra√ßador de raios, que pode calcular o quadro por v√°rios minutos.  O c√≥digo C ++ cont√©m a vari√°vel <code>sampleCount</code> , que controla a qualidade final da imagem, com <code>sampleCount = 2</code> seguinte maneira: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/10a/17e/e2d/10a17ee2df5205f5fa8bd138693bc4a6.png"><br><br>  Obviamente, n√£o √© muito realista! <br><br>  Mas quando voc√™ obt√©m <code>sampleCount = 2048</code> , tudo parece <i>muito</i> melhor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/304/4b2/14d/3044b214da9027dd34dcbc19fdc75d2f.png"><br><br>  Mas come√ßar com <code>sampleCount = 2048</code> consome <b>muito</b> tempo, portanto, todas as outras execu√ß√µes s√£o executadas com um valor <code>2</code> para atender pelo menos um minuto.  Alterar <code>sampleCount</code> afeta apenas o n√∫mero de itera√ß√µes do loop de c√≥digo mais externo; consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta lista</a> para obter uma explica√ß√£o. <br><br><h3>  Resultados ap√≥s uma porta de linha ‚Äúing√™nua‚Äù </h3><br>  Para comparar substancialmente C ++ e C #, usei a ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">time-windows</a> , esta √© a porta do comando <code>time</code> unix.  Os resultados iniciais foram assim: <br><br><table><thead><tr><th></th><th>  C ++ (VS 2017) </th><th>  .NET Framework (4.7.2) </th><th>  .NET Core (2.2) </th></tr></thead><tbody><tr><td>  Tempo (s) </td><td>  47,40 </td><td>  80,14 </td><td>  78,02 </td></tr><tr><td>  No n√∫cleo (s) </td><td>  0,14 (0,3%) </td><td>  0,72 (0,9%) </td><td>  0,63 (0,8%) </td></tr><tr><td>  No espa√ßo do usu√°rio (s) </td><td>  43,86 (92,5%) </td><td>  73,06 (91,2%) </td><td>  70,66 (90,6%) </td></tr><tr><td>  N√∫mero de erros de falha de p√°gina </td><td>  1143 </td><td>  4818 </td><td>  5945 </td></tr><tr><td>  Conjunto de trabalho (KB) </td><td>  4232 </td><td>  13 624 </td><td>  17 052 </td></tr><tr><td>  Mem√≥ria extrudada (KB) </td><td>  95 </td><td>  172 </td><td>  154 </td></tr><tr><td>  Mem√≥ria n√£o preemptiva </td><td>  7 </td><td>  14 </td><td>  16 </td></tr><tr><td>  Trocar arquivo (KB) </td><td>  1460 </td><td>  10 936 </td><td>  11 024 </td></tr></tbody></table><br>  Inicialmente, vemos que o c√≥digo C # √© um pouco mais lento que a vers√£o C ++, mas est√° melhorando (veja abaixo). <br><br>  Mas vamos primeiro ver o que o .NET JIT faz conosco, mesmo com essa porta "ing√™nua" linha por linha.  Primeiro, ele faz um bom trabalho ao incorporar m√©todos auxiliares menores.  Isso pode ser visto na sa√≠da da excelente ferramenta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Inlining Analyzer</a> (verde = embutido): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cc/484/0a5/4cc4840a53f18362d3b4f3a4249fb2d5.png"></a> <br><br>  No entanto, ele n√£o incorpora todos os m√©todos, por exemplo, devido √† complexidade, <code>QueryDatabase(..)</code> ignorado: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/9e2/648/da2/9e2648da2a8ae7df5f94ceb77771c0ab.png"></a> <br><br>  Outro recurso do compilador .NET Just-In-Time (JIT) √© a convers√£o de chamadas de m√©todo espec√≠ficas para as instru√ß√µes de CPU correspondentes.  Podemos ver isso em a√ß√£o com a fun√ß√£o shell <code>sqrt</code> , aqui est√° o c√≥digo fonte do C # (observe a chamada para <code>Math.Sqrt</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); }</span></span></code> </pre> <br>  E aqui est√° o c√≥digo do assembler que o .NET JIT gera: n√£o h√° chamada para <code>Math.Sqrt</code> e a instru√ß√£o do processador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vsqrtsd √© usada</a> : <br><br><pre> <code class="plaintext hljs">; Assembly listing for method Program:sqrtf(float):float ; Emitting BLENDED_CODE for X64 CPU with AVX - Windows ; Tier-1 compilation ; optimized code ; rsp based frame ; partially interruptible ; Final local variable assignments ; ; V00 arg0 [V00,T00] ( 3, 3 ) float -&gt; mm0 ;# V01 OutArgs [V01 ] ( 1, 1 ) lclBlk ( 0) [rsp+0x00] "OutgoingArgSpace" ; ; Lcl frame size = 0 G_M8216_IG01: vzeroupper G_M8216_IG02: vcvtss2sd xmm0, xmm0 vsqrtsd xmm0, xmm0 vcvtsd2ss xmm0, xmm0 G_M8216_IG03: ret ; Total bytes of code 16, prolog size 3 for method Program:sqrtf(float):float ; ============================================================</code> </pre> <br>  (para obter esse problema, siga <a href="">estas instru√ß√µes</a> , use o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">complemento VS2019 "Disasmo"</a> ou consulte o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">SharpLab.io</a> ) <br><br>  Essas substitui√ß√µes tamb√©m s√£o conhecidas como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">intr√≠nsecas</a> e, no c√≥digo abaixo, podemos ver como o JIT as gera.  Esse trecho mostra o mapeamento apenas para <code>AMD64</code> , mas o JIT tamb√©m tem como alvo <code>X86</code> , <code>ARM</code> e <code>ARM64</code> , o m√©todo completo <a href="">aqui</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Compiler::IsTargetIntrinsic(CorInfoIntrinsics intrinsicId) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(_TARGET_AMD64_) || (defined(_TARGET_X86_) &amp;&amp; !defined(LEGACY_BACKEND)) switch (intrinsicId) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// AMD64/x86 has SSE2 instructions to directly compute sqrt/abs and SSE4.1 // instructions to directly compute round/ceiling/floor. // // </span></span><span class="hljs-doctag"><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span></span><span class="hljs-meta"><span class="hljs-comment"> Because the x86 backend only targets SSE for floating-point code, // it does not treat Sine, Cosine, or Round as intrinsics (JIT32 // implemented those intrinsics as x87 instructions). If this poses // a CQ problem, it may be necessary to change the implementation of // the helper calls to decrease call overhead or switch back to the // x87 instructions. This is tracked by #7097. case CORINFO_INTRINSIC_Sqrt: case CORINFO_INTRINSIC_Abs: return true; case CORINFO_INTRINSIC_Round: case CORINFO_INTRINSIC_Ceiling: case CORINFO_INTRINSIC_Floor: return compSupports(InstructionSet_SSE41); default: return false; } ... }</span></span></span></span></code> </pre> <br>  Como voc√™ pode ver, alguns m√©todos s√£o implementados, como <code>Sqrt</code> e <code>Abs</code> , enquanto outros usam fun√ß√µes de tempo de execu√ß√£o C ++, por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">powf</a> . <br><br>  Todo esse processo √© muito bem explicado no artigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Como o Math.Pow () √© implementado no .NET Framework?"</a>  , tamb√©m pode ser visto na fonte CoreCLR: <br><br><ul><li>  Implementa√ß√£o de <code><a href="">COMSingle::Pow</a></code> , ou seja, o m√©todo que √© executado se <code>MathF.Pow(..)</code> chamado de c√≥digo C # <br></li><li>  Mapeamento na <a href="">implementa√ß√£o do m√©todo de tempo de execu√ß√£o C</a> <br></li><li>  Vers√£o <a href="">de</a> plataforma cruzada <a href="">da implementa√ß√£o powf</a> que fornece o mesmo comportamento no sistema operacional </li></ul><br><h3>  Resultados ap√≥s melhorias simples no desempenho </h3><br>  Gostaria de saber se voc√™ pode melhorar imediatamente a porta ing√™nua linha por porta.  Ap√≥s alguns perfis, fiz duas grandes mudan√ßas: <br><br><ul><li>  Removendo a inicializa√ß√£o de matriz embutida </li><li>  Substituindo as fun√ß√µes de <code>Math.XXX(..)</code> por an√°logos de <code>MathF.()</code> </li></ul><br>  Essas altera√ß√µes s√£o explicadas em mais detalhes abaixo. <br><br><h4>  Removendo a inicializa√ß√£o de matriz embutida </h4><br>  Para obter mais informa√ß√µes sobre por que isso √© necess√°rio, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta excelente resposta de estouro de pilha</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Andrei Akinshin</a> , juntamente com refer√™ncias e c√≥digo de montador.  Ele chega √† seguinte conclus√£o: <br><br><blockquote>  <b>Conclus√£o</b> <br><br><ul><li>  <i><b>O .NET armazena em cache matrizes locais codificadas?</b></i>  Como os que colocam o compilador Roslyn em metadados. </li><li>  <i><b>Nesse caso, haver√° sobrecarga?</b></i>  Infelizmente, sim: para cada chamada, o JIT copiar√° o conte√∫do da matriz dos metadados, o que leva mais tempo em compara√ß√£o com uma matriz est√°tica.  O tempo de execu√ß√£o tamb√©m seleciona objetos e cria tr√°fego na mem√≥ria. </li><li>  <i><b>Existe alguma necessidade de se preocupar com isso?</b></i>  Possivelmente.  Se esse for um m√©todo ativo e voc√™ desejar obter um bom n√≠vel de desempenho, precisar√° usar uma matriz est√°tica.  Se esse √© um m√©todo frio que n√£o afeta o desempenho do aplicativo, voc√™ provavelmente precisar√° escrever um c√≥digo-fonte ‚Äúbom‚Äù e colocar a matriz na √°rea do m√©todo. </li></ul></blockquote><br>  Voc√™ pode ver as altera√ß√µes feitas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste diff</a> . <br><br><h4>  Usando fun√ß√µes MathF em vez de Math </h4><br>  Em segundo lugar, e mais importante, eu melhorei significativamente o desempenho fazendo as seguintes altera√ß√µes: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> NETSTANDARD2_1 || NETCOREAPP2_0 || NETCOREAPP2_1 || NETCOREAPP2_2 || NETCOREAPP3_0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// intnv square root public static Vec operator !(Vec q) { return q * (1.0f / MathF.Sqrt(q % q)); } #else public static Vec operator !(Vec q) { return q * (1.0f / (float)Math.Sqrt(q % q)); } #endif</span></span></span></span></code> </pre> <br>  A partir do .NET Standard 2.1, existem implementa√ß√µes concretas de fun√ß√µes matem√°ticas comuns de <code>float</code> .  Eles est√£o localizados na classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">System.MathF</a> .  Para saber mais sobre essa API e sua implementa√ß√£o, consulte aqui: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nova API matem√°tica com precis√£o √∫nica</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Adicione fun√ß√µes matem√°ticas com precis√£o √∫nica</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Fornecendo um conjunto de testes de unidade para novas APIs matem√°ticas de precis√£o √∫nica</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">System.Math e System.MathF devem ser implementados no c√≥digo gerenciado, n√£o como FCALL para o tempo de execu√ß√£o C</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Movendo Math.Abs ‚Äã‚Äã(double) e Math.Abs ‚Äã‚Äã(float) para implementar no c√≥digo gerenciado</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Design e processo para adicionar ferramentas incorporadas espec√≠ficas da plataforma ao .NET</a> </li></ul><br>  Ap√≥s essas altera√ß√µes, a diferen√ßa no desempenho do c√≥digo C # e C ++ foi reduzida para cerca de 10%: <br><br><table><thead><tr><th></th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  TC do .NET Core (2.2) DESATIVADO </th><th>  TC do .NET Core (2.2) ativado </th></tr></thead><tbody><tr><td>  Tempo (s) </td><td>  41,38 </td><td>  58,89 </td><td>  46,04 </td><td>  44,33 </td></tr><tr><td>  No n√∫cleo (s) </td><td>  0,05 (0,1%) </td><td>  0,06 (0,1%) </td><td>  0,14 (0,3%) </td><td>  0,13 (0,3%) </td></tr><tr><td>  No espa√ßo do usu√°rio (s) </td><td>  41,19 (99,5%) </td><td>  58,34 (99,1%) </td><td>  44,72 (97,1%) </td><td>  44,03 (99,3%) </td></tr><tr><td>  N√∫mero de erros de falha de p√°gina </td><td>  1119 </td><td>  4749 </td><td>  5776 </td><td>  5661 </td></tr><tr><td>  Conjunto de trabalho (KB) </td><td>  4136 </td><td>  13.440 </td><td>  16.788 </td><td>  16.652 </td></tr><tr><td>  Mem√≥ria extrudada (KB) </td><td>  89 </td><td>  172 </td><td>  150 </td><td>  150 </td></tr><tr><td>  Mem√≥ria n√£o preemptiva </td><td>  7 </td><td>  13 </td><td>  16 </td><td>  16 </td></tr><tr><td>  Trocar arquivo (KB) </td><td>  1428 </td><td>  10 904 </td><td>  10 960 </td><td>  11 044 </td></tr></tbody></table><br>  TC - compila√ß√£o multin√≠vel, compila√ß√£o em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">camadas</a> ( <i>suponho</i> que ser√° ativada por padr√£o no .NET Core 3.0) <br><br>  Para completar, eis os resultados de v√°rias execu√ß√µes: <br><br><table><thead><tr><th>  Executar </th><th>  C ++ (VS C ++ 2017) </th><th>  .NET Framework (4.7.2) </th><th>  TC do .NET Core (2.2) DESATIVADO </th><th>  TC do .NET Core (2.2) ativado </th></tr></thead><tbody><tr><td>  TestRun-01 </td><td>  41,38 </td><td>  58,89 </td><td>  46,04 </td><td>  44,33 </td></tr><tr><td>  TestRun-02 </td><td>  41.19 </td><td>  57,65 </td><td>  46,23 </td><td>  45,96 </td></tr><tr><td>  TestRun-03 </td><td>  42,17 </td><td>  62,64 </td><td>  46,22 </td><td>  48,73 </td></tr></tbody></table><br>  <b>Nota</b> : a diferen√ßa entre o .NET Core e o .NET Framework se deve √† aus√™ncia da API MathF no .NET Framework 4.7.2. Para obter mais informa√ß√µes, consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">o t√≠quete de suporte .Net Framework (4.8?) Para o padr√£o de rede 2.1</a> . <br><br><h1>  Aumentar ainda mais a produtividade </h1><br>  Estou certo de que o c√≥digo ainda pode ser melhorado! <br><br>  Se voc√™ estiver interessado em resolver a diferen√ßa de desempenho, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui est√° o c√≥digo C #</a> .  Para compara√ß√£o, voc√™ pode assistir ao c√≥digo do assembler C ++ no excelente servi√ßo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compiler Explorer</a> . <br><br>  Por fim, se isso ajudar, aqui est√° a sa√≠da do criador de perfil do Visual Studio com uma exibi√ß√£o "hot path" (ap√≥s as melhorias de desempenho descritas acima): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b78/3df/2e6/b783df2e692b62f492b78c8e7affcbf4.png"></a> <br><br><h1>  C # √© um idioma de baixo n√≠vel? </h1><br>  Ou mais especificamente: <br><br><blockquote>  <b><b>Quais recursos de idioma da funcionalidade C # / F # / VB.NET ou BCL / Runtime significam programa√ß√£o "baixo n√≠vel" *?</b></b> </blockquote><br>  * Sim, entendo que "n√≠vel baixo" √© um termo subjetivo. <br><br>  <b>Nota:</b> cada desenvolvedor de C # tem sua pr√≥pria id√©ia do que √© o ‚Äúbaixo n√≠vel‚Äù, essas fun√ß√µes ser√£o consideradas garantidas pelos programadores de C ++ ou Rust. <br><br>  Aqui est√° a lista que eu fiz: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ref retorna e ref locals</a> <br><ul><li>  ‚ÄúPassagem e retorno por refer√™ncia para evitar a c√≥pia de grandes estruturas.  Tipos e mem√≥ria seguros podem ser ainda <b>mais r√°pidos do</b> que inseguros! ‚Äù </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C√≥digo inseguro no .NET</a> <br><ul><li>  ‚ÄúA linguagem C # principal, conforme definida nos cap√≠tulos anteriores, √© muito diferente de C e C ++, pois n√£o possui ponteiros como tipo de dados.  Em vez disso, o C # fornece links e a capacidade de criar objetos controlados pelo coletor de lixo.  Esse design, combinado com outros recursos, torna o C # uma linguagem muito mais segura que o C ou C ++. ‚Äù </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ponteiros gerenciados no .NET</a> <br><ul><li>  ‚ÄúExiste outro tipo de ponteiro no CLR - um ponteiro gerenciado.  Ele pode ser definido como um tipo mais geral de link que pode apontar para outros locais, e n√£o apenas para o in√≠cio do objeto. ‚Äù </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">S√©rie C # 7, parte 10: Span &lt;T&gt; e gerenciamento de mem√≥ria universal</a> <br><ul><li>  ‚ÄúSystem.Span &lt;T&gt; √© apenas um tipo de pilha ( <code>ref struct</code> ) que agrupa todos os padr√µes de acesso √† mem√≥ria; √© um tipo para acesso universal √† mem√≥ria cont√≠nua.  Podemos imaginar uma implementa√ß√£o Span com uma refer√™ncia fict√≠cia e um comprimento que aceite todos os tr√™s tipos de acesso √† mem√≥ria ". </li></ul><br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compatibilidade ("Guia de Programa√ß√£o em C #")</a> <br><ul><li>  "O .NET Framework fornece interoperabilidade com c√≥digo n√£o gerenciado por meio de servi√ßos de chamada de plataforma, o <code>System.Runtime.InteropServices</code> , compatibilidade com C ++ e compatibilidade COM (interoperabilidade COM)." </li></ul></li></ul><br>  Tamb√©m chorei no Twitter e tenho muito mais op√ß√µes para inclus√£o na lista: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ben Adams</a> : ‚ÄúFerramentas internas para plataformas (instru√ß√µes da CPU)‚Äù <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mark Gravell</a> : ‚ÄúO SIMD via Vector (que combina bem com o Span) √© * bastante * baixo;  O .NET Core deve (em breve?) Oferecer ferramentas incorporadas diretas √† CPU para uso mais expl√≠cito de instru√ß√µes espec√≠ficas da CPU ‚Äù <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mark Gravell</a> : ‚ÄúJIT poderoso: coisas como elis√£o de intervalo em matrizes / intervalos, al√©m de usar regras por estrutura-T para remover grandes partes de c√≥digo que o JIT sabe com certeza que elas n√£o est√£o dispon√≠veis para esse T ou para o seu espec√≠fico CPU (BitConverter.IsLittleEndian, Vector.IsHardwareAccelerated, etc.) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kevin Jones</a> : ‚ÄúEu mencionaria especialmente as classes <code>MemoryMarshal</code> e <code>Unsafe</code> , e talvez algumas outras coisas nos <code>System.Runtime.CompilerServices</code> ‚Äù <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Theodoros Chatsigiannakis</a> : "Voc√™ tamb√©m pode incluir <code>__makeref</code> e o resto" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">damageeboy</a> : "A capacidade de gerar dinamicamente um c√≥digo que corresponda exatamente √† entrada esperada, uma vez que este √∫ltimo s√≥ ser√° conhecido em tempo de execu√ß√£o e poder√° ser alterado periodicamente?" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Robert Hacken</a> : "Emiss√£o din√¢mica de IL" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Victor Baybekov</a> : ‚ÄúStackalloc n√£o foi mencionado.  Tamb√©m √© poss√≠vel escrever IL pura (n√£o din√¢mica, portanto, √© salva em uma chamada de fun√ß√£o), por exemplo, use <code>ldftn</code> cache e chame-os atrav√©s de <code>calli</code> .  H√° um modelo de projeto no VS2017 que torna isso trivial reescrevendo os m√©todos extern + MethodImplOptions.ForwardRef + ilasm.ex ¬ª <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Victor Baybekov</a> : ‚ÄúMethodImplOptions.AggressiveInlining tamb√©m‚Äú ativa a programa√ß√£o de baixo n√≠vel ‚Äùno sentido em que permite escrever c√≥digo de alto n√≠vel com muitos m√©todos pequenos e ainda controlar o comportamento do JIT para obter um resultado otimizado.  Caso contr√°rio, copie e cole centenas de m√©todos LOC ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ben Adams</a> : ‚ÄúUsando as mesmas conven√ß√µes de chamada (ABI) que na plataforma base ep / chama para intera√ß√£o?‚Äù <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Victor Baibekov</a> : ‚ÄúAl√©m disso, como voc√™ mencionou #fsharp - ela possui uma <code>inline</code> que funciona no n√≠vel de IL at√© JIT, portanto foi considerada importante no n√≠vel de idioma.  C # isso n√£o √© suficiente (at√© agora) para lambdas, que s√£o sempre chamadas virtuais, e as solu√ß√µes alternativas geralmente s√£o estranhas (gen√©ricos limitados) " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alexandre Mutel</a> : ‚ÄúNovo SIMD incorporado, p√≥s-processamento da classe Unsafe Utility / IL (por exemplo, personalizado, Fody, etc.).  Para C # 8.0, pr√≥ximos ponteiros de fun√ß√£o ... " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Alexandre Mutel</a> : ‚ÄúEm rela√ß√£o √† IL, o F # suporta diretamente a IL em um idioma, por exemplo‚Äù <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">OmariO</a> : ‚Äú <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Prim√°rios bin√°rios</a> .  N√≠vel baixo, mas seguro " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Koji Matsui</a> : ‚ÄúE o seu pr√≥prio montador embutido?  √â dif√≠cil para o kit de ferramentas e o tempo de execu√ß√£o, mas pode substituir a solu√ß√£o p / invoke atual e implementar o c√≥digo incorporado, se houver " <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Frank A. Kruger</a> : "Ldobj, stobj, initobj, initblk, cpyblk" <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Conrad Coconut</a> : ‚ÄúTalvez fazendo streaming de armazenamento local?  Buffers de tamanho fixo?  Voc√™ provavelmente deve mencionar restri√ß√µes n√£o gerenciadas e tipos blittable :) ‚Äù <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sebastiano Mandala</a> : ‚ÄúApenas uma pequena adi√ß√£o a tudo o que foi dito: que tal algo simples, como organizar estruturas e como o preenchimento e o alinhamento da mem√≥ria e da ordem dos campos podem afetar o desempenho do cache?  Isso √© algo que eu mesmo devo explorar. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nino Floris</a> : "Constantes incorporadas via readonlyspan, stackalloc, finalizadores, WeakReference, representantes abertos, MethodImplOptions, MemoryBarriers, TypedReference, varargs, SIMD, Unsafe.AsRef, podem definir os tipos de estruturas exatamente de acordo com o layout (usado para TaskAwaiter e sua vers√£o)" </li></ul><br>  <b>Portanto, no final, eu diria que o C # certamente permite que voc√™ escreva um c√≥digo parecido com o C ++ e, em combina√ß√£o com as bibliotecas de tempo de execu√ß√£o e de classe base, fornece muitas fun√ß√µes de baixo n√≠vel.</b> <br><br><h1>  Leitura adicional </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Modelos para C # de alto desempenho.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Federico Andres Lois</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Question√°rio de desempenho # 6 - Dicion√°rio chin√™s-ingl√™s</a> (desde 2005, dois blogueiros da Microsoft lutam a batalha do desempenho do C ++ contra o C #) <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Teste de Desempenho # 6 - Conclus√£o, explora√ß√£o espacial</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Qu√£o mais r√°pido √© o C ++ que o C #?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Otimiza√ß√£o de C # gerenciado e c√≥digo C ++ nativo</a> (2005) </li></ul><br>  Compilador de explos√£o da unidade: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Como o Unity criou (um subconjunto) de C # t√£o r√°pido quanto C ++</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Compilador Unity Burst: F√°cil Otimiza√ß√£o de Desempenho</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Desbravador Di√°rio, Parte 3: C # e Unity Burst</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">C ++, C # e Unidade</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mergulhe fundo no compilador Burst - Unite LA</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443804/">https://habr.com/ru/post/pt443804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443788/index.html">No√ß√µes b√°sicas de roteamento est√°tico no Mikrotik RouterOS</a></li>
<li><a href="../pt443790/index.html">Erro do sobrevivente</a></li>
<li><a href="../pt443792/index.html">Erros t√≠picos ao trabalhar com o PostgreSQL. Parte 2</a></li>
<li><a href="../pt443794/index.html">As principais orienta√ß√µes para startups de TI no campo da venda de im√≥veis</a></li>
<li><a href="../pt443798/index.html">Zotero hacks: armazenamento sincronizado ilimitado e seu uso suave com o rmarkdown</a></li>
<li><a href="../pt443808/index.html">An√°lise de garotas com baixa responsabilidade social (Cobrada com Power BI, Qlik Sense, Tableau)</a></li>
<li><a href="../pt443810/index.html">Quanto ganham os desenvolvedores de diferentes qualifica√ß√µes, 2018</a></li>
<li><a href="../pt443812/index.html">Como implementar uma linguagem de programa√ß√£o em JavaScript. Parte 2: Int√©rprete</a></li>
<li><a href="../pt443814/index.html">Dar √© o meu "antigo neg√≥cio"</a></li>
<li><a href="../pt443816/index.html">Minist√©rio das Comunica√ß√µes insiste em um √∫nico operador 5G</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>