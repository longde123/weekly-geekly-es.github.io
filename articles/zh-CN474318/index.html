<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌛 🥘 🤝 什么是虚拟表表？ 👨🏾‍🍳 📰 🧤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在Slack上，我遇到了C ++首字母缩略词词汇表的新首字母缩略词 ：“ VTT”。 Godbolt ： 



test.o: In function `MyClass': test.cc:3: undefined reference to `VTT for MyClass'  
 在本文中，“ ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>什么是虚拟表表？</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474318/"> 在Slack上，我遇到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++首字母缩略词词汇表</a>的新首<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">字母缩略词</a> ：“ VTT”。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Godbolt</a> ： <br><br><pre><code class="plaintext hljs">test.o: In function `MyClass': test.cc:3: undefined reference to `VTT for MyClass'</code> </pre> <br> 在本文中，“ VTT”是指“虚拟表表”。 这是创建一些本身从虚拟基类继承的基类时使用的辅助数据结构（在Itanium C ++ ABI中）。  VTT遵循与虚拟​​表（vtable）和类型信息（typeinfo）相同的布局规则，因此，如果您遇到上述错误，则可以在精神上用“ vtable”代替“ VTT”并开始调试。  （很可能您未定义该类的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">键功能</a> ）。 为了了解为什么需要VTT或类似的结构，让我们从基础开始。 <br><a name="habracut"></a><br><h3> 非虚拟继承的设计顺序 </h3><br> 当我们有一个继承层次结构时，基类是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从最基本的开始</a>构造的。 要构造Charlie，我们必须首先构造其父类MrsBucket和MrBucket，以递归方式来构造MrBucket，首先必须构造其父类GrandmaJosephine和GrandpaJoe。 <br><br> 像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ABCDE</span></span></code> </pre> <br><h3> 虚拟基类的设计顺序 </h3><br> 但是虚拟继承会混淆所有信息！ 使用虚拟继承，我们可以拥有菱形的层次结构，其中两个不同的父类可以共享一个共同的祖先。 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">G</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">M</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> G {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> M, F {}; <span class="hljs-comment"><span class="hljs-comment">//     // GMFE</span></span></code> </pre> <br> 在最后一节中，每个构造函数负责调用其基类的构造函数。 但是现在我们有了虚拟继承，并且构造函数M和F必须以某种方式知道不必构造G，因为它很常见。 如果在这种情况下M和F负责构造基础对象，则公共基础对象将被构造两次，这不是很好。 <br><br> 为了使用虚拟继承子对象，Itanium C ++ ABI将每个构造函数分为两部分：基础对象构造函数和完整对象构造函数。 基础对象的构造函数负责构造所有非虚拟继承子对象（及其子对象，并将其vptr安装在其vtable上，并在C ++代码中以大括号运行代码）。 每次创建完整的C ++对象时都会调用该完整对象的构造函数，该构造函数负责构造派生对象的虚拟继承的所有子对象，然后进行其余工作。 <br><br> 考虑上一节中的ABCDE示例与以下示例之间的区别： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> A {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> C {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> :</span></span> B, D {}; <span class="hljs-comment"><span class="hljs-comment">//     // ACBDE</span></span></code> </pre> <br> 完整对象E的构造函数首先调用虚拟子对象A和C的基础对象的构造函数； 然后调用基本非虚拟继承对象B和D的构造函数，B和D不再分别负责构造A和C。 <br><br><h3> 设计vtable表 </h3><br> 假设我们有一个带有一些虚拟方法的类，例如（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Godbolt</a> ）： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> {</span></span> Cat() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(<span class="hljs-string"><span class="hljs-string">"meow"</span></span>); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lion</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> roar = <span class="hljs-string"><span class="hljs-string">"roar"</span></span>; Lion() { poke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ roar += <span class="hljs-string"><span class="hljs-string">'!'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(roar.c_str()); } };</code> </pre> <br> 构造Lion时，首先要构造基本的Cat子对象。  Cat的构造函数调用poke（）。 此时，我们只有一个Cat对象-我们尚未初始化制作Lion对象所需的成员数据。 如果Cat构造函数调用Lion :: poke（），则可以尝试更改std :: string roar的未初始化成员，从而得到UB。 因此，C ++标准要求我们在Cat构造函数中执行此操作，对poke（）虚拟方法的调用应调用Cat :: poke（），而不是Lion :: poke（）！ <br><br> 没问题 编译器只是通过将对象的vptr设置为Cat对象的vtable来使Cat :: Cat（）（基础对象的版本和完整对象的版本）开始。  Lion :: Lion（）将调用Cat :: Cat（），然后将vptr重置为Lion中Cat对象的vtable表的指针，然后再运行括号中的代码。 没问题！ <br><br><h3> 虚拟继承偏移 </h3><br> 让猫实际上继承自动物。 然后，用于Cat的vtable不仅存储Cat虚拟成员函数的函数指针，而且还存储Cat内部的Animal虚拟子对象的偏移量。  （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">天哪</a> 。） <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = <span class="hljs-string"><span class="hljs-string">"hi"</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> Animal { Cat() { <span class="hljs-built_in"><span class="hljs-built_in">puts</span></span>(data); } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nermal</span></span></span><span class="hljs-class"> :</span></span> Cat {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Garfield</span></span></span><span class="hljs-class"> :</span></span> Cat { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; };</code> </pre> <br>  Cat构造函数查询成员Animal ::数据。 如果此Cat对象是Nermal对象的基础子对象，则其成员数据位于vptr后面的偏移量8处。 但是，如果Cat对象是Garfield对象的基础子对象，则成员数据位于vptr和Garfield :: padding之后的偏移量16。 为了解决这个问题，Itanium ABI将虚拟基础对象的偏移量存储在Cat对象的vtable中。  Cat-in-Nermal的vtable保留以下事实：动物（基础Cat子对象）存储在偏移量8处；  Cat-in-Garfield的vtable保留以下事实：动物（基础Cat子对象）存储在偏移量16处。 <br><br> 现在，将其与上一节结合。 编译器必须确保Cat :: Cat（）（基础对象版本和完整对象版本）都可以通过在类型为Cat-in-Nermal的vtable上或在Cat-in-Garfield的vtable上安装vptr来启动，具体取决于类型最衍生的设施！ 但是它是如何工作的呢？ <br><br> 派生程度最高的对象的完整对象的构造函数必须预先计算在构造对象时他希望基础子对象的vptr引用哪个表vtable，然后派生度最大的对象的完整对象的构造函数必须将此信息传递给基础子对象的基础对象的构造函数作为隐藏参数！ 让我们看一下Cat :: Cat（）（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Godbolt</a> ）的生成代码： <br><br><pre> <code class="cpp hljs">_ZN3CatC1Ev: #    Cat movq $_ZTV3Cat+<span class="hljs-number"><span class="hljs-number">24</span></span>, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = &amp;vtable-for-Cat; retq _ZN3CatC2Ev: #     Cat movq (%rsi), %rax # fetch a value from rsi movq %rax, (%rdi) # this-&gt;vptr = *rsi; retq</span></span></code> </pre> <br> 基础对象的构造函数不仅接受％rdi中的此隐藏参数，还接受％rsi中的隐藏VTT参数！ 基础对象构造函数从（％rsi）加载地址，并将该地址存储在Cat对象的vtable中。 <br><br> 调用基本Cat对象的构造函数的人都有责任预测应在vptr中写入哪个Cat :: Cat（）地址，并将（％rsi）中的指针设置为该地址。 <br><br><h3> 为什么我们需要另一种身份？ </h3><br> 考虑完整的Nermal对象的构造函数。 <br><br><pre> <code class="cpp hljs">_ZN3CatC2Ev: #    <span class="hljs-function"><span class="hljs-function">Cat </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">movq</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rsi)</span></span></span><span class="hljs-function">, %rax #    rsi movq %rax, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(%rdi)</span></span></span><span class="hljs-function"> </span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-meta"># this-&gt;vptr = *rsi; retq _ZN6NermalC1Ev: #    Nermal pushq %rbx movq %rdi, %rbx movl $_ZTT6Nermal+8, %esi # %rsi = &amp;VTT-for-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq _ZTT6Nermal: .quad _ZTV6Nermal+24 # vtable-for-Nermal .quad _ZTC6Nermal0_3Cat+24 # construction-vtable-for-Cat-in-Nermal</span></span></span></span></code> </pre> <br> 为什么_ZTC6Nermal0_3Cat + 24位于数据部分中，并且其地址传递给％rsi，而不是直接传递_ZTC6Nermal0_3Cat + 24？ <br><br><pre> <code class="cpp hljs">#   ? _ZN3CatC2Ev: #     Cat movq %rsi, (%rdi) <span class="hljs-meta"><span class="hljs-meta"># this-&gt;vptr = rsi; retq _ZN6NermalC1Ev: #     Nermal pushq %rbx movq %rdi, %rbx movl $_ZTC6Nermal0_3Cat+24, %esi # %rsi = &amp;construction-vtable-for-Cat-in-Nermal callq _ZN3CatC2Ev #     Cat movq $_ZTV6Nermal+24, (%rbx) # this-&gt;vptr = &amp;vtable-for-Nermal popq %rbx retq</span></span></code> </pre> <br> 这是因为我们可以具有多个继承级别！ 在每个继承级别，基础对象的构造函数都应设置vptr，然后可能将控制权进一步沿链向下传递到下一个基础构造函数，后者可以将vptrs设置为其他值。 这意味着指向vtable的列表或指针表。 <br><br> 这是一个具体示例（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Godbolt</a> ）： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> member_of_vb = <span class="hljs-number"><span class="hljs-number">42</span></span>; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grandparent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> VB { Grandparent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parent</span></span></span><span class="hljs-class"> :</span></span> Grandparent { Parent() {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gretel</span></span></span><span class="hljs-class"> :</span></span> Parent { Gretel() : VB{<span class="hljs-number"><span class="hljs-number">1000</span></span>} {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hansel</span></span></span><span class="hljs-class"> :</span></span> Parent { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> padding; Hansel() : VB{<span class="hljs-number"><span class="hljs-number">2000</span></span>} {} };</code> </pre> <br>  Grandparent基本构造函数对象必须将其vptr设置为Grandparent-其他，这是派生程度最高的类。  Parent基础对象的构造函数必须首先使用适当的％rsi调用Grandparent :: Grandparent（），然后将vptr设置为Parent，这是派生程度最高的类。 为Gretel实施此方法： <br><br><pre> <code class="cpp hljs">Gretel::Gretel() [  ]: pushq %rbx movq %rdi, %rbx movl $<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>(%rdi) <span class="hljs-meta"><span class="hljs-meta"># imm = 0x3E8 movl $VTT for Gretel+8, %esi callq Parent::Parent() [  ] movq $vtable for Gretel+24, (%rbx) popq %rbx retq VTT for Gretel: .quad vtable for Gretel+24 .quad construction vtable for Parent-in-Gretel+24 .quad construction vtable for Grandparent-in-Gretel+24</span></span></code> </pre> <br> 您可以在Godbolt中看到，Parent类的基础对象的构造函数首先调用％rsi + 8的Grandparent :: Grandparent（），然后将其自己的vptr设置为（％rsi）。 因此，在这里我们利用的事实是，可以说，Gretel精心铺设了一条面包屑路径，在构建过程中，她的所有基层都遵循了这一路径。 <br><br> 析构函数（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Godbolt</a> ）中使用了相同的VTT。 据我所知，VTT表的空行从未使用过。  Gretel构造函数将Gretel + 24的vtable加载到vptr中，但他知道此地址是静态的，因此不需要从VTT加载。 我认为保留表的零行仅出于历史原因。  （当然，编译器不能只是将其丢弃，因为这将违反Itanium ABI，并且不可能链接到遵循Itanium-ABI的旧代码）。 <br><br> 就是这样，我们查看了一个虚拟表或VTT表。 <br><br><h3> 进一步资料 </h3><br> 您可以在以下位置找到VTT信息： <br><br>  StackOverflow：“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">什么是课程的VTT？</a>  ” <br>  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://web.archive.org/web/20190930143149/">GCC C ++编译器v4.0.1中关于多重继承的VTable注意</a> ”（Morgan Deters，2005年） <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Itanium C ++ ABI的</a> “ VTT订单”部分 <br><br> 最后，我必须重申VTT是Itanium C ++ ABI的功能，并且在Linux，OSX等上使用。  Windows上使用的MSVC ABI没有VTT，并且对虚拟继承使用完全不同的机制。 我（到目前为止）对MSVC ABI几乎一无所知，但也许有一天我会发现所有内容并撰写有关它的文章！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474318/">https://habr.com/ru/post/zh-CN474318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474306/index.html">使指向，焦点和活动状态的样式不同。</a></li>
<li><a href="../zh-CN474308/index.html">用Python编写的HTTP API的类型：Instagram体验</a></li>
<li><a href="../zh-CN474310/index.html">CSS中有随机数吗？</a></li>
<li><a href="../zh-CN474312/index.html">在Windows Server Core上安装GUI</a></li>
<li><a href="../zh-CN474316/index.html">自制电动汽车-第1部分。一切从头开始，我如何在YouTube上获得1,000,000次观看</a></li>
<li><a href="../zh-CN474320/index.html">DDD社区危机</a></li>
<li><a href="../zh-CN474322/index.html">ScalaConf 2019-John Preacher，圣杯和Haskell教授</a></li>
<li><a href="../zh-CN474324/index.html">太阳为什么绕地球公转</a></li>
<li><a href="../zh-CN474326/index.html">了解CI和CD之间的区别：“如果某事导致疼痛，请多做点事情”</a></li>
<li><a href="../zh-CN474330/index.html">＃320移动开发人员的有趣材料摘要（10月28日至11月3日）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>