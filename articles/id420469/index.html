<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤¶ğŸ¼ ğŸ§¢ ğŸ‘ƒğŸ¾ Fitur menggunakan Druid pada contoh Classmates ğŸ‘¼ğŸ¿ ğŸš» ğŸ”¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Yuri Nevinitsin, dan saya terlibat dalam sistem statistik internal di OK. Saya ingin berbicara tentang bagaimana kami mentransfer sistem ana...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fitur menggunakan Druid pada contoh Classmates</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/420469/"><img src="https://habrastorage.org/webt/jd/0-/fd/jd0-fdngd2psn0-j-hkq1gmcm_a.jpeg"><br><br>  Nama saya Yuri Nevinitsin, dan saya terlibat dalam sistem statistik internal di OK.  Saya ingin berbicara tentang bagaimana kami mentransfer sistem analitik 50-terabyte waktu nyata, di mana miliaran peristiwa dicatat setiap hari, dari Microsoft SQL ke basis kolom yang disebut Druid.  Dan pada saat yang sama Anda akan belajar beberapa resep untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Druid</a> . <br><a name="habracut"></a><br><h2>  Mengapa kita membutuhkan statistik? </h2><br>  Kami ingin mengetahui segala sesuatu tentang situs kami, jadi kami mencatat tidak hanya perilaku disk, prosesor, dll., Tetapi juga setiap tindakan pengguna, setiap interaksi antara subsistem dan semua proses internal dari hampir semua sistem kami.  Sistem statistik terintegrasi erat ke dalam proses pengembangan. <br><br>  Berdasarkan data dari sistem statistik, manajer kami menetapkan tujuan untuk tim, melacak pencapaian mereka dan indikator utama.  Administrator dan pengembang memantau pengoperasian semua sistem, menyelidiki insiden dan anomali.  Pemantauan otomatis secara konstan memonitor dan pada tahap awal mengidentifikasi masalah, membuat perkiraan melebihi batas.  Juga, fitur dan eksperimen terus diluncurkan, pembaruan dan perubahan dibuat.  Dan kami memantau efek dari semua tindakan ini melalui sistem statistik.  Jika dia menolak, kami tidak akan dapat membuat perubahan ke situs. <br><br>  Statistik kami disajikan terutama dalam bentuk grafik.  Biasanya, grafik menampilkan beberapa hari sekaligus, sehingga dinamika menjadi jelas.  Ini adalah contoh percobaan saya dengan Druid.  Berikut ini adalah grafik pemuatan data (baris / 5 menit). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9b4/66b/1b1/9b466b1b191463f97dd3d192a8c4da42.jpg"><br><br>  Saya memperlambat unduhan (grafik merah mogok ke nol), menunggu beberapa saat, memulai kembali unduhan, dan menyaksikan seberapa cepat Druid dapat memuat data yang terakumulasi (puncak setelah kegagalan). <br><br>  Jadwal apa pun dapat diperluas dengan parameter apa pun, misalnya, oleh host, tabel, operasi, dll.  Kami juga memiliki grafik jangka panjang dengan dinamika tahunan.  Misalnya, di bawah ini adalah grafik peningkatan harian dalam jumlah entri di Druid. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9d/b52/45d/d9db5245dca91cc7cbdeee071b3529fa.png"><br><br>  Kami juga dapat menggabungkan beberapa bagan pada panel terpisah (dasbor), yang ternyata sangat nyaman.  Dan bahkan jika pengguna perlu melihat hanya beberapa ratusan grafik, ia masih membukanya tidak secara individu, tetapi di panel, yang meningkatkan beban pada sistem. <br><br><h2>  Masalah </h2><br>  Meskipun volume data kecil, kami berhasil mengatasi SQL dengan cukup baik.  Tetapi karena volume data tumbuh, output grafik melambat.  Dan pada akhirnya, statistik pada jam sibuk mulai tertinggal setengah jam, dan waktu respons rata-rata satu grafik mencapai 6 detik.  Artinya, seseorang menerima jadwal dalam 2 detik, seseorang dalam 10-20, dan seseorang dalam satu menit.  (Anda dapat membaca tentang pengembangan sistem dalam SQL di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ) <br><br>  Saat Anda menyelidiki anomali atau kejadian, Anda biasanya perlu membuka dan melihat selusin grafik, yang masing-masingnya mengikuti dari yang sebelumnya, mereka tidak dapat dibuka pada saat yang sama.  Saya harus menunggu 10 kali selama 10-20 detik.  Itu sangat menjengkelkan. <br><br><h2>  Migrasi </h2><br>  Anda masih bisa memeras sesuatu dari sistem, menambah server ... Tetapi pada saat yang bersamaan, Microsoft mengubah kebijakan lisensi.  Jika kami terus menggunakan SQL Server, kami harus memberikan jutaan dolar.  Karena itu, mereka memutuskan untuk bermigrasi. <br><br>  Persyaratannya adalah sebagai berikut: <br><br><ul><li>  Statistik tidak boleh ketinggalan (lebih dari 2 menit). </li><li>  Bagan harus dibuka tidak lebih dari 2 detik. </li><li>  Seluruh panel akan terbuka dalam waktu tidak lebih dari 10 detik. </li><li>  Sistem harus toleran terhadap kesalahan, mampu bertahan dari hilangnya pusat data. </li><li>  Sistem harus mudah diukur. </li><li>  Sistemnya harus mudah dimodifikasi, jadi kami ingin berada di Jawa. </li></ul><br>  Semua ini ditawarkan kepada kami hanya oleh Druid.  Ini juga memiliki agregasi awal, yang memungkinkan Anda untuk menyimpan lebih banyak volume, dan pengindeksan selama penyisipan data.  Druid mendukung semua jenis kueri yang diperlukan untuk statistik kami.  Oleh karena itu, sepertinya kita dapat dengan mudah mengganti Druid dengan SQL Server. <br><br>  Tentu saja, kami mempertimbangkan tidak hanya Druid untuk peran kandidat untuk pindah.  Pikiran pertama saya adalah mengganti Microsoft SQL Server dengan PostgreSQL.  Namun, ini hanya akan menyelesaikan masalah biaya keuangan, tetapi tidak akan membantu dengan aksesibilitas dan penskalaan. <br><br>  Kami juga menganalisis Influx, tetapi ternyata bagian yang bertanggung jawab atas ketersediaan dan skalabilitas tinggi ditutup.  Prometheus, dengan segala hormat sehubungan dengan kinerjanya, lebih sesuai untuk pemantauan dan tidak dapat membanggakan ketersediaan tinggi atau skalabilitas sederhana.  OpenTSDB juga lebih cocok untuk pemantauan, tidak memiliki indeks untuk semua bidang.  Kami tidak mempertimbangkan Click House, karena pada saat itu tidak ada. <br><br>  Masukan Druid.  Terabyte data dimigrasikan.  Dan segera setelah beralih dari SQL Server ke Druid, jumlah tampilan grafik meningkat 5 kali.  Kemudian mereka mulai menjalankan statistik "berat", yang mereka takut jalankan sebelumnya, karena  SQL akan sulit menanganinya. <br><br>  Sekarang Druid dari 12 node (40 core, 196 GB RAM) membutuhkan 500 ribu peristiwa per detik per jam sibuk, sementara ada margin keamanan yang besar (kolom MAX: hampir lima kali margin CPU). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/833/336/d09/833336d095db6e9d32da19dae981d474.png" width="500"><br><br>  Angka-angka ini didasarkan pada data produksi.  Saya akan memberi tahu Anda bagaimana kami mencapai ini, tetapi pertama-tama saya akan menjelaskan Druid secara lebih rinci. <br><br><h2>  Druid </h2><br>  Ini adalah sistem OLAP timeseries kolom terdistribusi.  Dokumentasinya tidak mengandung konsep-konsep biasa dari dunia SQL untuk sebuah tabel (sumber data sebagai gantinya) atau string (sebagai gantinya), tetapi saya akan menggunakannya untuk kemudahan deskripsi. <br><br>  Druid didasarkan pada beberapa asumsi data (batasan): <br><br><ul><li>  setiap jalur data memiliki stempel waktu yang tumbuh secara monoton (dalam jendela 10 menit secara default). </li><li>  data tidak berubah, Masukkan saja (Perbarui operasi tidak). </li></ul><br>  Ini memungkinkan Anda untuk memotong data menjadi apa yang disebut segmen waktu.  Segmen adalah "partisi" minimal yang tidak dapat dipisahkan dan tidak berubah dari satu tabel untuk periode waktu tertentu.  Semua operasi data, semua permintaan dilakukan segmen demi segmen. <br><br>  Setiap segmen swasembada: selain tabel utama, ditulis dalam bentuk kolom, juga berisi direktori dan indeks yang diperlukan untuk eksekusi kueri.  Kita dapat mengatakan bahwa segmen adalah basis data read-only kolom kecil (Penjelasan lebih rinci tentang perangkat segmen akan diberikan di bawah). <br><br>  Pada gilirannya, ini menghasilkan "distribusi": kemampuan untuk membagi sejumlah besar data menjadi segmen-segmen kecil untuk melakukan perhitungan secara paralel (baik pada satu mesin dan pada banyak sekaligus). <br><br>  Jika Anda perlu "meningkatkan" setidaknya satu baris, Anda harus memuat ulang seluruh segmen lagi.  Itu mungkin dan semuanya siap untuk ini.  Setiap segmen memiliki versi, dan sebuah segmen dengan versi yang lebih baru akan secara otomatis menggantikan segmen dengan versi yang lama (namun, jika pembaruan diperlukan secara berkala, maka ada baiknya mengevaluasi kembali apakah Druid cocok untuk penggunaan ini). <br><br>  Untuk menjelaskan segmen perangkat, kami mempertimbangkan contoh sederhana dalam bentuk tabel biasa: <br><br><img src="https://habrastorage.org/webt/7l/pb/hw/7lpbhwalmq7ogn5qnaq2gjrkzua.png" width="600"><br><br>  Dalam tabel ini, jumlah panggilan dalam dua lima menit dari empat host (perhatikan bahwa untuk host web1 ada dua baris dalam setiap periode lima menit). <br><br>  Semua sel data dari sudut pandang druid dibagi menjadi tiga jenis: <br><br><ul><li>  timestamp - timestamp UTC dalam ms (dalam contoh ini adalah Waktu). </li><li>  metrik adalah apa yang perlu Anda hitung (jumlah, min, maks, hitung, ...), dan Anda harus mengetahuinya terlebih dahulu untuk setiap tabel (dalam contoh, ini Panggilan, dan kami akan menghitung jumlahnya). </li><li>  Dimensi - inilah yang dapat Anda kelompokkan dan filter (Anda tidak perlu mengetahuinya terlebih dahulu dan dapat diubah dengan cepat) (dalam contoh, ini adalah Host). </li></ul><br>  Saat memasukkan, semua baris dikelompokkan berdasarkan set penuh dimensi + cap waktu, dan jika mereka cocok dengan masing-masing metrik, fungsi agregasi "nya" diterapkan (sebagai hasilnya, tidak ada baris dengan set dimensi + cap waktu yang sama).  Jadi, contoh kita setelah dimasukkan ke dalam druid akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb8/8b9/e64/eb88b9e64bdafc870ca39646e4c0a4fb.png" width="500"><br><br>  Stempel waktu dan semua metrik (dalam kasus kami, ini adalah Waktu dan Panggilan) akan ditulis sebagai array dari jumlah tipe yang panjang (float dan double juga didukung).  Untuk setiap dimensi (dalam kasus kami ini adalah Host), kamus akan dibuat - serangkaian string yang diurutkan (dengan nama host).  Kolom host sendiri akan ditulis sebagai array int, menunjukkan angka-angka dalam kamus. <br><br>  Harap dicatat bahwa setelah memasukkan ke dalam Druid, pasang garis untuk host web1 dengan stempel waktu yang sama digabungkan, dan jumlah total dicatat dalam panggilan (tidak mungkin untuk mengekstrak data awal dari Druid). <br><br>  Diperlukan indeks untuk memfilter data cepat, karena mungkin ada jutaan baris dan ribuan host.  Indeks adalah bitmap, satu untuk setiap baris dalam kamus. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f32/bb5/edd/f32bb5eddba3c14b6ef241057f061724.png" width="500"><br><br>  Unit menunjukkan nomor baris tempat host ini berpartisipasi.  Untuk memfilter dua host, Anda perlu mengambil dua bitmap, menggabungkannya melalui OR, dan memilih nomor baris dalam unit bitmap yang dihasilkan. <br><br><h2>  Druid terdiri dari banyak komponen. </h2><br>  Pertama, ia memiliki beberapa dependensi eksternal. <br><br><img src="https://habrastorage.org/webt/rd/zs/uo/rdzsuo03og7v4whzfi5rz4m6qss.png" width="400"><br><br><ol><li>  Penyimpanan  Di sana, Druid hanya menyimpan segmen dalam bentuk terkompresi.  Itu bisa berupa direktori lokal, HDFS, Amazon S3.  Hanya ruang yang digunakan di sini, tidak ada perhitungan yang dilakukan. </li><li>  Meta: database untuk informasi Meta.  Basis data ini menyimpan peta data lengkap: segmen mana yang relevan, yang kedaluwarsa, jalur mana yang disimpan. </li><li>  Menggunakan ZooKeeper, sistem melakukan penemuan dan mengumumkan di mana node druid segmen mana yang tersedia untuk kueri. </li><li>  Tembolok dari permintaan yang dieksekusi, bisa memcached atau cache lokal di java heap. </li></ol><br>  Kedua, Druid sendiri terdiri dari beberapa jenis komponen. <br><br><ol><li>  Node realtime memuat aliran data segar dalam urutan yang diterima dan melayani permintaan untuk itu. </li><li>  Simpul historis berisi seluruh massa data dan melayani permintaan untuknya.  Ketika kami mengatakan bahwa kami memiliki 300 TB cluster, yang kami maksud adalah node historis. </li><li>  Broker bertanggung jawab untuk mendistribusikan perhitungan antara node historis dan realtime. </li><li>  Koordinator bertanggung jawab untuk mengalokasikan segmen lintas node historis dan untuk replikasi. </li><li>  Layanan pengindeksan, yang memungkinkan Anda untuk (kembali) memuat data dalam batch, misalnya, untuk "memutakhirkan" bagian dari data. </li></ol><br><h2>  Aliran data </h2><br><img src="https://habrastorage.org/webt/gh/yg/pc/ghygpcnsakfac9x6dqrjtjjagdc.png" width="400"><br>  <i>Panah tebal menunjukkan aliran data, panah tipis menunjukkan aliran metadata.</i> <br><br>  Node Realtime mengambil data, indeks, dan memotong segmen menurut waktu, misalnya hari. <br><br>  Setiap segmen baru dari node realtime menulis ke penyimpanan dan meninggalkan salinan untuk melayani permintaan untuk itu.  Kemudian ia mencatat metadata bahwa segmen baru telah muncul di repositori di sepanjang jalur ini dan itu. <br><br>  Informasi ini diterima oleh koordinator, secara berkala membaca ulang basis metadata.  Ketika dia menemukan segmen baru, (melalui ZooKeeper) memesan beberapa node historis untuk mengunduh segmen ini.  Mereka mengunduh dan (melalui ZooKeeper) mengumumkan bahwa mereka memiliki segmen baru.  Ketika node realtime menerima pesan ini (melalui ZooKeeper), itu menghapus salinannya untuk memberikan ruang bagi data baru. <br><br><h2>  Meminta pemrosesan </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c1f/8f5/e8f/c1f8f5e8fcc11c157c7ab10311ae977a.png"><br><br>  Tiga jenis node berpartisipasi dalam pemrosesan permintaan: broker, realtime, dan historis.  Permintaan datang ke broker, siapa yang tahu di node mana segmen berada.  Ini mendistribusikan permintaan oleh node historis (dan realtime) yang menyimpan segmen yang diinginkan.  Simpul historis juga memparalelkan perhitungan sebanyak mungkin, mengirim hasilnya ke broker, dan dia memberikannya kepada klien.  Dengan menggabungkan skema ini dengan penyimpanan data kolom, Druid dapat memproses informasi dalam jumlah besar dengan sangat cepat. <br><br><h2>  Ketersediaan tinggi </h2><br>  Seingat Anda, Druid dalam daftar dependensi memiliki basis untuk metadata, yang bisa berupa MySQL atau PostgreSQL.  Apache Derby juga disebutkan, tetapi produk ini tidak dapat digunakan untuk produksi, hanya untuk pengembangan (seperti yang saya mengerti, derby digunakan dalam bentuk tertanam, agar tidak meningkatkan mysql / pgsql di lingkungan perdananya). <br><br>  Apa yang akan terjadi jika pangkalan ini gagal (dan / atau penyimpanan dan / atau koordinator)?  Node realtime tidak dapat menulis metadata (dan / atau segmen).  Maka koordinator tidak akan dapat membacanya kembali dan tidak akan menemukan segmen baru.  Node historis tidak akan mengunduhnya, dan simpul waktu nyata tidak akan menghapus salinannya, tetapi akan terus mengunduh data terbaru.  Akibatnya, data akan mulai menumpuk di node realtime.  Ini tidak dapat berlangsung tanpa batas.  Namun demikian, diketahui sumber daya apa yang tersedia pada node realtime, dan jenis aliran data apa yang kita miliki.  Oleh karena itu, kami memiliki jumlah waktu yang dapat diprediksi yang dapat digunakan untuk memperbaiki basis yang gagal (dan / atau penyimpanan dan / atau koordinator). <br><br>  Karena mysql / pgsql yang didukung tidak menjamin ketersediaan tinggi di luar kotak, kami memutuskan untuk memainkannya dengan aman dan menggunakan solusi kami sendiri (siap pakai) berdasarkan Cassandra, karena di luar kotak memberikan ketersediaan tinggi (Anda dapat membaca lebih lanjut tentang hal itu di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> ). <br><br>  Selain itu, kami menyelesaikan node realtime sedemikian rupa sehingga dengan akumulasi berlebihan, data terlama dihapus, membebaskan ruang untuk yang baru.  Ini sangat penting bagi kami, karena situasi ketika kami tidak dapat menaikkan basis yang gagal (dan / atau penyimpanan dan / atau koordinator) untuk waktu yang lama dan banyak data yang terakumulasi kemungkinan besar merupakan konsekuensi dari kecelakaan besar.  Dan pada saat ini, data terbaru adalah yang paling penting. <br><br><h2>  Druid dan ZooKeeper </h2><br>  Dengan ZooKeeper, semuanya lebih baik dan lebih buruk.  Lebih baik karena ZooKeeper sendiri toleran terhadap kesalahan, ia memiliki replikasi di luar kotak.  Tampaknya itu bisa terjadi? <br><br>  Secara umum, bab ini tidak lagi relevan.  Dan ini bukan kisah sukses, ini adalah rasa sakit yang (baik kami dan Druid segar) memutuskan untuk secara radikal menghapus hampir semua data dari ZooKeeper, dan sekarang node Druid meminta mereka langsung dari satu sama lain melalui HTTP. <br><br>  ZooKeeper memiliki dua jenis batas waktu.  Batas waktu koneksi adalah batas waktu jaringan yang sederhana, setelah itu klien menghubungkan kembali ke ZooKeeper dan mencoba memulihkan sesi.  Dan batas waktu sesi, setelah sesi dihapus dan semua data <i>sesaat yang</i> dibuat dalam sesi ini juga dihapus (oleh ZooKeeper sendiri), yang diberitahukan kepada semua klien ZooKeeper lainnya. <br><br>  Berdasarkan ini, penemuan dalam karya druid: pada saat startup, setiap node membuat sesi baru di ZooKeeper dan mencatat data <i>fana</i> tentang dirinya: host: port, jenis node (broker / realtime / historical / ...), timestamp koneksi, dll. ... Simpul druid lain menerima pemberitahuan dari ZooKeeper dan membaca data ini, sehingga mereka mengetahui bahwa simpul druid baru telah naik dan seperti apa simpul itu.  Jika ada node druid yang jatuh setelah batas waktu sesi, data tentang itu akan dihapus oleh ZooKeeper, dan node druid lainnya akan mengetahuinya.  Agar mereka mempelajarinya lebih cepat, kami lebih memilih untuk menempatkan waktu tunggu sesi kecil. <br><br>  Ketika simpul waktu nyata atau historis naik, simpul itu, selain data tentang dirinya sendiri, juga menulis kepada ZooKeeper daftar segmen yang dimilikinya (ini juga data <i>sementara</i> ).  Lebih jauh di sepanjang jalan, segmen pada node realtime dan historis dibuat baru dan lama akan dihapus, dan setiap node mencerminkan ini dalam daftar di ZooKeeper.  Daftar ini bisa besar, sehingga dipecah menjadi beberapa bagian sehingga tidak seluruh daftar ditimpa, tetapi hanya bagian yang dimodifikasi. <br>  Broker, pada gilirannya, ketika dia melihat simpul waktu nyata atau historis, juga mengurangi daftar segmen dari ZooKeeper untuk mendistribusikan permintaan ke simpul ini.  Node realtime membaca daftar ini untuk menghapus salinan segmen yang muncul pada simpul historis.  Karena daftar ini dibagi menjadi beberapa bagian dan ditimpa dalam beberapa bagian, ZooKeeper akan memberi tahu Anda bagian mana yang telah diubah, hanya itu yang akan dibaca kembali. <br><br>  Seperti yang saya katakan, daftar ini bisa panjang.  Ketika ada banyak data di ZooKeeper, maka ternyata tidak lagi stabil.  Dalam kasus kami, masalah yang jelas dimulai ketika jumlah segmen mencapai sekitar 7 juta, snapshot ZooKeeper kemudian menempati 6GB. <br>  Apa yang terjadi jika simpul Druid kehilangan kontak dengan ZooKeeper? <br><br>  Druid bekerja dengan ZooKeeper sedemikian rupa sehingga dalam hal timeout sesi, setiap node membuat sesi baru dan menulis semua datanya di sana dan membaca kembali data dari node lain.  Karena ada banyak data, lalu lintas macet di ZooKeeper.  Hal ini dapat menyebabkan batas waktu pada node lain dari Druid, maka mereka juga mulai menulis ulang dan membaca kembali.  Dengan demikian, lalu lintas tumbuh seperti longsoran salju sampai-sampai ZooKeeper kehilangan sinkronisasi antara instansenya dan mulai mendorong snapshot bolak-balik. <br><br>  Apa yang dilihat pengguna saat ini? <br><br>  Ketika seorang pialang kehilangan kontak dengan ZooKeeper (dan batas waktu sesi terjadi), pialang tidak lagi tahu segmen mana yang merupakan titik sejarah.  Dan memberikan jawaban kosong.  Artinya, jika ZooKeeper down, maka Druid tidak berfungsi.  Sangat tidak mungkin untuk "menyembuhkan" itu, tetapi mungkin untuk menyebarkan sedotan di beberapa tempat. <br>  Pertama, Anda dapat menghapus data dari ZooKeeper.  Tidak apa-apa jika mereka tersesat: Druid hanya akan menimpa mereka.  Jika masalah dengan ZooKeeper sudah dimulai, maka untuk solusi tercepat, disarankan untuk menonaktifkan ZooKeeper, hapus data, dan angkat itu kosong, dan jangan tunggu sampai diselesaikan sendiri. <br><br>  Sekarang kami meningkatkan batas waktu sesi.  Apa yang terjadi dalam kasus ini? <br><br>  Katakanlah node historis tidak memulai kembali dengan benar dan tidak menghapus sesi lama dari ZooKeeper, sambil membuat yang baru dan menulis banyak data di sana.  Sementara sesi lama masih hidup dan batas waktu belum berlalu, dua salinan data disimpan di ZooKeeper.  Jika ada banyak node yang segera dimulai kembali, maka banyak data akan diduplikasi.  Karena itu, Anda perlu menyimpan persediaan memori untuk ZooKeeper agar tidak habis dan ZooKeeper tidak berhenti bekerja.  Mengapa tidak bisa menghapus data dari sesi lama? <br><br>  Untuk alasan yang sama, perlu menyelesaikan operasi node historis dengan benar, karena pada saat itu mereka menghapus data mereka dari ZooKeeper, dan dapat melakukan ini untuk waktu yang lama.  Penyelesaian node historis membutuhkan waktu sekitar setengah jam. <br><br>  Simpul historis memiliki satu fitur lagi.  Ketika mereka mulai, mereka melihat segmen apa yang disimpan di dalamnya, dan kemudian informasi tentang ini ditulis ke ZooKeeper.  Dan karena data tersebar kurang lebih secara merata di seluruh node historis, jika Anda menjalankannya secara bersamaan, maka mereka akan mulai menulis di ZooKeeper pada waktu yang hampir bersamaan.  Ini lagi meningkatkan kemungkinan pertumbuhan lalu lintas seperti gelombang dan timeout.  Oleh karena itu, Anda perlu menjalankan node historis secara berurutan untuk menyebarkan sesi rekaman di ZooKeeper pada waktunya. <br><br>  Kami juga membuat dua optimasi lagi: <br><br><ul><li>  Kami memprogram ulang bekerja dengan ZooKeeper sedikit sehingga hanya simpul yang membutuhkannya yang dibaca dari Druid.     realtime,   ,    .    ,        .          ,    . </li><li>  ,    ZooKeeper,       ,     .      ZooKeeper  6   2  (  ). </li></ul><br>          8 ;         . <br><br><h2>   Druid </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/2f4/71b/9a9/2f471b9a9927b4075e3dcc9bba8333cc.png"><br><br>     realtime    ,      .      - (   , , ).       ,     MMAP (   ).          .     . <br><br> -, realtime-   ,       JVM    ,      . <br><br><img src="https://habrastorage.org/webt/on/uk/w1/onukw1xyab_eojgwxynlsxjr6qc.png" width="500"><br><br>    .         : 1)     2)       .       ,       . ,  ,  .     ,   ,      ,  . (  ,      ,   ). <br><br>    ,    realtime-       ,     , ..      ,     ,   ,     (  ). <br><br>  ,     .       ,      ,  . <br><br>     ,       Druid   .    ,       ,       ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f32/bb5/edd/f32bb5eddba3c14b6ef241057f061724.png" width="500"><br><br>  ,      . ,          (web%, api%). <br><br><ul><li> Druid     â€”  .           . </li><li>   ,      . </li><li>  Druid   ,  ,    :   ,  , ,    . </li><li>   Druid        ,   ,        calls. </li></ul><br>     ,     5 %     ,  95 % â€”  . <br><br>  ,  ,  realtime-         . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/76b/30d/618/76b30d618474a0cd9afdf6aa40af6b90.png" width="500"><br><br>   ,   ( 10:45)  .  -   ,   -.  ,    ( 10:50)  ,   -.  Dan sebagainya.    ,   ,   Â«callsÂ», Â«timeÂ»  Â«hostÂ»     . <br>       -.         ,    Â«Â»      .    ,    ,      .          (   95% )      ,    :   ,    .         100 ,          1000. <br><br>     ?    ,   . ,          realtime ,     .      (..      historical     realtime-),     . <br><br>    ,         :          . ,       ,    .    100 . ,   .           . <br><br>    .  80% ,   ,      ,    .             .    .      ,     selector,            .      ,   . <br><br><h2>   </h2><br>   ,      ,  ,    . ,        .        , 8    .     Druid.   ,    ,    Druid,       .      ,        .  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/917/10e/c6d91710e3436dc0feede42b3138baa0.png" width="500"><br><br>      ,  ,  .       .     ,       ,   .    .   27  . ,    27 , 27 . <br><br>   ,   .       27   ,    9,  9 ,    . <br>       . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/710/585/fcb/710585fcb1dcf69e39a4a8e2faacc62f.png" width="500"><br><br>  â€” : , , .   â€” : , , .   â€” :  ,  ,  .        â€” ,        .    ,     .         ,      27.   9,  .          (   95% )    9 .        27    . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada kenyataannya, kami memiliki 14 ribu kombinasi. </font><font style="vertical-align: inherit;">Dengan demikian, dalam kamus kami ada 14 ribu nilai dan 14 ribu bitmap. </font><font style="vertical-align: inherit;">Akibatnya, ketika kami memotong bidang ini menjadi bagian-bagian kecil sesuai dengan kata-kata, kecepatan statistik rekaman meningkat 10 kali, dan ukuran data dibelah dua. </font><font style="vertical-align: inherit;">Sekarang semuanya bekerja dengan cepat.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Meminta Prioritas </font></font></h2><br>          ,  2 .       11   ,    74 .  ,       .        74 ?  ,         . <br> Druid    .      ,  ,    ,       .  ,         ,    .  ,    ,       .  ,    ,  . <br><br>    ,   Druid        .   ,      ( ) ,    .     5 :     ,       .       .          (     java),      .   Druid  ,    . <br><br><h2>  Ringkasan </h2><br>   , ,    SQL Server,       Microsoft. <br><br>     ,     /   . <br><br>         ,   ,       . <br><br>       20 ,          ,     18    . <br><br>       one-cloud ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://habr.com/company/odnoklassniki/blog/346868/</a> ),      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420469/">https://habr.com/ru/post/id420469/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420459/index.html">Ikon dengan penghitung di bilah alat atas: contoh berbagai pendekatan untuk satu tugas</a></li>
<li><a href="../id420461/index.html">10 kutipan dari desainer yang buruk</a></li>
<li><a href="../id420463/index.html">ICO sepatutnya dalam penurunan, tetapi mereka memiliki kesempatan untuk berubah</a></li>
<li><a href="../id420465/index.html">Variabel nginx dengan njs: sederhana, tidak menyakitkan dan melalui JavaScript</a></li>
<li><a href="../id420467/index.html">Wrapper C ++ untuk "semua" Sistem Operasi Real-Time untuk CortexM4</a></li>
<li><a href="../id420471/index.html">Tiga laporan teknis RIT 2018 oleh Plesk</a></li>
<li><a href="../id420473/index.html">Buku untuk eksekutif pemula atau mengapa sangat penting untuk dibaca</a></li>
<li><a href="../id420475/index.html">Perbandingan mesin pemotong laser Raylogic 11G dan Raylogic V12</a></li>
<li><a href="../id420477/index.html">Ulasan HyperX Cloud Stinger Core: headset karakter yang ringan dan kasar</a></li>
<li><a href="../id420479/index.html">Ketergantungan injeksi dalam layanan Apache Ignite.NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>