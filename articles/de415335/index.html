<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äç‚úàÔ∏è ü§æüèø üèí Android Hintergrund Tutorial. Teil 5: Coroutinen in Kotlin üè∞ üî® üñäÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kotlin Island 

 Fr√ºhere Texte in dieser Reihe: √ºber AsyncTask , √ºber Loader , √ºber Executors und EventBus , √ºber RxJava . 

 Diese Stunde ist also ge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Android Hintergrund Tutorial. Teil 5: Coroutinen in Kotlin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/415335/"><img src="https://habrastorage.org/webt/r3/h-/kd/r3h-kdmudutyx6g2zcisi4vly7c.png"><br>  <sup>Kotlin Island</sup> <br><br>  <i>Fr√ºhere Texte in dieser Reihe: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber AsyncTask</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Loader</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber Executors und EventBus</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºber RxJava</a> .</i> <br><br>  Diese Stunde ist also gekommen.  Dies ist der Artikel, f√ºr den die gesamte Serie geschrieben wurde: eine Erkl√§rung, wie der neue Ansatz ‚Äûunter der Haube‚Äú funktioniert.  Wenn Sie noch nicht wissen, wie Sie es verwenden sollen, finden Sie hier einige n√ºtzliche Links, um Ihnen den Einstieg zu erleichtern: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Seite auf der offiziellen Website</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Android Coroutine Rezepte Blog Post</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht von Roman Elizarov</a> </li></ul><br>  Und nachdem Sie sich mit Coroutinen vertraut gemacht haben, fragen Sie sich vielleicht, was Kotlin diese Gelegenheit gegeben hat und wie es funktioniert.  Bitte beachten Sie, dass wir uns hier nur auf die Kompilierungsphase konzentrieren: Sie k√∂nnen einen separaten Artikel √ºber die Ausf√ºhrung schreiben. <br><a name="habracut"></a><br>  Das erste, was wir verstehen m√ºssen, ist, dass im Korpus tats√§chlich keine Koroutinen existieren.  Der Compiler wandelt die Funktion mit dem Suspend-Modifikator in eine Funktion mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Continuation-</a> Parameter um.  Diese Schnittstelle hat zwei Methoden: <br><br><pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resume</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resumeWithException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(exception: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br>  Typ T ist der R√ºckgabetyp Ihrer urspr√ºnglichen Suspend-Funktion.  Und hier ist, was tats√§chlich passiert: Diese Funktion wird in einem bestimmten Thread ausgef√ºhrt (Geduld, wir kommen auch dazu), und das Ergebnis wird an die Wiederaufnahmefunktion dieser Fortsetzung √ºbergeben, in deren Kontext die Suspend-Funktion aufgerufen wurde.  Wenn die Funktion das Ergebnis nicht empf√§ngt und eine Ausnahme ausl√∂st, wird resumeWithException ausgel√∂st, wodurch ein Fehler im aufrufenden Code ausgel√∂st wird. <br><br>  Ok, aber woher kam die Fortsetzung?  Nat√ºrlich vom Corutin-Erbauer!  Schauen wir uns den Code an, der eine Coroutine erstellt, zum Beispiel den Start: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">launch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CoroutineContext</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = DefaultDispatcher, start: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CoroutineStart</span></span></span></span><span class="hljs-function"><span class="hljs-params"> = CoroutineStart.DEFAULT, parent: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Job</span></span></span></span><span class="hljs-function"><span class="hljs-params">? = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params">, block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CoroutineScope</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ): Job { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newContext = newCoroutineContext(context, parent) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> coroutine = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start.isLazy) LazyStandaloneCoroutine(newContext, block) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> StandaloneCoroutine(newContext, active = <span class="hljs-literal"><span class="hljs-literal">true</span></span>) coroutine.start(start, coroutine, block) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coroutine }</code> </pre><br>  Hier erstellt der Builder eine Coroutine - eine Instanz der AbstractCoroutine-Klasse, die wiederum die Continuation-Schnittstelle implementiert.  Die Startmethode geh√∂rt zur Jobschnittstelle.  Es ist jedoch sehr schwierig, die Definition der Startmethode zu finden.  Aber wir k√∂nnen von der anderen Seite hierher kommen.  Ein aufmerksamer Leser hat bereits bemerkt, dass das erste Argument f√ºr die Startfunktion der CoroutineContext ist und standardm√§√üig auf DefaultDispatcher gesetzt ist.  Dispatcher sind Klassen, die die Ausf√ºhrung von Coroutinen steuern. Sie sind daher auf jeden Fall wichtig, um zu verstehen, was passiert.  Schauen wir uns die DefaultDispatcher-Deklaration an: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">actual</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> DefaultDispatcher: CoroutineDispatcher = CommonPool</code> </pre><br>  Tats√§chlich ist dies also CommonPool, obwohl Java-Docks uns sagen, dass sich dies √§ndern kann.  Was ist CommonPool? <br><br>  Dies ist ein Coroutine-Manager, der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ForkJoinPool</a> als Implementierung von ExecutorService verwendet.  Ja, das ist es: Am Ende sind alle Ihre Lambda-Coroutinen nur lauff√§hig und in Executor mit einer Reihe kniffliger Transformationen gefangen.  Aber der Teufel steckt wie immer im Detail. <br><br><img src="https://habrastorage.org/webt/jh/yg/wr/jhygwrz-zofdvbpe11tbvvatsqi.jpeg"><br>  <sup>Gabel?</sup>  <sup>Oder mitmachen?</sup> <br><br>  Nach den Ergebnissen der Umfrage auf meinem Twitter zu urteilen, muss ich hier kurz erkl√§ren, was FJP ist :) <br><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); width: 500px; margin: 10px auto; max-width: 100%; min-width: 220px;" data-tweet-id="991950848996597760"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Zun√§chst einmal ist ForkJoinPool ein moderner Executor, der f√ºr die Verwendung mit parallelen Java 8-Streams erstellt wurde. Die urspr√ºngliche Aufgabe war die effiziente Parallelit√§t bei der Arbeit mit der Stream-API. Dies bedeutet im Wesentlichen, dass die Streams aufgeteilt werden, um einen Teil der Daten zu verarbeiten, und diese dann kombiniert werden, wenn alle Daten verarbeitet wurden.  Stellen Sie sich zur Vereinfachung vor, Sie h√§tten den folgenden Code: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">IntStream</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.range</span></span>(1, 1_000_000) <span class="hljs-selector-class"><span class="hljs-selector-class">.parallel</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.sum</span></span>()</code> </pre><br>  Die Menge eines solchen Streams wird nicht in einem Stream berechnet. Stattdessen teilt ForkJoinPool den Bereich rekursiv in Teile auf (zuerst in zwei Teile von 500.000, dann jeweils in 250.000 usw.), berechnet die Summe jedes Teils und kombiniert die Ergebnisse zu einem einzigen Menge.  Hier ist eine Visualisierung eines solchen Prozesses: <br><br><img src="https://habrastorage.org/webt/15/yb/uk/15ybukvbskzmzddp9lytwarsbvy.jpeg"><br>  <sup>Threads werden f√ºr verschiedene Aufgaben aufgeteilt und nach Abschluss wieder zusammengef√ºhrt</sup> <br><br>  Die Effektivit√§t von FJP basiert auf dem Algorithmus ‚ÄûJob Theft‚Äú: Wenn einem bestimmten Thread die Aufgaben ausgehen, werden die Warteschlangen anderer Pool-Threads aufgerufen und ihre Aufgaben gestohlen.  Zum besseren Verst√§ndnis k√∂nnen Sie den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bericht von</a> Alexei Shipilev sehen oder eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pr√§sentation</a> ansehen. <br><br>  Nun, wir haben erkannt, was unsere Coroutinen tun!  Aber wie landen sie dort? <br><br>  Dies geschieht innerhalb der CommonPool # -Versandmethode: <br><br><pre> <code class="hljs css">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">pool</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.execute</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">timeSource</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.trackTask</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">block</span></span>))</code> </pre><br>  Die Versandmethode wird von der Methode resume (Wert: T) in DispatchedContinuation aufgerufen.  Klingt vertraut!  Wir erinnern uns, dass Continuation eine in AbstractCoroutine implementierte Schnittstelle ist.  Aber wie h√§ngen sie zusammen? <br><br>  Der Trick liegt in der CoroutineDispatcher-Klasse.  Die ContinuationInterceptor-Schnittstelle wird wie folgt implementiert: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> actual <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> fun &lt;T&gt; interceptContinuation(continuation: Continuation&lt;T&gt;): Continuation&lt;T&gt; = DispatchedContinuation(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, continuation)</code> </pre><br>  Sehen Sie?  Sie stellen dem Builder-Corutin einen einfachen Block zur Verf√ºgung.  Sie m√ºssen keine Schnittstellen implementieren, √ºber die Sie nichts wissen m√∂chten.  Die Coroutine-Bibliothek k√ºmmert sich um all das.  Sie ist <br>  f√§ngt die Ausf√ºhrung ab, ersetzt die Fortsetzung durch DispatchedContinuation und sendet sie an den Executor, wodurch die effizienteste Ausf√ºhrung Ihres Codes garantiert wird. <br><br>  Jetzt m√ºssen wir uns nur noch damit befassen, wie der Versand von Anfang an aufgerufen wird.  Lassen Sie uns diese L√ºcke f√ºllen.  Die Resume-Methode wird von startCoroutine in der Erweiterungsfunktion des Blocks aufgerufen: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;R, T&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">suspend</span></span></span></span><span class="hljs-function"><span class="hljs-params"> R.()</span></span></span></span> -&gt; T).startCoroutine( receiver: R, completion: Continuation&lt;T&gt; ) { createCoroutineUnchecked(receiver, completion).resume(<span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) }</code> </pre><br>  Und startCoroutine wird wiederum vom Operator "()" in der CoroutineStart-Enumeration aufgerufen.  Ihr Builder akzeptiert es als zweiten Parameter und der Standardwert ist CoroutineStart.DEFAULT.  Das ist alles! <br><br>  Das ist der Grund, warum ich den Corutin-Ansatz bewundere: Es ist nicht nur eine spektakul√§re Syntax, sondern auch eine brillante Implementierung. <br><br><blockquote>  Und f√ºr diejenigen, die bis zum Ende gelesen haben, erhalten sie exklusiv: Ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Video</a> meines Berichts ‚ÄûEin Geiger wird nicht ben√∂tigt: Wir lehnen RxJava zugunsten von Coroutine in Kotlin ab‚Äú von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mobius-</a> Konferenz.  Viel Spa√ü :) <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de415335/">https://habr.com/ru/post/de415335/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de415323/index.html">Abschlussprojekte von Technoproject-Absolventen, Fr√ºhjahr 2018</a></li>
<li><a href="../de415327/index.html">Der Satz von Pythagoras wurde von den Bauherren von Stonehenge 2000 Jahre vor der Geburt von Pythagoras selbst verwendet</a></li>
<li><a href="../de415329/index.html">Die ganze Wahrheit √ºber RTOS von Colin Walls. Artikel 3. Aufgaben und Planung</a></li>
<li><a href="../de415331/index.html">In Jaroslawl werden Konstruktionsdrucker f√ºr Druckereien mit 5-6 Stockwerken hergestellt</a></li>
<li><a href="../de415333/index.html">Arduino - mikropowerful AM Broadcast Sender</a></li>
<li><a href="../de415337/index.html">Wie Pusher-Kan√§le bereits 10.000.000.000.000 Nachrichten √ºbermittelten</a></li>
<li><a href="../de415341/index.html">PostgreSQL-Verwaltungskurse</a></li>
<li><a href="../de415343/index.html"># 2HACKATON f√ºr junge Berufst√§tige in Perm</a></li>
<li><a href="../de415345/index.html">Tipps f√ºr die Entscheidung, iOS-Entwickler zu werden</a></li>
<li><a href="../de415347/index.html">2. Basierend auf Meyers ‚ÄûEffective and Modern C ++‚Äú - Details zur Inferenz des Vorlagentyps f√ºr Arrays</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>