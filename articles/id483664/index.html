<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍩 ⏪ 🚘 API Fungsional Keras di TensorFlow 👩🏿‍💻 👵🏽 🌥️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Keras memiliki dua API untuk dengan cepat membangun arsitektur jaringan saraf Sekuensial dan Fungsional. Jika yang pertama memungkinkan Anda untuk mem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>API Fungsional Keras di TensorFlow</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483664/"><img src="https://habrastorage.org/webt/w1/zr/n8/w1zrn8ydafoxahso_ig7vx1stfg.png"><br><br>  Keras memiliki dua API untuk dengan cepat membangun arsitektur jaringan saraf Sekuensial dan Fungsional.  Jika yang pertama memungkinkan Anda untuk membangun hanya arsitektur berurutan dari jaringan saraf, maka dengan menggunakan API Fungsional Anda dapat menentukan jaringan saraf dalam bentuk grafik asiklik yang diarahkan secara sewenang-wenang, yang memberikan lebih banyak peluang untuk membangun model yang kompleks.  Artikel ini adalah terjemahan dari Panduan Fitur API Fungsional dari situs web TensorFlow. <br><a name="habracut"></a><br><h2>  Pendahuluan </h2><br>  API Fungsional memungkinkan Anda membuat model lebih fleksibel daripada Sequential API, ia dapat memproses model dengan topologi non-linear, model dengan lapisan umum, dan model dengan beberapa input atau output. <br><br>  Hal ini didasarkan pada fakta bahwa model pembelajaran dalam biasanya merupakan grafik asiklik terarah (DAG) dari lapisan <br><br>  API Fungsional adalah seperangkat alat untuk <b>merencanakan lapisan</b> . <br><br>  Pertimbangkan model berikut: <br><br><blockquote>  (input: vektor 784 dimensi) <br>  ↧ <br>  [Lapisan padat (64 elemen, aktivasi relu)] <br>  ↧ <br>  [Lapisan padat (64 elemen, aktivasi relu)] <br>  ↧ <br>  [Lapisan padat (10 elemen, aktivasi softmax)] <br>  ↧ <br>  (output: distribusi probabilitas lebih dari 10 kelas) </blockquote>  Ini adalah grafik sederhana 3 lapisan. <br><br>  Untuk membangun model ini menggunakan API Fungsional, Anda harus mulai dengan membuat simpul input: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> keras inputs = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">784</span></span>,))</code> </pre> <br>  Di sini kami hanya menunjukkan dimensi data kami: vektor 784 dimensi.  Harap perhatikan bahwa jumlah data selalu dihilangkan, kami hanya menunjukkan dimensi dari setiap elemen.  Untuk memasukkan ukuran yang dimaksudkan untuk gambar `(32, 32, 3)`, kita akan menggunakan: <br><br><pre> <code class="python hljs">img_inputs = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br>  <code>inputs</code> apa yang dikembalikan berisi informasi tentang ukuran dan jenis data yang Anda rencanakan untuk ditransfer ke model Anda: <br><br><pre> <code class="python hljs">inputs.shape</code> </pre> <br><pre> <code class="python hljs">TensorShape([<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, <span class="hljs-number"><span class="hljs-number">784</span></span>])</code> </pre> <br><pre> <code class="python hljs">inputs.dtype</code> </pre> <br><pre> <code class="python hljs">tf.float32</code> </pre> <br>  Anda membuat simpul baru dalam grafik layer dengan memanggil layer pada objek <code>inputs</code> ini: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow.keras <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> layers dense = layers.Dense(<span class="hljs-number"><span class="hljs-number">64</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>) x = dense(inputs)</code> </pre> <br>  "Memanggil layer" mirip dengan menggambar panah dari "input" ke dalam layer yang kita buat.  Kami “meneruskan” input ke lapisan <code>dense</code> , dan kami mendapatkan <code>x</code> . <br><br>  Mari kita tambahkan beberapa layer lagi ke grafik layer kita: <br><br><pre> <code class="python hljs">x = layers.Dense(<span class="hljs-number"><span class="hljs-number">64</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) outputs = layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)(x)</code> </pre> <br>  Sekarang kita dapat membuat <code>Model</code> menentukan input dan outputnya dalam grafik layer: <br><br><pre> <code class="python hljs">model = keras.Model(inputs=inputs, outputs=outputs)</code> </pre> <br>  Mari kita lihat lagi proses definisi model lengkap: <br><br><pre> <code class="python hljs">inputs = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">784</span></span>,), name=<span class="hljs-string"><span class="hljs-string">'img'</span></span>) x = layers.Dense(<span class="hljs-number"><span class="hljs-number">64</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(inputs) x = layers.Dense(<span class="hljs-number"><span class="hljs-number">64</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) outputs = layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)(x) model = keras.Model(inputs=inputs, outputs=outputs, name=<span class="hljs-string"><span class="hljs-string">'mnist_model'</span></span>)</code> </pre> <br>  Mari kita lihat seperti apa ringkasan model: <br><br><pre> <code class="python hljs">model.summary()</code> </pre> <br><pre> <code class="python hljs">Model: <span class="hljs-string"><span class="hljs-string">"mnist_model"</span></span> _________________________________________________________________ Layer (type) Output Shape Param <span class="hljs-comment"><span class="hljs-comment"># ================================================================= img (InputLayer) [(None, 784)] 0 _________________________________________________________________ dense_3 (Dense) (None, 64) 50240 _________________________________________________________________ dense_4 (Dense) (None, 64) 4160 _________________________________________________________________ dense_5 (Dense) (None, 10) 650 ================================================================= Total params: 55,050 Trainable params: 55,050 Non-trainable params: 0 _________________________________________________________________</span></span></code> </pre> <br>  Kami juga dapat menggambar model sebagai grafik: <br><br><pre> <code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string"><span class="hljs-string">'my_first_model.png'</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/oq/4o/vl/oq4ovlxewr3hxczaldchmbeyfua.png" alt="gambar"><br><br>  Dan secara opsional menurunkan dimensi input dan output dari setiap lapisan pada grafik yang dibangun: <br><br><pre> <code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string"><span class="hljs-string">'my_first_model_with_shape_info.png'</span></span>, show_shapes=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/fn/rm/hc/fnrmhcqknnsjdcgmqp9w6dpong8.png" alt="gambar"><br><br>  Gambar ini dan kode yang kami tulis identik.  Dalam versi kode, panah yang mengikat hanya diganti dengan operasi panggilan. <br><br>  "Lapisan grafik" adalah gambar mental yang sangat intuitif untuk model pembelajaran yang mendalam, dan API Fungsional adalah cara untuk membuat model yang mencerminkan citra mental ini secara dekat. <br><br><h2>  Pelatihan, penilaian dan kesimpulan </h2><br>  Mempelajari, mengevaluasi, dan menurunkan pekerjaan untuk model yang dibuat menggunakan API Fungsional seperti pada model Sequential. <br><br>  Pertimbangkan demo cepat. <br><br>  Di sini kita memuat dataset gambar MNIST, mengubahnya menjadi vektor, melatih model pada data (sambil memantau kualitas pekerjaan pada sampel uji), dan akhirnya kami mengevaluasi model kami pada data uji: <br><br><pre> <code class="python hljs">(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data() x_train = x_train.reshape(<span class="hljs-number"><span class="hljs-number">60000</span></span>, <span class="hljs-number"><span class="hljs-number">784</span></span>).astype(<span class="hljs-string"><span class="hljs-string">'float32'</span></span>) / <span class="hljs-number"><span class="hljs-number">255</span></span> x_test = x_test.reshape(<span class="hljs-number"><span class="hljs-number">10000</span></span>, <span class="hljs-number"><span class="hljs-number">784</span></span>).astype(<span class="hljs-string"><span class="hljs-string">'float32'</span></span>) / <span class="hljs-number"><span class="hljs-number">255</span></span> model.compile(loss=<span class="hljs-string"><span class="hljs-string">'sparse_categorical_crossentropy'</span></span>, optimizer=keras.optimizers.RMSprop(), metrics=[<span class="hljs-string"><span class="hljs-string">'accuracy'</span></span>]) history = model.fit(x_train, y_train, batch_size=<span class="hljs-number"><span class="hljs-number">64</span></span>, epochs=<span class="hljs-number"><span class="hljs-number">5</span></span>, validation_split=<span class="hljs-number"><span class="hljs-number">0.2</span></span>) test_scores = model.evaluate(x_test, y_test, verbose=<span class="hljs-number"><span class="hljs-number">2</span></span>) print(<span class="hljs-string"><span class="hljs-string">'Test loss:'</span></span>, test_scores[<span class="hljs-number"><span class="hljs-number">0</span></span>]) print(<span class="hljs-string"><span class="hljs-string">'Test accuracy:'</span></span>, test_scores[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre> <br><h2>  Menyimpan dan Serializing </h2><br>  Menyimpan dan membuat serial untuk model yang dibangun menggunakan Fungsional API bekerja persis sama dengan untuk model Sequential. <br><br>  Cara standar untuk menyimpan model Fungsional adalah memanggil <code>model.save(</code> ), yang memungkinkan Anda menyimpan seluruh model dalam satu file. <br><br>  Anda nanti dapat mengembalikan model yang sama dari file ini, bahkan jika Anda tidak lagi memiliki akses ke kode yang membuat model. <br><br>  File ini termasuk: <br><br><ul><li>  Arsitektur model </li><li>  Bobot model (yang diperoleh selama pelatihan) </li><li>  Konfigurasi pelatihan model (apa yang Anda lewati dalam <code>compile</code> ) </li><li>  Pengoptimal dan kondisinya, jika itu (ini memungkinkan Anda untuk melanjutkan pelatihan dari tempat Anda tinggalkan) </li></ul><br><pre> <code class="python hljs">model.save(<span class="hljs-string"><span class="hljs-string">'path_to_my_model.h5'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">del</span></span> model <span class="hljs-comment"><span class="hljs-comment"># Recreate the exact same model purely from the file: model = keras.models.load_model('path_to_my_model.h5')</span></span></code> </pre><br><h2>  Menggunakan grafik lapisan yang sama untuk mendefinisikan beberapa model </h2><br>  Dalam Fungsional API, model dibuat dengan menentukan input dan output data dalam grafik layer.  Ini berarti bahwa grafik lapisan tunggal dapat digunakan untuk menghasilkan beberapa model. <br><br>  Dalam contoh di bawah ini, kami menggunakan tumpukan lapisan yang sama untuk membuat dua model: <br>  model <code> (encoder)</code> yang mengubah gambar input menjadi vektor 16 dimensi, dan model <code> (autoencoder)</code> ujung ke ujung untuk pelatihan. <br><br><pre> <code class="python hljs">encoder_input = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), name=<span class="hljs-string"><span class="hljs-string">'img'</span></span>) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(encoder_input) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.MaxPooling2D(<span class="hljs-number"><span class="hljs-number">3</span></span>)(x) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) encoder_output = layers.GlobalMaxPooling2D()(x) encoder = keras.Model(encoder_input, encoder_output, name=<span class="hljs-string"><span class="hljs-string">'encoder'</span></span>) encoder.summary() x = layers.Reshape((<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>))(encoder_output) x = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.UpSampling2D(<span class="hljs-number"><span class="hljs-number">3</span></span>)(x) x = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) decoder_output = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) autoencoder = keras.Model(encoder_input, decoder_output, name=<span class="hljs-string"><span class="hljs-string">'autoencoder'</span></span>) autoencoder.summary()</code> </pre><br>  Harap dicatat bahwa kami membuat arsitektur penguraian secara simetris dengan arsitektur pengodean, sehingga kami mendapatkan dimensi data output sama dengan data input <code>(28, 28, 1)</code> .  Lapisan <code>Conv2D</code> ke lapisan <code>Conv2D</code> , dan lapisan <code>MaxPooling2D</code> akan menjadi kembali ke lapisan <code>MaxPooling2D</code> . <br><br><h2>  Model dapat disebut sebagai lapisan </h2><br>  Anda dapat menggunakan model apa saja seolah-olah itu adalah lapisan, memanggilnya pada <code>Input</code> atau pada output dari lapisan lain. <br><br>  Perhatikan bahwa dengan menggunakan model, Anda tidak hanya menggunakan kembali arsitekturnya, Anda juga menggunakan kembali bobotnya.  Mari kita lihat dalam aksi.  Berikut ini contoh lain dari auto-encoder, ketika model encoder, model decoder dibuat, dan mereka terhubung dalam dua panggilan untuk mendapatkan model auto-encoder: <br><br><pre> <code class="python hljs">encoder_input = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), name=<span class="hljs-string"><span class="hljs-string">'original_img'</span></span>) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(encoder_input) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.MaxPooling2D(<span class="hljs-number"><span class="hljs-number">3</span></span>)(x) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) encoder_output = layers.GlobalMaxPooling2D()(x) encoder = keras.Model(encoder_input, encoder_output, name=<span class="hljs-string"><span class="hljs-string">'encoder'</span></span>) encoder.summary() decoder_input = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">16</span></span>,), name=<span class="hljs-string"><span class="hljs-string">'encoded_img'</span></span>) x = layers.Reshape((<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>))(decoder_input) x = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.UpSampling2D(<span class="hljs-number"><span class="hljs-number">3</span></span>)(x) x = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) decoder_output = layers.Conv2DTranspose(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) decoder = keras.Model(decoder_input, decoder_output, name=<span class="hljs-string"><span class="hljs-string">'decoder'</span></span>) decoder.summary() autoencoder_input = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), name=<span class="hljs-string"><span class="hljs-string">'img'</span></span>) encoded_img = encoder(autoencoder_input) decoded_img = decoder(encoded_img) autoencoder = keras.Model(autoencoder_input, decoded_img, name=<span class="hljs-string"><span class="hljs-string">'autoencoder'</span></span>) autoencoder.summary()</code> </pre> <br>  Seperti yang Anda lihat, sebuah model dapat disarangkan: sebuah model dapat berisi submodel (karena model dapat dianggap sebagai layer). <br><br>  Kasus penggunaan umum untuk model bersarang adalah <i>ansambel</i> . <br><br>  Sebagai contoh, inilah cara menggabungkan satu set model menjadi satu model yang rata-rata perkiraannya: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_model</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> inputs = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">128</span></span>,)) outputs = layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>)(inputs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keras.Model(inputs, outputs) model1 = get_model() model2 = get_model() model3 = get_model() inputs = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">128</span></span>,)) y1 = model1(inputs) y2 = model2(inputs) y3 = model3(inputs) outputs = layers.average([y1, y2, y3]) ensemble_model = keras.Model(inputs=inputs, outputs=outputs)</code> </pre> <br><br><h2>  Memanipulasi topologi grafik yang kompleks </h2><br><h3>  Model dengan banyak input dan output </h3><br>  API Fungsional menyederhanakan manipulasi beberapa input dan output.  Ini tidak dapat dilakukan dengan Sequential API. <br><br>  Ini adalah contoh sederhana. <br><br>  Misalkan Anda membuat sistem untuk menentukan peringkat aplikasi pelanggan berdasarkan prioritas dan mengirimkannya ke departemen yang tepat. <br><br>  Model Anda akan memiliki 3 input: <br><br><ul><li>  Header Aplikasi (input teks) </li><li>  Konten teks dari aplikasi (input teks) </li><li>  Tag apa pun yang ditambahkan oleh pengguna (input kategorikal) </li></ul><br>  Model akan memiliki 2 output: <br><br><ul><li>  Skor prioritas antara 0 dan 1 (skalar sigmoid output) </li><li>  Departemen yang harus memproses aplikasi (output softmax mengenai banyak departemen) </li></ul><br>  Mari kita membangun model dalam beberapa baris menggunakan API Fungsional. <br><br><pre> <code class="python hljs">num_tags = <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-comment"><span class="hljs-comment">#     num_words = 10000 #         num_departments = 4 #     title_input = keras.Input(shape=(None,), name='title') #      body_input = keras.Input(shape=(None,), name='body') #      tags_input = keras.Input(shape=(num_tags,), name='tags') #    `num_tags` #      64-  title_features = layers.Embedding(num_words, 64)(title_input) #      64-  body_features = layers.Embedding(num_words, 64)(body_input) #        128-  title_features = layers.LSTM(128)(title_features) #        32-  body_features = layers.LSTM(32)(body_features) #          x = layers.concatenate([title_features, body_features, tags_input]) #         priority_pred = layers.Dense(1, activation='sigmoid', name='priority')(x) #       department_pred = layers.Dense(num_departments, activation='softmax', name='department')(x) #   ,     model = keras.Model(inputs=[title_input, body_input, tags_input], outputs=[priority_pred, department_pred])</span></span></code> </pre> <br>  Mari kita menggambar grafik model: <br><br><pre> <code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string"><span class="hljs-string">'multi_input_and_output_model.png'</span></span>, show_shapes=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/gc/hk/uw/gchkuwc_zgefnaf4tx0ercck8bc.png"><br><br>  Saat mengkompilasi model ini, kami dapat menetapkan fungsi kerugian yang berbeda untuk setiap output. <br><br>  Anda bahkan dapat menetapkan bobot yang berbeda untuk setiap fungsi kerugian untuk memvariasikan kontribusinya terhadap keseluruhan fungsi hilangnya pembelajaran. <br><br><pre> <code class="python hljs">model.compile(optimizer=keras.optimizers.RMSprop(<span class="hljs-number"><span class="hljs-number">1e-3</span></span>), loss=[<span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, <span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span></span>], loss_weights=[<span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>])</code> </pre> <br>  Karena kami memberi nama ke lapisan output kami, kami juga dapat menentukan fungsi kerugian: <br><br><pre> <code class="python hljs">model.compile(optimizer=keras.optimizers.RMSprop(<span class="hljs-number"><span class="hljs-number">1e-3</span></span>), loss={<span class="hljs-string"><span class="hljs-string">'priority'</span></span>: <span class="hljs-string"><span class="hljs-string">'binary_crossentropy'</span></span>, <span class="hljs-string"><span class="hljs-string">'department'</span></span>: <span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span></span>}, loss_weights=[<span class="hljs-number"><span class="hljs-number">1.</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>])</code> </pre> <br>  Kita dapat melatih model dengan melewati daftar array input dan label Numpy: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> np <span class="hljs-comment"><span class="hljs-comment"># Dummy input data title_data = np.random.randint(num_words, size=(1280, 10)) body_data = np.random.randint(num_words, size=(1280, 100)) tags_data = np.random.randint(2, size=(1280, num_tags)).astype('float32') # Dummy target data priority_targets = np.random.random(size=(1280, 1)) dept_targets = np.random.randint(2, size=(1280, num_departments)) model.fit({'title': title_data, 'body': body_data, 'tags': tags_data}, {'priority': priority_targets, 'department': dept_targets}, epochs=2, batch_size=32)</span></span></code> </pre><br>  Ketika memanggil cocok dengan objek <code>Dataset</code> , salah satu tupel daftar seperti <code>([title_data, body_data, tags_data], [priority_targets, dept_targets])</code> , atau tupel kamus <code>({'title': title_data, 'body': body_data, 'tags': tags_data}, {'priority': priority_targets, 'department': dept_targets})</code> harus dikembalikan <code>({'title': title_data, 'body': body_data, 'tags': tags_data}, {'priority': priority_targets, 'department': dept_targets})</code> . <br><br><h3>  Pelatihan model resnet </h3><br>  Selain model dengan banyak input dan output, API Fungsional menyederhanakan manipulasi topologi dengan konektivitas non-linear, yaitu model di mana lapisan yang tidak terhubung secara seri.  Model semacam itu juga tidak dapat diimplementasikan menggunakan Sequential API (sesuai namanya). <br><br>  Kasus penggunaan umum untuk ini adalah koneksi residual. <br><br>  Mari kita membangun model pelatihan ResNet untuk CIFAR10 untuk mendemonstrasikan ini. <br><br><pre> <code class="python hljs">inputs = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>), name=<span class="hljs-string"><span class="hljs-string">'img'</span></span>) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(inputs) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) block_1_output = layers.MaxPooling2D(<span class="hljs-number"><span class="hljs-number">3</span></span>)(x) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(block_1_output) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) block_2_output = layers.add([x, block_1_output]) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(block_2_output) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>, padding=<span class="hljs-string"><span class="hljs-string">'same'</span></span>)(x) block_3_output = layers.add([x, block_2_output]) x = layers.Conv2D(<span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(block_3_output) x = layers.GlobalAveragePooling2D()(x) x = layers.Dense(<span class="hljs-number"><span class="hljs-number">256</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(x) x = layers.Dropout(<span class="hljs-number"><span class="hljs-number">0.5</span></span>)(x) outputs = layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'softmax'</span></span>)(x) model = keras.Model(inputs, outputs, name=<span class="hljs-string"><span class="hljs-string">'toy_resnet'</span></span>) model.summary()</code> </pre> <br>  Mari kita menggambar grafik model: <br><br><pre> <code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string"><span class="hljs-string">'mini_resnet.png'</span></span>, show_shapes=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre> <br><img src="https://habrastorage.org/webt/qj/vi/bk/qjvibkpx9zrbp09rcfhj_drtlzc.png"><br><br>  Dan ajari dia: <br><br><pre> <code class="python hljs">(x_train, y_train), (x_test, y_test) = keras.datasets.cifar10.load_data() x_train = x_train.astype(<span class="hljs-string"><span class="hljs-string">'float32'</span></span>) / <span class="hljs-number"><span class="hljs-number">255.</span></span> x_test = x_test.astype(<span class="hljs-string"><span class="hljs-string">'float32'</span></span>) / <span class="hljs-number"><span class="hljs-number">255.</span></span> y_train = keras.utils.to_categorical(y_train, <span class="hljs-number"><span class="hljs-number">10</span></span>) y_test = keras.utils.to_categorical(y_test, <span class="hljs-number"><span class="hljs-number">10</span></span>) model.compile(optimizer=keras.optimizers.RMSprop(<span class="hljs-number"><span class="hljs-number">1e-3</span></span>), loss=<span class="hljs-string"><span class="hljs-string">'categorical_crossentropy'</span></span>, metrics=[<span class="hljs-string"><span class="hljs-string">'acc'</span></span>]) model.fit(x_train, y_train, batch_size=<span class="hljs-number"><span class="hljs-number">64</span></span>, epochs=<span class="hljs-number"><span class="hljs-number">1</span></span>, validation_split=<span class="hljs-number"><span class="hljs-number">0.2</span></span>)</code> </pre> <br><h2>  Berbagi lapisan </h2><br>  Penggunaan lain yang baik dari Functional API adalah model yang menggunakan lapisan umum.  Lapisan umum adalah contoh lapisan yang digunakan kembali dalam model yang sama: mereka mempelajari fitur yang berhubungan dengan beberapa jalur dalam grafik lapisan. <br><br>  Lapisan umum sering digunakan untuk menyandikan data input yang berasal dari ruang yang sama (misalnya, dari dua bagian teks yang memiliki kamus yang sama), karena mereka memberikan pertukaran informasi antara data yang berbeda ini, yang memungkinkan model semacam itu untuk dilatih dengan data yang lebih sedikit.  Jika kata tertentu muncul di salah satu input, ini akan memudahkan pemrosesan pada semua input yang melewati level umum. <br><br>  Untuk berbagi lapisan dalam Fungsional API, panggil instance dari lapisan yang sama beberapa kali.  Sebagai contoh, di sini layer <code>Embedding</code> dibagi pada dua input teks: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   1000    128-  shared_embedding = layers.Embedding(1000, 128) #     text_input_a = keras.Input(shape=(None,), dtype='int32') #     text_input_b = keras.Input(shape=(None,), dtype='int32') #           encoded_input_a = shared_embedding(text_input_a) encoded_input_b = shared_embedding(text_input_b)</span></span></code> </pre> <br><h2>  Mengambil dan menggunakan kembali node dalam grafik layer </h2><br>  Karena grafik lapisan yang Anda manipulasi dalam Fungsional API adalah struktur data statis, Anda dapat mengaksesnya dan memeriksanya.  Inilah cara kami membangun model Fungsional, misalnya, dalam bentuk gambar. <br><br>  Ini juga berarti bahwa kita dapat mengakses aktivasi lapisan menengah ("node" dalam grafik) dan menggunakannya di tempat lain.  Ini sangat berguna untuk mengekstraksi sifat, misalnya! <br><br>  Mari kita lihat sebuah contoh.  Ini adalah model VGG19 dengan timbangan yang telah dilatih sebelumnya di ImageNet: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tensorflow.keras.applications <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> VGG19 vgg19 = VGG19()</code> </pre> <br>  Dan ini adalah aktivasi model menengah yang diperoleh dengan menanyakan struktur data grafik: <br><br><pre> <code class="python hljs">features_list = [layer.output <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> layer <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vgg19.layers]</code> </pre> <br>  Kita dapat menggunakan fitur ini untuk membuat model ekstraksi fitur baru yang mengembalikan nilai aktivasi tingkat menengah - dan kita bisa melakukan semuanya dalam 3 baris <br><br><pre> <code class="python hljs">feat_extraction_model = keras.Model(inputs=vgg19.input, outputs=features_list) img = np.random.random((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">224</span></span>, <span class="hljs-number"><span class="hljs-number">224</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)).astype(<span class="hljs-string"><span class="hljs-string">'float32'</span></span>) extracted_features = feat_extraction_model(img)</code> </pre> <br>  Ini nyaman saat menerapkan transfer gaya saraf, seperti dalam kasus lain. <br><br><h2>  Memperluas API dengan menulis lapisan khusus </h2><br>  <code>tf.keras</code> memiliki berbagai lapisan <code>tf.keras</code> .  Berikut ini beberapa contohnya: <br><br>  Lapisan konvolusional: <code>Conv1D</code> , <code>Conv2D</code> , <code>Conv3D</code> , <code>Conv2DTranspose</code> , dll. <br>  Lapisan <code>MaxPooling1D</code> : <code>MaxPooling1D</code> , <code>MaxPooling2D</code> , <code>MaxPooling3D</code> , <code>MaxPooling3D</code> , dll. <br>  Lapisan RNN: <code>GRU</code> , <code>LSTM</code> , <code>ConvLSTM2D</code> , dll. <br>  <code>BatchNormalization</code> , <code>Dropout</code> , <code>Embedding</code> , dll. <br><br>  Jika Anda belum menemukan yang Anda butuhkan, mudah untuk memperpanjang API dengan membuat layer Anda sendiri. <br><br>  Semua lapisan subkelas kelas <code>Layer</code> dan mengimplementasikan: <br><br>  Metode <code>call</code> yang mendefinisikan perhitungan yang dilakukan oleh layer. <br>  Metode <code>build</code> yang menciptakan bobot layer (perhatikan bahwa ini hanya konvensi gaya; Anda juga bisa membuat bobot dalam <code>__init__</code> ). <br><br>  Berikut ini adalah implementasi sederhana dari layer <code>Dense</code> : <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomDense</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(layers.Layer)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, units=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> super(CustomDense, self).__init__() self.units = units <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, input_shape)</span></span></span><span class="hljs-function">:</span></span> self.w = self.add_weight(shape=(input_shape[<span class="hljs-number"><span class="hljs-number">-1</span></span>], self.units), initializer=<span class="hljs-string"><span class="hljs-string">'random_normal'</span></span>, trainable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) self.b = self.add_weight(shape=(self.units,), initializer=<span class="hljs-string"><span class="hljs-string">'random_normal'</span></span>, trainable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, inputs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tf.matmul(inputs, self.w) + self.b inputs = keras.Input((<span class="hljs-number"><span class="hljs-number">4</span></span>,)) outputs = CustomDense(<span class="hljs-number"><span class="hljs-number">10</span></span>)(inputs) model = keras.Model(inputs, outputs)</code> </pre> <br>  Jika Anda ingin layer kustom Anda mendukung serialisasi, Anda juga harus mendefinisikan metode <code>get_config</code> yang mengembalikan argumen konstruktor dari instance layer: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomDense</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(layers.Layer)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, units=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> super(CustomDense, self).__init__() self.units = units <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, input_shape)</span></span></span><span class="hljs-function">:</span></span> self.w = self.add_weight(shape=(input_shape[<span class="hljs-number"><span class="hljs-number">-1</span></span>], self.units), initializer=<span class="hljs-string"><span class="hljs-string">'random_normal'</span></span>, trainable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) self.b = self.add_weight(shape=(self.units,), initializer=<span class="hljs-string"><span class="hljs-string">'random_normal'</span></span>, trainable=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, inputs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tf.matmul(inputs, self.w) + self.b <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">'units'</span></span>: self.units} inputs = keras.Input((<span class="hljs-number"><span class="hljs-number">4</span></span>,)) outputs = CustomDense(<span class="hljs-number"><span class="hljs-number">10</span></span>)(inputs) model = keras.Model(inputs, outputs) config = model.get_config() new_model = keras.Model.from_config( config, custom_objects={<span class="hljs-string"><span class="hljs-string">'CustomDense'</span></span>: CustomDense})</code> </pre> <br>  Secara opsional, Anda juga dapat mengimplementasikan metode kelas <code>from_config (cls, config)</code> , yang bertanggung jawab untuk membuat kembali instance layer, mengingat kamus konfigurasinya.  <code>from_config</code> default <code>from_config</code> terlihat seperti ini: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">from_config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, config)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cls(**config)</code> </pre> <br><h2>  Kapan menggunakan API Fungsional </h2><br>  Bagaimana menentukan kapan lebih baik menggunakan Fungsional API untuk membuat model baru, atau cukup dengan subkelas <code>Model</code> secara langsung? <br><br>  Secara umum, Functional API lebih tingkat tinggi dan mudah digunakan, ia memiliki sejumlah fungsi yang tidak didukung oleh model subclass. <br><br>  Namun, subkelas Model memberi Anda fleksibilitas besar saat membuat model yang tidak mudah digambarkan sebagai grafik lapisan asiklik yang diarahkan (misalnya, Anda tidak dapat mengimplementasikan Tree-RNN dengan API Fungsional, Anda perlu subklas <code>Model</code> secara langsung). <br><br><h3>  Kekuatan API Fungsional: </h3><br>  Properti yang tercantum di bawah ini semuanya benar untuk model Sequential (yang juga merupakan struktur data), tetapi mereka berlaku untuk model subkelas (yang merupakan kode Python, bukan struktur data). <br><br><h4>  API Fungsional menghasilkan kode yang lebih pendek. </h4><br>  Tidak ada <code>super(MyClass, self).__init__(...)</code> , tidak ada <code>def call(self, ...):</code> dll. <br><br>  Bandingkan: <br><br><pre> <code class="python hljs">inputs = keras.Input(shape=(<span class="hljs-number"><span class="hljs-number">32</span></span>,)) x = layers.Dense(<span class="hljs-number"><span class="hljs-number">64</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>)(inputs) outputs = layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>)(x) mlp = keras.Model(inputs, outputs)</code> </pre> <br>  Dengan versi subklas: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MLP</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(keras.Model)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super(MLP, self).__init__(**kwargs) self.dense_1 = layers.Dense(<span class="hljs-number"><span class="hljs-number">64</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'relu'</span></span>) self.dense_2 = layers.Dense(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, inputs)</span></span></span><span class="hljs-function">:</span></span> x = self.dense_1(inputs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.dense_2(x) <span class="hljs-comment"><span class="hljs-comment">#   . mlp = MLP() #    . #            . _ = mlp(tf.zeros((1, 32)))</span></span></code> </pre> <br><h4>  Model Anda divalidasi saat ditulis. </h4><br>  Dalam Fungsional API, spesifikasi input (bentuk dan tipe) dibuat terlebih dahulu (melalui `Input`), dan setiap kali Anda memanggil layer, layer memeriksa bahwa spesifikasi yang diteruskan sesuai dengan asumsi, jika tidak, Anda akan menerima pesan kesalahan yang berguna . <br><br>  Ini memastikan bahwa model apa pun yang Anda bangun dengan API Fungsional dimulai.  Semua debugging (tidak terkait dengan debugging konvergensi) akan terjadi secara statis selama konstruksi model, dan tidak pada saat dijalankan.  Ini mirip dengan mengetikkan pengecekan di kompiler. <br><br><h4>  Model Fungsional Anda dapat direpresentasikan secara grafis, dan juga dapat diuji. </h4><br>  Anda dapat menggambar model dalam bentuk grafik, dan Anda dapat dengan mudah mengakses node perantara dari grafik, misalnya, untuk mengekstrak dan menggunakan kembali aktivasi lapisan menengah, seperti yang kita lihat dalam contoh sebelumnya: <br><br><pre> <code class="plaintext hljs">features_list = [layer.output for layer in vgg19.layers] feat_extraction_model = keras.Model(inputs=vgg19.input, outputs=features_list)</code> </pre> <br>  Karena model Fungsional lebih merupakan struktur data daripada sepotong kode, maka dapat diserialisasi dengan aman dan dapat disimpan sebagai file tunggal yang memungkinkan Anda membuat ulang model yang persis sama tanpa akses ke kode sumber. <br><br><h3>  Kelemahan API Fungsional </h3><br><h4>  Itu tidak mendukung arsitektur dinamis. </h4><br>  API Fungsional memproses model sebagai lapisan DAG.  Ini berlaku untuk arsitektur pembelajaran yang paling mendalam, tetapi tidak untuk semua orang: misalnya, jaringan rekursif atau RNN Pohon tidak memenuhi asumsi ini dan tidak dapat diimplementasikan dalam API Fungsional. <br><br><h4>  Terkadang Anda hanya perlu menulis semuanya dari awal. </h4><br>  Saat menulis arsitektur canggih, Anda mungkin ingin melakukan sesuatu yang melampaui "mendefinisikan lapisan DAG": misalnya, Anda dapat menggunakan beberapa pelatihan khusus dan metode output pada contoh model Anda.  Ini membutuhkan subklasifikasi. <br><br><h2>  Menggabungkan dan menggabungkan berbagai gaya API </h2><br>  Penting untuk dicatat bahwa memilih antara Fungsional API atau subkelas Model bukanlah solusi biner yang membatasi Anda untuk satu kategori model.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semua model dalam API tf.keras dapat berinteraksi satu sama lain, baik itu model Sequential, model Fungsional, atau Model / Layers subkelas yang ditulis dari awal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda selalu dapat menggunakan model Fungsional atau model Sequential sebagai bagian dari Model / Lapisan subclass:</font></font><br><br><pre> <code class="python hljs">units = <span class="hljs-number"><span class="hljs-number">32</span></span> timesteps = <span class="hljs-number"><span class="hljs-number">10</span></span> input_dim = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-comment"><span class="hljs-comment"># Define a Functional model inputs = keras.Input((None, units)) x = layers.GlobalAveragePooling1D()(inputs) outputs = layers.Dense(1, activation='sigmoid')(x) model = keras.Model(inputs, outputs) class CustomRNN(layers.Layer): def __init__(self): super(CustomRNN, self).__init__() self.units = units self.projection_1 = layers.Dense(units=units, activation='tanh') self.projection_2 = layers.Dense(units=units, activation='tanh') # Our previously-defined Functional model self.classifier = model def call(self, inputs): outputs = [] state = tf.zeros(shape=(inputs.shape[0], self.units)) for t in range(inputs.shape[1]): x = inputs[:, t, :] h = self.projection_1(x) y = h + self.projection_2(state) state = y outputs.append(y) features = tf.stack(outputs, axis=1) print(features.shape) return self.classifier(features) rnn_model = CustomRNN() _ = rnn_model(tf.zeros((1, timesteps, input_dim)))</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebaliknya, Anda dapat menggunakan Lapisan atau Model subkelas apa pun di API Fungsional jika Anda menerapkan metode </font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang cocok dengan salah satu pola berikut: di </font></font><br><br> <code>call(self, inputs, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mana </font></font><code>inputs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struktur tensor atau bersarang tensor (mis. Daftar tensor), dan di mana </font></font><code>**kwargs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">argumen non-tensor (bukan input) . </font></font><br> <code>call(self, inputs, training=None, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana </font></font><code>training</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai Boolean menunjukkan dalam mode apa layer, pembelajaran atau output harus berperilaku. </font></font><br> <code>call(self, inputs, mask=None, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana </font></font><code>mask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tensor topeng boolean (berguna untuk RNN, misalnya). </font></font><br> <code>call(self, inputs, training=None, mask=None, **kwargs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- tentu saja Anda dapat memiliki kedua parameter yang mendefinisikan perilaku layer pada saat yang sama.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain itu, jika Anda menerapkan metode `get_config` pada Layer atau Model kustom Anda, model Fungsional yang Anda buat dengannya akan serializable dan dikloning. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah ini adalah contoh kecil di mana kami menggunakan RNN khusus yang ditulis dari awal Model fungsional:</font></font><br><br><pre> <code class="python hljs">units = <span class="hljs-number"><span class="hljs-number">32</span></span> timesteps = <span class="hljs-number"><span class="hljs-number">10</span></span> input_dim = <span class="hljs-number"><span class="hljs-number">5</span></span> batch_size = <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomRNN</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(layers.Layer)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super(CustomRNN, self).__init__() self.units = units self.projection_1 = layers.Dense(units=units, activation=<span class="hljs-string"><span class="hljs-string">'tanh'</span></span>) self.projection_2 = layers.Dense(units=units, activation=<span class="hljs-string"><span class="hljs-string">'tanh'</span></span>) self.classifier = layers.Dense(<span class="hljs-number"><span class="hljs-number">1</span></span>, activation=<span class="hljs-string"><span class="hljs-string">'sigmoid'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, inputs)</span></span></span><span class="hljs-function">:</span></span> outputs = [] state = tf.zeros(shape=(inputs.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>], self.units)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(inputs.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]): x = inputs[:, t, :] h = self.projection_1(x) y = h + self.projection_2(state) state = y outputs.append(y) features = tf.stack(outputs, axis=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.classifier(features) <span class="hljs-comment"><span class="hljs-comment">#           #  `batch_shape`,     `CustomRNN`  #    (     `state`). inputs = keras.Input(batch_shape=(batch_size, timesteps, input_dim)) x = layers.Conv1D(32, 3)(inputs) outputs = CustomRNN()(x) model = keras.Model(inputs, outputs) rnn_model = CustomRNN() _ = rnn_model(tf.zeros((1, 10, 5)))</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menyimpulkan Panduan API Fungsional kami! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang Anda memiliki satu set alat yang kuat untuk membangun model pembelajaran yang mendalam.</font></font><br><br>  <i>Setelah verifikasi, terjemahan juga akan muncul di Tensorflow.org.</i>  <i>Jika Anda ingin berpartisipasi dalam terjemahan dokumentasi situs web Tensorflow.org ke dalam bahasa Rusia, silakan hubungi secara pribadi atau komentar.</i>  <i>Setiap koreksi atau komentar sangat dihargai.</i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai ilustrasi, kami menggunakan gambar model GoogLeNet, yang juga merupakan grafik asiklik terarah.</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id483664/">https://habr.com/ru/post/id483664/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id483652/index.html">Berbohong kepada saya jika Anda bisa: fitur melakukan pentest sosioteknik</a></li>
<li><a href="../id483654/index.html">Umpan balik dalam aksi unjuk rasa, satu lawan satu, mengapa mungkin tidak berhasil dan bagaimana cara memperbaikinya?</a></li>
<li><a href="../id483656/index.html">Tablo di ritel, benarkah?</a></li>
<li><a href="../id483660/index.html">Telegram-bot untuk manajemen infrastruktur</a></li>
<li><a href="../id483662/index.html">Integrasi Cisco Threat Response dan Cisco Stealthwatch Enterprise</a></li>
<li><a href="../id483666/index.html">Tentang Volodya dan ozonizer</a></li>
<li><a href="../id483670/index.html">Semua yang Anda ingin tahu tentang alamat MAC</a></li>
<li><a href="../id483674/index.html">Bagaimana jaringan syaraf biner bekerja, dan mengapa jaringan itu akan populer pada tahun 2020</a></li>
<li><a href="../id483676/index.html">Penilaian efektivitas dan biaya penerapan sistem analisis pemasaran end-to-end</a></li>
<li><a href="../id483678/index.html">Mengembangkan program Python yang sangat cepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>