<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🍳 🈁 ☠️ Wie kam dieser Beiwagencontainer hierher [bei Kubernetes]? 🏭 😝 👏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Mit diesem Artikel von Scott Rahner, einem Ingenieur bei Dow Jones, setzen wir die Reihe zahlreicher Materialien fort, die erklären, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie kam dieser Beiwagencontainer hierher [bei Kubernetes]?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/431252/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Mit diesem Artikel von Scott Rahner, einem Ingenieur bei Dow Jones, setzen wir die Reihe zahlreicher Materialien fort, die erklären, wie Kubernetes funktioniert, wie seine grundlegenden Komponenten funktionieren, miteinander verbunden und verwendet werden.</i>  <i>Diesmal ist dies ein praktischer Hinweis mit Beispielcode zum Erstellen eines Hooks in Kubernetes, der vom Autor unter dem Vorwand demonstriert wurde, automatisch Beiwagencontainer zu erstellen.</i> <br><br><img src="https://habrastorage.org/webt/xg/bh/80/xgbh80h6dyzuokwsgrcttaiqtxs.jpeg"><br>  <i>(Foto von Gordon A. Maxwell, im Internet gefunden.)</i> <br><br>  Als ich anfing, Beiwagencontainer und Servicegitter zu untersuchen, musste ich verstehen, wie der Schlüsselmechanismus funktioniert - das automatische Einsetzen eines Beiwagencontainers.  Bei der Verwendung von Systemen wie Istio oder Consul wird beim Bereitstellen des Containers mit der Anwendung plötzlich der bereits konfigurierte Envoy-Container in seinem Pod angezeigt <i>(eine ähnliche Situation tritt bei Conduit auf, über das wir zu Beginn des Jahres geschrieben haben - ca. Transl.)</i> .  Was?  Wie?  Also begann meine Forschung ... <a name="habracut"></a><br><br>  Für diejenigen, die es nicht wissen, ist ein Beiwagen-Container ein Container, der neben den Containern der Anwendung bereitgestellt wird, um dieser Anwendung auf irgendeine Weise zu „helfen“.  Ein Beispiel für eine solche Verwendung ist ein Proxy zum Verwalten des Datenverkehrs und zum Beenden von TLS-Sitzungen, ein Container zum Streamen von Protokollen und Metriken, ein Container zum Scannen von Sicherheitsproblemen ... Die Idee besteht darin, verschiedene Aspekte der gesamten Anwendung von der Geschäftslogik zu isolieren, indem für jeden separate Container verwendet werden Funktionen. <br><br>  Bevor ich fortfahre, werde ich meine Erwartungen skizzieren.  Der Zweck dieses Artikels besteht nicht darin, die Feinheiten und Verwendungsszenarien von Docker, Kubernetes, Service Mesh usw. zu erläutern, sondern einen leistungsstarken Ansatz zur Erweiterung der Funktionen dieser Technologien aufzuzeigen.  Der Artikel richtet sich an diejenigen, die bereits mit dem Einsatz dieser Technologien vertraut sind oder zumindest viel darüber gelesen haben.  Um den praktischen Teil in Aktion zu testen, benötigen Sie einen Computer mit bereits konfigurierten Docker und Kubernetes.  Der einfachste Weg, dies zu tun, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.docker.com/docker-for-windows/kubernetes/</a> (ein Windows-Handbuch, das mit Docker für Mac funktioniert).  <i>(Hinweis perev .: Als Alternative zu Benutzern von Linux- und * nix-Systemen können wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minikube</a> anbieten.)</i> <br><br><h2>  Gesamtbild </h2><br>  Schauen wir uns zunächst Kubernetes an: <br><br><img src="https://habrastorage.org/webt/gf/dh/2d/gfdh2deneli8j1ikyuutjbf2uvm.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kube Arch</a> lizenziert unter CC BY 4.0</i> <br><br>  Wenn Sie etwas für Kubernetes bereitstellen möchten, müssen Sie das Objekt an kube-apiserver senden.  Dies geschieht meistens durch Übergeben von Argumenten oder einer YAML-Datei an kubectl.  In diesem Fall durchläuft der API-Server mehrere Phasen, bevor die Daten direkt in etcd abgelegt und die entsprechenden Aufgaben geplant werden: <br><br><img src="https://habrastorage.org/webt/g-/mv/hw/g-mvhwfhhsoxrdofk2be2ezkrow.jpeg"><br><br>  Diese Reihenfolge ist wichtig, um zu verstehen, wie das Einsetzen von Beiwagencontainern funktioniert.  Insbesondere müssen Sie auf die Zugangskontrolle achten, bei der Kubernetes Objekte vor dem Speichern validiert und gegebenenfalls ändert <i>(weitere Einzelheiten zu diesem Schritt finden Sie im Kapitel "Zugangskontrolle" in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> - ca. Übersetzung)</i> .  Mit Kubernetes können Sie auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webhooks</a> registrieren, die benutzerdefinierte Validierungen und <i>Mutationen durchführen können</i> . <br><br>  Das Erstellen und Registrieren Ihrer Hooks ist jedoch nicht so einfach und gut dokumentiert.  Ich musste mehrere Tage damit verbringen, die Dokumentation zu lesen und erneut zu lesen sowie den Istio und Consul Code zu analysieren.  Und wenn es um den Code für einige der API-Antworten ging, verbrachte ich mindestens einen halben Tag damit, zufällige Versuche und Irrtümer durchzuführen. <br><br>  Nachdem das Ergebnis erreicht wurde, wird es meiner Meinung nach unfair sein, es nicht mit Ihnen allen zu teilen.  Es ist einfach und gleichzeitig effektiv. <br><br><h2>  Code </h2><br>  Der Name Webhook spricht für sich selbst - es ist ein HTTP-Endpunkt, der die in Kubernetes definierte API implementiert.  Sie erstellen einen API-Server, den Kubernetes aufrufen kann, bevor Sie sich mit Bereitstellungen befassen.  Ich musste mich hier mit Schwierigkeiten auseinandersetzen, da nur wenige Beispiele verfügbar sind, von denen einige nur Komponententests von Kubernetes sind, andere inmitten einer riesigen Codebasis versteckt sind ... und alle in Go geschrieben sind.  Aber ich habe mich für eine günstigere Option entschieden - Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(bodyParser.json()); app.post(<span class="hljs-string"><span class="hljs-string">'/mutate'</span></span>, (req, res) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body.request.object) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adminResp = {<span class="hljs-attr"><span class="hljs-attr">response</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">allowed</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">patch</span></span>: Buffer.from(<span class="hljs-string"><span class="hljs-string">"[{ \"op\": \"add\", \"path\": \"/metadata/labels/foo\", \"value\": \"bar\" }]"</span></span>).toString(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>), <span class="hljs-attr"><span class="hljs-attr">patchType</span></span>: <span class="hljs-string"><span class="hljs-string">"JSONPatch"</span></span>, }} <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(adminResp) res.send(adminResp) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = https.createServer(options, app);</code> </pre> <br>  <i>( <a href="">index.js</a> )</i> <br><br>  Der Pfad zur API - in diesem Fall <code>/mutate</code> - kann beliebig sein (er sollte nur der YAML entsprechen, die in Zukunft an Kubernetes übergeben wird).  Für ihn ist es wichtig, den vom API-Server empfangenen JSON zu sehen und zu verstehen.  In diesem Fall ziehen wir nichts aus JSON heraus, aber es kann in anderen Szenarien nützlich sein.  Im obigen Code aktualisieren wir JSON.  Dafür sind zwei Dinge erforderlich: <br><br><ol><li>  Lernen und verstehen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON Patch</a> . </li><li>  Konvertieren Sie einen JSON-Patch-Ausdruck korrekt in ein Array von Bytes, die mit base64 codiert sind. </li></ol><br>  Sobald dies erledigt ist, müssen Sie nur noch die Antwort mit einem sehr einfachen Objekt an den API-Server übergeben.  In diesem Fall fügen wir jedem Pod, der zu uns kommt, das Label <code>foo=bar</code> . <br><br><h2>  Bereitstellung </h2><br>  Nun, wir haben Code, der Anforderungen vom Kubernetes-API-Server akzeptiert und darauf reagiert, aber wie wird er bereitgestellt?  Und wie kann man Kubernetes dazu bringen, uns diese Anfragen umzuleiten?  Sie können einen solchen Endpunkt überall dort bereitstellen, wo Sie den Kubernetes-API-Server erreichen können.  Am einfachsten ist es, den Code im Kubernetes-Cluster selbst bereitzustellen, wie in diesem Beispiel beschrieben.  Ich habe versucht, das Beispiel so einfach wie möglich zu gestalten, daher verwende ich für alle Aktionen nur Docker und kubectl.  Beginnen wir mit der Erstellung eines Containers, in dem der Code ausgeführt wird: <br><br><pre> <code class="plaintext hljs">FROM node:8 USER node WORKDIR /home/node COPY index.js . COPY package.json . RUN npm install #       TLS CMD node index.js</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockerfile</a> )</i> <br><br>  Anscheinend ist hier alles sehr einfach.  Nehmen Sie das Community-Image vom Knoten und legen Sie den Code darin ab.  Jetzt können Sie eine einfache Montage durchführen: <br><br><pre> <code class="bash hljs">docker build . -t localserver</code> </pre> <br>  Der nächste Schritt besteht darin, eine Bereitstellung in Kubernetes zu erstellen: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: webhook-server spec: replicas: 1 selector: matchLabels: component: webhook-server template: metadata: labels: component: webhook-server spec: containers: - name: webhook-server imagePullPolicy: Never image: localserver</code> </pre> <br>  <i>( <a href="">deploy.yaml</a> )</i> <br><br>  Beachten Sie, wie wir auf das gerade erstellte Bild angespielt haben?  Es könnte genauso gut ein Pod sein und etwas anderes, mit dem wir einen Dienst in Kubernetes verbinden können.  Definieren Sie nun diesen Service: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: webhook-service spec: ports: - port: 443 targetPort: 8443 selector: component: webhook-server</code> </pre> <br>  In Kubernetes wird also ein Endpunkt mit einem internen Namen angezeigt, der auf unseren Container verweist.  Der letzte Schritt besteht darin, Kubernetes mitzuteilen, dass der API-Server diesen Dienst aufrufen soll, wenn er bereit ist, <i>Mutationen</i> vorzunehmen: <br><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: name: webhook webhooks: - name: webhook-service.default.svc failurePolicy: Fail clientConfig: service: name: webhook-service namespace: default path: "/mutate" #    base64-  rootCA.crt #    `cat rootCA.crt | base64 | tr -d '\n'` #    .  caBundle: "==" rules: - operations: [ "CREATE" ] apiGroups: [""] apiVersions: ["v1"] resources: ["pods"]</code> </pre>  <i>( <a href="">hook.yaml</a> )</i> <br><br>  Der Name und der Pfad hier können beliebig sein, aber ich habe versucht, sie so aussagekräftig wie möglich zu gestalten.  Wenn Sie den Pfad ändern, müssen Sie den entsprechenden Code in JavaScript ändern.  Webhook- <code>failurePolicy</code> ist ebenfalls <code>failurePolicy</code> - sie bestimmt, ob das Objekt gespeichert werden soll, wenn der Hook einen Fehler zurückgibt oder fehlschlägt.  In diesem Fall weisen wir Kubernetes an, die Verarbeitung nicht fortzusetzen.  Schließlich die Regeln: Sie ändern sich je nachdem, welche API-Aufrufe Sie von Kubernetes erwarten.  In diesem Fall müssen wir, da wir versuchen, das Einfügen eines Beiwagencontainers zu emulieren, Anforderungen abfangen, um einen Pod zu erstellen. <br><br>  Das ist alles!  So einfach ... aber was ist mit Sicherheit?  RBAC ist ein Aspekt, der im Artikel nicht behandelt wird.  Ich gehe davon aus, dass Sie das Beispiel in Minikube oder in Kubernetes ausführen, das mit Docker für Windows / Mac geliefert wird.  Ich werde Ihnen jedoch ein weiteres notwendiges Element erläutern.  Der Kubernetes-API-Server greift nur mit HTTPS auf Endpunkte zu, sodass für die Anwendung SSL-Zertifikate erforderlich sind.  Sie müssen Kubernetes auch mitteilen, wer die Zertifizierungsstelle des Stammzertifikats ist. <br><br><h2>  TLS </h2><br>  <b>Nur zu Demonstrationszwecken (!!!) habe</b> ich der <code>Dockerfile</code> Code <code>Dockerfile</code> , um eine <code>Dockerfile</code> zu erstellen und damit das Zertifikat zu signieren: <br><br><pre> <code class="plaintext hljs">RUN openssl genrsa -out rootCA.key 4096 RUN openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=*.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl genrsa -out webhook.key 4096 RUN openssl req -new -key webhook.key -out webhook.csr \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=webhook-service.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl x509 -req -in webhook.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out webhook.crt -days 1024 -sha256 RUN cat rootCA.crt | base64 | tr -d '\n'</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockerfile</a> )</i> <br><br>  Bitte beachten Sie: Der letzte Schritt besteht darin, eine einzelne Zeile mit der in base64 codierten Stammzertifizierungsstelle anzuzeigen.  Dies ist genau das, was für die Hook-Konfiguration erforderlich ist. Kopieren Sie diese Zeile in Ihren weiteren Tests <code>caBundle</code> in das Feld <code>caBundle</code> Datei <code>caBundle</code> .  <code>Dockerfile</code> wirft Zertifikate direkt in <code>WORKDIR</code> , sodass JavaScript sie nur von dort nimmt und für den Server verwendet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privateKey = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.key'</span></span>).toString(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> certificate = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.crt'</span></span>).toString(); <span class="hljs-comment"><span class="hljs-comment">//… const options = {key: privateKey, cert: certificate}; const server = https.createServer(options, app);</span></span></code> </pre> <br>  Jetzt unterstützt der Code den HTTPS-Start und teilt Kubernetes mit, wo wir zu finden sind und welchem ​​Vertrauenszentrum wir vertrauen sollen.  Es bleibt nur noch alles in einen Cluster einzubetten: <br><br><pre> <code class="bash hljs">kubectl create -f deployment.yaml kubectl create -f service.yaml kubectl create -f hook.yaml</code> </pre> <br><h3>  Fassen Sie zusammen </h3><br><ul><li>  <code>Deployment.yaml</code> startet einen Container, der die Hook-API über HTTPS bereitstellt, und gibt einen JSON-Patch zurück, um das Objekt zu ändern. </li><li>  <code>Service.yaml</code> stellt einen Endpunkt für den Container <code>webhook-service.default.svc</code> - <code>webhook-service.default.svc</code> . </li><li>  <code>Hook.yaml</code> teilt dem API-Server mit, wo er uns finden soll: <code>https://webhook-service.default.svc/mutate</code> . </li></ul><br><h2>  Versuchen wir es im Geschäft! </h2><br>  Alles wird in einem Cluster bereitgestellt - es ist Zeit, den Code in Aktion zu testen. Dazu fügen wir einen neuen Pod / eine neue Bereitstellung hinzu.  Wenn alles richtig funktioniert, muss der Hook ein zusätzliches Label <code>foo</code> hinzufügen: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: test spec: replicas: 1 selector: matchLabels: component: test template: metadata: labels: component: test spec: containers: - name: test image: node:8 command: [ "/bin/sh", "-c", "--" ] args: [ "while true; do sleep 30; done;" ]</code> </pre> <br>  <i>( <a href="">test.yaml</a> )</i> <br><br><pre> <code class="bash hljs">kubectl create -f test.yaml</code> </pre> <br>  Ok, wir haben gesehen, wie der <code>deployment.apps test created</code> ... aber hat es geklappt? <br><br><pre> <code class="bash hljs">kubectl describe pods <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-6f79f9f8bd-r7tbd Namespace: default Node: docker-for-desktop/192.168.65.3 Start Time: Sat, 10 Nov 2018 16:08:47 -0500 Labels: component=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> foo=bar</code> </pre> <br>  Großartig!  Obwohl <code>test.yaml</code> ein einzelnes Label ( <code>component</code> ) gegeben wurde, erhielt der resultierende Pod zwei: <code>component</code> und <code>foo</code> . <br><br><h2>  Hausaufgaben </h2><br>  Aber warte!  Verwenden wir diesen Code, um einen Beiwagencontainer zu erstellen?  Ich habe gewarnt, dass ich zeigen werde, <b>wie man</b> einen Beiwagen hinzufügt ... Und jetzt, mit dem Wissen und dem Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dowjones/k8s-webhook</a> - experimentieren Sie und finden Sie heraus, wie Sie Ihren automatisch eingefügten Beiwagen herstellen können.  Es ist ganz einfach: Sie müssen nur den richtigen JSON-Patch vorbereiten, der der Testbereitstellung einen zusätzlichen Container hinzufügt.  Viel Spaß beim Orchestrieren! <br><br><h2>  PS vom Übersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein Pod in Kubernetes?</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie hohe Verfügbarkeit bei Kubernetes bereitgestellt wird</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie funktioniert der Kubernetes-Scheduler tatsächlich?"</a>  "; </li><li>  "Was passiert in Kubernetes, wenn der Kubectl-Lauf startet?"  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC bei Kubernetes verstehen</a> "; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> “ <i>(Videobericht, der eine Einführung in das technische Gerät von Kubernetes enthält)</i> ; </li><li>  „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein Service-Mesh und warum brauche ich es?</a>  ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431252/">https://habr.com/ru/post/de431252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431242/index.html">TLS- und Webzertifikate</a></li>
<li><a href="../de431244/index.html">"Zwei ungefiltert" oder eine einfache Möglichkeit, ein Bein zu schießen</a></li>
<li><a href="../de431246/index.html">@ OpenStack Meetup bei Mail.Ru Group: 30. November</a></li>
<li><a href="../de431248/index.html">Wer ist agil verantwortlich für die Qualität der Entwicklung komplexer Projekte oder die Quality Gates-Methodik?</a></li>
<li><a href="../de431250/index.html">Anhänger der statischen und dynamischen Typisierung werden sich nie verstehen. Und TypeScript wird ihnen nicht helfen</a></li>
<li><a href="../de431254/index.html">Wie man an einem entfernten Ort gut lebt</a></li>
<li><a href="../de431256/index.html">Großbritannien und Holland verhängten gegen Uber eine Geldstrafe von 1,2 Millionen US-Dollar wegen Verlusts personenbezogener Daten</a></li>
<li><a href="../de431258/index.html">Dezember Webinare Kotlin 1.3</a></li>
<li><a href="../de431260/index.html">So funktioniert es: Die Arbeit eines Analystenteams am Beispiel der Entwicklung eines digitalen Dienstes</a></li>
<li><a href="../de431262/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 19: „Anonyme Netzwerke“, Teil 1 (Vorlesung des Erstellers des Tor-Netzwerks)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>