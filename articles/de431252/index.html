<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚Äçüç≥ üàÅ ‚ò†Ô∏è Wie kam dieser Beiwagencontainer hierher [bei Kubernetes]? üè≠ üòù üëè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hinweis perev. : Mit diesem Artikel von Scott Rahner, einem Ingenieur bei Dow Jones, setzen wir die Reihe zahlreicher Materialien fort, die erkl√§ren, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie kam dieser Beiwagencontainer hierher [bei Kubernetes]?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/431252/">  <i><b>Hinweis</b></i>  <i><b>perev.</b></i>  <i>: Mit diesem Artikel von Scott Rahner, einem Ingenieur bei Dow Jones, setzen wir die Reihe zahlreicher Materialien fort, die erkl√§ren, wie Kubernetes funktioniert, wie seine grundlegenden Komponenten funktionieren, miteinander verbunden und verwendet werden.</i>  <i>Diesmal ist dies ein praktischer Hinweis mit Beispielcode zum Erstellen eines Hooks in Kubernetes, der vom Autor unter dem Vorwand demonstriert wurde, automatisch Beiwagencontainer zu erstellen.</i> <br><br><img src="https://habrastorage.org/webt/xg/bh/80/xgbh80h6dyzuokwsgrcttaiqtxs.jpeg"><br>  <i>(Foto von Gordon A. Maxwell, im Internet gefunden.)</i> <br><br>  Als ich anfing, Beiwagencontainer und Servicegitter zu untersuchen, musste ich verstehen, wie der Schl√ºsselmechanismus funktioniert - das automatische Einsetzen eines Beiwagencontainers.  Bei der Verwendung von Systemen wie Istio oder Consul wird beim Bereitstellen des Containers mit der Anwendung pl√∂tzlich der bereits konfigurierte Envoy-Container in seinem Pod angezeigt <i>(eine √§hnliche Situation tritt bei Conduit auf, √ºber das wir zu Beginn des Jahres geschrieben haben - ca. Transl.)</i> .  Was?  Wie?  Also begann meine Forschung ... <a name="habracut"></a><br><br>  F√ºr diejenigen, die es nicht wissen, ist ein Beiwagen-Container ein Container, der neben den Containern der Anwendung bereitgestellt wird, um dieser Anwendung auf irgendeine Weise zu ‚Äûhelfen‚Äú.  Ein Beispiel f√ºr eine solche Verwendung ist ein Proxy zum Verwalten des Datenverkehrs und zum Beenden von TLS-Sitzungen, ein Container zum Streamen von Protokollen und Metriken, ein Container zum Scannen von Sicherheitsproblemen ... Die Idee besteht darin, verschiedene Aspekte der gesamten Anwendung von der Gesch√§ftslogik zu isolieren, indem f√ºr jeden separate Container verwendet werden Funktionen. <br><br>  Bevor ich fortfahre, werde ich meine Erwartungen skizzieren.  Der Zweck dieses Artikels besteht nicht darin, die Feinheiten und Verwendungsszenarien von Docker, Kubernetes, Service Mesh usw. zu erl√§utern, sondern einen leistungsstarken Ansatz zur Erweiterung der Funktionen dieser Technologien aufzuzeigen.  Der Artikel richtet sich an diejenigen, die bereits mit dem Einsatz dieser Technologien vertraut sind oder zumindest viel dar√ºber gelesen haben.  Um den praktischen Teil in Aktion zu testen, ben√∂tigen Sie einen Computer mit bereits konfigurierten Docker und Kubernetes.  Der einfachste Weg, dies zu tun, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://docs.docker.com/docker-for-windows/kubernetes/</a> (ein Windows-Handbuch, das mit Docker f√ºr Mac funktioniert).  <i>(Hinweis perev .: Als Alternative zu Benutzern von Linux- und * nix-Systemen k√∂nnen wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Minikube</a> anbieten.)</i> <br><br><h2>  Gesamtbild </h2><br>  Schauen wir uns zun√§chst Kubernetes an: <br><br><img src="https://habrastorage.org/webt/gf/dh/2d/gfdh2deneli8j1ikyuutjbf2uvm.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kube Arch</a> lizenziert unter CC BY 4.0</i> <br><br>  Wenn Sie etwas f√ºr Kubernetes bereitstellen m√∂chten, m√ºssen Sie das Objekt an kube-apiserver senden.  Dies geschieht meistens durch √úbergeben von Argumenten oder einer YAML-Datei an kubectl.  In diesem Fall durchl√§uft der API-Server mehrere Phasen, bevor die Daten direkt in etcd abgelegt und die entsprechenden Aufgaben geplant werden: <br><br><img src="https://habrastorage.org/webt/g-/mv/hw/g-mvhwfhhsoxrdofk2be2ezkrow.jpeg"><br><br>  Diese Reihenfolge ist wichtig, um zu verstehen, wie das Einsetzen von Beiwagencontainern funktioniert.  Insbesondere m√ºssen Sie auf die Zugangskontrolle achten, bei der Kubernetes Objekte vor dem Speichern validiert und gegebenenfalls √§ndert <i>(weitere Einzelheiten zu diesem Schritt finden Sie im Kapitel "Zugangskontrolle" in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Artikel</a> - ca. √úbersetzung)</i> .  Mit Kubernetes k√∂nnen Sie auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Webhooks</a> registrieren, die benutzerdefinierte Validierungen und <i>Mutationen durchf√ºhren k√∂nnen</i> . <br><br>  Das Erstellen und Registrieren Ihrer Hooks ist jedoch nicht so einfach und gut dokumentiert.  Ich musste mehrere Tage damit verbringen, die Dokumentation zu lesen und erneut zu lesen sowie den Istio und Consul Code zu analysieren.  Und wenn es um den Code f√ºr einige der API-Antworten ging, verbrachte ich mindestens einen halben Tag damit, zuf√§llige Versuche und Irrt√ºmer durchzuf√ºhren. <br><br>  Nachdem das Ergebnis erreicht wurde, wird es meiner Meinung nach unfair sein, es nicht mit Ihnen allen zu teilen.  Es ist einfach und gleichzeitig effektiv. <br><br><h2>  Code </h2><br>  Der Name Webhook spricht f√ºr sich selbst - es ist ein HTTP-Endpunkt, der die in Kubernetes definierte API implementiert.  Sie erstellen einen API-Server, den Kubernetes aufrufen kann, bevor Sie sich mit Bereitstellungen befassen.  Ich musste mich hier mit Schwierigkeiten auseinandersetzen, da nur wenige Beispiele verf√ºgbar sind, von denen einige nur Komponententests von Kubernetes sind, andere inmitten einer riesigen Codebasis versteckt sind ... und alle in Go geschrieben sind.  Aber ich habe mich f√ºr eine g√ºnstigere Option entschieden - Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(bodyParser.json()); app.post(<span class="hljs-string"><span class="hljs-string">'/mutate'</span></span>, (req, res) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body.request.object) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adminResp = {<span class="hljs-attr"><span class="hljs-attr">response</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">allowed</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">patch</span></span>: Buffer.from(<span class="hljs-string"><span class="hljs-string">"[{ \"op\": \"add\", \"path\": \"/metadata/labels/foo\", \"value\": \"bar\" }]"</span></span>).toString(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>), <span class="hljs-attr"><span class="hljs-attr">patchType</span></span>: <span class="hljs-string"><span class="hljs-string">"JSONPatch"</span></span>, }} <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(adminResp) res.send(adminResp) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = https.createServer(options, app);</code> </pre> <br>  <i>( <a href="">index.js</a> )</i> <br><br>  Der Pfad zur API - in diesem Fall <code>/mutate</code> - kann beliebig sein (er sollte nur der YAML entsprechen, die in Zukunft an Kubernetes √ºbergeben wird).  F√ºr ihn ist es wichtig, den vom API-Server empfangenen JSON zu sehen und zu verstehen.  In diesem Fall ziehen wir nichts aus JSON heraus, aber es kann in anderen Szenarien n√ºtzlich sein.  Im obigen Code aktualisieren wir JSON.  Daf√ºr sind zwei Dinge erforderlich: <br><br><ol><li>  Lernen und verstehen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JSON Patch</a> . </li><li>  Konvertieren Sie einen JSON-Patch-Ausdruck korrekt in ein Array von Bytes, die mit base64 codiert sind. </li></ol><br>  Sobald dies erledigt ist, m√ºssen Sie nur noch die Antwort mit einem sehr einfachen Objekt an den API-Server √ºbergeben.  In diesem Fall f√ºgen wir jedem Pod, der zu uns kommt, das Label <code>foo=bar</code> . <br><br><h2>  Bereitstellung </h2><br>  Nun, wir haben Code, der Anforderungen vom Kubernetes-API-Server akzeptiert und darauf reagiert, aber wie wird er bereitgestellt?  Und wie kann man Kubernetes dazu bringen, uns diese Anfragen umzuleiten?  Sie k√∂nnen einen solchen Endpunkt √ºberall dort bereitstellen, wo Sie den Kubernetes-API-Server erreichen k√∂nnen.  Am einfachsten ist es, den Code im Kubernetes-Cluster selbst bereitzustellen, wie in diesem Beispiel beschrieben.  Ich habe versucht, das Beispiel so einfach wie m√∂glich zu gestalten, daher verwende ich f√ºr alle Aktionen nur Docker und kubectl.  Beginnen wir mit der Erstellung eines Containers, in dem der Code ausgef√ºhrt wird: <br><br><pre> <code class="plaintext hljs">FROM node:8 USER node WORKDIR /home/node COPY index.js . COPY package.json . RUN npm install #       TLS CMD node index.js</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockerfile</a> )</i> <br><br>  Anscheinend ist hier alles sehr einfach.  Nehmen Sie das Community-Image vom Knoten und legen Sie den Code darin ab.  Jetzt k√∂nnen Sie eine einfache Montage durchf√ºhren: <br><br><pre> <code class="bash hljs">docker build . -t localserver</code> </pre> <br>  Der n√§chste Schritt besteht darin, eine Bereitstellung in Kubernetes zu erstellen: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: webhook-server spec: replicas: 1 selector: matchLabels: component: webhook-server template: metadata: labels: component: webhook-server spec: containers: - name: webhook-server imagePullPolicy: Never image: localserver</code> </pre> <br>  <i>( <a href="">deploy.yaml</a> )</i> <br><br>  Beachten Sie, wie wir auf das gerade erstellte Bild angespielt haben?  Es k√∂nnte genauso gut ein Pod sein und etwas anderes, mit dem wir einen Dienst in Kubernetes verbinden k√∂nnen.  Definieren Sie nun diesen Service: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: webhook-service spec: ports: - port: 443 targetPort: 8443 selector: component: webhook-server</code> </pre> <br>  In Kubernetes wird also ein Endpunkt mit einem internen Namen angezeigt, der auf unseren Container verweist.  Der letzte Schritt besteht darin, Kubernetes mitzuteilen, dass der API-Server diesen Dienst aufrufen soll, wenn er bereit ist, <i>Mutationen</i> vorzunehmen: <br><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: name: webhook webhooks: - name: webhook-service.default.svc failurePolicy: Fail clientConfig: service: name: webhook-service namespace: default path: "/mutate" #    base64-  rootCA.crt #    `cat rootCA.crt | base64 | tr -d '\n'` #    .  caBundle: "==" rules: - operations: [ "CREATE" ] apiGroups: [""] apiVersions: ["v1"] resources: ["pods"]</code> </pre>  <i>( <a href="">hook.yaml</a> )</i> <br><br>  Der Name und der Pfad hier k√∂nnen beliebig sein, aber ich habe versucht, sie so aussagekr√§ftig wie m√∂glich zu gestalten.  Wenn Sie den Pfad √§ndern, m√ºssen Sie den entsprechenden Code in JavaScript √§ndern.  Webhook- <code>failurePolicy</code> ist ebenfalls <code>failurePolicy</code> - sie bestimmt, ob das Objekt gespeichert werden soll, wenn der Hook einen Fehler zur√ºckgibt oder fehlschl√§gt.  In diesem Fall weisen wir Kubernetes an, die Verarbeitung nicht fortzusetzen.  Schlie√ülich die Regeln: Sie √§ndern sich je nachdem, welche API-Aufrufe Sie von Kubernetes erwarten.  In diesem Fall m√ºssen wir, da wir versuchen, das Einf√ºgen eines Beiwagencontainers zu emulieren, Anforderungen abfangen, um einen Pod zu erstellen. <br><br>  Das ist alles!  So einfach ... aber was ist mit Sicherheit?  RBAC ist ein Aspekt, der im Artikel nicht behandelt wird.  Ich gehe davon aus, dass Sie das Beispiel in Minikube oder in Kubernetes ausf√ºhren, das mit Docker f√ºr Windows / Mac geliefert wird.  Ich werde Ihnen jedoch ein weiteres notwendiges Element erl√§utern.  Der Kubernetes-API-Server greift nur mit HTTPS auf Endpunkte zu, sodass f√ºr die Anwendung SSL-Zertifikate erforderlich sind.  Sie m√ºssen Kubernetes auch mitteilen, wer die Zertifizierungsstelle des Stammzertifikats ist. <br><br><h2>  TLS </h2><br>  <b>Nur zu Demonstrationszwecken (!!!) habe</b> ich der <code>Dockerfile</code> Code <code>Dockerfile</code> , um eine <code>Dockerfile</code> zu erstellen und damit das Zertifikat zu signieren: <br><br><pre> <code class="plaintext hljs">RUN openssl genrsa -out rootCA.key 4096 RUN openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=*.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl genrsa -out webhook.key 4096 RUN openssl req -new -key webhook.key -out webhook.csr \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=webhook-service.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl x509 -req -in webhook.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out webhook.crt -days 1024 -sha256 RUN cat rootCA.crt | base64 | tr -d '\n'</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockerfile</a> )</i> <br><br>  Bitte beachten Sie: Der letzte Schritt besteht darin, eine einzelne Zeile mit der in base64 codierten Stammzertifizierungsstelle anzuzeigen.  Dies ist genau das, was f√ºr die Hook-Konfiguration erforderlich ist. Kopieren Sie diese Zeile in Ihren weiteren Tests <code>caBundle</code> in das Feld <code>caBundle</code> Datei <code>caBundle</code> .  <code>Dockerfile</code> wirft Zertifikate direkt in <code>WORKDIR</code> , sodass JavaScript sie nur von dort nimmt und f√ºr den Server verwendet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privateKey = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.key'</span></span>).toString(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> certificate = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.crt'</span></span>).toString(); <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ const options = {key: privateKey, cert: certificate}; const server = https.createServer(options, app);</span></span></code> </pre> <br>  Jetzt unterst√ºtzt der Code den HTTPS-Start und teilt Kubernetes mit, wo wir zu finden sind und welchem ‚Äã‚ÄãVertrauenszentrum wir vertrauen sollen.  Es bleibt nur noch alles in einen Cluster einzubetten: <br><br><pre> <code class="bash hljs">kubectl create -f deployment.yaml kubectl create -f service.yaml kubectl create -f hook.yaml</code> </pre> <br><h3>  Fassen Sie zusammen </h3><br><ul><li>  <code>Deployment.yaml</code> startet einen Container, der die Hook-API √ºber HTTPS bereitstellt, und gibt einen JSON-Patch zur√ºck, um das Objekt zu √§ndern. </li><li>  <code>Service.yaml</code> stellt einen Endpunkt f√ºr den Container <code>webhook-service.default.svc</code> - <code>webhook-service.default.svc</code> . </li><li>  <code>Hook.yaml</code> teilt dem API-Server mit, wo er uns finden soll: <code>https://webhook-service.default.svc/mutate</code> . </li></ul><br><h2>  Versuchen wir es im Gesch√§ft! </h2><br>  Alles wird in einem Cluster bereitgestellt - es ist Zeit, den Code in Aktion zu testen. Dazu f√ºgen wir einen neuen Pod / eine neue Bereitstellung hinzu.  Wenn alles richtig funktioniert, muss der Hook ein zus√§tzliches Label <code>foo</code> hinzuf√ºgen: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: test spec: replicas: 1 selector: matchLabels: component: test template: metadata: labels: component: test spec: containers: - name: test image: node:8 command: [ "/bin/sh", "-c", "--" ] args: [ "while true; do sleep 30; done;" ]</code> </pre> <br>  <i>( <a href="">test.yaml</a> )</i> <br><br><pre> <code class="bash hljs">kubectl create -f test.yaml</code> </pre> <br>  Ok, wir haben gesehen, wie der <code>deployment.apps test created</code> ... aber hat es geklappt? <br><br><pre> <code class="bash hljs">kubectl describe pods <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-6f79f9f8bd-r7tbd Namespace: default Node: docker-for-desktop/192.168.65.3 Start Time: Sat, 10 Nov 2018 16:08:47 -0500 Labels: component=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> foo=bar</code> </pre> <br>  Gro√üartig!  Obwohl <code>test.yaml</code> ein einzelnes Label ( <code>component</code> ) gegeben wurde, erhielt der resultierende Pod zwei: <code>component</code> und <code>foo</code> . <br><br><h2>  Hausaufgaben </h2><br>  Aber warte!  Verwenden wir diesen Code, um einen Beiwagencontainer zu erstellen?  Ich habe gewarnt, dass ich zeigen werde, <b>wie man</b> einen Beiwagen hinzuf√ºgt ... Und jetzt, mit dem Wissen und dem Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/dowjones/k8s-webhook</a> - experimentieren Sie und finden Sie heraus, wie Sie Ihren automatisch eingef√ºgten Beiwagen herstellen k√∂nnen.  Es ist ganz einfach: Sie m√ºssen nur den richtigen JSON-Patch vorbereiten, der der Testbereitstellung einen zus√§tzlichen Container hinzuf√ºgt.  Viel Spa√ü beim Orchestrieren! <br><br><h2>  PS vom √úbersetzer </h2><br>  Lesen Sie auch in unserem Blog: <br><br><ul><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein Pod in Kubernetes?</a>  "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie hohe Verf√ºgbarkeit bei Kubernetes bereitgestellt wird</a> "; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wie funktioniert der Kubernetes-Scheduler tats√§chlich?"</a>  "; </li><li>  "Was passiert in Kubernetes, wenn der Kubectl-Lauf startet?"  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RBAC bei Kubernetes verstehen</a> "; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Unsere Erfahrung mit Kubernetes in kleinen Projekten</a> ‚Äú <i>(Videobericht, der eine Einf√ºhrung in das technische Ger√§t von Kubernetes enth√§lt)</i> ; </li><li>  ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist ein Service-Mesh und warum brauche ich es?</a>  ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431252/">https://habr.com/ru/post/de431252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431242/index.html">TLS- und Webzertifikate</a></li>
<li><a href="../de431244/index.html">"Zwei ungefiltert" oder eine einfache M√∂glichkeit, ein Bein zu schie√üen</a></li>
<li><a href="../de431246/index.html">@ OpenStack Meetup bei Mail.Ru Group: 30. November</a></li>
<li><a href="../de431248/index.html">Wer ist agil verantwortlich f√ºr die Qualit√§t der Entwicklung komplexer Projekte oder die Quality Gates-Methodik?</a></li>
<li><a href="../de431250/index.html">Anh√§nger der statischen und dynamischen Typisierung werden sich nie verstehen. Und TypeScript wird ihnen nicht helfen</a></li>
<li><a href="../de431254/index.html">Wie man an einem entfernten Ort gut lebt</a></li>
<li><a href="../de431256/index.html">Gro√übritannien und Holland verh√§ngten gegen Uber eine Geldstrafe von 1,2 Millionen US-Dollar wegen Verlusts personenbezogener Daten</a></li>
<li><a href="../de431258/index.html">Dezember Webinare Kotlin 1.3</a></li>
<li><a href="../de431260/index.html">So funktioniert es: Die Arbeit eines Analystenteams am Beispiel der Entwicklung eines digitalen Dienstes</a></li>
<li><a href="../de431262/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 19: ‚ÄûAnonyme Netzwerke‚Äú, Teil 1 (Vorlesung des Erstellers des Tor-Netzwerks)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>