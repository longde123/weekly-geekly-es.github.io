<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📧 👨🏽‍🍳 🎑 Performa Kotlin di Android 🧚🏼 🏻 🚣🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari kita bicara hari ini tentang kinerja Kotlin di Android dalam produksi. Mari kita lihat di bawah kap, terapkan optimasi rumit, bandingkan kode byt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Performa Kotlin di Android</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/420143/">  Mari kita bicara hari ini tentang kinerja Kotlin di Android dalam produksi.  Mari kita lihat di bawah kap, terapkan optimasi rumit, bandingkan kode byte.  Akhirnya, kami akan secara serius mendekati perbandingan dan mengukur tolok ukur. <br><br>  Artikel ini didasarkan pada laporan oleh <strong>Alexander Smirnov</strong> di AppsConf 2017 dan akan membantu mencari tahu apakah mungkin untuk menulis kode di Kotlin, yang tidak akan kalah dengan kecepatan Java. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/AqeKHDKJ4To" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>Tentang pembicara:</strong> Alexander Smirnov CTO di PapaJobs, menjalankan blog video <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Android di Faces</a> , dan juga salah satu penyelenggara komunitas Mosdroid. <br><a name="habracut"></a><br>  Mari kita mulai dengan harapan Anda. <br><br><blockquote>  Apakah menurut Anda Kotlin di runtime lebih lambat dari Java?  Atau lebih cepat?  Atau mungkin tidak banyak perbedaan?  Bagaimanapun, keduanya bekerja pada bytecode yang disediakan oleh mesin virtual kepada kita. </blockquote><br>  Mari kita perbaiki.  Secara tradisional, ketika pertanyaan tentang membandingkan kinerja muncul, semua orang ingin melihat tolok ukur dan angka tertentu.  Sayangnya, untuk Android tidak ada JMH ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Java Microbenchmark Harness</a> ), jadi kami tidak bisa mengukur seberapa keren itu bisa dilakukan di Jawa.  Jadi apa yang bisa kita lakukan untuk melakukan pengukuran, seperti dijelaskan di bawah ini? <br><br><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">measure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> startTime = System.nanoTime() work() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> System.nanoTime() - startTime } adb shell dumpsys gfxinfo %package_name%</code> </pre> <br>  Jika Anda pernah mencoba mengukur kode Anda dengan cara ini, maka salah satu pengembang JMH akan sedih, menangis dan mendatangi Anda dalam mimpi - tidak pernah melakukan itu. <br><br>  Di Android, Anda dapat membuat tolok ukur, khususnya, Google mendemonstrasikan ini di I / O tahun lalu.  Mereka mengatakan bahwa mereka sangat meningkatkan mesin virtual, dalam hal ini ART, dan jika pada Android 4.1 satu alokasi objek membutuhkan sekitar 600-700 nanodetik, maka pada versi kedelapan akan membutuhkan sekitar 60 nanodetik.  Yaitu  mereka dapat mengukurnya dengan akurasi seperti itu di mesin virtual.  Mengapa kami tidak dapat melakukan keduanya - kami tidak memiliki alat seperti itu. <br><br>  Jika kita melihat semua dokumentasi, maka satu-satunya yang dapat kita temukan adalah rekomendasi di atas, bagaimana mengukur UI: <br><br>  <strong>adb shell dumpsys gfxinfo% package_name%</strong> <br><br>  Sebenarnya, mari kita lakukan dengan cara ini dan lihat pada akhirnya apa yang akan diberikannya.  Tetapi pertama-tama, kita akan menentukan apa yang akan kita ukur dan apa lagi yang bisa kita lakukan. <br><br><blockquote>  Pertanyaan selanjutnya.  Menurut Anda di mana kinerja itu penting ketika Anda membuat aplikasi kelas satu? <br><br><ol><li>  Di mana-mana. </li><li>  Utas UI. </li><li>  Tampilan kustom + animasi. </li></ol><br></blockquote><br><img src="https://habrastorage.org/webt/h3/hi/0n/h3hi0n8douh0daoayii6yono2lo.jpeg"><br><br>  Saya paling suka opsi pertama, tetapi kemungkinan besar diyakini bahwa tidak mungkin untuk membuat semua kode bekerja sangat, sangat cepat dan penting bahwa setidaknya tidak ada tampilan UiThread atau kustom.  Saya juga setuju dengan ini - ini sangat, sangat penting.  Fakta bahwa dalam aliran JSON Anda yang terpisah akan deserialized selama 10 milidetik lebih lama tidak akan ada yang memperhatikan. <br><br>  Psikologi Gestalt mengatakan bahwa ketika kita berkedip, selama sekitar 150-300 milidetik, mata manusia tidak fokus dan tidak melihat apa yang sebenarnya terjadi di sana.  Dan 10 milidetik cuaca ini tidak.  Tetapi jika kita kembali ke psikologi gestalt, penting bukan apa yang benar-benar saya lihat dan apa yang sebenarnya terjadi, tetapi apa yang saya pahami sebagai pengguna itu penting. <br><br>  Yaitu  jika kita membuat pengguna berpikir bahwa dia memiliki segalanya dengan sangat, sangat cepat, tetapi sebenarnya itu hanya akan dipukuli dengan indah, misalnya, dengan bantuan animasi yang indah, maka dia akan puas, bahkan jika kenyataannya tidak. <br><br>  Motif psikologi Gestalt di iOS telah bergerak cukup lama.  Oleh karena itu, jika Anda mengambil dua aplikasi dengan waktu pemrosesan yang sama, tetapi pada platform yang berbeda, dan menempatkannya berdampingan, akan terlihat bahwa di iOS semuanya lebih cepat.  Animasi di iOS proses sedikit lebih cepat, animasi sebelumnya dimulai saat startup dan banyak animasi lainnya, sehingga indah. <br><br>  Jadi <strong>aturan pertama adalah memikirkan pengguna.</strong> <br><br>  Dan untuk aturan kedua, Anda harus membenamkan diri dalam hardcore. <br><br><h2>  GAYA KOTLIN <br></h2><br>  Untuk secara jujur ​​mengevaluasi kinerja Kotlin, kami akan membandingkannya dengan Jawa.  Karena itu, ternyata tidak mungkin mengukur beberapa hal yang hanya ada di Kotlin, misalnya: <br><br><ul><li>  Koleksi Api. </li><li>  Metode parameter default. </li><li>  Kelas data. </li><li>  Jenis yang telah diverifikasi. </li><li>  Coroutine. </li></ul><br>  <strong>API koleksi</strong> yang disediakan oleh Kotlin sangat keren, sangat cepat.  Di Jawa, ini sama sekali tidak ada, hanya ada implementasi yang berbeda.  Misalnya, pustaka Liteweight Stream API akan lebih lambat karena melakukan segalanya sama seperti Kotlin, tetapi dengan satu atau dua alokasi tambahan untuk operasi, karena semuanya berubah menjadi objek tambahan. <br><br>  Jika kita mengambil Stream API dari Java 8, itu akan bekerja lebih lambat daripada Kotlin Collection API, tetapi dengan satu syarat - tidak ada kelumpuhan seperti itu di API Pengumpulan, jika kita memasukkan paralel, pada volume besar data Stream API, Java akan mem-bypass Kotlin Collection API.  Karena itu, kami tidak dapat membandingkan hal-hal seperti itu, karena kami melakukan perbandingan dengan tepat dari sudut pandang Android. <br><br>  Hal kedua, yang menurut saya, tidak dapat dibandingkan, adalah <strong>parameter standar Metode</strong> - fitur yang sangat keren, yang, omong-omong, ada di Dart.  Ketika Anda memanggil beberapa metode, itu mungkin memiliki beberapa parameter yang mungkin mengambil beberapa nilai, tetapi mungkin NULL.  Dan karena itu, Anda tidak membuat 10 metode yang berbeda, tetapi lakukan satu metode dan katakan bahwa salah satu parameter bisa NULL, dan di masa depan menggunakannya tanpa parameter apa pun.  Yaitu  dia akan melihat, parameternya telah datang, atau dia belum datang.  Sangat nyaman karena Anda dapat menulis kode yang jauh lebih sedikit, tetapi ketidaknyamanannya adalah Anda harus membayarnya.  Ini adalah gula sintaksis: Anda, sebagai pengembang, berpikir bahwa ini adalah satu metode API, tetapi pada kenyataannya, di bawah tenda, setiap variasi metode dengan parameter yang hilang dihasilkan dalam bytecode.  Dan masing-masing metode ini juga memeriksa sedikit demi sedikit apakah parameter ini telah tiba.  Jika itu datang, maka ok, jika tidak, maka kami membuat topeng bit, dan tergantung pada topeng bit ini, metode asli yang Anda tulis sebenarnya disebut.  Operasi bitwise, semua <em>jika /</em> selain biaya sedikit uang, tetapi sangat sedikit, dan itu normal bahwa Anda harus membayar untuk kenyamanan.  Menurut saya ini benar-benar normal. <br><br>  Item berikutnya yang tidak dapat dibandingkan adalah <strong>kelas data</strong> . <br><br>  Semua orang menangis bahwa di Jawa ada parameter yang ada kelas model.  Yaitu  Anda mengambil parameter dan melakukan lebih banyak metode, getter, dan setter untuk semua parameter ini.  Ternyata untuk kelas dengan sepuluh parameter, Anda masih membutuhkan setumpuk getter, setter, dan banyak lagi.  Apalagi, jika Anda tidak menggunakan generator, maka Anda harus menulis dengan tangan Anda, yang pada umumnya mengerikan. <br><br>  Kotlin memungkinkan Anda menjauh dari itu semua.  Pertama, karena ada properti di Kotlin, Anda tidak perlu menulis getter dan setter.  Tidak memiliki <strong>parameter kelas, semua properti</strong> .  Bagaimanapun, kami pikir begitu.  Kedua, jika Anda menulis bahwa ini adalah kelas Data, banyak hal lain yang akan dihasilkan.  Misalnya, equals (), toStrung () / hasCode (), dll. <br><br>  Tentu saja, ini juga memiliki kekurangan.  Misalnya, saya tidak perlu semua 20 parameter kelas data saya untuk dibandingkan sekaligus dalam equals saya (), saya hanya perlu membandingkan 3. Seseorang tidak menyukai semua ini karena kinerja hilang pada ini, dan di samping itu, banyak yang dihasilkan fungsi layanan, dan kode yang dikompilasi cukup banyak.  Artinya, jika Anda menulis semuanya dengan tangan, akan ada lebih sedikit kode daripada jika Anda menggunakan kelas data. <br><br>  Saya tidak menggunakan kelas data untuk alasan lain.  Sebelumnya, ada batasan pada perluasan kelas-kelas seperti itu dan sesuatu yang lain.  Sekarang semua orang lebih baik dengan ini, tetapi kebiasaan itu tetap ada. <br><br>  Apa yang sangat, sangat keren di Kotlin, dan apa yang selalu lebih cepat daripada Java?  Ini adalah <strong>tipe Reified</strong> , yang, omong-omong, juga ada di Dart. <br><br>  Anda tahu bahwa ketika Anda menggunakan generik, tipe penghapusan dihapus pada tahap kompilasi dan di runtime Anda tidak lagi tahu objek apa yang sebenarnya digunakan generik ini. <br><br>  Dengan jenis Reified, Anda tidak perlu menggunakan refleksi di banyak tempat ketika Anda membutuhkannya di Jawa, karena dengan metode sebaris itu adalah dengan Reified yang Anda tahu tentang jenisnya, dan karenanya Anda tidak menggunakan refleksi dan kode Anda bekerja lebih cepat.  Keajaiban. <br><br>  Dan ada <strong>Coroutine</strong> .  Mereka sangat keren, saya sangat menyukainya, tetapi pada saat pertunjukan mereka hanya dimasukkan dalam versi alpha, jadi tidak mungkin untuk membuat perbandingan yang benar dengan mereka. <br><br><h2>  BIDANG <br></h2><br>  Jadi mari kita lanjutkan, beralih ke apa yang bisa kita bandingkan dengan Jawa dan apa yang bisa kita pengaruhi secara umum. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = B() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> d = a + b <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> e = ca + cb } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>(<span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span>)</code> </pre><br>  Seperti yang saya katakan, kita tidak memiliki parameter untuk kelas, kita memiliki properti. <br><br>  Kami memiliki var, kami memiliki val, kami memiliki kelas eksternal, salah satu sifatnya adalah @JvmField, dan kami akan melihat apa yang sebenarnya terjadi dengan fungsi work (): kami menjumlahkan nilai bidang a dan bidang b dari kelas kami sendiri dan nilai-nilai bidang a dan bidang b dari kelas luar, yang ditulis dalam bidang yang tidak dapat diubah c. <br><br>  Pertanyaannya adalah apa, pada kenyataannya, akan dipanggil dalam d = a + b.  Kita semua tahu bahwa properti ini satu kali, pengambil kelas ini akan dipanggil untuk parameter ini. <br><br><pre> <code class="hljs cmake"> L0 LINENUMBER <span class="hljs-number"><span class="hljs-number">10</span></span> L0 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.a : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/<span class="hljs-keyword"><span class="hljs-keyword">Test</span></span>.b : I IADD ISTORE <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  Tetapi jika kita melihat bytecode, kita akan melihat bahwa getfield sebenarnya sedang diakses.  Artinya, ini dalam bytecode bukan panggilan ke fungsi InvokeVirtual, tetapi akses langsung ke lapangan.  Pada awalnya tidak ada yang dijanjikan kepada kami, bahwa kami memiliki semua properti, bukan ladang.  Ternyata Kotlin menipu kita, ada permohonan langsung. <br><br>  Apa yang terjadi jika kita melihat bytecode apa yang dihasilkan untuk baris lain: val e = ca + cb? <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L1</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">11</span></span> L1 ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">GETFIELD</span></span> kotlin/Ba : I ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> GETFIELD kotlin/Test.c : Lkotlin/B; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/B.getB ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  Sebelumnya, jika Anda mengakses properti pribadi, maka Anda selalu memiliki panggilan InvokeVirtual.  Jika ini adalah properti pribadi, maka akses ke sana adalah melalui GetField.  GetField jauh lebih cepat daripada InvokeVirtual, spesifikasi dari Android mengklaim bahwa mengakses bidang secara langsung adalah 3-7 kali lebih cepat.  Karena itu, disarankan agar Anda selalu merujuk ke Field, dan tidak melalui pengambil atau setter.  Sekarang, terutama di mesin virtual ART kedelapan, sudah ada angka yang berbeda, tetapi jika Anda masih mendukung 4.1, ini akan benar. <br><br>  Oleh karena itu, ternyata masih bermanfaat bagi kita untuk memiliki GetField, dan bukan InvokeVirtual. <br><br>  Sekarang, Anda dapat mencapai GetField jika Anda mengakses properti dari kelas Anda sendiri, atau jika ini adalah properti publik, Anda harus mengatur @JvmField.  Kemudian, persis sama dalam bytecode akan menjadi panggilan GetField, yang 3-7 kali lebih cepat. <br><br>  Jelas bahwa di sini kita berbicara dalam nanodetik dan, dengan satu takhta, itu sangat, sangat kecil.  Tetapi, di sisi lain, jika Anda melakukannya di utas UI, misalnya, dalam metode ondraw Anda mengakses beberapa jenis tampilan, maka ini akan mempengaruhi rendering setiap frame, dan Anda dapat melakukannya sedikit lebih cepat. <br><br>  <strong>Jika kita menjumlahkan semua optimasi, maka jumlah itu dapat memberikan sesuatu.</strong> <br><br><h2>  STATIC!? <br></h2><br>  Bagaimana dengan statika?  Kita semua tahu bahwa di Kotlin statis adalah objek pendamping.  Sebelumnya, Anda mungkin menambahkan semacam tag, misalnya, public static, final static, dll., Jika Anda mengonversinya ke kode Kotlin, Anda akan mendapatkan objek pendamping, yang akan menulis sesuatu seperti berikut: <br><br><pre> <code class="hljs kotlin"> <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br><blockquote>  Apakah Anda pikir entri ini identik dengan deklarasi final statis standar di Jawa?  Apakah ini statis atau tidak? </blockquote><br>  Ya, memang, Kotlin menyatakan bahwa ini dia di Kotlin - statis, objek itu mengatakan bahwa itu statis.  Pada kenyataannya, ini tidak statis. <br><br>  Jika kita melihat bytecode yang dihasilkan, kita akan melihat yang berikut: <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.getK ()I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Test.Companion dihasilkan, objek tunggal yang membuat instance dibuat, instance ini ditulis ke bidangnya sendiri.  Setelah itu, akses ke salah satu objek pendamping terjadi melalui objek ini.  Dia mengambil getstatic, yaitu instance statis dari kelas ini, dan memanggil fungsi getK invokevirtual di atasnya, dan persis sama untuk fungsi work2.  Jadi kami mendapatkan bahwa itu tidak statis. <br><br>  Ini penting, karena pada JVM yang lebih lama, invokestatik sekitar 30% lebih cepat daripada invokevirtual.  Sekarang, tentu saja, di HotSpot, virtualisasi yang dioptimalkan akan sangat keren, dan itu hampir tidak terlihat.  Namun demikian, Anda harus mengingat ini, terutama karena ada satu alokasi tambahan, dan lokasi tambahan pada 4ST1 adalah 700 nanodetik, terlalu banyak. <br><br>  Mari kita lihat kode Java yang keluar jika Anda melakukan reverse-deploy bytecode: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Test.k;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> var1)</span></span></span><span class="hljs-function"> </span></span>{ Test.k = var1; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Bidang statis dibuat, implementasi final statis objek Pendamping, getter dan setter dibuat, dan, seperti yang Anda lihat, merujuk pada bidang statis di dalam, metode statis tambahan muncul.  Semuanya cukup menyedihkan. <br><br>  Apa yang bisa kita lakukan, memastikan itu tidak statis?  Kita dapat mencoba menambahkan @JvmField dan @JvmStatic dan melihat apa yang terjadi. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i = k + work2() <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-meta"><span class="hljs-meta">@JvmField</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span> JvmStatic <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> : <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">42</span></span> }</code> </pre><br>  Saya akan mengatakan segera bahwa Anda tidak akan pergi dari @JvmStatic, itu akan menjadi objek yang sama, karena ini adalah objek pendamping, akan ada alokasi tambahan dari objek ini dan akan ada panggilan tambahan. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Test.Companion Companion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test.Companion((DefaultConstructorMarker)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Companion</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@JvmStatic</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Companion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-comment"><span class="hljs-comment">// $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } }</span></span></code> </pre><br>  Tetapi panggilan akan berubah hanya untuk k, karena itu akan menjadi @JvmField, itu akan diambil secara langsung sebagai getstatic, getter dan setter tidak akan lagi dihasilkan.  Tetapi untuk fungsi work2 tidak ada yang akan berubah. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">L2</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">21</span></span> L2 GETSTATIC kotlin/Test.k : I GETSTATIC kotlin/Test.Companion : Lkotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/Test<span class="hljs-variable"><span class="hljs-variable">$Companion</span></span>.work2 ()I IADD ISTORE <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Opsi kedua tentang cara membuat statis diusulkan dalam dokumentasi Kotlin, sehingga dikatakan bahwa kita bisa membuat objek, dan ini akan menjadi kode statis. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> A { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">53</span></span> }</code> </pre><br>  Pada kenyataannya, ini juga tidak demikian. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">L3</span></span> LINENUMBER <span class="hljs-number"><span class="hljs-number">23</span></span> L3 GETSTATIC kotlin/A.INSTANCE : Lkotlin/A; <span class="hljs-attribute"><span class="hljs-attribute">INVOKEVIRTUAL</span></span> kotlin/A.test ()I POP</code> </pre><br>  Ternyata kami membuat panggilan instan getstatic dari singletone, yang dibuat, dan memanggil metode virtual yang sama persis. <br><br>  Satu-satunya cara kita dapat mencapai invokestatik adalah Fungsi Orde Tinggi.  Ketika kita hanya menulis beberapa fungsi di luar kelas, misalnya, test2 akan benar-benar disebut statis. <br><br><pre> <code class="hljs kotlin"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = <span class="hljs-number"><span class="hljs-number">99</span></span> L4 LINENUMBER <span class="hljs-number"><span class="hljs-number">24</span></span> L4 INVOKESTATIC kotlin/TestKt.test2 ()I POP</code> </pre><br>  Selain itu, hal yang paling menarik adalah bahwa sebuah kelas akan dibuat, sebuah objek, dalam hal ini testKt, itu akan menghasilkan objek untuk dirinya sendiri, itu akan menghasilkan fungsi yang dimasukkan ke objek ini, dan sekarang akan disebut sebagai invokestatic. <br><br>  Mengapa ini dilakukan tidak bisa dipahami.  Banyak yang tidak senang dengan ini, tetapi ada yang menganggap implementasi seperti itu cukup normal.  Karena mesin virtual, termasuk.  Seni meningkat, sekarang tidak begitu kritis.  Di Android versi kedelapan, seperti halnya pada HotSpot, semuanya dioptimalkan, tetapi hal-hal kecil ini sedikit mempengaruhi kinerja secara keseluruhan. <br><br><h2>  KEWAJIBAN <br></h2><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> : String { second ?: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>  Ini adalah contoh menarik berikutnya.  Tampaknya kami mencatat bahwa yang kedua dapat dibatalkan, dan harus diperiksa sebelum melakukan sesuatu dengannya.  Dalam hal ini, saya berharap bahwa kita punya satu jika.  Ketika kode ini digunakan jika yang kedua tidak sama dengan nol, maka saya pikir eksekusi akan berjalan lebih jauh dan hanya output pertama. <br><br>  Bagaimana ini benar-benar terungkap dalam kode java?  Sebenarnya akan ada cek. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first,@Nullable String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> second != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? (first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second) : first; }</code> </pre><br>  Kami akan mendapatkan Intrinsics pada awalnya.  Katakanlah saya mengatakan yang ini <br><br>  Jika akan berkembang menjadi operator ternary.  Tapi selain itu, meskipun kami bahkan menetapkan bahwa parameter pertama tidak dapat nullable, masih akan diperiksa melalui Intrinsics. <br><br>  Intrinsics adalah kelas internal di Kotlin yang memiliki serangkaian parameter dan pemeriksaan tertentu.  Dan setiap kali Anda membuat parameter metode non-nullable, itu tetap memeriksanya.  Mengapa  Kemudian, kami bekerja di Interop Java, dan mungkin Anda berharap tidak akan dibatalkan di sini, tetapi dengan Java, itu akan datang dari suatu tempat. <br><br>  Jika Anda memeriksa ini, ia akan pergi lebih jauh di sepanjang kode, dan kemudian setelah 10-20 panggilan metode, Anda akan melakukan sesuatu dengan parameter itu, meskipun mungkin tidak dapat dibatalkan, tetapi karena beberapa alasan itu ternyata.  Segalanya akan jatuh cinta pada Anda, dan Anda tidak akan dapat memahami apa yang sebenarnya terjadi.  Untuk menghindari situasi ini, setiap kali Anda melewati parameter nol, Anda masih harus memeriksanya.  Dan jika itu nullable, maka akan ada pengecualian. <br><br>  Cek ini juga bernilai sesuatu, dan jika ada banyak, maka itu tidak akan bagus. <br><br>  Tetapi pada kenyataannya, jika kita berbicara tentang HotSpot, maka 10 panggilan dari Intrinsik ini akan memakan waktu sekitar empat nanodetik.  Ini sangat, sangat kecil, dan Anda tidak perlu khawatir tentang ini, tetapi ini merupakan faktor yang menarik. <br><br><h2>  PRIMITIF <br></h2><br>  Di Jawa ada yang namanya primitif.  Di Kotlin, seperti yang kita semua tahu, tidak ada primitif, kami selalu beroperasi dengan benda.  Di Jawa, mereka digunakan untuk memberikan kinerja yang lebih tinggi untuk objek pada beberapa perhitungan minor.  Untuk menambahkan dua objek jauh lebih mahal daripada menambahkan dua primitif.  Pertimbangkan sebuah contoh. <br><br><pre> <code class="hljs swift"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bOption : <span class="hljs-type"><span class="hljs-type">Int?</span></span> = <span class="hljs-number"><span class="hljs-number">6</span></span></code> </pre><br>  Ada tiga angka, untuk dua yang pertama bukan tipe nol akan disimpulkan, dan sekitar yang ketiga kita katakan bahwa itu bisa nullable. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Nullable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Integer bOption = Integer.valueOf(<span class="hljs-number"><span class="hljs-number">6</span></span>);</code> </pre><br>  Jika Anda melihat bytecode dan melihat kode Java mana yang dihasilkan, dua angka pertama bukan nol, dan karena itu mereka bisa primitif.  Tetapi primitif tidak dapat berisi Null, hanya objek yang dapat melakukan ini, sehingga objek akan dihasilkan untuk angka ketiga. <br><br><h2>  AUTOBOXING <br></h2><br>  Saat Anda bekerja dengan primitif dan melakukan operasi dengan primitif dan non-primitif, Anda harus menerjemahkan salah satunya menjadi primitif atau objek. <br><br>  Dan, tampaknya, tidak mengherankan bahwa jika Anda melakukan operasi dengan nullable dan tidak nullable di Kotlin, maka Anda kehilangan sedikit dalam kinerja.  Apalagi, jika ada banyak operasi seperti itu, maka Anda kehilangan banyak. <br><br><pre> <code class="hljs scala"> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a: <span class="hljs-type"><span class="hljs-type">String</span></span>? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = a?.isBlank() == <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Lihat di mana Boxing / Unboxing akan berada di sini?  Saya juga tidak melihat sampai saya melihat bytecode. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; a.isBlank()) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre><br>  Sebenarnya, saya berharap bahwa akan ada sesuatu seperti perbandingan ini: jika string tidak nol dan jika kosong, maka setel ke true, jika tidak maka setel ke false.  Semuanya tampak sederhana, tetapi dalam kenyataannya kode berikut ini dihasilkan: <br><br><pre> <code class="java hljs">String a = (String)<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> b = Intrinsics.areEqual(a != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ? Boolean.valueOf(StringsKt.isBlank((CharSequence)a)) : <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, Boolean.valueOf(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre><br>  Ayo lihat ke dalam.  Variabel <em>a</em> diambil, ia dilemparkan ke dalam CharSequence, setelah dilemparkan, yang juga telah dihabiskan untuk beberapa waktu, pemeriksaan lain disebut - StringsKt.isBlank - ini adalah bagaimana fungsi ekstensi untuk CharSequence ditulis, jadi ia dilemparkan dan dikirim.  Karena ekspresi pertama dapat nullable, itu mengambil dan melakukan Boxing, dan membungkus semuanya dalam Boolean.valueOf.  Oleh karena itu, primitif sejati juga menjadi objek, dan hanya setelah itu verifikasi sudah berlangsung dan Intrinsics.areEqual dipanggil. <br><br>  Tampaknya operasi yang sederhana, tetapi hasil yang tidak terduga.  Bahkan, ada beberapa hal seperti itu.  Tetapi ketika Anda dapat memiliki nullable / not nullable, Anda dapat menghasilkan cukup banyak hal-hal seperti itu, dan yang Anda tidak akan pernah harapkan.  Karena itu, saya sarankan Anda menjauh dari ketidakjelasan sesegera mungkin.  Yaitu  <strong>datang ke kekebalan nilai sedini mungkin dan menjauh dari nullable</strong> sehingga Anda beroperasi tidak nol secepat mungkin. <br><br><h2>  Loop <br></h2><br>  Hal menarik berikutnya. <br><br>  Anda dapat menggunakan biasa untuk, yang di Jawa, tetapi Anda juga dapat menggunakan API nyaman baru - menulis enumerasi elemen dalam daftar segera. ,      work,  it  -   . <br><br><pre> <code class="hljs pgsql">list.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">work</span></span>(it * <span class="hljs-number"><span class="hljs-number">2</span></span>) }</code> </pre><br>         .  ,    .    ,     Google,  ,       ArrayList   for   3  ,   .        . <br><br>    ,    ArrayList,     —   foreach. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; size) { action(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(i)) i++ } } list.foreach { }</code> </pre><br>    API,     -  .     ,    Kotlin:   extension ,   «»,    reified, ..    ,    ,   ,    crossinline.      ,  ,    .  3  ,      Android  Google. <br><br><h2> RANGES <br></h2><br>        Ranges. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-type"><span class="hljs-keyword">reified</span></span></span></span><span class="hljs-function"><span class="hljs-type"> T&gt;</span></span></span><span class="hljs-function"> List</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foreach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">crossinline</span></span></span></span><span class="hljs-function"><span class="hljs-params"> action: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> size = size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..size) { work(i * <span class="hljs-number"><span class="hljs-number">2</span></span>) } }</code> </pre><br>     : Unit     -.        −1,  until ,   ,    .   ,    ,    ranges.  Yaitu   ,     .           step.    . <br><br><h2> INTRINSICS <br></h2><br> -  Intrinsics,      : <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">, second: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$first</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$second</span></span></span><span class="hljs-string">"</span></span> }</code> </pre><br>    Intrinsics    —   second,   first. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">concat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NotNull String first, @NotNull String second)</span></span></span><span class="hljs-function"> </span></span>{ Intrinsics.checkParameterIsNotNull(first, <span class="hljs-string"><span class="hljs-string">"first"</span></span>); Intrinsics.checkParameterIsNotNull(second, <span class="hljs-string"><span class="hljs-string">"second"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first + <span class="hljs-string"><span class="hljs-string">" "</span></span> + second; } }</code> </pre><br>   ,      gradle.   ,    -     4 ,      .     Kotlin  UI,    ,       nullable,    Kotlin : <br><br> <strong>kotlinc -Xno-call-assertions -Xno-param-assertions Test.kt</strong> <br><br>   Intrinsics,    ,   . <br><br>   ,     ,      .   — Xno-param-assertions —    Intrinsics,     . <br><br>    ,     ,     ,    ,     ,    .    ,    ,     ,    . <br><br><h2> REDEX <br></h2><br>  ,    ,    ,   Proguard.    ,   99%  ,     ,   .  Android 8.0  ,    .   ,      . <br><br>  ,    Proguard,   Facebook,   <strong>Redex</strong> .      -,        ,        . ,  Jvm Fields     ,         . <br><br>  ,  Redex   .  ,    ,      ,    Proguard,   ,    .          Redex    7%   APK.  ,   . <br><br><h2> BENCHMARKS </h2><br>   .     ,       ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,        . ,   dumpsys gfxinfo     ,       .   github  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><strong>github.com/smred</strong></a>      . <br><br> ,     Huawei. <br><img src="https://habrastorage.org/webt/hm/nf/hb/hmnfhbvpmrfyg6aapr_z7u5pbws.jpeg"><br><br>       .  — ,     .     ,    ,    0,04 . ,  ,        —   ,         . <br><img src="https://habrastorage.org/webt/jo/kg/ov/jokgovmpmtwe_h6gsdrmohvzi5g.jpeg"><br><br>      Kotlin,      .  ,    ,     .  - ,     Kotlin  ,   Java.    , , ,     ,      .       . <br><img src="https://habrastorage.org/webt/je/h5/tm/jeh5tm5-oyprnnvzjaegqemeecs.jpeg"><br><br> , ,    ,      ,  Kotlin          Java. , -    , ,  ,    ,    ,        . <br><img src="https://habrastorage.org/webt/k8/6o/c6/k86oc6tr5tnegbzvtizkhddnyz4.jpeg"><br><br> ,   : -      Kotlin       , ..   .       ,     .    -             -  —   2  ,    Galaxy S6,     . <br><img src="https://habrastorage.org/webt/ix/ud/d2/ixudd25fkc3zje65vwseoo7xkzm.jpeg"><br><br>    Google Pixel.     ,    0,1 . <br><br><h1>  <br></h1><br>  ,   ,    ,  <br><br><ul><li>     UI   custom view. </li><li>    onmeasure-onlayout-ondraw.     autoboxing, not null   .. </li><li>       Kotlin,      Java ,        . </li><li>   — . </li></ul><br>  ,   ,       .  ,  ,    , , Kotlin,     .       ,  Kotlin             . <br><br>    ,      . <br><br><blockquote>        brand new <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">AppsConf</a> ,        Android   . ,      . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> ,   8  9       . </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id420143/">https://habr.com/ru/post/id420143/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id420131/index.html">Metode Penambangan Bitcoin Probabilistik</a></li>
<li><a href="../id420133/index.html">Pemodelan sistem dinamis: Bagaimana bulan bergerak?</a></li>
<li><a href="../id420135/index.html">Ini juga Toshiba: produk yang tidak terduga dari perusahaan Jepang</a></li>
<li><a href="../id420139/index.html">Buku “Rekayasa Keandalan Situs. Keandalan dan keandalan seperti di Google »</a></li>
<li><a href="../id420141/index.html">Dari MPMS DBMS yang dimuat - Danau Data peppy dengan alat analitis: bagikan detail pembuatannya</a></li>
<li><a href="../id420145/index.html">Bagaimana hari kerja para anggota PC AppsConf</a></li>
<li><a href="../id420147/index.html">OpenSource di Clojure</a></li>
<li><a href="../id420151/index.html">Lebih mudah daripada kedengarannya. Bab 12</a></li>
<li><a href="../id420153/index.html">Pencetakan 3D bagian kompleks yang terbuat dari ABS dan PLA dengan banyak dukungan</a></li>
<li><a href="../id420155/index.html">Intel Datacenter SSD. Volume besar dan nama baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>