<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◼️ 🙇🏼 👊🏿 Apa yang mengembang memori di Ruby? 👻 🔝 ↙️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami di Phusion memiliki proxy HTTP multi-utas sederhana di Ruby (mendistribusikan paket DEB dan RPM). Saya melihat di atasnya konsumsi memori 1,3 GB....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang mengembang memori di Ruby?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444482/">  Kami di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Phusion memiliki</a> proxy HTTP multi-utas sederhana di Ruby (mendistribusikan paket DEB dan RPM).  Saya melihat di atasnya konsumsi memori 1,3 GB.  Tapi ini gila untuk proses kewarganegaraan ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Pertanyaan: Apa itu?</font></i>  <i><font color="gray">Jawab: Penggunaan memori oleh proses Ruby dari waktu ke waktu!</font></i> <br><br>  Ternyata saya tidak sendirian dalam masalah ini.  Aplikasi Ruby dapat menggunakan banyak memori.  Tapi mengapa?  Menurut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Heroku</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nate Burkopek</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kembung</a> terutama disebabkan oleh fragmentasi memori dan distribusi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tumpukan yang</a> berlebihan. <br><a name="habracut"></a><br>  Berkopek menyimpulkan bahwa ada dua solusi: <br><br><ol><li>  Baik menggunakan pengalokasi memori yang sama sekali berbeda dari glibc - biasanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jemalloc</a> , atau: </li><li> Setel variabel lingkungan ajaib <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  Saya khawatir tentang deskripsi masalah dan solusi yang diajukan.  Ada sesuatu yang salah di sini ... Saya tidak yakin bahwa masalahnya dijelaskan dengan benar atau ini adalah satu-satunya solusi yang tersedia.  Ini juga mengganggu saya bahwa banyak orang menyebut jemalloc sebagai kolam perak ajaib. <br><br>  <b>Sihir hanyalah ilmu yang belum kita pahami</b> .  Jadi saya melakukan perjalanan penelitian untuk mengetahui seluruh kebenaran.  Artikel ini akan membahas topik-topik berikut: <br><br><ol><li>  Bagaimana alokasi memori bekerja. <br></li><li>  Apa ini "fragmentasi" dan "distribusi berlebihan" memori yang semua orang bicarakan? <br></li><li>  Apa yang menyebabkan konsumsi memori besar?  Apakah situasinya konsisten dengan apa yang orang katakan, atau ada sesuatu yang lain?  (spoiler: ya, ada sesuatu yang lain). <br></li><li>  Apakah ada solusi alternatif?  (spoiler: Saya menemukan satu). </li></ol><br>  <i>Catatan: artikel ini hanya relevan untuk Linux, dan hanya untuk aplikasi Ruby multi-threaded.</i> <br><br><h1>  Isi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alokasi Memori Ruby: Pendahuluan</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ruby</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalokasi memori sistem</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Intinya</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Definisi penggunaan memori</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu fragmentasi?</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fragmentasi Tingkat Ruby</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memori Alokasi Fragmentasi</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apakah Ruby menumpuk fragmentasi halaman yang menyebabkan memori membengkak?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Studi Fragmentasi Alokasi Memori</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alokasi memori yang berlebihan dan glibc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visualisasi tumpukan sistem</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Trik Sulap: Sunat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kesimpulan</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode Sumber Visualizer</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana dengan kinerja?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perlu lebih banyak tes.</a> </li></ul></li></ul><br><a name="1"></a><h1>  Alokasi Memori Ruby: Pendahuluan </h1><br>  Ruby mengalokasikan memori pada tiga level, dari atas ke bawah: <br><br><ol><li>  Penerjemah Ruby yang mengelola objek Ruby. <br></li><li>  Perpustakaan pengalokasi memori sistem operasi. <br></li><li>  Intinya. </li></ol><br>  Mari kita melewati setiap level. <br><br><a name="1_1"></a><h3>  Ruby </h3><br>  Di sisinya, Ruby mengatur objek di area memori yang disebut <i>halaman tumpukan Ruby</i> .  Halaman tumpukan seperti itu dibagi menjadi beberapa slot dengan ukuran yang sama, di mana satu objek menempati satu slot.  Apakah itu string, tabel hash, array, kelas, atau yang lainnya, ia menempati satu slot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Slot pada halaman tumpukan mungkin sibuk atau gratis.  Ketika Ruby memilih objek baru, ia segera mencoba menempati slot gratis.  Jika tidak ada slot gratis, halaman tumpukan baru akan disorot. <br><br>  Slotnya kecil, sekitar 40 byte.  Jelas, beberapa objek tidak akan cocok di dalamnya, misalnya, 1 MB baris.  Kemudian Ruby menyimpan informasi di tempat lain di luar halaman tumpukan, dan menempatkan penunjuk ke area memori eksternal ini di slot. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Data yang tidak sesuai dengan slot disimpan di luar halaman tumpukan.</font></i>  <i><font color="gray">Ruby menempatkan pointer ke data eksternal ini di slot</font></i> <br><br>  Baik halaman tumpukan Ruby dan area memori eksternal dialokasikan menggunakan pengalokasi memori sistem. <br><br><a name="1_2"></a><h3>  Pengalokasi memori sistem </h3><br>  Alokasi memori sistem operasi adalah bagian dari glibc (C runtime).  Ini digunakan oleh hampir semua aplikasi, bukan hanya Ruby.  Ini memiliki API sederhana: <br><br><ul><li>  Memori dialokasikan dengan memanggil <code>malloc(size)</code> .  Anda memberinya jumlah byte yang ingin Anda alokasikan, dan itu mengembalikan alamat alokasi atau kesalahan. </li><li>  Memori yang dialokasikan dibebaskan dengan memanggil <code>free(address)</code> . </li></ul><br>  Tidak seperti Ruby, di mana slot dengan ukuran yang sama dialokasikan, pengalokasi memori menangani permintaan untuk mengalokasikan memori dalam ukuran apa pun.  Seperti yang akan Anda pelajari nanti, fakta ini menyebabkan beberapa komplikasi. <br><br>  Pada gilirannya, pengalokasi memori mengakses API kernel.  Dibutuhkan potongan memori yang jauh lebih besar dari kernel daripada permintaan pelanggannya sendiri, karena panggilan kernel itu mahal dan API kernel memiliki batasan: itu hanya dapat mengalokasikan memori dalam kelipatan 4 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">Pengalokasi memori mengalokasikan potongan besar - mereka disebut tumpukan sistem - dan membagikan kontennya untuk memenuhi permintaan dari aplikasi</font></i> <br><br>  Area memori yang dialokasikan oleh pengalokasi memori dari kernel disebut heap.  Perhatikan bahwa itu tidak ada hubungannya dengan halaman tumpukan Ruby, jadi untuk kejelasan kita akan menggunakan istilah <i>tumpukan sistem</i> . <br><br>  Pengalokasi memori kemudian menetapkan bagian-bagian dari sistem yang menumpuk ke peneleponnya sampai ada ruang kosong.  Dalam hal ini, pengalokasi memori mengalokasikan tumpukan sistem baru dari kernel.  Ini mirip dengan bagaimana Ruby memilih objek dari halaman tumpukan Ruby. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby mengalokasikan memori dari pengalokasi memori, yang pada gilirannya mengalokasikan memori dari kernel</font></i> <br><br><a name="1_3"></a><h3>  Intinya </h3><br>  Kernel hanya dapat mengalokasikan memori dalam 4 unit KB.  Satu blok 4K seperti itu disebut halaman.  Untuk menghindari kebingungan dengan halaman tumpukan Ruby, untuk kejelasan kami akan menggunakan istilah <i>halaman sistem</i> (halaman OS). <br><br>  Alasannya sulit untuk dijelaskan, tetapi inilah cara semua kernel modern bekerja. <br><br>  Mengalokasikan memori melalui kernel memiliki dampak signifikan pada kinerja, itulah sebabnya mengapa pengalokasi memori mencoba untuk meminimalkan jumlah panggilan kernel. <br><br><a name="1_4"></a><h3>  Definisi penggunaan memori </h3><br>  Dengan demikian, memori dialokasikan pada beberapa level, dan setiap level mengalokasikan lebih banyak memori daripada yang sebenarnya dibutuhkan.  Halaman tumpukan Ruby dapat memiliki slot gratis, juga tumpukan sistem.  Karena itu, jawaban atas pertanyaan "Berapa banyak memori yang digunakan?"  benar-benar tergantung pada level apa yang Anda tanyakan! <br><br>  Alat seperti <code>top</code> atau <code>ps</code> menunjukkan penggunaan memori dari perspektif <b>kernel</b> .  Ini berarti bahwa level yang lebih tinggi harus bekerja bersamaan untuk membebaskan memori dari sudut pandang kernel.  Seperti yang akan Anda pelajari nanti, ini lebih sulit daripada kedengarannya. <br><br><a name="2"></a><h1>  Apa itu fragmentasi? </h1><br>  Fragmentasi memori berarti bahwa alokasi memori tersebar secara acak.  Ini dapat menyebabkan masalah yang menarik. <br><br><a name="2_1"></a><h3>  Fragmentasi Tingkat Ruby </h3><br>  Pertimbangkan pengumpulan sampah Ruby.  Pengumpulan sampah untuk suatu objek berarti menandai slot halaman tumpukan Ruby sebagai gratis, yang memungkinkannya untuk digunakan kembali.  Jika seluruh halaman tumpukan Ruby hanya berisi slot gratis, maka seluruh halamannya dapat dibebaskan kembali ke pengalokasi memori (dan, mungkin, kembali ke kernel). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  Tetapi apa yang terjadi jika tidak semua slot gratis?  Bagaimana jika kita memiliki banyak halaman tumpukan Ruby, dan pengumpul sampah membebaskan objek di tempat yang berbeda, sehingga pada akhirnya ada banyak slot gratis, tetapi di halaman yang berbeda?  Dalam situasi ini, Ruby memiliki slot gratis untuk menempatkan objek, tetapi pengalokasi memori dan kernel akan terus mengalokasikan memori! <br><br><a name="2_2"></a><h3>  Memori Alokasi Fragmentasi </h3><br>  Pengalokasi memori memiliki masalah yang sama tetapi sangat berbeda.  Dia tidak perlu segera menghapus seluruh tumpukan sistem.  Secara teoritis, ini dapat membebaskan halaman sistem tunggal.  Tetapi karena pengalokasi memori berurusan dengan alokasi memori dengan ukuran sewenang-wenang, mungkin ada beberapa alokasi pada halaman sistem.  Itu tidak dapat membebaskan halaman sistem sampai semua pilihan dibebaskan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  Pikirkan apa yang terjadi jika kita memiliki alokasi 3 KB, serta alokasi 2 KB, dibagi menjadi dua halaman sistem.  Jika Anda mengosongkan 3 KB pertama, kedua halaman sistem akan tetap terisi sebagian dan tidak dapat dibebaskan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Oleh karena itu, jika keadaan gagal, akan ada banyak ruang kosong di halaman sistem, tetapi mereka tidak akan dibebaskan sepenuhnya. <br><br>  Lebih buruk lagi: bagaimana jika ada banyak tempat gratis, tetapi tidak satu pun dari mereka yang cukup besar untuk memenuhi permintaan alokasi baru?  Pengalokasi memori harus mengalokasikan tumpukan sistem yang sama sekali baru. <br><br><a name="3"></a><h1>  Apakah Ruby menumpuk fragmentasi halaman yang menyebabkan memori membengkak? </h1><br>  Kemungkinan fragmentasi menyebabkan penggunaan memori berlebihan di Ruby.  Jika demikian, manakah dari dua fragmen yang lebih berbahaya?  Ini ... <br><br><ol><li>  Ruby menumpuk fragmentasi halaman?  Atau <br></li><li>  Fragmentasi pengalokasi memori? </li></ol><br>  Opsi pertama cukup mudah untuk diperiksa.  Ruby menyediakan dua API: <code>ObjectSpace.memsize_of_all</code> dan <code>GC.stat</code> .  Berkat informasi ini, Anda dapat menghitung semua memori yang diterima Ruby dari pengalokasi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> mengembalikan memori yang ditempati oleh semua objek Ruby yang aktif.  Artinya, semua ruang dalam slot mereka dan data eksternal apa pun.  Dalam diagram di atas, ini adalah ukuran semua benda biru dan oranye. <br><br>  <code>GC.stat</code> memungkinkan <code>GC.stat</code> untuk mengetahui ukuran semua slot gratis, mis. Seluruh area abu-abu dalam ilustrasi di atas.  Berikut algoritanya: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  Untuk meringkasnya, ini adalah semua memori yang diketahui Ruby, dan itu melibatkan fragmen halaman tumpukan Ruby.  Jika, dari sudut pandang kernel, penggunaan memori lebih tinggi, maka memori yang tersisa pergi ke suatu tempat di luar kendali Ruby, misalnya, ke perpustakaan atau fragmentasi pihak ketiga. <br><br>  Saya menulis sebuah program pengujian sederhana yang menciptakan banyak utas, yang masing-masing memilih garis dalam satu lingkaran.  Ini hasilnya setelah beberapa saat: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  itu ... hanya ... gila! <br><br>  Hasilnya menunjukkan bahwa Ruby memiliki efek yang lemah pada jumlah total memori yang digunakan, tidak masalah jika halaman tumpukan Ruby terfragmentasi atau tidak. <br><br>  Harus mencari pelakunya di tempat lain.  Setidaknya sekarang kita tahu bahwa Ruby tidak bisa disalahkan. <br><br><a name="4"></a><h1>  Studi Fragmentasi Alokasi Memori </h1><br>  Kemungkinan tersangka lain adalah pengalokasi memori.  Pada akhirnya, Nate Berkopek dan Heroku memperhatikan bahwa meributkan dengan pengalokasi memori (baik pengganti penuh untuk jemalloc atau mengatur variabel lingkungan ajaib <code>MALLOC_ARENA_MAX=2</code> ) secara drastis mengurangi penggunaan memori. <br><br>  Pertama mari kita lihat apa yang dilakukan <code>MALLOC_ARENA_MAX=2</code> dan mengapa itu membantu.  Kemudian kami memeriksa fragmentasi di tingkat distributor. <br><br><a name="4_1"></a><h3>  Alokasi memori yang berlebihan dan glibc </h3><br>  Alasan <code>MALLOC_ARENA_MAX=2</code> membantu adalah <code>MALLOC_ARENA_MAX=2</code> multithreading.  Ketika beberapa utas secara bersamaan mencoba mengalokasikan memori dari tumpukan sistem yang sama, mereka memperjuangkan akses.  Hanya satu utas pada satu waktu dapat menerima memori, yang mengurangi kinerja alokasi memori multi-utas. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">Hanya satu utas pada satu waktu yang dapat bekerja dengan tumpukan sistem.</font></i>  <i><font color="gray">Dalam tugas multi-utas, konflik muncul dan, akibatnya, kinerja menurun</font></i> <br><br>  Di pengalokasi memori untuk kasus seperti itu ada optimasi.  Dia mencoba membuat beberapa tumpukan sistem dan menetapkannya ke utas berbeda.  Sebagian besar utas hanya berfungsi dengan tumpukannya sendiri, menghindari konflik dengan utas lainnya. <br><br>  Faktanya, jumlah maksimum tumpukan sistem yang dialokasikan dengan cara ini secara default sama dengan jumlah prosesor virtual dikalikan dengan 8. Artinya, dalam sistem dual-core dengan dua hyper-thread, masing-masing menghasilkan <code>2 * 2 * 8 = 32</code> tumpukan sistem!  Inilah yang saya sebut <b>distribusi berlebihan</b> . <br><br>  Mengapa pengganda standar begitu besar?  Karena pengembang pengalokasi memori terkemuka adalah Red Hat.  Pelanggan mereka adalah perusahaan besar dengan server yang kuat dan satu ton RAM.  Optimalisasi di atas memungkinkan Anda untuk meningkatkan kinerja multithreading rata-rata sebesar 10% karena peningkatan yang signifikan dalam penggunaan memori.  Untuk pelanggan Red Hat, ini adalah kompromi yang bagus.  Untuk sebagian besar sisanya - hampir tidak. <br><br>  Nate dalam blognya dan artikel Heroku mengklaim bahwa meningkatkan jumlah tumpukan sistem meningkatkan fragmentasi, dan mengutip dokumentasi resmi.  Variabel <code>MALLOC_ARENA_MAX</code> mengurangi jumlah maksimum tumpukan sistem yang dialokasikan untuk multithreading.  Dengan logika ini, ini mengurangi fragmentasi. <br><br><a name="4_2"></a><h3>  Visualisasi tumpukan sistem </h3><br>  Apakah pernyataan oleh Nate dan Heroku benar bahwa meningkatkan jumlah tumpukan sistem meningkatkan fragmentasi?  Bahkan, apakah ada masalah dengan fragmentasi di tingkat pengalokasi memori?  Saya tidak mau menerima asumsi ini begitu saja, jadi saya mulai belajar. <br><br>  Sayangnya, tidak ada alat untuk memvisualisasikan tumpukan sistem, jadi <b>saya menulis visualisasi seperti itu sendiri</b> . <br><br>  Pertama, Anda perlu mempertahankan skema distribusi tumpukan sistem.  Saya mempelajari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber pengalokasi memori</a> dan melihat bagaimana itu secara internal mewakili memori.  Kemudian ia menulis perpustakaan yang beralih pada struktur data ini dan menulis skema ke file.  Akhirnya, ia menulis alat yang mengambil file seperti input dan mengkompilasi visualisasi sebagai gambar HTML dan PNG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode sumber</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Berikut adalah contoh memvisualisasikan satu tumpukan sistem tertentu (ada banyak lagi).  Blok kecil dalam visualisasi ini mewakili halaman sistem. <br><br><ul><li>  Area merah digunakan sel memori. </li><li>  Abu-abu adalah area bebas yang tidak dilepaskan kembali ke inti. </li><li>  Area putih dibebaskan untuk nukleus. </li></ul><br>  Kesimpulan berikut dapat diambil dari visualisasi: <br><br><ol><li>  Ada beberapa fragmentasi.  Bintik merah tersebar dari memori, dan beberapa halaman sistem hanya setengah merah. <br></li><li>  Yang mengejutkan saya, <i>kebanyakan</i> tumpukan sistem mengandung banyak halaman sistem gratis (abu-abu)! </li></ol><br>  Dan kemudian saya sadar: <br><br>  <i><b>Meskipun fragmentasi tetap menjadi masalah, bukan itu intinya!</b></i> <br><br>  Sebaliknya, masalahnya adalah banyak abu-abu: pengalokasi memori <i>ini tidak mengirim memori kembali ke kernel</i> ! <br><br>  Setelah mempelajari kembali kode sumber pengalokasi memori, ternyata secara default hanya mengirim halaman sistem ke kernel di akhir tumpukan sistem, dan bahkan <i>jarang</i> melakukannya.  Mungkin, algoritma semacam itu diterapkan untuk alasan kinerja. <br><br><a name="5"></a><h1>  Trik Sulap: Sunat </h1><br>  Untungnya, saya menemukan satu trik.  Ada satu antarmuka pemrograman yang akan memaksa pengalokasi memori untuk merilis untuk kernel tidak hanya yang terakhir, tetapi <i>semua</i> halaman sistem yang relevan.  Ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">malloc_trim</a> . <br><br>  Saya tahu tentang fungsi ini, tetapi saya pikir itu tidak berguna, karena manual mengatakan yang berikut: <br><br><blockquote>  Fungsi malloc_trim () mencoba membebaskan memori bebas di bagian atas heap. </blockquote><br>  <b>Manualnya salah!</b>  Analisis kode sumber mengatakan bahwa program membebaskan semua halaman sistem yang relevan, bukan hanya bagian atas. <br><br>  Apa yang terjadi jika fungsi ini dipanggil selama pengumpulan sampah?  Saya memodifikasi kode sumber Ruby 2.6 untuk memanggil <code>malloc_trim()</code> di fungsi gc_start dari gc.c, misalnya: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  Dan inilah hasil tesnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>Sungguh perbedaan besar!</b>  Patch sederhana mengurangi konsumsi memori hingga hampir <code>MALLOC_ARENA_MAX=2</code> . <br><br>  Begini tampilannya dalam visualisasi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  Kami melihat banyak area putih yang sesuai dengan halaman sistem yang dibebaskan kembali ke kernel. <br><br><a name="6"></a><h1>  Kesimpulan </h1><br>  Ternyata fragmentasi itu, pada dasarnya, tidak ada hubungannya dengan itu.  Defragmentasi masih berguna, tetapi masalah utamanya adalah bahwa pengalokasi memori tidak ingin membebaskan memori kembali ke kernel. <br><br>  Untungnya, solusinya ternyata sangat sederhana.  Hal utama adalah menemukan akar permasalahannya. <br><br><a name="6_1"></a><h3>  Kode Sumber Visualizer </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode sumber</a> <br><br><a name="6_2"></a><h3>  Bagaimana dengan kinerja? </h3><br>  Kinerja tetap menjadi salah satu perhatian utama.  Memanggil <code>malloc_trim()</code> tidak dapat <code>malloc_trim()</code> secara gratis, tetapi menurut kode, algoritme berfungsi dalam waktu linier.  Jadi saya menoleh ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Noah Gibbs</a> , yang meluncurkan benchmark Rails Ruby Bench.  Yang mengejutkan saya, tambalan itu menyebabkan sedikit <b>peningkatan</b> kinerja. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  Itu menghancurkan pikiran saya.  Efeknya tidak bisa dipahami, tetapi beritanya bagus. <br><br><a name="6_3"></a><h3>  Perlu lebih banyak tes. </h3><br>  Sebagai bagian dari penelitian ini, hanya sejumlah kecil kasus yang telah diverifikasi.  Tidak diketahui apa dampaknya terhadap beban kerja lainnya.  Jika Anda ingin membantu dalam pengujian, silakan <a href="">hubungi saya</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444482/">https://habr.com/ru/post/id444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444470/index.html">20 kebiasaan untuk menjaga kebersihan: cara menggunakan teknologi, tetapi jangan biarkan mereka mengambil waktu dan perhatian mereka</a></li>
<li><a href="../id444472/index.html">Meniru layanan web Amazon dalam proses JVM. Menghindari Roskomnadzor dan mempercepat pengembangan dan pengujian</a></li>
<li><a href="../id444474/index.html">Pembangunan jalur komunikasi Sakhalin-Kuril. Tur Segero - Kereta Gantung</a></li>
<li><a href="../id444476/index.html">Persaingan dari RUSNANO: mengambil kursus online tentang mikroelektronika modern, kemudian tur praktis dengan FPGA, dapatkan hadiah</a></li>
<li><a href="../id444480/index.html">Bagaimana mengurangi bobot elemen struktural pesawat hingga sepertiga</a></li>
<li><a href="../id444486/index.html">Proyek SIRIUS-19 adalah simulasi empat bulan ekspedisi ke bulan di sebuah kompleks berbasis-tanah di Moskow</a></li>
<li><a href="../id444490/index.html">Saya memindai Ukraina</a></li>
<li><a href="../id444492/index.html">Petualangan tiba-tiba</a></li>
<li><a href="../id444494/index.html">La Moto Volante (Lazareth LMV 496) - motor transformator terbang</a></li>
<li><a href="../id444496/index.html">Alat baru untuk mendeteksi intersepsi HTTPS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>