<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title> 革 ｐ Uso de un term贸metro inal谩mbrico externo Buro H999 con dispositivos caseros   憋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Todos son buenos en la estaci贸n meteorol贸gica Buro H146G con un term贸metro inal谩mbrico externo H999. Pero solo para ver las lecturas en su LCD descolo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Uso de un term贸metro inal谩mbrico externo Buro H999 con dispositivos caseros</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432704/"> Todos son buenos en la estaci贸n meteorol贸gica Buro H146G con un term贸metro inal谩mbrico externo H999.  Pero solo para ver las lecturas en su LCD descolorida requiere buena iluminaci贸n.  Y ser铆a mejor para m铆 si la salida de temperatura y humedad fuera de la ventana se mostrara en indicadores suficientemente brillantes (por ejemplo, combinando la pantalla de temperatura y humedad con el reloj en los indicadores de descarga de gas IN-12).  No es dif铆cil hacer tal oficio, pero debe conocer el protocolo de intercambio con un term贸metro inal谩mbrico.  Ya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ha habido art铆culos</a> sobre el uso de un term贸metro inal谩mbrico de estaci贸n meteorol贸gica para obtener temperatura y humedad en el aire.  Pero para las estaciones de Buro, el protocolo de intercambio a煤n no se ha descrito.  Entonces, tenemos que arreglarlo: tal vez alguien pueda ser 煤til. <br><a name="habracut"></a><br>  En Internet, no encontr茅 una descripci贸n del protocolo para intercambiar estaciones BURO.  Y esto significa que debe abrir el protocolo de intercambio de este sensor inal谩mbrico. <br><br>  Mi term贸metro externo se ve as铆: <br><br><img src="https://habrastorage.org/webt/o3/y4/ex/o3y4exet3g-ru6d1bdhpwrqiakm.jpeg"><br><br>  Al conectar un receptor chino superregenerativo de 433.92 MHz al osciloscopio y presionar el bot贸n de PRUEBA en el term贸metro, fue claramente visible c贸mo funcionaban los pulsos de transmisi贸n.  Bueno, dado que la frecuencia all铆 es peque帽a, la salida del receptor se conect贸 a la entrada de la tarjeta de sonido a trav茅s de un divisor resistivo.  Despu茅s de procesar el archivo de sonido grabado, el comparador produjo la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/kp/gh/sv/kpghsvyozbxt9dtkqfk4ap-f9hw.gif"><br><br>  Al igual que con otras estaciones meteorol贸gicas, la modulaci贸n se lleva a cabo cambiando el ciclo de trabajo.  La transmisi贸n comienza desde el bloque de reloj, luego hay otra se帽al de reloj, y luego hay datos, despu茅s de lo cual pasa la se帽al de reloj final.  Aparentemente, dos ceros despu茅s de la se帽al del reloj son el identificador del comienzo de los datos; en cualquier caso, nunca he notado su cambio.  Los datos con un reloj de inicio y fin se duplican seis veces.  El intercambio de datos se lleva a cabo por nibbles. <br><br>  Para decodificar, decid铆 comenzar a recibir el primer reloj y dos ceros, y terminar el 煤ltimo reloj. <br><br>  Para decodificar dicha se帽al, es suficiente calcular la duraci贸n entre las ca铆das de se帽al. <br><br>  Para esto, escrib铆 un programa de prueba simple para el controlador Atmega8: <br><br><div class="spoiler">  <b class="spoiler_title">Programa para Atmega8</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//---------------------------------------------------------------------------------------------------- // //---------------------------------------------------------------------------------------------------- #include &lt;avr/io.h&gt; #include &lt;util/delay.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdio.h&gt; #include &lt;avr/interrupt.h&gt; #include &lt;avr/pgmspace.h&gt; #include &lt;string.h&gt; #include &lt;stdbool.h&gt; #include &lt;stdint.h&gt; //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- #define F_CPU 8000000UL //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ // //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //   UART, / #define UART_SPEED 9600UL //---------------------------------------------------------------------------------------------------- // //---------------------------------------------------------------------------------------------------- //  enum BLOCK_TYPE { BLOCK_TYPE_UNKNOW,//  BLOCK_TYPE_DIVIDER,// BLOCK_TYPE_SYNCHRO,// BLOCK_TYPE_ONE,// BLOCK_TYPE_ZERO// }; //  enum MODE { MODE_WAIT_SYNCHRO,//  MODE_WAIT_ZERO_FIRST,//   MODE_WAIT_ZERO_SECOND,//   MODE_RECEIVE_DATA//  }; //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- static const uint16_t MAX_TIMER_INTERVAL_VALUE=0xFFFF;//    static volatile bool TimerOverflow=false;//    static uint8_t Buffer[20];//   static uint8_t BitSize=0;//   static uint8_t Byte=0;//  //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- void InitAVR(void);//  void UART_Write(unsigned char byte);//   COM- void SendText(const char *text);//   COM- void RF_Init(void);// void RF_SetTimerOverflow(void);//    void RF_ResetTimerOverflow(void);//    bool RF_IsTimerOverflow(void);//,     uint16_t RF_GetTimerValue(void);//   void RF_ResetTimerValue(void);//   BLOCK_TYPE RF_GetBlockType(uint32_t counter,bool value);//   void RF_AddBit(bool state);//   void RF_ResetData(void);//    void RF_AnalizeCounter(uint32_t counter,bool value,MODE &amp;mode);//  //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- int main(void) { InitAVR(); _delay_ms(200); SendText("Thermo unit\r\n"); _delay_ms(200); sei(); while(1); cli(); } //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //  //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- void InitAVR(void) { //  DDRB=0; DDRD=0; DDRC=0; //   PORTB=0; PORTD=0; PORTC=0; //    UART UCSRB=(1&lt;&lt;RXEN)|(1&lt;&lt;TXEN)|(0&lt;&lt;RXCIE); //RXCIE=1    ( I=1   SREG) :      UART  //TXCIE=1    ( I=1   SREG) :      UART  //UDRIE=1    ( I=1   SREG) :      UART  //RXEN=1 :  ,  D0   UART. //TXEN=1 :  ,  D1   UART. //CHR9=1 :       11  (9   + -  + -). //RXB8- - //TXB8- - //      unsigned long speed=F_CPU/(16UL); speed=(speed/UART_SPEED)-1UL; UBRRH=(speed&gt;&gt;8)&amp;0xff; UBRRL=speed&amp;0xFF; RF_Init(); } //---------------------------------------------------------------------------------------------------- //   COM- //---------------------------------------------------------------------------------------------------- void UART_Write(unsigned char byte) { while(!(UCSRA&amp;(1&lt;&lt;UDRE))); UDR=byte; } //---------------------------------------------------------------------------------------------------- //   COM- //---------------------------------------------------------------------------------------------------- void SendText(const char *text) { while((*text)) { UART_Write(*text); text++; } } //---------------------------------------------------------------------------------------------------- // //---------------------------------------------------------------------------------------------------- void RF_Init(void) { //   ACSR=(0&lt;&lt;ACD)|(1&lt;&lt;ACBG)|(0&lt;&lt;ACO)|(0&lt;&lt;ACI)|(1&lt;&lt;ACIE)|(0&lt;&lt;ACIC)|(0&lt;&lt;ACIS1)|(0&lt;&lt;ACIS0); //ACD -   (0 - !) //ACBG -       ' //ACO -   ( ) //ACI -     //ACIE -     //ACIC -       T1 //ACIS1,ACID0 -      //  T1   31250  TCCR1A=(0&lt;&lt;WGM11)|(0&lt;&lt;WGM10)|(0&lt;&lt;COM1A1)|(0&lt;&lt;COM1A0)|(0&lt;&lt;COM1B1)|(0&lt;&lt;COM1B0); //COM1A1-COM1A0 -   OC1A //COM1B1-COM1B0 -   OC1B //WGM11-WGM10 -    TCCR1B=(0&lt;&lt;WGM13)|(0&lt;&lt;WGM12)|(1&lt;&lt;CS12)|(0&lt;&lt;CS11)|(0&lt;&lt;CS10)|(0&lt;&lt;ICES1)|(0&lt;&lt;ICNC1); //WGM13-WGM12 -    //CS12-CS10 -    (      256 (  31250 )) //ICNC1 -       //ICES1 -      TCNT1=0;//   TIMSK|=(1&lt;&lt;TOIE1);//    ( T1 ) } //---------------------------------------------------------------------------------------------------- //    //---------------------------------------------------------------------------------------------------- void RF_SetTimerOverflow(void) { cli(); TimerOverflow=true; sei(); } //---------------------------------------------------------------------------------------------------- //    //---------------------------------------------------------------------------------------------------- void RF_ResetTimerOverflow(void) { cli(); TimerOverflow=false; sei(); } //---------------------------------------------------------------------------------------------------- //,     //---------------------------------------------------------------------------------------------------- bool RF_IsTimerOverflow(void) { cli(); bool ret=TimerOverflow; sei(); return(ret); } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- uint16_t RF_GetTimerValue(void) { cli(); uint16_t ret=TCNT1; sei(); return(ret); } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- void RF_ResetTimerValue(void) { cli(); TCNT1=0; sei(); RF_ResetTimerOverflow(); } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- BLOCK_TYPE RF_GetBlockType(uint32_t counter,bool value) { static const uint32_t DIVIDER_MIN=(31250UL*12)/44100UL; static const uint32_t DIVIDER_MAX=(31250UL*25)/44100UL; static const uint32_t ZERO_MIN=(31250UL*80)/44100UL; static const uint32_t ZERO_MAX=(31250UL*100)/44100UL; static const uint32_t ONE_MIN=(31250UL*160)/44100UL; static const uint32_t ONE_MAX=(31250UL*200)/44100UL; static const uint32_t SYNCHRO_MIN=(31250UL*320)/44100UL; static const uint32_t SYNCHRO_MAX=(31250UL*400)/44100UL; if (counter&gt;DIVIDER_MIN &amp;&amp; counter&lt;DIVIDER_MAX) return(BLOCK_TYPE_DIVIDER);// if (counter&gt;ZERO_MIN &amp;&amp; counter&lt;ZERO_MAX) return(BLOCK_TYPE_ZERO);// if (counter&gt;ONE_MIN &amp;&amp; counter&lt;ONE_MAX) return(BLOCK_TYPE_ONE);// if (counter&gt;SYNCHRO_MIN &amp;&amp; counter&lt;SYNCHRO_MAX) return(BLOCK_TYPE_SYNCHRO);// return(BLOCK_TYPE_UNKNOW);//  } //---------------------------------------------------------------------------------------------------- //   //---------------------------------------------------------------------------------------------------- void RF_AddBit(bool state) { if ((BitSize&gt;&gt;2)&gt;=19) return;//  Byte&lt;&lt;=1; if (state==true) Byte|=1; BitSize++; if ((BitSize&amp;0x03)==0) { Buffer[(BitSize&gt;&gt;2)-1]=Byte; Byte=0; } } //---------------------------------------------------------------------------------------------------- //    //---------------------------------------------------------------------------------------------------- void RF_ResetData(void) { BitSize=0; Byte=0; } //---------------------------------------------------------------------------------------------------- //  //---------------------------------------------------------------------------------------------------- void RF_AnalizeCounter(uint32_t counter,bool value,MODE &amp;mode) { //   BLOCK_TYPE type=RF_GetBlockType(counter,value); if (type==BLOCK_TYPE_UNKNOW) { mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } if (type==BLOCK_TYPE_DIVIDER) return;//    //      if (mode==MODE_WAIT_SYNCHRO)//  { if (type==BLOCK_TYPE_SYNCHRO) { mode=MODE_WAIT_ZERO_FIRST; return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } if (mode==MODE_WAIT_ZERO_FIRST || mode==MODE_WAIT_ZERO_SECOND)//   { if (type==BLOCK_TYPE_SYNCHRO &amp;&amp; mode==MODE_WAIT_ZERO_FIRST) return;//  if (type==BLOCK_TYPE_ZERO &amp;&amp; mode==MODE_WAIT_ZERO_FIRST) { mode=MODE_WAIT_ZERO_SECOND; return; } if (type==BLOCK_TYPE_ZERO &amp;&amp; mode==MODE_WAIT_ZERO_SECOND) { mode=MODE_RECEIVE_DATA; return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //  if (type==BLOCK_TYPE_SYNCHRO)//  { uint8_t size=(BitSize&gt;&gt;2); char str[30]; if (size!=10) { mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //  for(uint8_t n=0;n&lt;size;n++) { uint8_t b=Buffer[n]; uint8_t mask=(1&lt;&lt;3); for(uint8_t m=0;m&lt;4;m++,mask&gt;&gt;=1) { if (b&amp;mask) SendText("1"); else SendText("0"); } SendText(" "); } uint8_t channel=Buffer[2]&amp;0x03; uint8_t key=(Buffer[8]&gt;&gt;3)&amp;0x01; uint8_t h=(Buffer[7]&lt;&lt;4)|(Buffer[6]);// int16_t temp=(Buffer[5]&lt;&lt;8)|(Buffer[4]&lt;&lt;4)|(Buffer[3]);// int16_t k=18; int16_t t=(10*(temp-1220))/k; sprintf(str,"%i",key); SendText("Key:"); SendText(str); sprintf(str,"%i",channel+1); SendText(" Ch:"); SendText(str); sprintf(str,"%i",h); SendText(" H:"); SendText(str); SendText("%, T:"); if (t&lt;0) { t=-t; sprintf(str,"-%i.%i",(int)(t/10),(int)(t%10)); } else { sprintf(str,"%i.%i",(int)(t/10),(int)(t%10)); } SendText(str); SendText(" C\r\n"); mode=MODE_WAIT_SYNCHRO; RF_ResetData(); return; } //  if (type==BLOCK_TYPE_ONE) { RF_AddBit(true); return; } if (type==BLOCK_TYPE_ZERO) { RF_AddBit(false); return; } mode=MODE_WAIT_SYNCHRO; RF_ResetData(); } //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //   //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //---------------------------------------------------------------------------------------------------- //    T1 (16-  )   //---------------------------------------------------------------------------------------------------- ISR(TIMER1_OVF_vect) { RF_SetTimerOverflow(); } //---------------------------------------------------------------------------------------------------- //     //---------------------------------------------------------------------------------------------------- ISR(ANA_COMP_vect) { ACSR&amp;=0xFF^(1&lt;&lt;ACIE);//  ACSR|=(1&lt;&lt;ACI);//    static MODE mode=MODE_WAIT_SYNCHRO; //   uint16_t length=RF_GetTimerValue(); if (RF_IsTimerOverflow()==true) length=MAX_TIMER_INTERVAL_VALUE;// ,    RF_ResetTimerValue(); //   bool value=true; if (ACSR&amp;(1&lt;&lt;ACO)) value=false; RF_AnalizeCounter(length,value,mode); ACSR|=(1&lt;&lt;ACIE);//  }</span></span></code> </pre> <br></div></div><br>  La salida del receptor est谩 conectada al pin 13 (AIN1).  Atmega se conecta a trav茅s de max232 al puerto COM de la computadora (o al adaptador USB-COM).  Velocidad de puerto 9600 baudios. <br><br>  Despu茅s de la decodificaci贸n, obtenemos el siguiente flujo de datos (elimino los dos ceros iniciales): <br><br>  // sin bot贸n, canal 1 <br>  1100 1100 0000 1110 1000 0110 1100 0001 0000 1001 Humedad: 28% Temperatura: 25,4 <br>  // sin bot贸n, canal 2 <br>  1100 1100 0001 1110 1000 0110 1101 0001 0000 0110 Humedad: 29% Temperatura: 25.4 <br><br>  El paquete total se ve as铆: <br><br><img src="https://habrastorage.org/webt/dq/mj/iu/dqmjiuixxbenuwzxubzgfftypow.png"><br><br>  I0-I7: identificador del term贸metro.  Cada vez que se enciende el term贸metro, el identificador cambia. <br><br>  C0-C1 - canal (hay 3 posibles en total).  Los canales est谩n numerados desde cero. <br><br>  H0-H7 - humedad.  La humedad como porcentaje se lee tal cual, pero la temperatura (T0-T11) se ajusta por alguna raz贸n en un formato inusual para las estaciones meteorol贸gicas.  A juzgar por las descripciones de los protocolos de intercambio de varias estaciones meteorol贸gicas que encontr茅, uno esperar铆a una temperatura en d茅cimas de grado y con un cambio en el l铆mite inferior del term贸metro.  Entonces no.  Los experimentos mostraron que el c贸digo de temperatura de esta estaci贸n meteorol贸gica se traduce a grados Celsius como (T-1220) / 18.  驴C贸mo conocen estos n煤meros m谩gicos solo a los chinos que idearon este protocolo de intercambio? <br><br>  Como sugiri贸 el asistente de wolowizard en los comentarios, la estaci贸n transfiere la temperatura en d茅cimas de grado Fahrenheit, por lo que una traducci贸n significativa en grados Celsius ser谩 0.1 * (T-320) * 5 / 9-500 = 0.1 * (T-1220) /1.8. <br><br>  El bit K corresponde a presionar el bot贸n TEST. <br><br>  No se pudo establecer la asignaci贸n de los campos restantes, pero result贸 que el valor del interruptor Fahrenheit / Celsius en el term贸metro no entra en el protocolo de intercambio.  Presumiblemente, el 煤ltimo mordisco (o tal vez parte del pen煤ltimo) tambi茅n es CRC, pero todav铆a no he podido calcular el algoritmo (existe la sospecha de que las filas y columnas de mordisco est谩n involucradas en el c谩lculo).  Si alguien puede resolver este acertijo, d铆ganos el algoritmo de c谩lculo. <br>  Para aquellos que quieran estallar sus cerebros, pero no tienen ese term贸metro, les doy una tabla de datos aceptados. <br><br><div class="spoiler">  <b class="spoiler_title">Mesa</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1001 0110 0101 1011 1000 0110 1000 0010 0001 1111 Key:0 Ch:2 H:40%, T:25.2 C 1001 1001 0000 1101 1010 0100 0101 0101 0000 0110 Key:0 Ch:1 H:85%, T:-1.2 C 1001 0110 0101 1100 1000 0110 1010 0010 0001 0100 Key:0 Ch:2 H:42%, T:25.3 C 1001 0110 1001 0110 0111 0110 1101 0001 0010 1111 Key:0 Ch:2 H:29%, T:24.1 C 1001 0110 1001 0000 0111 0110 1101 0001 0010 1000 Key:0 Ch:2 H:29%, T:23.7 C 1001 0110 1001 0010 0101 0110 1110 0001 0010 1111 Key:0 Ch:2 H:30%, T:22.1 C 1001 0110 1001 1001 0011 0110 1110 0001 0010 1100 Key:0 Ch:2 H:30%, T:20.7 C 1001 0110 1001 1111 0001 0110 1111 0001 0010 1010 Key:0 Ch:2 H:31%, T:19.2 C 1001 0110 0101 1001 0000 0110 0001 0010 0010 1000 Key:0 Ch:2 H:33%, T:18.0 C 1001 0110 0101 0010 1111 0101 0010 0010 0010 0111 Key:0 Ch:2 H:34%, T:16.7 C 1001 0110 0101 0100 1110 0101 0010 0010 0010 0010 Key:0 Ch:2 H:34%, T:16.0 C 1001 0110 0101 0100 1101 0101 0011 0010 0010 0001 Key:0 Ch:2 H:35%, T:15.1 C 1001 0110 0101 1100 1100 0101 0100 0010 0010 1110 Key:0 Ch:2 H:36%, T:14.6 C 1001 0110 0101 1111 1011 0101 0101 0010 0010 1111 Key:0 Ch:2 H:37%, T:13.9 C 1001 0110 0101 0011 1011 0101 0101 0010 0010 0001 Key:0 Ch:2 H:37%, T:13.2 C 1001 0110 0101 1001 1010 0101 0110 0010 0010 0101 Key:0 Ch:2 H:38%, T:12.7 C 1001 0110 0101 0100 1010 0101 0111 0010 0010 1000 Key:0 Ch:2 H:39%, T:12.4 C 1001 0110 0101 1011 1001 0101 0111 0010 0010 1010 Key:0 Ch:2 H:39%, T:11.9 C 1001 0110 0101 0011 1001 0101 1000 0010 0010 1001 Key:0 Ch:2 H:40%, T:11.5 C 1001 0110 0101 1011 1000 0101 1000 0010 0010 1110 Key:0 Ch:2 H:40%, T:11.0 C 1001 0110 0101 0111 1000 0101 1001 0010 0010 0101 Key:0 Ch:2 H:41%, T:10.8 C 1001 0110 0101 1111 0111 0101 1001 0010 0010 1101 Key:0 Ch:2 H:41%, T:10.3 C 1001 0110 0101 0111 0111 0101 1010 0010 0010 0111 Key:0 Ch:2 H:42%, T:9.9 C 1001 0110 0101 0001 0111 0101 1011 0010 0010 0101 Key:0 Ch:2 H:43%, T:9.6 C 1001 0110 0101 1011 0110 0101 1100 0010 0010 0110 Key:0 Ch:2 H:44%, T:9.2 C 1001 0110 0101 1000 0110 0101 1100 0010 0010 1100 Key:0 Ch:2 H:44%, T:9.1 C 1001 0110 0101 0011 0110 0101 1101 0010 0010 0110 Key:0 Ch:2 H:45%, T:8.8 C 1001 0110 0101 1001 0101 0101 1110 0010 0010 0110 Key:0 Ch:2 H:46%, T:8.2 C 1001 0110 0101 0101 0101 0101 1111 0010 0010 1101 Key:0 Ch:2 H:47%, T:8.0 C 1001 0110 0101 0010 0101 0101 1111 0010 0010 1100 Key:0 Ch:2 H:47%, T:7.8 C 1001 0110 0101 1110 0100 0101 1111 0010 0010 0000 Key:0 Ch:2 H:47%, T:7.6 C 1001 0110 0101 1100 0100 0101 1111 0010 0010 1100 Key:0 Ch:2 H:47%, T:7.5 C</code> </pre> <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es432704/">https://habr.com/ru/post/es432704/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es432692/index.html">Lanzamos el mayor proyecto de limpieza de oc茅anos.</a></li>
<li><a href="../es432696/index.html">nomoregoogle.com - una nueva compilaci贸n de alternativas a los servicios gigantes tecnol贸gicos</a></li>
<li><a href="../es432698/index.html">Fant谩sticos timbales y donde viven</a></li>
<li><a href="../es432700/index.html">隆Vamos! @ # Con tu "toxicidad"</a></li>
<li><a href="../es432702/index.html">Contenido 2018: mira m谩s amplio, profundiza</a></li>
<li><a href="../es432706/index.html">Equipo One-to-Many en Customer Success: 驴Por qu茅 lo necesita?</a></li>
<li><a href="../es432708/index.html">SFU en cascada: mejora de la escalabilidad y la calidad de los medios en aplicaciones WebRTC</a></li>
<li><a href="../es432710/index.html">Llamadas de spam. 驴Es posible luchar contra ellos?</a></li>
<li><a href="../es432712/index.html">Agile no es un proceso de desarrollo, sino un enfoque para crear un producto</a></li>
<li><a href="../es432714/index.html">Semana de la seguridad 50: predicciones de 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>