<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏻 👩‍👩‍👧‍👧 🙅🏾 OutOfLine - pola dalam-memori untuk aplikasi C ++ kinerja tinggi ⤴️ 🤾 ⚪️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat bekerja di Headlands Technologies, saya cukup beruntung untuk menulis beberapa utilitas untuk menyederhanakan pembuatan kode C ++ berkinerja ting...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OutOfLine - pola dalam-memori untuk aplikasi C ++ kinerja tinggi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421475/"><p> Saat bekerja di Headlands Technologies, saya cukup beruntung untuk menulis beberapa utilitas untuk menyederhanakan pembuatan kode C ++ berkinerja tinggi.  Artikel ini menawarkan gambaran umum tentang salah satu dari utilitas ini, <a href=""><code>OutOfLine</code></a> . </p><a name="habracut"></a><br><p>  Mari kita mulai dengan contoh ilustratif.  Misalkan Anda memiliki sistem yang berhubungan dengan sejumlah besar objek sistem file.  Ini bisa berupa file biasa, bernama soket atau pipa UNIX.  Untuk beberapa alasan, Anda membuka banyak deskriptor file saat startup, kemudian bekerja secara intensif dengan mereka, dan pada akhirnya, tutup deskriptor dan hapus tautan ke file (kira-kira. Jalur berarti fungsi hapus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautan</a> ). </p><br><p>  Versi awal (disederhanakan) mungkin terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> path; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : path(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD() { close(fd); unlink(path.c_str()); } UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Dan ini adalah desain yang bagus dan logis.  Itu bergantung pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RAII</a> untuk secara otomatis melepaskan deskriptor dan menghapus tautan.  Anda bisa membuat array besar dari objek-objek seperti itu, bekerja dengannya, dan ketika array tidak ada lagi, objek-objek itu sendiri akan menghapus semua yang diperlukan dalam proses. </p><br><p>  Tetapi bagaimana dengan kinerja?  Misalkan <code>fd</code> digunakan sangat sering, dan <code>path</code> hanya saat menghapus suatu objek.  Sekarang array terdiri dari objek berukuran 40 byte, tetapi seringkali hanya 4 byte yang digunakan.  Ini berarti bahwa akan ada lebih banyak kesalahan dalam cache, karena Anda perlu "melewati" 90% data. </p><br><p>  Salah satu solusi umum untuk masalah ini adalah transisi dari array struktur ke struktur array.  Ini akan memberikan kinerja yang diinginkan, tetapi dengan mengorbankan RAII.  Apakah ada opsi yang menggabungkan keunggulan dari kedua pendekatan? </p><br><p>  Kompromi sederhana adalah mengganti <code>std::string</code> ukuran 32 byte dengan <code>std::unique_ptr&lt;std::string&gt;</code> , yang ukurannya hanya 8 byte.  Ini akan mengurangi ukuran objek kita dari 40 byte menjadi 16 byte, yang merupakan pencapaian besar.  Tetapi solusi ini masih kalah jika menggunakan banyak array. </p><br><p>  <code>OutOfLine</code> adalah alat yang memungkinkan tanpa meninggalkan RAII untuk sepenuhnya memindahkan bidang (dingin) yang jarang digunakan di luar objek.  OutOfLine digunakan sebagai kelas dasar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CRTP</a> , jadi argumen pertama ke template harus kelas anak.  Argumen kedua adalah tipe data yang jarang digunakan (dingin) yang dikaitkan dengan objek (utama) yang sering digunakan. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnlinkingFD</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd; UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; p) : OutOfLine&lt;UnlinkingFD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(p) { fd = open(p.c_str(), O_RDWR, <span class="hljs-number"><span class="hljs-number">0</span></span>); } ~UnlinkingFD(); UnlinkingFD(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> UnlinkingFD&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; };</code> </pre> <br><p>  Jadi seperti apa kelas ini? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FastData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ColdData</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class"> {</span></span></code> </pre> <br><p>  Gagasan implementasi dasar adalah menggunakan wadah asosiatif global yang memetakan pointer ke objek utama dan pointer ke objek yang berisi data dingin. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>*, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;ColdData&gt;&gt; global_map_;</code> </pre> <br><p>  <code>OutOfLine</code> dapat digunakan dengan semua jenis data dingin, sebuah instance yang dibuat dan dikaitkan dengan objek utama secara otomatis. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">explicit</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); }</code> </pre> <br><p>  Menghapus objek utama memerlukan penghapusan otomatis objek dingin terkait: </p><br><pre> <code class="cpp hljs"> ~OutOfLine() { global_map_.erase(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><p>  Saat memindahkan (memindahkan konstruktor / memindahkan tugas operator) dari objek utama, objek dingin yang sesuai akan secara otomatis dikaitkan dengan objek penerus utama baru.  Akibatnya, Anda tidak boleh mengakses data dingin objek yang dipindahkan dari. </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OutOfLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutOfLine&amp;&amp; other)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = other; } OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine&amp;&amp; other) { global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(global_map_[&amp;other]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre> <br><p>  Dalam contoh implementasi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">atas</a> , <code>OutOfLine</code> dibuat tidak dapat disalin untuk kesederhanaan.  Jika perlu, operasi penyalinan mudah ditambahkan, mereka hanya perlu membuat dan menautkan salinan objek dingin. </p><br><pre> <code class="cpp hljs">OutOfLine(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; OutOfLine&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(OutOfLine <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp;) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>;</code> </pre> <br><p>  Nah, agar ini benar-benar bermanfaat, alangkah baiknya memiliki akses ke data dingin.  Ketika mewarisi dari <code>OutOfLine</code> kelas menerima metode <code>cold()</code> konstan dan tidak konstan <code>cold()</code> : </p><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">ColdData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; } <span class="hljs-function"><span class="hljs-function">ColdData </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cold</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]; }</code> </pre> <br><p>  Mereka mengembalikan tipe referensi yang sesuai ke data dingin. </p><br><p>  Itu hampir semuanya.  Opsi <code>UnlinkingFD</code> ini akan berukuran 4 byte, menyediakan akses yang mudah digunakan untuk cache ke bidang <code>fd</code> , dan mempertahankan manfaat RAII.  Semua pekerjaan yang berkaitan dengan siklus hidup suatu objek sepenuhnya otomatis.  Ketika objek utama yang sering digunakan bergerak, jarang digunakan data dingin bergerak bersamanya.  Ketika objek utama dihapus, objek dingin yang sesuai juga dihapus. </p><br><p>  Namun, kadang-kadang, data Anda berkonspirasi untuk menyulitkan hidup Anda - dan Anda dihadapkan pada situasi di mana data dasar harus dibuat terlebih dahulu.  Sebagai contoh, mereka diperlukan untuk membangun data dingin.  Ada kebutuhan untuk membuat objek dalam urutan terbalik relatif terhadap apa yang ditawarkan <code>OutOfLine</code> .  Untuk kasus seperti itu, "cadangan" berguna bagi kita untuk mengontrol urutan inisialisasi dan de-inisialisasi. </p><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TwoPhaseInit</span></span></span><span class="hljs-class"> {</span></span>}; OutOfLine(TwoPhaseInit){} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">init_cold_data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgs</span></span></span><span class="hljs-class">&amp;&amp;... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">args</span></span></span><span class="hljs-class">) {</span></span> global_map_.find(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)-&gt;second = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;ColdData&gt;(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgs&gt;(args)...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release_cold_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ global_map_[<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>].reset(); }</code> </pre> <br><p>  Ini adalah konstruktor <code>OutOfLine</code> lain yang dapat digunakan di kelas anak-anak, ia menerima tag tipe <code>TwoPhaseInit</code> .  Jika Anda membuat <code>OutOfLine</code> dengan cara ini, data dingin tidak akan diinisialisasi, dan objek akan tetap setengah dibangun.  Untuk menyelesaikan konstruksi dua fase, Anda perlu memanggil metode <code>init_cold_data</code> (menyampaikan argumen yang diperlukan untuk membuat objek tipe <code>ColdData</code> ).  Ingat bahwa Anda tidak dapat memanggil <code>.cold()</code> pada objek yang datanya dingin belum diinisialisasi.  Dengan analogi, data dingin dapat dihapus lebih cepat dari jadwal sebelum mengeksekusi <code>~OutOfLine</code> destructor dengan memanggil <code>release_cold_data</code> . </p><br><pre> <code class="cpp hljs">}; <span class="hljs-comment"><span class="hljs-comment">// end of class OutOfLine</span></span></code> </pre> <br><p>  Sekarang semuanya.  Jadi apa yang diberikan 29 baris kode ini kepada kita?  Mereka adalah tradeoff lain yang mungkin antara kinerja dan kemudahan penggunaan.  Dalam kasus di mana Anda memiliki objek, beberapa yang anggotanya digunakan lebih sering daripada yang lain, <code>OutOfLine</code> dapat berfungsi sebagai cara yang mudah digunakan untuk mengoptimalkan cache, dengan biaya secara signifikan memperlambat akses ke data yang jarang digunakan. </p><br><p>  Kami dapat menerapkan teknik ini di beberapa tempat - cukup sering ada kebutuhan untuk melengkapi data kerja yang digunakan secara intensif dengan metadata tambahan yang diperlukan di akhir pekerjaan, dalam situasi yang jarang atau tidak terduga.  Baik itu informasi tentang pengguna yang membuat koneksi, dari terminal perdagangan dari mana pesanan datang, atau gagang akselerator perangkat keras yang terlibat dalam pemrosesan data pertukaran - <code>OutOfLine</code> menjaga cache tetap bersih ketika Anda berada di bagian penting dari perhitungan (jalur kritis). </p><br><p>  Saya menyiapkan <a href="">tes</a> sehingga Anda dapat melihat dan mengevaluasi perbedaannya. </p><br><table><thead><tr><th>  Skrip </th><th>  Waktu </th></tr></thead><tbody><tr><td>  Data dingin di objek utama (versi awal) </td><td>  34684547 </td></tr><tr><td>  Data dingin sepenuhnya dihapus (skenario kasus terbaik) </td><td>  2938327 </td></tr><tr><td>  Menggunakan OutOfLine </td><td>  2947645 </td></tr></tbody></table><br><p>  Saya mendapat akselerasi <code>OutOfLine</code> saat menggunakan <code>OutOfLine</code> .  Jelas, tes ini dirancang untuk menunjukkan potensi <code>OutOfLine</code> , tetapi juga menunjukkan berapa banyak optimasi cache dapat memiliki dampak signifikan pada kinerja, seperti halnya <code>OutOfLine</code> memungkinkan <code>OutOfLine</code> untuk mendapatkan optimasi ini.  Menjaga cache tetap bebas dari data yang jarang digunakan dapat memberikan perbaikan yang kompleks, terukur, komprehensif untuk sisa kode.  Seperti biasa dengan optimasi, pengukuran kepercayaan lebih dari asumsi, namun saya harap <code>OutOfLine</code> akan terbukti menjadi alat yang berguna dalam koleksi utilitas Anda. </p><br><h2 id="primechanie-ot-perevodchika">  <em>Catatan dari penerjemah</em> </h2><br><p>  <em>Kode yang disediakan dalam artikel berfungsi untuk menunjukkan gagasan dan tidak mewakili kode produksi.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id421475/">https://habr.com/ru/post/id421475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id421465/index.html">Mobile DevOps dalam praktiknya</a></li>
<li><a href="../id421467/index.html">Pengembangan robot untuk mengumpulkan bola golf</a></li>
<li><a href="../id421469/index.html">Telegram setuju untuk mentransfer ke layanan khusus [tetapi bukan Rusia] alamat IP dan nomor dari beberapa pengguna</a></li>
<li><a href="../id421471/index.html">Server Ad Exchange - Tidak Seperti Lainnya</a></li>
<li><a href="../id421473/index.html">Apa itu Coroutine di Kotlin?</a></li>
<li><a href="../id421477/index.html">Apa yang tertulis dalam file .ssh / known_hosts</a></li>
<li><a href="../id421481/index.html">Mikrofon, tangkapan layar, dan video lokal: bagaimana Voximplant Web SDK mengontrol media di browser</a></li>
<li><a href="../id421485/index.html">Pemberitahuan penting untuk pengguna Halaman Gitlab</a></li>
<li><a href="../id421487/index.html">Cara Memperkuat Dukungan Teknis - 6 Cara Rahasia</a></li>
<li><a href="../id421489/index.html">Menggerutu tapi memberi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>