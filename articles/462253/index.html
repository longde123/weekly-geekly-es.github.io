<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜüèæ üèè üìê Los primeros experimentos que utilizan el protocolo de transmisi√≥n en el ejemplo de comunicaci√≥n de CPU y procesador en el FPGA Redd üé∑ üåò üè∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En art√≠culos anteriores, ya nos reunimos con el bus Avalon-MM , donde MM significa Memory Mapped, es decir, proyectado en la memoria. Este neum√°tico e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Los primeros experimentos que utilizan el protocolo de transmisi√≥n en el ejemplo de comunicaci√≥n de CPU y procesador en el FPGA Redd</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462253/"><img src="https://habrastorage.org/webt/hx/9r/u0/hx9ru01kpi9-x1z8jztv7uaemjm.jpeg"><br><br>  En art√≠culos anteriores, ya nos reunimos con el bus <b>Avalon-MM</b> , donde MM significa Memory Mapped, es decir, proyectado en la memoria.  Este neum√°tico es bastante vers√°til.  Se pueden conectar varios dispositivos maestros (Master) y varios esclavos.  Ya conectamos dos dispositivos l√≠deres a la vez (Instruction Master y Data Master), porque el procesador NIOS II tiene una arquitectura Harvard, por lo que los buses de comando y datos son diferentes, pero muchos autores los conectan al mismo com√∫n para simplificar el desarrollo de software desde el exterior al bus <br><br>  Si un bloque en el bus tiene la funcionalidad de acceso directo a memoria (DMA), tambi√©n contendr√° un maestro para el bus. <br><br>  En realidad, el principal inconveniente de este neum√°tico se basa en este hecho (muchos l√≠deres, muchos seguidores).  Cuando dise√±amos nuestro esclavo, tuvimos que decodificar la direcci√≥n.  Cuando result√≥ ser mi l√≠der, hab√≠a mucho m√°s alboroto con el arbitraje.  Pero un hilo rojo en toda la serie de art√≠culos es la afirmaci√≥n de que el desarrollo para Redd es una parte auxiliar del proyecto, no deber√≠a requerir demasiado trabajo.  Y si podemos liberarnos de la rutina, debemos liberarnos de ella. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/ns/cc/m1/nsccm1g4bldwl-4okgx-puukhyk.png"><br><br>  Todos los art√≠culos del ciclo: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd, y depuraci√≥n utilizando la prueba de memoria como ejemplo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo del "firmware" m√°s simple para FPGAs instalados en Redd.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. C√≥digo del programa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de su propio n√∫cleo para incrustar en un sistema de procesador basado en FPGA</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Desarrollo de programas para el procesador central Redd sobre el ejemplo de acceso a la FPGA</a> </li></ol><br>  El documento de <b>especificaciones de la interfaz de Avalon</b> que ya conocemos (en general, no doy enlaces directos, ya que siempre cambian, por lo que toda la red est√° llena de art√≠culos con enlaces muertos, es m√°s f√°cil encontrar la posici√≥n actual al ingresar el nombre en el motor de b√∫squeda) informa que, adem√°s del autob√∫s <b>Avalon-MM</b> , Tambi√©n hay un autob√∫s <b>Avalon-ST</b> , donde ST significa Stream, es decir, streaming.  El hecho es que muy a menudo los datos transmitidos tienen una estructura de flujo.  S√≠, incluso el sector cl√°sico del disco duro.  Tiene un tama√±o fijo.  Se debe pasar de principio a fin.  Incluso si lo consideramos en el √°rea direccionable, entonces las direcciones aumentar√°n linealmente.  Y si usa el bloque FIFO para el almacenamiento, entonces las direcciones dentro de √©l est√°n completamente ocultas para nosotros.  Lo son, pero trabajar con ellos no es nuestra preocupaci√≥n. <br><br>  Lo mismo se aplica a muchos otros datos de transmisi√≥n: siempre van de principio a fin y se colocan en repositorios secuencialmente.  Esto es exactamente lo que los protocolos de transmisi√≥n se utilizan para transferir dichos datos.  Adem√°s de la falta de direccionamiento expl√≠cito, el bus <b>Avalon-ST</b> es interesante porque siempre conecta dos dispositivos: una fuente y un receptor.  Siempre hay dos de ellos.  Un dispositivo es siempre la fuente, el segundo es siempre el receptor.  Por lo tanto, los problemas con el arbitraje de este autob√∫s no se refieren.  As√≠ es como se ven los pares de dispositivos t√≠picos conectados a este bus: <br><br><img src="https://habrastorage.org/webt/z_/ix/tz/z_ixtzpnxmb0fhhyoxgsqnydhvc.png"><br><br>  Y aqu√≠ est√°n las se√±ales t√≠picas de este autob√∫s: <br><br><img src="https://habrastorage.org/webt/ua/bh/ku/uabhkulgiofulvfomh0mw-mdz7g.png"><br><br>  Adem√°s, las l√≠neas de <b>error</b> son opcionales, transmiten c√≥digos de error binarios asignados por nosotros y podemos decir que no hay c√≥digos de error.  Y las l√≠neas de n√∫mero de canal, como vimos anteriormente, solo son necesarias si la demultiplexaci√≥n se realiza m√°s.  Si no, el n√∫mero de canal no es necesario.  Lo haremos sin √©l por ahora.  Quedan tres l√≠neas: de hecho, datos, una se√±al de disponibilidad y una se√±al de confirmaci√≥n de datos (luz estrobosc√≥pica).  Bueno, otra se√±al de reloj, ya que el bus est√° sincronizado. <br><br>  De la documentaci√≥n tambi√©n se deduce que son posibles tres se√±ales m√°s, agregando al bus las propiedades de transmisi√≥n de distintos paquetes: <br><br><img src="https://habrastorage.org/webt/ix/wa/rc/ixwarc27-jx3cqndio3gzxaim_g.png"><br><br>  En general, el neum√°tico es muy interesante, y hoy comenzaremos a experimentar con √©l.  Como ya sabemos, el FPGA est√° conectado al bus USB del complejo Redd a trav√©s del puente <b>FT2232H</b> que funciona en modo <b>FT245-SYNC</b> .  Estrictamente hablando, los datos que pasan a trav√©s de esta interfaz est√°n transmitiendo datos por completo.  Hoy aprenderemos c√≥mo transferir estos datos a nuestro sistema de procesador basado en NIOS II.  Es una pena que el protocolo <b>FT245-SYNC</b> , a pesar de la transmisi√≥n, no cumpla totalmente con el bus <b>Avalon-ST</b> .  Para salvar las patas del chip, tiene un bus de datos bidireccional, y el bus <b>Avalon-ST</b> es unidireccional.  Entonces, tenemos que hacer un bloque que coordine los protocolos cercanos pero no coincidentes. <br><br>  Ya nos familiarizamos con el protocolo <b>FT245-SYNC</b> en uno <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de los art√≠culos anteriores</a> .  Perm√≠tame recordarle que su descripci√≥n se puede encontrar en el documento <b>AN_130 FT2232H utilizado en un modo FIFO s√≠ncrono de estilo FT245</b> .  Aqu√≠ hay un diagrama de tiempo t√≠pico de transmisi√≥n desde un puente a un FPGA <br><br><img src="https://habrastorage.org/webt/ea/-y/ly/ea-ylyf7hie2zal-gfjzyp_ehwy.png"><br><br>  En general, como programador, estoy muy interesado en el hecho de que el paquete transmitido habr√≠a marcado claramente el inicio y el final.  Bueno, para que sea m√°s l√≥gico en l√≥gica al protocolo UDP, ya que si la transferencia es en el estilo TCP, tendr√° que agregar datos de referencia especiales a la transmisi√≥n, que se gastar√°n en mi programaci√≥n, esfuerzos y ciclos de procesador ... Parece que la l√≠nea RXF nos puede ayudar con esto.  Verificamos ... Completamos el "firmware" en el FPGA para medir el rendimiento, realizado en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo anterior</a> , y conectamos la sonda del osciloscopio a la l√≠nea RXF.  Como programa de prueba para el procesador central Redd, utilizamos la base, tambi√©n utilizada para medir el rendimiento, en lugar de enviar grandes cantidades de datos, enviamos un bloque monol√≠tico de 0x400 bytes. <br><br><pre><code class="plaintext hljs">uint8_t temp [maxBlockSize]; memset (temp,0,sizeof (temp)); uint32_t dwWritten; FT_Write(ftHandle0, temp, 0x400, &amp;dwWritten);</code> </pre> <br>  Obtenemos la siguiente imagen en la l√≠nea RXF: <br><br><img src="https://habrastorage.org/webt/0-/yc/ic/0-ycici6rpo4urdmg8nlvyuem3w.png"><br><br>  Est√° claro que el microcircuito recibe 0x200 bytes de b√∫fer (es decir, cu√°nto puede venir en un paquete USB2.0 HS), luego los env√≠a al canal.  En general, esto es extra√±o, ya que la documentaci√≥n establece que se usan dos memorias intermedias en cada direcci√≥n.  Durante la transmisi√≥n, el segundo b√∫fer deber√≠a haber tenido tiempo de llenarse.  Por desgracia  El final de su llenado es claramente tarde.  En realidad, esto muestra por qu√© el rendimiento no alcanza los 52 megabytes te√≥ricos por segundo: un gran porcentaje del tiempo (aunque no el 50%) simplemente no se transmite. <br><br>  Pero de una forma u otra, descubrimos que es posible detectar el comienzo de un paquete en un borde RXF negativo solo si el tama√±o del paquete no supera los 0x200 bytes.  Si enviamos solo comandos con una peque√±a cantidad de datos al dispositivo, esto es bastante factible.  Pero si enviamos grandes flujos de datos, tendremos que usar un canal continuo, similar en l√≥gica a UART (o, digamos, al canal TCP), destacando los l√≠mites de los paquetes de manera puramente program√°tica. <br><br>  En general, para simplificar la presentaci√≥n, tomamos como base la versi√≥n de transmisi√≥n.  No consideraremos paquetes hoy.  Bueno, qu√© versi√≥n del autob√∫s <b>Avalon-ST</b> tomamos como base es clara.  Comenzamos a dise√±ar nuestro bloque.  Como se se√±al√≥ anteriormente, tenemos que hacer no solo un puente, sino un interruptor, porque el bus <b>FT245FIFO es</b> bidireccional y el bus <b>Avalon-ST</b> es unidireccional.  Es decir, es necesario hacer dos buses <b>Avalon-ST</b> a la vez: salida y entrada. <br><br><img src="https://habrastorage.org/webt/hr/hl/fm/hrhlfm67sw8-xemukkwo47lg3va.png"><br><br>  Estamos comenzando a desarrollar lentamente un aut√≥mata que implementar√° la l√≥gica que necesitamos.  Por supuesto, en el art√≠culo esta l√≥gica se simplificar√° al m√°ximo.  Comencemos con la transferencia de datos desde el FPGA a la PC, ya que este proceso es un poco m√°s simple (no necesita cambiar el estado de la l√≠nea OE, de la que hablamos en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">√∫ltimo art√≠culo</a> ).  Es decir, estamos implementando el puerto Sink. <br><br>  Del lado del bus <b>Avalon-ST</b> , eleg√≠ el siguiente modo de operaci√≥n (hay muchos de ellos en el documento, pero este es el m√°s cercano a la interfaz con el <b>FT245-SYNC</b> ): <br><br><img src="https://habrastorage.org/webt/f_/rh/nm/f_rhnmctxwtl01xdlaiioun81jk.png"><br><br>  D√©jame recordarte la direcci√≥n de las se√±ales: <br><br><img src="https://habrastorage.org/webt/sd/cc/r-/sdccr--rw2vsk1xitskseckafiq.png"><br><br>  Es decir, solo esperamos la confirmaci√≥n en el bus ( <b>v√°lido</b> ), hacemos clic en los datos y se√±alamos este hecho con la l√≠nea <b>preparada</b> . <br><br>  Desde el lado <b>FT245_FIFO, el</b> protocolo se ve as√≠: <br><br><img src="https://habrastorage.org/webt/d-/nf/ki/d-nfkirvzei94d3kvkhntyea7pi.png"><br><br>  Resulta que debemos esperar la se√±al TXE y bloquear los datos con la se√±al WR # (la polaridad es inversa para ambas se√±ales). <br><br>  TXE # es muy similar en funcionalidad a <b>listo</b> , y WR # es <b>v√°lido</b> .  Los detalles son un poco diferentes, pero la l√≥gica es similar. <br><br>  Resulta que podemos seleccionar un solo estado para PC, en el que se realizar√°n las conmutaciones m√°s simples de algunas l√≠neas.  La condici√≥n para ingresar a este estado ser√° la preparaci√≥n de ambas partes para la transmisi√≥n, es decir (TXE # == 0) Y (v√°lido == 1).  Tan pronto como desaparece parte de la preparaci√≥n, volvemos a estar inactivos. <br><br>  El gr√°fico de transici√≥n del aut√≥mata sigue siendo simple: <br><br><img src="https://habrastorage.org/webt/ci/gb/j9/cigbj9hrioumzbnck6pyeevv1ia.png"><br><br>  Y la tabla de conmutaci√≥n es as√≠ (donde los nombres de las se√±ales son ambiguos, se les agregan √≠ndices, donde los nombres son √∫nicos, no hay √≠ndices): <br><br><div class="scrollable-table"><table><tbody><tr><th>  Se√±al </th><th>  Estado de la PC </th><th>  Otras condiciones </th></tr><tr><td>  WR # </td><td>  NO (v√°lido) </td><td>  1 </td></tr><tr><td>  readySink </td><td>  NO (TXE #) </td><td>  0 0 </td></tr><tr><td>  DATAFT245_FIFO </td><td>  DataSink </td><td>  Z </td></tr></tbody></table></div><br><br>  Pasando a una transferencia un poco m√°s compleja de Source a FT245_FIFO.  Como vimos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el art√≠culo anterior</a> , la complicaci√≥n es cambiar de direcci√≥n con la se√±al OE #: <br><br><img src="https://habrastorage.org/webt/al/xu/1-/alxu1-uqzen0dpj4n8bbgcruyck.png"><br><br>  Para el bus <b>Avalon_ST,</b> todo es igual que antes, por lo que las im√°genes no se muestran por segunda vez, pero ahora estamos en la posici√≥n de origen. <br><br>  Aqu√≠, la l√≠nea RXF # corresponde a la l√≠nea <b>v√°lida</b> , y la l√≠nea RD # corresponde a la l√≠nea <b>preparada</b> .  Bueno, est√° bien, agrega un par de estados a la m√°quina: <br><br><img src="https://habrastorage.org/webt/pu/gs/fm/pugsfmp11c6b79fi8cwfud-wm-q.png"><br><br>  y la siguiente l√≥gica para se√±ales activas en este estado: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Se√±al </th><th>  dropOE </th><th>  desde PC </th><th>  Otras condiciones </th></tr><tr><td>  OE # </td><td>  0 0 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  RD # </td><td>  1 </td><td>  NO (readySource) </td><td>  1 </td></tr><tr><td>  dataSource </td><td>  Cualquier valor </td><td>  DATAFT245_FIFO </td><td>  Cualquier valor </td></tr><tr><td>  fuente v√°lida </td><td>  0 0 </td><td>  NO (RXF #) </td><td>  0 0 </td></tr></tbody></table></div><br>  Est√° claro que el esquema no era el m√°s ideal.  Hay varios matices asociados con desbordamientos o desbordamientos del b√∫fer.  Pero no deber√≠a haber ning√∫n tipo de p√©rdida de datos, pero en cuanto a la optimizaci√≥n, ¬°debes comenzar por alg√∫n lado! <br><br>  Comenzamos a transferir la teor√≠a desarrollada al c√≥digo SystemVerilog.  Es cierto que no podemos usar todas las caracter√≠sticas de SystemVerilog.  Fue el caso, escrib√≠ un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo grande</a> donde prob√© la sintetizaci√≥n pr√°ctica de las hermosas caracter√≠sticas de este lenguaje con un entorno de desarrollo real.  Aqu√≠ solo pedimos el uso de interfaces, porque el sistema tendr√° dos instancias del <b>tipo Avalon-ST</b> .  Ay y ah.  Aqu√≠ est√° el c√≥digo de prueba: <br><pre> <code class="plaintext hljs">interface AvalonST #(parameter width=8)(input clk); logic [width-1:0] data; logic ready; logic valid; modport source (input clk, ready, output data,valid); modport sink (input clk, data, valid, output ready); endinterface module FT245toAvalonST ( AvalonST.source source, AvalonST.sink sink ); //assign source.ready = sink.valid; assign sink.ready = source.valid; endmodule</code> </pre><br>  Est√° perfectamente sintetizado en el compilador principal (una l√≠nea comentada al eliminar un comentario provoca un error para asegurarse de que el sintetizador interprete todo correctamente), pero cuando se marca el bot√≥n <b>Analizar archivos de s√≠ntesis</b> para un componente de este c√≥digo, se <b>genera</b> un error que desconoce el tipo <b>AvalonST</b> .  Es decir, el an√°lisis no est√° en SystemVerilog, sino en Verilog puro.  Que pena. <br><br><img src="https://habrastorage.org/webt/4x/ju/ma/4xjumaitxzkw5tig_pdponziq38.png"><br><br>  Adem√°s, el idioma se determina correctamente, solo el analizador no comprende las interfaces entre los puertos. <br><br><img src="https://habrastorage.org/webt/tp/vm/gn/tpvmgnmidvtcb1e5ngfteokprpi.png"><br><br>  En general, tienes que usar la sintaxis vieja y fea. <br><br><div class="spoiler">  <b class="spoiler_title">Con esta sintaxis obtenemos la siguiente interfaz de m√≥dulo:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data );</code> </pre><br></div></div><br>  Grosero, vintage, pero ¬øqu√© puedes hacer? <br><br><div class="spoiler">  <b class="spoiler_title">Realizamos el gr√°fico de transici√≥n del aut√≥mata sin lujos:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end</code> </pre><br></div></div><br>  El control de las salidas, sin embargo, requiere alguna explicaci√≥n. <br><br><div class="spoiler">  <b class="spoiler_title">Parte de las instalaciones se realiza "en la frente":</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">//    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end</code> </pre><br></div></div><br>  Pero, digamos, para un bus de datos bidireccional, se debe aplicar una soluci√≥n t√≠pica.  Como recordamos, se declara en la parte de la interfaz de la siguiente manera: <br><br><pre> <code class="plaintext hljs"> inout [7:0] ft245_data,</code> </pre><br>  y leerlo se puede hacer de la manera habitual.  Para nuestro caso, simplemente envolvemos todos los datos en los datos del bus <b>Avalon-ST</b> saliente: <br><br><pre> <code class="plaintext hljs">//          assign source_data = ft245_data;</code> </pre><br>  Pero en general, siempre puedes leer desde el autob√∫s y de la manera que quieras.  Pero deber√≠as escribirle usando el multiplexor.  Cuando escribimos datos en el bus, estos datos deben provenir de cualquier otro bus preparado previamente.  Por lo general, en un m√≥dulo se inicia una variable de tipo <b>reg</b> (o <b>l√≥gica</b> nueva).  En nuestro caso, ese autob√∫s ya existe.  Este es el bus <b>sink_data</b> .  En otros casos, se emite el estado Z. Si est√° familiarizado con los circuitos, conoce bien un b√∫fer de salida t√≠pico.  O bien se salta cualquier dato de entrada o pasa al estado Z.  En nuestro c√≥digo, este multiplexor se ve as√≠: <br><br><pre> <code class="plaintext hljs">//      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz;</code> </pre><br>  Y otra se√±al ft245_siwu.  Nunca lo usamos, as√≠ que de acuerdo con la documentaci√≥n en FT2232H, ll√©velo a la unidad: <br><br><pre> <code class="plaintext hljs">//   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1;</code> </pre><br>  En realidad, eso es todo. <br><br><div class="spoiler">  <b class="spoiler_title">Todo el m√≥dulo se ve as√≠:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module FT245toAvalonST ( input clk, input reset, inout [7:0] ft245_data, input logic ft245_rxf, input logic ft245_txe, output logic ft245_rd, output logic ft245_wr, output logic ft245_oe, output logic ft245_siwu, input logic source_ready, output logic source_valid, output logic[7:0] source_data, output logic sink_ready, input logic sink_valid, input logic[7:0] sink_data ); //    enum {idle, toPC, dropOE, fromPC} state = idle; //     always_ff @(posedge clk,posedge reset) begin if (reset == 1) begin state &lt;= idle; end else begin case (state) idle: begin if ((ft245_txe == 0) &amp;&amp; (sink_valid == 1)) state &lt;= toPC; else if ((ft245_rxf == 0)&amp;&amp;(source_ready == 1)) state &lt;= dropOE; end toPC: begin if (!((ft245_txe == 0) &amp;&amp; (sink_valid == 1))) state &lt;= idle; end dropOE: begin state &lt;= fromPC; end fromPC: begin if (!((ft245_rxf == 0)&amp;&amp;(source_ready == 1))) state &lt;= idle; end endcase end end //    //   ,        , //  -    . always_comb begin ft245_oe &lt;= 1; ft245_rd &lt;= 1; ft245_wr &lt;= 1; source_valid &lt;= 0; sink_ready &lt;= 0; //     , //     assign- case (state) idle: begin end toPC: begin ft245_wr &lt;= !(sink_valid); sink_ready &lt;= !(ft245_txe); end dropOE: begin ft245_oe &lt;= 0; end fromPC: begin ft245_oe &lt;= 0; ft245_rd &lt;= !(source_ready); source_valid &lt;= !(ft245_rxf); end endcase end // -  c  ,   ... //   FTDI : // Tie this pin to VCCIO if not used. assign ft245_siwu = 1; //      inout- assign ft245_data = (state == toPC) ? sink_data : 8'hzz; //          assign source_data = ft245_data; endmodule</code> </pre><br></div></div><br>  C√≥mo incluir el m√≥dulo en la lista de disponibles para usar en el sistema del procesador, lo examinamos en detalle en uno de los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos anteriores</a> , as√≠ que solo muestro el resultado en la figura.  Recuerdo que para lograrlo tuve que agregar dos buses <b>AVALON-ST</b> , un bus <b>Conduit</b> , extraer se√±ales de un bus <b>AVALON-MM</b> err√≥neamente definido, y cuando no quede una sola se√±al en ese bus, simplemente elim√≠nelo.  En el camino, la figura muestra la configuraci√≥n que seleccion√© para los buses <b>AVALON-ST</b> (8 bits por s√≠mbolo, sin errores, el canal m√°ximo es cero, la latencia es cero). <br><br><img src="https://habrastorage.org/webt/-v/9t/ml/-v9tmldj2eyv4rsv8lb3reokzoa.png"><br><br>  Con el desarrollo de un m√≥dulo para atracar neum√°ticos, eso es todo.  Pero por desgracia, ah.  Desarrollar es solo el comienzo del trabajo.  La implementaci√≥n es mucho m√°s dif√≠cil.  Como se puede ver desde la posici√≥n del desplazador en la pantalla, el final del art√≠culo a√∫n est√° lejos.  Entonces, estamos comenzando a crear un proyecto simple que utiliza la <b>uni√≥n de</b> bus <b>FT245-SYNC</b> con los buses <b>AVALON-ST</b> .  Es lo mas simple.  Un proyecto serio no encaja en el marco de un solo art√≠culo de un tama√±o razonable.  Ahora har√© una simplificaci√≥n tras simplificaci√≥n simplemente para que la atenci√≥n de los lectores sea suficiente para el resto del texto y que no dejen de leer en una palabra.  La primera simplificaci√≥n es que los <b>relojes</b> de 60 MHz para el <b>FT245_SYNC son</b> generados por el chip <b>FT2232H</b> .  Podr√≠a agregar dos l√≠neas de reloj al sistema, pero tan pronto como todos lo vean, tendremos tales telara√±as de cables que mi madre no llorar√°.  Si sigo prestando atenci√≥n a las diferentes l√≠neas de reloj, todos nos confundiremos.  Por lo tanto, simplemente anuncio que hoy nuestro sistema de procesador <b>registrar√°</b> desde el chip <b>FT2232H</b> y no desde un generador normal. <br><br>  ¬øPor qu√© no siempre puedes hacer eso?  Muy simple: siempre que el <b>FT2232H</b> no <b>est√©</b> en modo 245_SYNC, no tiene estos pulsos en la salida.  Es decir, primero debe ejecutar el programa para el procesador central, y solo luego cargar todo en el FPGA.  Si cre√°ramos un sistema para un cliente externo, tal soluci√≥n crear√≠a muchos problemas.  S√© por experiencia que nos llamaban regularmente y dec√≠an que nada funciona, que recordamos los bares, pero eso ayudar√≠a por un tiempo.  Pero estamos haciendo algo interno, y lo usaremos solo en condiciones de laboratorio.  Es decir, dentro del marco de esta tarea, esto es permisible. <br><br>  Pero esto trae nuevos desaf√≠os.  Tenemos una frecuencia de 60 MHz, y el bloque de reloj SDRAM que estamos usando actualmente est√° estrechamente vinculado a una frecuencia de 50 MHz.  S√≠, verifiqu√©, se pueden enviar 60, pero supongamos que intentamos no ir m√°s all√° de los modos permitidos.  En art√≠culos posteriores intentar√© mostrar c√≥mo reemplazar este bloque duro, pero hoy solo decimos que, dado que nuestra unidad de reloj de SDRAM no puede funcionar en la frecuencia utilizada, la excluimos del sistema de procesador SDRAM.  El programa y sus datos se ubicar√°n completamente en la memoria interna de la FPGA.  Se descubri√≥ experimentalmente que en la configuraci√≥n actual, los FPGA pueden ocupar un m√°ximo de 28 kilobytes de RAM para este negocio.  Resulta que puedes tomar vol√∫menes y no m√∫ltiples poderes de dos ... <br><br>  Adem√°s, utilizaremos el reloj est√°ndar y la unidad de reinicio.  Se restablece un poco diferente al que usamos para SDRAM.  Para no complicar el art√≠culo, aprovechar√© el hecho de que el sistema en desarrollo siempre funcionar√° bajo el control de un depurador, por lo que comenzar√© a restablecer el subsistema JTAG para la depuraci√≥n. <br><br>  En total, obtenemos un esquema del sistema de procesador base (la l√≠nea de reinicio m√°s dif√≠cil se resalta en este momento, el marcador azul est√° en la fuente de se√±al): <br><br><img src="https://habrastorage.org/webt/zx/ug/nk/zxugnk3v9rhownqtdorprzuvqc8.png"><br><br>  donde la frecuencia se ha ajustado para el reloj y el bloque de reinicio: <br><br><img src="https://habrastorage.org/webt/dj/hq/ap/djhqapk0jpgumyp0qrp34ucszhw.png"><br><br>  y para RAM - el volumen: <br><br><img src="https://habrastorage.org/webt/pm/k2/vn/pmk2vngq6jhbl3yhydiarxcsm2i.png"><br><br>  Hoy necesitamos mostrar el texto en la terminal.  Por lo tanto, agregaremos un bloque tan interesante al sistema: <br><br><img src="https://habrastorage.org/webt/9q/nx/r-/9qnxr-5owicrjxhlqmkeckfxxn8.png"><br><br>  Con este bloque, podremos llamar a funciones similares a printf.  Adem√°s del bus AVALON_MM, tambi√©n debe conectar la salida de solicitud de interrupci√≥n. <br><br><img src="https://habrastorage.org/webt/gp/h6/rg/gph6rg59lvarzmtdeaq9wvsiohu.png"><br><br>  Eso es todo, la adquisici√≥n del sistema del procesador se ha completado.  Es hora de incrustar nuestra unidad.  ¬øA d√≥nde enviar√° los datos?  Entre los bloques disponibles para nosotros, hay una memoria FIFO de dos puertos muy interesante.  Su encanto radica en el hecho de que un puerto se puede configurar en modo <b>AVALON-ST</b> y conectarlo a nuestra unidad, y el segundo en modo <b>AVALON_MM</b> y trabajar con √©l utilizando el procesador NIOS II.  Este maravilloso bloque se encuentra aqu√≠: <br><br><img src="https://habrastorage.org/webt/fe/9o/ur/fe9ourutodpbj31wm9av_-pkfc4.png"><br><br>  Tenemos dos <b>buses Avalon-ST</b> (uno para leer, el otro para escribir), por lo que tambi√©n necesitamos dos bloques FIFO.  Ahora analizar√© uno de ellos con gran detalle, enrollamos un par de kil√≥metros de web (y un mont√≥n de pantallas de texto con im√°genes), y alrededor del segundo decimos que "se puede hacer por analog√≠a", indicando solo diferencias.  Por lo tanto, por ahora, agregamos solo un bloque al sistema y observamos su configuraci√≥n.  Hay muchas configuraciones.  Ser√≠a posible simplemente indicar los valores requeridos para que todos se refieran al art√≠culo como referencia, pero de repente alguien entra en una situaci√≥n que necesita ser configurada, pero no hay acceso a la red (y, por lo tanto, al art√≠culo).  Por lo tanto, agregar√© configuraciones de forma iterativa.  Primero obvio, luego, seg√∫n lo exija el sistema, ejecute el di√°logo una y otra vez.  Entonces todos sentir√°n el proceso y podr√°n repetirlo en cualquier momento.  Entonces  Por defecto, nos dieron la siguiente configuraci√≥n: <br><br><img src="https://habrastorage.org/webt/yl/bt/14/ylbt14u32cw8xeqherwazdx8nx4.png"><br><br>  Ahora har√© FIFO, que recopila datos de <b>Avalon-ST</b> y los carga en <b>Avalon-MM</b> .  Resulta que la primera edici√≥n ser√° as√≠: <br><br><img src="https://habrastorage.org/webt/1w/m0/xx/1wm0xx_bdp9gjk9nqmb6sooxop0.png"><br><br>  Recib√≠ esta interesante advertencia: <br><br><img src="https://habrastorage.org/webt/1u/a8/qs/1ua8qsawychkqv0nxjg_l5u3f4q.png"><br><br>  Resulta que cuando al menos uno de los puertos se proyecta en la memoria, el ancho del bus <b>Avalon-ST</b> debe ser estrictamente de 32 bits.  Y tenemos un bus de 8 bits.  C√≥mo acordar las profundidades de bits, te dir√© un poco m√°s abajo, pero por ahora estamos haciendo un bus de 32 bits con un car√°cter de ocho bits aqu√≠.  Bueno, deshabilite el modo por lotes, como se decidi√≥ en la parte te√≥rica. <br><br><img src="https://habrastorage.org/webt/oi/jh/k0/oijhk02tjofxdavtznc1m1es8w4.png"><br><br>  Lo siguiente es la capacidad.  Supongamos que pongo en cola 256 palabras (es decir, 1024 bytes): <br><br><img src="https://habrastorage.org/webt/s4/ca/vl/s4cavlmtxomzl0gsc2dfwn2ovmg.png"><br><br>  Ahora el estado.  Al principio, no le di ninguna importancia, y el programa se congel√≥ fuertemente.  Entonces ahora s√© que se necesita el estado.  Dado que trabajaremos con el puerto de salida mediante programaci√≥n, agregaremos el estado correspondiente. <br><br><img src="https://habrastorage.org/webt/0_/hc/hp/0_hchpmkhfrlg8pg3tjaqg3vpsi.png"><br><br>  y capta el error: <br><br><img src="https://habrastorage.org/webt/xk/e7/lg/xke7lgan6dpoohxssnvglenuhog.png"><br><br>  Pues bien.  A√±adir doble reloj.  Simplemente conecte ambas entradas a la misma l√≠nea de reloj, ya que tenemos una. <br>  Uhhhh  Total tenemos: <br><br><img src="https://habrastorage.org/webt/iv/nv/pv/ivnvpvdfov3zeo6owfevsdhrq6k.png"><br><br>  Pero es demasiado pronto para conectar este negocio al sistema com√∫n.  Como descubrimos, el bus <b>Avalon-ST de</b> 8 bits deja el bloque que desarrollamos, y esto deber√≠a incluir el de 32 bits.  Como seamos  Remodelar su bloque?  No!  Todo se ha hecho antes que nosotros.  Esto es lo que nos ayudar√°: <br><br><img src="https://habrastorage.org/webt/3g/2j/q7/3g2jq74qwjbcgmnvhdchryqi9xm.png"><br><br>  Agr√©guelo al sistema.  Adem√°s, dado que es una capa, puramente por belleza, la colocamos entre nuestro bloque y FIFO, usando la flecha correspondiente: <br><br><img src="https://habrastorage.org/webt/lt/pd/9q/ltpd9qytvl60ez2znbxu1qsudyq.png"><br><br>  Hacemos los siguientes ajustes: en la entrada tenemos un bus de 8 bits, en la salida de 32 bits.  Las se√±ales de paquete no se usan, se usan se√±ales <b>listas</b> y <b>v√°lidas</b> . <br><br><img src="https://habrastorage.org/webt/bo/-e/h1/bo-eh154mbqqyr0owj9vn96his8.png"><br><br>  Es hora de tejer una red.  Primero, colocar√© las l√≠neas de transmisi√≥n (en la figura, ambas est√°n resaltadas, los marcadores est√°n en los receptores de datos): <br><br><img src="https://habrastorage.org/webt/br/xu/uj/brxuujnbnsiazm3pxfnnr3tb-cc.png"><br><br>  Es decir, la se√±al de la Fuente de nuestro bloque va a la entrada del adaptador.  Y desde la salida del adaptador hasta la entrada FIFO.  Como dije, todas las conexiones en el protocolo de transmisi√≥n se realizan punto a punto. <br>  Bueno, ahora colgamos las l√≠neas de reinicio, las l√≠neas del reloj, y tambi√©n conectamos todo al bus del sistema y a las interrupciones ... <br><br><img src="https://habrastorage.org/webt/dc/tj/1g/dctj1gqgwbbs7-pcdf4urfbhvsy.png"><br><br>  Bueno ... Y ahora, por el mismo principio, agregamos FIFO para emitir datos al <b>FT245SYNC</b> .  Solo all√≠, los datos ingresan al FIFO desde <b>Avalon-MM</b> en forma de 32 bits.  Pasan a trav√©s de un adaptador 32 en 8 y luego llegan a la entrada SINK de nuestro bloque, que no est√° conectado en el circuito actual ... Obtenemos el siguiente fragmento del circuito final (la memoria all√≠ result√≥ con un solo reloj): <br><br><img src="https://habrastorage.org/webt/eg/e5/kc/ege5kckjc4x5vwtsfaxmlp32rqo.png"><br><br>  Otros tr√°mites que ya hemos resuelto bien en los experimentos descritos en art√≠culos anteriores ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en su mayor parte, en este</a> ).  Asignamos vectores al procesador.  Para el sistema, llamamos a la asignaci√≥n autom√°tica de n√∫meros de interrupci√≥n y direcciones.  Guardamos el sistema ... ¬øTodos recuerdan que el nombre del sistema guardado debe coincidir con el nombre del proyecto para que el sistema est√© en el nivel superior de la jerarqu√≠a?  Agregue el sistema al proyecto, haga un borrador del proyecto, asigne piernas.  Personalmente, hice trampa: copi√© las asignaciones del archivo * .qsf del borrador del proyecto al final actual (y puede tomar mi proyecto y copiar las l√≠neas * .qsf correspondientes a las suyas, pero simplemente puede asignar todas las patas a trav√©s de la GUI).  Presto especial atenci√≥n al hecho de que la se√±al clk est√° conectada al tramo 23, no al 25, como en proyectos anteriores.  Les recuerdo que aqu√≠ estamos haciendo tictac desde la salida FT2232. <br><br><img src="https://habrastorage.org/webt/9z/bx/sb/9zbxsbgsn4m_9wewmjestkse0fi.png"><br><br>  Genial  El hardware est√° listo.  Pasamos al software.  Por donde empezamos  Hoy esta pregunta no vale la pena.  Si comenzamos con un programa que se ejecuta en el procesador NIOS II, nada funcionar√° para nosotros.  Primero, debemos poner el FT2232 en modo 245-SYNC, solo entonces nuestro sistema de procesador recibir√° pulsos de reloj.  Por lo tanto, comenzamos con el c√≥digo para el procesador central. <br><br><div class="spoiler">  <b class="spoiler_title">Obtenemos algo como esto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#include &lt;cstdio&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include "ftd2xx.h" FT_HANDLE OpenFT2232H() { FT_HANDLE ftHandle0; static FT_DEVICE ftDevice; //      int nDevice = 0; while (true) { //     if (FT_Open(nDevice, &amp;ftHandle0) != FT_OK) { printf("No FT2232 found\n"); //  ,      return 0; } //     ? if (FT_GetDeviceInfo(ftHandle0, &amp;ftDevice, NULL, NULL, NULL, NULL) == FT_OK) { // ,    if (ftDevice == FT_DEVICE_2232H) { // ,     AN130 FT_SetBitMode(ftHandle0, 0xff, 0x00); usleep(1000000); //Sync FIFO mode FT_SetBitMode(ftHandle0, 0xff, 0x40); FT_SetLatencyTimer(ftHandle0, 2); FT_SetUSBParameters(ftHandle0, 0x10000, 0x10000); return ftHandle0; } } //    FT_Close(ftHandle0); //    nDevice += 1; } printf("No FT2232 found\n"); } int main() { FT_HANDLE ftHandle0 = OpenFT2232H(); if (ftHandle0 == 0) { printf("Cannot open device\n"); return -1; } int item; bool bWork = true; while (bWork) { printf("1 - Send 16 bytes\n"); printf("2 - Send 256 bytes\n"); printf("3 - Receive loop\n"); printf("0 - Exit\n"); scanf("%d", &amp;item); switch (item) { case 0: bWork = false; break; case 1: { static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f }; DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 2: { unsigned char data[0x100]; for (size_t i = 0; i &lt; sizeof(data); i++) { data[i] = (unsigned char)i; } DWORD dwWritten; FT_Write(ftHandle0, (void*)data, sizeof(data), &amp;dwWritten); } break; case 3: { DWORD dwRxBytes; DWORD dwRead; DWORD buf[0x100]; while (true) { FT_GetQueueStatus(ftHandle0, &amp;dwRxBytes); if (dwRxBytes != 0) { printf("Received %d bytes (%d DWORDs)\n", dwRxBytes, dwRxBytes / sizeof(buf[0])); if (dwRxBytes &gt; sizeof(buf)) { dwRxBytes = sizeof(buf); } FT_Read(ftHandle0, buf, dwRxBytes, &amp;dwRead); for (DWORD i = 0; i &lt; dwRxBytes / sizeof(buf[0]);i++) { printf("0x%X, ",buf[i]); } printf("\n"); } } } break; } } // ,    FT_Close(ftHandle0); return 0; }</code> </pre><br></div></div><br>  <b>OpenFT2232H()</b>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> .     FT2232       .         ,          NIOS II. ,     ,  .    (1),    (2),   (3).     ,     ,   .   ,      8--32.         .   ‚Äî  . <br><br>     NIOS II      BSP. ,        Hello World Small.    BSP       (        BSP,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a> ). ,     ,  ,  Settings,       . <br><br><img src="https://habrastorage.org/webt/lc/mg/jh/lcmgjhu3udg8njitretcj5wp4vm.png"><br><br>  Generate BSP ,    ,     <b>hello_world_small.c</b>  <b>hello_world_small.cpp</b> ,     ,         . <br><br>        (         ,   FIFO,    ‚Äî   ,    ,        ).         .   ‚Äî        NIOS II.      : <br><br><pre> <code class="plaintext hljs">extern "C" { #include "sys/alt_stdio.h" #include &lt;system.h&gt; #include &lt;altera_avalon_fifo_util.h&gt; } #include &lt;stdint.h&gt; int main() { while (1) { int level = IORD_ALTERA_AVALON_FIFO_LEVEL(FIFO_0_OUT_CSR_BASE); if (level != 0) { alt_printf("0x%x words received:\n",level); for (int i=0;i&lt;level;i++) { alt_printf("0x%x,",IORD_ALTERA_AVALON_FIFO_DATA (FIFO_0_OUT_BASE)); } alt_printf("\n"); } } /* Event loop never exits. */ while (1); return 0; }</code> </pre><br>       FIFO.    ,  . <br>   .    ,    .    Redd   ¬´¬ª ,        NIOS II.   : <br><br><img src="https://habrastorage.org/webt/88/1c/xk/881cxkj95xirw_0rdrrhyaf0ffm.png"><br><br>      ,        .    ,    .   ,     ,      .        FT2232,      ,       .            .      :      <b>FT245-SYNC</b> . <br><br>       1.    ,    : <br><br> <b>0x2 words received: <br> 0x3020100,0x7060504, <br> 0x2 words received: <br> 0xb0a0908,0xf0e0d0c,</b> <br><br> : <br><br> <b>0x3 words received: <br> 0x3020100,0x7060504,0xb0a0908, <br> 0x1 words received: <br> 0xf0e0d0c,</b> <br><br>  ,    1,  3  ,      .    ,      ,      .     ,          ,      JTAG ‚Äî   .       ,          .   ,   (  ,   ?    ),    (FIFO ‚Äî   ,         ,         ). <br><br>         Little Endian. ,    : <br><br><pre> <code class="plaintext hljs">static const unsigned char data[0x10] = { 0x00,0x01,0x02,0x03, 0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f };</code> </pre><br>  Eso es correcto         2,    (  ,     ): <br><br><pre> <code class="plaintext hljs">0x3 words received: 0x3020100,0x7060504,0xb0a0908, 0x3d words received: 0xf0e0d0c, 0x13121110,0x17161514,0x1b1a1918,0x1f1e1d1c, 0x23222120,0x27262524,0x2b2a2928,0x2f2e2d2c, 0x33323130,0x37363534,0x3b3a3938,0x3f3e3d3c, 0x43424140,0x47464544,0x4b4a4948,0x4f4e4d4c, 0x53525150,0x57565554,0x5b5a5958,0x5f5e5d5c, 0x63626160,0x67666564,0x6b6a6968,0x6f6e6d6c, 0x73727170,0x77767574,0x7b7a7978,0x7f7e7d7c, 0x83828180,0x87868584,0x8b8a8988,0x8f8e8d8c, 0x93929190,0x97969594,0x9b9a9998,0x9f9e9d9c, 0xa3a2a1a0,0xa7a6a5a4,0xabaaa9a8,0xafaeadac, 0xb3b2b1b0,0xb7b6b5b4,0xbbbab9b8,0xbfbebdbc, 0xc3c2c1c0,0xc7c6c5c4,0xcbcac9c8,0xcfcecdcc, 0xd3d2d1d0,0xd7d6d5d4,0xdbdad9d8,0xdfdedddc, 0xe3e2e1e0,0xe7e6e5e4,0xebeae9e8,0xefeeedec, 0xf3f2f1f0,0xf7f6f5f4,0xfbfaf9f8,0xfffefdfc,</code> </pre><br>   .     .    NIOS II  : <br><br><pre> <code class="plaintext hljs"> /*  -  2 */ uint32_t buf[] = {0x11223344,0x55667788,0x99aabbcc,0xddeeff00}; for (uint32_t i=0;i&lt;sizeof(buf)/sizeof(buf[0]);i++) { IOWR_ALTERA_AVALON_FIFO_DATA (FIFO_1_IN_BASE,buf[i]); }</code> </pre><br>        3       NIOS II. : <br><br> <b>Received 16 bytes (4 DWORDs) <br><br> 0x11223344, 0x55667788, 0x99AABBCC, 0xDDEEFF00,</b> <br><br>    .    -   . <br><br><h3>  Conclusi√≥n </h3><br>        <b>Avalon-ST</b> .        Redd   ,   .           .        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>           .     ,          ,    Redd. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462253/">https://habr.com/ru/post/462253/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462221/index.html">Qu√© decepcionado estoy en Google Play</a></li>
<li><a href="../462227/index.html">Mosc√∫, 9 de agosto - Backend Stories 4.0</a></li>
<li><a href="../462243/index.html">Mejora del rendimiento front-end de Magento con ReactJS</a></li>
<li><a href="../462245/index.html">auto git bisect como un ejemplo del kernel de Linux</a></li>
<li><a href="../462251/index.html">¬øEs el modo inc√≥gnito en el navegador una ficci√≥n?</a></li>
<li><a href="../462257/index.html">Kafka en Kubernetes, ¬øest√° bien?</a></li>
<li><a href="../462259/index.html">Hacer un controlador para una casa inteligente</a></li>
<li><a href="../462263/index.html">Pedal to the floor: crea otro manipulador de pies para PC</a></li>
<li><a href="../462265/index.html">Python y cubos</a></li>
<li><a href="../462267/index.html">Conozca el analizador est√°tico PVS-Studio para Java</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>