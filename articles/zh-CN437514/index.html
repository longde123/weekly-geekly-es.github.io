<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽 🤛🏾 ✊🏼 在.NET的Amazon Web Services SDK源代码中搜索错误 🎛️ 👊🏿 🚼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="欢迎所有破坏别人代码的粉丝。 :)今天，在我们的实验室中，我们有了一种新的研究材料-适用于.NET项目的AWS开发工具包的源代码。 当时，我们写了一篇有关检查适用于C ++的AWS开发工具包的文章。 然后没有什么特别有趣的。 让我们看看AWS SDK版本的.NET值得什么。 再次，这是一个绝佳的机会...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在.NET的Amazon Web Services SDK源代码中搜索错误</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/437514/"><p><img src="https://habrastorage.org/getpro/habr/post_images/188/292/f27/188292f271dd0648b09f848dbe66efa6.png" alt="图片1"></p><br> 欢迎所有破坏别人代码的粉丝。  :)今天，在我们的实验室中，我们有了一种新的研究材料-适用于.NET项目的AWS开发工具包的源代码。 当时，我们写了一篇有关检查适用于C ++的AWS开发工具包的文章。 然后没有什么特别有趣的。 让我们看看AWS SDK版本的.NET值得什么。 再次，这是一个绝佳的机会来展示PVS-Studio分析仪的功能，并使世界变得更好。 <br><a name="habracut"></a><br> 适用于.NET的Amazon Web Services（AWS）SDK是一组开发人员工具，用于在AWS基础设施中基于.NET创建应用程序。 该集合可以显着简化代码编写过程。 该SDK包括针对各种AWS服务（例如Amazon S3，Amazon EC2，DynamoDB等）的API .NET集。  SDK源代码可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GitHub上获得</a> 。 <br><br> 正如我提到的，当时我们已经撰写了有关检查适用于C ++的AWS开发工具包的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文章</a> 。 这篇文章很小，每512万行代码中只发现了几个错误。 这次，我们正在处理更大的代码，其中包括约3.4万个cs文件，并且代码行的总数（不包括空白行）令人印象深刻的500万。 一小部分代码（664-cs文件中的20万行）属于测试，我没有考虑它们。 <br><br> 如果SDK版本的.NET代码的质量与C ++的质量大致相同（每512 KLOC出现两个错误），那么我们应该得到的错误数量大约是原来的10倍。 当然，这是一种非常不准确的计算方法，它没有考虑到语言的特殊性和许多其他因素，但是我认为读者现在不想陷入无聊的推理之中。 相反，我建议继续研究结果。 <br><br> 使用PVS-Studio 6.27进行检查。 真是不可思议，但事实仍然是，在适用于.NET的AWS开发工具包中，分析器设法检测到40个错误，这值得一谈。 它不仅演示了高质量的SDK代码（每512 KLOC大约有4个错误），而且还演示了与C ++相比，C＃PVS-Studio分析仪的质量。 很好的结果！ <br><br> 适用于.NET的AWS开发工具包的作者，您真是冠军！ 在每个项目中，您都将展示出色的代码质量。 对于其他团队来说，这可能是一个很好的例子。 但是，如果我不给我2美分，我当然不会成为静态分析仪的开发商。  :)我们已经与Amazon的Lumberyard团队合作使用PVS-Studio。 由于它是一家非常庞大的公司，在全球拥有许多分支机构，因此.NET的AWS开发工具包团队很可能从未听说过PVS-Studio。 无论如何，我没有发现在SDK代码中使用分析器的任何迹象，尽管它没有说明任何问题。 但是，至少，团队<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用</a> Visual Studio中内置的分析器。 很棒，但是代码评论总是可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">增强的</a> :)。 <br><br> 结果，我确实设法在SDK代码中发现了一些错误，最后是时候分享它们了。 <br><br>  <b>逻辑错误</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3008</a> [CWE-563]连续两次为变量“ this.linker.s3.region”分配值。 也许这是一个错误。 检查行：116，114。AWSSDK.DynamoDBv2.Net45 S3Link.cs 116 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br> 分析仪会警告您将重复的值分配给同一变量。 从代码中可以清楚地看出，这是由于违反程序工作逻辑的错误引起的：无论条件如何，变量<i>this.linker.s3.region</i>的值将始终等于变量<i>value的值</i> 。 <i>如果（String.IsNullOrEmpty（value））</i> 。  <i>if</i>块的正文中缺少<i>return</i>语句。 该代码需要固定如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  <b>无限递归</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3110</a> [CWE-674]'OnFailure'属性内可能无限递归。  AWSSDK.ElasticMapReduce.Net45 ResizeJobFlowStep.cs 171 <br><br><pre> <code class="cpp hljs">OnFailure? onFailure = null; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnFailure; } <span class="hljs-comment"><span class="hljs-comment">// &lt;= set { this.onFailure = value; } }</span></span></code> </pre> <br> 错字的经典示例，它导致<i>OnFailure</i>属性的<i>get</i>访问器中的无限递归。 代替返回私有字段<i>onFailure</i>的值，而是访问属性<i>OnFailure</i> 。 正确的变体： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure = value; } }</code> </pre> <br> 您可能会问：“它是如何工作的？” 到目前为止-没有如何。 该属性未在其他任何地方使用，但这是临时的。 某个时候，有人会开始使用它，并且肯定会收到意想不到的结果。 为了防止出现此类错别字，建议不要使用仅在首字母不同的情况下使用的标识符。 <br><br> 此构造的另一个注释是使用标识符，该标识符与<i>OnFailure</i>类型的名称完全匹配。 从编译器的角度来看，这是完全可以接受的，但是这会使人对代码的理解变得复杂。 <br><br> 另一个类似的错误： <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3110</a> [CWE-674]'SSES3'属性内可能存在无限递归。  AWSSDK.S3.Net45 InventoryEncryption.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SSES3 sSES3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3 = value; } }</code> </pre> <br> 情况与上述相同。 但是，在同时访问属性<i>SSES3</i>进行读取和分配时，将发生无限递归。 正确的变体： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3 = value; } }</code> </pre> <br>  <b>考虑考虑</b> <br><br> 现在，我想引用一个使用复制粘贴方法执行的开发人员的任务。 查看代码在Visual Studio编辑器中的外观，然后尝试查找错误。 <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfa/71b/1ab/bfa71b1ab4af941c43e5349df51b1614.png" alt="图片3"></p><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3029</a>彼此并排的'if'语句的条件表达式相同。 检查行：91，95。AWSSDK.AppSync.Net45 CreateApiKeyResponseUnmarshaller.cs 91 <br><br> 我减少了方法<i>UnmarshallException</i>的主体，删除了不需要的所有内容。 现在您可以看到相同的检查相互遵循： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AmazonServiceException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmarshallException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } .... }</code> </pre> <br> 该错误似乎并不严重-只是一个额外的检查。 但是，当不执行所需的检查时，这种模式通常可能表示代码中存在更严重的问题。 <br><br> 在代码中，有几个类似的错误。 <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：75、79。AWSSDK.CloudDirectory.Net45 CreateSchemaResponseUnmarshaller.cs 75 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：105、109。AWSSDK.CloudDirectory.Net45 GetSchemaAsJsonResponseUnmarshaller.cs 105 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：201、205。AWSSDK.CodeCommit.Net45 PostCommentForPullRequestResponseUnmarshaller.cs 201 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：101，105。AWSSDK.CognitoIdentityProvider.Net45 VerifySoftwareTokenResponseUnmarshaller.cs 101 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：72，76。AWSSDK.Glue.Net45 UpdateConnectionResponseUnmarshaller.cs 72 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：123、127。AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 123 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：167、171。AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 167 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：127，131。AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 127 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：171、175。AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 171 </li><li>  V3029彼此并排放置的'if'语句的条件表达式相同。 检查行：99、103。AWSSDK.Rekognition.Net45 RecognizeCelebritiesResponseUnmarshaller.cs 99 </li></ul><br>  <b>怎么了</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3062</a>对象“ attributeName”用作其自身方法的参数。 考虑检查“包含”方法的第一个实际参数。  AWSSDK.MobileAnalytics.Net45 CustomEvent.cs 261 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Dictionary that stores attribute for this event only. /// &lt;/summary&gt; private Dictionary&lt;string,string&gt; _attributes = new Dictionary&lt;string,string&gt;(); /// &lt;summary&gt; /// Gets the attribute. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;The attribute. Return null of attribute doesn't /// exist.&lt;/returns&gt; public string GetAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } string ret = null; lock(_lock) { if(attributeName.Contains(attributeName)) // &lt;= ret = _attributes[attributeName]; } return ret; }</span></span></code> </pre> <br> 分析器在<i>GetAttribute</i>方法中检测到错误：检查字符串是否包含自身。 从方法的描述可以得出以下结论：如果找到了属性名称（ <i>attributeName</i>键）（在字典<i>_attributes中</i> ），则应返回属性值，否则返回<i>-null</i> 。 实际上，由于条件<i>attributeName.Contains（attributeName）</i>始终为true，因此尝试通过可能在字典中找不到的键返回值。 然后，将引发<i>KeyNotFoundException</i>异常，而不是返回<i>null</i> 。 <br><br> 让我们尝试修复此代码。 为了更好地了解如何执行此操作，应查看另一种方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Determines whether this instance has attribute the specified /// attributeName. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;Return true if the event has the attribute, else /// false.&lt;/returns&gt; public bool HasAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } bool ret = false; lock(_lock) { ret = _attributes.ContainsKey(attributeName); } return ret; }</span></span></code> </pre> <br> 此方法检查字典<i>_attributes中</i>是否存在属性名称（ <i>attributeName</i>键）。 让我们再次回到<i>GetAttribute</i>方法并修复错误： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attributeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(attributeName)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"attributeName"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret = null; lock(_lock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_attributes.ContainsKey(attributeName)) ret = _attributes[attributeName]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br> 现在，该方法完全可以执行描述中所述的操作。 <br><br> 此代码段还有一个小注释。 我注意到作者在使用<i>_attributes</i>字典时使用<i>锁</i> 。 显然，在具有多线程访问时，这是必需的，但<i>锁的</i>构造相当缓慢且麻烦。 在这种情况下，使用字典的线程安全版本<i>-ConcurrentDictionary</i>可能会比使用<i>Dictionary</i>更方便。 这样，就无需<i>锁定。</i> 虽然，也许我不了解该项目的细节。 <br><br>  <b>可疑行为</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3063</a> [CWE-571]如果对条件表达式进行评估，则该条件表达式的一部分始终为true：string.IsNullOrEmpty（inferredIndexName）。  AWSSDK.DynamoDBv2.PCL ContextInternal.cs 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryIndexName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> inferredIndexName = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= indexNames.Count &gt; 0) throw new InvalidOperationException("Local Secondary Index range key conditions are used but no index could be inferred from model. Specified index name = " + specifiedIndexName); .... }</span></span></code> </pre> <br> 分析器担心检查<i>字符串.IsNullOrEmpty（inferredIndexName）</i> 。 确实，为字符串<i>inferredIndexName</i>分配了<i>null</i> ，然后此变量的值未在任何地方更改，然后由于某种原因检查了<i>null</i>还是空字符串。 看起来可疑。 让我们仔细看一下上面的代码片段。 我故意没有减少它以更好地了解情况。 因此，在第一个<i>if</i>语句中（以及在下一个<i>if</i>语句中）将以某种方式检查<i>指定</i>的变量indexIndexName。 根据检查结果，变量<i>inferredIndexName</i>将获得新值。 现在让我们看一下第三条<i>if</i>语句。 如果<i>indexNames.Count&gt; 0（</i>作为整个条件的第一部分<i>）</i>为<i>string.IsNullOrEmpty（inferredIndexName）</i>始终为true，则将执行此语句的主体（ <i>引发</i>异常）。 也许， <i>指定的</i>变量<i>IndexName</i>和<i>inferredIndexName</i>混合在一起，或者第三次检查必须没有<i>else</i> ，代表一个独立的<i>if</i>语句： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; indexNames.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(....);</code> </pre> <br> 在这种情况下，很难给出修复此代码的选项的明确答案。 无论如何，作者需要检查一下。 <br><br>  <b>NullReferenceException</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3095</a> [CWE-476]在对空值进行验证之前使用了“ conditionValues”对象。 检查行：228、238。AWSSDK.Core.Net45 JsonPolicyWriter.cs 228 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; .... if (conditionValues != null &amp;&amp; conditionValues.Count != 0) { .... } .... } }</span></span></code> </pre> <br> 这是经典。 使用变量<i>conditionValues时</i>无需预先检查<i>null</i> 。 稍后在代码中执行此检查。 该代码需要按以下方式更正： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... } }</code> </pre> <br> 我在代码中发现了几个类似的错误。 <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3095 [CWE-476]在验证是否为null之前使用了“ ts.Listeners”对象。 检查行：140，143。AWSSDK.Core.Net45 Logger.Diagnostic.cs 140 </li><li>  V3095 [CWE-476]在验证是否为null之前，已使用'obj'对象。 检查行：743、745。AWSSDK.Core.Net45 JsonMapper.cs 743 </li><li>  V3095 [CWE-476]在对null进行验证之前，已使用'multipartUploadMultipartUploadpartsList'对象。 检查行：65，67。AWSSDK.S3.Net45 CompleteMultipartUploadRequestMarshaller.cs 65 </li></ul><br> 以下警告在含义上非常相似，但情况与上述警告相反。 <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3125</a> [CWE-476]在验证为空后使用了“状态”对象。 检查行：139、127。AWSSDK.Core.Net45 RefreshingAWSCredentials.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } state.Expiration -= PreemptExpiryTime; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br> 代码片段之一包括检查<i>状态</i>变量的值是否为<i>null</i> 。 在下面的代码中，该变量用于退订<i>PreemptExpiryTime</i>事件，但是，不再执行对<i>null</i>的检查，并且可能<i>引发</i>异常<i>NullReferenceException</i> 。 该代码的更安全版本： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != null) state.Expiration -= PreemptExpiryTime; .... }</code> </pre> <br> 在代码中，还有其他类似的错误： <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3125 [CWE-476]在针对null验证了'wrappedRequest.Content'对象之后，使用了该对象。 检查行：395、383。AWSSDK.Core.Net45 HttpHandler.cs 395 </li><li>  V3125 [CWE-476]在对null进行验证之后，使用了“ datasetUpdates”对象。 检查行：477、437。AWSSDK.CognitoSync.Net45 Dataset.cs 477 </li><li>  V3125 [CWE-476]在对null进行验证之后，使用了'cORSConfigurationCORSConfigurationcORSRulesListValue'对象。 检查行：125、111。AWSSDK.S3.Net45 PutCORSConfigurationRequestMarshaller.cs 125 </li><li>  V3125 [CWE-476]在对null进行验证之后，使用了'lifecycleConfigurationLifecycleConfigurationrulesListValue'对象。 检查行：157，68。AWSSDK.S3.Net45 PutLifecycleConfigurationRequestMarshaller.cs 157 </li><li>  V3125 [CWE-476]在验证了null之后使用了“ this.Key”对象。 检查行：199、183。AWSSDK.S3.Net45 S3PostUploadRequest.cs 199 </li></ul><br>  <b>非替代现实</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a> [CWE-393]奇怪的是，此方法始终返回一个相同的'true'值。  AWSSDK.Core.Net45 Lexer.cs 651 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State19</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 该方法始终返回<i>true</i> 。 让我们看看它对于调用代码有多重要。 我检查了使用<i>State19</i>方法的情况。 它涉及用其他类似的方法（分别有28个名称分别从<i>State1</i>到<i>State28</i>的名称）填充处理程序<i>fsm_handler_table</i>的数组。 在此重要的是要注意，除了<i>State19之外</i> ，对于某些其他处理程序，也发出了警告<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a> [CWE-393]。 这些是处理程序： <i>State23，State26，State27，State28</i> 。 分析仪为其发出的警告： <br><br><ul><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 752 </li><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 810 </li><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 822 </li><li>  V3009 [CWE-393]奇怪的是，此方法始终返回一个相同的“ true”值。  AWSSDK.Core.Net45 Lexer.cs 834 </li></ul><br> 这是处理程序的声明和数组初始化的样子： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StateHandler[] fsm_handler_table; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopulateFsmTables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fsm_handler_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateHandler[<span class="hljs-number"><span class="hljs-number">28</span></span>] { State1, State2, .... State19, .... State23, .... State26, State27, State28 };</code> </pre> <br> 为了使图片更完整，让我们看分析器没有声明任何声明的处理程序之一的代码，例如<i>State2</i> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br> 这是处理程序调用发生的方式： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { handler = fsm_handler_table[state - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! handler (fsm_context)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new JsonException (input_char); .... } .... }</span></span></code> </pre> <br> 如我们所见，如果返回<i>false</i> ，将引发异常。 在我们的案例中，对于处理程序<i>State19，State23，State26，State27</i>和<i>State28，</i>这将永远不会发生。 看起来可疑。 另一方面，五个处理程序具有相似的行为（将始终返回<i>true</i> ），因此它可能是人为设计的，而不是拼写错误的结果。 <br><br> 为什么我要深入了解所有这一切？ 从静态分析仪通常只能指示可疑结构的意义上讲，这种情况非常重要。 即使是一个对项目没有足够了解的人（不是机器），即使花了一些时间学习代码，也仍然无法给出关于错误存在的完整答案。 开发人员应查看此代码。 <br><br>  <b>无意义的检查</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a> [CWE-571]表达式'doLog'始终为true。  AWSSDK.Core.Net45 StoredProfileAWSCredentials.cs 235 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidCredentialsExistInSharedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var doLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidDataException) { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doLog) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } .... }</span></span></code> </pre> <br> 注意<i>doLog</i>变量。 在使用<i>false</i>值初始化之后，此变量将在代码的所有情况下均获得<i>true</i>值。 因此，检查<i>（doLog）</i>是否始终为true。 也许在方法的早期有一个分支，没有为<i>doLog</i>变量分配任何值。 在检查时，它可能包含初始化时收到的<i>错误</i>值。 但是现在没有这样的分支。 <br><br> 另一个类似的错误： <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a>表达式“！结果”始终为false。  353 AWSSDK.CognitoSync.PCL SQLiteLocalStorage.cs <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = PutValueHelper(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) &lt;= { _logger.DebugFormat(<span class="hljs-string"><span class="hljs-string">"{0}"</span></span>, @<span class="hljs-string"><span class="hljs-string">"Cognito Sync - SQLiteStorage - Put Value Failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UpdateLastModifiedTimestamp(....); } .... }</code> </pre> <br> 分析器声称<i>结果</i>变量的值始终为true。 只有在方法<i>PutValueHelper</i>始终返回<i>true的</i>情况下<i>才有</i>可能。 看一下这个方法： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValueHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record == null) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br> 实际上，该方法在所有情况下都将返回<i>true</i> 。 此外，分析仪已对此方法发出警告。  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a> [CWE-393]奇怪的是，此方法始终返回一个相同的'true'值。  SQLiteLocalStorage.cs 1016 <br><br> 我在查询其他错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3009</a>并将其保存为这种情况时，故意不引用此警告。 因此，该工具正确指出了调用代码中的错误<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3022</a> 。 <br><br>  <b>复制粘贴。</b>  <b>再来一次</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3001</a>在'||'的左侧和右侧有相同的子表达式'this.token == JsonToken.String' 操作员。  AWSSDK.Core.Net45 JsonReader.cs 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ObjectEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ArrayEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.String || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.token == JsonToken.Boolean || this.token == JsonToken.Double || this.token == JsonToken.Int || this.token == JsonToken.UInt || this.token == JsonToken.Long || this.token == JsonToken.ULong || this.token == JsonToken.Null || this.token == JsonToken.String // &lt;= )) { .... } .... }</span></span></code> </pre> <br> 将字段<i>this.token</i>与枚举<i>JsonToken</i>的值<i>JsonToken.String</i>进行两次比较。 可能其中一个比较应包含另一个枚举值。 如果是这样，那么这里就犯了一个严重的错误。 <br><br>  <b>重构+注意力不集中？</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3025</a> [CWE-685]格式错误。 调用“格式”功能时，期望格式项目的数量不同。 未使用的参数：AWSConfigs.AWSRegionKey。  AWSSDK.Core.Net45 AWSRegion.cs 116 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstanceProfileAWSRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>, AWSConfigs.AWSRegionKey)); } .... }</code> </pre> <br> 也许<i>string.Format</i>方法的格式字符串先前包含格式项<i>{0}，</i>为此设置了参数<i>AWSConfigs.AWSRegionKey</i> 。 然后更改了字符串，格式项消失了，但是开发人员忘了删除参数。 给定的代码示例可以正常工作（错误是在相反的情况下抛出的-没有参数的格式项），但是看起来并不好。 该代码应更正如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>); }</code> </pre> <br>  <b>不安全</b> <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3083</a> [CWE-367]事件'mOnSyncSuccess'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.CognitoSync.PCL Dataset.cs 827 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOnSyncSuccess != null) { mOnSyncSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); } }</code> </pre> <br> 事件处理程序不安全调用的常见情况。 用户可以在检查<i>mOnSyncSuccess</i>变量<i>是否</i>为<i>空</i>和调用处理程序之间退订，因此其值将变为<i>null</i> 。 发生这种情况的可能性很小，但是使代码更安全仍然更好： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ mOnSyncSuccess?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); }</code> </pre> <br> 在代码中，还有其他类似的错误： <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  V3083 [CWE-367]事件'mOnSyncFailure'的不安全调用，可能会导致NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.CognitoSync.PCL Dataset.cs 839 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonServiceClient.cs 332 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonServiceClient.cs 344 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonServiceClient.cs 357 </li><li>  V3083 [CWE-367]事件'mExceptionEvent'的不安全调用，可能为NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  366AWSSDK.Core.PCL AmazonServiceClient.cs </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL AmazonWebServiceRequest.cs 78 </li><li>  V3083 [CWE-367]事件'OnRead'的不安全调用，可能会发生NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.PCL EventStream.cs 97 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.Android NetworkReachability.cs 57 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.Android NetworkReachability.cs 94 </li><li>  V3083 [CWE-367]事件的不安全调用，可能是NullReferenceException。 请考虑在调用事件之前将事件分配给局部变量。  AWSSDK.Core.iOS NetworkReachability.cs 54 </li></ul><br>  <b>粗级</b> <br><br>  <b>PVS-Studio警告：</b>实现IEquatable &lt;T&gt;接口的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V3126</a>类型“ JsonData”不会覆盖“ GetHashCode”方法。  AWSSDK.Core.Net45 JsonData.cs 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonData</span></span></span><span class="hljs-class"> :</span></span> IJsonWrapper, IEquatable&lt;JsonData&gt; { .... }</code> </pre> <br>  <i>JsonData</i>类包含很多代码，因此我没有给出完整的内容，只是引用了它的声明。 此类确实不包含被覆盖的方法<i>GetHashCode，</i>这是不安全的，因为在使用<i>JsonData</i>类型（例如，与集合一起使用）时，它可能导致错误的行为。 目前可能没有问题，但是将来这种策略可能会改变。 该错误在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a>中有更详细的描述。 <br><br>  <b>结论</b> <br><br> 这些都是有趣的错误，我可以使用PVS-Studio静态分析器在适用于.NET的AWS开发工具包的代码中检测到。 我想再次强调项目的质量。 我发现500万行代码中的错误很少。 尽管对发出的警告进行更彻底的分析可能会使我在此列表中添加更多错误。 不过，我很有可能在错误中添加了一些警告。 在这种情况下，只有在检查代码上下文中的开发人员才能得出明确的结论。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437514/">https://habr.com/ru/post/zh-CN437514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437502/index.html">我将不再把商品扔进垃圾桶</a></li>
<li><a href="../zh-CN437504/index.html">小组件：可能出什么问题？ 我们使用唯一责任原则</a></li>
<li><a href="../zh-CN437508/index.html">CVE-2019-6111和其他SCP漏洞</a></li>
<li><a href="../zh-CN437510/index.html">发送短信时会发生什么</a></li>
<li><a href="../zh-CN437512/index.html">什么是JavaScript中的纯函数？</a></li>
<li><a href="../zh-CN437516/index.html">在Amazon Web Services SDK for .NET源代码中寻找错误</a></li>
<li><a href="../zh-CN437518/index.html">甲虫袭击</a></li>
<li><a href="../zh-CN437520/index.html">“我的灯是一面镜子！ -说，给我看我的双重身份……”：设计一个好的框架，然后将第二个作为礼物</a></li>
<li><a href="../zh-CN437522/index.html">殖民地 第22章：最终决定</a></li>
<li><a href="../zh-CN437524/index.html">创建一个简单的国际象棋AI：5个简单步骤</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>