<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßöüèø üë®‚Äçüî¨ üë®üèΩ‚ÄçüöÄ "Ol√°, Checkmarx!" Como escrever uma solicita√ß√£o para o Checkmarx SAST e encontrar vulnerabilidades interessantes üè¢ üö∏ üë®‚Äçüëß‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° Habr! 

 No artigo, quero falar sobre a nossa experi√™ncia na cria√ß√£o de minhas consultas no Checkmarx SAST. 

 Quando voc√™ se familiariza com esse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>"Ol√°, Checkmarx!" Como escrever uma solicita√ß√£o para o Checkmarx SAST e encontrar vulnerabilidades interessantes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dins/blog/477742/"><img src="https://habrastorage.org/webt/sh/ll/ln/shlllnc6iduoendolw26rabdugk.jpeg"><br><br>  Ol√° Habr! <br><br>  No artigo, quero falar sobre a nossa experi√™ncia na cria√ß√£o de minhas consultas no Checkmarx SAST. <br><br>  Quando voc√™ se familiariza com esse analisador, pode ter a impress√£o de que, al√©m de procurar algoritmos fracos de criptografia / hash e um monte de falso positivo, ele n√£o retorna mais nada.  Mas, quando configurada corretamente, √© uma ferramenta super poderosa que pode procurar bugs s√©rios. <br><br>  Compreenderemos os meandros da linguagem de consulta Checkmarx SAST e escreveremos 2 consultas para procurar por inje√ß√µes de SQL e refer√™ncias diretas a objetos inseguras. <br><a name="habracut"></a><br><br><h2>  Entrada </h2><br>  Ap√≥s uma longa pesquisa por guias ou artigos sobre o Checkmarx, ficou claro para mim que, al√©m da documenta√ß√£o oficial, n√£o havia informa√ß√µes √∫teis suficientes.  E a documenta√ß√£o oficial n√£o diz que tudo est√° se tornando muito claro e compreens√≠vel.  Por exemplo, n√£o encontrei pr√°ticas recomendadas, como organizar consultas de substitui√ß√£o corretamente, como escrever consultas "para manequins" etc. etc. Sim, h√° documenta√ß√£o sobre as fun√ß√µes da linguagem de consulta do CMx, mas veja como combinar essas fun√ß√µes em uma √∫nica consulta, a documenta√ß√£o n√£o est√° escrita. <br><br>  Talvez a falta de artigos e guias da comunidade Checkmarx esteja associada ao alto custo da ferramenta e, como resultado, a uma pequena audi√™ncia.  Ou talvez apenas algumas pessoas se preocupem com o ajuste fino e usem a solu√ß√£o como est√°, pronta para uso. <br><br>  Na minha experi√™ncia, vejo mais que o SAST √© usado mais para cumprir formalidades relacionadas a v√°rios requisitos por parte dos clientes do que para procurar bugs reais.  Com essa abordagem, como resultado, temos, na melhor das hip√≥teses, um n√∫mero relativamente pequeno de ‚Äúvulnerabilidades‚Äù que quase automaticamente passam a ser chamadas de ‚Äún√£o explor√°veis‚Äù (porque elas est√£o em 99,9% dos casos). <br><br>  Deve-se observar que o pr√≥prio Checkmarx est√° tentando atualizar suas consultas para fornecer o melhor resultado imediato.  Por√©m, as consultas do CMx Query Language s√£o adaptadas ao "caso geral".  A pesquisa inicial de tokens √© baseada no nome.  Por exemplo, o CMx SAST assume que todas as consultas ao banco de dados ter√£o a seguinte apar√™ncia: * createQuery * ou * createSQLQuery *.  Mas se o desenvolvimento interno for usado para trabalhar com o banco de dados e o m√©todo para consultar o banco de dados for chamado de maneira diferente, por exemplo * driveMyQuery *, todos os m√©todos SQL ser√£o ignorados.  Por exemplo, nosso cliente usa ORM personalizado para banco de dados SQL.  Nesse caso, as consultas CMx prontas para o uso ignoraram todas as inje√ß√µes de SQL. <br><br><h4>  Abrevia√ß√µes e defini√ß√µes </h4><br>  <b>CMx</b> - Checkmarx SAST. <br>  <b>CMxQL</b> - linguagem de consulta Checkmarx SAST <br>  <b>Token</b> - uma string com um certo valor √© o resultado do trabalho do analisador lexical (tamb√©m chamado de tokeniza√ß√£o) <br><br><h3>  Aplicativo de teste </h3><br>  Para escrever um artigo, esbocei um c√≥digo Java, um pequeno aplicativo de teste.  Este c√≥digo √© uma c√≥pia aproximada de uma pequena parte do sistema real.  Embora, em geral, o c√≥digo do aplicativo de teste n√£o seja muito diferente de qualquer outro c√≥digo de back-end HTTP.  As principais se√ß√µes do c√≥digo do aplicativo de teste ser√£o vis√≠veis nas capturas de tela. <br><br><h4>  O aplicativo de teste possui a seguinte estrutura </h4><br>  Classe <i>WebRouter</i> para processar solicita√ß√µes HTTP recebidas; 4 m√©todos para processar URLs dentro: <br><ul><li>  <i>/ getTransaction</i> - aceita o <i>ID</i> da transa√ß√£o como entrada <i>e retorna as informa√ß√µes</i> , <i>identifica</i> -o como uma sequ√™ncia e passa-o para <i>getTransactionInfo (transactionId)</i> =&gt; <i>getTransactionInfo (transactoinId)</i> - torna o transactionId concatenado com a consulta SQL (ou seja, a inje√ß√£o SQL √© obtida); </li><li>  <i>/ getSecureTransaction</i> - recebe o <i>ID</i> da transa√ß√£o na entrada <i>e retorna as informa√ß√µes</i> , <i>identifica</i> -o como uma string e passa-o <i>getTransactionInfoSecured ()</i> =&gt; <i>getTransactionInfoSecured (transactoinId)</i> - primeiro <i>lan√ßa o</i> string <i>transactionId</i> para o tipo Long e depois o concatena na consulta SQL (neste caso a inje√ß√£o n√£o seja explorada); </li><li>  <i>/ getSettings</i> - aceita <i>userId</i> e <i>mailboxId como entrada</i> - e emite as configura√ß√µes da caixa de correio.  N√£o verifica se o <i>id</i> da <i>caixa de correio</i> pertence ao usu√°rio; </li><li>  <i>/ getSecureSettings</i> - tamb√©m aceita <i>userId</i> e <i>mailboxId na entrada</i> e exibe as configura√ß√µes da caixa de correio.  MAS verifica se o <i>id</i> da <i>caixa de correio</i> pertence ao usu√°rio. </li></ul><br><br><h2>  CMx: informa√ß√µes gerais e defini√ß√µes b√°sicas </h2><br><h3>  Antes de come√ßar a desenvolver consultas </h3><br>  O desenvolvimento da consulta √© realizado em um programa separado CxAuditor.  No CxAuditor, voc√™ precisa digitalizar todo o c√≥digo (criar projeto local), para o qual escreveremos consultas.  Depois disso, voc√™ pode escrever e executar novas consultas.  Com uma grande base de c√≥digos, a verifica√ß√£o prim√°ria pode levar horas e gigabytes de mem√≥ria.  Depois disso, cada solicita√ß√£o n√£o ser√° executada com rapidez suficiente.  Isso √© completamente inadequado para o desenvolvimento. <br><br>  Portanto, voc√™ pode pegar um pequeno conjunto de arquivos do projeto, de prefer√™ncia com um bug encontrado no c√≥digo antes do tipo em que estamos escrevendo uma solicita√ß√£o (ou colocar o bug com as m√£os) e verificar apenas esse conjunto de arquivos.  N√£o √© necess√°rio cumprir a estrutura de arquivos do projeto.  Ou seja, se voc√™ tiver o pacote Java A e B e as classes no pacote B usarem as classes e os m√©todos do pacote A, poder√° colocar tudo isso em um √∫nico diret√≥rio, e o CMx ainda entender√° os relacionamentos e criar√° cadeias de chamadas entre arquivos corretamente (bom ou quase sempre correto, embora os erros dificilmente estejam relacionados √† estrutura de arquivos do projeto). <br><br><h3>  Defini√ß√µes b√°sicas </h3><br><h4>  Cxlist </h4><br>  O principal tipo de dados no CMx.  O resultado de quase todas as fun√ß√µes do CMxQL ser√° <i>CxList</i> .  Existem muitos elementos com certas propriedades.  As propriedades que s√£o mais √∫teis para o desenvolvimento ser√£o consideradas abaixo. <br><br><h4>  resultado </h4><br>  O CMxQL possui um <i>resultado</i> vari√°vel interno.  O conjunto que cont√©m a vari√°vel de <i>resultado</i> , ap√≥s a execu√ß√£o de toda a consulta, ser√° exibido como resultado. <br><br>  Ou seja, a opera√ß√£o final de qualquer consulta deve ser a sequ√™ncia <i>result = WHATEVER</i> , por exemplo: <br><pre><code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"anyname"</span></span>);</code> </pre> <br><h4>  elemento de fluxo e c√≥digo </h4><br>  A maioria das fun√ß√µes do CMxQL pelo tipo de valores retornados s√£o divididas em 2, aquelas que retornam "elementos de c√≥digo" e aquelas que retornam o Flow.  Nos dois casos, o resultado √© um <i>CxList</i> .  Mas seu conte√∫do ser√° um pouco diferente para os elementos de fluxo e c√≥digo. <br><ul><li>  <b>Elemento de c√≥digo</b> - token - por exemplo, uma vari√°vel, chamada de m√©todo, atribui√ß√£o, etc; </li><li>  <b>Fluxo</b> - o relacionamento entre os tokens fornecidos. </li></ul><br><br><h4>  Tudo e "sub" Tudo </h4><br>  Cada fun√ß√£o do CMxQL pode ser executada no conjunto <i>Tudo</i> (cont√©m todos os tokens de todo o c√≥digo digitalizado, j√° vimos um exemplo com <i>resultado</i> ) ou no conjunto <i>CxList</i> , que por sua vez foi obtido como resultado de algumas opera√ß√µes na consulta, por exemplo, na consulta: <br><pre> <code class="actionscript hljs">CxList newList = CxList.New();</code> </pre> <br>  criar√° um conjunto vazio, que poder√° ser preenchido com elementos usando o m√©todo <i>Add ()</i> e, em seguida, pesquisar pelos elementos do novo conjunto: <br><pre> <code class="actionscript hljs">CxList newFind = newList.FindByName(<span class="hljs-string"><span class="hljs-string">"narrowedScope"</span></span>);</code> </pre> <br><h4>  Propriedades dos itens encontrados </h4><br>  Cada elemento do conjunto CxList possui v√°rias propriedades.  Ao analisar os resultados para escrever consultas, os mais √∫teis s√£o: <br><br><ul><li>  <b>SourceFile</b> - o nome do arquivo que cont√©m esse elemento; </li><li>  <b>Linha de Origem</b> - n√∫mero da linha com token; </li><li>  <b>Nome da fonte</b> - o nome do token.  Equivalente ao token, ou seja, se a vari√°vel for chamada var1, ent√£o Nome da Fonte = var1; </li><li>  <b>Tipo de origem</b> - o tipo de token.  Por exemplo, se for uma string, ser√° StringLiteral, se o m√©todo for chamado, MethodInvokeExpr e muitos outros; </li><li>  <b>Arquivo de destino</b> </li><li>  <b>Linha de destino;</b> </li><li>  <b>Nome do destino;</b> </li><li>  <b>Tipo de destino.</b> </li></ul><br><br>  Origem e Destino ser√£o diferentes se os elementos do conjunto de resultados forem Fluxo e vice-versa corresponder√£o se o resultado for elementos de c√≥digo. <br><br><h2>  Comece a criar consultas </h2><br>  Todas as fun√ß√µes do CMxQL podem ser divididas em v√°rios tipos.  Aqui, na minha opini√£o, pode-se notar a principal desvantagem da documenta√ß√£o do CMxQL, todas as fun√ß√µes no dock s√£o descritas simplesmente em ordem alfab√©tica, enquanto seria muito mais conveniente estrutur√°-las de acordo com a funcionalidade e somente ent√£o alfabeticamente. <br><br><ul><li>  Fun√ß√µes de pesquisa - quase todas as fun√ß√µes do CMxQL com o nome <b>FindBy *</b> e <b>GetBy *</b> ; </li><li>  As fun√ß√µes das opera√ß√µes em conjuntos s√£o adi√ß√£o, subtra√ß√£o, interse√ß√£o, itera√ß√£o sobre elementos, etc. </li><li>  Fun√ß√µes de an√°lise - Essas s√£o basicamente as fun√ß√µes <b>* InfluencedBy *</b> <b>* InfluencingOn *</b> . </li></ul><br><br>  O princ√≠pio b√°sico das consultas √© a altern√¢ncia desses tipos de fun√ß√µes.  Primeiro, usando as fun√ß√µes de pesquisa, selecionamos apenas os tokens que nos interessam por determinadas propriedades.  Usando opera√ß√µes em conjuntos, podemos combinar diferentes conjuntos com diferentes propriedades de token em um, ou vice-versa, subtrair o outro de um.  Em seguida, usando as fun√ß√µes de an√°lise, criamos o Code Flow e tentamos entender se as poss√≠veis vulnerabilidades dependem dos par√¢metros nos pontos de entrada. <br><br>  A escolha do local a partir do qual iniciar a pesquisa e, em geral, todo o caminho de pesquisa, depende do c√≥digo espec√≠fico e, mais precisamente, at√© do "texto".  Em alguns casos, √© conveniente procurar consultas do usu√°rio a partir do ponto de entrada; em alguns casos, √© mais conveniente come√ßar do "final" ou at√© do meio.  Tudo depende do c√≥digo espec√≠fico e voc√™ precisa abordar individualmente cada reposit√≥rio. <br><br><h2>  Exemplo: Pesquisar inje√ß√£o SQL </h2><br>  Plano de pesquisa, entre par√™nteses, indiquei o nome dos conjuntos (vari√°veis ‚Äã‚Äãna consulta): <br><br><ol><li>  Definir exce√ß√µes - tokens que podem ser lan√ßados imediatamente fora dos escopos de pesquisa ( <i>exclusionList</i> ); </li><li>  Determinar a localiza√ß√£o das verifica√ß√µes de sanitiza√ß√£o / seguran√ßa ( <i>sanitiza√ß√£o</i> ); </li><li>  Encontre todos os locais de baixo n√≠vel com execu√ß√£o de consulta no banco de dados ( <i>runSuperSecureSQLQuery</i> ); </li><li>  Encontre todos os par√¢metros dos m√©todos chamados <i>runSuperSecureSQLQuery</i> ( <i>runSSSQParams</i> ); </li><li>  Encontre pontos de entrada (m√©todos pai e seus par√¢metros) para os locais de execu√ß√£o da consulta no banco de dados ( <i>entryPointsParameters</i> ); </li><li>  Localize as depend√™ncias dos par√¢metros <i>runSSSQParams</i> em <i>entryPoints</i> , enquanto apenas os locais onde n√£o h√° entrada de entrada de <i>higieniza√ß√£o</i> . </li></ol><br><br>  Como resultado, obtemos m√©todos de baixo n√≠vel com consultas SQL, onde os par√¢metros da consulta SQL: <br><br><ul><li>  depende dos par√¢metros do m√©todo; </li><li>  par√¢metros s√£o aceitos como strings; </li><li>  par√¢metros s√£o concatenados √† solicita√ß√£o. </li></ul><br>  N√£o verificaremos se podemos controlar esses par√¢metros, como  acreditamos que existe um mecanismo para mapear vari√°veis ‚Äã‚Äãem uma consulta e existe uma convers√£o para um tipo num√©rico para n√∫meros, e a concatena√ß√£o de cadeias √© sempre considerada perigosa.  Mesmo se n√£o houver controle sobre a linha agora, ela pode aparecer na nova vers√£o. <br><br><h3>  SQLi: Etapa 1. Definindo exce√ß√µes </h3><br>  Em exce√ß√µes, voc√™ precisa adicionar as classes ou arquivos em que os nomes dos tokens podem corresponder aos que voc√™ procura, porque  esses tokens levar√£o a entradas inv√°lidas. <br><br>  Por exemplo, um m√©todo para acessar um banco de dados √© chamado <i>runSuperSecureSQLquery</i> .  Assumimos que o m√©todo <i>runSuperSecureSQLquery</i> interno seja implementado com seguran√ßa.  E nossa tarefa √© encontrar lugares onde n√£o √© seguro usar o m√©todo em si.  Para inje√ß√£o de SQL, locais de concatena√ß√£o de par√¢metros controlados pelo usu√°rio n√£o ser√£o locais seguros.  E locais seguros para mapear par√¢metros na estrutura ORM ou, por exemplo, para par√¢metros num√©ricos, √© uma convers√£o para o tipo correspondente.  N√£o precisamos varrer todo o c√≥digo "mais profundo" do que <i>runSuperSecureSQLquery</i> , o que significa que √© melhor exclu√≠-lo para evitar descobertas in√∫teis. <br><br>  Para procurar essas exce√ß√µes, √© conveniente usar as fun√ß√µes do CMxQL: <br><ul><li>  <b>FindByFileName ()</b> - encontrar√° o conjunto de todos os tokens em um arquivo espec√≠fico; </li><li>  <b>GetByClass ()</b> - encontrar√° o conjunto de todos os tokens na classe com o nome fornecido. </li></ul><br><br>  Para um aplicativo de teste, essa exce√ß√£o √© a classe <i>Session</i> , que cont√©m a implementa√ß√£o do m√©todo <i>runSuperSecureSQLquery</i> . <br>  Um exemplo de uma solicita√ß√£o para excluir c√≥digo na classe <i>Session</i> (o m√©todo <i>GetByClass ()</i> verificar√° quais dos tokens passados ‚Äã‚Äãpara a entrada tem um tipo <i>CMx</i> de <i>ClassDecl</i> e emitir√° muitos tokens dessa classe) <br><br><pre> <code class="java hljs">CxList exclusionList = All.GetByClass(All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Session*"</span></span>)); result = exclusionList;</code> </pre> <br><br>  Ou outra maneira √© lan√ßar c√≥digo em todo o arquivo <i>Session.java</i> : <br><br><pre> <code class="java hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*Session.java"</span></span>); result = exclusionList;</code> </pre> <br><br>  O asterisco antes do nome √© importante, porque o nome do arquivo inclui todo o caminho. <br>  Agora, temos muitos tokens que podem ser subtra√≠dos nas pr√≥ximas etapas do escopo da pesquisa. <br><br>  O resultado da pesquisa de tokens na classe <i>Session</i> : <br><br><img src="https://habrastorage.org/webt/x3/gz/vx/x3gzvxxumbbu-th01llyjbymkoo.png"><br><br><h3>  SQLi: Etapa 2. Determinando locais de higieniza√ß√£o </h3><br>  Existem 2 m√©todos de API no aplicativo de teste (consulte uma breve descri√ß√£o do aplicativo de teste).  A diferen√ßa entre os dois m√©todos de API √© que <i>getTransactionInfo ()</i> concatena o par√¢metro transactionId na consulta SQL e <i>getTransactionInfoSecured ()</i> primeiro <i>converte</i> transactionId em Long e depois o passa como uma string.  A vulnerabilidade (concatena√ß√£o de par√¢metros) √© incorporada nos dois m√©todos.  Mas, gra√ßas √† convers√£o para Long em <i>getTransactionInfoSecured ()</i> , o √∫ltimo m√©todo n√£o √© vulner√°vel √† inje√ß√£o, porque quando tentamos passar uma inje√ß√£o (string), obtemos uma exce√ß√£o Java. <br><br>  Neste exemplo, consideraremos o elenco como Long como o local de saneamento.  Para encontrar esses tokens: <br><br><pre> <code class="java hljs">CxList sanitization = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*Long*"</span></span>); result = sanitization;</code> </pre> <br><br>  Resultado de exemplo: <br><br><img src="https://habrastorage.org/webt/hb/ms/vx/hbmsvxmjwynfncf96eyclx2ey8y.png"><br><br>  O resultado incluiu tokens com os m√©todos YP do tipo <i>Long</i> e <i>getValueAsLong</i> , que <i>convertem</i> internamente <i>o</i> valor no tipo <i>Long</i> .  Voc√™ precisa revisar cuidadosamente o resultado para garantir que n√£o haja nada extra. <br><br><h3>  SQLi: Etapa 3. Encontre todos os locais de baixo n√≠vel com execu√ß√£o de consulta no banco de dados </h3><br>  A consulta a seguir encontrar√° todos os locais usando o token runSuperSecureSQLQuery (usado para acessar o banco de dados): <br><br><pre> <code class="actionscript hljs">result = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>)</code> </pre> <br>  Resultado da pesquisa pelo nome do token runSuperSecureSQLQuery: <br><img src="https://habrastorage.org/webt/qm/bh/ci/qmbhci6ucl_wx3sb_9zqfkkpim8.png"><br><br>  Al√©m disso, nos locais em que esse m√©todo √© chamado (a classe <i>Billing</i> ), somente os tokens de chamada de m√©todo (tipo <i>MethodInvokeExpr</i> ) ser√£o encontrados e, para o local da declara√ß√£o do m√©todo (classe <i>Session</i> ), todos os tokens ser√£o encontrados - vari√°veis. <br><br>  Filtramos apenas os tokens de chamada do m√©todo: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery;</code> </pre> <br>  Resultado: <br><img src="https://habrastorage.org/webt/or/82/dw/or82dwxfoze-fcbko2b2mljfyus.png"><br><br>  Como resultado, obtivemos 7 locais, 4 deles as chamadas necess√°rias para o m√©todo <i>runSuperSecureSQLQuery ()</i> (classes de <i>Faturamento</i> e <i>Usu√°rio</i> ).  2 - chama o m√©todo interno runSuperSecureSQLQuery () dentro da classe <i>Session</i> , e mais um √© o m√©todo <i>add</i> , que √© um tipo de peculiaridade da pesquisa do CMxQL.  Digamos apenas que eu n√£o esperava que estivesse na lista =) Os tokens na classe <i>Session</i> , como descobrimos na etapa 1, n√£o s√£o interessantes para n√≥s, portanto, simplesmente os subtra√≠mos do resultado: <br><br><pre> <code class="java hljs">CxList runSuperSecureSQLQuery = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*runSuperSecureSQLQuery*"</span></span>).FindByType(typeof(MethodInvokeExpr)); result = runSuperSecureSQLQuery - exclusionList;</code> </pre> <br>  Recebemos uma lista v√°lida de chamadas para o m√©todo necess√°rio: <br><br><img src="https://habrastorage.org/webt/sh/c8/ix/shc8ixcpk9wrkmdv_vzqfz5wj80.png"><br><br>  Observe as <i>fun√ß√µes FindByType ()</i> e <i>typeof ()</i> na consulta anterior.  Se quisermos pesquisar por tipo de CMx, isto √©, pela propriedade <i>CxList</i> ‚ÄúSource Type‚Äù - ent√£o usamos <i>typeof (Source Type)</i> .  Se queremos fazer uma pesquisa por tipo de dados, precisamos passar o par√¢metro apenas como uma string.  Por exemplo: <br><br><pre> <code class="java hljs">result = All.FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre><br>  encontrar√° todos os tokens java com o tipo String. <br><br><h3>  SQLi: Etapa 4. Encontre todos os par√¢metros dos m√©todos runSuperSecureSQLQuery chamados </h3><br>  Para procurar par√¢metros de m√©todo, a fun√ß√£o CMPQL <i>GetParameters () √© usada</i> : <br><br><pre> <code class="actionscript hljs">CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); result = runSSSQParams;</code> </pre> <br>  Resultado: <br><br><img src="https://habrastorage.org/webt/s4/4h/id/s44hidweor1j61xs1dkwbewrpja.png"><br><br><h3>  SQLi: Etapa 5. Encontre pontos de entrada para locais de execu√ß√£o de consulta no banco de dados </h3><br>  Para fazer isso, primeiro obtemos os nomes dos m√©todos pai, dentro dos quais est√£o as chamadas para o banco de dados <i>runSuperSecureSQLQuery</i> e, em seguida, obtemos seus par√¢metros.  Para procurar tokens pai, a fun√ß√£o <i>GetAncOfType () do CMxQL √© usada</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodDecl)); result = entryPoints;</code> </pre> <br><br>  Nesta consulta, para o conjunto runSuperSecureSQLQuery, retorne todos os tokens pai do tipo MethodDecl - este √© o m√©todo anterior na pilha de chamadas: <br><br><img src="https://habrastorage.org/webt/we/8w/7u/we8w7ucxjxvtgzerknbgjxir8fa.png"><br><br>  Para procurar par√¢metros de m√©todo, tamb√©m usamos <i>GetParameters ()</i> : <br><br><pre> <code class="actionscript hljs">CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType(<span class="hljs-string"><span class="hljs-string">"String"</span></span>);</code> </pre> <br><br>  A consulta retornar√° os par√¢metros de um subconjunto de <i>entryPoints</i> com o tipo Java String: <br><br><img src="https://habrastorage.org/webt/7y/mw/tf/7ymwtfxg94oxlwggez3zhpfvcko.png"><br><br><h3>  SQLi: Etapa 6. Encontre as depend√™ncias dos par√¢metros runSSSQParams em entryPointsParameters, enquanto apenas os locais onde n√£o h√° entrada de higieniza√ß√£o </h3><br>  Nesta etapa, usamos as fun√ß√µes de an√°lise.  As seguintes fun√ß√µes s√£o usadas para analisar o c√≥digo de fluxo: <br><br><ul><li>  InfluencedBy () </li><li>  InfluencedByAndNotSanitized () </li><li>  InfluencingOn () </li><li>  InfluencingOnAndNotSanitized () </li><li>  NotInfluencedBy () </li><li>  NotInfluencingOn () </li></ul><br><br>  Para localizar o fluxo de par√¢metros de solicita√ß√£o <i>runSSSQParams,</i> dependendo dos par√¢metros do m√©todo pai <i>entryPointsParameters</i> , e excluir tokens de <i>limpeza</i> : <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization);</code> </pre> <br><br>  No entanto, n√£o tenho certeza se as fun√ß√µes <i>* AndNotSanitized</i> dentro fazem alguma m√°gica, e parece mais que o m√©todo simplesmente subtrai o conjunto higienizado de seu resultado.  Ou seja, se voc√™ fizer: <br><br><pre> <code class="java hljs">CxList dataInflOnTable = runSSSQParams.InfluencedBy(entryPointsParameters) - sanitization;</code> </pre> <br><br>  acontece a mesma coisa.  Embora talvez eu simplesmente n√£o tenha encontrado uma op√ß√£o quando ainda existem diferen√ßas. <br><br>  O resultado da consulta nos fornece um fluxo corretamente constru√≠do: <br><br><img src="https://habrastorage.org/webt/ru/hs/2d/ruhs2dlh7alil7njbzsf2jke9qw.png"><br><br>  Obtive fluxo com poss√≠vel inje√ß√£o de SQL.  Como pode ser visto na captura de tela, o Checkmarx retornou 3 Flow.  O fluxo na captura de tela √© o mais curto, inicia e termina em um arquivo e um m√©todo.  O pr√≥ximo fluxo j√° sai da classe Session.  Preste aten√ß√£o √† origem / destino.  E o √∫ltimo √© outro m√©todo na classe Session.  O fluxo dentro da <i>sess√£o</i> ter√° a seguinte apar√™ncia: <br><br><img src="https://habrastorage.org/webt/mv/o7/uu/mvo7uuu6wp_dq-ggltm8lb5m5p0.png"><br><br>  Para selecionar um fluxo, o m√©todo <i>ReduceFlow (CxList.ReduceFlowType flowType) √© usado</i> , onde flowType pode ser: <br><br><ul><li>  <i>CxList.ReduceFlowType.ReduceBigFlow</i> - selecione o Fluxo mais curto </li><li>  <i>CxList.ReduceFlowType.ReduceSmallFlow</i> - selecione o fluxo mais longo </li></ul><br><br><h3>  SQLi: consulta final para encontrar inje√ß√£o SQL </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.GetByClass(All.FindByName("*Session*")); // 2.    CxList sanitization = All.FindByName("*Long*"); // 3.    runSuperSecureSQLQuery() CxList runSuperSecureSQLQuery = All.FindByName("*runSuperSecureSQLQuery*").FindByType(typeof(MethodInvokeExpr)); runSuperSecureSQLQuery -= exclusionList; // 4.     runSuperSecureSQLQuery() CxList runSSSQParams = All.GetParameters(runSuperSecureSQLQuery); // 5.   ,     runSuperSecureSQLQuery() CxList entryPoints = runSuperSecureSQLQuery.GetAncOfType(typeof(MethodDecl)); CxList entryPointsParameters = All.GetParameters(entryPoints).FindByType("String"); // 6.       (runSuperSecureSQLQuery)     CxList dataInflOnTable = runSSSQParams.InfluencedByAndNotSanitized(entryPointsParameters, sanitization); // 7.   result = dataInflOnTable.ReduceFlow(CxList.ReduceFlowType.ReduceBigFlow);</span></span></code> </pre> <br><br><h2>  Exemplo 2: Pesquisando refer√™ncias de objetos diretos inseguros </h2><br>  Nesta solicita√ß√£o, procuraremos todos os locais onde o trabalho com objetos ocorre sem verificar o propriet√°rio do objeto.  Nesse caso, podem ser usados ‚Äã‚Äãnomes diferentes de par√¢metros HTTP para mailboxid (presumimos que seja herdado) e a verifica√ß√£o em si pode ocorrer em diferentes est√°gios: em algum lugar no ponto da API de entrada HTTP, em algum lugar antes da solicita√ß√£o ao banco de dados e, √†s vezes em m√©todos intermedi√°rios. <br><br>  Plano de pesquisa <br><ol><li>  Definir exce√ß√µes ( <i>exclusionList</i> ); </li><li>  Identifique locais para verifica√ß√µes de autoriza√ß√£o ( <i>idorSanitizer</i> ); </li><li>  Encontre pontos de entrada - locais para processamento prim√°rio de solicita√ß√µes HTTP ( <i>webRemoteMethods</i> ); </li><li>  Somente por tokens de ponto de entrada para localizar o local de extra√ß√£o do par√¢metro HTTP <i>mailboxid</i> ( <i>mailboxidInit</i> ); </li><li>  Encontre todas as chamadas de webRemoteMethods para m√©todos e par√¢metros de <i>middleware</i> dessas chamadas ( <i>middlewareMethods</i> ); </li><li>  Encontre m√©todos de middleware que dependem do mailboxid ( <i>apiPotentialIDOR</i> ); </li><li>  Encontre todos os locais onde os m√©todos de middleware est√£o definidos ( <i>middlewareDecl</i> ); </li><li>  Passe por todo o <i>apiPotentialIDOR</i> e selecione apenas os <i>middlewareDecl</i> nos quais n√£o h√° verifica√ß√£o do propriet√°rio do objeto da caixa de <i>correio</i> . </li></ol><br><br><h3>  IDOR: Etapa 1. Identificar exce√ß√µes </h3><br>  Nesse caso, exclua todos os tokens em um arquivo espec√≠fico: <br><br><pre> <code class="actionscript hljs">CxList exclusionList = All.FindByFileName(<span class="hljs-string"><span class="hljs-string">"*WebMethodContext.java"</span></span>); result = exclusionList;</code> </pre> <br>  <i>O WebMethodContext.java</i> cont√©m uma implementa√ß√£o de m√©todos como <i>getMailboxId</i> e <i>getUserId</i> , al√©m da string "mailboxid".  Como o nome dos tokens coincidir√° com os que precisamos procurar por vulnerabilidades, esse arquivo emitir√° descobertas falsas. <br><br><h3>  IDOR: Etapa 2. Localize as verifica√ß√µes de autoriza√ß√£o </h3><br>  No aplicativo de teste, o m√©todo <i>validateMailbox ()</i> √© usado para determinar se o objeto solicitado pertence ao usu√°rio: <br><br><pre> <code class="actionscript hljs">CxList idorSanitizer = All.FindByName(<span class="hljs-string"><span class="hljs-string">"*validateMailbox*"</span></span>); result = idorSanitizer;</code> </pre><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/a7/jx/3e/a7jx3eqcxzb5pwgzze9yuqbysos.png"><br><br><h3>  IDOR: Etapa 3. Encontre pontos de entrada para solicita√ß√µes personalizadas da API HTTP </h3><br>  Os manipuladores de solicita√ß√£o HTTP t√™m uma anota√ß√£o especial que facilita a localiza√ß√£o.  No meu caso, isso √© "WebRemote"; a fun√ß√£o <i>CMxQL FindByCustomAttribute () √©</i> usada para procurar anota√ß√µes.  Para <i>FindByCustomAttribute ()</i> , a fun√ß√£o de pesquisa do token pai <i>GetAncOfType ()</i> retornar√° o m√©todo na anota√ß√£o: <br><br><pre> <code class="java hljs">CxList webRemoteMethods = All.FindByCustomAttribute(<span class="hljs-string"><span class="hljs-string">"WebRemote"</span></span>) .GetAncOfType(typeof(MethodDecl)); result = webRemoteMethods;</code> </pre> <br><br>  Resultado da solicita√ß√£o: <br><br><img src="https://habrastorage.org/webt/rc/xt/q_/rcxtq_rfostgwmdtmwrfyg-9ly4.png"><br><br><h3>  IDOR: Etapa 4. Usando apenas tokens de ponto de entrada, localize os locais de extra√ß√£o HTTP para o par√¢metro mailboxid </h3><br>  Para encontrar tokens relacionados ao processamento do par√¢metro HTTP mailboxid: <br><br><pre> <code class="java hljs">CxList getMailboxId = All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxId\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + All.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxId;</code> </pre> <br>  n√≥s adicionamos 3 conjuntos com 3 linhas diferentes, porque  de acordo com a legenda, o nome do par√¢metro HTTP pode diferir em diferentes partes do sistema. <br><br>  A consulta encontrar√° todos os locais em que <i>mailboxid / mid / boxid √©</i> gravado como uma string (entre aspas duplas).  Mas essa consulta retornar√° muitas descobertas, tk.  essa sequ√™ncia pode ser encontrada n√£o apenas em locais onde os par√¢metros HTTP s√£o extra√≠dos.  Se continuarmos trabalhando com esse conjunto, obteremos um grande n√∫mero de descobertas falsas. <br><br>  Portanto, procuraremos apenas tokens de pontos de entrada ( <i>webRemoteMethods</i> ).  Para localizar todos os tokens filhos, a fun√ß√£o <i>CMBQL GetByAncs () √© usada</i> : <br><br><pre> <code class="java hljs">result = All.GetByAncs(webRemoteMethods);</code> </pre> <br>  A solicita√ß√£o retornar√° todos os tokens pertencentes aos m√©todos anotados como <i>WebRemote</i> .  J√° nesta fase, podemos filtrar os tokens dos m√©todos em que o propriet√°rio do objeto √© verificado.  Portanto, reescrevemos a consulta anterior para procurar tokens filhos de maneira a selecionar apenas os tokens filhos dos m√©todos <i>WebRemote</i> , onde n√£o h√° verifica√ß√£o de seguran√ßa para o propriet√°rio do objeto.  Para fazer isso, use um loop com a condi√ß√£o: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//          CxList entry_point_tokens = All.NewCxList(); //      webRemoteMethods foreach (CxList method in webRemoteMethods) { //        CxList method_tokens = All.GetByAncs(method); // ,       ,    owner if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { //  ,     , ,     } else { //  ,         entry_point_tokens.Add(method_tokens); } }</span></span></code> </pre><br>  Agora podemos fazer uma sele√ß√£o mais precisa usando os par√¢metros HTTP <i>mailboxid</i> : <br><br><pre> <code class="java hljs">CxList getMailboxHTTPParams = entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mailboxid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"mid\""</span></span>) + entry_point_tokens.FindByName(<span class="hljs-string"><span class="hljs-string">"\"boxid\""</span></span>); result = getMailboxHTTPParams;</code> </pre> <br>  Mas n√£o estamos interessados ‚Äã‚Äãnos locais onde os par√¢metros HTTP s√£o recuperados, mas nas vari√°veis ‚Äã‚Äã√†s quais s√£o atribu√≠dos os valores dos par√¢metros HTTP.  Como √© mais confi√°vel procurar o Flow precisamente por tokens de vari√°veis. <br><br>  A fun√ß√£o <i>CMxQL FindByInitialization ()</i> encontrar√° os locais de inicializa√ß√£o da vari√°vel para os tokens fornecidos: <br><br><pre> <code class="java hljs">CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); result = mailboxidInit;</code> </pre> <br>  Resultado: <br><br><img src="https://habrastorage.org/webt/cp/e7/5q/cpe75qru5pcwzikvaona3h7w67c.png"><br><br><h3>  IDOR: Etapa 5. Encontre todas as chamadas de webRemoteMethods para m√©todos e par√¢metros de middleware dessas chamadas </h3><br>  Por middleware, quero dizer c√≥digo mais profundo do que os m√©todos de processamento de solicita√ß√µes da API HTTP, ou seja, mais profundo do que os pontos de entrada das solicita√ß√µes do usu√°rio.  Por exemplo, para a captura de tela acima, estes s√£o m√©todos da classe <i>User</i> , chamadas para <i>user.getSettings ()</i> e <i>user.getSecureSettings ()</i> : <br><br><pre> <code class="java hljs">CxList middlewareMethods = All.FindByShortName(<span class="hljs-string"><span class="hljs-string">"user"</span></span>).GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); result = middlewareMethodsParams;</code> </pre> <br>  Primeiro, selecionamos todos os tokens com o nome user e, em seguida, usando <i>GetRightmostMember (),</i> selecionamos os tokens de chamada para o middleware.  <i>GetRightmostMember ()</i> na cadeia de chamadas de m√©todo retornar√° a mais √† direita.  Em seguida, derivamos os par√¢metros do m√©todo encontrado usando <i>GetParameters ()</i> . <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/8b/mm/2a/8bmm2ad7zg-xwponufdxuocn-t0.png"><br><br><h3>  IDOR: Etapa 6. Encontre m√©todos de middleware que dependem do mailboxid </h3><br>  A an√°lise de fluxo usa os <i>m√©todos</i> <i>* InfluencedBy *</i> e <i>* InfluncingOn *</i> .  A diferen√ßa entre eles √© clara pelo nome. <br><br>  Por exemplo: <br><br><pre> <code class="java hljs">All.InfluencedBy(getMailboxHTTPParams)</code> </pre> <br>  percorrer√° o conjunto All e encontrar√° todos os tokens que dependem de <i>getMailboxHTTPParams</i> . <br><br>  O mesmo pode ser escrito de outra maneira: <br><br><pre> <code class="java hljs">getMailboxHTTPParams.InfluencingOn(All)</code> </pre> <br><br>  Para procurar tokens dependentes de <i>mailboxidInit</i> : <br><br><pre> <code class="java hljs">CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); result = apiPotentialIDOR;</code> </pre><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/xl/wa/rq/xlwarqf4bvr96xchztinpiua7h4.png"><br><br><h3>  IDOR: Etapa 7. Encontre todos os locais para definir m√©todos de middleware </h3><br>  Vamos encontrar as defini√ß√µes de todos os m√©todos intermedi√°rios que podem ser usados ‚Äã‚Äãem locais onde as solicita√ß√µes dos usu√°rios s√£o processadas.  Para fazer isso, destacamos sua propriedade comum, por exemplo, em todos esses m√©todos, h√° a cria√ß√£o de um objeto <i>Request ()</i> , a cria√ß√£o de um objeto √© do tipo CMx <i>ObjectCreateExpr</i> : <br><br><pre> <code class="java hljs">CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName(<span class="hljs-string"><span class="hljs-string">"*Request*"</span></span>); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); result = middlewareDecl;</code> </pre> <br><br>  <i>(All - exclusionList)</i> - voc√™ pode fazer essa subtra√ß√£o de conjuntos e, em seguida, chamar a fun√ß√£o CMxQL desejada do resultado.  <i>As solicita√ß√µes</i> agora cont√™m todos os tokens com o nome <i>Solicita√ß√£o</i> e o tipo correspondente √† cria√ß√£o do objeto. <br><br>  Em seguida, usando o familiar <i>GetAncOfType (),</i> encontramos o token pai do tipo <i>MethodDecl</i> . <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/pp/ie/21/ppie21nmruhnqfekmune0fa5ytu.png"><br><br><h3>  IDOR: Etapa 8. Passe por todo o apiPotentialIDOR e selecione apenas o middlewareDecl no qual n√£o h√° verifica√ß√£o do propriet√°rio do objeto da caixa de correio </h3><br>  Na parte final da solicita√ß√£o, determinaremos quais dos m√©todos de middleware s√£o chamados diretamente dos m√©todos do ponto de entrada e n√£o verificaremos a quem o <i>id</i> da <i>caixa de correio</i> pertence.  Em seguida, combine o Flow para uma an√°lise mais conveniente dos resultados. <br><br>  Novos recursos que ainda n√£o usamos: <br>  <i>GetCxListByPath ()</i> - essa fun√ß√£o √© necess√°ria para iterar sobre o Flow, se n√£o for usada, o CMx compactar√° o Flow no Code Element (no primeiro n√≥ do flow) <br>  <i>Concatenar * ()</i> - um n√∫mero de fun√ß√µes necess√°rias para combinar v√°rios fluxos em um <br>  <i>FindByParameters ()</i> - encontre um m√©todo por um token de par√¢metro espec√≠fico <br>  <i>GetName ()</i> - retornar√° uma string com o nome do token, se houver mais de um elemento no CxList, retornar√° o primeiro.  O m√©todo √© usado apenas ao iterar sobre elementos de um conjunto. <br><br>  A parte final da solicita√ß√£o: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//    CxList vulns = All.NewCxList(); //   Flow  apiPotentialIDOR foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { //    Flow CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); //       flow (mailboxid) CxList method_call = entry_point_tokens.FindByParameters(endNode); //     CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); //     if (method_decl.Count &gt; 0) { //       CxList _all = (All - exclusionList).GetByAncs(method_decl); //       if (_all.FindByName(idorSanitizer).Count &gt; 0) { //  ,       cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); //  ,   Flow     vulns } else { //     Flow       vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } }</span></span></code> </pre> <br><br>  Resultado: <br><br><img src="https://habrastorage.org/webt/_z/qs/rj/_zqsrju8bqoni7u0ksolmokizhe.png"><br><br> <i>CocatenatePath</i>  ,          .     Code Element  Flow <br><br><h3> IDOR:     IDOR </h3><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// 1.   CxList exclusionList = All.FindByFileName("*WebMethodContext.java"); // 2.     CxList idorSanitizer = All.FindByName("*validateMailbox*"); // 3.    ‚Äì    HTTP  CxList webRemoteMethods = All.FindByCustomAttribute("WebRemote").GetAncOfType(typeof(MethodDecl)); // 4.         HTTP  mailboxid //     CxList entry_point_tokens = All.NewCxList(); foreach (CxList method in webRemoteMethods) { CxList method_tokens = All.GetByAncs(method); if (method_tokens.FindByName(idorSanitizer).Count &gt; 0) { } else { entry_point_tokens.Add(method_tokens); } } //    HTTP    -  CxList getMailboxHTTPParams = entry_point_tokens.FindByName("\"mailboxId\"") + entry_point_tokens.FindByName("\"mid\"") + entry_point_tokens.FindByName("\"boxid\""); CxList mailboxidInit = entry_point_tokens.FindByInitialization(getMailboxHTTPParams); // 5.      middleware     CxList middlewareMethods = All.FindByShortName("user").GetRightmostMember(); CxList middlewareMethodsParams = entry_point_tokens.GetParameters(middlewareMethods); // 6.  middleware ,     mailboxid CxList apiPotentialIDOR = entry_point_tokens.InfluencedByAndNotSanitized(mailboxidInit, idorSanitizer); // 7.      middleware      CxList requests = (All - exclusionList).FindByType(typeof(ObjectCreateExpr)).FindByName("*Request*"); CxList middlewareDecl = requests.GetAncOfType(typeof(MethodDecl)); // 8.    apiPotentialIDOR     middlewareDecl,      CxList vulns = All.NewCxList(); foreach(CxList cxFlow in apiPotentialIDOR.GetCxListByPath()) { CxList endNode = cxFlow.GetStartAndEndNodes(CxList.GetStartEndNodesType.EndNodesOnly); CxList method_call = entry_point_tokens.FindByParameters(endNode); CxList method_decl = middlewareDecl.FindByShortName(method_call.GetName()); if (method_decl.Count &gt; 0) { CxList _all = (All - exclusionList).GetByAncs(method_decl); if (_all.FindByName(idorSanitizer).Count &gt; 0) { cxLog.WriteDebugMessage("find sanitized in method: " + method_call.GetName()); } else { vulns.Add(cxFlow.ConcatenatePath(method_call).ConcatenatePath(method_decl)); cxLog.WriteDebugMessage("find NOT sanitized in method: " + method_call.GetName()); } } } result = vulns;</span></span></code> </pre><br><br><h2>  Conclus√£o </h2><br> Checkmarx      ,     .        ,      ,   ,     ..      Flow (    ).           ,         ,    ¬´¬ª . <br><br>     false positive,     : <br><ul><li>     ,       (   ). </li><li>     ,    (  ). ,     ¬´Privacy Violation¬ª,   ,         ,    Web UI.    , ..       UI    .       TLS        XSS     . </li><li>  -    ,           (,   ). ,   XXE  ,   , -    ,   . </li><li>   false positive,   ,           CMxQL   FindBy/GetBy.         ,     (        SQL). </li><li>   false positives,    ,      ,   ,       ,   CMx,      . ,       LDAP ,      .       c LDAP-   ,   ,      . </li></ul><br><br>   how-to     ¬´hello world¬ª  ,        Checkmarx. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt477742/">https://habr.com/ru/post/pt477742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt477732/index.html">Classifica√ß√£o errada dos dedos dos sistemas de navega√ß√£o subaqu√°tica</a></li>
<li><a href="../pt477734/index.html">Compreendendo o UICollectionViewLayout com o aplicativo Fotos</a></li>
<li><a href="../pt477736/index.html">O caminho do testador: do "freio de m√£o" √† automa√ß√£o</a></li>
<li><a href="../pt477738/index.html">iKassa ou como domamos o "caixa digital"</a></li>
<li><a href="../pt477740/index.html">E onde olhar para este telesc√≥pio com o olho?</a></li>
<li><a href="../pt477744/index.html">Por que os profissionais √†s vezes criam aplicativos ruins?</a></li>
<li><a href="../pt477746/index.html">Designer de monetiza√ß√£o: quem ele √© e como se tornar um</a></li>
<li><a href="../pt477752/index.html">Backend United # 5: Shawarma - Microsservi√ßos, Sistemas Distribu√≠dos e Kafka</a></li>
<li><a href="../pt477756/index.html">Como nos casamos com dois sistemas banc√°rios de CRM</a></li>
<li><a href="../pt477758/index.html">‚ÄúDoutor, retire isso da conta‚Äù: como procuramos servi√ßos ilegais na VHI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>