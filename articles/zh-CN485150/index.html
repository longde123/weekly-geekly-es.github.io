<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🚒 ☹️ 👩🏼‍🎨 移动PvP射击游戏的物理原理，或我们如何将二维游戏重新制作为三维游戏 🤴🏼 🈳 🕴🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在上一篇文章中，我的同事谈到了我们如何在移动多人射击游戏中使用二维物理引擎。 现在，我想分享一下我们如何抛弃以前所做的一切并从头开始-换句话说，我们如何将游戏从2D世界转移到3D。 

 一切始于这样一个事实，即制作人和领先的游戏设计师一旦来到我们的程序员部门，并给我们带来了挑战：必须在狭窄空间内进...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>移动PvP射击游戏的物理原理，或我们如何将二维游戏重新制作为三维游戏</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/485150/"><img src="https://habrastorage.org/webt/fo/if/az/foifazxdmxh_smqsswnkxhn0ww4.png"><br><br> 在<a href="https://habr.com/ru/company/pixonic/blog/481880/">上一篇文章中，</a>我的同事谈到了我们如何在移动多人射击游戏中使用二维物理引擎。 现在，我想分享一下我们如何抛弃以前所做的一切并从头开始-换句话说，我们如何将游戏从2D世界转移到3D。 <br><a name="habracut"></a><br> 一切始于这样一个事实，即制作人和领先的游戏设计师一旦来到我们的程序员部门，并给我们带来了挑战：必须在狭窄空间内进行射击的移动式PvP自上而下射击游戏必须转换为在开放区域射击的第三人称射击游戏。 在这种情况下，希望卡看起来不是这样： <br><br><img src="https://habrastorage.org/webt/he/j3/2p/hej32pvogui5sukjz842wjpyqry.png"><br><br> 依此类推： <br><br><img src="https://habrastorage.org/webt/n8/25/xw/n825xwkx_jsgqgoemkcor-r4ti0.jpeg"><br><br> 技术要求如下： <br><br><ul><li> 地图尺寸-100×100米； </li><li> 高差-40米； </li><li> 支持隧道，桥梁； </li><li> 向不同高度的目标射击； </li><li> 与静态几何体发生碰撞（我们与游戏中的其他角色没有碰撞）； </li><li> 自由落体物理学； </li><li> 手榴弹投掷物理。 </li></ul><br> 展望未来，我可以说我们的游戏看起来不像上一个屏幕截图：事实证明，这是第一个选项和第二个选项之间的交叉。 <br><br><h2> 选项一：分层结构 </h2><br> 提出第一个想法是不更改物理引擎，而只是添加几层“层数”级别。 原来这是建筑物的平面图： <br><br><img src="https://habrastorage.org/webt/lz/dy/oq/lzdyoquthw76ajisyvgqcn7zc_i.jpeg"><br><br> 使用这种方法，我们不需要从根本上重做客户端或服务器应用程序，并且通常看来，以这种方式可以很简单地解决任务。 但是，在尝试实现它时，我们遇到了几个关键问题： <br><br><ol><li> 在与关卡设计师澄清了细节之后，我们得出的结论是，这种方案中的“楼层”数量可以令人印象深刻：有些地图位于平缓坡度和丘陵的开放区域。 </li><li> 从一层射击到另一层时，命中率的计算成为一项艰巨的任务。 问题情况的示例如下图所示：在这里，玩家1可以进入玩家3，但不能进入玩家2，因为射击路径会阻塞第2层，尽管玩家2和玩家3都在同一层。 </li></ol><br><img src="https://habrastorage.org/webt/be/rg/be/bergbenv9gtcjzpkci26w_jmsik.png"><br><br> 简而言之，我们很快放弃了将空间划分为2D层的想法-决定我们将完全替换物理引擎来采取行动。 <br><br> 这导致我们需要选择这种引擎并将其构建到现有的客户端和服务器应用程序中。 <br><br><h2> 选项二：选择一个就绪库 </h2><br> 由于游戏客户端是用Unity编写的，因此我们决定考虑使用默认内置于Unity中的物理引擎PhysX的可能性。 总的来说，他完全满足了我们游戏设计师的要求，以支持游戏中的3D物理，但是仍然存在一个重大问题。 事实是我们的服务器应用程序是使用C＃编写的，而没有使用Unity。 <br><br> 可以选择在服务器上使用C ++库（例如，相同的PhysX），但我们并未认真考虑：由于使用本机代码，因此这种方法很可能导致服务器崩溃。 另外，Interop操作的生产率低下以及PhysX组件（仅在Unity下）的独特性（在其他环境中使用除外）也感到尴尬。 <br><br> 另外，在尝试实现此想法时，发现了其他问题： <br><br><ul><li> 缺乏在Linux上使用IL2CPP构建Unity的支持，这非常关键，因为在最新版本之一中，我们将游戏服务器切换到了.Net Core 2.1并将其部署在Linux机器上； </li><li> 缺乏在Unity上对服务器进行性能分析的便捷工具； </li><li>  Unity应用程序的性能低下：我们只需要一个物理引擎，而不需要Unity中所有可用的功能。 </li></ul><br> 此外，与我们的项目同时，该公司还在开发另一款多人PvP游戏原型。 它的开发人员使用Unity服务器，我们对建议的方法有很多负面反馈。 尤其值得一提的是，Unity服务器运行非常“流”，必须每隔几个小时重新启动一次。 <br><br> 这些问题的结合使我们也放弃了这个想法。 然后，我们决定将游戏服务器保留在.Net Core 2.1上，并选择使用C＃编写的另一个开放式物理引擎代替之前使用的VolatilePhysics。 也就是说，我们需要一个C＃引擎，因为我们在使用C ++编写的引擎时会担心意外崩溃。 <br><br> 结果，选择了以下引擎进行测试： <br><br><ul><li>  <a href="https://github.com/bepu/bepuphysics1">Bepu Physic v1</a> ； </li><li>  <a href="https://github.com/bepu/bepuphysics2">Bepu Physic v2；</a> </li><li>  <a href="https://github.com/mattleibow/jitterphysics">抖动物理；</a> </li><li>  <a href="https://github.com/ValtoLibraries/BulletSharp">子弹头</a> </li></ul><br> 对我们来说，主要标准是引擎的性能，将其集成到Unity中及其支持的可能性：如果我们发现其中的任何错误，都不应放弃它。 <br><br> 因此，我们测试了Bepu Physics v1，Bepu Physics v2和Jitter Physics引擎的性能，其中Bepu Physics v2被证明是效率最高的。 此外，他是这三位中唯一继续积极发展的人。 <br><br> 但是，Bepu Physics v2不满足Unity的最后一个集成标准：该库使用SIMD操作和System.Numerics，并且由于使用IL2CPP的移动设备上的程序集中不存在SIMD支持，因此Bepu优化的所有好处都丧失了。  iPhone 5S上的iOS版本中的演示场景非常慢。 我们无法在移动设备上使用此解决方案。 <br><br> 在这里应该解释为什么我们通常对使用物理引擎感兴趣。 在我以前的<a href="https://habr.com/ru/company/pixonic/blog/415959/">一篇文章中，</a>我谈到了我们如何实现游戏的网络部分以及本地预测玩家行为的方式。 简而言之，在客户端和服务器（ECS系统）上执行相同的代码。 客户无需等待服务器的响应即可立即响应玩家的行为-发生了所谓的预测。 当服务器发出响应时，客户端将使用接收到的响应检查世界的预测状态，如果不匹配（错误预测），则基于服务器的响应，对玩家看到的内容进行协调。 <br><br> 主要思想是我们在客户端和服务器上都执行相同的代码，并且错误预测的情况非常少见。 但是，在移动设备上工作时，我们发现没有物理C＃引擎能够满足我们的要求：例如，它无法在iPhone 5S上提供稳定的30 fps。 <br><br><h2> 选项三，最终：两个不同的引擎 </h2><br> 然后，我们决定进行实验：在客户端和服务器上使用两个不同的物理引擎。 我们认为在我们的情况下这可能行得通：我们的游戏中有一个非常简单的碰撞物理，此外，它是由我们作为单独的ECS系统实施的，而不是物理引擎的一部分。 物理引擎所需的一切就是在3D空间中制作reykast和扫播的能力。 <br><br> 因此，我们决定在客户端上使用内置的物理Unity-PhysX-在服务器上使用Bepu Physics v2。 <br><br> 首先，我们重点介绍了使用物理引擎的界面： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Prototype.Common.Physics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPhysicsWorld</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentSimulationTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tick</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SphereCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-function">RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, CollisionLayer layer, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleOverlap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ticksBehind = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOrphanedDynamicBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">WorldState.TableSet currentWorld</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, Vector3 position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> angle</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre> <br></div></div><br> 客户端和服务器对该接口有不同的实现：如前所述，在服务器上，我们将实现与Bepu一起使用，在客户端-Unity。 <br><br> 在这里值得一提的是在服务器上处理物理问题的细微差别。 <br><br> 由于客户端延迟（滞后）从服务器接收世界更新的事实，玩家看到的世界与他在服务器上看到的世界有些不同：他现在和过去都看到了自己。 因此，事实证明播放器在本地射击位于其他服务器上的目标。 因此，由于我们使用本地玩家动作预测系统，因此我们需要补偿在服务器上射击时的延迟。 <br><br><img src="https://habrastorage.org/webt/h5/gy/k3/h5gyk3svohmmd61k-xll9wq8zps.png"><br><br> 为了补偿它们，我们需要在服务器上存储最近N毫秒的世界历史，还需要处理历史中的物体，包括它们的物理性质。 就是说，我们的系统必须能够“过去”计算碰撞，rakcast和扫掠。 通常，物理引擎不知道如何执行此操作，使用PhysX的Bepu也不例外。 因此，我们必须自己实现此类功能。 <br><br> 由于我们以每秒30个滴答声的固定频率模拟游戏，因此我们必须为每个滴答声保存物理世界的数据。 这个想法不是在物理引擎中创建模拟的一个实例，而是创建N-对于存储在历史记录中的每个刻度-并使用这些模拟的循环缓冲区将它们存储在历史记录中： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SimulationSlice[] _simulationHistory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimulationSlice[PhysicsConfigs.HistoryLength]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BepupPhysicsWorld</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _currentSimulationTick = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; PhysicsConfigs.HistoryLength; i++) { _simulationHistory[i] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimulationSlice(_bufferPool); } }</code> </pre> <br> 在我们的ECS中，有许多适用于物理的读写系统： <br><br><ul><li>  InitPhysicsWorldSystem； </li><li>  SpawnPhysicsDynamicsBodiesSystem; </li><li>  DestroyPhysicsDynamicsBodiesSystem; </li><li>  UpdatePhysicsTransformsSystem; </li><li>  MovePhysicsSystem， </li></ul><br> 以及许多只读系统，例如用于计算射击命中，手榴弹爆炸等的系统。 <br><br> 在世界模拟的每个滴答中，首先执行InitPhysicsWorldSystem，它将当前滴答号（SimulationSlice）设置到物理引擎： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentSimulationTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> tick</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldTick = tick - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newSlice = _simulationHistory[tick % PhysicsConfigs.HistoryLength]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldSlice = _simulationHistory[oldTick % PhysicsConfigs.HistoryLength]; newSlice.RestoreBodiesFromPreviousTick(oldSlice); _currentSimulationTick = tick; }</code> </pre> <br>  RestoreBodiesFromPreviousTick方法从存储在历史记录中的数据中，在上次滴答时还原物理引擎中对象的位置： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreBodiesFromPreviousTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SimulationSlice previous</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldStaticCount = previous._staticIds.Count; <span class="hljs-comment"><span class="hljs-comment">// add created static objects for (int i = 0; i &lt; oldStaticCount; i++) { var oldId = previous._staticIds[i]; if (!_staticIds.Contains(oldId)) { var oldHandler = previous._staticIdToHandler[oldId]; var oldBody = previous._staticHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, true, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _staticHandlerToBody[handler] = body; } else { var handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, false, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Box = oldBody.Box; _staticHandlerToBody[handler] = body; } } } // delete not existing dynamic objects var newDynamicCount = _dynamicIds.Count; var idsToDel = stackalloc uint[_dynamicIds.Count]; int delIndex = 0; for (int i = 0; i &lt; newDynamicCount; i++) { var newId = _dynamicIds[i]; if (!previous._dynamicIds.Contains(newId)) { idsToDel[delIndex] = newId; delIndex++; } } for (int i = 0; i &lt; delIndex; i++) { var id = idsToDel[i]; var handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } // add created dynamic objects var oldDynamicCount = previous._dynamicIds.Count; for (int i = 0; i &lt; oldDynamicCount; i++) { var oldId = previous._dynamicIds[i]; if (!_dynamicIds.Contains(oldId)) { var oldHandler = previous._dynamicIdToHandler[oldId]; var oldBody = previous._dynamicHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, true, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _dynamicHandlerToBody[handler] = body; } else { var handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, false, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Box = oldBody.Box; _dynamicHandlerToBody[handler] = body; } } } }</span></span></code> </pre> <br></div></div><br> 之后，SpawnPhysicsDynamicsBodiesSystem和DestroyPhysicsDynamicsBodiesSystem系统根据上一次ECS滴答中的更改方式在物理引擎中创建或删除对象。 然后，UpdatePhysicsTransformsSystem根据ECS中的数据更新所有动态实体的位置。 <br><br> 一旦ECS和物理引擎中的数据同步，我们就可以计算对象的运动。 完成所有读写操作后，用于计算游戏逻辑（射击，爆炸，战争迷雾...）的只读系统开始起作用。 <br><br> 适用于Bepu Physics的完整SimulationSlice实现代码： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuPhysics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuPhysics.Collidables; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BepuUtilities.Memory; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Quaternion = BepuUtilities.Quaternion; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Prototype.Physics</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BepupPhysicsWorld</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimulationSlice</span></span> : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, StaticBody&gt; _staticHandlerToBody = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, StaticBody&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, DynamicBody&gt; _dynamicHandlerToBody = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, DynamicBody&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _staticIdToHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; _dynamicIdToHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; _staticIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt; _dynamicIds = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> BufferPool _bufferPool; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Simulation _simulation; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SimulationSlice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BufferPool bufferPool</span></span></span><span class="hljs-function">)</span></span> { _bufferPool = bufferPool; _simulation = Simulation.Create(_bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NarrowPhaseCallbacks(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PoseIntegratorCallbacks(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-9.81f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>))); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds=</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); BepupRayCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BepupRayCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.RayCast(origin, direction, distance, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _simulation.Bodies.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SphereCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); SweepCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.Sweep(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Sphere(radius), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(direction.Normalized()), distance, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(collidableReference.Handle, _simulation.Bodies); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = reference.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RayCastHit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleCast</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Vector3 direction, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> distance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, CollisionLayer layer, List&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; ignoreIds = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { direction = direction.Normalized(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; SweepCastHitHandler handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SweepCastHitHandler(_staticHandlerToBody, _dynamicHandlerToBody, layer, ignoreIds); _simulation.Sweep(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(direction.Normalized()), distance, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = handler.RayCastHit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.IsValid) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidableReference = handler.CollidableReference; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (handler.CollidableReference.Mobility == CollidableMobility.Static) { _simulation.Statics.GetDescription(collidableReference.Handle, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> description); result.HitEntityId = _staticHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = description.Pose.Position; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(collidableReference.Handle, _simulation.Bodies); result.HitEntityId = _dynamicHandlerToBody[collidableReference.Handle].Id; result.CollidableCenter = reference.Pose.Position; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapsuleOverlap</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, BodyMobilityField bodyMobilityField, CollisionLayer layer, List&lt;Overlap&gt; overlaps</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BepupOverlapHitHandler( bodyMobilityField, layer, _staticHandlerToBody, _dynamicHandlerToBody, overlaps); _simulation.Sweep( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose(origin, Quaternion.Identity), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyVelocity(Vector3.Zero), <span class="hljs-number"><span class="hljs-number">0</span></span>, _bufferPool, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Box(size.X, size.Y, size.Z); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = CreateDynamic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _dynamicHandlerToBody[handler]; body.Box = shape; _dynamicHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticBox</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, Vector3 size, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Box(size.X, size.Y, size.Z); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler =CreateStatic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _staticHandlerToBody[handler]; body.Box = shape; _staticHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateStaticCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler =CreateStatic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _staticHandlerToBody[handler]; body.Capsule = shape; _staticHandlerToBody[handler] = body; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateDynamicCapsule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 origin, Quaternion rotation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> radius, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> height, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, CollisionLayer layer</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = height - <span class="hljs-number"><span class="hljs-number">2</span></span> * radius; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shape = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Capsule(radius, length); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pose = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RigidPose() { Position = origin, Orientation = rotation }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = CreateDynamic(shape, pose, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, id, layer); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> body = _dynamicHandlerToBody[handler]; body.Capsule = shape; _dynamicHandlerToBody[handler] = body; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreateDynamic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isCapsule, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> id, CollisionLayer collisionLayer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TShape : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, IShape { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyActivityDescription() { SleepThreshold = <span class="hljs-number"><span class="hljs-number">-1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> collidable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollidableDescription() { Shape = _simulation.Shapes.Add(shape), SpeculativeMargin = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleDescription = BodyDescription.CreateKinematic(pose, collidable, activity); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _simulation.Bodies.Add(capsuleDescription); _dynamicIds.Add(id); _dynamicIdToHandler.Add(id, handler); _dynamicHandlerToBody.Add(handler, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicBody { BodyReference = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BodyReference(handler, _simulation.Bodies), Id = id, IsCapsule = isCapsule, CollisionLayer = collisionLayer }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CreateStatic&lt;TShape&gt;(TShape shape, RigidPose pose, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isCapsule, <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> id, CollisionLayer collisionLayer) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TShape : <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>, IShape { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleDescription = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticDescription() { Pose = pose, Collidable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CollidableDescription() { Shape = _simulation.Shapes.Add(shape), SpeculativeMargin = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _simulation.Statics.Add(capsuleDescription); _staticIds.Add(id); _staticIdToHandler.Add(id, handler); _staticHandlerToBody.Add(handler, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticBody { Description = capsuleDescription, Id = id, IsCapsule = isCapsule, CollisionLayer = collisionLayer }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveOrphanedDynamicBodies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TableSet currentWorld</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toDel = <span class="hljs-keyword"><span class="hljs-keyword">stackalloc</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span>[_dynamicIds.Count]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toDelIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _dynamicIdToHandler) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentWorld.DynamicPhysicsBody.HasCmp(i.Key)) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } toDel[toDelIndex] = i.Key; toDelIndex++; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; toDelIndex; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = toDel[i]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasBody</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _staticIdToHandler.ContainsKey(id) || _dynamicIdToHandler.ContainsKey(id); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreBodiesFromPreviousTick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SimulationSlice previous</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> oldStaticCount = previous._staticIds.Count; <span class="hljs-comment"><span class="hljs-comment">// add created static objects for (int i = 0; i &lt; oldStaticCount; i++) { var oldId = previous._staticIds[i]; if (!_staticIds.Contains(oldId)) { var oldHandler = previous._staticIdToHandler[oldId]; var oldBody = previous._staticHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateStatic(oldBody.Capsule, oldBody.Description.Pose, true, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _staticHandlerToBody[handler] = body; } else { var handler = CreateStatic(oldBody.Box, oldBody.Description.Pose, false, oldId, oldBody.CollisionLayer); var body = _staticHandlerToBody[handler]; body.Box = oldBody.Box; _staticHandlerToBody[handler] = body; } } } // delete not existing dynamic objects var newDynamicCount = _dynamicIds.Count; var idsToDel = stackalloc uint[_dynamicIds.Count]; int delIndex = 0; for (int i = 0; i &lt; newDynamicCount; i++) { var newId = _dynamicIds[i]; if (!previous._dynamicIds.Contains(newId)) { idsToDel[delIndex] = newId; delIndex++; } } for (int i = 0; i &lt; delIndex; i++) { var id = idsToDel[i]; var handler = _dynamicIdToHandler[id]; _simulation.Bodies.Remove(handler); _dynamicHandlerToBody.Remove(handler); _dynamicIds.Remove(id); _dynamicIdToHandler.Remove(id); } // add created dynamic objects var oldDynamicCount = previous._dynamicIds.Count; for (int i = 0; i &lt; oldDynamicCount; i++) { var oldId = previous._dynamicIds[i]; if (!_dynamicIds.Contains(oldId)) { var oldHandler = previous._dynamicIdToHandler[oldId]; var oldBody = previous._dynamicHandlerToBody[oldHandler]; if (oldBody.IsCapsule) { var handler = CreateDynamic(oldBody.Capsule, oldBody.BodyReference.Pose, true, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Capsule = oldBody.Capsule; _dynamicHandlerToBody[handler] = body; } else { var handler = CreateDynamic(oldBody.Box, oldBody.BodyReference.Pose, false, oldId, oldBody.CollisionLayer); var body = _dynamicHandlerToBody[handler]; body.Box = oldBody.Box; _dynamicHandlerToBody[handler] = body; } } } } public void Update() { _simulation.Timestep(GameState.TickDurationSec); } public void UpdateBody(uint id, Vector3 position, float angle) { if (_staticIdToHandler.TryGetValue(id, out var handler)) { _simulation.Statics.GetDescription(handler, out var staticDescription); staticDescription.Pose.Position = position; staticDescription.Pose.Orientation = Quaternion.CreateFromAxisAngle(new Vector3(0, 1, 0), angle); _simulation.Statics.ApplyDescription(handler, staticDescription); } else if(_dynamicIdToHandler.TryGetValue(id, out handler)) { BodyReference reference = new BodyReference(handler, _simulation.Bodies); reference.Pose.Position = position; reference.Pose.Orientation = Quaternion.CreateFromAxisAngle(new Vector3(0, 1, 0), angle); } } public void Dispose() { _simulation.Clear(); } } public void Dispose() { _bufferPool.Clear(); } } }</span></span></code> </pre> <br></div></div><br> 另外，除了在服务器上实现历史记录之外，我们还需要在客户端上实现物理历史记录。 我们的Unity客户端具有服务器仿真模式（我们称为本地仿真），在该模式下，服务器代码与客户端一起运行。 我们使用此模式来快速制作游戏功能原型。 <br><br> 与Bepu一样，PhysX也没有历史记录支持。 在这里，我们对服务器上的每个历史记录使用了几次物理模拟，使用了相同的想法。 但是，Unity在使用物理引擎时强加了自己的细节。 但是，应该注意的是，我们的项目是在Unity 2018.4（LTS）上开发的，某些API可能会在较新的版本中更改，因此不会出现像我们这样的问题。 <br><br> 问题在于，Unity不允许创建单独的物理模拟（或用PhysX术语表示为场景），因此我们在Unity上的物理历史中将每个滴答实现为单独的场景。 <br><br> 在此类情况下编写了包装器类-UnityPhysicsHistorySlice： <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnityPhysicsHistorySlice</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SphereCastDelegate sphereCastDelegate, OverlapSphereNonAlloc overlapSphere, CapsuleCastDelegate capsuleCast, OverlapCapsuleNonAlloc overlapCapsule, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { _scene = SceneManager.CreateScene(name, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CreateSceneParameters() { localPhysicsMode = LocalPhysicsMode.Physics3D }); _physicsScene = _scene.GetPhysicsScene(); _sphereCast = sphereCastDelegate; _capsuleCast = capsuleCast; _overlapSphere = overlapSphere; _overlapCapsule = overlapCapsule; _boxPool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhysicsSceneObjectsPool&lt;BoxCollider&gt;(_scene, <span class="hljs-string"><span class="hljs-string">"box"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); _capsulePool = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhysicsSceneObjectsPool&lt;UnityEngine.CapsuleCollider&gt;(_scene, <span class="hljs-string"><span class="hljs-string">"sphere"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Unity的第二个问题是，所有与物理学有关的工作都是通过Physics静态类完成的，该类的API不允许您在特定场景中执行rakecast和scancast。 该API仅适用于一个活动场景。 但是，PhysX引擎本身允许您同时处理多个场景，只需要调用正确的方法即可。 幸运的是，Unity将此类方法隐藏在Physics.cs类接口的后面，剩下的就是访问它们。 我们这样做是这样的： <br><br><div class="spoiler">  <b class="spoiler_title">查看代码</b> <div class="spoiler_text"><pre> <code class="cs hljs">MethodInfo raycastMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"Internal_SphereCast"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sphereCast = (SphereCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(SphereCastDelegate), raycastMethod); MethodInfo overlapSphereMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"OverlapSphereNonAlloc_Internal"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overlapSphere = (OverlapSphereNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(OverlapSphereNonAlloc), overlapSphereMethod); MethodInfo capsuleCastMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"Internal_CapsuleCast"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capsuleCast = (CapsuleCastDelegate) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(CapsuleCastDelegate), capsuleCastMethod); MethodInfo overlapCapsuleMethod = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Physics).GetMethod(<span class="hljs-string"><span class="hljs-string">"OverlapCapsuleNonAlloc_Internal"</span></span>, BindingFlags.NonPublic | BindingFlags.Static); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> overlapCapsule = (OverlapCapsuleNonAlloc) Delegate.CreateDelegate(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(OverlapCapsuleNonAlloc), overlapCapsuleMethod);</code> </pre> <br></div></div><br> 否则，用于实现UnityPhysicsHistorySlice的代码与BepuSimulationSlice中的代码没有太大不同。 <br><br> 因此，我们获得了两种游戏物理实现：在客户端和服务器上。 <br><br> 下一步是测试。 <br><br> 客户的“健康状况”最重要的指标之一是服务器误判次数的参数。 在切换到不同的物理引擎之前，该指标在1-2％范围内变化-也就是说，在持续9000滴答声（或5分钟）的战斗中，我们被误认为是90-180滴答声。 我们在软休息室中通过游戏的多个发行版获得了这些结果。 切换到不同的引擎后，我们预计该指标会强劲增长-甚至可能是几十倍-毕竟，现在我们在客户端和服务器上执行了不同的代码，而且不同算法的计算错误会迅速累积，这似乎是合乎逻辑的。 实际上，事实证明，差异参数仅增长0.2-0.5％，平均每场战斗2-2.5％，这完全适合我们。 <br><br> 我们研究的大多数引擎和技术在客户端和服务器上都使用相同的代码。 但是，我们关于使用不同物理引擎的可能性的假设得到了证实。 差异率如此之小增长的主要原因是我们使用ECS系统之一来计算物体在空间中的运动和碰撞。 客户端和服务器上的代码均相同。 从物理引擎上，我们需要快速计算瑞克广播和扫视广播，并且在实践中，对于我们的两个引擎而言，这些操作的结果相差无几。 <br><br><h2> 读什么 </h2><br> 总之，与往常一样，这里有一些相关链接： <br><br><ul><li>  <a href="https://habr.com/ru/company/pixonic/blog/481880/">移动PvP射击游戏的物理原理，第1部分</a> ； </li><li>  <a href="https://habr.com/ru/company/pixonic/blog/415959/">移动PvP射击游戏的网络代码</a> ; </li><li>  <a href="https://gafferongames.com/">Glen Fiedler的博客，介绍如何在游戏中编写网络代码</a> ； </li><li>  <a href="https://www.gdcvault.com/play/1026322/Back-to-the-Future-Working">For Honor中的确定性仿真和网络代码</a> 。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN485150/">https://habr.com/ru/post/zh-CN485150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN485136/index.html">Istio跟踪和监视：微服务和不确定性原则</a></li>
<li><a href="../zh-CN485138/index.html">应用程序本地化：我们如何交友翻译和开发</a></li>
<li><a href="../zh-CN485144/index.html">我如何修复损坏的基座以及它的作用</a></li>
<li><a href="../zh-CN485146/index.html">根据Habr Career计算器，2019年下半年的IT薪酬</a></li>
<li><a href="../zh-CN485148/index.html">这个可爱的Unicode</a></li>
<li><a href="../zh-CN485152/index.html">在Redmadrobot的移动开发人员春季实习</a></li>
<li><a href="../zh-CN485154/index.html">如何通过开发人员打造品牌怪胎：程序员激励系统</a></li>
<li><a href="../zh-CN485156/index.html">如何成为国内众筹（第一部分）</a></li>
<li><a href="../zh-CN485158/index.html">尼古拉·瓦维洛夫（Nikolay Vavilov）。 想要养活整个世界并在监狱牢房中饿死的人</a></li>
<li><a href="../zh-CN485160/index.html">我对ACID的看法是什么？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>