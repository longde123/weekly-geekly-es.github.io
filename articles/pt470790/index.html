<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😖 💅🏻 🤢 Resolvemos tarefas Yandex.Interview em um estilo funcional 👩🏾‍⚕️ 🏇🏻 ♋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns meses atrás, um artigo apareceu no blog da Yandex que discutia a passagem da seção algorítmica da entrevista. Entre outras coisas, neste artigo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resolvemos tarefas Yandex.Interview em um estilo funcional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Alguns meses atrás, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> apareceu no blog da Yandex que discutia a passagem da seção algorítmica da entrevista.  Entre outras coisas, neste artigo, foi fornecido um link para um concurso especial contendo tarefas semelhantes às oferecidas pelo Yandex aos seus candidatos. </p><br><p>  Tendo me registrado no sistema, minha atenção foi imediatamente atraída pela capacidade de resolver problemas no Haskell.  O fato é que, embora eu goste de programar nessa linguagem, não progredi além da implementação de tarefas de vários cursos de plataformas educacionais on-line.  Tendo decidido que a solução deles pode ser um desafio interessante e aumentará meu nível como desenvolvedor, passei a resolvê-los. </p><br><p>  Quem se importa com o que acabou por vir, bem-vindo ao gato. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Pedras e jóias </h2><br><blockquote> Duas linhas de caracteres latinos minúsculos são fornecidas: cadeia J e cadeia S. Os caracteres incluídos na cadeia J são “jóias” e incluídos na cadeia S são “pedras”.  É necessário determinar quantos caracteres de S são simultaneamente "jóias".  Simplificando, você precisa verificar quantos caracteres de S estão em J. </blockquote><p>  A primeira tarefa é um aquecimento, vamos resolvê-lo “na testa”.  Definimos a função <em>jeweleryCount :: String -&gt; String -&gt; Int</em> , que, usando a convolução da lista passada pelo segundo argumento, resume todos os casos do item que está sendo processado na primeira lista.  Para esses fins, definimos a função <em>elemInt com</em> base na função <em>elem</em> , que, diferentemente da última, retornará não Verdadeiro ou Falso, mas o número 0 ou 1. Na função principal, você só precisa ler duas linhas, passá-las para a função correspondente e imprimir o resultado.  O veredicto do sistema de teste está OK, passamos para a segunda tarefa. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>O código fonte para resolver esta e outras tarefas também está disponível no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">repositório</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">github.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Unidades consecutivas </h2><br><blockquote>  É necessário encontrar a seqüência mais longa de unidades no vetor binário e imprimir seu comprimento. </blockquote><p>  Para resolver esse problema, implementamos uma função recursiva que percorre a lista transferida e calcula o comprimento da sequência necessária.  Com os argumentos da função, além da própria lista, transmitiremos o comprimento máximo atual e o número de unidades consecutivas na chamada atual.  Primeiro, definimos a base da recursão na lista vazia e, em seguida, a própria recursão. </p><br><p>  Para ler a entrada, definimos a função <em>getUserInputs :: IO [Char]</em> , na qual lemos primeiro o número n - o tamanho da lista e, em seguida, usando o combinador <em>replicateM</em> , obtemos uma função que chama a função <em>&lt;&lt;get&gt; getLine</em> n times e mescla os resultados em uma lista . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  Nós enviamos a decisão, o veredicto está OK.  Nós seguimos em frente. </p><br><h2 id="c-udalenie-dublikatov">  C. Remoção duplicada </h2><br><blockquote>  É fornecida uma matriz de números inteiros de 32 bits ordenados em ordem não decrescente.  É necessário remover todas as repetições dele. </blockquote><p>  Vamos começar com uma implementação simples.  Definimos uma função inicial que lê um número, o imprime e o retorna envolto na mônada de E / S.  Também definimos a função <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , que lê um número e o imprime apenas se não for igual ao segundo argumento (passaremos o número lido na etapa anterior).  Depois disso, a função se chama recursivamente e, assim, prossegue para o próximo número no fluxo de entrada.  A base de recursão é o número de números a serem lidos; passaremos para o primeiro argumento. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Enviamos a solução, ela passa em todos os testes e parece que podemos passar para a próxima tarefa, mas, na minha opinião, a chamada recursiva da função que trabalha na mônada de IO é mais confusa do que concisa.  Vamos tentar melhorá-lo. </p><br><p>  Observe que, de um modo geral, você pode primeiro ler a lista inteira de números (usaremos o combinador replicateM já familiarizado com a segunda tarefa), depois passá-lo para uma função pura que filtra todas as repetições e, finalmente, imprime o resultado. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  Estou enviando uma solução e a primeira decepção é que o programa não passa no teste 193 devido a exceder o limite de memória usada.  O principal erro é ler a lista inteira na memória completamente.  Vamos tentar evitar isso e implementar um certo híbrido da primeira e da segunda versões. </p><br><p>  Observe que a tarefa de remover duplicatas lembra um pouco a convolução associativa à esquerda: em cada etapa calculamos uma função que, dependendo do item atual lido e de alguns de seus resultados, na etapa anterior decide imprimir e prossegue para o próximo par de valores. </p><br><p>  Uma função que imprime ou não imprime o resultado dependendo de seus argumentos, após o qual retorna seu segundo argumento, envolto na mônada IO, é bastante simples, vamos chamá-lo de etapa: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  Nós descobrimos se devemos ou não imprimir, dependendo dos valores passados, mas como organizar a leitura?  Para fazer isso, usamos a função de convolução monádica <em>foldM :: (Foldable t, Monad m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , aplicável à lista de funções de leitura. <br>  Por tipo de função foldM, notamos que a cada passo a “descompactação” do resultado da aplicação anterior da função ocorre sob o capô da própria foldM.  Assim, em cada etapa, precisamos apenas iniciar um cálculo monádico do item da lista atual (de fato, ler o próximo número) usando o operador de <em>ligação</em> ( <em>&gt;&gt; =</em> ) e passá-lo junto com o número anterior para a etapa.  Como resultado, obtemos o seguinte programa </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. Geração de sequências de colchetes </h2><br><blockquote>  Dado um número inteiro n.  É necessário derivar todas as seqüências de colchetes corretas de comprimento 2 ⋅ n, ordenadas lexicograficamente (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  Somente parênteses são usados ​​na tarefa. <br>  É aconselhável obter uma solução que funcione em um tempo proporcional ao número total de seqüências de colchetes corretas na resposta e, ao mesmo tempo, use uma capacidade de memória proporcional a n. </blockquote><p>  Essa tarefa, como muitas outras, nas quais é necessário derivar seqüências que atendam a certas condições (por exemplo, a tarefa de trocar moedas, organizar oito rainhas e outras, pode ser lida com mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">aqui</a> ), é resolvida de forma sucinta usando a lista mônada.  Em suma, essa abordagem é baseada na ligação monádica para listas, cujo significado é unir o conjunto de operações realizadas em cada elemento da lista. </p><br><p>  Defina a função recursiva <em>generate ':: Int -&gt; Int -&gt; [[Char]]</em> , que leva o número de colchetes a serem colocados como segundo argumento e o número de colchetes de abertura não fechados já definido.  Para a etapa de recursão, precisamos de duas funções auxiliares: <em>possível</em> - retorna uma lista de colchetes que podem ser colocados na próxima etapa e <em>etapa</em> - faz uma chamada recursiva para a função generate 'com os parâmetros necessários. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Enviamos a solução e entendemos que não levamos em conta a restrição que foi imposta à quantidade de memória usada pelo programa - a solução não passa no 14º teste por exceder o limite de memória usada. </p><br><p>  Modificamos a função generate 'para que, em vez de construir toda a lista de sequências de colchetes corretas, ela as exiba imediatamente na tela.  Para fazer isso, teremos que adicionar o terceiro argumento à função - um fragmento da sequência construída para a etapa atual.  Observo que, nesta implementação, construiremos a sequência na ordem inversa - isso nos permitirá usar o construtor list ( <em>:) em</em> vez do operador de concatenação mais caro ( <em>++</em> ). </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagramas </h2><br><blockquote>  Duas linhas são dadas, consistindo em letras latinas minúsculas.  É necessário determinar se essas linhas são anagramas, ou seja, elas diferem apenas na sequência de caracteres. </blockquote><p>  Para resolver esse problema, contaremos quantas vezes uma carta ocorre em cada linha e comparamos os resultados.  Entendemos imediatamente que as listas padrão não são adequadas para nós e é necessário usar uma estrutura de dados que nos permita acessar efetivamente o elemento pelo seu índice.  Existem vários tipos de dados que satisfariam nossas condições, mas usaremos a matriz imutável padrão <em>Data.Array</em> (ainda existem pelo menos várias matrizes mutáveis, bem como <em>Data.Vector</em> ). </p><br><p>  Para construir as matrizes necessárias, usamos a função <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Matriz ab</em> , que, de acordo com a lista transferida de elementos e o intervalo ao qual esses elementos devem pertencer, forma uma matriz, que armazena o número de repetições de elementos da lista.  Essa função, embora não esteja incluída no módulo Data.Array, geralmente é fornecida como um exemplo do uso de outra função já existente na biblioteca, o acumArray.  Só podemos copiar sua implementação e escrever main - o benefício da comparação de igualdade para <em>Array Char Int</em> já <em>está</em> definido.  Chamo sua atenção para um recurso interessante - como índice, podemos usar não apenas números inteiros, mas também qualquer representante da classe <em>Ix</em> .  No nosso caso, Char desempenha um papel natural nesse papel. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  F. Mesclar k listas ordenadas </h2><br><blockquote>  Dadas k matrizes de números inteiros não negativos classificadas em ordem não decrescente, cada uma das quais não excede 100. É necessário construir o resultado de sua fusão: uma matriz classificada em ordem não decrescente contendo todos os elementos das matrizes k originais. <br>  O comprimento de cada matriz não excede 10 k. <br>  Tente fazer a solução funcionar pelo tempo k ⋅ log (k) ⋅ n, se assumirmos que as matrizes de entrada são de comprimento n. </blockquote><p>  Mesclar duas listas ordenadas é uma tarefa clássica da lista e é abordada em muitos cursos sobre programação Haskell.  Por exemplo, pode ser resolvido da seguinte maneira. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Bem, podemos mesclar duas listas.  E o que devemos fazer com a lista de listas?  Convolva-o com esta função!  Assim, combinaremos todas as listas em uma e teremos apenas que imprimi-las. </p><br><div class="spoiler">  <b class="spoiler_title">Solução</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Entretanto, esta solução tem dois problemas sérios - a complexidade computacional é maior que a necessária - <em>O (k ^ 2 ⋅ n) em</em> vez de <em>O (k ⋅ log (k) ⋅ n)</em> , além de usar muita memória adicional.  Como resultado, esta solução falha no número de teste 17 devido a exceder o limite de memória usada - 17,27 Mb em vez dos 10 Mb permitidos. </p><br><p>  Embora não prestemos atenção ao fato de que os números fornecidos à entrada pertencem a um intervalo limitado de valores, continuamos a procurar soluções para um caso mais geral. </p><br><p>  O próximo passo é tentar implementar a abordagem proposta no artigo original com a análise dessas tarefas.  Deixe-me lembrá-lo de que é baseado no uso de uma estrutura de dados que fornece uma maneira eficiente de extrair o elemento mínimo.  Como tal estrutura, selecione <em>Data.Set</em> .  Inicializamos Set com a lista dos primeiros elementos; em cada etapa, extraímos e imprimimos o elemento mínimo e, em seguida, adicionamos o próximo elemento da lista correspondente.  Além disso, precisaremos de uma estrutura <em>Data.Sequence</em> para armazenar as próprias listas.  Foi escolhido por razões de que, em cada etapa, é necessário ter acesso rápido à lista por seu índice (que a lista não pode fornecer) e alterar o elemento desse elemento sem a necessidade de copiar toda a estrutura (que em geral não pode fornecer <em>Dados</em> imutáveis <em>. Matriz</em> ). </p><br><p>  Assim, temos o seguinte programa: </p><br><div class="spoiler">  <b class="spoiler_title">Solução</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Enviamos a solução e descobrimos que, embora o programa tenha começado a consumir muito menos memória (10,26 Mb em vez de 17,27 Mb no 17º teste), ele ainda não atingiu o limite.  A razão disso está no fato de que, com essa decisão, de uma forma ou de outra, precisamos ler todos os dados de entrada na memória.  Vamos tentar evitar isso com a ajuda da terceira solução para esse problema - classificando por contagem. </p><br><p>  Já executamos a contagem do número de caracteres recebidos ao resolver o problema anterior do anagrama.  Além disso, como para resolvê-lo, usaremos <em>Data.Array</em> .  Primeiro, implementamos a função <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , que forma uma matriz com base na existente, aumentando os valores nos índices que correspondem aos valores da lista. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Em seguida, usaremos a abordagem conhecida por nós no problema de remover repetições - usando a convolução monádica, aplicando sequencialmente a função <em>addToArray</em> em <em>k</em> matrizes de origem.  E ... obtemos o mesmo resultado de 10,26 Mb no 17º teste.  E então é hora de lembrar que <em>foldl</em> (cujo análogo é <em>foldM</em> ) de acordo com a ordem de redução aceita primeiro expandirá toda a cadeia de expressões aninhadas e só então prosseguirá para o cálculo ativo.  Como você sabe, para combater esse fato, o módulo <em>Data.List</em> implementa a função <em>foldl</em> <em>'</em> , que usa a função <em>seq :: a -&gt; b -&gt; b</em> , que primeiro lança o primeiro argumento na forma normal da cabeça fraca, ou seja, reduz a parte externa - o valor da função ou construtor e, em seguida, retorna o segundo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  Não temos escolha a não ser implementar a função <em>foldM 'independentemente</em> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  Como resultado, a quantidade de memória usada no 17º teste quase caiu pela metade e totalizou 5.64Mb!  Embora os testes 17 e 18 tenham sido aprovados com êxito, essa implementação não passou no 19º teste pelo mesmo motivo que o limite de memória foi excedido - 10,25Mb. </p><br><p>  Ok, siga em frente - ainda não experimentamos o Data.Array.Unboxed.  Esse tipo de matriz é digno de nota, pois, diferentemente do padrão, ele pode armazenar os próprios valores, em vez de apontar para eles ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  Devido a isso, essas matrizes ocupam menos espaço de memória e são mais eficientes.  Para usá-los, precisamos apenas alterar os tipos de importação e função, pois o <em>Data.Array</em> e o <em>Data.Array.Unboxed</em> implementam uma interface de matrizes imutáveis ​​do <em>IArray</em> . </p><br><p>  Estamos enviando uma solução - o consumo de memória diminuiu 4,5 vezes para 2,26 MB, mas não ultrapassou o limite de tempo - o tempo de execução foi de 1,09 segundos.  Com o que isso poderia estar conectado?  A julgar pelo fato de que o tempo de execução dos testes restantes permanece o mesmo, acho que o motivo não é que a matriz sem caixa tenha sido mais lenta que a caixa, mas em particular o sistema de teste.  Parece que a tarefa é interrompida assim que uma das restrições é violada.  No entanto, em casos muito raros, essa implementação ainda passa no 19º teste com um resultado de 0,98 segundos, mas falha no teste número 20 também devido ao excedente do prazo. </p><br><p>  Depois disso, tentei usar o analógico inseguro da função acum, que em teoria deveria ser mais rápido, vários métodos de buffer (função <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; IO ()</em> ), matrizes mutáveis ​​de <em>IOArray</em> , mas nenhum desses métodos <em>produziu</em> resultados . </p><br><p>  Não estou inclinado a acreditar que os limites para Haskell são muito rígidos e espero que ainda exista uma solução que passe em todos os testes.  No repositório do projeto, publiquei várias versões diferentes do código para resolver esse problema (com Array e IOArray), talvez este seja o ponto de partida para uma solução que passará em todos os testes. </p><br><h2 id="zaklyuchenie">  Conclusão </h2><br><p>  Mesmo apesar de apenas cinco das seis tarefas terem me sucumbido, concluí minha tarefa principal - praticar a programação funcional.  Não menos importante foi o papel de severas restrições aos recursos consumidos pelo programa, o que nos forçou a procurar cada vez mais novas abordagens para solucionar problemas.  Espero que a descrição deles seja útil para aqueles que estão começando sua jornada na programação funcional </p><br><p>  A abordagem funcional foi conveniente para resolver esses problemas?  Honestamente, tenho uma dupla impressão.  Por um lado, as soluções para a maioria dos problemas se mostraram muito concisas e as ferramentas expressivas do próprio Haskell, bem como de sua rica biblioteca padrão, tiveram um papel significativo nisso.  Por outro lado, não se pode deixar de admitir que, na maioria dos casos, o gerenciamento de recursos consumidos pode ser um determinado problema, o que não permitirá solucionar o problema nas restrições especificadas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470790/">https://habr.com/ru/post/pt470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470778/index.html">Revisão do drive Seagate ST2000DM008: rápido "dois" sem preço excessivo</a></li>
<li><a href="../pt470780/index.html">A barra está pronta - o novo da Seagate para armazenamento</a></li>
<li><a href="../pt470782/index.html">Dados na fronteira: como criar uma nova arquitetura de TI</a></li>
<li><a href="../pt470784/index.html">O design de cores dos mundos misteriosos de células mortas</a></li>
<li><a href="../pt470786/index.html">Preparando-se para a certificação profissional da Spring. Segurança de primavera</a></li>
<li><a href="../pt470792/index.html">Entrevista com um dos criadores do jogo Untitled Goose</a></li>
<li><a href="../pt470794/index.html">Laravel: explique os conceitos básicos. Parte Um: Teoria</a></li>
<li><a href="../pt470800/index.html">P - antecipação, bem como o Programa Preliminar DUMP Kazan. Veja os relatórios que passaram na seleção do moedor de carne</a></li>
<li><a href="../pt470802/index.html">Backup, Parte 6: Comparando ferramentas de backup</a></li>
<li><a href="../pt470804/index.html">Prêmio Alice: 5 idéias do vencedor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>