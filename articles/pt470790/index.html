<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòñ üíÖüèª ü§¢ Resolvemos tarefas Yandex.Interview em um estilo funcional üë©üèæ‚Äç‚öïÔ∏è üèáüèª ‚ôãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alguns meses atr√°s, um artigo apareceu no blog da Yandex que discutia a passagem da se√ß√£o algor√≠tmica da entrevista. Entre outras coisas, neste artigo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Resolvemos tarefas Yandex.Interview em um estilo funcional</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470790/"><p>  Alguns meses atr√°s, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um artigo</a> apareceu no blog da Yandex que discutia a passagem da se√ß√£o algor√≠tmica da entrevista.  Entre outras coisas, neste artigo, foi fornecido um link para um concurso especial contendo tarefas semelhantes √†s oferecidas pelo Yandex aos seus candidatos. </p><br><p>  Tendo me registrado no sistema, minha aten√ß√£o foi imediatamente atra√≠da pela capacidade de resolver problemas no Haskell.  O fato √© que, embora eu goste de programar nessa linguagem, n√£o progredi al√©m da implementa√ß√£o de tarefas de v√°rios cursos de plataformas educacionais on-line.  Tendo decidido que a solu√ß√£o deles pode ser um desafio interessante e aumentar√° meu n√≠vel como desenvolvedor, passei a resolv√™-los. </p><br><p>  Quem se importa com o que acabou por vir, bem-vindo ao gato. </p><a name="habracut"></a><br><h2 id="a-kamni-i-ukrasheniya">  A. Pedras e j√≥ias </h2><br><blockquote> Duas linhas de caracteres latinos min√∫sculos s√£o fornecidas: cadeia J e cadeia S. Os caracteres inclu√≠dos na cadeia J s√£o ‚Äúj√≥ias‚Äù e inclu√≠dos na cadeia S s√£o ‚Äúpedras‚Äù.  √â necess√°rio determinar quantos caracteres de S s√£o simultaneamente "j√≥ias".  Simplificando, voc√™ precisa verificar quantos caracteres de S est√£o em J. </blockquote><p>  A primeira tarefa √© um aquecimento, vamos resolv√™-lo ‚Äúna testa‚Äù.  Definimos a fun√ß√£o <em>jeweleryCount :: String -&gt; String -&gt; Int</em> , que, usando a convolu√ß√£o da lista passada pelo segundo argumento, resume todos os casos do item que est√° sendo processado na primeira lista.  Para esses fins, definimos a fun√ß√£o <em>elemInt com</em> base na fun√ß√£o <em>elem</em> , que, diferentemente da √∫ltima, retornar√° n√£o Verdadeiro ou Falso, mas o n√∫mero 0 ou 1. Na fun√ß√£o principal, voc√™ s√≥ precisa ler duas linhas, pass√°-las para a fun√ß√£o correspondente e imprimir o resultado.  O veredicto do sistema de teste est√° OK, passamos para a segunda tarefa. </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">jeweleryCount</span></span> :: <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">String</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> jeweleryCount j = foldr ((+).(elemInt j)) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> elemInt sx = fromEnum $ elem xs main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> j &lt;- getLine s &lt;- getLine print $ jeweleryCount js</code> </pre> <br><p>  <em>O c√≥digo fonte para resolver esta e outras tarefas tamb√©m est√° dispon√≠vel no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">reposit√≥rio</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">github.</a></em> </p><br><h2 id="b-posledovatelno-iduschie-edinicy">  B. Unidades consecutivas </h2><br><blockquote>  √â necess√°rio encontrar a seq√º√™ncia mais longa de unidades no vetor bin√°rio e imprimir seu comprimento. </blockquote><p>  Para resolver esse problema, implementamos uma fun√ß√£o recursiva que percorre a lista transferida e calcula o comprimento da sequ√™ncia necess√°ria.  Com os argumentos da fun√ß√£o, al√©m da pr√≥pria lista, transmitiremos o comprimento m√°ximo atual e o n√∫mero de unidades consecutivas na chamada atual.  Primeiro, definimos a base da recurs√£o na lista vazia e, em seguida, a pr√≥pria recurs√£o. </p><br><p>  Para ler a entrada, definimos a fun√ß√£o <em>getUserInputs :: IO [Char]</em> , na qual lemos primeiro o n√∫mero n - o tamanho da lista e, em seguida, usando o combinador <em>replicateM</em> , obtemos uma fun√ß√£o que chama a fun√ß√£o <em>&lt;&lt;get&gt; getLine</em> n times e mescla os resultados em uma lista . </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad (<span class="hljs-title"><span class="hljs-title">replicateM</span></span>) onesCount :: [Char] -&gt; Int onesCount xs = onesCount' xs 0 0 where onesCount' "" max curr | max &gt; curr = max | otherwise = curr onesCount' (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) max curr | x == '1' = onesCount' xs max $ curr + 1 | curr &gt; max = onesCount' xs curr 0 | otherwise = onesCount' xs max 0 getUserInputs :: IO [Char] getUserInputs = do n &lt;- read &lt;$&gt; getLine :: IO Int replicateM n $ head &lt;$&gt; getLine main :: IO () main = do xs &lt;- getUserInputs print $ onesCount xs</code> </pre><br><p>  N√≥s enviamos a decis√£o, o veredicto est√° OK.  N√≥s seguimos em frente. </p><br><h2 id="c-udalenie-dublikatov">  C. Remo√ß√£o duplicada </h2><br><blockquote>  √â fornecida uma matriz de n√∫meros inteiros de 32 bits ordenados em ordem n√£o decrescente.  √â necess√°rio remover todas as repeti√ß√µes dele. </blockquote><p>  Vamos come√ßar com uma implementa√ß√£o simples.  Definimos uma fun√ß√£o inicial que l√™ um n√∫mero, o imprime e o retorna envolto na m√¥nada de E / S.  Tamb√©m definimos a fun√ß√£o <em>deleteDoubles :: Int -&gt; Int -&gt; IO ()</em> , que l√™ um n√∫mero e o imprime apenas se n√£o for igual ao segundo argumento (passaremos o n√∫mero lido na etapa anterior).  Depois disso, a fun√ß√£o se chama recursivamente e, assim, prossegue para o pr√≥ximo n√∫mero no fluxo de entrada.  A base de recurs√£o √© o n√∫mero de n√∫meros a serem lidos; passaremos para o primeiro argumento. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad initial :: IO Int initial = do a &lt;- read &lt;$&gt; getLine print a return a deleteDoubles :: Int -&gt; Int -&gt; IO() deleteDoubles 0 _ = return () deleteDoubles ta = do b &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">a</span></span> == <span class="hljs-title"><span class="hljs-title">b</span></span>) $ print b deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1) b main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ initial &gt;&gt;= deleteDoubles (<span class="hljs-title"><span class="hljs-title">t</span></span>-1)</code> </pre> <br><p>  Enviamos a solu√ß√£o, ela passa em todos os testes e parece que podemos passar para a pr√≥xima tarefa, mas, na minha opini√£o, a chamada recursiva da fun√ß√£o que trabalha na m√¥nada de IO √© mais confusa do que concisa.  Vamos tentar melhor√°-lo. </p><br><p>  Observe que, de um modo geral, voc√™ pode primeiro ler a lista inteira de n√∫meros (usaremos o combinador replicateM j√° familiarizado com a segunda tarefa), depois pass√°-lo para uma fun√ß√£o pura que filtra todas as repeti√ß√µes e, finalmente, imprime o resultado. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad deleteDoubles' _ [] = [] deleteDoubles' prev (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) | prev /= x = x:(<span class="hljs-title"><span class="hljs-title">deleteDoubles'</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | otherwise = deleteDoubles' x xs deleteDoubles (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) = x:deleteDoubles' x xs getUserInputs :: Int -&gt; IO [Int] getUserInputs t = replicateM t $ read &lt;$&gt; getLine main :: IO () main = do t &lt;- read &lt;$&gt; getLine unless (<span class="hljs-title"><span class="hljs-title">t</span></span> &lt; 1) $ (<span class="hljs-title"><span class="hljs-title">deleteDoubles</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">getUserInputs</span></span> <span class="hljs-title"><span class="hljs-title">t</span></span>) &gt;&gt;= mapM_ print</code> </pre> <br><p>  Estou enviando uma solu√ß√£o e a primeira decep√ß√£o √© que o programa n√£o passa no teste 193 devido a exceder o limite de mem√≥ria usada.  O principal erro √© ler a lista inteira na mem√≥ria completamente.  Vamos tentar evitar isso e implementar um certo h√≠brido da primeira e da segunda vers√µes. </p><br><p>  Observe que a tarefa de remover duplicatas lembra um pouco a convolu√ß√£o associativa √† esquerda: em cada etapa calculamos uma fun√ß√£o que, dependendo do item atual lido e de alguns de seus resultados, na etapa anterior decide imprimir e prossegue para o pr√≥ximo par de valores. </p><br><p>  Uma fun√ß√£o que imprime ou n√£o imprime o resultado dependendo de seus argumentos, ap√≥s o qual retorna seu segundo argumento, envolto na m√¥nada IO, √© bastante simples, vamos cham√°-lo de etapa: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd</code> </pre> <br><p>  N√≥s descobrimos se devemos ou n√£o imprimir, dependendo dos valores passados, mas como organizar a leitura?  Para fazer isso, usamos a fun√ß√£o de convolu√ß√£o mon√°dica <em>foldM :: (Foldable t, Monad m) =&gt; (b -&gt; a -&gt; mb) -&gt; b -&gt; ta -&gt; mb</em> , aplic√°vel √† lista de fun√ß√µes de leitura. <br>  Por tipo de fun√ß√£o foldM, notamos que a cada passo a ‚Äúdescompacta√ß√£o‚Äù do resultado da aplica√ß√£o anterior da fun√ß√£o ocorre sob o cap√¥ da pr√≥pria foldM.  Assim, em cada etapa, precisamos apenas iniciar um c√°lculo mon√°dico do item da lista atual (de fato, ler o pr√≥ximo n√∫mero) usando o operador de <em>liga√ß√£o</em> ( <em>&gt;&gt; =</em> ) e pass√°-lo junto com o n√∫mero anterior para a etapa.  Como resultado, obtemos o seguinte programa </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">step</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> step fst snd = unless (fst == snd) (print snd) &gt;&gt; return snd initial :: <span class="hljs-type"><span class="hljs-type">IO</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> initial = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> a &lt;- read &lt;$&gt; getLine print a return a getUserInputs t = replicate t $ read &lt;$&gt; getLine main :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () main = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> t &lt;- read &lt;$&gt; getLine unless (t &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> init &lt;- initial foldM_ ((=&lt;&lt;) . step) init $ getUserInputs (t<span class="hljs-number"><span class="hljs-number">-1</span></span>)</code> </pre> <br><h2 id="d-generaciya-skobochnyh-posledovatelnostey">  D. Gera√ß√£o de sequ√™ncias de colchetes </h2><br><blockquote>  Dado um n√∫mero inteiro n.  √â necess√°rio derivar todas as seq√º√™ncias de colchetes corretas de comprimento 2 ‚ãÖ n, ordenadas lexicograficamente (consulte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://ru.wikipedia.org/wiki/Lexographic_order</a> ). <br>  Somente par√™nteses s√£o usados ‚Äã‚Äãna tarefa. <br>  √â aconselh√°vel obter uma solu√ß√£o que funcione em um tempo proporcional ao n√∫mero total de seq√º√™ncias de colchetes corretas na resposta e, ao mesmo tempo, use uma capacidade de mem√≥ria proporcional a n. </blockquote><p>  Essa tarefa, como muitas outras, nas quais √© necess√°rio derivar seq√º√™ncias que atendam a certas condi√ß√µes (por exemplo, a tarefa de trocar moedas, organizar oito rainhas e outras, pode ser lida com mais detalhes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">aqui</a> ), √© resolvida de forma sucinta usando a lista m√¥nada.  Em suma, essa abordagem √© baseada na liga√ß√£o mon√°dica para listas, cujo significado √© unir o conjunto de opera√ß√µes realizadas em cada elemento da lista. </p><br><p>  Defina a fun√ß√£o recursiva <em>generate ':: Int -&gt; Int -&gt; [[Char]]</em> , que leva o n√∫mero de colchetes a serem colocados como segundo argumento e o n√∫mero de colchetes de abertura n√£o fechados j√° definido.  Para a etapa de recurs√£o, precisamos de duas fun√ß√µes auxiliares: <em>poss√≠vel</em> - retorna uma lista de colchetes que podem ser colocados na pr√≥xima etapa e <em>etapa</em> - faz uma chamada recursiva para a fun√ß√£o generate 'com os par√¢metros necess√°rios. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; [String] generate = generate' 0 where generate' _ 0 = [[]] generate' an = [x:xs | x &lt;- possible, xs &lt;- step x] where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) possible | n == a = ")" | a == 0 = "(" | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = "()" main :: IO () main = do n &lt;- read &lt;$&gt; getLine let result = generate $ n * 2 mapM_ putStrLn result</code> </pre><br><p>  Enviamos a solu√ß√£o e entendemos que n√£o levamos em conta a restri√ß√£o que foi imposta √† quantidade de mem√≥ria usada pelo programa - a solu√ß√£o n√£o passa no 14¬∫ teste por exceder o limite de mem√≥ria usada. </p><br><p>  Modificamos a fun√ß√£o generate 'para que, em vez de construir toda a lista de sequ√™ncias de colchetes corretas, ela as exiba imediatamente na tela.  Para fazer isso, teremos que adicionar o terceiro argumento √† fun√ß√£o - um fragmento da sequ√™ncia constru√≠da para a etapa atual.  Observo que, nesta implementa√ß√£o, construiremos a sequ√™ncia na ordem inversa - isso nos permitir√° usar o construtor list ( <em>:) em</em> vez do operador de concatena√ß√£o mais caro ( <em>++</em> ). </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad(<span class="hljs-title"><span class="hljs-title">mapM_</span></span>) generate :: Int -&gt; IO() generate = generate' "" 0 where generate' xs _ 0 = putStrLn $ reverse xs generate' xs an | n == a = step ')' | a == 0 = step '(' | <span class="hljs-title"><span class="hljs-title">otherwise</span></span> = <span class="hljs-title"><span class="hljs-title">step</span></span> '(' &gt;&gt; <span class="hljs-title"><span class="hljs-title">step</span></span> ')' where step '(' = <span class="hljs-title"><span class="hljs-title">generate'</span></span> ('(':<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">a</span></span> + 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) step ')' = generate' (')':xs) (<span class="hljs-title"><span class="hljs-title">a</span></span> - 1) (<span class="hljs-title"><span class="hljs-title">n</span></span> - 1) main :: IO () main = do n &lt;- read &lt;$&gt; getLine generate $ n * 2</code> </pre><br><h2 id="e-anagrammy">  E. Anagramas </h2><br><blockquote>  Duas linhas s√£o dadas, consistindo em letras latinas min√∫sculas.  √â necess√°rio determinar se essas linhas s√£o anagramas, ou seja, elas diferem apenas na sequ√™ncia de caracteres. </blockquote><p>  Para resolver esse problema, contaremos quantas vezes uma carta ocorre em cada linha e comparamos os resultados.  Entendemos imediatamente que as listas padr√£o n√£o s√£o adequadas para n√≥s e √© necess√°rio usar uma estrutura de dados que nos permita acessar efetivamente o elemento pelo seu √≠ndice.  Existem v√°rios tipos de dados que satisfariam nossas condi√ß√µes, mas usaremos a matriz imut√°vel padr√£o <em>Data.Array</em> (ainda existem pelo menos v√°rias matrizes mut√°veis, bem como <em>Data.Vector</em> ). </p><br><p>  Para construir as matrizes necess√°rias, usamos a fun√ß√£o <em>hist :: (Ix a, Num b) =&gt; (a, a) -&gt; [a] -&gt; Matriz ab</em> , que, de acordo com a lista transferida de elementos e o intervalo ao qual esses elementos devem pertencer, forma uma matriz, que armazena o n√∫mero de repeti√ß√µes de elementos da lista.  Essa fun√ß√£o, embora n√£o esteja inclu√≠da no m√≥dulo Data.Array, geralmente √© fornecida como um exemplo do uso de outra fun√ß√£o j√° existente na biblioteca, o acumArray.  S√≥ podemos copiar sua implementa√ß√£o e escrever main - o benef√≠cio da compara√ß√£o de igualdade para <em>Array Char Int</em> j√° <em>est√°</em> definido.  Chamo sua aten√ß√£o para um recurso interessante - como √≠ndice, podemos usar n√£o apenas n√∫meros inteiros, mas tamb√©m qualquer representante da classe <em>Ix</em> .  No nosso caso, Char desempenha um papel natural nesse papel. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Array hist :: (<span class="hljs-type"><span class="hljs-type">Ix</span></span> <span class="hljs-title"><span class="hljs-title">a</span></span>, <span class="hljs-type"><span class="hljs-type">Num</span></span> <span class="hljs-title"><span class="hljs-title">b</span></span>) =&gt; (<span class="hljs-title"><span class="hljs-title">a</span></span>,<span class="hljs-title"><span class="hljs-title">a</span></span>) -&gt; [a] -&gt; Array ab hist bnds is = accumArray (+) 0 bnds [(<span class="hljs-title"><span class="hljs-title">i</span></span>, 1) | i&lt;-is, inRange bnds i] main = do arr1 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine arr2 &lt;- hist ('<span class="hljs-title"><span class="hljs-title">a'</span></span>,'<span class="hljs-title"><span class="hljs-title">z'</span></span>) &lt;$&gt; getLine if (<span class="hljs-title"><span class="hljs-title">arr1</span></span> == <span class="hljs-title"><span class="hljs-title">arr2</span></span>) then print 1 else print 0</code> </pre><br><h2 id="f-sliyanie-k-sortirovannyh-spiskov">  F. Mesclar k listas ordenadas </h2><br><blockquote>  Dadas k matrizes de n√∫meros inteiros n√£o negativos classificadas em ordem n√£o decrescente, cada uma das quais n√£o excede 100. √â necess√°rio construir o resultado de sua fus√£o: uma matriz classificada em ordem n√£o decrescente contendo todos os elementos das matrizes k originais. <br>  O comprimento de cada matriz n√£o excede 10 k. <br>  Tente fazer a solu√ß√£o funcionar pelo tempo k ‚ãÖ log (k) ‚ãÖ n, se assumirmos que as matrizes de entrada s√£o de comprimento n. </blockquote><p>  Mesclar duas listas ordenadas √© uma tarefa cl√°ssica da lista e √© abordada em muitos cursos sobre programa√ß√£o Haskell.  Por exemplo, pode ser resolvido da seguinte maneira. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">merge</span></span> :: [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] merge [] ys = ys merge xs [] = xs merge (x:xs) (y:ys) | x &lt; y = x:merge xs (y:ys) | otherwise = y:merge (x:xs) ys</code> </pre><br><p>  Bem, podemos mesclar duas listas.  E o que devemos fazer com a lista de listas?  Convolva-o com esta fun√ß√£o!  Assim, combinaremos todas as listas em uma e teremos apenas que imprimi-las. </p><br><div class="spoiler">  <b class="spoiler_title">Solu√ß√£o</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad merge :: [Int] -&gt; [Int] -&gt; [Int] merge [] ys = ys merge xs [] = xs merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | x &lt; y = x:merge xs (<span class="hljs-title"><span class="hljs-title">y</span></span>:<span class="hljs-title"><span class="hljs-title">ys</span></span>) | otherwise = y:merge (<span class="hljs-title"><span class="hljs-title">x</span></span>:<span class="hljs-title"><span class="hljs-title">xs</span></span>) ys mergeLists :: [[Int]] -&gt; [Int] mergeLists = foldl merge [] getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do k &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs k let res = mergeLists lists mapM_ (<span class="hljs-title"><span class="hljs-title">putStrLn</span></span> . <span class="hljs-title"><span class="hljs-title">show</span></span>) res</code> </pre> </div></div><br><p>  Entretanto, esta solu√ß√£o tem dois problemas s√©rios - a complexidade computacional √© maior que a necess√°ria - <em>O (k ^ 2 ‚ãÖ n) em</em> vez de <em>O (k ‚ãÖ log (k) ‚ãÖ n)</em> , al√©m de usar muita mem√≥ria adicional.  Como resultado, esta solu√ß√£o falha no n√∫mero de teste 17 devido a exceder o limite de mem√≥ria usada - 17,27 Mb em vez dos 10 Mb permitidos. </p><br><p>  Embora n√£o prestemos aten√ß√£o ao fato de que os n√∫meros fornecidos √† entrada pertencem a um intervalo limitado de valores, continuamos a procurar solu√ß√µes para um caso mais geral. </p><br><p>  O pr√≥ximo passo √© tentar implementar a abordagem proposta no artigo original com a an√°lise dessas tarefas.  Deixe-me lembr√°-lo de que √© baseado no uso de uma estrutura de dados que fornece uma maneira eficiente de extrair o elemento m√≠nimo.  Como tal estrutura, selecione <em>Data.Set</em> .  Inicializamos Set com a lista dos primeiros elementos; em cada etapa, extra√≠mos e imprimimos o elemento m√≠nimo e, em seguida, adicionamos o pr√≥ximo elemento da lista correspondente.  Al√©m disso, precisaremos de uma estrutura <em>Data.Sequence</em> para armazenar as pr√≥prias listas.  Foi escolhido por raz√µes de que, em cada etapa, √© necess√°rio ter acesso r√°pido √† lista por seu √≠ndice (que a lista n√£o pode fornecer) e alterar o elemento desse elemento sem a necessidade de copiar toda a estrutura (que em geral n√£o pode fornecer <em>Dados</em> imut√°veis <em>. Matriz</em> ). </p><br><p>  Assim, temos o seguinte programa: </p><br><div class="spoiler">  <b class="spoiler_title">Solu√ß√£o</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Sequence <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Seq <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Set <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Set <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Foldable mergeLists :: Set.Set (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; Seq.Seq [Int] -&gt; IO () mergeLists set seq | Set.null set = return () | otherwise = do let ((<span class="hljs-title"><span class="hljs-title">val</span></span>, <span class="hljs-title"><span class="hljs-title">idx</span></span>), set') = Set.deleteFindMin set print val if null (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>) then mergeLists set' seq else mergeLists (<span class="hljs-type"><span class="hljs-type">Set</span></span>.<span class="hljs-title"><span class="hljs-title">insert</span></span> (<span class="hljs-title"><span class="hljs-title">head</span></span> (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">index</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span>), idx) set') (<span class="hljs-type"><span class="hljs-type">Seq</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> <span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">idx</span></span> <span class="hljs-title"><span class="hljs-title">seq</span></span>) getUserInputs :: Int -&gt; IO [[Int]] getUserInputs t = replicateM t $ do n &lt;- getLine return $ tail $ read &lt;$&gt; words n main :: IO () main = do t &lt;- read &lt;$&gt; getLine lists &lt;- getUserInputs t let init_seq = Seq.fromList (<span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">not</span></span> . <span class="hljs-title"><span class="hljs-title">null</span></span>) lists) let init_heap = Set.fromList (<span class="hljs-title"><span class="hljs-title">zipWith</span></span> (,) (<span class="hljs-title"><span class="hljs-title">toList</span></span> (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">head</span></span> <span class="hljs-title"><span class="hljs-title">init_seq</span></span>)) [0..]) mergeLists init_heap $ tail &lt;$&gt; init_seq</code> </pre></div></div><br><p>  Enviamos a solu√ß√£o e descobrimos que, embora o programa tenha come√ßado a consumir muito menos mem√≥ria (10,26 Mb em vez de 17,27 Mb no 17¬∫ teste), ele ainda n√£o atingiu o limite.  A raz√£o disso est√° no fato de que, com essa decis√£o, de uma forma ou de outra, precisamos ler todos os dados de entrada na mem√≥ria.  Vamos tentar evitar isso com a ajuda da terceira solu√ß√£o para esse problema - classificando por contagem. </p><br><p>  J√° executamos a contagem do n√∫mero de caracteres recebidos ao resolver o problema anterior do anagrama.  Al√©m disso, como para resolv√™-lo, usaremos <em>Data.Array</em> .  Primeiro, implementamos a fun√ß√£o <em>addToArray :: Array Int Int -&gt; [Int] -&gt; Array Int Int</em> , que forma uma matriz com base na existente, aumentando os valores nos √≠ndices que correspondem aos valores da lista. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addToArray</span></span> :: <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Array</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> addToArray acc elems = accum (+) acc [(i, <span class="hljs-number"><span class="hljs-number">1</span></span>) | i&lt;-elems]</code> </pre><br><p>  Em seguida, usaremos a abordagem conhecida por n√≥s no problema de remover repeti√ß√µes - usando a convolu√ß√£o mon√°dica, aplicando sequencialmente a fun√ß√£o <em>addToArray</em> em <em>k</em> matrizes de origem.  E ... obtemos o mesmo resultado de 10,26 Mb no 17¬∫ teste.  E ent√£o √© hora de lembrar que <em>foldl</em> (cujo an√°logo √© <em>foldM</em> ) de acordo com a ordem de redu√ß√£o aceita primeiro expandir√° toda a cadeia de express√µes aninhadas e s√≥ ent√£o prosseguir√° para o c√°lculo ativo.  Como voc√™ sabe, para combater esse fato, o m√≥dulo <em>Data.List</em> implementa a fun√ß√£o <em>foldl</em> <em>'</em> , que usa a fun√ß√£o <em>seq :: a -&gt; b -&gt; b</em> , que primeiro lan√ßa o primeiro argumento na forma normal da cabe√ßa fraca, ou seja, reduz a parte externa - o valor da fun√ß√£o ou construtor e, em seguida, retorna o segundo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://www.ibm.com/developerworks/ru/library/l-haskell4/index.html</a> ).  N√£o temos escolha a n√£o ser implementar a fun√ß√£o <em>foldM 'independentemente</em> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldM'</span></span> :: (<span class="hljs-type"><span class="hljs-type">Monad</span></span> m) =&gt; (a -&gt; b -&gt; ma) -&gt; a -&gt; [b] -&gt; ma foldM' _ z [] = return z foldM' fz (x:xs) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> z' &lt;- fzx z' `seq` foldM' fz' xs</code> </pre> <br><p>  Como resultado, a quantidade de mem√≥ria usada no 17¬∫ teste quase caiu pela metade e totalizou 5.64Mb!  Embora os testes 17 e 18 tenham sido aprovados com √™xito, essa implementa√ß√£o n√£o passou no 19¬∫ teste pelo mesmo motivo que o limite de mem√≥ria foi excedido - 10,25Mb. </p><br><p>  Ok, siga em frente - ainda n√£o experimentamos o Data.Array.Unboxed.  Esse tipo de matriz √© digno de nota, pois, diferentemente do padr√£o, ele pode armazenar os pr√≥prios valores, em vez de apontar para eles ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">https://wiki.haskell.org/Arrays#Unboxed_arrays</a> ).  Devido a isso, essas matrizes ocupam menos espa√ßo de mem√≥ria e s√£o mais eficientes.  Para us√°-los, precisamos apenas alterar os tipos de importa√ß√£o e fun√ß√£o, pois o <em>Data.Array</em> e o <em>Data.Array.Unboxed</em> implementam uma interface de matrizes imut√°veis ‚Äã‚Äãdo <em>IArray</em> . </p><br><p>  Estamos enviando uma solu√ß√£o - o consumo de mem√≥ria diminuiu 4,5 vezes para 2,26 MB, mas n√£o ultrapassou o limite de tempo - o tempo de execu√ß√£o foi de 1,09 segundos.  Com o que isso poderia estar conectado?  A julgar pelo fato de que o tempo de execu√ß√£o dos testes restantes permanece o mesmo, acho que o motivo n√£o √© que a matriz sem caixa tenha sido mais lenta que a caixa, mas em particular o sistema de teste.  Parece que a tarefa √© interrompida assim que uma das restri√ß√µes √© violada.  No entanto, em casos muito raros, essa implementa√ß√£o ainda passa no 19¬∫ teste com um resultado de 0,98 segundos, mas falha no teste n√∫mero 20 tamb√©m devido ao excedente do prazo. </p><br><p>  Depois disso, tentei usar o anal√≥gico inseguro da fun√ß√£o acum, que em teoria deveria ser mais r√°pido, v√°rios m√©todos de buffer (fun√ß√£o <em>hSetBuffering :: Handle -&gt; BufferMode -&gt; IO ()</em> ), matrizes mut√°veis ‚Äã‚Äãde <em>IOArray</em> , mas nenhum desses m√©todos <em>produziu</em> resultados . </p><br><p>  N√£o estou inclinado a acreditar que os limites para Haskell s√£o muito r√≠gidos e espero que ainda exista uma solu√ß√£o que passe em todos os testes.  No reposit√≥rio do projeto, publiquei v√°rias vers√µes diferentes do c√≥digo para resolver esse problema (com Array e IOArray), talvez este seja o ponto de partida para uma solu√ß√£o que passar√° em todos os testes. </p><br><h2 id="zaklyuchenie">  Conclus√£o </h2><br><p>  Mesmo apesar de apenas cinco das seis tarefas terem me sucumbido, conclu√≠ minha tarefa principal - praticar a programa√ß√£o funcional.  N√£o menos importante foi o papel de severas restri√ß√µes aos recursos consumidos pelo programa, o que nos for√ßou a procurar cada vez mais novas abordagens para solucionar problemas.  Espero que a descri√ß√£o deles seja √∫til para aqueles que est√£o come√ßando sua jornada na programa√ß√£o funcional </p><br><p>  A abordagem funcional foi conveniente para resolver esses problemas?  Honestamente, tenho uma dupla impress√£o.  Por um lado, as solu√ß√µes para a maioria dos problemas se mostraram muito concisas e as ferramentas expressivas do pr√≥prio Haskell, bem como de sua rica biblioteca padr√£o, tiveram um papel significativo nisso.  Por outro lado, n√£o se pode deixar de admitir que, na maioria dos casos, o gerenciamento de recursos consumidos pode ser um determinado problema, o que n√£o permitir√° solucionar o problema nas restri√ß√µes especificadas. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt470790/">https://habr.com/ru/post/pt470790/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt470778/index.html">Revis√£o do drive Seagate ST2000DM008: r√°pido "dois" sem pre√ßo excessivo</a></li>
<li><a href="../pt470780/index.html">A barra est√° pronta - o novo da Seagate para armazenamento</a></li>
<li><a href="../pt470782/index.html">Dados na fronteira: como criar uma nova arquitetura de TI</a></li>
<li><a href="../pt470784/index.html">O design de cores dos mundos misteriosos de c√©lulas mortas</a></li>
<li><a href="../pt470786/index.html">Preparando-se para a certifica√ß√£o profissional da Spring. Seguran√ßa de primavera</a></li>
<li><a href="../pt470792/index.html">Entrevista com um dos criadores do jogo Untitled Goose</a></li>
<li><a href="../pt470794/index.html">Laravel: explique os conceitos b√°sicos. Parte Um: Teoria</a></li>
<li><a href="../pt470800/index.html">P - antecipa√ß√£o, bem como o Programa Preliminar DUMP Kazan. Veja os relat√≥rios que passaram na sele√ß√£o do moedor de carne</a></li>
<li><a href="../pt470802/index.html">Backup, Parte 6: Comparando ferramentas de backup</a></li>
<li><a href="../pt470804/index.html">Pr√™mio Alice: 5 id√©ias do vencedor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>