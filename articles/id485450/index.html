<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍🏭 👨‍👧‍👦 🕵️ Apa yang baru di SObjectizer-5.7.0 dan apa yang menunggu proyek ini selanjutnya? 👩🏿‍🎨 👩🏽‍🤝‍👨🏿 ✒️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SObjectizer adalah kerangka kerja C ++ 17 yang relatif kecil yang memungkinkan Anda untuk menggunakan pendekatan seperti Actor Model, Publish-Subscrib...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang baru di SObjectizer-5.7.0 dan apa yang menunggu proyek ini selanjutnya?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485450/"><p>  <a href="https://github.com/Stiffstream/sobjectizer">SObjectizer</a> adalah kerangka kerja C ++ 17 yang relatif kecil yang memungkinkan Anda untuk menggunakan pendekatan seperti Actor Model, Publish-Subscribe dan Communicating Sequential Processes (CSP) dalam program C ++.  Yang sangat menyederhanakan pengembangan aplikasi multi-threaded yang kompleks di C ++.  Jika pembaca mendengar tentang SObjectizer untuk pertama kalinya, maka Anda dapat membuat kesan tentang dia dari <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/What%2520is%2520SObjectizer-5.7%2520%2528at%2520v.5.7.0%2529.pdf/download">presentasi</a> ini, atau dari <a href="https://habr.com/post/304386/">artikel yang</a> sudah cukup lama <a href="https://habr.com/post/304386/">ini</a> . </p><br><p>  Secara umum, tidak ada banyak alat serupa yang terbuka, masih hidup, dan masih dikembangkan untuk C ++.  Seseorang hanya dapat mengingat <a href="https://www.state-machine.com/qpcpp/">QP / C ++</a> , <a href="http://actor-framework.org/">CAF: C ++ Actor Framework</a> , <a href="https://github.com/jinncrafters/actor-zeta">aktor-zeta,</a> dan proyek <a href="https://github.com/basiliscos/cpp-rotor">rotor yang</a> sangat muda.  Ada pilihan, tapi tidak sebesar itu. </p><br><p>  Baru-baru ini, <a href="https://groups.google.com/d/msg/sobjectizer/iudaw-GBHnc/7HjgPLPTCgAJ">versi lain "besar" dari SObjectizer</a> telah tersedia, di mana akhirnya muncul sesuatu yang telah dibicarakan sejak lama, dan implementasi yang saya beberapa kali gagal dekati.  Kita dapat mengatakan bahwa tonggak pencapaian telah tercapai.  Ini juga merupakan kesempatan untuk berbicara tentang apa yang akan diharapkan SObjectizer setelah rilis versi 5.7.0. </p><br><h1 id="podderzhka-send_case-v-select">  Dukungan Send_case di select () </h1><br><p>  Jadi, inovasi paling penting yang muncul di v.5.7.0 dan yang kompatibilitasnya dengan v.5.6 dirilis tahun lalu (dan kami tidak merusak kompatibilitas) adalah dukungan untuk send_case dalam fungsi select ().  Apa yang membuat SObjectizer's select () lebih seperti Go Selects.  Sekarang, menggunakan select (), Anda tidak hanya dapat membaca pesan dari beberapa saluran CSP, tetapi juga mengirim pesan keluar ke saluran-saluran yang siap ditulis. </p><a name="habracut"></a><br><p>  Tetapi untuk mengungkapkan topik ini, Anda harus mulai dari jauh. </p><br><h2 id="poyavlenie-elementov-csp-v-sobjectizer-5">  Munculnya elemen CSP di SObjectizer-5 </h2><br><p>  Elemen CSP, yaitu analog saluran CSP, muncul di SObjectizer-5 bukan untuk menandai kotak "dukungan CSP", tetapi untuk memecahkan masalah praktis. </p><br><p>  Masalahnya adalah ketika seluruh aplikasi sepenuhnya didasarkan pada SObjectizer, pertukaran informasi antara berbagai entitas (bagian) dari program diwujudkan dengan satu-satunya cara yang jelas.  Segala sesuatu dalam aplikasi disajikan dalam bentuk agen (aktor) dan agen hanya mengirim pesan satu sama lain dengan cara standar. </p><br><p>  Tetapi ketika dalam aplikasi hanya sebagian dari fungsi yang diimplementasikan pada SObjectizer ... </p><br><p>  Misalnya, aplikasi GUI di Qt atau wxWidgets, di mana bagian utama kode adalah GUI, dan SObjectizer diperlukan untuk melakukan beberapa tugas latar belakang.  Atau sebagian dari aplikasi ditulis menggunakan benang kosong dan Asio, dan data yang dibaca oleh Asio dari jaringan dikirim ke agen SObjectizer untuk diproses. </p><br><p>  Ketika aplikasi memiliki bagian SObjectizer dan bagian non-SObjectizer, muncul pertanyaan: bagaimana cara mentransfer informasi dari bagian SObjectizer aplikasi ke bagian non-SObjectizer? </p><br><p>  Solusinya ditemukan dalam bentuk yang disebut  rantai pesan (mchains), mis.  percakapan.  Yang, kebetulan, ternyata adalah inti dari saluran CSP.  Bagian SObjectizer dari aplikasi mengirimkan pesan ke mchain dengan cara biasa, menggunakan fungsi send () biasa. </p><br><p>  Untuk membaca pesan dari bagian non-SObjectizer, Anda dapat menggunakan fungsi accept () baru, untuk menggunakan yang Anda tidak perlu membuat agen atau menyelam ke dalam belantara SObjectizer lainnya. </p><br><p>  Ternyata skema itu cukup bisa dimengerti dan bekerja. </p><br><h2 id="nachalo-ispolzovaniya-mchains-ne-po-naznacheniyu">  Penyalahgunaan mchains </h2><br><p>  Selain itu, skema ini ternyata sangat dimengerti dan bekerja sehingga beberapa aplikasi pada SObjectizer mulai menulis tanpa agen sama sekali, hanya pada mchain.  Yaitu  menggunakan pendekatan CSP, bukan Model Aktor.  Sudah ada artikel tentang itu di sini di Habré: <a href="https://habr.com/ru/post/336854/">satu</a> dan <a href="https://habr.com/ru/post/358120/">dua</a> . </p><br><p>  Ini menyebabkan dua konsekuensi yang menarik. </p><br><p>  Pertama, fungsi accept () telah ditumbuhi dengan fitur-fitur canggih.  Ini diperlukan agar hanya dimungkinkan untuk melakukan satu panggilan untuk menerima (), pengembalian yang akan terjadi ketika semua pekerjaan yang diperlukan telah dilakukan.  Berikut adalah contoh dari apa yang diterima SObjectizer () dapat dilakukan: </p><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//    3 . //  3    mchain ,   . //   receive    3 , //      . receive( from(chain).handle_n( 3 ), handlers... ); //    3 . //       mchain ,    //     200ms. // ..     200ms,    receive,   //      . receive( from(chain).handle_n( 3 ).empty_timeout( milliseconds(200) ), handlers... ); //       . //     ,    //  500ms. receive( from(chain).handle_all().empty_timeout( milliseconds(500) ), handlers... ); //       . //       2s. receive( from(chain).handle_all().total_time( seconds(2) ), handlers... );</span></span></code> </pre> <br><p>  Kedua, segera menjadi jelas bahwa meskipun berbagai jenis pesan dapat ditempatkan di mchain SObjectizer, dan meskipun ada fungsi lanjutan menerima (), kadang-kadang Anda harus dapat bekerja dengan beberapa saluran sekaligus ... </p><br><h2 id="select-no-tolko-dlya-chteniya">  pilih () tetapi hanya baca </h2><br><p>  Fungsi select () telah ditambahkan ke SObjectizer untuk membaca dan memproses pesan dari beberapa rantai.  Pilihan bisnis yang jelas () muncul tidak hanya seperti itu, tetapi di bawah pengaruh bahasa Go.  Tapi pilih () SObjectizer memiliki dua fitur. </p><br><p>  Pertama, select () kami, seperti accept (), berorientasi pada skrip, ketika select () dipanggil hanya sekali dan semua pekerjaan yang bermanfaat dilakukan di dalamnya.  Sebagai contoh: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch1 = env.create_mchain(...); <span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> ch2 = env.create_mchain(...); <span class="hljs-comment"><span class="hljs-comment">//    3 . //    3    ch1. //  2  ch1    ch2. //    ch1  2  ch2... // //   ,       . // select()      3 , //     . select( from_all().handle_n( 3 ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //    3 . //    ,     200ms. select( from_all().handle_n( 3 ).empty_timeout( milliseconds(200) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) ); //       . //    ,     500ms. select( from_all().handle_all().empty_timeout( milliseconds(500) ), receive_case( ch1, []( const first_message_type &amp; msg ) { ... }, []( const second_message_type &amp; msg ) { ... } ), receive_case( ch2, []( const third_message_type &amp; msg ) { ... }, []( so_5::mhood_t&lt; some_signal_type &gt; ) { ... } ), ... ) );</span></span></code> </pre> <br><p>  Kedua, pilih () tidak mendukung pengiriman pesan ke saluran.  Yaitu  itu mungkin untuk membaca pesan dari saluran.  Tetapi untuk mengirim pesan ke saluran menggunakan select () - no. </p><br><p>  Sekarang bahkan sulit untuk mengingat mengapa itu terjadi.  Mungkin karena select () dengan dukungan send_case ternyata menjadi tugas yang sulit dan tidak ada sumber daya yang ditemukan untuk menyelesaikannya. </p><br><h3 id="mchain-y-v-sobjectizer-hitree-chem-kanaly-v-go">  mchain di SObjectizer lebih rumit daripada saluran di Go </h3><br><p>  Awalnya, pilih () tanpa dukungan send_case tidak dianggap sebagai masalah.  Faktanya adalah bahwa mchains di SObjectizer memiliki spesifikasi sendiri yang tidak dimiliki saluran Go. </p><br><p>  Pertama, SObjectizer dibagi menjadi tanpa dimensi dan dengan kapasitas maksimum tetap.  Oleh karena itu, jika send () dijalankan untuk mchain tanpa dimensi, maka send () ini tidak akan diblokir pada prinsipnya.  Oleh karena itu, tidak masuk akal untuk menggunakan select () untuk mengirim pesan ke mchain tanpa dimensi. </p><br><p>  Kedua, untuk rantai dengan kapasitas maksimum tetap, saat membuat, itu segera menunjukkan apa yang terjadi ketika Anda mencoba menulis pesan ke mchain penuh: </p><br><ul><li>  Apakah saya perlu menunggu tampilan ruang kosong di mchain.  Dan jika perlu, berapa lama; </li><li>  jika tidak ada ruang kosong, lalu apa yang harus dilakukan: menghapus pesan terlama dari mchain, abaikan pesan baru, lempar pengecualian atau bahkan panggil std :: abort () (skrip keras ini cukup diminati dalam praktiknya). </li></ul><br><p>  Dengan demikian, skenario yang cukup sering (sejauh yang saya tahu) menggunakan pilih di Pergi untuk mengirim pesan yang tidak benar-benar memblokir goroutin segera tersedia di SObjectizer tanpa bunga api dan tanpa pilih. </p><br><h2 id="v-konce-koncov-polnocennyy-select">  Pada akhirnya, pilih penuh () </h2><br><p>  Namun demikian, waktu berlalu, kadang-kadang ada kasus ketika kurangnya dukungan send_case di select () masih terpengaruh.  Terlebih lagi, dalam kasus ini, kemampuan built-in dari mchains tidak membantu, tetapi sebaliknya. </p><br><p>  Oleh karena itu, dari waktu ke waktu saya mencoba mendekati masalah implementasi send_case.  Tetapi sampai saat ini, tidak ada yang berhasil.  Terutama karena tidak mungkin untuk membuat desain send_case ini sendiri.  Yaitu  seperti apa tampilan send_case di dalam select ()?  Apa sebenarnya yang harus dia lakukan jika memungkinkan untuk mengirim?  Dalam hal ketidakmungkinan?  Apa yang harus dilakukan dengan membagi menjadi mchains tanpa dimensi dan tetap? </p><br><p>  Itu mungkin untuk menemukan jawaban yang cocok bagi saya untuk ini dan pertanyaan lain hanya pada bulan Desember 2019.  Sebagian besar karena konsultasi dengan orang-orang yang terbiasa dengan Go dan telah menggunakan Go go dalam pekerjaan nyata.  Nah, begitu gambar send_case akhirnya terbentuk, implementasinya tiba di sana. </p><br><p>  Jadi sekarang Anda bisa menulis seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Greeting</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> text_; }; select(from_all().handle_n(<span class="hljs-number"><span class="hljs-number">1</span></span>), send_case(ch, <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;Greeting&gt;::make(<span class="hljs-string"><span class="hljs-string">"Hello!"</span></span>), []{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Hello sent!"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }));</code> </pre> <br><p>  Yang penting adalah bahwa send_case di select () mengabaikan respons overload yang ditetapkan untuk target mchain.  Jadi, dalam contoh di atas, ch dapat dibuat dengan abort_app reaksi ketika mencoba mengirim pesan ke saluran lengkap.  Dan jika Anda mencoba memanggil pengiriman sederhana () untuk menulis ke ch, maka std :: abort () dapat dipanggil.  Tetapi dalam kasus pilih () - dan ini tidak akan terjadi, pilih () akan menunggu sampai ruang kosong muncul di ch.  Atau sampai ch ditutup. </p><br><p>  Berikut adalah beberapa contoh lagi apa yang dapat dilakukan send_case di SObjectizer's select (): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> so_5; <span class="hljs-comment"><span class="hljs-comment">//     ,   //    . //    . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     . //     ( ) //   ( ). select(from_all().handle_n(3), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...})); //     chW. //     chW    150ms. select(from_all().handle_n(1).empty_timeout(150ms), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //     chW. //  ,   chW   . select(from_all().handle_n(1).no_wait_on_empty(), send_case(chW, message_holder_t&lt;Msg&gt;::make(...), []{...})); //    ,      250ms. select(from_all().handle_all().total_time(250ms), send_case(ch1, message_holder_t&lt;FirstMessage&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMessage&gt;::make(...), []{...}), send_case(ch3, message_holder_t&lt;ThirdMessage&gt;::make(...), []{...}));</span></span></code> </pre> <br><p>  Secara alami, send_case di select () dapat digunakan bersama dengan accept_case: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//          //  .       //  . select(from_all().handle_n(1), send_case(ch1, message_holder_t&lt;FirstMsg&gt;::make(...), []{...}), send_case(ch2, message_holder_t&lt;SecondMsg&gt;::make(...), []{...}), receive_case(ch3, [](...){...}), receive_case(ch4, [](...){...}));</span></span></code> </pre> <br><p>  Jadi sekarang di SObjectizer pendekatan CSP dapat digunakan, seperti yang mereka katakan, di semua bidang.  Tidak akan lebih buruk daripada di Go.  Verbose, tentu saja.  Tapi tidak lebih buruk :) </p><br><p>  Kita dapat mengatakan bahwa sejarah panjang menambahkan dukungan untuk pendekatan CSP ke SObjectizer telah berakhir. </p><br><h1 id="drugie-vazhnye-veschi-v-etom-relize">  Hal penting lainnya dalam rilis ini </h1><br><h2 id="okonchatelnyy-pereezd-na-github">  Langkah terakhir ke github </h2><br><p>  SObjectizer awalnya hidup dan dikembangkan di <a href="https://sourceforge.net/projects/sobjectizer/">SourceForge</a> .  Setahun iklan sejak 2006.  Tetapi di SF.net, kinerja Subversion turun dan turun, jadi tahun lalu kami pindah ke BitBucket dan Mercurial.  Segera setelah kami melakukan ini, Atlassian mengumumkan bahwa repositori Mercurial dengan BitBucket akan segera dihapus sama sekali.  Oleh karena itu, sejak Agustus 2019, SObjectizer dan so5extra berada di GitHub. </p><br><p>  SF.net memiliki semua konten lama yang tersisa, termasuk Wiki dengan dokumentasi untuk versi SObjectizer sebelumnya.  Dan juga <a href="https://sourceforge.net/projects/sobjectizer/files/">bagian File</a> dari mana Anda dapat mengunduh arsip berbagai versi SObjectizer / so5extra dan tidak hanya (misalnya, <a href="https://sourceforge.net/projects/sobjectizer/files/sobjectizer/Slides/">PDF dengan beberapa presentasi tentang SObjectizer</a> ). </p><br><p>  Secara umum, cari kami sekarang di <a href="https://github.com/Stiffstream/sobjectizer">GitHub</a> .  Dan jangan lupa untuk menempatkan bintang, kita memiliki terlalu sedikit untuk saat ini;) </p><br><h2 id="ispravleno-povedenie-enveloped-messages">  Memperbaiki perilaku pesan yang di-amplop </h2><br><p>  Dalam SO-5.7.0, perbaikan kecil terjadi yang tidak bisa disebutkan.  Tetapi pantas untuk dikatakan, karena ini adalah demonstrasi yang bagus tentang bagaimana berbagai fitur yang terakumulasi dalam SObjectizer saling mempengaruhi selama pengembangannya. </p><br><p>  Empat tahun lalu, dukungan untuk agen, yang merupakan mesin negara hierarkis, telah ditambahkan ke SObjectizer (lebih detail di <a href="https://habr.com/post/423497/">sini</a> ).  Kemudian, setelah beberapa tahun lagi, <a href="https://habr.com/ru/post/426983/">amplop pesan</a> ditambahkan ke SObjectizer.  Yaitu  pesan, ketika dikirim, dibungkus dengan objek amplop tambahan dan amplop ini dapat menerima informasi tentang apa yang terjadi dengan pesan tersebut. </p><br><p>  Salah satu fitur dari mekanisme pesan yang di-amplop adalah bahwa amplop diberitahu bahwa pesan telah dikirim ke penerima.  Artinya, bahwa pawang untuk pesan ini ditemukan di agen pelanggan dan pawang ini dipanggil. </p><br><p>  Ternyata jika agen penerima pesan adalah mesin status hierarkis yang menggunakan fitur seperti <code>suppress()</code> (mis., Memaksa pesan untuk diabaikan dalam keadaan tertentu), amplop mungkin menerima notifikasi pengiriman yang salah, meskipun pesan tersebut sebenarnya ditolak oleh penerima. karena <code>suppress()</code> .  Situasi yang lebih menarik adalah dengan <code>transfer_to_state()</code> , karena  setelah mengubah status agen penerima, penangan pesan dapat ditemukan, atau mungkin tidak ada.  Tetapi amplop tentang pengiriman pesan tetap diinformasikan. </p><br><p>  Kasus yang sangat jarang, yang, sejauh yang saya tahu, belum ditunjukkan dalam praktik oleh siapa pun.  Namun demikian, salah perhitungan dibuat. </p><br><p>  Oleh karena itu, dalam SO-5.7.0 poin ini ditingkatkan dan jika pesan diabaikan karena menerapkan <code>suppress()</code> atau <code>transfer_to_state()</code> , amplop tidak akan lagi berpikir bahwa pesan telah dikirim ke penerima. </p><br><h2 id="dopolnitelnaya-biblioteka-so5extra-smenila-licenziyu-na-bsd-3-clause">  Pustaka so5extra tambahan mengubah lisensi BSD-3-CLAUSE </h2><br><p>  Pada 2017, kami mulai membuat perpustakaan komponen tambahan untuk SObjectizer yang disebut <a href="https://github.com/Stiffstream/so5extra">so5extra</a> .  Selama masa ini, perpustakaan telah tumbuh secara signifikan dan mengandung banyak hal berguna dalam rumah tangga. </p><br><p>  So5extra awalnya didistribusikan di bawah lisensi ganda: GNU Affero GPL v.3 untuk proyek open source dan komersial untuk yang tertutup. </p><br><p>  Sekarang kami telah mengubah lisensi untuk so5extra dan mulai dari versi 1.4.0 so5extra didistribusikan di bawah lisensi BSD-3-CLAUSE.  Yaitu  itu dapat digunakan secara gratis bahkan ketika mengembangkan perangkat lunak berpemilik. </p><br><p>  Karena itu, jika Anda kehilangan sesuatu di SObjectizer, Anda <a href="https://github.com/Stiffstream/so5extra/wiki/so5extra-1.4-docs">dapat melihat so5extra</a> , bagaimana jika Anda sudah memiliki yang Anda butuhkan? </p><br><h1 id="buduschee-sobjectizer-a">  Masa depan SObjectizer </h1><br><p>  Sebelum Anda mengatakan beberapa kata tentang apa yang menunggu SObjectizer, Anda perlu melakukan penyimpangan penting.  Terutama bagi mereka yang percaya bahwa SObjectizer adalah "limbah referensi", "pengerjaan setinggi lutut", "laboratorium siswa", "proyeksi eksperimental yang ditinggalkan penulis ketika mereka bermain cukup" ... (ini hanya sebagian dari karakteristik yang kami dengar dari para ahli di dari internet kami selama 4-5 tahun terakhir). </p><br><p>  Saya telah mengembangkan SObjectizer selama hampir delapan belas tahun.  Dan saya dapat dengan bertanggung jawab mengatakan bahwa dia tidak pernah menjadi proyek percontohan.  Ini adalah alat praktis yang masuk ke dalam pekerjaan nyata sejak versi pertama di tahun 2002. </p><br><p>  Baik saya dan kolega saya, dan orang-orang yang berani mengambil dan mencoba SObjectizer, berkali-kali diyakinkan bahwa SObjectizer benar-benar membuat pengembangan beberapa jenis aplikasi C ++ multithreaded jauh lebih mudah.  Tentu saja, SObjectizer bukan peluru perak, dan tidak bisa selalu digunakan.  Tetapi jika berlaku, itu membantu. </p><br><p>  Kehidupan secara teratur memberikan kesempatan sekali lagi untuk diyakinkan tentang hal ini.  Dari waktu ke waktu, kode multithreaded orang lain menjadi perhatian kami, di mana tidak ada yang serupa dengan SObjectizer dan sepertinya tidak akan pernah muncul.  Berurusan dengan kode ini di sana-sini, momen-momen mencolok ketika penggunaan aktor atau saluran CSP dapat membuat kode lebih sederhana dan lebih dapat diandalkan.  Tapi tidak, Anda harus membangun pola interaksi non-sepele antara utas menggunakan mutex-s dan condition_variables di mana di SObjectizer Anda dapat mengelola dengan satu mchain, beberapa pesan dan timer yang dibangun ke dalam SObjectizer.  Dan kemudian juga menghabiskan banyak waktu untuk menguji skema non-sepele ini ... </p><br><p>  Jadi SObjectizer bermanfaat bagi kami.  Saya berani berpikir bahwa itu bermanfaat tidak hanya untuk kita.  Dan yang paling penting, sudah lama di sini dan tersedia secara bebas untuk semua orang.  Dia tidak akan pergi dari mana pun.  Dan ke mana harus pergi ke apa yang ada di OpenSource di bawah lisensi permisif?  ;) </p><br><p>  Hal lain adalah bahwa kami sendiri menerapkan semua Wishlist besar kami di SObjectizer.  Dan pengembangan SObjectizer di masa depan akan ditentukan tidak begitu banyak oleh kebutuhan kita seperti keinginan pengguna. </p><br><p>  Akan ada keinginan seperti itu - akan ada fitur baru di SObjectizer. </p><br><p>  Itu tidak akan ... Baiklah, maka kami hanya akan mengeluarkan rilis korektif dari waktu ke waktu dan memeriksa kinerja SObjectizer di bawah versi baru kompiler C ++. </p><br><p>  Jadi jika Anda ingin melihat sesuatu di SObjectizer, beri tahu kami.  Jika Anda memerlukan bantuan dengan SObjectizer, jangan ragu untuk menghubungi kami (melalui <a href="https://github.com/Stiffstream/sobjectizer/issues">Masalah pada GitHub</a> atau <a href="https://groups.google.com/forum/">grup Google</a> ), kami pasti akan mencoba membantu. </p><br><p>  Baiklah, saya ingin mengucapkan terima kasih kepada para pembaca yang dapat membaca sampai akhir artikel ini.  Dan saya akan mencoba menjawab pertanyaan tentang SObjectizer / so5extra, jika muncul. </p><br><p>  PS.  Saya akan berterima kasih jika pembaca akan menemukan waktu untuk menulis di komentar apakah itu menarik / berguna untuk membaca artikel tentang SObjectizer dan apakah mereka ingin melakukan ini di masa depan.  Atau lebih baik bagi kita untuk berhenti membuang waktu menulis artikel seperti itu, dan dengan demikian berhenti meluangkan waktu pengguna Habr? </p><br><p>  PPS  Atau mungkin seseorang menganggap SObjectizer sebagai alat yang tidak dapat diterapkan karena satu dan lain alasan?  Akan sangat menarik untuk mengetahui tentang ini. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485450/">https://habr.com/ru/post/id485450/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485426/index.html">Mobil di Belanda: statistik dan informasi untuk 2019</a></li>
<li><a href="../id485428/index.html">Program LyX yang misterius. Bagian 5</a></li>
<li><a href="../id485430/index.html">Editor teks multi-pengguna yang sederhana dengan enkripsi ujung ke ujung</a></li>
<li><a href="../id485438/index.html">Menguji Komponen UI Bereaksi</a></li>
<li><a href="../id485448/index.html">Radio FM lain di RDA5807 menjalankan Arduino</a></li>
<li><a href="../id485452/index.html">Mengapa Rust Memimpin Tolok Ukur Kerangka Kerja TechEmpower</a></li>
<li><a href="../id485454/index.html">Memulai dengan Pengembalian Pengguna: Kiat untuk Model Hooked</a></li>
<li><a href="../id485458/index.html">Knalpot howitzer</a></li>
<li><a href="../id485460/index.html">20 perpustakaan untuk aplikasi iOS yang spektakuler</a></li>
<li><a href="../id485462/index.html">Kami berurusan dengan eSIM (+ wawancara dengan pakar)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>