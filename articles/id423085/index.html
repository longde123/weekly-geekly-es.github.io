<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♣️ ⌚️ 🤺 Penyeimbangan beban penyetelan halus 👩‍💼 🌛 👩🏽‍🤝‍👩🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan fokus pada penyeimbangan beban dalam proyek web. Banyak yang percaya bahwa solusi untuk masalah ini dalam distribusi beban antar serv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penyeimbangan beban penyetelan halus</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/423085/">  Artikel ini akan fokus pada penyeimbangan beban dalam proyek web.  Banyak yang percaya bahwa solusi untuk masalah ini dalam distribusi beban antar server - semakin akurat, semakin baik.  Tetapi kita tahu bahwa ini tidak sepenuhnya benar.  <strong>Stabilitas sistem jauh lebih penting dari sudut pandang bisnis</strong> . <br><br><img src="https://habrastorage.org/webt/6i/vb/-w/6ivb-w0bzdgl_oa-hkep6luitfi.png"><br><br>  Puncak menit kecil di 84 RPS "lima ratus" adalah lima ribu kesalahan yang diterima pengguna nyata.  Ini banyak dan sangat penting.  Penting untuk mencari alasan, mengerjakan kesalahan dan mencoba terus mencegah situasi seperti itu. <br><br>  <strong>Nikolay Sivko</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">NikolaySivko</a> ) dalam laporannya tentang RootConf 2018 berbicara tentang aspek penyeimbangan beban yang halus dan belum populer: <br><br><ul><li>  kapan harus mengulangi permintaan (coba lagi); </li><li>  cara memilih nilai untuk waktu habis; </li><li>  bagaimana tidak membunuh server yang mendasarinya pada saat kecelakaan / kemacetan; </li><li>  apakah pemeriksaan kesehatan diperlukan; </li><li>  bagaimana menangani masalah yang berkedip-kedip. </li></ul><br>  Di bawah decoding kucing laporan ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2-j2ADWFkkE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>  <strong>Tentang pembicara:</strong> Nikolay Sivko, pendiri okmeter.io.  Dia bekerja sebagai administrator sistem dan pemimpin sekelompok administrator.  Operasi yang diawasi di hh.ru.  Ia mendirikan layanan pemantauan okmeter.io.  Sebagai bagian dari laporan ini, pengalaman pemantauan pemantauan adalah sumber utama kasus. <br><br><h2>  Apa yang akan kita bicarakan? <br></h2><br>  Artikel ini akan berbicara tentang proyek web.  Di bawah ini adalah contoh produksi langsung: grafik menunjukkan permintaan per detik untuk layanan web tertentu. <br><br><img src="https://habrastorage.org/webt/oy/5c/qt/oy5cqtlz-halhw7y5ayuz6xl9lm.png"><br><br>  Ketika saya berbicara tentang penyeimbangan, banyak yang melihatnya sebagai "kita perlu mendistribusikan beban antar server - semakin akurat, semakin baik." <br><br><img src="https://habrastorage.org/webt/pm/g2/sp/pmg2spartsnxrxcyhzi_4-ui64g.png"><br><br>  Sebenarnya, ini tidak sepenuhnya benar.  Masalah ini relevan untuk sejumlah kecil perusahaan.  Lebih sering bisnis khawatir tentang kesalahan dan stabilitas sistem. <br><br><img src="https://habrastorage.org/webt/6i/vb/-w/6ivb-w0bzdgl_oa-hkep6luitfi.png"><br><br>  Puncak kecil pada grafik adalah "lima ratus", yang dikembalikan oleh server dalam satu menit, dan kemudian berhenti.  Dari sudut pandang bisnis, seperti toko online, puncak kecil ini di 84 RPS "lima ratus" adalah 5040 kesalahan untuk pengguna nyata.  Beberapa tidak menemukan sesuatu di katalog Anda, yang lain tidak bisa memasukkan barang ke keranjang.  Dan ini sangat penting.  Meskipun puncak ini tidak terlihat sangat besar pada grafik, <strong>ini banyak di pengguna nyata</strong> . <br><br>  Sebagai aturan, setiap orang memiliki puncak seperti itu, dan admin tidak selalu meresponsnya.  Sangat sering, ketika sebuah bisnis bertanya apa itu, mereka menjawabnya: <br><br><ul><li>  "Ini ledakan singkat!" </li><li>  "Ini hanya rilis bergulir." </li><li>  "Server sudah mati, tetapi semuanya sudah beres." </li><li>  "Vasya mengganti jaringan salah satu backend." </li></ul><br>  Seringkali orang <strong>bahkan tidak mencoba untuk memahami alasan</strong> mengapa hal ini terjadi, dan tidak melakukan pasca kerja sehingga tidak terjadi lagi. <br><br><h2>  Nada yang bagus <br></h2><br>  Saya menyebut laporan "Fine tuning" (Inggris. Fine tuning), karena saya pikir tidak semua orang dapat melakukan tugas ini, tetapi akan sia-sia.  Kenapa mereka tidak ke sana? <br><br><ul><li>  <strong>Tidak semua orang mendapatkan tugas ini,</strong> karena ketika semuanya bekerja, itu tidak terlihat.  Ini sangat penting untuk masalah.  Fakapa tidak terjadi setiap hari, dan masalah sekecil itu membutuhkan upaya yang sangat serius untuk menyelesaikannya. </li><li>  <strong>Anda harus banyak berpikir.</strong>  Sangat sering, admin - orang yang mengatur keseimbangan - tidak dapat secara mandiri menyelesaikan masalah ini.  Selanjutnya kita akan lihat alasannya. </li><li>  <strong>Ini menangkap level yang mendasarinya.</strong>  Tugas ini sangat terkait erat dengan pengembangan, dengan adopsi keputusan yang memengaruhi produk dan pengguna Anda. </li></ul><br>  <strong>Saya menegaskan bahwa inilah saatnya untuk melakukan tugas ini karena beberapa alasan:</strong> <br><br><ul><li>  Dunia berubah, menjadi lebih dinamis, ada banyak rilis.  Mereka mengatakan bahwa sekarang sudah benar untuk melepaskan 100 kali sehari, dan rilis adalah fakap masa depan dengan probabilitas 50 hingga 50 (sama seperti kemungkinan bertemu dinosaurus) </li><li>  Dari sudut pandang teknologi, semuanya juga sangat dinamis.  Kubernet dan orkestra lainnya muncul.  Tidak ada penerapan lama yang baik, ketika satu backend pada beberapa IP dimatikan, pembaruan digulir, dan layanan naik.  Sekarang dalam proses peluncuran di k8s daftar IP upstream benar-benar berubah. </li><li>  Layanan Mikro: sekarang semua orang berkomunikasi melalui jaringan, yang berarti Anda harus melakukan ini dengan andal.  Keseimbangan memainkan peran penting. </li></ul><br><h2>  Test stand <br></h2><br>  Mari kita mulai dengan kasus yang sederhana dan jelas.  Untuk kejelasan, saya akan menggunakan bangku tes.  Ini adalah aplikasi Golang yang memberikan http-200, atau Anda dapat mengubahnya ke mode "beri http-503". <br><br>  Kami memulai 3 contoh: <br><br><ul><li>  127.0.0.1.10001 </li><li>  127.0.0.1.10002 </li><li>  127.0.0.1.10003 </li></ul><br>  Kami melayani 100rps melalui yandex.tank via nginx. <br><br>  Nginx di luar kotak: <br><br><pre><code class="plaintext hljs">upstream backends { server 127.0.0.1:20001; server 127.0.0.1:20002; server 127.0.0.1:20003; } server { listen 127.0.0.1:30000; location / { proxy_pass http://backends; } }</code> </pre> <br><h3>  Skenario primitif </h3><br>  Pada titik tertentu, nyalakan salah satu backend dalam mode beri 503, dan kami mendapatkan tepat sepertiga dari kesalahan. <br><br><img src="https://habrastorage.org/webt/qp/m1/ro/qpm1rolcydmcpwpvule4pw97b-o.png"><br><br>  Jelas bahwa tidak ada yang berfungsi di luar kotak: nginx tidak mencoba kembali dari kotak jika menerima <strong>respons</strong> dari server. <br><br><pre> <code class="plaintext hljs">Nginx default: proxy_next_upstream error timeout;</code> </pre><br>  Sebenarnya, ini cukup logis dari sisi pengembang nginx: nginx tidak memiliki hak untuk memutuskan untuk Anda apa yang ingin Anda retray dan yang tidak. <br><br>  Karena itu, kita perlu mencoba lagi - coba lagi, dan kita mulai membicarakannya. <br><br><h2>  Coba lagi <br></h2><br>  Penting untuk menemukan kompromi antara: <br><br><ul><li>  Permintaan pengguna itu suci, terluka, tetapi jawab.  Kami ingin menjawab pengguna di semua biaya, pengguna adalah yang paling penting. </li><li>  Lebih baik menjawab dengan kesalahan daripada membebani server. </li><li>  Integritas data (untuk permintaan non-idempoten), yaitu mustahil untuk mengulangi jenis permintaan tertentu. </li></ul><br>  <strong>Kebenaran, seperti biasa, ada di suatu tempat antara -</strong> kita dipaksa untuk menyeimbangkan antara tiga poin ini.  Mari kita coba memahami apa dan bagaimana. <br><br>  Saya membagi upaya yang gagal menjadi 3 kategori: <br><br>  1. <strong>Kesalahan transportasi</strong> <br>  Untuk transport HTTP adalah TCP, dan sebagai aturan, di sini kita berbicara tentang kesalahan pengaturan koneksi dan batas waktu pengaturan koneksi.  Dalam laporan saya, saya akan menyebutkan 3 penyeimbang umum (kami akan berbicara tentang Utusan sedikit lebih jauh): <br><br><ul><li>  <strong>nginx</strong> : kesalahan + batas waktu (proxy_connect_timeout); </li><li>  <strong>HAProxy</strong> : batas waktu koneksi; </li><li>  <strong>Utusan</strong> : koneksi-kegagalan + aliran ditolak. </li></ul><br>  Nginx memiliki kesempatan untuk mengatakan bahwa upaya yang gagal adalah kesalahan koneksi dan batas waktu koneksi;  HAProxy memiliki batas waktu koneksi, Utusan juga memiliki semuanya standar dan normal. <br><br>  2. <strong>Batas waktu permintaan:</strong> <br>  Misalkan kita mengirim permintaan ke server, berhasil terkoneksi ke sana, tetapi jawabannya tidak datang kepada kita, kita menunggu dan kita mengerti bahwa tidak ada gunanya menunggu lagi.  Ini disebut batas waktu permintaan: <br><br><ul><li>  <strong>Nginx</strong> memiliki: batas waktu (prox_send_timeout * + proxy_read_timeout *); </li><li>  <strong>HAProxy memiliki</strong> <strong>OOPS :(</strong> - pada prinsipnya tidak ada. Banyak orang tidak tahu bahwa HAProxy, jika telah berhasil membuat koneksi, tidak akan pernah mencoba mengirim ulang permintaan. </li><li>  <strong>Utusan</strong> dapat melakukan segalanya: batas waktu ||  per_try_timeout. </li></ul><br>  3. <strong>status HTTP</strong> <br>  Semua penyeimbang, kecuali untuk HAProxy, dapat memproses, jika bagaimanapun backend menjawab Anda, tetapi dengan semacam kode yang salah. <br><br><ul><li>  <strong>nginx</strong> : http_ * </li><li>  <strong>HAProxy</strong> : <strong>OOPS :(</strong> </li><li>  <strong>Utusan</strong> : 5xx, gateway-error (502, 503, 504), retriable-4xx (409) </li></ul><br><h3>  Batas waktu <br></h3><br>  Sekarang mari kita bicara secara rinci tentang batas waktu, bagi saya tampaknya perlu memperhatikan hal ini.  Tidak akan ada lagi ilmu roket - ini hanya informasi terstruktur tentang apa yang umumnya terjadi dan bagaimana kaitannya dengannya. <br><br><h4>  Hubungkan batas waktu <br></h4><br>  Connect timeout adalah waktu untuk membuat koneksi.  Ini adalah karakteristik jaringan Anda dan server spesifik Anda, dan tidak tergantung pada permintaan.  Biasanya, nilai default untuk koneksi habis diatur ke kecil.  Di semua proxy, nilai default cukup besar, dan ini salah - itu harus <strong>unit, terkadang puluhan milidetik</strong> (jika kita berbicara tentang jaringan dalam satu DC). <br><br>  Jika Anda ingin mengidentifikasi server bermasalah sedikit lebih cepat dari unit-puluhan milidetik ini, Anda dapat menyesuaikan beban di backend dengan mengatur backlog kecil untuk menerima koneksi TCP.  Dalam hal ini, Anda dapat, ketika jaminan simpanan aplikasi sudah penuh, suruh Linux untuk mengatur ulang untuk melimpahkan jaminan simpanan.  Maka Anda akan dapat menembak backend "buruk" kelebihan beban sedikit lebih awal dari batas waktu koneksi: <br><br><pre> <code class="plaintext hljs">fail fast: listen backlog + net.ipv4.tcp_abort_on_overflow</code> </pre> <br><h4>  Permintaan batas waktu <br></h4><br>  Batas waktu permintaan bukanlah karakteristik jaringan, tetapi <strong>karakteristik sekelompok permintaan</strong> (penangan).  Ada permintaan yang berbeda - mereka berbeda dalam keparahan, mereka memiliki logika yang sangat berbeda di dalam, mereka perlu mengakses repositori yang sama sekali berbeda. <br><br>  Nginx sendiri <strong>tidak memiliki batas waktu untuk seluruh permintaan.</strong>  Dia memiliki: <br><br><ul><li>  proxy_send_timeout: waktu antara dua operasi tulis yang berhasil tulis (); </li><li>  proxy_read_timeout: waktu antara dua bacaan berhasil dibaca (). </li></ul><br>  Artinya, jika Anda memiliki backend perlahan, satu byte kali, memberikan sesuatu dalam batas waktu, maka semuanya baik-baik saja.  Karena itu, nginx tidak memiliki request_timeout.  Tetapi kita berbicara tentang hulu.  Di pusat data kami, mereka dikendalikan oleh kami, oleh karena itu, dengan asumsi bahwa jaringan tidak memiliki kukang, maka, pada prinsipnya, read_timeout dapat digunakan sebagai request_timeout. <br><br>  Utusan memiliki semuanya: batas waktu ||  per_try_timeout. <br><br><h4>  Pilih batas waktu permintaan <br></h4><br>  Sekarang hal yang paling penting, menurut saya, adalah request_timeout yang akan dimasukkan.  Kami melanjutkan dari berapa lama yang diizinkan bagi pengguna untuk menunggu - ini adalah maksimum tertentu.  Jelas bahwa pengguna tidak akan menunggu lebih dari 10 detik, jadi Anda harus menjawabnya lebih cepat. <br><br><ul><li>  Jika kami ingin menangani kegagalan satu server tunggal, maka batas waktu harus kurang dari batas waktu maksimum yang diizinkan: <strong>request_timeout &lt;maks.</strong> </li><li>  Jika Anda ingin memiliki <strong>2 upaya yang dijamin untuk</strong> mengirim permintaan ke dua backend yang berbeda, maka batas waktu untuk satu upaya sama dengan setengah dari interval yang diperbolehkan ini: <strong>per_try_timeout = 0,5 * maks.</strong> </li><li>  Ada juga opsi perantara - <strong>2 upaya optimis</strong> jika backend pertama telah "tumpul", tetapi yang kedua akan merespons dengan cepat: <strong>per_try_timeout = k * max (di mana k&gt; 0,5).</strong> </li></ul><br>  Ada beberapa pendekatan berbeda, tetapi secara umum, <strong>memilih batas waktu itu sulit</strong> .  Akan selalu ada kasus batas, misalnya, penangan yang sama dalam 99% kasus diproses dalam 10 ms, tetapi ada 1% kasus ketika kita menunggu 500 ms, dan ini normal.  Ini harus diselesaikan. <br><br>  Dengan 1% ini, sesuatu perlu dilakukan, karena seluruh grup permintaan harus, misalnya, mematuhi SLA dan memenuhi 100 ms.  Sangat sering pada saat-saat ini aplikasi diproses: <br><br><ul><li>  Paging muncul di tempat-tempat di mana tidak mungkin untuk mengembalikan semua data dalam batas waktu. </li><li>  Admin / laporan dipisahkan menjadi grup url terpisah untuk meningkatkan batas waktu untuknya, dan ya untuk menurunkan permintaan pengguna. </li><li>  Kami memperbaiki / mengoptimalkan permintaan yang tidak sesuai dengan batas waktu kami. </li></ul><br>  Segera, kita perlu mengambil keputusan yang tidak terlalu sederhana dari sudut pandang psikologis bahwa jika kita tidak punya waktu untuk menjawab pengguna dalam waktu yang ditentukan, kita memberikan kesalahan (ini seperti dalam pepatah Tiongkok kuno: "Jika kuda mati, turun!") <strong>.</strong> <br><br>  Setelah itu, proses pemantauan layanan Anda dari sudut pandang pengguna disederhanakan: <br><br><ul><li>  Jika ada kesalahan, semuanya buruk, itu perlu diperbaiki. </li><li>  Jika tidak ada kesalahan, kami masuk ke dalam waktu respon yang tepat, maka semuanya baik-baik saja. </li></ul><br><h3>  Coba lagi secara spekulatif # nifig <br></h3><br>  Kami memastikan bahwa memilih nilai batas waktu cukup sulit.  Seperti yang Anda tahu, untuk menyederhanakan sesuatu, Anda perlu menyulitkan sesuatu :) <br><br>  <strong>Retray spekulatif</strong> - permintaan berulang ke server lain, yang diluncurkan oleh beberapa kondisi, tetapi permintaan pertama tidak terganggu.  Kami mengambil jawaban dari server yang menjawab lebih cepat. <br><br>  Saya tidak melihat fitur ini dalam balancers yang saya kenal, tetapi ada contoh yang bagus dengan Cassandra (perlindungan baca cepat): <br><br>  speculative_retry = N ms |  <strong>Persentil <sup>ke</sup> -3</strong> <br><br>  Dengan cara ini Anda <strong>tidak perlu istirahat</strong> .  Anda dapat membiarkannya pada tingkat yang dapat diterima dan dalam kasus apa pun memiliki upaya kedua untuk mendapatkan respons terhadap permintaan tersebut. <br><br>  Cassandra memiliki peluang menarik untuk menetapkan spekulatif_retri statis atau dinamis, maka upaya kedua akan dilakukan melalui persentil waktu respons.  Cassandra mengumpulkan statistik pada waktu respons dari permintaan sebelumnya dan menyesuaikan nilai batas waktu tertentu.  Ini bekerja dengan cukup baik. <br><br>  Dalam pendekatan ini, semuanya bertumpu pada keseimbangan antara keandalan dan beban palsu. Bukan server. Anda memberikan keandalan, tetapi kadang-kadang Anda mendapatkan permintaan tambahan ke server.  Jika Anda terburu-buru di suatu tempat dan mengirim permintaan kedua, tetapi yang pertama masih menjawab, server menerima sedikit lebih banyak beban.  Dalam satu kasus, ini adalah masalah kecil. <br><br><img src="https://habrastorage.org/webt/uv/7c/bs/uv7cbswancegyh5vc8t7mwvr8uy.png"><br><br>  Konsistensi batas waktu adalah aspek penting lainnya.  Kami akan berbicara lebih banyak tentang pembatalan permintaan, tetapi secara umum, jika batas waktu untuk seluruh permintaan pengguna adalah 100 ms, maka tidak masuk akal untuk menetapkan batas waktu untuk permintaan dalam basis data selama 1 detik.  Ada sistem yang memungkinkan Anda melakukan ini secara dinamis: layanan ke layanan mentransfer sisa waktu yang Anda tunggu jawaban untuk permintaan ini.  Ini rumit, tetapi jika Anda tiba-tiba membutuhkannya, Anda dapat dengan mudah menemukan cara melakukannya di Utusan yang sama. <br><br>  Apa lagi yang perlu Anda ketahui tentang coba lagi? <br><br><h3>  Point of no return (V1) <br></h3><br>  Di sini V1 bukan versi 1. Dalam penerbangan ada konsep seperti itu - kecepatan V1.  Ini adalah kecepatan setelah itu tidak mungkin untuk memperlambat akselerasi di landasan.  Hal ini diperlukan untuk lepas landas, dan kemudian membuat keputusan tentang apa yang harus dilakukan selanjutnya. <br><br>  Titik tanpa pengembalian yang sama ada di penyeimbang beban: <strong>ketika Anda melewatkan 1 byte respons ke klien Anda, tidak ada kesalahan yang bisa diperbaiki</strong> .  Jika backend mati pada saat ini, tidak ada percobaan ulang akan membantu.  Anda hanya dapat mengurangi kemungkinan skenario seperti itu dipicu, melakukan shutdown anggun, yaitu, memberi tahu aplikasi Anda: "Anda tidak menerima permintaan baru sekarang, tetapi memodifikasi yang lama!", Dan hanya kemudian memadamkannya. <br><br>  Jika Anda mengontrol klien, ini adalah Ajax atau aplikasi seluler yang rumit, mungkin mencoba mengulangi permintaan, dan kemudian Anda dapat keluar dari situasi ini. <br><br><h3>  Point of No Return [Utusan] <br></h3><br>  Utusan punya trik aneh.  Ada per_try_timeout - membatasi berapa banyak upaya untuk mendapatkan respons terhadap permintaan.  Jika batas waktu ini berhasil, tetapi backend sudah mulai merespons ke klien, maka semuanya terputus, klien menerima kesalahan. <br><br>  Rekan saya Pavel Trukhanov ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">tru_pablo</a> ) membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan</a> , yang sudah ada di master Utvoy dan akan berada di 1.7.  Sekarang berfungsi sebagaimana mestinya: jika respons sudah mulai dikirim, hanya batas waktu global yang akan bekerja. <br><br><h3>  Coba lagi: perlu dibatasi <br></h3><br>  Retries itu bagus, tetapi ada yang disebut permintaan killer: queri berat yang banyak melakukan logika mengakses database dan sering tidak cocok dengan per_try_timeout.  Jika kami mengirim coba lagi dan lagi, maka kami membunuh basis kami.  Karena <strong>di sebagian besar (99,9%) layanan basis data tidak ada permintaan pembatalan</strong> . <br><br>  Pembatalan permintaan berarti bahwa klien telah melepaskan ikatan, Anda harus menghentikan semua pekerjaan sekarang.  Golang aktif mempromosikan pendekatan ini, tetapi sayangnya berakhir dengan backend, dan banyak repositori database tidak mendukung ini. <br><br>  Karena itu, coba ulang harus dibatasi, yang memungkinkan hampir semua penyeimbang (kami berhenti mempertimbangkan HAProxy mulai sekarang). <br><br>  <strong>Nginx:</strong> <br><br><ul><li>  proxy_next_upstream_timeout (global) </li><li>  proxt_read_timeout ** sebagai per_try_timeout </li><li>  proxy_next_upstream_tries </li></ul><br>  <strong>Utusan:</strong> <br><br><ul><li>  batas waktu (global) </li><li>  per_try_timeout </li><li>  num_retries </li></ul><br>  Dalam Nginx, kita dapat mengatakan bahwa kita mencoba melakukan percobaan ulang melalui jendela X, yaitu, pada interval waktu tertentu, misalnya, 500 ms, kita melakukan percobaan sebanyak yang sesuai.  Atau ada pengaturan yang membatasi jumlah sampel yang diulang.  Dalam <strong>Utusan</strong> , hal yang sama adalah kuantitas atau batas waktu (global). <br><br><h4>  Coba lagi: terapkan [nginx] <br></h4><br>  Pertimbangkan contoh: kami menetapkan upaya coba lagi di nginx 2 - karena itu, setelah menerima HTTP 503, kami mencoba mengirim permintaan ke server lagi.  Lalu matikan <strong>kedua</strong> backend. <br><br><pre> <code class="plaintext hljs">upstream backends { server 127.0.0.1:20001; server 127.0.0.1:20002; server 127.0.0.1:20003; } server { listen 127.0.0.1:30000; proxy_next_upstream error timeout http_503; proxy_next_upstream_tries 2; location / { proxy_pass http://backends; } }</code> </pre><br>  Di bawah ini adalah grafik dari bangku tes kami.  Tidak ada kesalahan pada grafik atas, karena sangat sedikit dari mereka.  Jika Anda hanya meninggalkan kesalahan, jelas itu salah. <br><br><img src="https://habrastorage.org/webt/3h/sx/aq/3hsxaq8qyifcoyq3mvcyzmxm_cc.png"><br><br><img src="https://habrastorage.org/webt/sc/f_/2w/scf_2wz9tctmouvrs9hpqtpmau0.png"><br><br>  <strong>Apa yang terjadi</strong> <br><br><ul><li>  proxy_next_upstream_tries = <strong>2.</strong> </li><li>  Dalam kasus ketika Anda melakukan upaya pertama ke server "mati", dan yang kedua - ke "mati" lainnya, Anda mendapatkan HTTP-503 jika <strong>kedua</strong> upaya tersebut dilakukan ke server "buruk". </li><li>  Ada beberapa kesalahan, karena nginx "mencekal" server yang buruk.  Artinya, jika dalam nginx beberapa kesalahan telah kembali dari backend, berhenti membuat upaya berikut untuk mengirim permintaan ke sana.  Ini diatur oleh variabel <strong>fail_timeout.</strong> </li></ul><br>  Tetapi ada kesalahan, dan ini tidak cocok untuk kita. <br><br>  <strong>Apa yang harus dilakukan?</strong> <br><br>  Kita dapat meningkatkan jumlah percobaan ulang (tapi kemudian kembali ke masalah "permintaan pembunuh"), atau kita dapat mengurangi kemungkinan permintaan menjadi backend "mati".  Ini dapat dilakukan dengan <strong>pemeriksaan kesehatan.</strong> <br><br><h2>  Pemeriksaan kesehatan <br></h2><br>  Saya sarankan mempertimbangkan pemeriksaan kesehatan sebagai optimisasi proses pemilihan server "langsung".  <strong>Ini sama sekali tidak memberikan jaminan apa pun.</strong>  Oleh karena itu, selama eksekusi permintaan pengguna, kami lebih cenderung mendapatkan hanya server "langsung".  Penyeimbang secara teratur mengakses URL tertentu, server menjawabnya: "Saya hidup dan siap." <br><br><h4>  Pemeriksaan kesehatan: dalam hal backend <br></h4><br>  Dari sudut pandang backend, Anda dapat melakukan hal-hal menarik: <br><br><ul><li>  Periksa kesiapan untuk operasi semua subsistem yang mendasari di mana operasi backend tergantung: jumlah koneksi yang diperlukan ke database dibuat, kumpulan memiliki koneksi gratis, dll, dll. </li><li>  Anda dapat menggantung logika Anda sendiri di URL pemeriksaan kesehatan jika penyeimbang yang digunakan tidak terlalu cerdas (misalnya, Anda mengambil Load Balancer dari host).  Server dapat mengingat bahwa "pada menit terakhir saya memberikan begitu banyak kesalahan - saya mungkin semacam server" salah ", dan untuk 2 menit berikutnya saya akan merespons dengan" lima ratus "untuk pemeriksaan Kesehatan.  Dengan demikian saya akan melarang diri saya sendiri! "  Ini terkadang sangat membantu ketika Anda memiliki Load Balancer yang tidak terkontrol. </li><li>  Biasanya, interval pemeriksaan sekitar satu detik, dan Anda memerlukan penangan pemeriksaan Kesehatan untuk tidak membunuh server Anda.  Itu harus ringan. </li></ul><br><h4>  Pemeriksaan kesehatan: implementasi <br></h4><br>  Secara umum, semua yang ada di sini adalah sama untuk semua orang: <br><br><ul><li>  Minta; </li><li>  Batas waktu di atasnya; </li><li>  Interval di mana kami melakukan pengecekan.  Proxy tertipu memiliki <strong>jitter</strong> , yaitu, beberapa pengacakan sehingga semua cek kesehatan tidak datang ke backend sekaligus, dan jangan membunuhnya. </li><li>  <strong>Ambang tidak sehat</strong> - ambang berapa banyak pemeriksaan Kesehatan yang gagal harus dilewati agar layanan dapat menandainya sebagai Tidak Sehat. </li><li>  <strong>Ambang batas yang sehat</strong> - sebaliknya, berapa banyak upaya yang berhasil harus dilewati agar server kembali beroperasi. </li><li>  Logika tambahan.  Anda dapat menguraikan Periksa status + tubuh, dll. </li></ul><br>  Nginx mengimplementasikan fungsi pemeriksaan kesehatan hanya dalam versi berbayar dari nginx +. <br><br>  Saya perhatikan fitur <strong>Utusan</strong> , ia memiliki <strong>mode panik</strong> pemeriksaan Kesehatan <strong>.</strong>  Ketika kami mencekal, sebagai "tidak sehat", lebih dari N% host (katakanlah 70%), ia percaya bahwa semua cek Kesehatan kami bohong, dan semua host sebenarnya hidup.  Dalam kasus yang sangat buruk, ini akan membantu Anda tidak mengalami situasi di mana Anda sendiri menembak kaki Anda dan melarang semua server.  Ini cara aman lagi. <br><br><h2>  Menyatukan semuanya <br></h2><br>  Biasanya untuk pemeriksaan Kesehatan ditetapkan: <br><br><ul><li>  Atau nginx +; </li><li>  Atau nginx + sesuatu yang lain :) </li></ul><br>  Di negara kami, ada kecenderungan untuk mengatur nginx + HAProxy, karena versi gratis nginx tidak memiliki pemeriksaan kesehatan, dan hingga 1.11.5 tidak ada batasan jumlah koneksi ke backend.  Tetapi opsi ini buruk karena HAProxy tidak tahu bagaimana cara pensiun setelah membuat koneksi.  Banyak orang berpikir bahwa jika HAProxy mengembalikan kesalahan pada nginx dan nginx retries, maka semuanya akan baik-baik saja.  Tidak juga.  Anda bisa mendapatkan HAProxy lain dan backend yang sama, karena pool backend sama.  Jadi, Anda memperkenalkan satu tingkat abstraksi lagi untuk diri Anda sendiri, yang mengurangi keakuratan penyeimbangan Anda dan, dengan demikian, ketersediaan layanan. <br><br>  Kami memiliki nginx + Utusan, tetapi jika Anda bingung, Anda dapat membatasi diri hanya untuk Utusan. <br><br><h2>  Utusan macam apa? <br></h2><br>  Utusan adalah penyeimbang beban pemuda yang trendi, awalnya dikembangkan di Lyft, ditulis dalam C ++.  <strong>Di luar kotak ia dapat melakukan banyak roti pada topik kita hari ini.</strong>  Anda mungkin melihatnya sebagai Service Mesh untuk Kubernetes.  Sebagai aturan, Utusan bertindak sebagai bidang data, yaitu secara langsung menyeimbangkan lalu lintas, dan ada juga bidang kontrol yang memberikan informasi tentang apa yang Anda butuhkan untuk mendistribusikan beban di antara (penemuan layanan, dll.). <br><br>  Aku akan memberitahumu beberapa kata tentang roti nya. <br><br>  Untuk meningkatkan kemungkinan respons coba lagi yang berhasil saat berikutnya Anda mencoba, Anda dapat tidur sedikit dan menunggu backend kembali ke akal sehatnya.  Dengan cara ini kita akan menangani masalah basis data pendek.  Utusan memiliki <strong>backoff untuk retries</strong> - jeda antara retries.  Selain itu, interval penundaan antara upaya meningkat secara eksponensial.  Percobaan pertama terjadi setelah 0-24 ms, yang kedua setelah 0-74 ms, dan kemudian untuk setiap upaya berikutnya interval meningkat, dan penundaan spesifik dipilih secara acak dari interval ini. <br><br>  Pendekatan kedua tidak khusus Utusan, tetapi pola yang disebut <strong>Circuit breaking</strong> (lit. circuit breaker atau fuse).  Ketika backend kita tumpul, sebenarnya kita berusaha menyelesaikannya setiap saat.  Ini karena pengguna dalam situasi apa pun yang tidak dapat dipahami mengeklik laman refresh-at, mengirimkan lebih banyak permintaan baru kepada Anda.  Penyeimbang Anda menjadi gugup, mengirim percobaan ulang, jumlah permintaan meningkat - beban bertambah, dan dalam situasi ini alangkah baiknya untuk tidak mengirim permintaan. <br><br>  Pemutus sirkuit hanya memungkinkan Anda untuk menentukan bahwa kami berada dalam keadaan ini, dengan cepat menembak kesalahan dan memberikan backend "tenangkan napas." <br><br><img src="https://habrastorage.org/webt/xb/mm/i8/xbmmi88cqacoqvkzdmujynq6da0.gif"><br>  <em>Circuit breaker (hystrix like libs),</em> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>asli</em></a> <em>di blog ebay.</em> <br><br>  Di atas adalah sirkuit pemutus sirkuit Hystrix.  Hystrix adalah perpustakaan Java Netflix yang dirancang untuk menerapkan pola toleransi kesalahan. <br><br><ul><li>  "Sekering" bisa dalam keadaan "tertutup" ketika semua permintaan dikirim ke backend dan tidak ada kesalahan. </li><li>  Ketika ambang gagal tertentu dipicu, yaitu, beberapa kesalahan telah terjadi, pemutus sirkuit masuk ke status "Buka".  Dengan cepat mengembalikan kesalahan ke klien, dan permintaan tidak sampai ke backend. </li><li>  Sekali dalam periode waktu tertentu, sebagian kecil dari permintaan dikirim ke backend.  Jika kesalahan dipicu, statusnya tetap "Terbuka".  Jika semuanya mulai bekerja dengan baik dan merespons, "sekering" menutup dan bekerja berlanjut. </li></ul><br>  Dalam Utusan, dengan demikian, ini tidak semua.  Ada batas tingkat atas pada kenyataan bahwa tidak boleh ada lebih dari N permintaan untuk kelompok hulu tertentu.  Jika lebih, ada sesuatu yang salah di sini - kami mengembalikan kesalahan.  Tidak boleh ada lagi N percobaan ulang aktif (mis. Percobaan ulang yang sedang terjadi saat ini). <br><br>  Anda tidak memiliki percobaan ulang, sesuatu yang meledak - kirim percobaan lagi.  Utusan memahami bahwa lebih dari N tidak normal, dan semua permintaan harus ditembak dengan kesalahan. <br><br>  <strong>Pemutus Sirkuit [Utusan]</strong> <br><br><ul><li>  Koneksi maks Cluster (upstream group) </li><li>  Permintaan cluster tertunda maks </li><li>  Permintaan kluster maks </li><li>  Cluster max percobaan aktif </li></ul><br>  Hal sederhana ini berfungsi dengan baik, dapat dikonfigurasi, Anda tidak perlu membuat parameter khusus, dan pengaturan defaultnya cukup bagus. <br><br><h4>  Pemutus sirkuit: pengalaman kami <br></h4><br>  Kami dulu memiliki pengumpul metrik HTTP, yaitu agen yang dipasang di server klien kami mengirim metrik ke cloud kami melalui HTTP.  Jika kami memiliki masalah dalam infrastruktur, agen menulis metrik ke disk-nya dan kemudian mencoba mengirimkannya kepada kami. <br><br>  Dan agen terus-menerus berupaya mengirim data kepada kami, mereka tidak kesal bahwa kami entah bagaimana merespons secara salah, dan tidak pergi. <br><br>         (       ,      )  ,     ,           . <br><br>            nginx limit req.    ,    , , 200 RPS.       ,   ,          ,   limit req. <br><br>           TCP     HTTP (  nginx limit req).            .      limit req . <br><br>     ,      ,  .   <strong> </strong>  Circuit breaker,  ,     N  ,   ,   - ,   ,  .   ,    ,      spool  . <br><br>  <strong></strong>   Circuit breaker       + request cancellation ( ).  ,    N   Cassandra, N   Elastic,  ,    —   ,         .      — ,   . <br><br><img src="https://habrastorage.org/webt/jo/l2/jk/jol2jk44vlcmz3twgvr0jgtpbii.png"><br><br><img src="https://habrastorage.org/webt/1a/7b/x4/1a7bx4yq20uehqoagd4tutqxgmw.png"><br><br>    ,         (:  —  «»,  — «»). ,      800 RPS    20-30.     «», ,    . <br><br><h2>    <br></h2><br>    —  ,  . <br><br>         ,   ,        —      .    . <br><br>  ,       , ,      ,   Health checks — HTTP 200. <br><br>    . <br><br><img src="https://habrastorage.org/webt/yu/cy/9s/yucy9sofdr-z7brvjedmnxt4_gc.png"><br><br>     Load Balancer, 3 ,         Cassandra.      Cassandra,   Cassandra   ,    Cassandra     data noda. <br><br>   —    : <strong>kernel: NETDEV WATCHDOG: eth0 (ixgbe): transmit queue 3 timed out.</strong> <br><br>   :     (    ),    64     . , 1/64   .     reboot,    . <br><br> ,  ,    ,      .  , ,        ,            .   ,    ,   .     ,   . <br><br> <strong>Cassandra: coordinator -&gt; nodes</strong> <br><br>  Cassandra,      (speculative retries),      .    latency  99 ,         . <br><br> <strong>App -&gt; cassandra coordinator</strong> <br><br>     .     Cassandra      «» ,    ,  ,  latency  .. <br><br>      gocql —   cassandra client.       .   HostSelectionPolicy,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bitly/go-hostpool</a> .    Epsilon greedy  ,       . <br><br>     ,    <strong>Epsilon-greedy</strong> . <br><br>      (multi-armed bandit):       ,     ,     N     . <br><br>    : <br><br><ol><li>  « <strong>explore»</strong> —   : 10    ,  ,   . <br></li><li>  « <strong>exploit»</strong> —      . <br></li></ol><br> ,    (10 — 30%)   <strong>round</strong> - <strong>robin</strong>    ,  ,  ,  .  70 — 90%        . <br><br> Host-pool          .         .        (    — ,    ,  ).      .      ,     , ,       . <br><br><h2>   </h2><br>   «» ()   —Cassandra  Cassandra coordinator-data.     (nginx, Envoy —  )    «» Application,     Cassandra  ,       ,      . <br><br>  Envoy    <strong>Outlier detection</strong> : <br><br><ul><li> Consecutive http-5xx. </li><li> Consecutive gateway errors (502,503,504). </li><li> Success rate. </li></ul><br>   «»  ,    -  ,   .   ,    .        —    ,   ,     .  ,    ,          . <br><br>   ,       «»,   max_ejection_percent.    ,      outlier,     .  ,    70%  —  ,   — , ! <br><br>      ,       — ! <br><br><h2>  <br></h2><br> ,     ,      .  ,       latency    , : <br><br><ul><li>  ,        .. </li><li>    ,      -,       . </li></ul><br> ,  <strong>    </strong> ,   .  ,      ,     ,         —  ,    . <br><br> <strong>      </strong> .  99%     nginx/ <s>HAProxy</s> /Envoy.   proxy ,           «». <br><br> <strong>    proxy</strong> (   HAProxy:)), <strong>  ,    .</strong> <br><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DevOpsConf Russia</a>      Kubernetes         .          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>    ,       — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>      DevOps. <br><br>    ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YouTube-</a> —              . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423085/">https://habr.com/ru/post/id423085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423073/index.html">Sistem file antarplanet - hash (identitas) sepele, blok DAG dan Protokol Buffer</a></li>
<li><a href="../id423075/index.html">Mengapa CFO sangat ingin menerjemahkan belanja modal pada TI ke dalam operasi</a></li>
<li><a href="../id423077/index.html">Panduan Perakitan X86 untuk Pemula</a></li>
<li><a href="../id423079/index.html">Poin-poin penting dari wawancara dengan Elon Musk di Joe Rogan</a></li>
<li><a href="../id423083/index.html">Bagaimana saya menjadi pengembang di ABBYY</a></li>
<li><a href="../id423087/index.html">Jangan mendorong mata saya</a></li>
<li><a href="../id423089/index.html">Programmer di MBLT DEV 2018</a></li>
<li><a href="../id423091/index.html">Bergetar untuk pengembang Android. Cara membuat UI untuk Aktivitas menggunakan Flutter</a></li>
<li><a href="../id423093/index.html">Kami meningkatkan keacakan fakta bahwa [mungkin] [hampir] secara tidak sengaja</a></li>
<li><a href="../id423095/index.html">Apa yang Baru di Presentasi Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>