<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç± üë®üèø‚Äç‚öñÔ∏è üëßüèΩ Programmation JavaScript asynchrone (rappel, promesse, RxJs) ü•õ üßëüèΩ üë©üèΩ‚Äçü§ù‚Äçüë©üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour √† tous. En contact avec Omelnitsky Sergey. Il n'y a pas si longtemps, j'ai dirig√© un flux de programmation r√©actif o√π j'ai parl√© d'asynchronie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Programmation JavaScript asynchrone (rappel, promesse, RxJs)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462355/"><p>  Bonjour √† tous.  En contact avec Omelnitsky Sergey.  Il n'y a pas si longtemps, j'ai dirig√© un flux de programmation r√©actif o√π j'ai parl√© d'asynchronie en JavaScript.  Aujourd'hui, je voudrais d√©crire ce mat√©riau. </p><br><p><img src="https://habrastorage.org/webt/oq/x0/s1/oqx0s1ukuyf6izyu-5cxkd9cd-m.png"></p><br><p>  Mais avant de commencer le mat√©riel principal, nous devons faire une introduction.  Commen√ßons donc par les d√©finitions: qu'est-ce que la pile et la file d'attente? </p><br><p>  <strong>Une pile</strong> est une collection dont les √©l√©ments sont re√ßus selon le principe du "dernier entr√©, premier sorti" LIFO </p><br><p>  <strong>Une file d'attente</strong> est une collection dont les √©l√©ments sont re√ßus selon le principe (FIFO ¬´premier entr√©, premier sorti¬ª </p><br><p>  Ok, continuons. </p><br><p><img src="https://habrastorage.org/webt/xk/dt/rr/xkdtrrm0vasdzlva2iqgrpjmwuk.png"></p><br><p>  JavaScript est un langage de programmation monothread.  Cela signifie qu'il n'a qu'un seul thread d'ex√©cution et une pile dans laquelle les fonctions sont mises en file d'attente pour ex√©cution.  Par cons√©quent, √† un moment donn√©, JavaScript ne peut effectuer qu'une seule op√©ration, tandis que d'autres op√©rations attendent leur tour sur la pile jusqu'√† ce qu'elles soient appel√©es. </p><a name="habracut"></a><br><p>  <strong>La pile d'appels</strong> est une structure de donn√©es qui, en termes simples, enregistre des informations sur la place dans le programme o√π nous sommes.  Si nous entrons dans une fonction, nous mettons un enregistrement √† ce sujet en haut de la pile.  Lorsque nous revenons de la fonction, nous tirons l'√©l√©ment le plus haut de la pile et nous trouvons d'o√π nous avons appel√© cette fonction.  C'est tout ce que la pile peut faire.  Et maintenant, une question extr√™mement int√©ressante.  Comment fonctionne alors l'asynchronie en JavasScript? </p><br><p><img src="https://habrastorage.org/webt/h2/-x/aj/h2-xajggqa9vcloczh7owhqiffc.png"></p><br><p>  En fait, en plus de la pile, les navigateurs ont une file d'attente sp√©ciale pour travailler avec ce que l'on appelle WebAPI.  Les fonctions de cette file d'attente seront ex√©cut√©es dans l'ordre uniquement apr√®s que la pile aura √©t√© compl√®tement effac√©e.  Ce n'est qu'apr√®s cela qu'ils sont pouss√©s de la file d'attente vers la pile pour ex√©cution.  Si au moins un √©l√©ment est actuellement sur la pile, alors ils ne peuvent pas entrer sur la pile.  C'est pr√©cis√©ment √† cause de cela que l'appel de fonctions par timeout n'est souvent pas pr√©cis dans le temps, car une fonction ne peut pas passer de la file d'attente √† la pile lorsqu'elle est pleine. </p><br><p>  Prenons l'exemple suivant et effectuez son ¬´ex√©cution¬ª √©tape par √©tape.  Voir √©galement ce qui se passe dans le syst√®me. </p><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hi'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cb1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'cb1'</span></span>); }, <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Bye'</span></span>);</code> </pre> <br><p><img src="https://habrastorage.org/webt/tg/i-/xf/tgi-xfd5vxrjxltraxp4o7uhiki.png"></p><br><p>  1) Jusqu'√† pr√©sent, rien ne se passe.  La console du navigateur est propre, la pile d'appels est vide. </p><br><p><img src="https://habrastorage.org/webt/v4/et/uh/v4etuhvfo-eltv08fhxv1bqx1a0.png"></p><br><p>  2) Ensuite, la commande console.log ('Hi') est ajout√©e √† la pile d'appels. </p><br><p><img src="https://habrastorage.org/webt/ns/-k/-k/ns-k-klle5egqpwjdzbgxkrwaes.png"></p><br><p>  3) Et il est ex√©cut√© </p><br><p><img src="https://habrastorage.org/webt/dp/oo/tz/dpootztdu0jjapitb1v60dzwdcu.png"></p><br><p>  4) Ensuite, console.log ('Hi') est supprim√© de la pile des appels. </p><br><p><img src="https://habrastorage.org/webt/fu/yb/wb/fuybwb7kq0kcxdj4gobj38-r_fc.png"></p><br><p>  5) Allez maintenant √† la commande setTimeout (fonction cb1 () {...}).  Il est ajout√© √† la pile d'appels. </p><br><p><img src="https://habrastorage.org/webt/85/ps/v2/85psv2_s7ec0ibxh8h2991nbxi4.png"></p><br><p>  6) La commande setTimeout (fonction cb1 () {...}) est ex√©cut√©e.  Le navigateur cr√©e une minuterie qui fait partie de l'API Web.  Il fera le compte √† rebours. </p><br><p><img src="https://habrastorage.org/webt/3a/4p/sh/3a4pshoazrkbxfgcajwjqm1cz-m.png"></p><br><p>  7) La commande setTimeout (fonction cb1 () {...}) est termin√©e et est supprim√©e de la pile d'appels. </p><br><p><img src="https://habrastorage.org/webt/oe/qt/ne/oeqtnemv7rawkjpanipkv41qpeq.png"></p><br><p>  8) La commande console.log ('Bye') est ajout√©e √† la pile d'appels. </p><br><p><img src="https://habrastorage.org/webt/bb/mp/fb/bbmpfba1p2tadcztfm-41py_mgi.png"></p><br><p>  9) La commande console.log ('Bye') est ex√©cut√©e. </p><br><p><img src="https://habrastorage.org/webt/d0/ra/3z/d0ra3zfarz4ujmyy46cmsofs8ue.png"></p><br><p>  10) La commande console.log ('Bye') est supprim√©e de la pile d'appels. </p><br><p><img src="https://habrastorage.org/webt/5y/by/dr/5ybydrdk6yuexhgyhbxwsvnkefa.png"></p><br><p>  11) Apr√®s au moins 5000 ms, le temporisateur se termine et place le rappel cb1 dans la file d'attente de rappel. </p><br><p><img src="https://habrastorage.org/webt/sx/of/no/sxofnovn3xkkz5oyngnotdggpcs.png"></p><br><p>  12) La boucle d'√©v√©nement prend c la fonction cb1 de la file d'attente de rappel et la place sur la pile d'appels. </p><br><p><img src="https://habrastorage.org/webt/ge/qp/1t/geqp1t65hnddi0hx0ut4b80ooi0.png"></p><br><p>  13) La fonction cb1 est ex√©cut√©e et ajoute console.log ('cb1') √† la pile d'appels. </p><br><p><img src="https://habrastorage.org/webt/xi/vq/ac/xivqac36m7yv79qocvstugftlb4.png"></p><br><p>  14) La commande console.log ('cb1') est ex√©cut√©e. </p><br><p><img src="https://habrastorage.org/webt/hp/tu/gk/hptugkn_5iizvyhez25bpf8zvpy.png"></p><br><p>  15) La commande console.log ('cb1') est supprim√©e de la pile des appels. </p><br><p><img src="https://habrastorage.org/webt/bh/wr/st/bhwrstroipmqqhrhiit4cmdy-we.png"></p><br><p>  16) La fonction cb1 est supprim√©e de la pile d'appels. </p><br><p>  Jetez un ≈ìil √† un exemple de dynamique: </p><br><p><img src="https://habrastorage.org/webt/xx/nj/a8/xxnja8sfjhdg5ks3ku5q6yzkxvc.gif"></p><br><p>  Eh bien, ici, nous avons examin√© la fa√ßon dont l'asynchronie est impl√©ment√©e en JavaScript.  Parlons maintenant bri√®vement de l'√©volution du code asynchrone. </p><br><h2 id="evolyuciya-asinhronnogo-koda">  L'√©volution du code asynchrone. </h2><br><pre> <code class="javascript hljs">a(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromA</span></span></span><span class="hljs-function">) </span></span>{ b(resultsFromA, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromB</span></span></span><span class="hljs-function">) </span></span>{ c(resultsFromB, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromC</span></span></span><span class="hljs-function">) </span></span>{ d(resultsFromC, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromD</span></span></span><span class="hljs-function">) </span></span>{ e(resultsFromD, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromE</span></span></span><span class="hljs-function">) </span></span>{ f(resultsFromE, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resultsFromF</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(resultsFromF); }) }) }) }) }) });</code> </pre> <br><p>  La programmation asynchrone, telle que nous la connaissons en JavaScript, ne peut √™tre impl√©ment√©e qu'avec des fonctions.  Ils peuvent √™tre pass√©s comme n'importe quelle autre variable √† d'autres fonctions.  Les rappels sont donc n√©s.  Et c'est cool, amusant et provocant, jusqu'√† ce qu'il se transforme en tristesse, envie et tristesse.  Pourquoi?  Oui, tout est simple: </p><br><ul><li>  Avec la complexit√© croissante du code, le projet se transforme rapidement en blocs imbriqu√©s √† plusieurs reprises obscurs - ¬´enfer de rappel¬ª. </li><li>  La gestion des erreurs peut √™tre facilement manqu√©e. </li><li>  Vous ne pouvez pas renvoyer d'expressions avec return. </li></ul><br><p>  Avec Promise, les choses se sont un peu am√©lior√©es. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">2000</span></span>); }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">'FAILED HERE'</span></span>); alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { alert(result); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result + <span class="hljs-number"><span class="hljs-number">2</span></span>; }).catch(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'error: '</span></span>, e); });</code> </pre> <br><ul><li>  Des cha√Ænes de promesses sont apparues, ce qui a am√©lior√© la lisibilit√© du code </li><li>  Une m√©thode distincte de r√©cup√©ration des erreurs est apparue </li><li>  Vous pouvez maintenant ex√©cuter en parall√®le en utilisant Promise.all </li><li>  Nous pouvons r√©soudre l'asynchronie imbriqu√©e avec async / wait </li></ul><br><p>  Mais promis a ses limites.  Par exemple, une promesse, sans danser avec un tambourin, ne peut pas √™tre annul√©e et, surtout, elle fonctionne avec une seule valeur. </p><br><p>  Eh bien, nous avons abord√© en douceur la programmation r√©active.  √ätes-vous fatigu√©?  Eh bien, la bonne chose est que vous pouvez aller faire des go√©lands, r√©fl√©chir et revenir pour lire plus loin.  Et je vais continuer. </p><br><p><img src="https://habrastorage.org/webt/pj/0g/7b/pj0g7bgonkiefme08noahs3y0wc.png" alt="Bases de la programmation r√©active"></p><br><p>  <strong>La programmation r√©active</strong> est un paradigme de programmation ax√© sur les flux de donn√©es et la propagation du changement.  Examinons de plus pr√®s ce qu'est un flux de donn√©es. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     const input = ducument.querySelector('input'); const eventsArray = []; //      eventsArray input.addEventListener('keyup', event =&gt; eventsArray.push(event) );</span></span></code> </pre> <br><p>  Imaginez que nous ayons un champ de saisie.  Nous cr√©ons un tableau, et pour chaque keyup de l'√©v√©nement d'entr√©e, nous enregistrons l'√©v√©nement dans notre tableau.  Dans ce cas, je voudrais noter que notre tableau est tri√© par le temps, c'est-√†-dire  l'indice des √©v√©nements ult√©rieurs est sup√©rieur √† l'indice des √©v√©nements ant√©rieurs.  Un tel tableau est un mod√®le de flux de donn√©es simplifi√©, mais ce n'est pas encore un flux.  Pour que ce tableau soit appel√© en toute s√©curit√© un flux, il doit √™tre en mesure d'informer les abonn√©s qu'il a re√ßu de nouvelles donn√©es.  Nous arrivons donc √† la d√©finition du flux. </p><br><h3 id="potok-dannyh">  Flux de donn√©es </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { interval } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; interval(<span class="hljs-number"><span class="hljs-number">1000</span></span>).pipe( take(<span class="hljs-number"><span class="hljs-number">4</span></span>) )</code> </pre> <br><p><img src="https://habrastorage.org/webt/iu/oe/9k/iuoe9k_c75atoryyrxykddnhuzi.gif"></p><br><p>  <strong>Un flux</strong> est un tableau de donn√©es tri√©es par heure qui peut indiquer que les donn√©es ont chang√©.  Imaginez maintenant √† quel point il devient pratique d'√©crire du code dans lequel vous devez d√©clencher plusieurs √©v√©nements dans diff√©rentes parties du code en une seule action.  Nous venons de nous abonner au flux et il nous fera savoir quand les changements se produiront.  Et la biblioth√®que RxJs peut le faire. </p><br><p><img src="https://habrastorage.org/webt/2e/eg/cv/2eegcvxzcaz0j6x_n27h7nko68s.png"></p><br><p>  <strong>RxJS</strong> est une biblioth√®que pour travailler avec des programmes asynchrones et bas√©s sur des √©v√©nements utilisant des s√©quences observables.  La biblioth√®que fournit le type principal d' <em>Observable</em> , plusieurs types auxiliaires ( <em>Observateur, Planificateurs, Sujets</em> ) et des op√©rateurs de travail avec des √©v√©nements comme avec des collections ( <em>carte, filtre, r√©duire, tout</em> et similaire √† partir de tableau JavaScript). </p><br><p>  Examinons les concepts de base de cette biblioth√®que. </p><br><h3 id="observable-observer-producer">  Observable, observateur, producteur </h3><br><p>  Observable est le premier type de base que nous examinerons.  Cette classe contient l'essentiel de l'impl√©mentation RxJs.  Il est associ√© √† un flux observable auquel vous pouvez vous abonner √† l'aide de la m√©thode d'abonnement. </p><br><p>  Observable impl√©mente un m√©canisme auxiliaire pour cr√©er des mises √† jour, le soi-disant <em>Observer</em> .  La source de valeurs d'Observer s'appelle <em>Producer</em> .  Il peut s'agir d'un tableau, d'un it√©rateur, d'une prise Web, d'une sorte d'√©v√©nement, etc.  On peut donc dire qu'observable est un conducteur entre producteur et observateur. </p><br><p>  Observable g√®re trois types d'√©v√©nements Observer: </p><br><ul><li>  suivant - nouvelles donn√©es </li><li>  erreur - une erreur si la s√©quence s'est termin√©e en raison d'une exception.  cet √©v√©nement implique √©galement l'ach√®vement de la s√©quence. </li><li>  complete - signal sur la fin de la s√©quence.  Cela signifie qu'il n'y aura pas de nouvelles donn√©es. </li></ul><br><p>  Voyons la d√©mo: </p><br><p><img src="https://habrastorage.org/webt/mg/qn/pf/mgqnpfxctqlz3yqwseag1fqttrc.gif"></p><br><p>  Au d√©but, nous traiterons les valeurs 1, 2, 3 et apr√®s 1 seconde.  nous en aurons 4 et terminerons notre flux. </p><br><div class="spoiler">  <b class="spoiler_title">Pens√©es √† l'oreille</b> <div class="spoiler_text"><p>  Et puis j'ai r√©alis√© que raconter √©tait plus int√©ressant que d'√©crire √† ce sujet.  : D </p></div></div><br><h3 id="subscription">  Abonnement </h3><br><p>  Lorsque nous nous abonnons √† un flux, nous cr√©ons une nouvelle classe d' <strong>abonnement</strong> qui nous permet de nous d√©sinscrire en utilisant la m√©thode de <em>d√©sabonnement</em> .  Nous pouvons √©galement regrouper les abonnements √† l'aide de la m√©thode <em>add</em> .  Eh bien, il est logique que nous puissions dissocier les threads avec <em>remove</em> .  Les m√©thodes d'entr√©e ajouter et supprimer acceptent un autre abonnement.  Je voudrais noter que lorsque nous nous d√©sinscrivons, nous nous d√©sinscrivons de tous les abonnements enfants comme s'ils appelaient la m√©thode de d√©sabonnement.  Allez-y. </p><br><h3 id="vidy-potokov">  Types de flux </h3><br><div class="scrollable-table"><table><thead><tr><th>  CHAUD </th><th>  FROID </th></tr></thead><tbody><tr><td>  Producteur cr√©√© √† l'ext√©rieur observable </td><td>  Producteur cr√©√© √† l'int√©rieur observable </td></tr><tr><td>  Les donn√©es sont transf√©r√©es au moment de la cr√©ation de l'observable. </td><td>  Les donn√©es sont communiqu√©es au moment de la souscription </td></tr><tr><td>  Besoin de plus de logique pour vous d√©sinscrire </td><td>  Le fil se termine de lui-m√™me </td></tr><tr><td>  Utilise la communication un-√†-plusieurs </td><td>  Utilise une relation un √† un </td></tr><tr><td>  Tous les abonnements ont la m√™me valeur. </td><td>  Les abonnements sont ind√©pendants </td></tr><tr><td>  Les donn√©es peuvent √™tre perdues s'il n'y a pas d'abonnement </td><td>  R√©√©dite toutes les valeurs de flux pour un nouvel abonnement </td></tr></tbody></table></div><br><p>  Pour donner une analogie, j'imagine un flux chaud comme un film dans une salle de cin√©ma.  √Ä quel moment vous √™tes venu, √† partir de ce moment et avez commenc√© √† regarder.  Je comparerais un flux froid avec un appel dans ceux-ci.  soutien.  Chaque appelant √©coute le r√©pondeur du d√©but √† la fin, mais vous pouvez raccrocher en vous d√©sinscrivant. </p><br><p>  Je voudrais noter qu'il existe encore des flux dits chauds (une telle d√©finition que j'ai rencontr√©e tr√®s rarement et uniquement dans des communaut√©s √©trang√®res) - c'est un flux qui se transforme d'un flux froid en un flux chaud.  La question se pose - o√π utiliser)) Je vais donner un exemple de la pratique. </p><br><p>  Je travaille avec un angulaire.  Il utilise activement rxjs.  Pour obtenir des donn√©es sur le serveur, j'attends un flux froid et j'utilise ce flux dans le mod√®le en utilisant asyncPipe.  Si j'utilise ce tube plusieurs fois, puis, revenant √† la d√©finition d'un flux froid, chaque tube demandera des donn√©es au serveur, ce qui est pour le moins √©trange.  Et si je convertis un flux froid en flux chaud, la demande se produira une fois. </p><br><p>  En g√©n√©ral, la compr√©hension de la forme des flux est assez compliqu√©e pour les d√©butants, mais importante. </p><br><h3 id="operators">  Les op√©rateurs </h3><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.http.get(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${environment.apiUrl}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.apiUrl}</span></span></span><span class="hljs-string">/trade_companies`</span></span>) .pipe( tap(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.companies$$.next(cloneDeep(data))), map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ data }: TradeCompanyList</span></span></span><span class="hljs-function">) =&gt;</span></span> data) );</code> </pre> <br><p>  Les op√©rateurs nous offrent la possibilit√© de travailler avec des flux.  Ils aident √† contr√¥ler les √©v√©nements qui se produisent dans l'Observable.  Nous allons consid√©rer quelques-uns des plus populaires, et les op√©rateurs peuvent √™tre trouv√©s plus en d√©tail en utilisant les liens dans les informations utiles. </p><br><p>  <strong>Op√©rateurs - de</strong> </p><br><p>  Nous commen√ßons par l'op√©rateur auxiliaire de.  Il cr√©e un observable bas√© sur une valeur simple. </p><br><p><img src="https://habrastorage.org/webt/ty/gv/ns/tygvns2-ufljiud304keflcihtw.png"></p><br><p>  <strong>Op√©rateurs - filtre</strong> </p><br><p><img src="https://habrastorage.org/webt/lu/ej/-q/luej-qu433z2ascmvk4avc9qg80.png"></p><br><p>  L'op√©rateur de filtre filtre, comme son nom l'indique, filtre le signal de flux.  Si l'op√©rateur retourne vrai, il saute plus loin. </p><br><p>  <strong>Op√©rateurs - prendre</strong> </p><br><p><img src="https://habrastorage.org/webt/n3/h-/p7/n3h-p7dnsmlrus2qxcid1k-j0sc.png"></p><br><p>  take - Prend la valeur du nombre d'√©missions, apr√®s quoi le flux se termine. </p><br><p>  <strong>Op√©rateurs - debounceTime</strong> </p><br><p><img src="https://habrastorage.org/webt/fm/-h/ov/fm-hovzqqm8setakpkxrq35220i.png"></p><br><p>  debounceTime - supprime les valeurs √©mises qui tombent dans la p√©riode de temps sp√©cifi√©e entre les donn√©es de sortie - apr√®s l'√©coulement de l'intervalle de temps, il √©met la derni√®re valeur. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, take } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); //     1500 setInterval(() =&gt; { observer.next(i++) }, 1500); }).pipe( debounceTime(700), //  700     take(3) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/wq/c4/is/wqc4is_4memtbjbseivewpqsm3y.gif"></p><br><p>  <strong>Op√©rateurs - takeWhile</strong> </p><br><p><img src="https://habrastorage.org/webt/be/_4/bw/be_4bwupgcjmlqubh0bnjfwaq3o.png"></p><br><p>  Il √©met des valeurs jusqu'√† ce que takeWhile renvoie false, apr√®s quoi il se d√©sabonnera du flux. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { debounceTime, takeWhile } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; observer.next(i++); <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++) }, 1000); }).pipe( takeWhile( producer =&gt; producer &lt; 5 ) );</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/fj/yx/ht/fjyxhtlst2zizvmv6uoei5vi_bm.gif"></p><br><p>  <strong>Op√©rateurs - combineLatest</strong> </p><br><p>  L'op√©rateur combine combineLatest est quelque peu similaire √† promise.all.  Il combine plusieurs threads en un seul.  Apr√®s que chaque thread ait √©mis au moins une √©mission, nous obtenons les derni√®res valeurs de chacune sous la forme d'un tableau.  De plus, apr√®s toute √©mission des flux combin√©s, il donnera de nouvelles valeurs. </p><br><p><img src="https://habrastorage.org/webt/cg/lq/pj/cglqpjraurcow4xpusyfy-o-g1i.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { combineLatest, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); combineLatest(observer_1, observer_2).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lx/f6/qc/lxf6qcp3uqlpezwwxzipibko8mw.gif"></p><br><p>  <strong>Op√©rateurs - zip</strong> </p><br><p>  Zip - attend une valeur de chaque flux et forme un tableau bas√© sur ces valeurs.  Si la valeur ne provient d'aucun flux, le groupe ne sera pas form√©. </p><br><p><img src="https://habrastorage.org/webt/_w/uw/u5/_wuwu5ncu3ikb96iszphaeho1cu.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { zip, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }); zip(observer_1, observer_2, observer_3).pipe(take(5));</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/lr/iz/k2/lrizk28md9flrpm-5nkiioxlbw0.gif"></p><br><p>  <strong>Op√©rateurs - forkJoin</strong> </p><br><p>  forkJoin concat√®ne √©galement les threads, mais il ne valorise que lorsque tous les threads sont termin√©s. </p><br><p><img src="https://habrastorage.org/webt/kg/yn/i8/kgyni8bmucerz2-o015i4fnrlrg.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { forkJoin, Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take } = RxOperators; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> observer_1 = Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next('a: ' + i++); }, 1000); }).pipe(take(3)); const observer_2 = Observable.create((observer) =&gt; { let i = 1; //     750 setInterval(() =&gt; { observer.next('b: ' + i++); }, 750); }).pipe(take(5)); const observer_3 = Observable.create((observer) =&gt; { let i = 1; //     500 setInterval(() =&gt; { observer.next('c: ' + i++); }, 500); }).pipe(take(4)); forkJoin(observer_1, observer_2, observer_3);</span></span></code> </pre> <br><p><img src="https://habrastorage.org/webt/34/ny/qn/34nyqnbve4g6gsheeoeaii1qkw0.gif"></p><br><p>  <strong>Op√©rateurs - carte</strong> </p><br><p>  L'op√©rateur de transformation de carte convertit la valeur d'√©mission en une nouvelle. </p><br><p><img src="https://habrastorage.org/webt/z5/cq/gn/z5cqgnureeelbyknte8aohlkjyo.png"></p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { Observable } = Rx; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { take, map } = RxOperators; Observable.create(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observer</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     1000 setInterval(() =&gt; { observer.next(i++); }, 1000); }).pipe( map(x =&gt; x * 10), take(3) );</span></span></code> </pre><br><p><img src="https://habrastorage.org/webt/zy/fz/az/zyfzazyep10bcow9f1nxzumq8nk.gif"></p><br><p>  <strong>Op√©rateurs - partager, toucher</strong> </p><br><p>  L'op√©rateur tap - vous permet de faire des effets secondaires, c'est-√†-dire toutes les actions qui n'affectent pas la s√©quence. </p><br><p>  L'op√©rateur de partage de services publics peut le faire chaud √† partir d'un flux froid. </p><br><p><img src="https://habrastorage.org/webt/2p/lc/fr/2plcfr9agwst3elkl_yglmmfftk.png"></p><br><p>  Avec les op√©rateurs termin√©s.  Passons au sujet. </p><br><div class="spoiler">  <b class="spoiler_title">Pens√©es √† l'oreille</b> <div class="spoiler_text"><p>  Et puis je suis all√© boire des go√©lands.  Ces exemples m'ennuient: D </p></div></div><br><h2 id="semeystvo-subject-ov">  Famille du sujet </h2><br><p>  La famille de sujets est un excellent exemple de flux chauds.  Ces classes sont une sorte d'hybride qui agit simultan√©ment comme observable et observateur.  √âtant donn√© que le sujet est un flux chaud, vous devez vous en d√©sinscrire.  Si nous parlons des m√©thodes de base, alors ceci: </p><br><ul><li>  suivant - transfert de nouvelles donn√©es vers le flux </li><li>  error - erreur et fin du flux </li><li>  complet - fin du flux </li><li>  s'abonner - s'abonner au flux </li><li>  se d√©sinscrire - se d√©sinscrire du flux </li><li>  asObservable - transformer en observateur </li><li>  toPromise - se transforme en promesse </li></ul><br><p>  Attribuer <del>  4 </del>  5 types de sujets. </p><br><div class="spoiler">  <b class="spoiler_title">Pens√©es √† l'oreille</b> <div class="spoiler_text"><p>  Il a parl√© sur le stream 4, mais il s'est av√©r√© qu'ils en ont ajout√© un de plus.  Comme dit le proverbe, vivez et apprenez. </p></div></div><br><p>  Sujet simple <code>new Subject()</code> est le type de sujet le plus simple.  Il est cr√©√© sans param√®tres.  Transmet les valeurs qui ne sont venues qu'apr√®s l'abonnement. </p><br><p>  BehaviorSubject <code>new BehaviorSubject( defaultData&lt;T&gt; )</code> - √† mon avis, le type de sujet le plus courant.  L'entr√©e accepte une valeur par d√©faut.  Il enregistre toujours les donn√©es de la derni√®re √©mission, qu'il transf√®re lors de l'abonnement.  Cette classe poss√®de √©galement une m√©thode de valeur utile qui renvoie la valeur actuelle du flux. </p><br><p>  ReplaySubject <code>new ReplaySubject(bufferSize?: number, windowTime?: number)</code> - L'entr√©e peut √©ventuellement accepter le premier argument comme la taille du tampon de valeurs qu'il stockera en lui-m√™me, et la deuxi√®me fois pendant laquelle nous aurons besoin de modifications. </p><br><p>  AsyncSubject <code>new AsyncSubject()</code> - rien ne se produit lors de l'abonnement, et la valeur ne sera retourn√©e qu'une fois termin√©e.  Seule la derni√®re valeur de flux sera retourn√©e. </p><br><p>  WebSocketSubject <code>new WebSocketSubject(urlConfigOrSource: string | WebSocketSubjectConfig&lt;T&gt; | Observable&lt;T&gt;, destination?: Observer&lt;T&gt;)</code> - La documentation est silencieuse √† ce sujet et je la vois pour la premi√®re fois.  Qui sait ce qu'il fait, √©crit, compl√®te. </p><br><p>  Fuf.  Eh bien, ici, nous avons consid√©r√© tout ce que je voulais dire aujourd'hui.  J'esp√®re que ces informations vous ont √©t√© utiles.  Vous pouvez vous familiariser avec la liste des r√©f√©rences dans l'onglet informations utiles. </p><br><h2 id="poleznaya-informaciya">  Informations utiles </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien de flux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: pr√©sentation du moteur, des m√©canismes d'ex√©cution et de la pile d'appels</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de JS: boucle d'√©v√©nements, asynchrone et cinq fa√ßons d'am√©liorer le code √† l'aide de l'async / wait</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Fonctionnement de la boucle d'√©v√©nements dans JavaSript</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âvolution JavaScript asynchrone</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que RxJS et pourquoi est-il utile de le savoir</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Application pratique de RxJS</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tutoriel RxJS Observables - Cr√©ation et abonnement √† Observables</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RXJS: Observables chauds et froids</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classes, fonctions pour cr√©er un observable.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les op√©rateurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Op√©rateurs RxJS par exemple</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Liste des API</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vari√©t√©s de sujet et de listes dans RxJS</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr462355/">https://habr.com/ru/post/fr462355/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr462337/index.html">Statistiques du site et votre petit r√©f√©rentiel</a></li>
<li><a href="../fr462339/index.html">Comment la formation manuelle est-elle li√©e aux normes internes d'Amazon et comment a-t-elle affect√© la vision du monde de l'entreprise?</a></li>
<li><a href="../fr462347/index.html">Les dix premiers jours sur le chemin d'un hibou √† un l√®ve-t√¥t: sommeil, alimentation, r√©gime et exercice</a></li>
<li><a href="../fr462349/index.html">RESTinio est un serveur HTTP asynchrone. Un exemple simple de la pratique: renvoyer une grande quantit√© de donn√©es en r√©ponse</a></li>
<li><a href="../fr462353/index.html">FAQ sur la s√©curit√© du protocole LoRaWAN</a></li>
<li><a href="../fr462357/index.html">Premier prototype: Unikernels comme √©tape de l'√©volution de Linux</a></li>
<li><a href="../fr462359/index.html">Dat - de quel protocole s'agit-il et qui l'utilise</a></li>
<li><a href="../fr462365/index.html">Limitations de l'apprentissage automatique</a></li>
<li><a href="../fr462367/index.html">13 faits sur le capital-risque pour les fondateurs</a></li>
<li><a href="../fr462371/index.html">D√©marrer Spring StateMachine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>