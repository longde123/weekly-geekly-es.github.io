<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚏 👸🏾 🐏 面向协议的编程，第2部分 👼 🚶 📨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本主题的继续中，我们将研究协议类型和通用代码。 


 在此过程中将考虑以下问题： 


- 在没有继承和引用类型的情况下实现多态 
- 协议类型对象如何存储和使用 
- 方法分派如何与他们一起工作 
 协议类型 


 在没有继承和引用类型的情况下实现多态： 


protocol Drawab...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>面向协议的编程，第2部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474558/"><p> 在本主题的继续中，我们将研究协议类型和通用代码。 </p><br><p> 在此过程中将考虑以下问题： </p><br><ul><li> 在没有继承和引用类型的情况下实现多态 </li><li> 协议类型对象如何存储和使用 </li><li> 方法分派如何与他们一起工作 </li></ul><a name="habracut"></a><br><h2 id="protokolnye-tipy">  <strong>协议类型</strong> </h2><br><p>  <strong>在没有继承和引用类型的情况下实现多态：</strong> </p><br><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x, y: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Line</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, x2, y1, y2: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ... } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> drawbles = [<span class="hljs-type"><span class="hljs-type">Drawable</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> drawbles { d.draw() }</code> </pre> <br><ol><li> 表示Drawable协议，它具有draw方法。 </li><li> 我们为点和线实现了此协议-现在您可以像使用Drawable一样处理它们（调用draw方法） </li></ol><br><p> 我们仍然有一个多态代码。  drawables数组的d元素具有一个接口，该接口在Drawable协议中指示，但具有不同的方法实现，在Line和Point中指示。 </p><br><blockquote> 多态性的主要原理（即席）：“通用接口-许多实现” </blockquote><p>  <strong>没有虚拟表的动态调度</strong> </p><br><p> 回想一下，使用类（引用类型）时，方法的正确实现的定义是通过动态提交和虚拟表实现的。 每个类类型都有一个虚拟表；它存储其方法的实现。 动态分派通过查看其虚拟表来定义类型的方法实现。 由于继承和覆盖方法的可能性，所有这些都是必要的。 </p><br><p> 在结构的情况下，继承以及方法的重新定义都是不可能的。 然后，乍一看，不需要虚拟表，但是动态调度又将如何工作呢？ 程序如何理解将在d.draw（）上调用哪个方法？ </p><br><blockquote> 值得注意的是，此方法的实现数量等于符合Drawable协议的类型的数量。 </blockquote><br><h2 id="protocol-witness-table">  <strong>协议见证表</strong> </h2><br><p> 是这个问题的答案。 实现协议的每种类型都有此表。 就像类的虚拟表一样，它存储协议所需的方法的实现。 </p><br><blockquote> 在下文中，协议见证表将被称为“协议方法表” </blockquote><p> 好的，现在我们知道了在哪里寻找方法的实现。 仅剩下两个问题： </p><br><ol><li> 如何为实现此协议的对象找到合适的协议方法表？ 在我们的情况下，如何为drawables数组的d元素找到此表？ </li><li> 数组的元素必须具有相同的大小（这是数组的本质）。 如果可绘制数组可以在其中存储线和点，并且它们具有不同的大小，那么如何满足此要求呢？ </li></ol><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)) <span class="hljs-comment"><span class="hljs-comment">// 32 bits MemoryLayout.size(ofValue: Point(...)) // 16 bits</span></span></code> </pre> <br><h3 id="ekzistencialnyy-konteyner"> 现有容器 </h3><br><p> 为了解决这两个问题，Swift使用一种特殊的存储方案存储协议类型的实例，称为存在容器。 看起来像这样： </p><br><p><img src="https://habrastorage.org/webt/ru/nt/v_/runtv_rsqkbtwyq0soofiqidbde.jpeg"></p><br><p> 它需要5个机器字（在x64位系统中为5 * 8 = 40位）。 它分为三个部分： </p><br><p> 值缓冲区-实例本身的空间 <br>  vwt-指向价值见证表的指针 <br>  pwt-指向协议见证表的指针 </p><br><p> 更详细地考虑所有三个部分： </p><br><p>  <strong>内容缓冲区</strong> </p><br><p> 只需三个机器字即可存储实例。 如果实例可以容纳在内容缓冲区中，则将其存储在其中。 如果实例具有3个以上的机器字，则它将不适合缓冲区，并且程序将被迫在堆上分配内存，将该实例放在该内存中，然后将指向该内存的指针放在内容缓冲区中。 考虑一个例子： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Point</span></span>(...)</code> </pre> <br><p>  Point（）占用2个机器字，并且完全适合值缓冲区-程序会将其放置在其中： </p><br><p><img src="https://habrastorage.org/webt/c3/it/ir/c3itirb85eqbbrvpop_9jstl0vm.jpeg"></p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...)</code> </pre> <br><p>  Line（）占用4个机器字，无法容纳在值缓冲区中-程序将为其分配内存以供堆使用，并在值缓冲区中添加指向该内存的指针： </p><br><p><img src="https://habrastorage.org/webt/jm/5w/yj/jm5wyjsk6zazutscdsx8a1a32y4.jpeg"></p><br><p>  ptr指向放置在堆上的Line（）的实例： </p><br><p><img src="https://habrastorage.org/webt/we/sk/td/wesktdeuiw6iypty_2dkbklezgm.jpeg"></p><br><p>  <strong>生命周期表</strong> </p><br><p> 与协议方法表一样，具有协议的每个表都具有该表。 它包含四个方法的实现：分配，复制，销毁，取消分配。 这些方法控制对象的整个生命周期。 考虑一个例子： </p><br><ol><li> 创建对象时（点（...）为Drawable），从T.Zh开始分配方法。 这个对象。 分配方法将决定对象的内容应放置在何处（在值缓冲区中还是在堆中），如果应将其放置在堆中，它将分配所需的内存量 </li><li> 复制方法会将对象的内容放在适当的位置。 </li><li> 处理完对象后，将调用destruct方法，该方法将减少所有链接数（如果有） </li><li> 销毁后，将调用deallocate方法，该方法将释放在堆上分配的内存（如果有） </li></ol><br><p>  <strong>协议方法表</strong> </p><br><p> 如上所述，它包含该表绑定到的类型的协议所需的方法的实现。 </p><br><p>  <strong>现有容器-答案</strong> </p><br><p> 因此，我们回答了两个问题： </p><br><ol><li> 协议方法表存储在此对象的Existential容器中，可以从中轻松获得 </li><li> 如果数组的元素类型是协议，则此数组的任何元素都采用5个机器字的固定值-这正是现有容器所需要的。 如果元素的内容不能放置在值缓冲区中，则它将放置在堆中。 如果可以，那么所有内容将被放置在值缓冲区中。 无论如何，我们得到具有协议类型的对象的大小是5个机器字（40位），并且随之而来的是数组的所有元素都将具有相同的大小。 </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> line: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-type"><span class="hljs-type">MemoryLayout</span></span>.size(ofValue: line) <span class="hljs-comment"><span class="hljs-comment">// 40 bits let drawables: [Drawable] = [Line(...), Point(...), Line(...)] MemoryLayout.size(ofValue: drawables._content) // 120 bits</span></span></code> </pre> <br><p>  <strong>现有容器-示例</strong> </p><br><p> 考虑以下代码中存在容器的行为： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(local: Drawable)</span></span></span></span> { local.draw() } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) drawACopy(val)</code> </pre> <br><p> 存在容器可以这样表示： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExistContDrawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> valueBuffer: (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vwt: <span class="hljs-type"><span class="hljs-type">ValueWitnessTable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pwt: <span class="hljs-type"><span class="hljs-type">ProtocolWitnessTable</span></span> }</code> </pre> <br><p>  <strong>伪代码</strong> </p><br><p> 在幕后，drawACopy函数采用ExistContDrawable： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... }</code> </pre> <br><p> 函数参数是手动创建的：创建一个容器，并从接收到的参数中填充其字段： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> local = <span class="hljs-type"><span class="hljs-type">ExistContDrawable</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vwt = val.vwt <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pwt = val.pwt local.type = type local.pwt = pwt ... }</code> </pre> <br><p> 我们决定内容的存储位置（在缓冲区或堆中）。 我们调用vwt.allocate和vwt.copy来用val填充本地内容： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.allocateBufferAndCopy(&amp;local, val) }</code> </pre> <br><p> 我们调用draw方法并向其传递一个指向self的指针（projectBuffer方法将确定self的位置-在缓冲区中还是在堆上-并返回正确的指针）： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... pwt.draw(vwt.projectBuffer(&amp;local)) }</code> </pre> <br><p> 我们完成了与当地的合作。 我们从当地清理所有臀部链接。 该函数返回一个值-我们清除分配给drawACopy（堆栈帧）的所有内存： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawACopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(val: ExistContDrawable)</span></span></span></span> { ... vwt.destructAndDeallocateBuffer(&amp;local) }</code> </pre> <br><p>  <strong>现有容器-目的</strong> </p><br><p> 使用现有的容器需要大量工作-上面的示例证实了这一点-但是为什么它甚至有必要，目的是什么？ 目标是使用协议及其实现类型来实现多态。 在OOP中，我们使用抽象类并通过重写方法从它们继承。 在EPP中，我们使用协议并实现其要求。 同样，即使使用协议，实现多态也是一项艰巨且耗能的工作。 因此，为了避免“不必要的”工作，您需要了解何时需要多态性，何时不需要多态性。 </p><br><p> 在EPP的实现中，多态性的一个事实是，使用结构，我们不需要常量引用计数，就没有类继承。 是的，一切都非常相似，类使用虚拟表来确定方法的实现，协议使用协议方法。 将类放置在堆上，有时也可以将结构放置在堆上。 但是问题在于，可以将尽可能多的指针指向放置在堆上的类，并且引用计数是必需的，并且只有一个指向放置在堆上的结构的指针，并将其存储在一个存在容器中。 </p><br><p> 实际上，重要的是要注意，存储在存在性容器中的结构将保留值类型的语义，而不管它是放在堆栈还是堆上。 生命周期表负责语义的保留，因为它描述了确定语义的方法。 </p><br><p>  <strong>现有容器-存储的属性</strong> </p><br><p> 我们研究了函数如何传递和使用协议类型的变量。 让我们考虑一下如何存储这些变量： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pair</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(<span class="hljs-number"><span class="hljs-number">_</span></span> f: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span> s: <span class="hljs-type"><span class="hljs-type">Drawable</span></span>) { first = f second = s } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> first: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> second: <span class="hljs-type"><span class="hljs-type">Drawable</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(<span class="hljs-type"><span class="hljs-type">Line</span></span>(), <span class="hljs-type"><span class="hljs-type">Point</span></span>())</code> </pre> <br><p> 这两个Drawable结构如何存储在Pair结构中？ 对的内容是什么？ 它由两个存在的容器组成-一个用于第一个，另一个用于第二个。 行不能容纳在缓冲区中，而是放置在堆上。 点拟合在缓冲区中。 它还允许Pair结构存储不同大小的对象： </p><br><pre> <code class="swift hljs">pair.second = <span class="hljs-type"><span class="hljs-type">Line</span></span>()</code> </pre> <br><p> 现在，第二个内容也放置在堆上，因为它不适合缓冲区。 考虑一下这可能导致： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">Line</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p> 执行此代码后，程序将收到以下内存状态： </p><br><p><img src="https://habrastorage.org/webt/yp/qz/td/ypqztdofriyggwgvlrl2rc3wvtc.jpeg"></p><br><p> 我们在堆上有4个内存分配，这不好。 让我们尝试修复： </p><br><ol><li> 创建一个模拟类Line </li></ol><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LineStorage</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1, y1, x2, y2: <span class="hljs-type"><span class="hljs-type">Double</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre> <br><ol><li> 我们成对使用 </li></ol><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lineStorage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(lineStorage, lineStorage) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair</code> </pre> <br><p> 我们在堆上得到一个放置，并指向它四个指针： </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p> 但是我们正在处理参照行为。 更改copy.first会影响pair.first（与.second相同），这并不总是我们想要的。 </p><br><p>  <strong>间接存储和更改时复制（写时复制）</strong> </p><br><p> 在此之前，曾提到过String是写时复制结构（将其内容存储在堆中，并在更改时进行复制）。 考虑如何实现您的结构，该结构在更改时将被复制： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BetterLine</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Drawable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> storage: <span class="hljs-type"><span class="hljs-type">LineStorage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>() { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>((<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Double</span></span> { ... } <span class="hljs-keyword"><span class="hljs-keyword">mutating</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isKnownUniquelyReferenced(&amp;storage) { storage = <span class="hljs-type"><span class="hljs-type">LineStorage</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.storage) } <span class="hljs-comment"><span class="hljs-comment">// storage editing } }</span></span></code> </pre> <br><ol><li>  BetterLine将所有属性存储在存储中，而存储是一个类，存储在堆中。 </li><li> 只能使用move方法更改存储。 在其中，我们检查是否只有一个指针指向存储。 如果有更多的指针，则此BetterLine与某人共享存储，并且为了使BetterLine完全表现为结构，存储必须是独立的-我们会进行复制并在以后使用它。 </li></ol><br><p> 让我们看看它如何在内存中工作： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> aLine = <span class="hljs-type"><span class="hljs-type">BetterLine</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> pair = <span class="hljs-type"><span class="hljs-type">Pair</span></span>(aLine, aLine) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = pair copy.second.x1 = <span class="hljs-number"><span class="hljs-number">3.0</span></span></code> </pre> <br><p> 通过执行此代码，我们得到： </p><br><p><img src="https://habrastorage.org/webt/8q/dt/xe/8qdtxe8s2qoavdxl4qxyljpqe1a.jpeg"></p><br><p> 换句话说，我们有两个Pair实例共享相同的存储：LineStorage。 在一个用户（第一位/第二位）中更改存储时，将为此用户创建一个单独的存储副本，以使其更改不会影响其他用户。 这解决了前面示例中违反值类型语义的问题。 </p><br><h2 id="protokolnye-tipy---itog"> 协议类型-摘要 </h2><br><ol><li>  <em>小值</em> 。 如果我们使用的对象占用很少的内存并且可以放置在存在容器的缓冲区中，则： </li></ol><br><ul><li> 堆上没有放置 </li><li> 没有参考计数 </li><li> 使用协议表进行多态性（动态发送） </li></ul><br><ol><li>  <em>物超所值。</em> 如果我们使用缓冲区中不适合的对象，则： </li></ol><br><ul><li> 堆放置 </li><li> 如果对象包含链接，则进行引用计数。 </li></ul><br><blockquote> 已经证明了使用重写进行更改和间接存储的机制，并且在有大量引用引用计数的情况下，可以大大改善这种情况。 </blockquote><p> 我们发现协议类型（如类）能够实现多态。 这是通过存储在存在的容器中并使用协议表（生命周期表和协议方法表）来实现的。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN474558/">https://habr.com/ru/post/zh-CN474558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN474546/index.html">从Terraform移至CloudFormation-很遗憾</a></li>
<li><a href="../zh-CN474548/index.html">Google BERT是一种新的搜索算法。 排名将如何变化以及现在该怎么做？</a></li>
<li><a href="../zh-CN474550/index.html">如何在新的Firefox 70中返回绿色的TLS指示器？</a></li>
<li><a href="../zh-CN474554/index.html">英特尔Tremont-新型能效微体系结构</a></li>
<li><a href="../zh-CN474556/index.html">如何使PCRE2支持Apache 2.4</a></li>
<li><a href="../zh-CN474560/index.html">从经济学家到定制开发经理的4个步骤，或者说IT作为解决无聊问题的一种方法</a></li>
<li><a href="../zh-CN474562/index.html">LEGO MINDSTORMS Education EV3 + MicroPython：我们用成人语言编写儿童的构造函数</a></li>
<li><a href="../zh-CN474564/index.html">自动进样器-永生</a></li>
<li><a href="../zh-CN474566/index.html">这个城市需要一个新英雄：Bobby Hero防盗背包回顾</a></li>
<li><a href="../zh-CN474568/index.html">牙齿中的牛奶：细胞职业的转变</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>