<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥪 ☁️ 💜 Test des applications Flutter. Commencer 👩🏼‍🏫 👒 🏳️‍🌈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On se souvient de Flutter lorsqu'il est nécessaire de créer rapidement une application belle et réactive pour plusieurs plateformes à la fois, mais co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test des applications Flutter. Commencer</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/468631/"><p>  On se souvient de Flutter lorsqu'il est nécessaire de créer rapidement une application belle et réactive pour plusieurs plateformes à la fois, mais comment garantir la qualité du code «rapide»? <br>  Vous serez surpris, mais Flutter a les moyens non seulement d'assurer la qualité du code, mais aussi de garantir l'opérabilité de l'interface visuelle. <br>  Dans l'article, nous examinerons comment les choses se passent avec les tests sur Flutter, nous analyserons les tests de widgets et les tests d'intégration de l'application dans son ensemble. </p><br><p><img src="https://habrastorage.org/webt/nr/vc/tb/nrvctbv08rqv1xge9z2zknv69ym.jpeg"></p><a name="habracut"></a><br><p>  J'ai commencé à étudier Flutter il y a plus d'un an, avant sa sortie officielle, au cours de l'étude, il n'a pas été difficile de trouver des informations sur le développement.  Et quand j'ai voulu essayer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TDD</a> , il s'est avéré que les informations sur les tests étaient désastreusement petites.  En russe, et en général, presque aucun.  Les problèmes de test devaient être étudiés indépendamment, selon le code source des tests Flutter et des articles rares en anglais.  Tout ce que j'ai étudié sur le test des éléments visuels, je l'ai décrit dans un article pour aider ceux qui commencent tout juste à approfondir le sujet. </p><br><h2 id="widget-testing-vidzhet-testy">  Test des widgets </h2><br><h3 id="obschie-svedeniya">  Informations générales </h3><br><p>  Un test de widget teste un seul widget.  Il peut également être appelé test de composant.  Le but du test est de prouver que l'interface utilisateur du widget ressemble et interagit comme prévu.  Le test d'un widget nécessite un environnement de test qui fournit le contexte approprié pour le cycle de vie du widget. <br>  Le widget testé a la capacité de recevoir des actions et des événements utilisateur et d'y répondre, de créer une arborescence de widgets enfants.  Par conséquent, les tests de widgets sont plus complexes que les tests unitaires.  Cependant, comme le test unitaire, l'environnement de test de widget est une simulation simple, beaucoup plus simple qu'un système d'interface utilisateur à part entière. </p><br><p>  Les tests de widgets vous permettent d'isoler et de tester le comportement d'un seul élément de l'interface visuelle.  Et, ce qui est remarquable, d'effectuer toutes les vérifications dans la console, ce qui est idéal pour les tests qui s'exécutent dans le cadre du processus CI / CD. </p><br><p>  Les fichiers contenant des tests se trouvent généralement dans le sous-répertoire de <strong>test</strong> du projet. <br>  Les tests peuvent être exécutés à partir de l'EDI ou de la console avec la commande: </p><br><pre><code class="plaintext hljs">$ flutter test</code> </pre> <br><p>  Dans ce cas, tous les tests avec le masque * <strong>_test.dart</strong> du sous-répertoire <strong>test</strong> seront exécutés. <br>  Vous pouvez exécuter un test distinct en spécifiant le nom du fichier: </p><br><pre> <code class="plaintext hljs">$ flutter test test/phone_screen_test.dart</code> </pre> <br><p>  Le test est créé par la fonction <strong>testWidgets</strong> , qui reçoit un outil comme paramètre de <strong>testeur</strong> , avec lequel le code de test interagit avec le widget testé: </p><br><pre> <code class="java hljs">testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   });</span></span></code> </pre> <br><p>  Pour combiner des tests en blocs logiques, les fonctions de test peuvent être combinées en groupes, à l'intérieur de la fonction de <strong>groupe</strong> : </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'  '</span></span>, (){ testWidgets(<span class="hljs-string"><span class="hljs-string">' '</span></span>, (WidgetTester tester) async { <span class="hljs-comment"><span class="hljs-comment">//   }); testWidgets(' ', (WidgetTester tester) async { //   }); });</span></span></code> </pre> <br><p>  Les fonctions <strong>setUp</strong> et <strong>tearDown</strong> vous permettent d'exécuter du code «avant» et «après» chaque test.  En conséquence, les fonctions <strong>setUpAll</strong> et <strong>tearDownAll</strong> vous permettent d'exécuter le code «avant» et «après» tous les tests, et si ces fonctions sont appelées à l'intérieur du groupe, elles seront appelées «avant» et «après» l'exécution de tous les tests du groupe: </p><br><pre> <code class="java hljs">setUp(() { <span class="hljs-comment"><span class="hljs-comment">//    }); tearDown(() { //    });</span></span></code> </pre> <br><h3 id="poisk-vidzhetov">  Recherche de widgets </h3><br><p>  Afin d'effectuer une action sur un widget imbriqué, vous devez le trouver dans l'arborescence du widget.  Pour ce faire, il existe un objet de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>recherche</strong></a> global qui vous permet de trouver des widgets: </p><br><ul><li>  dans l'arborescence par text - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  par clé - <strong>find.byKey</strong> ; </li><li>  par icône - <strong>find.byIcon</strong> , <strong>find.widgetWithIcon</strong> ; </li><li>  par type - <strong>find.byType</strong> ; </li><li>  par position dans l'arbre - <strong>find.descendant</strong> et <strong>find.ancestor</strong> ; </li><li>  en utilisant une fonction qui analyse les widgets sur une liste - <strong>find.byWidgetPredicate</strong> . </li></ul><br><h3 id="vzaimodeystvie-s-testiruemym-vidzhetom">  Tester l'interaction du widget </h3><br><p>  La classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>WidgetTester</strong></a> fournit des fonctions pour créer un widget de test, en attendant que son état change et pour effectuer certaines actions sur ces widgets. <br>  Toute modification du widget entraîne une modification de son état.  Mais l'environnement de test ne reconstruit pas le widget en même temps.  Vous devez indiquer indépendamment à l'environnement de test que vous souhaitez reconstruire le widget en appelant les fonctions <strong>pump</strong> ou <strong>pumpAndSettle</strong> . </p><br><ul><li>  <strong>pumpWidget</strong> - créez un widget de test; </li><li>  <strong>pompe</strong> - commence à traiter la transition d'état du widget et attend qu'elle se termine dans le délai spécifié (100 ms par défaut); </li><li>  <strong>pumpAndSettle</strong> - appelle la pompe dans un cycle pour changer les états pendant un délai donné (100 ms par défaut), c'est l'attente pour que toutes les animations se terminent; </li><li>  <strong>appuyez sur</strong> - envoyez un clic au widget; </li><li>  <strong>longPress</strong> - <strong>appui</strong> long; </li><li>  <strong>lancer</strong> - glisser / glisser; </li><li>  <strong>glisser</strong> -transférer; </li><li>  <strong>enterText</strong> - saisie de texte. </li></ul><br><p>  Les tests peuvent implémenter à la fois des scénarios positifs, en vérifiant les opportunités planifiées et des scénarios négatifs pour s'assurer qu'ils n'entraînent pas de conséquences fatales, par exemple, lorsqu'un utilisateur clique dans la mauvaise direction et n'entre pas ce qui est requis: </p><br><pre> <code class="java hljs">await tester.enterText(find.byKey(Key(<span class="hljs-string"><span class="hljs-string">'phoneField'</span></span>)), <span class="hljs-string"><span class="hljs-string">'bla-bla-bla'</span></span>);</code> </pre> <br><p>  Après toute action avec des widgets, vous devez appeler <strong>tester.pumpAndSettle ()</strong> pour changer les états. </p><br><h3 id="moki">  Moki </h3><br><p>  Beaucoup connaissent la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Mockito</strong></a> .  Cette bibliothèque du monde Java s'est avérée si réussie qu'il existe des implémentations de cette bibliothèque dans de nombreux langages de programmation, y compris Dart. </p><br><p>  Pour vous connecter, vous devez ajouter la dépendance au projet.  Ajoutez les lignes suivantes au fichier <strong>pubspec.yaml</strong> : </p><br><pre> <code class="plaintext hljs">dependencies: mockito: any</code> </pre> <br><p>  Et connectez-vous dans le fichier de test: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:mockito/mockito.dart'</span></span>;</code> </pre> <br><p>  Cette bibliothèque vous permet de créer des classes moque, dont dépend le widget testé, afin que le test soit plus simple et ne couvre que le code que nous testons. <br>  Par exemple, si nous testons le widget <strong>PhoneInputScreen</strong> , qui, lorsqu'il est cliqué, à l'aide du service <strong>AuthInteractor</strong> , effectue une demande au <strong>backend</strong> authInteractor.checkAccess <strong>()</strong> , puis en remplaçant la maquette au lieu du service, nous pouvons vérifier la chose la plus importante - le fait d'accéder à ce service. </p><br><p>  Les mobs de dépendance sont créés en tant que descendants de la classe <strong>Mock</strong> et implémentent l'interface de dépendance: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Une classe dans Dart est également une interface, il n'est donc pas nécessaire de déclarer l'interface séparément, comme dans certains autres langages de programmation. </p><br><p>  Pour déterminer la fonctionnalité du mok, la fonction <strong>when</strong> est utilisée, ce qui vous permet de déterminer la réponse du mok à l'appel d'une fonction: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.value(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>));</code> </pre> <br><p>  Moki peut renvoyer des erreurs ou des données erronées: </p><br><pre> <code class="java hljs">when( authInteractor.checkAccess(any), ).thenAnswer((_) =&gt; Future.error(UnknownHttpStatusCode(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)));</code> </pre> <br><h3 id="proverki">  Chèques </h3><br><p>  Pendant le test, vous pouvez vérifier les widgets à l'écran.  Cela vous permet de vous assurer que le nouvel état de l'écran est correct en termes de visibilité des widgets souhaités: </p><br><pre> <code class="java hljs">expect(find.text(<span class="hljs-string"><span class="hljs-string">' '</span></span>), findsOneWidget); expect(find.text(<span class="hljs-string"><span class="hljs-string">'  '</span></span>), findsNothing);</code> </pre> <br><p>  Une fois le test terminé, vous pouvez également vérifier quelles méthodes de la classe mob ont été appelées pendant le test et combien de fois.  Cela est nécessaire, par exemple, pour comprendre si telle ou telle donnée est demandée trop souvent, s'il y a des changements inutiles dans l'état de l'application: </p><br><pre> <code class="java hljs">verify(appComponent.authInteractor).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verify(authInteractor.checkAccess(any)).called(<span class="hljs-number"><span class="hljs-number">1</span></span>); verifyNever(appComponent.profileInteractor);</code> </pre> <br><h3 id="otladka">  Débogage </h3><br><p>  Les tests sont effectués dans la console sans aucun graphique.  Vous pouvez exécuter des tests en mode débogage et définir des points d'arrêt dans le code du widget. </p><br><p>  Pour avoir une idée de ce qui se passe dans l'arborescence des widgets, vous pouvez utiliser la fonction <strong>debugDumpApp ()</strong> , qui, lorsqu'elle est appelée dans le code de test, affiche la représentation textuelle de la hiérarchie de l'arborescence des widgets entière à un moment donné dans la console. </p><br><p>  Pour comprendre comment le widget utilise moki, il existe une fonction <strong>logInvocations ()</strong> .  Il prend en paramètre une liste de moxas et envoie à la console une séquence d'appels de méthode pour ces moxas qui ont été effectués lors du test. </p><br><p>  Un exemple d'une telle conclusion est ci-dessous.  La marque <strong>VERIFIÉE se</strong> trouve sur les appels qui ont été vérifiés lors du test à l'aide de la fonction de <strong>vérification</strong> : </p><br><pre> <code class="plaintext hljs">AppComponentMock.sessionChangedInteractor [VERIFIED] AppComponentMock.authInteractor [VERIFIED] AuthInteractorMock.checkAccess(71111111111)</code> </pre> <br><h3 id="podgotovka">  La préparation </h3><br><p>  Toutes les dépendances doivent être soumises au widget testé sous la forme d'un mok: </p><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponentMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractorMock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mock</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AuthInteractor</span></span></span><span class="hljs-class"> </span></span>{}</code> </pre> <br><p>  Le transfert des dépendances vers le composant testé doit être effectué d'une manière ou d'une autre acceptée dans votre application.  Pour simplifier la narration, considérons un exemple où les dépendances sont transmises via le constructeur. </p><br><p>  Dans l'exemple de code, <strong>PhoneInputScreen</strong> est un widget de test basé sur <strong>StatefulWidget</strong> enveloppé dans <strong>Scaffold</strong> .  Il est créé dans un environnement de test à l'aide de la fonction <strong>pumpWidget ()</strong> : </p><br><pre> <code class="java hljs">await tester.pumpWidget(PhoneInputScreen(mock));</code> </pre> <br><p>  Cependant, un vrai widget peut utiliser l'alignement pour les widgets imbriqués, ce qui nécessite <strong>MediaQuery</strong> dans l'arborescence des widgets, il obtient probablement <strong>Navigator.of (context)</strong> pour la navigation, il est donc plus pratique d'envelopper le widget sous test dans <strong>MaterialApp</strong> ou <strong>CupertinoApp</strong> : </p><br><pre> <code class="java hljs">await tester.pumpWidget( MaterialApp( home: PhoneInputScreen(mock), ), );</code> </pre> <br><p>  Après avoir créé un widget de test et après toute action avec celui-ci, vous devez appeler <strong>tester.pumpAndSettle ()</strong> pour que l'environnement de test <strong>gère</strong> toutes les modifications de l'état du widget. </p><br><h2 id="integration-tests-integracionnye-testy">  Tests d'intégration </h2><br><h3 id="obschie-svedeniya-1">  Informations générales </h3><br><p>  Contrairement aux tests de widgets, le test d'intégration vérifie l'intégralité de l'application ou une grande partie de celle-ci.  L'objectif du test d'intégration est de s'assurer que tous les widgets et services fonctionnent ensemble comme prévu.  Le fonctionnement du test d'intégration peut être observé dans le simulateur ou sur l'écran de l'appareil.  Cette méthode est un bon substitut aux tests manuels.  De plus, des tests d'intégration peuvent être utilisés pour tester les performances des applications. </p><br><p>  Le test d'intégration est généralement effectué sur un véritable appareil ou émulateur, tel que iOS Simulator ou Android Emulator. </p><br><p>  Les fichiers contenant des tests d'intégration sont généralement situés dans le sous-répertoire <strong>test_driver</strong> du projet. </p><br><p>  L'application est isolée du code du pilote de test et démarre après celui-ci.  Le pilote de test vous permet de contrôler l'application pendant le test.  Cela ressemble à ceci: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:flutter_driver/driver_extension.dart'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'package:app_package_name/main.dart'</span></span> as app; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ enableFlutterDriverExtension(); app.main(); }</code> </pre> <br><p>  Les tests sont exécutés à partir de la ligne de commande.  Si le lancement de l'application cible est décrit dans le fichier <strong>app.dart</strong> et que le script de test s'appelle <strong>app_test.dart</strong> , la commande suivante suffit: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart</code> </pre> <br><p>  Si le script de test a un nom différent, vous devez le spécifier explicitement: </p><br><pre> <code class="plaintext hljs">$ flutter drive --target=test_driver/app.dart --driver=test_driver/home_test.dart</code> </pre> <br><p>  Un test est créé par la fonction de <strong>test</strong> et groupé par la fonction de <strong>groupe</strong> . </p><br><pre> <code class="java hljs">group(<span class="hljs-string"><span class="hljs-string">'park-flutter app'</span></span>, () { <span class="hljs-comment"><span class="hljs-comment">// ,       FlutterDriver driver; //     setUpAll(() async { driver = await FlutterDriver.connect(); }); //     tearDownAll(() async { if (driver != null) { driver.close(); } }); test(' ', () async { //   }); test(' ', () async { //   }); }</span></span></code> </pre> <br><p>  Cet exemple montre le code de création d'un pilote de test via lequel les tests interagissent avec l'application testée. </p><br><h3 id="vzaimodeystvie-s-testiruemym-prilozheniem">  Interaction avec l'application testée </h3><br><p>  L'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>FlutterDriver</strong></a> interagit avec l'application de test via les méthodes suivantes: </p><br><ul><li>  <strong>appuyez sur</strong> - envoyez un clic au widget; </li><li>  <strong>waitFor</strong> - attendez que le widget apparaisse à l'écran; </li><li>  <strong>waitForAbsent</strong> - attendez que le widget disparaisse; </li><li>  <strong>scroll</strong> et <strong>scrollIntoView</strong> , <strong>scrollUntilVisible</strong> - <strong>faites</strong> défiler l'écran jusqu'au décalage spécifié ou au widget souhaité; </li><li>  <strong>enterText</strong> , <strong>getText</strong> - entrez du texte ou prenez le texte du widget; </li><li>  <strong>capture d'écran</strong> - obtenez une capture d'écran; </li><li>  <strong>requestData</strong> - interaction plus complexe via un appel de fonction à l'intérieur de l'application testée. </li></ul><br><p>  Il peut y avoir une situation où vous devez influencer l'état global de l'application à partir du code de test.  Par exemple, pour simplifier le test d'intégration en remplaçant une partie des services au sein de l'application par moki.  Dans l'application, vous pouvez spécifier un gestionnaire de demande, auquel vous pouvez accéder via un appel à <strong>driver.requestData ('certains paramètres')</strong> dans le code de test: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Future&lt;String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dataHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String msg)</span></span></span><span class="hljs-function"> async </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg == <span class="hljs-string"><span class="hljs-string">"some param"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//       return 'some result'; } } enableFlutterDriverExtension(handler: dataHandler); app.main(); }</span></span></code> </pre> <br><h3 id="poisk-vidzhetov-1">  Recherche de widgets </h3><br><p>  La recherche de widgets pendant les tests d'intégration avec l'objet de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>recherche</strong></a> globale diffère dans la composition des méthodes des fonctionnalités similaires dans les tests de widgets.  Cependant, la signification générale ne change pratiquement pas: </p><br><ul><li>  dans l'arborescence par text - <strong>find.text</strong> , <strong>find.widgetWithText</strong> ; </li><li>  par clé - <strong>find.byValueKey</strong> ; </li><li>  par type - <strong>find.byType</strong> ; </li><li>  à l'invite - <strong>find.byTooltip</strong> ; </li><li>  par étiquette sémantique - <strong>find.bySemanticsLabel</strong> ; </li><li>  par position dans l'arbre <strong>find.descendant</strong> et <strong>find.ancestor</strong> . </li></ul><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Nous avons cherché des moyens d'organiser le test d'une interface d'application écrite à l'aide de Flutter.  Nous pouvons à la fois implémenter des tests pour vérifier que le code répond aux exigences des spécifications techniques et effectuer des tests avec cette tâche même.  Parmi les lacunes notées des tests d'intégration - il n'y a aucun moyen d'interagir avec les dialogues système de la plate-forme.  Mais, par exemple, les demandes d'autorisations peuvent être évitées en émettant des autorisations à partir de la ligne de commande au stade de l'installation de l'application, comme décrit dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce ticket</a> . </p><br><p>  Cet article est le point de départ pour explorer une rubrique de test qui présente brièvement au lecteur comment fonctionne le test de l'interface utilisateur.  Il ne sauvegarde pas la documentation de lecture, à partir de laquelle il est assez facile de découvrir comment fonctionne une classe ou une méthode particulière.  Après tout, l'étude d'un nouveau sujet pour vous-même nécessite, tout d'abord, une compréhension de tous les processus en cours dans leur ensemble, sans trop de détails. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr468631/">https://habr.com/ru/post/fr468631/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr468621/index.html">Nous traduisons le réseau domestique en DoH, ou un autre clic sur le nez de filtrage</a></li>
<li><a href="../fr468623/index.html">Je veux des avis sur Habr</a></li>
<li><a href="../fr468625/index.html">Sans serveur: 15% plus lent et huit fois plus cher</a></li>
<li><a href="../fr468627/index.html">Modules d'E / S ADAM-6200</a></li>
<li><a href="../fr468629/index.html">Comment j'ai créé un filtre qui ne corrompe pas l'image même après un million d'exécutions - partie 2</a></li>
<li><a href="../fr468635/index.html">Dichalcogénures de métaux de transition: débloquer les secrets de la croissance des cristaux WS2</a></li>
<li><a href="../fr468637/index.html">Comment gérer de grands ensembles de données dans les pandas. Nous travaillons avec la base de données FIAS en utilisant python et 8 Go de mémoire</a></li>
<li><a href="../fr468639/index.html">Nouveautés des consoles Web 2019</a></li>
<li><a href="../fr468641/index.html">Tutoriel pour créer une solution de chaîne de blocs sur Hyperledger Composer</a></li>
<li><a href="../fr468645/index.html">Deux pages ont suffi pour prouver l'hypothèse de 30 ans dans le domaine de l'informatique.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>