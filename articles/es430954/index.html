<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😊 🚴 🎯 Qt Everywhere: WebAssembly y WebGL Streaming 🗿 ✉️ 👽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt Everywhere: este es el nombre de los archivos con fuentes Qt. WebAssembly y WebGL streaming se entregarán en 5.12.0 y en todas partes suena diferen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qt Everywhere: WebAssembly y WebGL Streaming</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430954/"><p>  Qt Everywhere: este es el nombre de los archivos con fuentes Qt.  WebAssembly y WebGL streaming se entregarán en 5.12.0 y en todas partes suena diferente.  Entonces le pedí que hiciera un prototipo de algo.  Se implementó rápidamente un prototipo de chat en sockets web para probar el soporte de red.  Debajo del gato habrá instrucciones para ensamblar y lanzar un proyecto en WebAssembly, un ejemplo de llamar a JavaScript desde C ++. </p><a name="habracut"></a><br><h4 id="sborka-qt-s-webassembly">  Qt ensamblado con WebAssembly </h4><br><p> Primero debe colocar la cadena de herramientas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">emscripten</a> , que recopilaremos Qt.  Recuerde establecer variables de entorno para que qmake encuentre emcc.  El script de <code>configure</code> se ejecutó con los siguientes parámetros: </p><br><pre> <code class="plaintext hljs">./configure \ -prefix /home/dmitry/Qt/5.12.0/wasm \ -xplatform wasm-emscripten \ -confirm-license -opensource \ -nomake tests \ -c++std c++1z \ -nomake examples \ -release \ -no-dbus \ -skip qtxmlpatterns \ -skip qttools</code> </pre> <br><p>  Además como en otros lugares: </p><br><pre> <code class="plaintext hljs">$ make $ make install</code> </pre> <br><p>  Montaje y lanzamiento del proyecto. </p><br><pre> <code class="plaintext hljs">$ ~/Qt/5.12.0/wasm/bin/qmake $ make $ emrun chat.html</code> </pre> <br><h4 id="platformenno-zavisimyy-kod">  Código dependiente de plataforma </h4><br><p>  Coser la url en la que cuelga el backend no es muy bueno, porque  quiere correr en un puerto arbitrario.  En caso de trabajar desde el navegador, debe tomar <code>location.hostname</code> y <code>location.port</code> para determinar dónde se ejecuta el back-end.  Para hacer esto, tendrás que escribir un poco en JavaScript. </p><br><p>  Para los amantes de las definiciones, hay <code>Q_OS_WASM</code> , pero prefiero sacar el código en pimpl y archivos individuales.  Pimpl es superfluo aquí, pero distribuiré el código en diferentes archivos </p><br><p>  Consigamos algún tipo de configuración </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//config.h #pragma once #include &lt;QtCore/QUrl&gt; class Config { public: static QUrl wsUrl(); };</span></span></code> </pre> <br><p>  y dos implementaciones </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//config.cpp #include &lt;QtCore/QCoreApplication&gt; #include &lt;QtCore/QCommandLineParser&gt; #include "config.h" QUrl Config::wsUrl() { QCommandLineParser parser; QCommandLineOption wsOption(QStringList() &lt;&lt; "u" &lt;&lt; "url" , "WebSocket url" , "url" , "ws://localhost:1234"); parser.addOption(wsOption); parser.process(*QCoreApplication::instance()); return QUrl(parser.value(wsOption)); }</span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//config_wasm.cpp #include &lt;QtCore/QByteArray&gt; #include &lt;emscripten/emscripten.h&gt; #include &lt;emscripten/html5.h&gt; #include "config.h" QUrl Config::wsUrl() { QByteArray buff(1024, 0); EM_ASM_({ var url = "ws://"+ window.location.hostname + ":" + window.location.port + "/ws"; stringToUTF8(url, $0, $1); }, buff.data(), buff.size()); return QUrl(QString::fromUtf8(buff)); }</span></span></code> </pre> <br><p>  Queda por registrarse en el archivo pro </p><br><pre> <code class="plaintext hljs">wasm { SOURCES += config_wasm.cpp } else { SOURCES += config.cpp }</code> </pre> <br><p>  <code>EM_ASM_</code> es <code>EM_ASM_</code> magia <code>EM_ASM_</code> que le permite llamar a código JavaScript desde C ++.  Aunque podría hacerse sin JavaScript </p><br><pre> <code class="cpp hljs">emscripten::val location = emscripten::val::global(<span class="hljs-string"><span class="hljs-string">"location"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> host = QString::fromStdString(location[<span class="hljs-string"><span class="hljs-string">"host"</span></span>].as&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> protocol = QString::fromStdString(location[<span class="hljs-string"><span class="hljs-string">"protocol"</span></span>].as&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;());</code> </pre> <br><h4 id="podderzhka-v-brauzerah">  Soporte de navegador </h4><br><p>  Navegadores de escritorio: se inicia y funciona en Chrome, Firefox, Safari, Edge (aquí tuve que habilitar las funciones experimentales de JavaScript).  Dependiendo del hardware, puede haber retrasos significativos en la compilación de WebAssembly. </p><br><p>  En Chrome en Andorid, puede tomar minutos compilar WebAssembly.  Inmediatamente noté la falta de soporte para navegadores móviles, es decir, no hay llamadas al teclado del sistema cuando intento ingresar texto. </p><br><p>  Safari en iOS 12 aquí la aplicación se bloquea en la etapa de compilación de WebAssembly y no discutí.  Teóricamente, puede cambiar a asm.js, pero esto requiere un estudio por separado. </p><br><h4 id="qt-quick-webgl">  Qt Quick WebGL </h4><br><p>  El blog se posicionó como VNC en sockets web con renderizado en WebGL.  De las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dependencias</a> Qt WebSockets y Qt compiladas con soporte para OpenGL ES 2, es decir  Conducir en hardware sin una GPU será doloroso.  Para <code>-platform webgl</code> , solo ponga <em>Qt WebGL Streaming Plugin</em> en el instalador en línea y ejecute la aplicación con la <code>-platform webgl</code> o <code>-platform webgl:port=80</code> si necesita especificar un puerto. </p><br><p>  Pero esta tecnología tiene sus limitaciones: </p><br><ul><li>  retrasos o el notorio retraso de entrada; </li><li>  falta de soporte de aplicaciones en Qt Widgets; </li><li>  falta de transmisión de sonido; </li><li>  una conexión de usuario por proceso, es decir  en la segunda pestaña ya no entra, el precargador girará. </li></ul><br><p>  También noté que FPS se hundía al animar StackView en las transiciones entre pantallas.  Ventaja de la transmisión WebGL: </p><br><ul><li>  servidor incorporado; </li><li>  mínimo esfuerzo  No tuve que compilar Qt de las fuentes y reconstruir por separado la aplicación existente. </li></ul><br><h4 id="sposoby-primeneniya-webassembly-i-webgl-streaming">  Usos para WebAssembly y WebGL Streaming </h4><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Wt</a> alternativa cuando hay una aplicación lista para usar en C ++ y necesita sujetarle la interfaz web.  Por ejemplo, la interfaz web de la mecedora torrent. </p><br><p>  Interfaz web para algunos hogares inteligentes.  No en vano, MQTT se entregó a Qt, sino un ejemplo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mqtt_simpleclient</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">msorvig / qt-webassembly-examples</a> .  Puede tener un código de interfaz de usuario común que funcione en la tableta y en el navegador. </p><br><p>  El código está disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GitHub</a> , binarios preparados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el mismo lugar.</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430954/">https://habr.com/ru/post/es430954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430942/index.html">Julia Scripts y análisis de argumentos de línea de comando</a></li>
<li><a href="../es430944/index.html">La NASA ha decidido a los participantes para su competencia de mini-rover de luna</a></li>
<li><a href="../es430948/index.html">El Ministerio de Comunicaciones propone reforzar el control sobre los datos personales.</a></li>
<li><a href="../es430950/index.html">Making Modern Build</a></li>
<li><a href="../es430952/index.html">Los autos eléctricos y los híbridos deberán emitir sonidos adicionales: ¿por qué es necesario?</a></li>
<li><a href="../es430956/index.html">Enseñamos a un cerdo con monoides a creer en sí mismos y volar</a></li>
<li><a href="../es430958/index.html">Lanzamos el contenedor con pruebas unitarias en Azure DevOps (VSTS)</a></li>
<li><a href="../es430960/index.html">Sobre gamedev de una exposición de escritorio</a></li>
<li><a href="../es430962/index.html">Razor Support en Visual Studio Code</a></li>
<li><a href="../es430964/index.html">Pensamiento declarativo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>