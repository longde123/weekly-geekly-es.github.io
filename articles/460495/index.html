<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéº üîÜ üíÉüèø Contenedor a canalizaci√≥n: CRI-O ahora es el valor predeterminado en OpenShift Container Platform 4 üì¨ üàÅ üë®üèø‚Äç‚öïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La plataforma Red Hat OpenShift Container Platform 4 le permite transmitir la creaci√≥n de hosts para el despliegue de contenedores , incluso en la inf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Contenedor a canalizaci√≥n: CRI-O ahora es el valor predeterminado en OpenShift Container Platform 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/460495/"> La <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">plataforma Red Hat OpenShift Container Platform 4 le</a> permite transmitir la creaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hosts para el despliegue de contenedores</a> , incluso en la infraestructura de proveedores de servicios en la nube, en plataformas de virtualizaci√≥n o en sistemas de metal desnudo.  Para crear una plataforma en la nube en el sentido completo, tuvimos que tomar un control estricto de todos los elementos utilizados y as√≠ aumentar la confiabilidad de un proceso de automatizaci√≥n complejo. <br><br><img src="https://habrastorage.org/webt/h5/hn/x9/h5hnx9ulnrjawbfhd2dncjqmxvm.png" width="100%"><br><br>  La soluci√≥n obvia era usar Red Hat Enterprise Linux CoreOS (una variaci√≥n de Red Hat Enterprise Linux) y CRI-O como est√°ndar, y he aqu√≠ por qu√© ... <br><a name="habracut"></a><br>  Dado que el tema de la navegaci√≥n es muy exitoso para encontrar analog√≠as al explicar el funcionamiento de Kubernetes y contenedores, tratemos de hablar sobre los problemas comerciales que CoreOS y CRI-O resuelven, utilizando el ejemplo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la invenci√≥n</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Brunel para la producci√≥n de bloques de aparejo</a> .  En 1803, Mark Brunel tuvo la tarea de fabricar 100,000 bloques de aparejos para las necesidades de la creciente armada brit√°nica.  Un bloque de elevaci√≥n es un tipo de plataforma que se usa para unir cuerdas a velas.  Hasta principios del siglo XIX, estos bloques se fabricaban a mano, pero Brunel pudo automatizar la producci√≥n y comenz√≥ a producir bloques estandarizados utilizando m√°quinas.  La automatizaci√≥n de este proceso significaba que, como resultado, todos los bloques eran casi iguales, pod√≠an reemplazarse f√°cilmente en caso de aver√≠a y pod√≠an hacerse en grandes cantidades. <br><br>  Ahora imagine que Brunel tendr√≠a que hacer este trabajo para 20 modelos de barcos diferentes (versiones de Kubernetes) y para cinco planetas diferentes con corrientes marinas y vientos completamente diferentes (proveedores de nubes).  Adem√°s, se requer√≠a que todos los barcos (conglomerados OpenShift), independientemente de los planetas que se navegaran, desde el punto de vista de los capitanes (operadores que controlan la operaci√≥n de los conglomerados) se comporten de manera id√©ntica.  Continuando con la analog√≠a marina, a los capitanes de barco no les importa en absoluto qu√© bloques de aparejo (CRI-O) se utilizan en sus barcos; lo principal para ellos es que estos bloques son fuertes y confiables. <br><br>  OpenShift 4, como plataforma en la nube, enfrenta un desaf√≠o comercial muy similar.  Se deben crear nuevos nodos en el momento de la creaci√≥n del cl√∫ster, en caso de falla en uno de los nodos o al escalar el cl√∫ster.  Al crear e inicializar un nuevo nodo, los componentes cr√≠ticos del host, incluido CRI-O, deben configurarse en consecuencia.  Como en cualquier otra producci√≥n, las "materias primas" deben suministrarse al principio.  En el caso de los barcos, el metal y la madera act√∫an como materia prima.  Sin embargo, si crea un host para implementar contenedores en un cl√∫ster de OpenShift 4, debe tener archivos de configuraci√≥n y servidores API proporcionados en la entrada.  Despu√©s de eso, OpenShift proporcionar√° el nivel necesario de automatizaci√≥n durante todo el ciclo de vida, ofreciendo el soporte de producto necesario para los usuarios finales y, por lo tanto, amortizando las inversiones en la plataforma. <br><br>  OpenShift 4 se cre√≥ de tal manera que proporciona la capacidad de actualizar convenientemente el sistema durante todo el ciclo de vida de la plataforma (para las versiones 4.X) para todos los principales proveedores de computaci√≥n en la nube, plataformas de virtualizaci√≥n e incluso sistemas de metal desnudo.  Para esto, los nodos deben crearse sobre la base de elementos intercambiables.  Cuando un cl√∫ster requiere una nueva versi√≥n de Kubernetes, tambi√©n recibe la versi√≥n CRI-O correspondiente en CoreOS.  Dado que la versi√≥n CRI-O est√° vinculada directamente a Kubernetes, todo esto simplifica enormemente cualquier permutaciones para pruebas, resoluci√≥n de problemas o soporte.  Adem√°s, este enfoque reduce los costos para los usuarios finales y Red Hat. <br><br>  Este es un aspecto fundamentalmente nuevo en los cl√∫steres de Kubernetes, que sienta las bases para planificar nuevas funciones muy √∫tiles y atractivas.  CRI-O (interfaz de tiempo de ejecuci√≥n de contenedor de proyecto de contenedor abierto - Open Container Initiative, abreviado CRI-OCI) fue la opci√≥n m√°s exitosa para la creaci√≥n masiva de nodos, que es necesaria para trabajar con OpenShift.  CRI-O reemplazar√° el motor Docker utilizado anteriormente, ofreciendo a los usuarios de OpenShift un motor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">econ√≥mico, estable, simple y aburrido</a> , s√≠, lo entendieron bien, un contenedor aburrido dise√±ado espec√≠ficamente para trabajar con Kubernetes. <br><br><h3>  El mundo de los contenedores abiertos. </h3><br>  El mundo lleva mucho tiempo avanzando hacia contenedores abiertos.  Ya sea en Kubernetes, o en niveles inferiores, el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">desarrollo de est√°ndares de contenedores</a> conduce a un ecosistema de innovaci√≥n en todos los niveles. <br><br>  Todo comenz√≥ con la creaci√≥n de la Iniciativa de Contenedores Abiertos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en junio de 2015</a> .  En esta etapa temprana del trabajo, se formaron especificaciones para la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">imagen</a> del contenedor <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">(imagen)</a> y el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tiempo de ejecuci√≥n</a> .  Esto permiti√≥ garantizar que las herramientas puedan utilizar un √∫nico est√°ndar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">im√°genes</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedor</a> y un √∫nico formato para trabajar con ellas.  Posteriormente se agregaron especificaciones de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">distribuci√≥n</a> , lo que permiti√≥ a los usuarios intercambiar f√°cilmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">im√°genes de contenedores</a> . <br><br>  La comunidad de Kubernetes luego desarroll√≥ un √∫nico est√°ndar de interfaz enchufable llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Container Runtime Interface (CRI)</a> .  Gracias a esto, los usuarios de Kubernetes pudieron conectar varios motores para trabajar con contenedores adem√°s de Docker. <br><br>  Los ingenieros de Red Hat y Google vieron una demanda en el mercado de un motor de contenedor que pudiera aceptar solicitudes de Kubelet usando el protocolo CRI e introdujo contenedores que eran compatibles con las especificaciones de OCI mencionadas anteriormente.  Entonces <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hab√≠a un OCID</a> .  Pero disc√∫lpeme, porque dijimos que este material se dedicar√° a CRI-O.  De hecho, es solo con el lanzamiento de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">versi√≥n 1.0, el</a> proyecto pas√≥ a llamarse CRI-O. <br><br>  <b><i>Fig.</i></b>  <b><i>1)</i></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/7-/-n/qb/7--nqbszwtnoy38f-tnbuzdmucm.png"></div><br><br><h3>  Innovaci√≥n con CRI-O y CoreOS </h3><br>  Con el lanzamiento de la plataforma OpenShift 4, se cambi√≥ el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">motor</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">contenedor</a> utilizado en la plataforma predeterminada, y Docker fue reemplazado por CRI-O, que ofrec√≠a un entorno de lanzamiento de contenedor econ√≥mico, estable, simple y aburrido, que se desarrolla en paralelo con Kubernetes.  Esto simplifica enormemente el soporte y la configuraci√≥n del cl√∫ster.  La configuraci√≥n del motor de contenedor y el host, as√≠ como su administraci√≥n, se automatiza en OpenShift 4. <br><br>  Para, como es? <br><br>  As√≠ es, con el advenimiento de OpenShift 4, ahora ya no es necesario conectarse a hosts individuales e instalar un motor contenedor, configurar el almacenamiento, configurar servidores para b√∫squeda o configurar una red.  La plataforma OpenShift 4 ha sido completamente redise√±ada para usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Marco</a> del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">operador</a> no solo en t√©rminos de aplicaciones de usuario final, sino tambi√©n en t√©rminos de operaciones b√°sicas a nivel de plataforma, como desplegar im√°genes, configurar el sistema o instalar actualizaciones. <br><br>  Kubernetes siempre ha permitido que los usuarios administren aplicaciones determinando el estado deseado y usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Controladores</a> para garantizar que el estado real sea lo m√°s cercano posible al estado dado.  Este <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enfoque que utiliza un estado dado y un estado real</a> abre grandes oportunidades tanto desde el punto de vista del desarrollo como desde el punto de vista de las operaciones.  Los desarrolladores pueden determinar el estado requerido, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transferirlo al</a> operador en forma de un archivo YAML o JSON, y luego el operador puede crear la instancia de aplicaci√≥n necesaria en el entorno operativo, mientras que el estado operativo de esta instancia corresponder√° completamente al especificado. <br><br>  Usando Operadores en la plataforma, OpenShift 4 trae este nuevo paradigma (usando el concepto de conjunto y estado actual) a la gesti√≥n de RHEL CoreOS y CRI-O.  Las tareas de configurar y versionar el sistema operativo y el motor del contenedor se automatizan utilizando el llamado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Operador de configuraci√≥n de la m√°quina (MCO)</a> .  MCO simplifica enormemente el trabajo del administrador del cl√∫ster, esencialmente automatizando las √∫ltimas etapas de instalaci√≥n, as√≠ como las operaciones posteriores despu√©s de la instalaci√≥n (operaciones del d√≠a dos).  Todo esto hace de OpenShift 4 una verdadera plataforma en la nube.  Nos detendremos en esto un poco m√°s tarde. <br><br><h3>  Lanzamiento de contenedores </h3><br>  Los usuarios tuvieron la oportunidad de utilizar el motor CRI-O en la plataforma OpenShift a partir de la versi√≥n 3.7 en el estado de Tech Preview y de la versi√≥n 3.9 en el estado de Disponible en general (actualmente compatible).  Adem√°s, Red Hat hace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un</a> uso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">extenso</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CRI-O para lanzar cargas</a> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">trabajo de producci√≥n</a> en OpenShift Online desde la versi√≥n 3.10.  Todo esto permiti√≥ que el equipo que trabajaba en CRI-O obtuviera una vasta experiencia en el lanzamiento masivo de contenedores en grandes grupos de Kubernetes.  Para obtener una comprensi√≥n b√°sica de c√≥mo Kubernetes usa CRI-O, echemos un vistazo a la siguiente ilustraci√≥n, que muestra c√≥mo funciona la arquitectura. <br><br>  <b><i>Fig.</i></b>  <b><i>2. C√≥mo funcionan los contenedores en el cl√∫ster de Kubernetes</i></b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/zr/kz/1azrkzz-ey6euphpkgqpazncwci.png"></div><br><br>  CRI-O simplifica la creaci√≥n de nuevos hosts de contenedores al sincronizar todo el nivel superior al inicializar nuevos nodos y al lanzar nuevas versiones de la plataforma OpenShift.  Una auditor√≠a completa de la plataforma permite actualizaciones / reversiones de transacciones, y tambi√©n evita puntos muertos en las dependencias entre el kernel de la cola del contenedor, el motor del contenedor, Kubelets y Kubernetes Master.  Con la administraci√≥n centralizada de todos los componentes de la plataforma, con el control y la administraci√≥n de versiones, siempre puede realizar un seguimiento de una ruta clara del estado A al estado B. Esto simplifica el proceso de actualizaci√≥n, mejora la seguridad, mejora los informes de rendimiento y ayuda a reducir el costo de actualizar e instalar nuevas versiones. <br><br><h3>  Demostraci√≥n del poder de los elementos intercambiables. </h3><br>  Como se mencion√≥ anteriormente, el uso de Machine Config Operator para administrar el host del contenedor y el motor del contenedor en OpenShift 4 proporciona un nuevo nivel de automatizaci√≥n que antes no era posible en la plataforma Kubernetes.  Para demostrar las nuevas funciones, mostramos c√≥mo puede realizar cambios en el archivo crio.conf.  Para no confundirse con la terminolog√≠a, intente concentrarse en los resultados. <br><br>  Primero, creemos lo que se llama una configuraci√≥n de tiempo de ejecuci√≥n de contenedor: la configuraci√≥n de tiempo de ejecuci√≥n de contenedor.  Considere esto un recurso de Kubernetes que representa la configuraci√≥n para CRI-O.  En realidad, esta es una versi√≥n especializada de lo que se llama MachineConfig, que es cualquier configuraci√≥n implementada en una m√°quina RHEL CoreOS dentro de un cl√∫ster OpenShift. <br><br>  Este recurso personalizado, llamado ContainerRuntimeConfig, se invent√≥ para facilitar a los administradores del cl√∫ster configurar CRI-O.  Esta es una herramienta lo suficientemente poderosa que solo se puede aplicar a ciertos nodos dependiendo de la configuraci√≥n de MachineConfigPool.  Considere esto un grupo de m√°quinas que tienen el mismo prop√≥sito. <br><br>  Presta atenci√≥n a las dos √∫ltimas l√≠neas que vamos a cambiar en el archivo /etc/crio/crio.conf.  Estas dos l√≠neas son muy similares a las l√≠neas en el archivo crio.conf, estas son: <br><br><pre><code class="plaintext hljs">vi ContainerRuntimeConfig.yaml</code> </pre> <br>  Conclusi√≥n <br><br><pre> <code class="plaintext hljs">apiVersion: machineconfiguration.openshift.io/v1 kind: ContainerRuntimeConfig metadata: name: set-log-and-pid spec: machineConfigPoolSelector: matchLabels: debug-crio: config-log-and-pid containerRuntimeConfig: pidsLimit: 2048 logLevel: debug</code> </pre><br>  Ahora env√≠e este archivo al cl√∫ster de Kubernetes y verifique que realmente se haya creado.  Tenga en cuenta que la operaci√≥n se lleva a cabo de la misma manera que con cualquier otro recurso de Kubernetes: <br><br><pre> <code class="plaintext hljs">oc create -f ContainerRuntimeConfig.yaml oc get ContainerRuntimeConfig</code> </pre><br>  Conclusi√≥n <br><br><pre> <code class="plaintext hljs">NAME AGE set-log-and-pid 22h</code> </pre><br>  Despu√©s de crear ContainerRuntimeConfig, debemos modificar uno de los MachineConfigPools para que Kubernetes comprenda que queremos aplicar esta configuraci√≥n a un grupo espec√≠fico de m√°quinas en el cl√∫ster.  En este caso, cambiaremos MachineConfigPool para los nodos maestros: <br><br><pre> <code class="plaintext hljs">oc edit MachineConfigPool/master</code> </pre><br>  Conclusi√≥n (para mayor claridad, queda el punto principal): <br><br><pre> <code class="plaintext hljs">... metadata: creationTimestamp: 2019-04-10T23:42:28Z generation: 1 labels: debug-crio: config-log-and-pid operator.machineconfiguration.openshift.io/required-for-upgrade: "" ...</code> </pre><br>  En este punto, MCO comienza a crear un nuevo archivo crio.conf para el cl√∫ster.  En este caso, se puede ver un archivo de configuraci√≥n completamente terminado usando la API de Kubernetes.  Recuerde, ContainerRuntimeConfig es solo una versi√≥n especializada de MachineConfig, por lo que podemos ver el resultado mirando las l√≠neas en MachineConfigs: <br><br><pre> <code class="plaintext hljs">oc get MachineConfigs | grep rendered</code> </pre><br>  Conclusi√≥n <br><br><pre> <code class="plaintext hljs">rendered-master-c923f24f01a0e38c77a05acfd631910b 4.0.22-201904011459-dirty 2.2.0 16h rendered-master-f722b027a98ac5b8e0b41d71e992f626 4.0.22-201904011459-dirty 2.2.0 4m rendered-worker-9777325797fe7e74c3f2dd11d359bc62 4.0.22-201904011459-dirty 2.2.0 16h</code> </pre><br>  Tenga en cuenta que el archivo de configuraci√≥n resultante para los nodos maestros result√≥ ser una versi√≥n m√°s nueva que las configuraciones originales.  Para verlo, ejecute el siguiente comando.  De paso, notamos que este es probablemente uno de los mejores scripts de una sola l√≠nea en la historia de Kubernetes: <br><br><pre> <code class="plaintext hljs">python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.argv[1]))" $(oc get MachineConfig/rendered-master-f722b027a98ac5b8e0b41d71e992f626 -o YAML | grep -B4 crio.conf | grep source | tail -n 1 | cut -d, -f2) | grep pid</code> </pre><br>  Conclusi√≥n <br><br><pre> <code class="plaintext hljs">pids_limit = 2048</code> </pre><br>  Ahora aseg√∫rese de que la configuraci√≥n se haya aplicado a todos los nodos maestros.  Primero obtenemos una lista de nodos en el cl√∫ster: <br><br><pre> <code class="plaintext hljs">oc get node | grep master Output: ip-10-0-135-153.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1 ip-10-0-154-0.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1 ip-10-0-166-79.us-east-2.compute.internal Ready master 23h v1.12.4+509916ce1</code> </pre><br>  Ahora mira el archivo instalado.  Ver√° que el archivo se ha actualizado con las nuevas directivas pid y debug que especificamos en el recurso ContainerRuntimeConfig.  Elegancia misma: <br><br><pre> <code class="plaintext hljs">oc debug node/ip-10-0-135-153.us-east-2.compute.internal ‚Äî cat /host/etc/crio/crio.conf | egrep 'debug||pid'</code> </pre><br>  Conclusi√≥n <br><br><pre> <code class="plaintext hljs">... pids_limit = 2048 ... log_level = "debug" ...</code> </pre><br>  Todos estos cambios en el cl√∫ster se realizaron incluso sin iniciar SSH.  Todo el trabajo se realiz√≥ contactando el nodo maestro de Kuberentes.  Es decir, estos nuevos par√°metros se configuraron solo en los nodos maestros.  Al mismo tiempo, los nodos de trabajo no cambiaron, lo que demuestra las ventajas de la metodolog√≠a de Kubernetes usando el conjunto y los estados actuales aplicados a los hosts de contenedores y motores de contenedores con elementos intercambiables. <br><br>  El ejemplo anterior muestra la capacidad de realizar cambios en un peque√±o cl√∫ster OpenShift Container Platform 4 con tres nodos de trabajo o en un gran cl√∫ster de producci√≥n con 3000 nodos.  En cualquier caso, la cantidad de trabajo ser√° la misma, y ‚Äã‚Äãmuy peque√±a, solo configure el archivo ContainerRuntimeConfig y cambie una etiqueta en MachineConfigPool.  Y puede hacerlo con cualquier versi√≥n de la plataforma OpenShift Container Platform 4.X utilizada por Kubernetes a lo largo de su ciclo de vida. <br><br>  A menudo, las compa√±√≠as de tecnolog√≠a se est√°n desarrollando tan r√°pido que no podemos explicar por qu√© elegimos ciertas tecnolog√≠as para los componentes b√°sicos.  Los motores de contenedores han sido hist√≥ricamente el componente con el que los usuarios interact√∫an directamente.  Como la popularidad de los contenedores comenz√≥ naturalmente con la llegada de los motores de contenedores, los usuarios a menudo muestran inter√©s en ellos.  Esta es otra raz√≥n por la cual Red Hat opt√≥ por CRI-O.  Los contenedores est√°n evolucionando, con el enfoque en la orquestaci√≥n de hoy, y hemos llegado a la conclusi√≥n de que CRI-O proporciona la mejor experiencia al trabajar con OpenShift 4. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/460495/">https://habr.com/ru/post/460495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460483/index.html">5 m√©todos para ejecutar una lluvia de ideas efectiva</a></li>
<li><a href="../460485/index.html">C√≥mo un torneo en l√≠nea puede desalentar el "terminar la pr√≥xima semana"</a></li>
<li><a href="../460489/index.html">TOP 11 errores en el desarrollo de BCP</a></li>
<li><a href="../460491/index.html">Sensor de temperatura y humedad Arduino con env√≠o y trazado (Parte 1)</a></li>
<li><a href="../460493/index.html">"Aplicaciones asesinas" para PC de los a√±os 80: VisiCalc y WordStar</a></li>
<li><a href="../460497/index.html">Uso intuitivo de los m√©todos de Monte Carlo con cadenas de Markov.</a></li>
<li><a href="../460499/index.html">Tres ganadores del Premio Dijkstra: ¬øc√≥mo fueron Hydra 2019 y SPTDC 2019?</a></li>
<li><a href="../460501/index.html">Ejemplo de implementaci√≥n de integraci√≥n continua con BuildBot</a></li>
<li><a href="../460503/index.html">Configuraci√≥n inal√°mbrica de Raspberry PI 3 B +</a></li>
<li><a href="../460505/index.html">Atrae tres cruces, o por qu√© los proyectos son tan dif√≠ciles de terminar a tiempo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>