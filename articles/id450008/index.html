<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõµ üòû üë∂üèΩ Temukan bug di LLVM 8 menggunakan penganalisa PVS-Studio üë∑üèª üë©üèø‚Äçüöí üßí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lebih dari dua tahun telah berlalu sejak verifikasi terakhir dari kode proyek LLVM menggunakan penganalisa PVS-Studio kami. Mari kita pastikan bahwa p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Temukan bug di LLVM 8 menggunakan penganalisa PVS-Studio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/450008/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f2/8d4/5bf/2f28d45bf369270d9330bfbe2ea78f00.png" alt="PVS-Studio dan LLVM 8.0.0"></div><br>  Lebih dari dua tahun telah berlalu sejak verifikasi terakhir dari kode proyek LLVM menggunakan penganalisa PVS-Studio kami.  Mari kita pastikan bahwa penganalisa PVS-Studio masih merupakan alat terkemuka untuk mendeteksi kesalahan dan kerentanan potensial.  Untuk melakukan ini, periksa dan temukan kesalahan baru dalam rilis LLVM 8.0.0. <br><a name="habracut"></a><br><h2>  Artikel yang akan ditulis </h2><br>  Sejujurnya, saya tidak ingin menulis artikel ini.  Tidak menarik untuk menulis tentang proyek yang telah kami uji berulang kali ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a> ).  Lebih baik menulis tentang sesuatu yang baru, tetapi saya tidak punya pilihan. <br><br>  Setiap kali versi baru LLVM dirilis atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Clang Static Analyzer</a> diperbarui, pertanyaan-pertanyaan berikut muncul di surat kami: <br><br>  <i>Lihat, versi baru Clang Static Analyzer telah belajar menemukan bug baru!</i>  <i>Menurut saya relevansi penggunaan PVS-Studio menurun.</i>  <i>Dentang menemukan lebih banyak kesalahan dari sebelumnya dan mengejar kemampuan PVS-Studio.</i>  <i>Apa yang Anda pikirkan tentang ini?</i> <br><br>  Untuk ini, saya selalu ingin menjawab sesuatu dalam roh: <br><br>  <b>Kami juga tidak duduk diam!</b>  Kami telah secara signifikan meningkatkan kemampuan penganalisa PVS-Studio.  Jadi jangan khawatir, kami terus memimpin, seperti sebelumnya. <br><br>  Sayangnya, ini jawaban yang buruk.  Tidak ada bukti di dalamnya.  Dan itulah sebabnya saya menulis artikel ini sekarang.  Jadi, proyek LLVM sekali lagi telah diuji dan berbagai kesalahan telah ditemukan di dalamnya.  Yang tampaknya menarik bagi saya, sekarang saya akan tunjukkan.  Kesalahan ini tidak dapat ditemukan oleh Clang Static Analyzer (atau sangat tidak nyaman untuk melakukannya).  Dan kita bisa.  Dan saya menemukan dan menulis semua kesalahan ini dalam satu malam. <br><br>  Tetapi penulisan artikel itu berlangsung selama beberapa minggu.  Saya tidak bisa memaksakan diri untuk mengatur semua ini dalam bentuk teks :). <br><br>  Ngomong-ngomong, jika Anda tertarik pada teknologi apa yang digunakan dalam alat analisa PVS-Studio untuk mendeteksi kesalahan dan kerentanan potensial, maka saya sarankan agar Anda membiasakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diri</a> dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">catatan</a> ini. <br><br><h2>  Diagnostik baru dan lama </h2><br>  Seperti yang sudah dicatat, sekitar dua tahun lalu, proyek LLVM sekali lagi diverifikasi, dan kesalahan yang ditemukan diperbaiki.  Sekarang di artikel ini sebagian kesalahan baru akan disajikan.  Mengapa bug baru ditemukan?  Ada 3 alasan untuk ini: <br><br><ol><li>  Proyek LLVM berkembang, kode lama berubah di dalamnya, dan yang baru muncul.  Secara alami, ada kesalahan baru dalam kode yang dimodifikasi dan ditulis.  Ini menunjukkan dengan baik bahwa analisis statis harus diterapkan secara teratur, dan bukan dari kasus ke kasus.  Artikel kami menunjukkan kemampuan alat analisa PVS-Studio dengan baik, tetapi ini tidak ada hubungannya dengan meningkatkan kualitas kode dan mengurangi biaya memperbaiki kesalahan.  Gunakan penganalisa kode statis secara teratur! </li><li>  Kami sedang menyelesaikan dan meningkatkan diagnostik yang ada.  Oleh karena itu, penganalisa dapat mendeteksi kesalahan yang tidak diperhatikan selama pemeriksaan sebelumnya. </li><li>  PVS-Studio memperkenalkan diagnostik baru, yang tidak 2 tahun yang lalu.  Saya memutuskan untuk memisahkan mereka menjadi bagian yang terpisah untuk menunjukkan dengan jelas perkembangan PVS-Studio. </li></ol><br><h2>  Cacat diidentifikasi oleh diagnostik yang ada 2 tahun yang lalu </h2><br>  <b>Fragmen N1: Salin-Tempel</b> <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldUpgradeX86Intrinsic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Function *F, StringRef Name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Name == <span class="hljs-string"><span class="hljs-string">"addcarryx.u32"</span></span> || <span class="hljs-comment"><span class="hljs-comment">// Added in 8.0 .... Name == "avx512.mask.cvtps2pd.128" || // Added in 7.0 Name == "avx512.mask.cvtps2pd.256" || // Added in 7.0 Name == "avx512.cvtusi2sd" || // Added in 7.0 Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name.startswith("avx512.mask.permvar.") || // Added in 7.0 // &lt;= Name == "sse2.pmulu.dq" || // Added in 7.0 Name == "sse41.pmuldq" || // Added in 7.0 Name == "avx2.pmulu.dq" || // Added in 7.0 .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V501</a> [CWE-570] Ada sub-ekspresi identik 'Name.startswith ("avx512.mask.permvar.")' Di sebelah kiri dan di sebelah kanan '||'  operator.  AutoUpgrade.cpp 73 <br><br>  Diperiksa ulang bahwa namanya dimulai dengan substring ‚Äúavx512.mask.permvar.‚Äù.  Pada tes kedua, mereka jelas ingin menulis sesuatu yang lain, tetapi lupa untuk memperbaiki teks yang disalin. <br><br>  <b>Fragmen N2: Typo</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CXNameRefFlags { CXNameRange_WantQualifier = <span class="hljs-number"><span class="hljs-number">0x1</span></span>, CXNameRange_WantTemplateArgs = <span class="hljs-number"><span class="hljs-number">0x2</span></span>, CXNameRange_WantSinglePiece = <span class="hljs-number"><span class="hljs-number">0x4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AnnotateTokensWorker::HandlePostPonedChildCursor( CXCursor Cursor, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> StartTokenIndex) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> flags = CXNameRange_WantQualifier | CXNameRange_WantQualifier; .... }</code> </pre> <br>  Peringatan PVS-Studio: V501 Ada sub-ekspresi identik 'CXNameRange_WantQualifier' di kiri dan di kanan '|'  operator.  CIndex.cpp 7245 <br><br>  Karena kesalahan ketik, <i>CXNameRange_WantQualifier</i> konstanta yang <i>sama digunakan dua kali</i> . <br><br>  <b>Cuplikan N3: Kebingungan tentang Prioritas Operator</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PPCTTIImpl::getVectorInstrCost(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Opcode, Type *Val, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Index) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V502</a> [CWE-783] Mungkin Operator '?:' Bekerja dengan cara yang berbeda dari yang diharapkan.  Operator '?:' Memiliki prioritas lebih rendah daripada operator '=='.  PPCTargetTransformInfo.cpp 404 <br><br>  Menurut pendapat saya, ini adalah kesalahan yang sangat indah.  Ya, saya tahu saya punya ide aneh tentang kecantikan :). <br><br>  Sekarang, sesuai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prioritas operator</a> , ekspresi dihitung sebagai berikut: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; (Index == ST-&gt;isLittleEndian())) ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  Dari sudut pandang praktis, kondisi seperti itu tidak masuk akal, karena dapat direduksi menjadi: <br><br><pre> <code class="cpp hljs">(ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == ST-&gt;isLittleEndian())</code> </pre> <br>  Ini adalah kesalahan yang jelas.  Kemungkinan besar, 0/1 ingin membandingkan dengan variabel <i>Indeks</i> .  Untuk memperbaiki kode, tambahkan tanda kurung di sekitar operator ternary: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ISD == ISD::EXTRACT_VECTOR_ELT &amp;&amp; Index == (ST-&gt;isLittleEndian() ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>))</code> </pre> <br>  Omong-omong, operator ternary sangat berbahaya dan memicu kesalahan logis.  Berhati-hatilah dengan itu dan jangan serakah untuk menempatkan tanda kurung.  Saya membahas topik ini secara lebih rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini,</a> di bab ‚ÄúTakut pada operator?: Dan lampirkan dalam tanda kurung‚Äù. <br><br>  <b>Fragmen N4, N5: Null pointer</b> <br><br><pre> <code class="cpp hljs">Init *TGParser::ParseValue(Record *CurRec, RecTy *ItemType, IDParseMode Mode) { .... TypedInit *LHS = dyn_cast&lt;TypedInit&gt;(Result); .... LHS = dyn_cast&lt;TypedInit&gt;( UnOpInit::get(UnOpInit::CAST, LHS, StringRecTy::get()) -&gt;Fold(CurRec)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!LHS) { Error(PasteLoc, Twine(<span class="hljs-string"><span class="hljs-string">"can't cast '"</span></span>) + LHS-&gt;getAsString() + <span class="hljs-string"><span class="hljs-string">"' to string"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; } .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V522</a> [CWE-476] Dereferencing dari null pointer 'LHS' mungkin terjadi.  TGParser.cpp 2152 <br><br>  Jika pointer <i>LHS</i> adalah nol, peringatan harus dikeluarkan.  Namun, alih-alih ini akan <i>mengubah</i> pointer nol ini: <i>LHS-&gt; getAsString ()</i> . <br><br>  Ini adalah situasi yang sangat khas ketika kesalahan disembunyikan di penangan kesalahan, karena tidak ada yang menguji mereka.  Analisis statis memeriksa semua kode yang dapat dijangkau, tidak peduli seberapa sering digunakan.  Ini adalah contoh yang sangat baik tentang bagaimana analisis statis melengkapi teknik pengujian dan perlindungan kesalahan lainnya. <br><br>  Kesalahan serupa yang memproses pointer <i>RHS</i> dibuat dalam kode di bawah ini: V522 [CWE-476] Dereferencing dari null pointer 'RHS' mungkin terjadi.  TGParser.cpp 2186 <br><br>  <b>Fragmen N6: Menggunakan kursor setelah bergerak</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; ExtractBlocks(....) { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; ProgClone = CloneModule(BD.getProgram(), VMap); .... BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= MiscompiledFunctions.clear(); for (unsigned i = 0, e = MisCompFunctions.size(); i != e; ++i) { Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first); // &lt;= assert(NewF &amp;&amp; "Function not found??"); MiscompiledFunctions.push_back(NewF); } .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V522 [CWE-476] Dereferencing dari penunjuk nol 'ProgClone' mungkin terjadi.  Miscompilation.cpp 601 <br><br>  Pada awalnya, penunjuk pintar <i>ProgClone</i> berhenti memiliki objek: <br><br><pre> <code class="cpp hljs">BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ProgClone));</code> </pre> <br>  Bahkan, sekarang <i>ProgClone</i> adalah pointer nol.  Oleh karena itu, dereferencing dari null pointer harus terjadi tepat di bawah: <br><br><pre> <code class="cpp hljs">Function *NewF = ProgClone-&gt;getFunction(MisCompFunctions[i].first);</code> </pre> <br>  Tetapi, pada kenyataannya, ini tidak akan terjadi!  Perhatikan bahwa loop tidak benar-benar berjalan. <br><br>  Pada awalnya, wadah <i>MiscompiledFunctions</i> dihapus: <br><br><pre> <code class="cpp hljs">MiscompiledFunctions.clear();</code> </pre> <br>  Selanjutnya, ukuran wadah ini digunakan dalam kondisi loop: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, e = MisCompFunctions.size(); i != e; ++i) {</code> </pre> <br>  Sangat mudah untuk melihat bahwa loop tidak dimulai.  Saya pikir ini juga kesalahan, dan kode harus ditulis berbeda. <br><br>  Sepertinya kita bertemu dengan kesalahan yang sangat terkenal itu!  Satu kesalahan menyamarkan yang lain :). <br><br>  <b>Fragmen N7: Menggunakan kursor setelah bergerak</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; TestOptimizer(BugDriver &amp;BD, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Test, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Safe) { outs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Optimizing functions being tested: "</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;Module&gt; Optimized = BD.runPassesOn(Test.get(), BD.getPassesToRun()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Optimized) { errs() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error running this sequence of passes"</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">" on the input program!\n"</span></span>; BD.setNewProgram(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Test)); <span class="hljs-comment"><span class="hljs-comment">// &lt;= BD.EmitProgressBitcode(*Test, "pass-error", false); // &lt;= if (Error E = BD.debugOptimizerCrash()) return std::move(E); return false; } .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V522 [CWE-476] Dereferencing dari null pointer 'Test' mungkin terjadi.  Miscompilation.cpp 709 <br><br>  Lagi-lagi situasi yang sama.  Pada awalnya, isi objek dipindahkan, dan kemudian digunakan seolah-olah tidak ada yang terjadi.  Saya semakin melihat situasi ini dalam kode program, setelah semantik gerakan muncul di C ++.  Untuk ini saya suka bahasa C ++!  Ada banyak cara baru untuk menembak kaki Anda sendiri.  Alat analisa PVS-Studio akan selalu bekerja :). <br><br>  <b>Fragmen N8: Null Pointer</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> FunctionDumper::dump(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PDBSymbolTypeFunctionArg &amp;Symbol) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> TypeId = Symbol.getTypeId(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Type = Symbol.getSession().getSymbolById(TypeId); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br>  PVS-Studio Warning: V522 [CWE-476] Dereferencing dari null pointer 'Type' mungkin terjadi.  PrettyFunctionDumper.cpp 233 <br><br>  Selain penangan kesalahan, fungsi untuk debugging cetakan biasanya tidak diuji.  Di hadapan kita adalah kasus seperti itu.  Fungsi sedang menunggu pengguna yang, alih-alih menyelesaikan masalahnya, akan dipaksa untuk memperbaikinya. <br><br>  Dengan benar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type) Type-&gt;dump(*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Printer &lt;&lt; <span class="hljs-string"><span class="hljs-string">"&lt;unknown-type&gt;"</span></span>;</code> </pre> <br>  <b>Fragmen N9: Null Pointer</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SearchableTableEmitter::collectTableEntries( GenericTable &amp;Table, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Record *&gt; &amp;Items) { .... RecTy *Ty = resolveTypes(Field.RecType, TI-&gt;getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Ty) <span class="hljs-comment"><span class="hljs-comment">// &lt;= PrintFatalError(Twine("Field '") + Field.Name + "' of table '" + Table.Name + "' has incompatible type: " + Ty-&gt;getAsString() + " vs. " + // &lt;= TI-&gt;getType()-&gt;getAsString()); .... }</span></span></code> </pre> <br>  PVS-Studio Warning: V522 [CWE-476] Dereferencing dari null pointer 'Ty' mungkin terjadi.  SearchableTableEmitter.cpp 614 <br><br>  Saya pikir, jadi semuanya jelas dan tidak memerlukan penjelasan. <br><br>  <b>Fragmen N10: Typo</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> FormatTokenLexer::tryMergeCSharpNullConditionals() { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Identifier = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Question = *(Tokens.end() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... Identifier-&gt;ColumnWidth += Question-&gt;ColumnWidth; Identifier-&gt;Type = Identifier-&gt;Type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= Tokens.erase(Tokens.end() - 1); return true; }</span></span></code> </pre> <br>  PVS-Studio Warning: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V570</a> Variabel 'Identifier-&gt; Type' ditugaskan untuk dirinya sendiri.  FormatTokenLexer.cpp 249 <br><br>  Tidak masuk akal untuk menetapkan variabel ke dirinya sendiri.  Kemungkinan besar mereka ingin menulis: <br><br><pre> <code class="cpp hljs">Identifier-&gt;Type = Question-&gt;Type;</code> </pre> <br>  <b>Fragmen N11: Istirahat yang mencurigakan</b> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SystemZOperand::print(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindToken: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Token:"</span></span> &lt;&lt; getToken(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KindReg: OS &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Reg:"</span></span> &lt;&lt; SystemZInstPrinter::getRegisterName(getReg()); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V622</a> [CWE-478] Pertimbangkan untuk memeriksa pernyataan 'sakelar'.  Mungkin saja operator 'case' pertama hilang.  SystemZAsmParser.cpp 652 <br><br>  Pada awalnya ada pernyataan <i>istirahat yang</i> sangat mencurigakan.  Apakah Anda lupa menulis sesuatu yang lain di sini? <br><br>  <b>Fragmen N12: Memeriksa pointer setelah dereferencing</b> <br><br><pre> <code class="cpp hljs">InlineCost AMDGPUInliner::getInlineCost(CallSite CS) { Function *Callee = CS.getCalledFunction(); Function *Caller = CS.getCaller(); TargetTransformInfo &amp;TTI = TTIWP-&gt;getTTI(*Callee); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> llvm::InlineCost::getNever(<span class="hljs-string"><span class="hljs-string">"undefined callee"</span></span>); .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595</a> [CWE-476] Pointer 'Callee' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 172, 174. AMDGPUInline.cpp 172 <br><br>  Pointer <i>Callee</i> di awal <i>ditereferensi</i> ketika fungsi <i>getTTI dipanggil</i> . <br><br>  Dan kemudian ternyata pointer ini harus diperiksa untuk kesetaraan <i>nullptr</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Callee || Callee-&gt;isDeclaration())</code> </pre> <br>  Tapi sudah terlambat ... <br><br>  <b>Fragment N13 - N ...: Memeriksa pointer setelah dereferencing</b> <br><br>  Situasi yang dibahas dalam cuplikan kode sebelumnya tidak unik.  Dia ditemukan di sini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">optimizeDoubleFP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CallInst *CI, IRBuilder&lt;&gt; &amp;B, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isBinary, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isPrecise = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ .... Function *CalleeFn = CI-&gt;getCalledFunction(); StringRef CalleeNm = CalleeFn-&gt;getName(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= AttributeList CalleeAt = CalleeFn-&gt;getAttributes(); if (CalleeFn &amp;&amp; !CalleeFn-&gt;isIntrinsic()) { // &lt;= .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V595 [CWE-476] Pointer 'CalleeFn' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 1079, 1081. SederhanakanLibCalls.cpp 1079 <br><br>  Dan di sini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Sema::InstantiateAttrs(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MultiLevelTemplateArgumentList &amp;TemplateArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Decl *Tmpl, Decl *New, LateInstantiatedAttrVec *LateAttrs, LocalInstantiationScope *OuterMostScope) { .... NamedDecl *ND = dyn_cast&lt;NamedDecl&gt;(New); CXXRecordDecl *ThisContext = dyn_cast_or_null&lt;CXXRecordDecl&gt;(ND-&gt;getDeclContext()); <span class="hljs-comment"><span class="hljs-comment">// &lt;= CXXThisScopeRAII ThisScope(*this, ThisContext, Qualifiers(), ND &amp;&amp; ND-&gt;isCXXInstanceMember()); // &lt;= .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V595 [CWE-476] Pointer 'ND' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 532, 534. SemaTemplateInstantiateDecl.cpp 532 <br><br>  Dan di sini: <br><br><ul><li>  V595 [CWE-476] Pointer 'U' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 404, 407. DWARFFormValue.cpp 404 </li><li>  V595 [CWE-476] Pointer 'ND' digunakan sebelum diverifikasi terhadap nullptr.  Periksa baris: 2149, 2151. SemaTemplateInstantiate.cpp 2149 </li></ul><br>  Dan kemudian menjadi tidak menarik bagi saya untuk mempelajari peringatan dengan nomor V595.  Jadi saya tidak tahu apakah ada kesalahan serupa selain yang tercantum di sini.  Kemungkinan besar ada. <br><br>  <b>Fragmen N17, N18: Pergeseran mencurigakan</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processLogicalImmediate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Imm, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegSize, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;Encoding)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Size = RegSize; .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>; .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V629</a> [CWE-190] Pertimbangkan untuk memeriksa ekspresi '~ (Ukuran - 1) &lt;&lt; 1'.  Pergeseran bit dari nilai 32-bit dengan ekspansi selanjutnya ke tipe 64-bit.  AArch64AddressingModes.h 260 <br><br>  Mungkin ini bukan kesalahan, dan kode berfungsi persis seperti yang dimaksudkan.  Tapi ini jelas tempat yang sangat mencurigakan, dan perlu diperiksa. <br><br>  Misalkan variabel <i>Ukuran</i> adalah 16, dan kemudian pembuat kode berencana untuk mendapatkan nilai dalam variabel <i>NImms</i> : <br><br>  11111111111111111111111111111111111111111111111111111111111111100000000 <br><br>  Namun, pada kenyataannya, hasilnya adalah: <br><br>  00000000000000000000000000000000000000111111111111111111111111111111000000 <br><br>  Faktanya adalah bahwa semua perhitungan terjadi menggunakan tipe unsigned 32-bit.  Dan hanya kemudian, tipe unsigned 32-bit ini akan secara implisit diperluas ke <i>uint64_t</i> .  Dalam hal ini, bit yang paling signifikan adalah nol. <br><br>  Anda dapat memperbaiki situasi seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> NImms = ~<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(Size<span class="hljs-number"><span class="hljs-number">-1</span></span>) &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Situasi serupa: V629 [CWE-190] Pertimbangkan untuk memeriksa ekspresi 'Immr &lt;&lt; 6'.  Pergeseran bit dari nilai 32-bit dengan ekspansi selanjutnya ke tipe 64-bit.  AArch64AddressingModes.h 269 <br><br>  <b>Cuplikan N19: Kehilangan kata kunci</b> <b><i>lain</i></b> <b>?</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AMDGPUAsmParser::cvtDPP(MCInst &amp;Inst, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OperandVector &amp;Operands) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Op.isReg() &amp;&amp; Op.Reg.RegNo == AMDGPU::VCC) { <span class="hljs-comment"><span class="hljs-comment">// VOP2b (v_add_u32, v_sub_u32 ...) dpp use "vcc" token. // Skip it. continue; } if (isRegOrImmWithInputMods(Desc, Inst.getNumOperands())) { // &lt;= Op.addRegWithFPInputModsOperands(Inst, 2); } else if (Op.isDPPCtrl()) { Op.addImmOperands(Inst, 1); } else if (Op.isImm()) { // Handle optional arguments OptionalIdx[Op.getImmTy()] = I; } else { llvm_unreachable("Invalid operand type"); } .... }</span></span></code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V646</a> [CWE-670] Pertimbangkan untuk memeriksa logika aplikasi.  Mungkin kata kunci 'lain' tidak ada.  AMDGPUAsmParser.cpp 5655 <br><br>  Tidak ada kesalahan di sini.  Karena kemudian blok pertama <i>jika</i> diakhiri dengan <i>melanjutkan</i> , tidak masalah <i>apakah</i> ada kata kunci <i>lain</i> atau tidak.  Bagaimanapun, kode akan bekerja sama.  Namun, kehilangan yang <i>lain</i> membuat kode lebih tidak jelas dan berbahaya.  Jika di masa depan <i>terus</i> menghilang, maka kode akan mulai bekerja dengan cara yang sama sekali berbeda.  Menurut pendapat saya, lebih baik menambahkan yang <i>lain</i> . <br><br>  <b>Fragment N20: Empat kesalahan ketik dari jenis yang sama</b> <br><br><pre> <code class="cpp hljs">LLVM_DUMP_METHOD <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Symbol::dump(raw_ostream &amp;OS) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUndefined()) Result += <span class="hljs-string"><span class="hljs-string">"(undef) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakDefined()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-def) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWeakReferenced()) Result += <span class="hljs-string"><span class="hljs-string">"(weak-ref) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isThreadLocalValue()) Result += <span class="hljs-string"><span class="hljs-string">"(tlv) "</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Kind) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> SymbolKind::GlobalSymbol: Result + Name.str(); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; case SymbolKind::ObjectiveCClass: Result + "(ObjC Class) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCClassEHType: Result + "(ObjC Class EH) " + Name.str(); // &lt;= break; case SymbolKind::ObjectiveCInstanceVariable: Result + "(ObjC IVar) " + Name.str(); // &lt;= break; } OS &lt;&lt; Result; }</span></span></code> </pre> <br>  Peringatan PVS-Studio: <br><br><ul><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + Nama.str ()'.  Symbol.cpp 32 </li><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + "(Kelas ObjC)" + Name.str ()'.  Symbol.cpp 35 </li><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + "(ObjC Kelas EH)" + Name.str ()'.  Symbol.cpp 38 </li><li>  V655 [CWE-480] Senar digabungkan tetapi tidak digunakan.  Pertimbangkan untuk memeriksa ekspresi 'Hasil + "(ObjC IVar)" + Name.str ()'.  Symbol.cpp 41 </li></ul><br>  Secara kebetulan, operator + digunakan alih-alih operator + =.  Hasilnya adalah desain yang tidak berarti. <br><br>  <b>Fragmen N21: Perilaku tidak terdefinisi</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReqFeatures</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;StringRef, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; &amp;FeaturesMap, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Record *&gt; &amp;ReqFeatures)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;R : ReqFeatures) { StringRef AsmCondString = R-&gt;getValueAsString(<span class="hljs-string"><span class="hljs-string">"AssemblerCondString"</span></span>); SmallVector&lt;StringRef, <span class="hljs-number"><span class="hljs-number">4</span></span>&gt; Ops; SplitString(AsmCondString, Ops, <span class="hljs-string"><span class="hljs-string">","</span></span>); assert(!Ops.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"AssemblerCondString cannot be empty"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp;Op : Ops) { assert(!Op.empty() &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Empty operator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FeaturesMap.find(Op) == FeaturesMap.end()) FeaturesMap[Op] = FeaturesMap.size(); } } }</code> </pre> <br>  Coba cari sendiri kode yang berbahaya.  Dan ini adalah gambar untuk gangguan, agar tidak segera melihat jawabannya: <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5d/183/d4e/d5d183d4e2d3107bc512e52d893fda25.png" alt="Hmmm ..."></div><br><br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V708</a> [CWE-758] Konstruksi berbahaya digunakan: 'FeaturesMap [Op] = FeaturesMap.size ()', di mana 'FeaturesMap' adalah dari kelas 'map'.  Ini dapat menyebabkan perilaku yang tidak terdefinisi.  RISCVCompressInstEmitter.cpp 490 <br><br>  Garis masalah: <br><br><pre> <code class="cpp hljs">FeaturesMap[Op] = FeaturesMap.size();</code> </pre> <br>  Jika elemen <i>Op</i> tidak ditemukan, elemen baru dibuat di peta dan jumlah elemen di peta ini ditulis di sana.  Hanya tidak diketahui apakah fungsi <i>ukuran</i> akan dipanggil sebelum atau setelah menambahkan elemen baru. <br><br>  <b>Fragmen N22-N24: Penugasan Kembali</b> <br><br><pre> <code class="cpp hljs">Error MachOObjectFile::checkSymbolTable() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { MachO::nlist STE = getSymbolTableEntry(SymDRI); NType = STE.n_type; <span class="hljs-comment"><span class="hljs-comment">// &lt;= NType = STE.n_type; // &lt;= NSect = STE.n_sect; NDesc = STE.n_desc; NStrx = STE.n_strx; NValue = STE.n_value; } .... }</span></span></code> </pre> <br>  PVS-Studio Warning: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V519</a> [CWE-563] Variabel 'NType' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 1663, 1664. MachOObjectFile.cpp 1664 <br><br>  Saya pikir tidak ada kesalahan nyata di sini.  Hanya mengulangi tugas yang tidak perlu.  Tapi masih ada kesalahan. <br><br>  Demikian pula: <br><br><ul><li>  V519 [CWE-563] Variabel 'B.NDesc' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 1488, 1489. llvm-nm.cpp 1489 </li><li>  V519 [CWE-563] Variabel diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 59, 61. coff2yaml.cpp 61 </li></ul><br>  <b>Fragmen N25-N27: Penugasan ulang lainnya</b> <br><br>  Sekarang pertimbangkan opsi penugasan yang sedikit berbeda. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Vectorizer::vectorizeLoadChain( ArrayRef&lt;Instruction *&gt; Chain, SmallPtrSet&lt;Instruction *, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; *InstructionsProcessed) { .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Alignment = getAlignment(L0); .... <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> NewAlign = getOrEnforceKnownAlignment(L0-&gt;getPointerOperand(), StackAdjustedAlignment, DL, L0, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, &amp;DT); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NewAlign != <span class="hljs-number"><span class="hljs-number">0</span></span>) Alignment = NewAlign; Alignment = NewAlign; .... }</code> </pre> <br>  PVS-Studio Warning: V519 [CWE-563] Variabel 'Alignment' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 1158, 1160. LoadStoreVectorizer.cpp 1160 <br><br>  Ini adalah kode yang sangat aneh yang tampaknya mengandung kesalahan logis.  Pada awalnya, variabel <i>Alignment</i> diberi nilai tergantung pada kondisinya.  Dan kemudian penugasan terjadi lagi, tetapi sekarang tanpa verifikasi. <br><br>  Situasi serupa dapat dilihat di sini: <br><br><ul><li>  V519 [CWE-563] Variabel 'Efek' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 152, 165. WebAssemblyRegStackify.cpp 165 </li><li>  V519 [CWE-563] Variabel 'ExpectNoDerefChunk' diberi nilai dua kali berturut-turut.  Mungkin ini sebuah kesalahan.  Periksa baris: 4970, 4973. SemaType.cpp 4973 </li></ul><br>  <b>Fragmen N28: Selalu kondisi yang benar</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readPrefixes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct InternalInstruction* insn)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> byte = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> nextByte; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byte == <span class="hljs-number"><span class="hljs-number">0xf3</span></span> &amp;&amp; (nextByte == <span class="hljs-number"><span class="hljs-number">0x88</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0x89</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc6</span></span> || nextByte == <span class="hljs-number"><span class="hljs-number">0xc7</span></span>)) { insn-&gt;xAcquireRelease = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextByte != <span class="hljs-number"><span class="hljs-number">0x90</span></span>) <span class="hljs-comment"><span class="hljs-comment">// PAUSE instruction support // &lt;= break; } .... }</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Peringatan</a> PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> [CWE-571] Ekspresi 'nextByte! = 0x90' selalu benar.  X86DisassemblerDecoder.cpp 379 <br><br>  Verifikasi tidak masuk akal.  Variabel <i>nextByte</i> selalu tidak sama dengan <i>0x90</i> , yang mengikuti dari pemeriksaan sebelumnya.  Ini semacam kesalahan logis. <br><br>  <b>Fragment N29 - N ...: Selalu benar / kondisi salah</b> <br><br>  Penganalisa memberikan banyak peringatan bahwa seluruh kondisi ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V547</a> ) atau bagian dari itu ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V560</a> ) selalu benar atau salah.  Seringkali ini bukan kesalahan nyata, tetapi hanya kode yang tidak akurat, hasil dari penyebaran makro dan sejenisnya.  Namun demikian, masuk akal untuk melihat semua peringatan ini, karena dari waktu ke waktu ada kesalahan logis yang nyata.  Misalnya, kode ini mencurigakan: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DecodeStatus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeGPRPairRegisterClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MCInst &amp;Inst, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> RegNo, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Decoder)</span></span></span><span class="hljs-function"> </span></span>{ DecodeStatus S = MCDisassembler::Success; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RegNo &gt; <span class="hljs-number"><span class="hljs-number">13</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MCDisassembler::Fail; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((RegNo &amp; <span class="hljs-number"><span class="hljs-number">1</span></span>) || RegNo == <span class="hljs-number"><span class="hljs-number">0xe</span></span>) S = MCDisassembler::SoftFail; .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V560</a> [CWE-570] Bagian dari ekspresi kondisional selalu salah: RegNo == 0xe.  ARMDisassembler.cpp 939 <br><br>  Konstanta 0xE adalah nilai 14 dalam sistem desimal.  Memeriksa <i>RegNo == 0xe</i> tidak masuk akal, karena jika <i>RegNo&gt; 13</i> , maka fungsi akan menyelesaikan eksekusi. <br><br>  Ada banyak peringatan lain dengan pengidentifikasi V547 dan V560, tetapi, seperti dalam kasus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V595</a> , saya tidak tertarik mempelajari peringatan ini.  Sudah jelas bahwa saya punya cukup bahan untuk menulis artikel :).  Oleh karena itu, tidak diketahui berapa banyak kesalahan jenis ini dapat dideteksi dalam LLVM menggunakan PVS-Studio. <br><br>  Saya akan memberikan contoh mengapa membosankan untuk mempelajari respons ini.  Penganalisa benar dalam mengeluarkan peringatan untuk kode berikut.  Tapi ini bukan kesalahan. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> UnwrappedLineParser::parseBracedList(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> ContinueOnSemicolons, tok::TokenKind ClosingBraceKind) { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> HasError = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; .... HasError = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ContinueOnSemicolons) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !HasError; .... }</code> </pre> <br>  Peringatan PVS-Studio: V547 [CWE-570] Ekspresi '! HasError' selalu salah.  UnwrappedLineParser.cpp 1635 <br><br>  <b>Fragmen N30: ‚Äã‚ÄãPengembalian yang mencurigakan</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isImplicitlyDef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MachineRegisterInfo &amp;MRI, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Reg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (MachineRegisterInfo::def_instr_iterator It = MRI.def_instr_begin(Reg), E = MRI.def_instr_end(); It != E; ++It) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*It).isImplicitDef(); } .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V612</a> [CWE-670] 'pengembalian' tanpa syarat dalam satu lingkaran.  R600OptimizeVectorRegisters.cpp 63 <br><br>  Ini adalah kesalahan atau trik khusus yang dimaksudkan untuk menjelaskan sesuatu kepada programmer yang membaca kode.  Desain ini tidak menjelaskan apa pun kepada saya dan terlihat sangat mencurigakan.  Lebih baik tidak menulis seperti itu :). <br><br>  Apakah kamu lelah?  Lalu saatnya membuat teh atau kopi. <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/f86/58f/8a2f8658fdacb0dde918807666d1cd39.png" alt="Kopi"></div><br><br><h2>  Cacat terdeteksi oleh diagnostik baru </h2><br>  Saya pikir 30 pemicu diagnostik lama sudah cukup.  Sekarang mari kita lihat apa yang menarik dapat ditemukan dengan diagnostik baru yang muncul di analisa setelah pemeriksaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> .  Secara total, 66 diagnostik tujuan umum ditambahkan ke penganalisa C ++ selama waktu ini. <br><br>  <b>Fragmen N31: Kode tidak dapat dijangkau</b> <br><br><pre> <code class="cpp hljs">Error CtorDtorRunner::run() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> CtorDtorMap = ES.lookup(JITDylibSearchList({{&amp;JD, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}}), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(Names), NoDependenciesToRegister, <span class="hljs-literal"><span class="hljs-literal">true</span></span>)) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CtorDtorMap.takeError(); CtorDtorsByPriority.clear(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error::success(); }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V779</a> [CWE-561] Kode tidak dapat dideteksi terdeteksi.  Mungkin saja ada kesalahan.  ExecutionUtils.cpp 146 <br><br>  Seperti yang Anda lihat, kedua cabang <i>pernyataan if</i> diakhiri dengan panggilan ke <i>pernyataan pengembalian</i> .  Dengan demikian, wadah <i>CtorDtorsByPriority</i> tidak <i>akan</i> pernah <i>dikosongkan</i> . <br><br>  <b>Cuplikan N32: Kode Tidak Terjangkau</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> LLParser::ParseSummaryEntry() { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Lex.getKind()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_gv: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseGVEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_module: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseModuleEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> lltok::kw_typeid: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-comment"><span class="hljs-comment">// &lt;= break; // &lt;= default: return Error(Lex.getLoc(), "unexpected summary kind"); } Lex.setIgnoreColonInIdentifiers(false); // &lt;= return false; }</span></span></code> </pre> <br>  Peringatan PVS-Studio: V779 [CWE-561] Kode tidak dapat dideteksi terdeteksi.  Mungkin saja ada kesalahan.  LLParser.cpp 835 <br><br>  Situasi yang menarik.  Mari kita lihat awal tempat ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseTypeIdEntry(SummaryID); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;</code> </pre> <br>  Sekilas, sepertinya tidak ada kesalahan.  Tampaknya pernyataan <i>break</i> berlebihan di sini, dan Anda dapat menghapusnya.  Namun, tidak semuanya begitu sederhana. <br><br>  Penganalisa menghasilkan peringatan pada baris: <br><br><pre> <code class="cpp hljs">Lex.setIgnoreColonInIdentifiers(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  Memang, kode ini tidak dapat dijangkau.  Semua case di akhir <i>beralih</i> dengan panggilan ke <i>pernyataan kembali</i> .  Dan sekarang <i>break</i> kesepian tanpa tujuan tidak terlihat begitu berbahaya!  Mungkin salah satu cabang harus diakhiri dengan <i>istirahat</i> , dan bukan dengan <i>kembali</i> ? <br><br>  <b>Fragmen N33: Kebetulan bit tinggi</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getStubAlignment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Arch == Triple::systemz) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } Expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>&gt; RuntimeDyldImpl::emitSection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ObjectFile &amp;Obj, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SectionRef &amp;Section, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsCode) { .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> DataSize = Section.getSize(); .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StubBufSize &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1</span></span>); .... }</code> </pre> <br>  PVS-Studio Warning: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V784</a> Ukuran bit mask kurang dari ukuran operan pertama.  Ini akan menyebabkan hilangnya bit yang lebih tinggi.  RuntimeDyld.cpp 815 <br><br>  Perhatikan bahwa fungsi <i>getStubAlignment</i> mengembalikan tipe yang <i>tidak ditandatangani</i> .  Kami menghitung nilai ekspresi jika kami menganggap bahwa fungsi mengembalikan nilai 8: <br><br>  ~ (getStubAlignment () - 1) <br><br>  ~ (8u-1) <br><br>  0xFFFFFFF8u <br><br>  Sekarang perhatikan bahwa variabel <i>DataSize</i> memiliki tipe unsigned 64-bit.  Ternyata selama operasi DataSize &amp; 0xFFFFFFF88, ketiga puluh dua bit tingkat tinggi akan diatur ulang.  Kemungkinan besar, ini bukan yang diinginkan oleh programmer.  Saya menduga bahwa dia ingin menghitung: DataSize &amp; 0xFFFFFFFFFFFFFFFFFFF8u. <br><br>  Untuk memperbaiki kesalahan, Anda harus menulis seperti ini: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>&gt;(getStubAlignment()) - <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  Atau lebih: <br><br><pre> <code class="cpp hljs">DataSize &amp;= ~(getStubAlignment() - <span class="hljs-number"><span class="hljs-number">1U</span></span>LL);</code> </pre> <br>  <b>Fragmen N34: Gagal eksplisit yang gagal</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scaleShuffleMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Scale, ArrayRef&lt;T&gt; Mask, SmallVectorImpl&lt;T&gt; &amp;ScaledMask)</span></span></span><span class="hljs-function"> </span></span>{ assert(<span class="hljs-number"><span class="hljs-number">0</span></span> &lt; Scale &amp;&amp; <span class="hljs-string"><span class="hljs-string">"Unexpected scaling factor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NumElts = Mask.size(); ScaledMask.assign(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;(NumElts * Scale), <span class="hljs-number"><span class="hljs-number">-1</span></span>); .... }</code> </pre> <br>  Peringatan PVS-Studio: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">V1028</a> [CWE-190] Kemungkinan meluap.  Pertimbangkan casting operan dari operator 'NumElts * Scale' ke tipe 'size_t', bukan hasilnya.  X86ISelLowering.h 1577 <br><br>  Konversi tipe eksplisit digunakan untuk mencegah overflow ketika mengalikan variabel tipe <i>int</i> .  Namun, casting eksplisit di sini tidak melindungi terhadap overflow.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada awalnya, variabel akan dikalikan, dan hanya dengan demikian hasil penggandaan 32-bit akan diperluas ke tipe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size_t</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen N35: Salin-Tempel yang gagal</font></font></b> <br><br><pre> <code class="cpp hljs">Instruction *InstCombiner::visitFCmpInst(FCmpInst &amp;I) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op0, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op0, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">0</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op0-&gt;getType())); <span class="hljs-comment"><span class="hljs-comment">// &lt;= return &amp;I; } .... }</span></span></code> </pre> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V778</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-682] Dua fragmen kode serupa ditemukan. </font><font style="vertical-align: inherit;">Mungkin, ini adalah kesalahan ketik dan variabel 'Op1' harus digunakan alih-alih 'Op0'. </font><font style="vertical-align: inherit;">InstCombineCompares.cpp 5507 Diagnostik </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baru yang menarik ini mengungkapkan situasi ketika sepotong kode disalin dan beberapa nama mulai berubah di dalamnya, tetapi tidak diperbaiki di satu tempat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa dalam perubahan blok kedua </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OP1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Tetapi di satu tempat mereka tidak memperbaikinya. </font><font style="vertical-align: inherit;">Kemungkinan besar, seharusnya ditulis seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!match(Op1, m_PosZeroFP()) &amp;&amp; isKnownNeverNaN(Op1, &amp;TLI)) { I.setOperand(<span class="hljs-number"><span class="hljs-number">1</span></span>, ConstantFP::getNullValue(Op1-&gt;getType())); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;I; }</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen N36: Kebingungan dalam variabel</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Status</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode; Status() : Mask(<span class="hljs-number"><span class="hljs-number">0</span></span>), Mode(<span class="hljs-number"><span class="hljs-number">0</span></span>){}; Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { Mode &amp;= Mask; }; .... };</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio Warning: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1001</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-563] Variabel 'Mode' ditugaskan tetapi tidak digunakan pada akhir fungsi. </font><font style="vertical-align: inherit;">SIModeRegister.cpp 48 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat berbahaya untuk memberikan argumen fungsi dengan nama yang sama dengan anggota kelas. </font><font style="vertical-align: inherit;">Sangat mudah bingung. </font><font style="vertical-align: inherit;">Di hadapan kita adalah kasus seperti itu. </font><font style="vertical-align: inherit;">Ungkapan ini tidak masuk akal:</font></font><br><br><pre> <code class="cpp hljs">Mode &amp;= Mask;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Argumen fungsi berubah. </font><font style="vertical-align: inherit;">Dan itu dia. </font><font style="vertical-align: inherit;">Argumen ini tidak lagi digunakan. </font><font style="vertical-align: inherit;">Kemungkinan besar, perlu menulis seperti ini:</font></font><br><br><pre> <code class="cpp hljs">Status(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mask, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> Mode) : Mask(Mask), Mode(Mode) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Mode &amp;= Mask; };</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen N37: Kebingungan dalam variabel</font></font></b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SectionBase</span></span></span><span class="hljs-class"> {</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size = <span class="hljs-number"><span class="hljs-number">0</span></span>; .... }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SymbolTableSection</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SectionBase { .... }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SymbolTableSection::addSymbol(Twine Name, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Bind, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Type, SectionBase *DefinedIn, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Value, <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> Visibility, <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> Shndx, <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> Size) { .... Sym.Value = Value; Sym.Visibility = Visibility; Sym.Size = Size; Sym.Index = Symbols.size(); Symbols.emplace_back(llvm::make_unique&lt;Symbol&gt;(Sym)); Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio: V1001 [CWE-563] Variabel 'Ukuran' ditetapkan tetapi tidak digunakan pada akhir fungsi. </font><font style="vertical-align: inherit;">Object.cpp 424 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situasinya mirip dengan yang sebelumnya. </font><font style="vertical-align: inherit;">Itu harus ditulis:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size += <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;EntrySize;</code> </pre> <br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragmen N38-N47: Pointer lupa untuk memeriksa.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sebelumnya, kami memeriksa contoh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemicu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagnostik </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">V595</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Esensinya adalah bahwa pointer dereferenced pada awalnya, dan hanya kemudian diperiksa. </font><font style="vertical-align: inherit;">Diagnostik muda </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah kebalikan dari maknanya, tetapi juga mendeteksi banyak kesalahan. </font><font style="vertical-align: inherit;">Ini mengidentifikasi situasi di mana pointer diperiksa di awal, dan kemudian lupa melakukannya. </font><font style="vertical-align: inherit;">Pertimbangkan kasus-kasus seperti yang ditemukan di dalam LLVM.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGEPCost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Type *PointeeType, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *Ptr, ArrayRef&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Value *&gt; Operands)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= assert(....); BaseGV = dyn_cast&lt;GlobalValue&gt;(Ptr-&gt;stripPointerCasts()); } bool HasBaseReg = (BaseGV == nullptr); auto PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio: V1004 [CWE-476] Pointer 'Ptr' digunakan secara tidak aman setelah diverifikasi terhadap nullptr. </font><font style="vertical-align: inherit;">Periksa baris: 729, 738. TargetTransformInfoImpl.h 738 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variabel </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dapat berupa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sebagaimana dibuktikan oleh centang:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Ptr != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Namun, di bawah penunjuk ini dereferensi tanpa verifikasi sebelumnya: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> PtrSizeBits = DL.getPointerTypeSizeInBits(Ptr-&gt;getType());</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pertimbangkan kasus serupa lainnya. </font></font><br><br><pre> <code class="cpp hljs">llvm::DISubprogram *CGDebugInfo::getFunctionFwdDeclOrStub(GlobalDecl GD, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Stub) { .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> *FD = dyn_cast&lt;FunctionDecl&gt;(GD.getDecl()); SmallVector&lt;QualType, <span class="hljs-number"><span class="hljs-number">16</span></span>&gt; ArgTypes; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FD) <span class="hljs-comment"><span class="hljs-comment">// &lt;= for (const ParmVarDecl *Parm : FD-&gt;parameters()) ArgTypes.push_back(Parm-&gt;getType()); CallingConv CC = FD-&gt;getType()-&gt;castAs&lt;FunctionType&gt;()-&gt;getCallConv(); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio: V1004 [CWE-476] Pointer 'FD' digunakan secara tidak aman setelah diverifikasi terhadap nullptr. </font><font style="vertical-align: inherit;">Periksa baris: 3228, 3231. CGDebugInfo.cpp 3231 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan pointer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FD</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya yakin masalahnya jelas terlihat, dan tidak diperlukan penjelasan khusus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan juga:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computePolynomialFromPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Value &amp;Ptr, Polynomial &amp;Result, Value *&amp;BasePtr, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DataLayout &amp;DL)</span></span></span><span class="hljs-function"> </span></span>{ PointerType *PtrTy = dyn_cast&lt;PointerType&gt;(Ptr.getType()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!PtrTy) { <span class="hljs-comment"><span class="hljs-comment">// &lt;= Result = Polynomial(); BasePtr = nullptr; } unsigned PointerBits = DL.getIndexSizeInBits(PtrTy-&gt;getPointerAddressSpace()); // &lt;= .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio: V1004 [CWE-476] Pointer 'PtrTy' digunakan secara tidak aman setelah diverifikasi terhadap nullptr. </font><font style="vertical-align: inherit;">Periksa baris: 960, 965. InterleavedLoadCombinePass.cpp 965 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana melindungi diri Anda dari kesalahan seperti itu? </font><font style="vertical-align: inherit;">Berhati-hatilah pada Code-Review dan gunakan analisa statis PVS-Studio untuk secara teratur memeriksa kode Anda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak masuk akal untuk membawa fragmen kode lain dengan kesalahan jenis ini. </font><font style="vertical-align: inherit;">Saya hanya akan meninggalkan daftar peringatan di artikel:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476] Pointer 'Expr' digunakan secara tidak aman setelah diverifikasi terhadap nullptr. </font><font style="vertical-align: inherit;">Periksa baris: 1049, 1078. DebugInfoMetadata.cpp 1078</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1004 [CWE-476] Pointer 'PI' digunakan secara tidak aman setelah diverifikasi terhadap nullptr. </font><font style="vertical-align: inherit;">Periksa baris: 733, 753. LegacyPassManager.cpp 753</font></font></li><li> V1004 [CWE-476] The 'StatepointCall' pointer was used unsafely after it was verified against nullptr. Check lines: 4371, 4379. Verifier.cpp 4379 </li><li> V1004 [CWE-476] The 'RV' pointer was used unsafely after it was verified against nullptr. Check lines: 2263, 2268. TGParser.cpp 2268 </li><li> V1004 [CWE-476] The 'CalleeFn' pointer was used unsafely after it was verified against nullptr. Check lines: 1081, 1096. SimplifyLibCalls.cpp 1096 </li><li> V1004 [CWE-476] The 'TC' pointer was used unsafely after it was verified against nullptr. Check lines: 1819, 1824. Driver.cpp 1824 </li></ul><br> <b> N48-N60:  ,   (  )</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutator&gt; createISelMutator() { .... <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IRMutationStrategy&gt;&gt; Strategies; Strategies.emplace_back( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InjectorIRStrategy(InjectorIRStrategy::getDefaultOps())); .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan PVS-Studio: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1023</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [CWE-460] Pointer tanpa pemilik ditambahkan ke wadah 'Strategi' dengan metode 'emplace_back'. Kebocoran memori akan terjadi jika ada pengecualian. llvm-isel-fuzzer.cpp 58 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menambahkan item ke akhir wadah seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: vector &lt;std :: unique_ptr &lt;X&gt;&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda tidak dapat menulis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxx.push_back (X baru)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena tidak ada konversi implisit dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std: : unique_ptr &lt;X&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi umum adalah menulis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxx.emplace_back (X baru)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , karena ia mengkompilasi: metode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplace_back</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> membangun elemen langsung dari argumen dan karenanya dapat menggunakan konstruktor eksplisit.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini tidak aman. </font><font style="vertical-align: inherit;">Jika vektor penuh, maka memori dialokasikan. </font><font style="vertical-align: inherit;">Operasi realokasi memori mungkin gagal, menghasilkan pengecualian </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: bad_alloc dilemparkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam hal ini, penunjuk akan hilang, dan objek yang dibuat tidak akan pernah dihapus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi yang aman adalah membuat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang akan memiliki pointer sebelum vektor mencoba mengalokasikan kembali memori:</font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;X&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X))</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dimulai dengan C ++ 14, Anda dapat menggunakan 'std :: make_unique': </font></font><br><br><pre> <code class="cpp hljs">xxx.push_back(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;X&gt;())</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis cacat ini tidak penting untuk LLVM. </font><font style="vertical-align: inherit;">Jika memori tidak dapat dialokasikan, maka kompiler hanya akan berhenti bekerja. </font><font style="vertical-align: inherit;">Namun, untuk aplikasi dengan waktu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aktif</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang </font><font style="vertical-align: inherit;">lama </font><font style="vertical-align: inherit;">yang tidak dapat berakhir begitu saja jika alokasi memori gagal, ini bisa menjadi bug yang jahat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, meskipun kode ini tidak menimbulkan bahaya praktis untuk LLVM, saya merasa berguna untuk berbicara tentang pola kesalahan ini dan bahwa penganalisa PVS-Studio belajar untuk mendeteksinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peringatan lain dari jenis ini:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V1023 [CWE-460] Pointer tanpa pemilik ditambahkan ke wadah 'Lulus' dengan metode 'emplace_back'. </font><font style="vertical-align: inherit;">Kebocoran memori akan terjadi jika ada pengecualian. </font><font style="vertical-align: inherit;">PassManager.h 546</font></font></li><li> V1023 [CWE-460] A pointer without owner is added to the 'AAs' container by the 'emplace_back' method. A memory leak will occur in case of an exception. AliasAnalysis.h 324 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Entries' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DWARFDebugFrame.cpp 519 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'AllEdges' container by the 'emplace_back' method. A memory leak will occur in case of an exception. CFGMST.h 268 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'VMaps' container by the 'emplace_back' method. A memory leak will occur in case of an exception. SimpleLoopUnswitch.cpp 2012 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Records' container by the 'emplace_back' method. A memory leak will occur in case of an exception. FDRLogBuilder.h 30 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'PendingSubmodules' container by the 'emplace_back' method. A memory leak will occur in case of an exception. ModuleMap.cpp 810 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Objects' container by the 'emplace_back' method. A memory leak will occur in case of an exception. DebugMap.cpp 88 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Strategies' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-isel-fuzzer.cpp 60 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 685 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 686 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 688 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 689 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 690 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 691 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 692 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 693 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Modifiers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. llvm-stress.cpp 694 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Operands' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 1911 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Stash' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2100 </li><li> V1023 [CWE-460] A pointer without owner is added to the 'Matchers' container by the 'emplace_back' method. A memory leak will occur in case of an exception. GlobalISelEmitter.cpp 2702 </li></ul><br><h2>  Kesimpulan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara total, saya menulis 60 peringatan, setelah itu saya berhenti. Apakah ada cacat lain yang terdeteksi oleh analyzer PVS-Studio di LLVM? Ya ada. Namun, ketika saya menulis cuplikan kode untuk artikel itu, sudah larut malam, atau lebih tepatnya, bahkan malam, dan saya memutuskan sudah waktunya untuk mengakhiri. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya harap Anda tertarik, dan Anda ingin mencoba alat analisa PVS-Studio. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengunduh penganalisa dan mendapatkan kunci percobaan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halaman ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yang paling penting, gunakan analisis statis secara teratur. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemeriksaan satu kali yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami lakukan untuk mempopulerkan metodologi analisis statis dan PVS-Studio bukanlah skenario normal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semoga berhasil dalam meningkatkan kualitas dan keandalan kode!</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/c78/30f/70c/c7830f70c5577c3d6704f254d7cad6a3.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda ingin berbagi artikel ini dengan audiens yang berbahasa Inggris, silakan gunakan tautan ke terjemahan: Andrey Karpov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menemukan Bug di LLVM 8 dengan PVS-Studio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450008/">https://habr.com/ru/post/id450008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449998/index.html">FAQ: apa yang perlu diketahui oleh seorang pelancong tentang vaksinasi sebelum bepergian</a></li>
<li><a href="../id450000/index.html">(Kanan ke kiri (Melalui Kaca Mencari</a></li>
<li><a href="../id450002/index.html">Menemukan Bug di LLVM 8 dengan PVS-Studio</a></li>
<li><a href="../id450004/index.html">Fast C / C ++ Cache, Thread Safety</a></li>
<li><a href="../id450006/index.html">Pendinginan pusat data chiller: pendingin mana yang harus dipilih?</a></li>
<li><a href="../id450010/index.html">Penyimpanan, cadangan, dan katalogisasi foto</a></li>
<li><a href="../id450016/index.html">Pembuatan sistem verifikasi formal dari awal. Bagian 1: mesin virtual karakter dalam PHP dan Python</a></li>
<li><a href="../id450018/index.html">Duo matematika memetakan wilayah permukaan minimal yang tak berujung</a></li>
<li><a href="../id450020/index.html">Lembah Silikon datang ke anak sekolah Kansas. Ini menyebabkan protes.</a></li>
<li><a href="../id450024/index.html">Tentang implementasi open-source dari fungsi hash GOST R 34.11-2012 dan dampaknya terhadap tanda tangan elektronik GOST R 34.10-2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>