<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíª üî£ üó£Ô∏è Microsoft ML Spark: ekstensi Spark yang menjadikan SparkML lebih manusiawi dan LightGBM sebagai bonus üë©üèº‚Äçüè´ ü•õ üöÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Banyak yang telah bekerja dengan Spark ML tahu bahwa beberapa hal yang telah mereka lakukan di sana "tidak sepenuhnya berhasil." 
 atau tidak dilakuka...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microsoft ML Spark: ekstensi Spark yang menjadikan SparkML lebih manusiawi dan LightGBM sebagai bonus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/raiffeisenbank/blog/456668/"><p>  Banyak yang telah bekerja dengan Spark ML tahu bahwa beberapa hal yang telah mereka lakukan di sana "tidak sepenuhnya berhasil." <br>  atau tidak dilakukan sama sekali.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Posisi pengembang Spark adalah</a> bahwa SparkML adalah platform dasar, dan semua ekstensi harus merupakan paket terpisah.  Tapi ini tidak selalu nyaman, karena Data Scientist dan analis ingin bekerja dengan alat yang sudah dikenal (Jupter, Zeppelin), di mana ada sebagian besar dari apa yang dibutuhkan.  Mereka tidak ingin mengumpulkan file JAR 500 megabyte dengan perakitan-maven atau mengunduh dependensi di tangan mereka dan menambahkannya ke parameter startup Spark.  Pekerjaan yang lebih baik dengan sistem pembangunan proyek-JVM mungkin memerlukan banyak upaya tambahan dari analis dan DataScientists yang terbiasa dengan Jupyter / Zeppelin.  Meminta DevOps dan administrator cluster untuk meletakkan banyak paket pada node komputasi jelas merupakan ide yang buruk.  Siapa pun yang memiliki ekstensi tertulis untuk SparkML secara independen tahu berapa banyak kesulitan tersembunyi yang ada dengan kelas dan metode penting (yang karena alasan pribadi [ml]), pembatasan pada jenis parameter yang disimpan, dll. </p><br><p>  Dan tampaknya sekarang, dengan perpustakaan MMLSpark, hidup akan sedikit lebih mudah, dan ambang batas untuk memasuki pembelajaran mesin yang skalabel dengan SparkML dan Scala sedikit lebih rendah. </p><a name="habracut"></a><br><h2 id="vvedenie">  Pendahuluan </h2><br><p> Karena sejumlah kesulitan, serta serangkaian metode dan solusi yang sudah jadi di SparkML, banyak perusahaan menulis ekstensi mereka untuk Spark.  Salah satu contoh adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PravdaML</a> , yang sedang dikembangkan di Odnoklassniki dan yang, dilihat dari penilaian cepat tentang apa yang ada di GitHub, terlihat sangat menjanjikan.  Sayangnya, sebagian besar solusi ini tertutup atau terbuka sama sekali, tetapi mereka tidak memiliki kemampuan untuk menginstal melalui Maven / sbt dan dokumentasi API, yang membuatnya sangat sulit untuk bekerja dengannya. </p><br><p>  Hari ini kita melihat perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MMLSpark</a> . </p><br><p>  Kami akan mempertimbangkan, seperti biasa, contoh tugas mengklasifikasikan penumpang Titanic.  Tujuannya adalah untuk menunjukkan sebanyak mungkin fitur perpustakaan MMLSpark, bukan <del>  nonaktifkan SOTA di ImageNet </del>  tunjukkan pembelajaran mesin keren.  Jadi Titanic akan melakukannya. </p><br><p><img src="https://habrastorage.org/webt/rg/bt/sf/rgbtsf7j0ovmfa5lpjkfpfapzti.jpeg"></p><br><p>  Perpustakaan itu sendiri memiliki API asli untuk Scala ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ), Python API ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> ), dan, dilihat dari beberapa tempat dalam repositori GitHub, perpustakaan itu akan segera memiliki API untuk R. </p><br><p>  Ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">contoh laptop yang bagus dalam</a> proyek GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">(PySpark + Jupyter)</a> , tetapi kita akan pergi ke arah lain.  Seperti yang ditulis Dmitry Bugaychenko, jika Anda mengembangkan untuk Spark, yaitu, Anda punya alasan untuk menggunakan Scala untuk ini, apalagi, Scala memungkinkan Anda untuk mendefinisikan Transformer dan Estimator Anda sendiri dengan lebih efisien dan lebih fleksibel untuk menanamkannya dalam SparkML Pipeline, tetapi seberapa lambat ia bekerja dengan lamban / kode panda dalam UDF (dipanggil executable dari JVM) telah banyak ditulis. </p><br><h2 id="kratko-ob-ustanovke">  Instalasi Singkat </h2><br><p>  Seluruh laptop tersedia di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Untuk bekerja dengan Titanic, gambar Docker dari Zeppelin berjalan secara lokal pada laptop dengan pengaturan default sudah cukup untuk mata.  Docker dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Perpustakaan MMLSpark bukan di Maven Central, tetapi dalam paket-percikan, dan untuk menambahkannya ke Zeppelin, Anda harus menjalankan blok berikut di awal laptop: </p><br><pre><code class="plaintext hljs">%spark.dep z.addRepo("bintray.com").url("http://dl.bintray.com/spark-packages/maven/") z.load("Azure:mmlspark:0.17")</code> </pre> <br><p>  Perlu dikatakan bahwa perpustakaan memiliki kompatibilitas ke belakang yang sangat baik: tidak seperti, misalnya, XGBoost4j-spark, yang membutuhkan minimal Spark 2.3+, hal ini masuk ke Spark 2.2.1, yang datang dengan gambar Zeppelin Docker, dan kesulitan apa pun. Saya tidak memperhatikan. </p><br><p>  <strong>Catatan:</strong> sebagian besar pustaka MMLSpark didedikasikan untuk inferensi kisi-kisi pada sebuah cluster, di mana CNTK hadir (yang, dilihat dari dokumentasi, harus membaca model cntk yang sudah jadi) dan blok OpenCV yang besar.  Kami akan fokus pada tugas yang lebih duniawi dan mencoba untuk "memodelkan" kasus ketika kami memiliki array besar data tabular yang terletak di HDFS dalam bentuk .csv, tabel atau dalam format lain.  Jadi, kita perlu pra-proses dan membangun model, sementara data ini tidak sesuai dengan memori satu mesin.  Karena itu, kami akan melakukan semua tindakan pada cluster. </p><br><h2 id="chtenie-i-razvedochnyy-analiz">  Analisis Membaca dan Kecerdasan </h2><br><p>  Secara umum, Spark + Zeppelin tidak buruk sama sekali dan dapat mengatasi tugas EDA, tetapi kami akan mencoba untuk memperluas kemampuan mereka.  Pertama, kita mengimpor kelas yang kita butuhkan: </p><br><ul><li>  Semua dari spark.sql.types untuk mendeklarasikan skema dan membaca data dengan benar </li><li>  Semua dari fungsi spark.sql. untuk mengakses kolom dan menggunakan fungsi bawaan </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">com.microsoft.ml.spark.SummarizeData</a> , yang bisa disebut analog panda. DataFrame.description </li></ul><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.<span class="hljs-type"><span class="hljs-type">SummarizeData</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.sql.functions._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.sql.types._</code> </pre> <br><p>  Kami membaca file kami: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> titanicSchema = <span class="hljs-type"><span class="hljs-type">StructType</span></span>( <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Passanger"</span></span>, <span class="hljs-type"><span class="hljs-type">ShortType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Survived"</span></span>, <span class="hljs-type"><span class="hljs-type">ShortType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"PClass"</span></span>, <span class="hljs-type"><span class="hljs-type">ShortType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>, <span class="hljs-type"><span class="hljs-type">StringType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Sex"</span></span>, <span class="hljs-type"><span class="hljs-type">StringType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Age"</span></span>, <span class="hljs-type"><span class="hljs-type">ShortType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"SibSp"</span></span>, <span class="hljs-type"><span class="hljs-type">ShortType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Parch"</span></span>, <span class="hljs-type"><span class="hljs-type">ShortType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Ticket"</span></span>, <span class="hljs-type"><span class="hljs-type">StringType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Fare"</span></span>, <span class="hljs-type"><span class="hljs-type">FloatType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Cabin"</span></span>, <span class="hljs-type"><span class="hljs-type">StringType</span></span>) :: <span class="hljs-type"><span class="hljs-type">StructField</span></span>(<span class="hljs-string"><span class="hljs-string">"Embarked"</span></span>, <span class="hljs-type"><span class="hljs-type">StringType</span></span>) :: <span class="hljs-type"><span class="hljs-type">Nil</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> train = spark .read .schema(titanicSchema) .option(<span class="hljs-string"><span class="hljs-string">"header"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) .csv(<span class="hljs-string"><span class="hljs-string">"/mountV/titanic/train.csv"</span></span>)</code> </pre> <br><p>  Dan sekarang mari kita lihat data itu sendiri, serta ukurannya: </p><br><pre> <code class="scala hljs">println(<span class="hljs-string"><span class="hljs-string">s"Train shape is: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${train.count}</span></span></span><span class="hljs-string"> x </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${train.columns.length}</span></span></span><span class="hljs-string">"</span></span>) train.limit(<span class="hljs-number"><span class="hljs-number">5</span></span>).createOrReplaceTempView(<span class="hljs-string"><span class="hljs-string">"trainHead"</span></span>)</code> </pre> <br><p>  <strong>Catatan:</strong> Benar-benar tidak perlu menggunakan createOrReplaceTempView ketika Anda bisa menulis .show (5).  Tetapi pertunjukan memiliki masalah: ketika data "lebar", maka representasi tekstual dari pelat "mengapung", dan tidak ada yang menjadi jelas sama sekali. </p><br><p>  Dapatkan ukuran data kami: <code>Train shape is: 891 x 12</code> <br>  Dan sekarang di sel sql kita bisa melihat 5 baris pertama: </p><br><pre> <code class="sql hljs">%sql <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> trainHead</code> </pre> <br><p><img src="https://habrastorage.org/webt/qe/jc/wj/qejcwjvi65jp6xucnorcdfdmxo4.png"></p><br><p>  Baiklah, mari kita lihat Ringkasan di meja kami: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SummarizeData</span></span>() .setBasic(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) .setCounts(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) .setPercentiles(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) .setSample(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) .setErrorThreshold(<span class="hljs-number"><span class="hljs-number">0.25</span></span>) .transform(train) .createOrReplaceTempView(<span class="hljs-string"><span class="hljs-string">"summary"</span></span>)</code> </pre> <br><p>  Kelas SummarizeData memiliki beberapa keunggulan dibandingkan Dataset.description sederhana, karena memungkinkan Anda untuk menghitung jumlah nilai yang hilang dan unik, dan juga memungkinkan Anda untuk menentukan keakuratan penghitungan kuantil.  Ini bisa sangat penting untuk data yang sangat besar. <br><img src="https://habrastorage.org/webt/91/g4/8c/91g48c0oaqiuz8pjgklo38jaiis.png"></p><br><div class="spoiler">  <b class="spoiler_title">Beberapa pemikiran pribadi</b> <div class="spoiler_text"><p>  Secara umum, bagi saya pribadi bahwa Odnoklassniki di PravdaML memiliki implementasi yang lebih baik dari analog SummarizeData.  Microsoft berjalan dengan mudah dan menggunakan <code>org.apache.spark.sql.functions</code> , hanya saja semuanya dengan mudah dibungkus dalam satu kelas.  Untuk Odnoklassniki, ini diterapkan melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>VectorStatCollector</code></a> mereka, yang memerlukan kode yang sedikit lebih rumit saat memanggil (Anda harus terlebih dahulu menambahkan semua fitur ke dalam vektor) dan mungkin memerlukan operasi tambahan (misalnya, <code>VectorAssembler</code> biasanya menolak untuk mencerna <code>DecimalType</code> ).  Tetapi saya memiliki asumsi berdasarkan pengalaman saya dengan Spark bahwa SummarizeData dari MMLSpark mungkin macet dengan kesalahan seperti <code>StackOverflow</code> di <code>org.apache.spark.sql.catalyst</code> jika ada <strong>banyak</strong> kolom, dan grafik perhitungannya tidak kecil pada saat dimulai ( meskipun khusus untuk penggemar "ekstrim" seperti itu di Spark 2.4 mereka menambahkan kemampuan untuk mengurangi pengoptimal grafik <code>Catalyst</code> ).  Nah, tampaknya dengan jumlah kolom yang <strong>sangat besar</strong> , versi dari Microsoft akan lebih lambat.  Tetapi ini, tentu saja, harus diperiksa secara terpisah. </p></div></div><br><h2 id="ochistka-dannyh">  Pembersihan data </h2><br><p>  Di Titanic, semuanya seperti biasa - sekelompok kolom string adalah nilai yang hilang.  Dan beberapa jenis cant dalam data (sepertinya versi data ini tidak terlalu spesifik) - 25 baris dari nilai yang hilang.  Pertama, perbaiki ini: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> trainFiltered = train.filter(!(isnan(col(<span class="hljs-string"><span class="hljs-string">"Survived"</span></span>)) || isnull(col(<span class="hljs-string"><span class="hljs-string">"Survived"</span></span>))))</code> </pre> <br><h3 id="obrabotka-strokovyh-dannyh">  Pemrosesan data string </h3><br><p>  Sejauh yang saya ingat, atribut yang dibawa keluar dari bidang <code>Name</code> dan <code>Cabin</code> adalah yang terbaik dibawa di Titanic.  Anda dapat memasok mereka banyak, tetapi kami akan membatasi diri hanya sedikit, hanya agar tidak memberikan contoh kode yang hampir sama. </p><br><p>  Biasanya nyaman untuk menggunakan ekspresi reguler untuk hal-hal seperti itu. <br>  Tapi kami ingin dalam hal ini: </p><br><ul><li>  semuanya didistribusikan, data diproses di tempat yang sama; </li><li>  semuanya dirancang sebagai SpakrML Transformer atau Spark ML Estimator, sehingga nantinya bisa dirakit di Pipeline. </li></ul><br><p>  <strong>Catatan:</strong> Pipeline, pertama, menjamin kami bahwa kami selalu menerapkan transformasi yang sama untuk kereta dan tes, dan juga memungkinkan kami untuk menangkap kesalahan "melihat ke masa depan" dalam validasi silang.  Dan itu juga memberi kita kemampuan sederhana untuk menghemat, memuat, dan memperkirakan menggunakan saluran pipa kami. </p><br><p>  SparkML memiliki kelas "hampir universal" untuk tugas-tugas tersebut - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SQLTranformer</a> , tetapi menulis dalam SQL jelas lebih buruk daripada menulis di Scala, jika hanya karena dimungkinkan untuk menangkap sintaks atau kesalahan khas selama kompilasi dan penyorotan sintaks dalam Ide.  Dan di sini MMLSpark datang untuk membantu kami, di mana <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">UDFTransformer yang</a> benar-benar universal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diterapkan</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.<span class="hljs-type"><span class="hljs-type">UDFTransformer</span></span></code> </pre> <br><p>  Untuk memulainya, kami akan membuat fungsi transformasi kami, yang sangat sederhana hingga batasnya, tetapi tujuan kami sekarang adalah untuk menunjukkan proses pembuatan UDFTransformer.  Pada prinsipnya, berdasarkan contoh sederhana seperti itu, siapa pun dapat menambahkan logika ke tingkat kompleksitas apa pun. </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> miss = <span class="hljs-string"><span class="hljs-string">".*miss\\..*"</span></span>.r <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mr = <span class="hljs-string"><span class="hljs-string">".*mr\\..*"</span></span>.r <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> mrs = <span class="hljs-string"><span class="hljs-string">".*mrs\\..*"</span></span>.r <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> master = <span class="hljs-string"><span class="hljs-string">".*master.*"</span></span>.r <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convertNames</span></span></span></span>(input: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = { <span class="hljs-type"><span class="hljs-type">Option</span></span>(input).map(x =&gt; { x.toLowerCase <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> miss() =&gt; <span class="hljs-string"><span class="hljs-string">"Miss"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> mr() =&gt; <span class="hljs-string"><span class="hljs-string">"Mr"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> mrs() =&gt; <span class="hljs-string"><span class="hljs-string">"Mrs"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> master() =&gt; <span class="hljs-string"><span class="hljs-string">"Master"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-string"><span class="hljs-string">"Unknown"</span></span> } }) }</code> </pre> <br><p>  (Anda dapat segera melihat betapa nyamannya Scala untuk bekerja dengan nilai yang hilang, yang, omong-omong, tidak hanya <code>null</code> , tetapi juga <code>Double.NaN</code> , tetapi ada <del>  lelucon seperti itu </del>  hal yang jarang terjadi seperti kelalaian dalam variabel <code>BooleanType</code> , dll.) </p><br><p>  Sekarang nyatakan <code>UserDefinedFunction</code> kami dan segera buat <code>Transformer</code> berdasarkan itu: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nameTransformUDF = udf(convertNames _) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> nameTransformer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">UDFTransformer</span></span>() .setUDF(nameTransformUDF) .setInputCol(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>) .setOutputCol(<span class="hljs-string"><span class="hljs-string">"NameType"</span></span>)</code> </pre> <br><p>  <strong>Catatan:</strong> Di laptop Zeppelin, semuanya sama saja, tetapi ketika semuanya datang bersamaan dalam kode produksi, penting bahwa semua UDF berada di kelas atau objek yang <code>extends Serializable</code> .  Hal yang jelas bahwa Anda kadang-kadang bisa melupakan dan kemudian mempelajari untuk waktu yang lama adalah apa yang salah dengan membaca jejak tumpukan panjang kesalahan Spark. </p><br><p>  Sekarang kami masih memiliki bidang <code>Cabin</code> .  Mari kita lihat lebih dekat: <br><img src="https://habrastorage.org/webt/1m/sn/n2/1msnn2zqeyerzpysj2ma3bwzuda.png"></p><br><p>  Kami melihat bahwa ada banyak nilai yang hilang, ada huruf, angka, kombinasi berbeda, dll.  Mari kita ambil jumlah kabin (jika lebih dari satu), dan juga jumlahnya - mereka mungkin memiliki semacam logika, misalnya, jika penomorannya dari satu ujung kapal, maka kabin pada haluan memiliki peluang lebih kecil.  Kami juga akan membuat fungsi, dan kemudian berdasarkan padanya <code>UDFTransformer</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCabinsCount</span></span></span></span>(input: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = { <span class="hljs-type"><span class="hljs-type">Option</span></span>(input) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(x) =&gt; x.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>).length <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">-1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numPattern = <span class="hljs-string"><span class="hljs-string">"([az])([0-9]+)"</span></span>.r <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getNumbersFromCabin</span></span></span></span>(input: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = { <span class="hljs-type"><span class="hljs-type">Option</span></span>(input) <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(x) =&gt; { x.split(<span class="hljs-string"><span class="hljs-string">" "</span></span>)(<span class="hljs-number"><span class="hljs-number">0</span></span>).toLowerCase <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> numPattern(sym, num) =&gt; <span class="hljs-type"><span class="hljs-type">Integer</span></span>.parseInt(num) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-number"><span class="hljs-number">-1</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">-2</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cabinsCountUDF = udf(getCabinsCount _) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbersFromCabinUDF = udf(getNumbersFromCabin _) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cabinsCountTransformer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">UDFTransformer</span></span>() .setInputCol(<span class="hljs-string"><span class="hljs-string">"Cabin"</span></span>) .setOutputCol(<span class="hljs-string"><span class="hljs-string">"CabinCount"</span></span>) .setUDF(cabinsCountUDF) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numbersFromCabinTransformer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">UDFTransformer</span></span>() .setInputCol(<span class="hljs-string"><span class="hljs-string">"Cabin"</span></span>) .setOutputCol(<span class="hljs-string"><span class="hljs-string">"CabinNumber"</span></span>) .setUDF(numbersFromCabinUDF)</code> </pre> <br><p>  Sekarang mari kita mulai dengan nilai-nilai yang hilang, yaitu usia.  Pertama, mari manfaatkan kemampuan visualisasi Zeppelin: </p><br><p><img src="https://habrastorage.org/webt/h-/cj/l6/h-cjl6tzbakgmqxc1w-gt_kgwk0.png"></p><br><p>  Dan lihat bagaimana nilai-nilai yang hilang merusak segalanya.  Adalah logis untuk menggantinya dengan nilai tengah (atau median), tetapi tujuan kami adalah untuk mempertimbangkan semua fitur perpustakaan MMLSpark.  Oleh karena itu, kami akan menulis <code>Estimator</code> kami sendiri, yang akan mempertimbangkan kelompok / rata-rata pada sampel pelatihan dan menggantinya dengan kesenjangan yang sesuai. </p><br><p>  Kami akan membutuhkan: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.sql.{<span class="hljs-type"><span class="hljs-type">Dataset</span></span>, <span class="hljs-type"><span class="hljs-type">DataFrame</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.{<span class="hljs-type"><span class="hljs-type">Estimator</span></span>, <span class="hljs-type"><span class="hljs-type">Model</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.param.{<span class="hljs-type"><span class="hljs-type">Param</span></span>, <span class="hljs-type"><span class="hljs-type">ParamMap</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.util.<span class="hljs-type"><span class="hljs-type">Identifiable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.util.<span class="hljs-type"><span class="hljs-type">DefaultParamsWritable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.{<span class="hljs-type"><span class="hljs-type">HasInputCol</span></span>, <span class="hljs-type"><span class="hljs-type">HasOutputCol</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.<span class="hljs-type"><span class="hljs-type">ConstructorWritable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.<span class="hljs-type"><span class="hljs-type">ConstructorReadable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.<span class="hljs-type"><span class="hljs-type">Wrappable</span></span></code> </pre> <br><p>  Mari kita perhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ConstructorWritable</code></a> , yang sangat menyederhanakan kehidupan.  Jika <code>Model</code> kami adalah <code>Model</code> "terlatih" yang mengembalikan metode <code>fit(),</code> , yang sepenuhnya ditentukan oleh konstruktornya (dan ini mungkin 99% kasus), maka kami tidak dapat menulis serialisasi dengan tangan kami sama sekali.  Ini sangat menyederhanakan dan mempercepat pengembangan, menghilangkan kesalahan, dan juga menurunkan ambang entri untuk DataScientist dan analis yang biasanya bukan programmer profesional. </p><br><p>  Tentukan kelas <code>Estimator</code> kami.  Padahal, yang terpenting di sini adalah metode <code>fit</code> , sisanya adalah poin teknis: </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupImputerEstimator</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">override val uid: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Estimator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupImputerModel</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasInputCol</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasOutputCol</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wrappable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultParamsWritable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-type"><span class="hljs-type">Identifiable</span></span>.randomUID(<span class="hljs-string"><span class="hljs-string">"GroupImputer"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupCol: <span class="hljs-type"><span class="hljs-type">Param</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Param</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"groupCol"</span></span>, <span class="hljs-string"><span class="hljs-string">"Groupping column"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setGroupCol</span></span></span></span>(v: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.set(groupCol, v) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getGroupCol</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span> = $(groupCol) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fit</span></span></span></span>(dataset: <span class="hljs-type"><span class="hljs-type">Dataset</span></span>[_]): <span class="hljs-type"><span class="hljs-type">GroupImputerModel</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> meanDF = dataset .toDF .groupBy($(groupCol)) .agg(mean(col($(inputCol))).alias(<span class="hljs-string"><span class="hljs-string">"groupMean"</span></span>)) .select(col($(groupCol)), col(<span class="hljs-string"><span class="hljs-string">"groupMean"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">GroupImputerModel</span></span>( uid, meanDF, getInputCol, getOutputCol, getGroupCol ) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformSchema</span></span></span></span>(schema: <span class="hljs-type"><span class="hljs-type">StructType</span></span>): <span class="hljs-type"><span class="hljs-type">StructType</span></span> = schema .add( <span class="hljs-type"><span class="hljs-type">StructField</span></span>( $(outputCol), schema.filter(x =&gt; x.name == $(inputCol))(<span class="hljs-number"><span class="hljs-number">0</span></span>).dataType ) ) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span></span>(extra: <span class="hljs-type"><span class="hljs-type">ParamMap</span></span>): <span class="hljs-type"><span class="hljs-type">Estimator</span></span>[<span class="hljs-type"><span class="hljs-type">GroupImputerModel</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> to = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">GroupImputerEstimator</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.uid) copyValues(to, extra).asInstanceOf[<span class="hljs-type"><span class="hljs-type">GroupImputerEstimator</span></span>] } }</code> </pre> <br><p>  <strong>Catatan:</strong> Saya tidak menggunakan defaultCopy, karena ketika saya menelepon, untuk beberapa alasan, bersumpah bahwa saya tidak memiliki konstruktor. \ &lt;init&gt; (java.lang.String), walaupun sepertinya ini seharusnya tidak terjadi.  Nah, bagaimanapun, menerapkan <code>copy</code> mudah. </p><br><p>  Sekarang Anda perlu mengimplementasikan <code>Model</code> - kelas yang menggambarkan model yang terlatih dan mengimplementasikan metode <code>transform</code> .  Kami akan membangunnya berdasarkan fungsi <code>coalesce</code> dibangun ke dalam fungsi <code>org.apache.spark.sql.functions</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupImputerModel</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params"> val uid: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val meanDF: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">DataFrame</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val inputCol: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val outputCol: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, val groupCol: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params"> </span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupImputerModel</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstructorWritable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupImputerModel</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> ttag: <span class="hljs-type"><span class="hljs-type">TypeTag</span></span>[<span class="hljs-type"><span class="hljs-type">GroupImputerModel</span></span>] = typeTag[<span class="hljs-type"><span class="hljs-type">GroupImputerModel</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">objectsToSave</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>] = <span class="hljs-type"><span class="hljs-type">List</span></span>(uid, meanDF, inputCol, outputCol, groupCol) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span></span>(extra: <span class="hljs-type"><span class="hljs-type">ParamMap</span></span>): <span class="hljs-type"><span class="hljs-type">GroupImputerModel</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">GroupImputerModel</span></span>(uid, meanDF, inputCol, outputCol, groupCol) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span></span>(dataset: <span class="hljs-type"><span class="hljs-type">Dataset</span></span>[_]): <span class="hljs-type"><span class="hljs-type">DataFrame</span></span> = { dataset .toDF .join(meanDF, <span class="hljs-type"><span class="hljs-type">Seq</span></span>(groupCol), <span class="hljs-string"><span class="hljs-string">"left"</span></span>) .withColumn( outputCol, coalesce(col(inputCol), col(<span class="hljs-string"><span class="hljs-string">"groupMean"</span></span>)) .cast(<span class="hljs-type"><span class="hljs-type">IntegerType</span></span>)) .drop(<span class="hljs-string"><span class="hljs-string">"groupMean"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transformSchema</span></span></span><span class="hljs-function"> </span></span>(schema: <span class="hljs-type"><span class="hljs-type">StructType</span></span>): <span class="hljs-type"><span class="hljs-type">StructType</span></span> = schema .add( <span class="hljs-type"><span class="hljs-type">StructField</span></span>(outputCol, schema.filter(x =&gt; x.name == inputCol)(<span class="hljs-number"><span class="hljs-number">0</span></span>).dataType) ) }</code> </pre> <br><p>  Objek terakhir yang perlu kita deklarasikan adalah <code>Reader</code> , yang kami implementasikan menggunakan kelas MMLSpark <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ConstructorReadable</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupImputerModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstructorReadable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupImputerModel</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br><h2 id="sozdanie-pipeline">  Pembuatan Pipa </h2><br><p>  Di Pipeline, saya ingin menunjukkan kelas SparkML yang biasa dan hal yang sangat nyaman dari MMLSpark - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MultiColumnAdapter</a> , yang memungkinkan Anda untuk menerapkan transformator SparkML ke banyak kolom sekaligus (untuk referensi, misalnya, StringIndexer dan OneHotEncoder mengambil tepat satu kolom ke input, yang mengubahnya) iklan kesakitan): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.feature.{<span class="hljs-type"><span class="hljs-type">StringIndexer</span></span>, <span class="hljs-type"><span class="hljs-type">VectorAssembler</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.<span class="hljs-type"><span class="hljs-type">Pipeline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.{<span class="hljs-type"><span class="hljs-type">MultiColumnAdapter</span></span>, <span class="hljs-type"><span class="hljs-type">LightGBMClassifier</span></span>}</code> </pre> <br><p>  Pertama, kami akan mendeklarasikan kolom mana yang kami miliki: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> catCols = <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-string"><span class="hljs-string">"Sex"</span></span>, <span class="hljs-string"><span class="hljs-string">"Embarked"</span></span>, <span class="hljs-string"><span class="hljs-string">"NameType"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> numCols = <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-string"><span class="hljs-string">"PClass"</span></span>, <span class="hljs-string"><span class="hljs-string">"AgeNoMissings"</span></span>, <span class="hljs-string"><span class="hljs-string">"SibSp"</span></span>, <span class="hljs-string"><span class="hljs-string">"Parch"</span></span>, <span class="hljs-string"><span class="hljs-string">"CabinCount"</span></span>, <span class="hljs-string"><span class="hljs-string">"CabinNumber"</span></span>)</code> </pre> <br><p>  Sekarang buat string encoder: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stringEncoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">MultiColumnAdapter</span></span>() .setBaseStage(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">StringIndexer</span></span>().setHandleInvalid(<span class="hljs-string"><span class="hljs-string">"keep"</span></span>)) .setInputCols(catCols) .setOutputCols(catCols.map(x =&gt; x + <span class="hljs-string"><span class="hljs-string">"_freqEncoded"</span></span>))</code> </pre> <br><p>  <strong>Catatan:</strong> Tidak seperti scikit-learn di SparkML, <code>StringIndexer</code> bekerja berdasarkan prinsip frequency-encoder, dan itu dapat digunakan untuk menentukan hubungan pesanan (mis. Kategori 0 &lt;kategori 1, dan ini masuk akal) - pendekatan ini sering bekerja dengan baik untuk pohon yang menentukan. </p><br><p>  <code>Imputer</code> kami: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> missingImputer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">GroupImputerEstimator</span></span>() .setInputCol(<span class="hljs-string"><span class="hljs-string">"Age"</span></span>) .setOutputCol(<span class="hljs-string"><span class="hljs-string">"AgeNoMissings"</span></span>) .setGroupCol(<span class="hljs-string"><span class="hljs-string">"Sex"</span></span>)</code> </pre> <br><p>  Dan <code>VectorAssembler</code> , karena pengklasifikasi SparkML lebih nyaman bekerja dengan <code>VectorType</code> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> assembler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">VectorAssembler</span></span>() .setInputCols(stringEncoder.getOutputCols ++ numCols) .setOutputCol(<span class="hljs-string"><span class="hljs-string">"features"</span></span>)</code> </pre> <br><p>  Sekarang kita akan menggunakan peningkatan gradien yang disertakan dengan MMLSpark - LightGBM, yang termasuk dalam "Tiga Besar" implementasi terbaik dari algoritma ini bersama dengan XGBoost dan CatBoost.  Ini berfungsi berkali-kali lebih cepat, lebih baik dan lebih stabil daripada implementasi GBM yang dimiliki SparkML (bahkan dengan mempertimbangkan bahwa port JVM masih dalam pengembangan aktif): </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> catColIndices = <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lgbClf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">LightGBMClassifier</span></span>() .setFeaturesCol(<span class="hljs-string"><span class="hljs-string">"features"</span></span>) .setLabelCol(<span class="hljs-string"><span class="hljs-string">"Survived"</span></span>) .setProbabilityCol(<span class="hljs-string"><span class="hljs-string">"predictedProb"</span></span>) .setPredictionCol(<span class="hljs-string"><span class="hljs-string">"predictedLabel"</span></span>) .setRawPredictionCol(<span class="hljs-string"><span class="hljs-string">"rawPrediction"</span></span>) .setIsUnbalance(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) .setCategoricalSlotIndexes(catColIndices) .setObjective(<span class="hljs-string"><span class="hljs-string">"binary"</span></span>)</code> </pre> <br><p>  <strong>Catatan:</strong> LightGBM mendukung kerja dengan variabel kategorikal (hampir seperti catboost), jadi kami menunjukkannya terlebih dahulu di mana atribut kategori ada di vektor kami, dan dia sendiri akan mencari tahu apa yang harus dilakukan dengan mereka dan bagaimana cara menyandikannya. </p><br><div class="spoiler">  <b class="spoiler_title">Lebih lanjut tentang fitur LightGBM untuk Spark</b> <div class="spoiler_text"><ul><li>  Pada node yang menjalankan RadHat LightGBM, versi apa pun kecuali yang terbaru akan macet karena fakta bahwa ia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak menyukai</a> versi <code>glibc</code> .  Ini diperbaiki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">baru-baru ini</a> , namun, ketika menginstal melalui Maven, MMLSpark menarik versi kedua dari LightGBM ketika menginstal melalui Maven, jadi Anda perlu menambahkan ketergantungan versi terbaru pada RadHat dengan tangan Anda. </li><li>  LightGBM dalam pekerjaannya menciptakan soket pada driver untuk komunikasi dengan para eksekutif, dan ia melakukan ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>new java.net.ServerSocket(0)</code></a> , dan oleh karena itu port acak dari port sesaat OS digunakan.  Jika kisaran port fana berbeda dari kisaran port yang dibuka oleh firewall, maka <del>  dapat membakar banyak </del>  Anda bisa mendapatkan efek yang menarik ketika LightGBM terkadang berhasil (ketika saya memilih port yang bagus), dan terkadang tidak.  Dan akan ada kesalahan di sana seperti <code>ConnectionTimeOut</code> , yang juga dapat menunjukkan, misalnya, opsi ketika GC bergantung pada eksekutif atau sesuatu seperti itu.  Secara umum, jangan ulangi kesalahan saya. </li></ul></div></div><br><p>  Yah, akhirnya, nyatakan Pipeline kami: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pipeline = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Pipeline</span></span>() .setStages( <span class="hljs-type"><span class="hljs-type">Array</span></span>( missingImputer, nameTransformer, cabinsCountTransformer, numbersFromCabinTransformer, stringEncoder, assembler, lgbClf ) )</code> </pre> <br><h2 id="obuchenie">  Pelatihan </h2><br><p>  Kami akan mematahkan set pelatihan kami menjadi kereta api dan tes dan memeriksa Pipa kami.  Di sini, hanya mungkin untuk mengevaluasi kenyamanan pipa, karena sepenuhnya independen terhadap partisi dan menjamin kami bahwa kami akan menerapkan transformasi yang sama untuk melatih dan menguji, dan semua parameter transformasi akan "dipelajari" di kereta: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">Array</span></span>(trainDF, testDF) = trainFiltered.randomSplit(<span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">0.8</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>)) println(<span class="hljs-string"><span class="hljs-string">s"Train rows: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${trainDF.count}</span></span></span><span class="hljs-string">\nTest rows: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${testDF.count}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Train rows: 708 // Test rows: 158 val predictions = pipeline .fit(trainDF) .transform(testDF)</span></span></code> </pre> <br><p>  Untuk perhitungan metrik yang nyaman, kami akan menggunakan kelas lain dari MMLSpark - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ComputeModelStatistics</a> : </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.<span class="hljs-type"><span class="hljs-type">ComputeModelStatistics</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.microsoft.ml.spark.metrics.<span class="hljs-type"><span class="hljs-type">MetricConstants</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> modelEvaluator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ComputeModelStatistics</span></span>() .setLabelCol(<span class="hljs-string"><span class="hljs-string">"Survived"</span></span>) .setScoresCol(<span class="hljs-string"><span class="hljs-string">"predictedProb"</span></span>) .setScoredLabelsCol(<span class="hljs-string"><span class="hljs-string">"predictedLabel"</span></span>) .setEvaluationMetric(<span class="hljs-type"><span class="hljs-type">MetricConstants</span></span>.<span class="hljs-type"><span class="hljs-type">ClassificationMetrics</span></span>)</code> </pre> <br><p><img src="https://habrastorage.org/webt/we/rc/ba/wercbac58qpt0hsygugtqqkhc3u.png"></p><br><p>  Tidak buruk, mengingat bahwa kami tidak mengubah pengaturan default. </p><br><h2 id="podbor-giperparametrov">  Pemilihan hiperparameter </h2><br><p>  Untuk memilih hyperparameters di MMLSpark ada hal keren yang terpisah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>TuneHyperparameters</code></a> , yang mengimplementasikan pencarian acak di grid.  Namun, sayangnya, itu belum mendukung <code>Pipeline</code> , jadi kami akan menggunakan SparkML <code>CrossValidator</code> biasa: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.tuning.{<span class="hljs-type"><span class="hljs-type">ParamGridBuilder</span></span>, <span class="hljs-type"><span class="hljs-type">CrossValidator</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.spark.ml.evaluation.<span class="hljs-type"><span class="hljs-type">BinaryClassificationEvaluator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paramSpace = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">ParamGridBuilder</span></span>() .addGrid(lgbClf.maxDepth, <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) .addGrid(lgbClf.learningRate, <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">0.05</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>)) .addGrid(lgbClf.numIterations, <span class="hljs-type"><span class="hljs-type">Array</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">300</span></span>)) .build println(<span class="hljs-string"><span class="hljs-string">s"Size of ParamsGrid: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${paramSpace.size}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// Size of ParamsGrid: 8 val crossValidator = new CrossValidator() .setEstimator(pipeline) .setEstimatorParamMaps(paramSpace) .setNumFolds(3) .setSeed(42L) .setEvaluator( new BinaryClassificationEvaluator() .setMetricName("areaUnderROC") .setLabelCol("Survived") .setRawPredictionCol("rawPrediction") ) val bestModel = crossValidator .fit(trainFiltered)</span></span></code> </pre> <br><p>  Sayangnya, saya tidak menemukan cara yang nyaman bagaimana Anda bisa melihat hasilnya bersama dengan parameter yang didapat.  Karena itu, perlu menggunakan desain "mengerikan": </p><br><pre> <code class="scala hljs">crossValidator .getEstimatorParamMaps .zip(bestModel.avgMetrics) .foreach(x =&gt; { println( <span class="hljs-string"><span class="hljs-string">"\n"</span></span> + x._1 .toSeq .foldLeft(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">StringBuilder</span></span>())( (a, b) =&gt; a .append(<span class="hljs-string"><span class="hljs-string">s"\n\t</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${b.param.name}</span></span></span><span class="hljs-string"> : </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${b.value}</span></span></span><span class="hljs-string">"</span></span>)) .toString + <span class="hljs-string"><span class="hljs-string">s"\n\tMetric: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${x._2}</span></span></span><span class="hljs-string">"</span></span> ) })</code> </pre> <br><p>  Yang memberi kita sesuatu seperti ini: <br><img src="https://habrastorage.org/webt/xl/li/o7/xllio7tbr67gq_wqolrqwzkzswu.png"></p><br><p>  Kami mendapatkan hasil terbaik dengan mengurangi kecepatan belajar dan meningkatkan kedalaman pohon.  Atas dasar ini, akan dimungkinkan untuk menyesuaikan ruang pencarian dan mencapai hasil yang lebih optimal, tetapi kami tidak memiliki tujuan seperti itu. </p><br><h2 id="zaklyuchenie">  Kesimpulan </h2><br><p>  Bahkan, sementara MMLSpark memiliki versi 0.17 dan masih mengandung bug terpisah.  Namun dari semua ekstensi Spark yang saya lihat, MMLSpark menurut saya memiliki dokumentasi yang paling komprehensif dan proses instalasi dan implementasi yang paling mudah dipahami.  Microsoft belum benar-benar mempromosikannya, hanya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan tentang Databricks</a> , tetapi ada lebih banyak tentang DeepLearning, dan bukan tentang hal-hal rutin yang saya tulis. </p><br><p>  Secara pribadi, dalam tugas kami, perpustakaan ini banyak membantu, memungkinkan saya mendapatkan sedikit lebih sedikit melalui hutan sumber Spark dan tidak menggunakan reflek untuk mengakses metode pribadi [ml], dan seorang rekan menemukan perpustakaan hampir secara kebetulan.  Pada saat yang sama, karena fakta bahwa perpustakaan sedang dalam pengembangan aktif, struktur file sumber <del>  bubur penuh </del>  agak membingungkan.  Nah, karena kenyataan bahwa tidak ada contoh khusus atau dokumentasi lain (kecuali untuk skaladoc telanjang), pada awalnya kami harus merangkak ke kode sumber terus-menerus. </p><br><p>  Oleh karena itu, saya sangat berharap bahwa tutorial mini ini (terlepas dari semua kejelasan dan kesederhanaannya) akan bermanfaat bagi seseorang dan akan membantu menghemat banyak waktu dan usaha! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456668/">https://habr.com/ru/post/id456668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456654/index.html">Proyek ERP tidak begitu menakutkan seperti yang dilukis</a></li>
<li><a href="../id456656/index.html">Pelajaran tentang SDL 2: Pelajaran 4 - Peregangan PNG</a></li>
<li><a href="../id456658/index.html">Tumbuh dewasa: bagaimana kami menilai keterampilan dalam suatu tim</a></li>
<li><a href="../id456662/index.html">Bagaimana cara menghemat uang pada seorang terapis menggunakan pengembangan berbasis tes</a></li>
<li><a href="../id456666/index.html">WebTotem atau bagaimana kita ingin membuat Internet lebih aman</a></li>
<li><a href="../id456670/index.html">Tentang metode otentikasi yang sangat mata-mata</a></li>
<li><a href="../id456672/index.html">Resep Nginx: pemberitahuan asinkron dari PostgreSQL ke websocket</a></li>
<li><a href="../id456676/index.html">Masuk dalam aplikasi php yang didistribusikan</a></li>
<li><a href="../id456678/index.html">Keadaan elektronik masa depan. Bagian 4</a></li>
<li><a href="../id456680/index.html">Delapan Hukum Penamaan dalam Desain UX (Bagian 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>