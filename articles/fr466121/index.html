<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèª‚Äçüè≠ üõ∏ üçπ G√©n√©ration de son sur des microcontr√¥leurs AVR utilisant une m√©thode de table d'onde avec prise en charge de la polyphonie üîà üôè üç¢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les microcontr√¥leurs AVR sont assez bon march√© et r√©pandus. Probablement, presque tous les d√©veloppeurs int√©gr√©s commencent par eux. Et parmi les amat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>G√©n√©ration de son sur des microcontr√¥leurs AVR utilisant une m√©thode de table d'onde avec prise en charge de la polyphonie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466121/">  Les microcontr√¥leurs AVR sont assez bon march√© et r√©pandus.  Probablement, presque tous les d√©veloppeurs int√©gr√©s commencent par eux.  Et parmi les amateurs, l'Arduino domine le ballon, dont le c≈ìur est g√©n√©ralement l'ATmega328p.  Beaucoup se sont s√ªrement demand√©: comment pouvez-vous les faire sonner? <br><br>  Si vous regardez des projets existants, ils sont de plusieurs types: <br><br><ol><li>  G√©n√©rateurs d'impulsions carr√©es.  G√©n√©rez en utilisant des broches PWM ou Yank dans les interruptions.  Dans tous les cas, un grincement tr√®s caract√©ristique est obtenu. </li><li>  Utiliser un √©quipement externe tel qu'un d√©codeur MP3. </li><li>  Utilisation de PWM pour produire un son 8 bits (parfois 16 bits) au format PCM ou ADPCM.  Comme la m√©moire des microcontr√¥leurs n'est clairement pas suffisante pour cela, ils utilisent g√©n√©ralement une carte SD. </li><li>  Utiliser PWM pour g√©n√©rer du son bas√© sur des tables d'ondes comme MIDI. </li></ol><br>  Ce dernier type √©tait particuli√®rement int√©ressant pour moi, car  ne n√©cessite presque pas d'√©quipement suppl√©mentaire.  Je pr√©sente mon option √† la communaut√©.  Tout d'abord, une petite d√©mo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Int√©ress√©, je demande chat. <br><a name="habracut"></a><br>  Ainsi, l'√©quipement: <br><br><ul><li>  ATmega8 ou ATmega328.  Le portage sur d'autres ATmega n'est pas difficile.  Et m√™me sur ATtiny, mais plus √† ce sujet plus tard; </li><li>  R√©sistance; </li><li>  Condensateur; </li><li>  Haut-parleur ou casque; </li><li>  La nutrition; </li></ul><br>  Comme tout. <br><br>  Un simple circuit RC avec un haut-parleur est connect√© √† la sortie du microcontr√¥leur.  La sortie est un son 8 bits avec une fr√©quence d'√©chantillonnage de 31250 Hz.  √Ä une fr√©quence cristalline de 8 MHz, jusqu'√† 5 canaux sonores + un canal de bruit pour les percussions peuvent √™tre g√©n√©r√©s.  Dans ce cas, presque tout le temps du processeur est utilis√©, mais apr√®s avoir rempli le tampon, le processeur peut √™tre occup√© par quelque chose d'utile en plus du son: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/JwqY7FoxYsk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Cet exemple s'int√®gre parfaitement dans la m√©moire ATmega8, 5 canaux + bruit sont trait√©s √† une fr√©quence cristalline de 8 MHz et il y a peu de temps pour l'animation sur l'√©cran. <br><br>  Dans cet exemple, je voulais √©galement montrer que la biblioth√®que peut √™tre utilis√©e non seulement comme une carte postale musicale ordinaire, mais aussi pour connecter le son √† des projets existants, par exemple, pour les notifications.  Et m√™me lorsque vous n'utilisez qu'un seul canal sonore, les notifications peuvent √™tre beaucoup plus int√©ressantes qu'un simple tweeter. <br><br>  Et maintenant les d√©tails ... <br><br><h2>  Tables ou tables d'ondes </h2><br>  Le calcul est extr√™mement simple.  Il existe une fonction de tonalit√© p√©riodique, par exemple <i>ton (t) = sin (t * freq / (2 * Pi))</i> . <br><br>  Il existe √©galement une fonction pour changer le volume de la tonalit√© fondamentale dans le temps, par exemple <i>volume (t) = e ^ (- t)</i> . <br><br>  Dans le cas le plus simple, le son d'un instrument est le produit de ces fonctions <i>instrument (t) = tonalit√© (t) * volume (t)</i> : <br><br>  Sur le graphique, tout ressemble √† ceci: <br><br><img src="https://habrastorage.org/webt/pn/dp/pi/pndppihozomu4ep_fxzcho44xx8.png"><br><br>  Ensuite, nous prenons tous les instruments qui sonnent √† un moment donn√© et les r√©sumons avec quelques facteurs de volume (pseudo-code): <br><br><pre><code class="cmake hljs">for (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; CHANNELS; i++) { value += channels[i].tone(t) * channels[i].volume(t) * channels[i].volume; }</code> </pre> <br>  Il suffit de s√©lectionner le volume pour qu'il n'y ait pas de d√©bordement.  Et c‚Äôest presque tout. <br><br>  Le canal de bruit fonctionne √† peu pr√®s de la m√™me mani√®re, mais au lieu d'une fonction de tonalit√©, un g√©n√©rateur de s√©quence pseudo-al√©atoire. <br><br>  La percussion est un m√©lange de canal de bruit et d'onde basse fr√©quence, √† environ 50-70 Hz. <br>  Bien s√ªr, la qualit√© sonore de cette mani√®re est difficile √† obtenir.  Mais nous n'avons que 8 kilo-octets pour tout.  J'esp√®re que cela peut √™tre pardonn√©. <br><br><h2>  Que puis-je extraire de 8 bits </h2><br>  Au d√©part, je me suis concentr√© sur ATmega8.  Sans quartz externe, il fonctionne √† une fr√©quence de 8 MHz et poss√®de un PWM 8 bits, ce qui donne une fr√©quence d'√©chantillonnage de base de 8000000/256 = 31250 Hz.  Un temporisateur utilise PWM pour produire du son, et il provoque une interruption pendant le d√©bordement pour transmettre la valeur suivante au g√©n√©rateur PWM.  En cons√©quence, nous avons 256 cycles pour calculer la valeur de l'√©chantillon pour tout, y compris la surcharge d'interruption, la mise √† jour des param√®tres du canal sonore, le suivi du moment o√π vous devez jouer la note suivante, etc. <br><br>  Pour l'optimisation, nous utiliserons activement les astuces suivantes: <br><br><ul><li>  Puisque nous avons un processeur huit bits, nous essaierons de rendre les variables identiques.  Parfois, nous utilisons 16 bits. </li><li>  Les calculs sont conditionnellement divis√©s en fr√©quents et non.  Les premiers doivent √™tre calcul√©s pour chaque √©chantillon, le second - beaucoup moins souvent, une fois tous les quelques dizaines / centaines d'√©chantillons. </li><li>  Pour r√©partir uniform√©ment la charge dans le temps, nous utilisons un tampon circulaire.  Dans la boucle principale du programme, nous remplissons le tampon, le soustrayons dans l'interruption.  Si tout va bien, le tampon se remplit plus vite qu'il ne se vide et nous avons le temps pour autre chose. </li><li>  Le code est √©crit en C avec beaucoup de ligne.  La pratique montre que c'est tellement plus rapide. </li><li>  Tout ce qui peut √™tre calcul√© par le pr√©processeur, notamment avec la participation de la division, est fait par le pr√©processeur. </li></ul><br>  Tout d'abord, divisez le temps en intervalles de 4 millisecondes (je les ai appel√©s ticks).  √Ä une fr√©quence d'√©chantillonnage de 31250 Hz, nous obtenons 125 √©chantillons par tick.  Le fait que chaque √©chantillon doit √™tre lu doit √™tre compt√© pour chaque √©chantillon, et le reste - une fois par tick ou moins.  Par exemple, en un seul tick, le volume de l'instrument sera constant: <i>instrument (t) = tone (t) * currentVolume</i> ;  et le volume actuel lui-m√™me sera recalcul√© une fois par tick en tenant compte du volume (t) et du volume s√©lectionn√© du canal sonore. <br><br>  Une dur√©e de tick de 4 ms a √©t√© choisie sur la base d'une simple limite de 8 bits: avec un compteur d'√©chantillons de huit bits, vous pouvez travailler avec une fr√©quence d'√©chantillonnage allant jusqu'√† 64 kHz, avec un compteur de ticks de huit bits, nous pouvons mesurer le temps jusqu'√† 1 seconde. <br><br><h2>  Du code </h2><br>  Le canal lui-m√™me est d√©crit par cette structure: <br><br><pre> <code class="cmake hljs">typedef struct { // Info about wave const int8_t* waveForm; // Wave table array uint16_t waveSample; // High byte is an index in waveForm array uint16_t waveStep; // Frequency, how waveSample is changed in time // Info about volume envelope const uint8_t* volumeForm; // Array of volume change in time uint8_t volumeFormLength; // Length of volumeForm uint8_t volumeTicksPerSample; // How many ticks should pass before index of volumeForm is changed uint8_t volumeTicksCounter; // Counter for volumeTicksPerSample // Info about volume uint8_t currentVolume; // Precalculated volume for current tick uint8_t instrumentVolume; // Volume of channel } waveChannel;</code> </pre> <br>  Conditionnellement, les donn√©es ici sont divis√©es en 3 parties: <br><br><ol><li>  Informations sur la forme d'onde, la phase, la fr√©quence. <br><br>  waveForm: informations sur la fonction tone (t): r√©f√©rence √† un tableau de 256 octets.  R√®gle la tonalit√©, le son de l'instrument. <br><br>  waveSample: l'octet haut indique l'index actuel du tableau waveForm. <br><br>  waveStep: d√©finit la fr√©quence √† laquelle waveSample sera augment√© lors du comptage du prochain √©chantillon. <br><br>  Chaque √©chantillon est consid√©r√© comme quelque chose comme ceci: <br><br><pre> <code class="cmake hljs">int8_t tone = channelData.waveForm[channelData.waveSample &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>]; channelData.waveSample += channelaData.waveStep; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tone * channelData.currentVolume;</code> </pre> <br></li><li>  Informations sur le volume.  D√©finit la fonction de modification du volume au fil du temps.  Comme le volume ne change pas si souvent, vous pouvez le recompter moins souvent, une fois par tick.  Cela se fait comme ceci: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((channel-&gt;volumeTicksCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; channel-&gt;volumeFormLength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { channel-&gt;volumeTicksCounter = channel-&gt;volumeTicksPerSample; channel-&gt;volumeFormLength--; channel-&gt;volumeForm++; } channel-&gt;currentVolume = channel-&gt;volumeForm * channel-&gt;instrumentVolume &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>;</code> </pre> <br></li><li>  R√®gle le volume du canal et le volume actuel calcul√©. <br></li></ol><br>  Remarque: la forme d'onde est de huit bits, le volume est √©galement de huit bits et le r√©sultat est de 16 bits.  Avec une l√©g√®re perte de performances, vous pouvez rendre le son (presque) 16 bits. <br><br>  Dans la lutte pour la productivit√©, j'ai d√ª recourir √† de la magie noire. <br><br>  Exemple num√©ro 1. Comment recalculer le volume des canaux: <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((tickSampleCounter--) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { //    tickSampleCounter = SAMPLES_PER_TICK ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>; //   - } // volume recalculation should no be done so often for all channels <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tickSampleCounter &lt; CHANNELS_SIZE) { recalculateVolume(channels[tickSampleCounter]); }</code> </pre> <br>  Ainsi, tous les canaux recomptent le volume une fois par tick, mais pas simultan√©ment. <br><br>  Exemple num√©ro 2. Conserver les informations de canal dans une structure statique est moins cher que dans un tableau.  Sans entrer dans les d√©tails de l'impl√©mentation de wavechannel.h je dirai que ce fichier est ins√©r√© plusieurs fois dans le code (√©gal au nombre de canaux) avec diff√©rentes directives de pr√©processeur.  Chaque insert cr√©e de nouvelles variables globales et une nouvelle fonction de calcul de canal, qui est ensuite int√©gr√©e dans le code principal: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#if CHANNELS_SIZE &gt;= 1 val += channel0NextSample(); #endif #if CHANNELS_SIZE &gt;= 2 val += channel1NextSample(); #endif ‚Ä¶</span></span></code> </pre><br>  Exemple num√©ro 3. Si nous commen√ßons √† jouer la note suivante un peu plus tard, alors personne ne le remarquera.  Imaginons la situation: nous avons pris le processeur avec quelque chose et pendant ce temps, le tampon √©tait presque vide.  Ensuite, nous commen√ßons √† le remplir et tout √† coup, il s'av√®re qu'une nouvelle mesure arrive: nous devons mettre √† jour les notes actuelles, lire dans le tableau la suite, etc.  Si nous n'avons pas le temps, il y aura un b√©gaiement caract√©ristique.  Il est pr√©f√©rable de remplir un peu le tampon d'anciennes donn√©es et de ne mettre √† jour que l'√©tat des canaux. <br><br><pre> <code class="cmake hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((samplesToWrite) &gt; <span class="hljs-number"><span class="hljs-number">4</span></span>) { //          fillBuffer(SAMPLES_PER_TICK); //     -  updateMusicData(); //    }</code> </pre> <br>  Dans le bon sens, il serait n√©cessaire de recharger le tampon apr√®s la boucle, mais comme nous avons presque tout en ligne, la taille du code est sensiblement gonfl√©e. <br><br><h2>  La musique </h2><br>  Un compteur de ticks de huit bits est utilis√©.  Lorsque z√©ro est atteint, une nouvelle mesure commence, le compteur se voit attribuer la dur√©e de la mesure (en ticks), un peu plus tard le tableau des commandes musicales est v√©rifi√©. <br><br>  Les donn√©es musicales sont stock√©es dans un tableau d'octets.  Il est √©crit quelque chose comme ceci: <br><br><pre> <code class="cmake hljs">const uint8_t demoSample[] PROGMEM = { DATA_TEMPO(<span class="hljs-number"><span class="hljs-number">160</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> beats per minute DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_INSTRUMENT(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Assign instrument <span class="hljs-number"><span class="hljs-number">1</span></span> (see setSample) to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">0</span></span> DATA_VOLUME(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>), // <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span> volume <span class="hljs-number"><span class="hljs-number">128</span></span> to channel <span class="hljs-number"><span class="hljs-number">1</span></span> DATA_PLAY(<span class="hljs-number"><span class="hljs-number">0</span></span>, NOTE_A4, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A4 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_PLAY(<span class="hljs-number"><span class="hljs-number">1</span></span>, NOTE_A3, <span class="hljs-number"><span class="hljs-number">1</span></span>), // Play note A3 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> channel <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> wait <span class="hljs-number"><span class="hljs-number">1</span></span> beat DATA_WAIT(<span class="hljs-number"><span class="hljs-number">63</span></span>), // Wait <span class="hljs-number"><span class="hljs-number">63</span></span> beats DATA_END() // End of data stream };</code> </pre> <br>  Tout ce qui commence par DATA_ sont des macros de pr√©processeur qui d√©veloppent les param√®tres dans le nombre d'octets de donn√©es requis. <br><br>  Par exemple, la commande DATA_PLAY est d√©velopp√©e en 2 octets, dans lesquels sont stock√©s: le marqueur de commande (1 bit), la pause avant la commande suivante (3 bits), le num√©ro de canal sur lequel jouer la note (4 bits), les informations sur la note (8 bits).  La limitation la plus importante est que cette commande ne peut pas √™tre utilis√©e pour de longues pauses, avec un maximum de 7 mesures.  Si vous en avez besoin de plus, vous devez utiliser la commande DATA_WAIT (jusqu'√† 63 mesures).  Malheureusement, je n'ai pas trouv√© si la macro peut √™tre √©tendue dans un nombre diff√©rent d'octets du tableau en fonction du param√®tre de macro.  Et m√™me avertissement je ne sais pas comment afficher.  Tu me dis peut-√™tre. <br><br><h2>  Utiliser </h2><br>  Dans le r√©pertoire des d√©mos, il existe plusieurs exemples pour diff√©rents microcontr√¥leurs.  Mais en bref, voici un morceau de readme, je n'ai vraiment rien √† ajouter: <br><br><pre> <code class="cmake hljs"><span class="hljs-comment"><span class="hljs-comment">#include "../../microsound/devices/atmega8timer1.h" #include "../../microsound/micromusic.h" // Make some settings #define CHANNELS_SIZE 5 #define SAMPLES_SIZE 16 #define USE_NOISE_CHANNEL initMusic(); // Init music data and sound control sei(); // Enable interrupts, silence sound should be generated setSample(0, instrument1); // Use instrument1 as sample 0 setSample(1, instrument2); // Init all other instruments‚Ä¶ playMusic(mySong); // Start playing music at pointer mySong while (!isMusicStopped) { fillMusicBuffer(); // Fill music buffer in loop // Do some other stuff }</span></span></code> </pre> <br>  Si vous voulez faire autre chose que de la musique, vous pouvez augmenter la taille du tampon en utilisant BUFFER_SIZE.  La taille du tampon doit √™tre de 2 ^ n, mais, malheureusement, avec une taille de 256, une d√©gradation des performances se produit.  Jusqu'√† ce que je le comprenne. <br><br>  Pour augmenter la productivit√©, vous pouvez augmenter la fr√©quence avec du quartz externe, vous pouvez r√©duire le nombre de canaux, vous pouvez r√©duire la fr√©quence d'√©chantillonnage.  Avec la derni√®re astuce, vous pouvez utiliser une interpolation lin√©aire, qui compense quelque peu la baisse de la qualit√© sonore. <br><br>  Tout retard n'est pas recommand√©, car  Le temps CPU est perdu.  Au lieu de cela, sa propre m√©thode est impl√©ment√©e dans le <i>fichier microsound / delay.h</i> , qui, en plus de la pause elle-m√™me, est impliqu√©e dans le remplissage du tampon.  Cette m√©thode peut ne pas fonctionner tr√®s pr√©cis√©ment sur des pauses courtes, mais sur des pauses longues plus ou moins saines. <br><br><h2>  Faire votre propre musique </h2><br>  Si vous √©crivez des commandes manuellement, vous devez pouvoir √©couter ce qui se passe.  Verser chaque changement dans le microcontr√¥leur n'est pas pratique, surtout s'il existe une alternative. <br><br>  Il existe un service assez amusant, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wavepot.com</a> - un √©diteur JavaScript en ligne dans lequel vous devez d√©finir de temps en temps la fonction du signal sonore, et ce signal est √©mis vers la carte son.  L'exemple le plus simple: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dsp</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0.1</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(<span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI * t * <span class="hljs-number"><span class="hljs-number">440</span></span>); }</code> </pre> <br>  J'ai port√© le moteur sur JavaScript, il se trouve dans <i>demos / wavepot.js</i> .  Le contenu du fichier doit √™tre ins√©r√© dans l'√©diteur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wavepot.com</a> et vous pouvez effectuer des exp√©riences.  Nous √©crivons nos donn√©es dans le tableau soundData, √©coutez, n'oubliez pas de sauvegarder. <br><br>  Il faut √©galement mentionner la variable simulate8bits.  Elle, selon le nom, simule un son huit bits.  Si soudain, il semble que les tambours bourdonnent et que du bruit apparaisse dans les instruments amortis avec un son calme, alors c'est tout, une distorsion d'un son de huit bits.  Vous pouvez essayer de d√©sactiver cette option et √©couter la diff√©rence.  Le probl√®me est beaucoup moins perceptible s'il n'y a pas de silence dans la musique. <br><br><h2>  Connexion </h2><br>  Dans une version simple, le circuit ressemble √† ceci: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VC | R1 | Pin+---/\/\--+-----&gt; OUT | | | +---+GN | === C1 | +-------+ | | | --- Grnd --- Grnd</code> </pre> <br>  La broche de sortie d√©pend du microcontr√¥leur.  La r√©sistance R1 et le condensateur C1 doivent √™tre s√©lectionn√©s en fonction de la charge, de l'amplificateur (le cas √©ch√©ant), etc.  Je ne suis pas ing√©nieur en √©lectronique et je ne donnerai pas de formules; elles sont faciles √† utiliser avec les calculatrices en ligne. <br><br>  J'ai R1 = 130 Ohms, C1 = 0,33 uF.  √Ä la sortie, je connecte un casque chinois ordinaire. <br><br><h2>  Qu'y avait-il √† propos du son 16 bits? </h2><br>  Comme je l'ai dit plus haut, lorsque nous multiplions deux nombres √† huit bits (fr√©quence et volume), nous obtenons un nombre √† 16 bits.  Vous ne pouvez pas l'arrondir √† huit bits, mais produire les deux octets sur 2 canaux PWM.  Si vous m√©langez ces 2 canaux dans le rapport 1/256, nous pouvons obtenir un son 16 bits.  La diff√©rence avec le huit bits est particuli√®rement facile √† entendre sur les sons et les tambours qui s'estompent en douceur dans les moments o√π un seul instrument sonne. <br><br>  Connexion de sortie 16 bits: <br><br><pre> <code class="plaintext hljs">+5V ^ MCU | +-------+ +---+VCC | R1 | PinH+---/\/\--+-----&gt; OUT | | | | | R2 | | PinL+---/\/\--+ +---+GND | | | +-------+ === C1 | | --- Grnd --- Grnd</code> </pre> <br>  Il est important de bien m√©langer les 2 sorties: la r√©sistance R2 doit √™tre 256 fois sup√©rieure √† la r√©sistance R1.  Plus c'est pr√©cis, mieux c'est.  Malheureusement, m√™me les r√©sistances avec une erreur de 1% ne donnent pas la pr√©cision requise.  Cependant, m√™me avec une s√©lection de r√©sistances peu pr√©cise, la distorsion peut √™tre sensiblement att√©nu√©e. <br><br>  Malheureusement, lors de l'utilisation d'un son 16 bits, les performances se d√©gradent et 5 canaux + bruit n'ont plus le temps de traiter dans les 256 cycles d'horloge allou√©s. <br><br><h2>  Est-ce possible sur Arduino? </h2><br>  Oui tu peux.  Je n'ai qu'un nano clone chinois sur ATmega328p, √ßa marche dessus.  Tr√®s probablement, d'autres Arduins sur l'ATmega328p devraient √©galement fonctionner.  L'ATmega168 semble avoir les m√™mes registres de contr√¥le de minuterie.  Ils fonctionneront tr√®s probablement inchang√©s.  Sur les autres microcontr√¥leurs que vous devez v√©rifier, vous devrez peut-√™tre ajouter un pilote. <br><br>  Il y a un croquis dans <i>demos / arduino328p</i> , mais pour qu'il s'ouvre normalement dans l'IDE Arduino, vous devez le copier √† la racine du projet. <br><br>  Dans l'exemple, un son 16 bits est g√©n√©r√© et les sorties D9 et D10 sont utilis√©es.  Pour simplifier, vous pouvez vous limiter au son 8 bits et utiliser une seule sortie D9. <br><br>  √âtant donn√© que presque tous les arduins fonctionnent √† 16 MHz, vous pouvez, si vous le souhaitez, augmenter le nombre de canaux √† 8. <br><br><h2>  Et ATtiny? </h2><br>  ATtiny n'a pas de multiplication mat√©rielle.  La multiplication logicielle que le compilateur utilise est extr√™mement lente et il vaut mieux l'√©viter.  Lors de l'utilisation d'inserts d'assemblage optimis√©s, les performances chutent de 2 fois par rapport √† ATmega.  Il semblerait que cela ne sert √† rien d'utiliser ATtiny, mais ... <br><br>  Certains ATtiny ont un multiplicateur de fr√©quence, PLL.  Et cela signifie que sur ces microcontr√¥leurs, il existe 2 fonctionnalit√©s int√©ressantes: <br><br><ol><li>  La fr√©quence du g√©n√©rateur PWM est de 64 MHz, ce qui donne une p√©riode PWM de 250 kHz, ce qui est bien mieux que 31250 Hz √† 8 MHz ou 62500 Hz avec du quartz √† 16 MHz sur n'importe quel ATmega. </li><li>  Le m√™me multiplicateur de fr√©quence permet au cristal de cadencer √† 16 MHz sans quartz. </li></ol><br>  D'o√π la conclusion: certains ATtiny peuvent √™tre utilis√©s pour g√©n√©rer du son.  Ils parviennent √† traiter les m√™mes 5 instruments + canal de bruit, mais √† 16 MHz et ils n'ont pas besoin de quartz externe. <br><br>  L'inconv√©nient est que la fr√©quence ne peut plus √™tre augment√©e et que les calculs prennent presque tout le temps.  Pour lib√©rer des ressources, vous pouvez r√©duire le nombre de canaux ou la fr√©quence d'√©chantillonnage. <br><br>  Un autre inconv√©nient est la n√©cessit√© d'utiliser deux temporisateurs √† la fois: un pour PWM, le second pour interruption.  C'est l√† que les chronom√®tres se terminent g√©n√©ralement. <br><br>  Parmi les microcontr√¥leurs PLL que je connais, je peux citer ATtiny85 / 45/25 (8 jambes), ATtiny861 / 461/261 (20 jambes), ATtiny26 (20 jambes). <br><br>  Quant √† la m√©moire, la diff√©rence avec ATmega n'est pas grande.  En 8kb, plusieurs instruments et m√©lodies s'int√©greront parfaitement.  En 4 Ko, vous pouvez mettre 1-2 instruments et 1-2 morceaux.  Il est difficile de mettre quelque chose en 2 kilo-octets, mais si vous le voulez vraiment, vous le pouvez.  Il est n√©cessaire de s√©parer les m√©thodes, de d√©sactiver certaines fonctions telles que le contr√¥le du volume sur les canaux, de r√©duire la fr√©quence d'√©chantillonnage et le nombre de canaux.  En g√©n√©ral, pour un amateur, mais il existe un exemple de travail sur ATtiny26. <br><br><h2>  Les probl√®mes </h2><br>  Il y a des probl√®mes.  Et le plus gros probl√®me est la vitesse de l'informatique.  Le code est enti√®rement √©crit en C avec de petites insertions de multiplication d'assembleur pour ATtiny.  L'optimisation est donn√©e au compilateur et il se comporte parfois √©trangement.  Avec de petits changements qui ne devraient pas sembler influencer quoi que ce soit, vous pouvez obtenir une diminution notable des performances.  De plus, passer de -Os √† -O3 n'aide pas toujours.  Un tel exemple est l'utilisation d'un tampon de 256 octets.  Particuli√®rement d√©sagr√©able est qu'il n'y a aucune garantie que dans les nouvelles versions du compilateur, nous n'obtiendrons pas une baisse des performances sur le m√™me code. <br><br>  Un autre probl√®me est que le m√©canisme d'att√©nuation avant la note suivante n'est pas du tout impl√©ment√©.  C'est-√†-dire  quand sur un canal une note est remplac√©e par une autre, l'ancien son est brusquement interrompu, parfois un petit clic se fait entendre.  Je voudrais trouver un moyen de m'en d√©barrasser sans perdre de performance, mais jusqu'√† pr√©sent. <br><br>  Il n'y a pas de commandes pour augmenter / diminuer le volume en douceur.  Il est particuli√®rement important pour les sonneries de notification courtes, o√π vous devez finalement att√©nuer rapidement le volume afin qu'il n'y ait pas de coupure nette dans le son.  Une partie du probl√®me est en √©crivant une s√©rie de commandes avec r√©glage manuel du volume et une courte pause. <br><br>  L'approche choisie, en principe, n'est pas en mesure de fournir un son naturaliste aux instruments.  Pour un son plus naturel, vous devez diviser les sons des instruments en attaque-sustain-release, utiliser au moins les 2 premi√®res parties et avec une dur√©e beaucoup plus longue qu'une p√©riode d'oscillation.  Mais alors, les donn√©es de l'outil auront besoin de beaucoup plus.  Il y avait une id√©e d'utiliser des tables d'ondes plus courtes, par exemple, en 32 octets au lieu de 256, mais sans interpolation, la qualit√© sonore diminue consid√©rablement, et avec l'interpolation, les performances diminuent.  Et un autre 8 bits d'√©chantillonnage n'est clairement pas suffisant pour la musique, mais cela peut √™tre contourn√©. <br><br>  La taille du tampon est limit√©e √† 256 √©chantillons.  Cela correspond √† environ 8 millisecondes et c'est la p√©riode de temps int√©grale maximale qui peut √™tre donn√©e √† d'autres t√¢ches.  Dans le m√™me temps, l'ex√©cution des t√¢ches est toujours p√©riodiquement suspendue par des interruptions. <br><br>  Le remplacement du d√©lai standard ne fonctionne pas tr√®s pr√©cis√©ment pour les courtes pauses. <br><br>  Je suis s√ªr que ce n'est pas une liste compl√®te. <br><br><h2>  Les r√©f√©rences </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lien Github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Calcul du filtre PWM</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Quelques id√©es et une d√©mo tir√©es d'ici</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466121/">https://habr.com/ru/post/fr466121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466105/index.html">Overclocking de l'API Magento Rest avec RoadRunner</a></li>
<li><a href="../fr466107/index.html">Syst√®me de maison intelligente √† faire soi-m√™me</a></li>
<li><a href="../fr466109/index.html">R√©solution de probl√®mes avec pwnable.kr 22 - brainfuck. Attaque Ret2libc</a></li>
<li><a href="../fr466111/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 32. R√©cup√©ration de mot de passe, XMODEM / TFTPDNLD et activation de licence Cisco</a></li>
<li><a href="../fr466113/index.html">D√©finir l'encodage de texte en PHP au lieu de mb_detect_encoding</a></li>
<li><a href="../fr466123/index.html">Croissance. Poids. Trois voisins</a></li>
<li><a href="../fr466127/index.html">Centrale nucl√©aire de Kola ou debout au r√©acteur</a></li>
<li><a href="../fr466129/index.html">Efficacit√© du transport sur l'essence, les batteries et l'hydrog√®ne</a></li>
<li><a href="../fr466135/index.html">Megapack: comment les d√©veloppeurs de Factorio ont r√©ussi √† r√©soudre le probl√®me avec le mode multijoueur √† 200 joueurs</a></li>
<li><a href="../fr466137/index.html">Pipelines System.IO. - un outil peu connu des amateurs de hautes performances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>