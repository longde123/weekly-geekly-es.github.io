<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üß£ ü¶Ü ‚≠êÔ∏è Biblioth√®que de g√©n√©rateur de code assembleur pour microcontr√¥leurs AVR. Partie 4 üñêüèø üåæ üîÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚Üê Partie 3. Adressage indirect et contr√¥le de flux 
 Partie 5. Conception d'applications multi-thread. ‚Üí 
 Biblioth√®que de g√©n√©rateur de code d'assemb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Biblioth√®que de g√©n√©rateur de code assembleur pour microcontr√¥leurs AVR. Partie 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463627/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">‚Üê Partie 3. Adressage indirect et contr√¥le de flux</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Partie 5. Conception d'applications multi-thread.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">‚Üí</a> </p><br><h2 id="biblioteka-generatora-assemblernogo-koda-dlya-mikrokontrollerov-avr">  Biblioth√®que de g√©n√©rateur de code d'assembleur pour microcontr√¥leurs AVR </h2><br><h3 id="chast-4-programmirovanie-periferiynyh-ustroystv-i-obrabotka-preryvaniy">  Partie 4. Programmation des p√©riph√©riques et gestion des interruptions </h3><br><p>  Dans cette partie de l'article, nous allons, comme promis, traiter de l'un des aspects les plus populaires de la programmation des microcontr√¥leurs - √† savoir, travailler avec des p√©riph√©riques.  Il existe deux approches les plus courantes de la programmation p√©riph√©rique.  Premi√®rement, le syst√®me de programmation ne sait rien des p√©riph√©riques et ne fournit que des moyens d'acc√®s aux ports de contr√¥le des p√©riph√©riques.  Cette approche n'est pratiquement pas diff√©rente de l'utilisation de p√©riph√©riques au niveau de l'assembleur et n√©cessite une √©tude approfondie de l'objectif de tous les ports associ√©s au fonctionnement d'un p√©riph√©rique sp√©cifique.  Pour faciliter le travail des programmeurs, il existe des programmes sp√©ciaux, mais leur aide, en r√®gle g√©n√©rale, se termine par la g√©n√©ration d'une s√©quence d'initialisation initiale du p√©riph√©rique.  L'avantage de cette approche est un acc√®s complet √† toutes les capacit√©s p√©riph√©riques, et l'inconv√©nient est la complexit√© de la programmation et la grande quantit√© de code de programme. </p><br><p>  La seconde - le travail avec les p√©riph√©riques s'effectue au niveau des p√©riph√©riques virtuels.  Le principal avantage de cette approche est la simplicit√© de la gestion des p√©riph√©riques et la possibilit√© de travailler avec eux sans plonger dans l'impl√©mentation mat√©rielle particuli√®re.  L'inconv√©nient de cette approche est la limitation des capacit√©s des p√©riph√©riques par le but et les fonctions du p√©riph√©rique virtuel √©mul√©. </p><br><p>  La biblioth√®que NanoRTOS impl√©mente une troisi√®me approche.  Chaque p√©riph√©rique est d√©crit par une classe sp√©cialis√©e, dont le but est de simplifier la configuration et le fonctionnement du p√©riph√©rique tout en conservant toutes ses fonctionnalit√©s.  Il est pr√©f√©rable de d√©montrer les caract√©ristiques de cette approche √† l'aide d'exemples, alors commen√ßons. </p><a name="habracut"></a><br><p>  Commen√ßons par le p√©riph√©rique le plus simple et le plus courant - le port d'entr√©e / sortie num√©rique.  Ce port combine jusqu'√† 8 canaux, chacun pouvant √™tre configur√© ind√©pendamment pour l'entr√©e ou la sortie.  Une clarification √† 8 signifie que l'architecture du contr√¥leur implique la possibilit√© d'attribuer des fonctions alternatives pour les bits de port individuels, ce qui exclut leur utilisation comme ports d'eau / de sortie, r√©duisant ainsi le nombre de bits disponibles.  La configuration et les travaux ult√©rieurs peuvent √™tre effectu√©s √† la fois au niveau d'un seul bit et au niveau du port dans son ensemble (√©criture et lecture des 8 bits avec une seule commande).  Le contr√¥leur Mega328 utilis√© dans les exemples a 3 ports: B, C et D. Dans l'√©tat initial, du point de vue de la biblioth√®que, les d√©charges de tous les ports sont neutres.  Cela signifie que pour leur activation, il est n√©cessaire d'indiquer le mode de leur utilisation.  En cas de tentative d'acc√®s √† un port non activ√©, le programme g√©n√©rera une erreur de compilation.  Ceci est fait afin d'√©liminer les conflits possibles lors de l'attribution de fonctions alternatives.  Pour basculer les ports en mode d'entr√©e / sortie, utilisez les commandes <em>Mode</em> pour d√©finir le mode mono-bit et <em>Direction</em> pour d√©finir le mode de tous les bits de port avec une seule commande.  Du point de vue de la programmation, tous les ports sont identiques et leur comportement est d√©crit par une classe. </p><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT;<span class="hljs-comment"><span class="hljs-comment">// 0   B    m.PortC.Direction(0xFF);//       m.PortB.Activate(); //   m.PortC.Activate(); //  C //   m.PortB[0].Set(); //  0   B  1 m.PortB[0].Clear();//  0   B  0 m.PortB[0].Toggle();//  0   B   m.PortC.Write(0b11000000);// 6  7        var rr = m.REG(); //     rr.Load(0xC0); m.PortC.Write(rr);//      rr var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  L'exemple ci-dessus montre comment organiser la sortie des donn√©es via les ports.  Ici, le travail avec le port B s'effectue au niveau d'une cat√©gorie et avec le port C au niveau du port dans son ensemble.  Faites attention √† la commande d'activation <em>Activate ()</em> .  Son but est de g√©n√©rer dans le code de sortie une s√©quence de commandes d'initialisation de p√©riph√©rique conform√©ment aux propri√©t√©s pr√©c√©demment d√©finies.  Ainsi, la commande <em>Activate ()</em> utilise toujours l'ensemble de param√®tres d√©finis qui est en cours au moment de l'ex√©cution.  Prenons un exemple de lecture de donn√©es √† partir d'un port. </p><br><pre> <code class="cs hljs"> m.PortB.Activate(); <span class="hljs-comment"><span class="hljs-comment">//  B m.PortC.Activate(); //  C Bit dd = m.BIT(); //     Register rr = m.REG(); //     m.PortB[0].Read(dd); //  0   B m.PortC.Read(rr);//      rr var t = AVRASM.Text(m);</span></span></code> </pre> <br><p>  Dans cet exemple, un nouveau type de donn√©es <em>Bit</em> est apparu.  L'analogue le plus proche de ce type dans les langues de haut niveau est le type <em>bool</em> .  Le type de donn√©es <em>Bit</em> est utilis√© pour stocker un seul bit d'information et permet √† sa valeur d'√™tre utilis√©e comme condition dans les op√©rations de branchement.  Afin d'√©conomiser de la m√©moire, les variables de bits pendant le stockage sont combin√©es en blocs de telle mani√®re qu'un registre RON est utilis√© pour stocker 8 variables de type <em>Bit</em> .  En plus du type d√©crit, la biblioth√®que contient deux autres types de donn√©es binaires: <em>Pin</em> , qui a la m√™me fonctionnalit√© que Bit, mais utilise des registres IO et <em>Mbit</em> pour stocker les variables binaires dans la m√©moire RAM.  Voyons comment utiliser les variables de bits pour organiser les branches </p><br><pre> <code class="cs hljs">m.IF(m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>], () =&gt; AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">",   = 1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = m.BIT(); b.Set(); m.IF(b, () =&gt; AVRASM.Comment(<span class="hljs-string"><span class="hljs-string">",   b "</span></span>));</code> </pre> <br><p>  La premi√®re ligne v√©rifie l'√©tat du port d'entr√©e, et si √† l'entr√©e 1, le code du bloc conditionnel est ex√©cut√©.  La derni√®re ligne contient un exemple o√π une variable de type <em>Bit</em> est utilis√©e comme condition de branchement. </p><br><p>  Le prochain p√©riph√©rique commun et souvent utilis√© peut √™tre consid√©r√© comme un compteur / temporisateur mat√©riel.  Dans les microcontr√¥leurs AVR, cet appareil a un large √©ventail de fonctions et, selon le r√©glage, peut √™tre utilis√© pour g√©n√©rer un retard, g√©n√©rer un m√©andre avec une fr√©quence programmable, mesurer la fr√©quence d'un signal externe, et aussi comme modulateur PWM multimode.  Contrairement aux ports d'E / S, chacun des temporisateurs Mega328 poss√®de un ensemble unique de fonctionnalit√©s.  Par cons√©quent, chaque temporisateur est d√©crit par une classe distincte. </p><br><p>  Examinons-les plus en d√©tail.  En tant que source de signal de chaque temporisateur, un signal externe et l'horloge interne du processeur peuvent √™tre utilis√©s.  Les param√®tres mat√©riels du microcontr√¥leur vous permettent de configurer l'utilisation de la fr√©quence compl√®te pour les p√©riph√©riques, ou d'activer le s√©parateur unique pour tous les p√©riph√©riques par 8. √âtant donn√© que le microcontr√¥leur permet un fonctionnement dans une large plage de fr√©quences, le calcul correct des valeurs du diviseur de minuterie pour le retard requis pendant le cadencement interne n√©cessite de sp√©cifier la fr√©quence du processeur et le mode pr√©-√©chelle.  Ainsi, la section des param√®tres du minuteur prend la forme suivante </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   m.CKDIV8 = false; //     //    Timer1 m.Timer1.Clock = eTimerClockSource.CLK256; //   m.Timer1.OCRA = (ushort)((0.5 * m.FCLK) / 256); //    A m.Timer1.Mode = eWaveFormMode.CTC_OCRA; //    m.Timer1.Activate(); //    Timer1</span></span></code> </pre> <br><p>  De toute √©vidence, le r√©glage de la minuterie n√©cessite d'√©tudier la documentation du fabricant pour s√©lectionner le mode correct et comprendre l'objectif de divers param√®tres, mais l'utilisation de la biblioth√®que rend le travail avec l'appareil plus facile et plus compr√©hensible, tout en conservant la possibilit√© d'utiliser tous les modes de l'appareil. </p><br><p>  Maintenant, je sugg√®re une petite distraction de la description de l'utilisation de p√©riph√©riques sp√©cifiques et avant de continuer, discuter du probl√®me du fonctionnement asynchrone.  Le principal avantage des p√©riph√©riques est qu'ils sont capables d'ex√©cuter certaines fonctions sans utiliser les ressources du processeur.  La complexit√© peut survenir dans l'organisation de l'interaction entre le programme et le p√©riph√©rique, car les √©v√©nements qui se produisent pendant le fonctionnement du p√©riph√©rique sont asynchrones par rapport au flux d'ex√©cution de code dans la CPU.  Les m√©thodes d'interaction synchrone, dans lesquelles le programme contient des cycles pour attendre l'√©tat du p√©riph√©rique souhait√©, annulent presque tous les avantages de la p√©riph√©rie en tant que p√©riph√©riques ind√©pendants.  Le mode d'interruption est plus efficace et pr√©f√©r√©.  Dans ce mode, le processeur ex√©cute en continu le code du thread principal et, lorsque l'√©v√©nement se produit, bascule le thread d'ex√©cution sur son gestionnaire.  √Ä la fin du traitement, le contr√¥le revient au thread principal.  Les avantages de cette approche sont √©vidents, mais son utilisation peut √™tre compliqu√©e par la complexit√© de la configuration.  En assembleur, pour utiliser une interruption, vous devez: </p><br><ul><li>  d√©finir l'adresse correcte dans la table d'interruption, </li><li>  configurer l'appareil lui-m√™me pour fonctionner avec des interruptions, </li><li>  D√©crire la fonction de gestion des interruptions </li><li>  pr√©voir la conservation de tous les registres et drapeaux utilis√©s afin que l'interruption n'affecte pas la progression du thread principal </li><li>  activer les interruptions globales. </li></ul><br><p>  Pour simplifier la programmation du travail gr√¢ce aux interruptions, les classes de description des p√©riph√©riques de la biblioth√®que contiennent les propri√©t√©s d'un gestionnaire d'√©v√©nements.  Dans le m√™me temps, pour organiser le travail avec un p√©riph√©rique via des interruptions, il vous suffit de d√©crire le code de traitement de l'√©v√©nement requis, et la biblioth√®que effectuera toutes les autres configurations par elle-m√™me.  Revenons au r√©glage du temporisateur et compl√©tons-le par la d√©finition du code qui doit √™tre ex√©cut√© lorsque les seuils de comparaison des canaux de comparaison du temporisateur sont atteints.  Supposons que nous voulons que lorsque les seuils des canaux de comparaison sont d√©clench√©s, certains bits des ports d'E / S soient r√©initialis√©s en cas de d√©bordement.  En d'autres termes, nous voulons impl√©menter √† l'aide d'un temporisateur la fonction de g√©n√©ration d'un signal PWM √† des ports arbitraires s√©lectionn√©s avec un rapport cyclique d√©termin√© par les valeurs <em>OCRA</em> pour le premier et <em>OCRB</em> pour le deuxi√®me canal.  Voyons √† quoi ressemblera le code dans ce cas. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; bit1.Mode = ePinMode.OUT; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; bit2.Mode = ePinMode.OUT; m.PortB.Activate(); <span class="hljs-comment"><span class="hljs-comment">//  0  1   B   //     m.Timer0.Clock = eTimerClockSource.CLK; m.Timer0.OCRA = 50; m.Timer0.OCRB = 170; m.Timer0.Mode = eWaveFormMode.PWMPC_TOP8; //   m.Timer0.OnCompareA = () =&gt; bit1.Set(); m.Timer0.OnCompareB = () =&gt;bit2.Set(); m.Timer0.OnOverflow = () =&gt; m.PortB.Write(0); m.Timer0.Activate(); m.EnableInterrupt(); //  //   m.LOOP(m.TempH, (r, l) =&gt; m.GO(l), (r) =&gt; { });</span></span></code> </pre> <br><p>  La partie concernant le r√©glage des modes de temporisation a √©t√© examin√©e plus t√¥t, alors passons tout de suite aux gestionnaires d'interruption.  Dans l'exemple, trois gestionnaires sont utilis√©s pour impl√©menter deux canaux PWM √† l'aide d'un seul temporisateur.  Le code des gestionnaires est assez √©vident, mais la question peut se poser de savoir comment la sauvegarde d'√©tat mentionn√©e pr√©c√©demment est impl√©ment√©e de sorte que l'appel d'interruption n'affecte pas la logique du thread principal.  La solution, dans laquelle tous les registres et drapeaux sont enregistr√©s, semble clairement redondante, par cons√©quent, la biblioth√®que analyse l'utilisation des ressources dans l'interruption et n'√©conomise que le minimum n√©cessaire.  La boucle principale vide confirme l'id√©e que la t√¢che de g√©n√©rer en continu plusieurs signaux PWM fonctionne sans la participation du programme principal. </p><br><p>  Il convient de noter que la biblioth√®que impl√©mente une approche unifi√©e pour travailler avec les interruptions pour toutes les classes de description des p√©riph√©riques.  Cela simplifie la programmation et r√©duit les erreurs. </p><br><p>  Nous allons continuer √† √©tudier le travail avec les interruptions et consid√©rer une situation dans laquelle le fait de cliquer sur les boutons attach√©s aux ports d'entr√©e devrait provoquer certaines actions de la part du programme.  Dans le processeur que nous consid√©rons, il existe deux fa√ßons de g√©n√©rer des interruptions lorsque l'√©tat des ports d'entr√©e change.  Le plus avanc√© est l'utilisation du mode d'interruption externe.  Dans ce cas, nous pouvons g√©n√©rer des interruptions distinctes pour chacune des conclusions et configurer la r√©action uniquement √† un √©v√©nement sp√©cifique (front, r√©cession, niveau).  Malheureusement, il n'y en a que deux dans notre cristal.  Une autre m√©thode vous permet de contr√¥ler au moyen d'interruptions l'un des bits du port d'entr√©e, mais le traitement est plus compliqu√© en raison du fait que l'√©v√©nement se produit au niveau du port lorsque le signal d'entr√©e de l'un des bits configur√©s change, et une clarification suppl√©mentaire de la cause de l'interruption doit √™tre effectu√©e au niveau de l'algorithme par le logiciel. . </p><br><p>  A titre d'illustration, nous allons essayer de r√©soudre le probl√®me du contr√¥le de l'√©tat de la sortie du port √† l'aide de deux boutons.  L'un d'eux devrait d√©finir la valeur du port indiqu√© par nous √† 1, et l'autre r√©initialiser.  Puisqu'il n'y a que deux boutons, nous profiterons de l'occasion pour utiliser des interruptions externes. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortD[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0x0C</span></span>); <span class="hljs-comment"><span class="hljs-comment">// pull-up   m.INT0.Mode = eExtIntMode.Falling; //  INT0  . m.INT0.OnChange = () =&gt; m.PortD[0].Set(); //      1 m.INT1.Mode = eExtIntMode.Falling; //  INT1  . m.INT1.OnChange = () =&gt; m.PortD[0].Clear(); //     //  m.INT0.Activate(); m.INT1.Activate(); m.PortD.Activate(); m.EnableInterrupt(); //   //  m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r, l) =&gt; { });</span></span></code> </pre> <br><p>  L'utilisation d'interruptions externes nous a permis de r√©soudre notre probl√®me aussi simplement et clairement que possible. </p><br><p>  La gestion des ports externes par programmation n'est pas la seule fa√ßon possible.  En particulier, les temporisateurs ont un r√©glage qui leur permet de contr√¥ler directement la sortie du microcontr√¥leur.  Pour ce faire, dans le r√©glage de la minuterie, vous devez sp√©cifier le mode de contr√¥le de sortie </p><br><pre> <code class="cs hljs">m.Timer0.CompareModeA = eCompareMatchMode.Set;</code> </pre> <br><p>  Apr√®s avoir activ√© le temporisateur, le 6e bit du port D recevra une fonction alternative et sera contr√¥l√© par un temporisateur.  Ainsi, nous sommes en mesure de g√©n√©rer un signal PWM √† la sortie du processeur uniquement au niveau mat√©riel, en utilisant un logiciel uniquement pour d√©finir les param√®tres du signal.  En m√™me temps, si nous essayons d'utiliser les outils de biblioth√®que pour nous tourner vers le port occup√© comme port d'entr√©e / sortie, nous obtiendrons une erreur au niveau de la compilation. </p><br><p>  Le dernier appareil que nous examinerons dans cette partie de l'article sera le port s√©rie USART.  La fonctionnalit√© de cet appareil est tr√®s large, mais jusqu'√† pr√©sent, nous n'aborderons que l'un des cas d'utilisation les plus courants pour cet appareil. </p><br><p>  Le cas d'utilisation le plus courant pour ce port est de connecter un terminal s√©rie aux informations textuelles d'entr√©e / sortie.  La partie du code concernant les param√®tres de port dans ce cas peut ressembler √† ceci </p><br><pre> <code class="cs hljs">m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   m.CKDIV8 = false; //     m.Usart.Mode = eUartMode.UART; //    UART m.Usart.Baudrate = 9600; //   9600  m.Usart.FrameFormat = eUartFrame.U8N1; //   8N1</span></span></code> </pre> <br><p>  Les param√®tres sp√©cifi√©s co√Øncident avec les param√®tres par d√©faut de l'USART dans la biblioth√®que, par cons√©quent, ils peuvent √™tre partiellement ou compl√®tement ignor√©s dans le texte du programme. </p><br><p>  Prenons un petit exemple dans lequel nous envoyons du texte statique au terminal.  Afin de ne pas gonfler le code, nous nous limitons √† la sortie vers le terminal du classique "Hello world!"  au d√©but du programme. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = m.ROMPTR(); <span class="hljs-comment"><span class="hljs-comment">//      m.CKDIV8 = false; m.FCLK = 16000000; //      m.Usart.Mode = eUartMode.UART; m.Usart.Baudrate = 9600; m.Usart.FrameFormat = eUartFrame.U8N1; //         m.Usart.OnTransmitComplete = () =&gt; { ptr.MLoadInc(m.TempL); m.IF(m.TempL!=0,()=&gt;m.Usart.Transmit(m.TempL)); }; m.Usart.Activate(); m.EnableInterrupt(); //   var str = Const.String("Hello world!"); //   ptr.Load(str); //     ptr.MloadInc(m.TempL); //    m.Usart.Transmit(m.TempL); //   . m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r,l) =&gt; { });</span></span></code> </pre> <br><p>  Dans ce programme, √† partir du nouveau, d√©clarant la cha√Æne constante <em>str</em> .  La biblioth√®que place toutes les variables constantes dans la m√©moire du programme, par cons√©quent, pour travailler avec elles, vous devez utiliser le pointeur <em>ROMPtr</em> .  La sortie de donn√©es vers le terminal commence par la sortie du premier caract√®re de la s√©quence de cha√Ænes, apr√®s quoi la commande passe imm√©diatement √† la boucle principale, sans attendre la fin de la sortie.  L'ach√®vement du processus de transfert d'octets provoque une interruption dans le gestionnaire dont le caract√®re suivant de la ligne est lu.  Si le caract√®re n'est pas √©gal √† 0 (la biblioth√®que utilise le format termin√© par z√©ro pour stocker les cha√Ænes), ce caract√®re est envoy√© au port d'interface s√©rie.  Si nous atteignons la fin de la ligne, le caract√®re n'est pas envoy√© au port et le cycle d'envoi se termine. </p><br><p>  L'inconv√©nient de cette approche est l'algorithme de traitement d'interruption fixe.  Il ne permettra pas d'utiliser le port s√©rie autrement que pour sortir des cha√Ænes statiques.  Un autre inconv√©nient de cette mise en ≈ìuvre est l'absence de m√©canisme de surveillance de l'occupation des ports.  Si vous essayez d'envoyer plusieurs lignes s√©quentiellement, il peut y avoir une situation o√π la transmission des lignes pr√©c√©dentes sera interrompue ou les lignes seront m√©lang√©es. </p><br><p>  Nous verrons dans la prochaine partie de l'article des m√©thodes plus efficaces pour r√©soudre ce probl√®me et d'autres, ainsi que travailler avec d'autres p√©riph√©riques.  Dans ce document, nous examinerons de plus pr√®s la programmation √† l'aide de la classe sp√©ciale de gestion des t√¢ches <em>parall√®les</em> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463627/">https://habr.com/ru/post/fr463627/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463613/index.html">Les images Docker peuvent √©galement √™tre construites dans werf en utilisant le Dockerfile habituel</a></li>
<li><a href="../fr463617/index.html">Caract√©ristiques du test du MMO mobile</a></li>
<li><a href="../fr463619/index.html">Travailler √† distance: notre exp√©rience</a></li>
<li><a href="../fr463623/index.html">Nous sommes s√©lectionn√©s dans la jungle des tests: nous construisons √† courte distance des luminaires aux tests</a></li>
<li><a href="../fr463625/index.html">Surveillance du r√©seau et d√©tection de l'activit√© r√©seau anormale √† l'aide des solutions Flowmon Networks</a></li>
<li><a href="../fr463629/index.html">Configuration de NextCloud + ONLYOFFICE sur le m√™me serveur √† l'aide de Docker</a></li>
<li><a href="../fr463631/index.html">Dialogues sur les lettres</a></li>
<li><a href="../fr463637/index.html">Tester votre infrastructure en tant que code avec Pulumi. 2e partie</a></li>
<li><a href="../fr463639/index.html">Eh bien Apple BLEee</a></li>
<li><a href="../fr463647/index.html">Vid√©os et rapports avec SmartMail Meetup: Frontend</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>