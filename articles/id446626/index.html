<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤›ğŸ½ ğŸ’› ğŸ§’ğŸ¿ Kaspersky Mobile Talks # 1. Multi-modularitas ğŸ“¢ ğŸ‘› â˜ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada akhir Februari, kami meluncurkan format baru untuk pertemuan pengembang Android dari Kaspersky Mobile Talks . Perbedaan utama dari aksi unjuk ras...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kaspersky Mobile Talks # 1. Multi-modularitas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/kaspersky/blog/446626/"><p>  Pada akhir Februari, kami meluncurkan format baru untuk pertemuan pengembang Android dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kaspersky Mobile Talks</a> .  Perbedaan utama dari aksi unjuk rasa biasa adalah bahwa alih-alih ratusan pendengar dan presentasi yang indah, pengembang "berpengalaman" berkumpul pada beberapa topik yang berbeda untuk membahas hanya satu topik: bagaimana mereka mengimplementasikan multi-modularitas dalam aplikasi mereka, masalah apa yang mereka hadapi, dan bagaimana mereka menyelesaikannya. </p><br><p><img src="https://habrastorage.org/webt/i5/da/5v/i5da5vzrshhino9ayx-a5e6ikkc.jpeg"></p><a name="habracut"></a><br><h2 id="soderzhanie">  Isi </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Latar belakang</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mediator di HeadHunter.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alexander Blinov</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modul Domain Tinkoff</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vladimir Kokhanov, Alexander Zhukov</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis dampak di Avito.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evgeny Krivobokov, Mikhail Yudin</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seperti di Tinkoff, mereka mengurangi waktu perakitan untuk PR dari empat puluh menit menjadi empat.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vladimir Kokhanov</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan yang bermanfaat</a> </li></ol><br><a name="history"></a><br><p>  Sebelum melanjutkan ke konten langsung pertemuan di kantor Lab Kaspersky, mari kita ingat dari mana mod untuk membagi aplikasi menjadi modul berasal (selanjutnya, modul dipahami sebagai modul Gradle, bukan Belati, kecuali dinyatakan lain). </p><br><p>  Topik multi-modularitas telah ada di benak komunitas Android selama bertahun-tahun.  Salah satu yang mendasar dapat dianggap sebagai laporan oleh Denis Neklyudov di St. Petersburg "Mobius" tahun lalu.  Dia mengusulkan membagi aplikasi monolitik, yang telah lama berhenti menjadi klien tipis, menjadi modul untuk meningkatkan kecepatan membangun. <br>  Tautan ke laporan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video</a> </p><br><p>  Lalu ada laporan oleh Vladimir Tagakov dari Yandex.Maps tentang menghubungkan modul menggunakan Dagger.  Dengan demikian, mereka memecahkan masalah mengalokasikan satu komponen kartu untuk digunakan kembali di banyak aplikasi Yandex lainnya. <br>  Tautan ke laporan: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video</a> </p><br><p>  Kaspersky Lab juga tidak lepas dari tren: pada bulan September, Evgeni Matsyuk menulis artikel tentang cara menghubungkan modul menggunakan Belati dan pada saat yang sama membangun arsitektur multi-modul secara horizontal, tidak lupa untuk mengikuti prinsip-prinsip Arsitektur Bersih secara vertikal. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tautan ke artikel</a> </p><br><p>  Dan pada musim dingin Mobius ada dua laporan sekaligus.  Pertama, Alexander Blinov berbicara tentang multi-modularitas dalam aplikasi HeadHunter menggunakan Tusuk Gigi sebagai DI, dan tepat setelahnya Artem Zinnatulin berbicara tentang rasa sakit dari 800+ modul di Lyft.  Sasha mulai berbicara tentang multi-modularitas, sebagai cara untuk meningkatkan arsitektur aplikasi, dan tidak hanya mempercepat perakitan. <br>  Blinov Report: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video</a> <br>  Laporan Zinnatulin: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Video</a> </p><br><p> Mengapa saya memulai artikel dengan retrospektif?  Pertama, ini akan membantu Anda mempelajari topik dengan lebih baik jika Anda membaca tentang multi-modularitas untuk pertama kalinya.  Dan kedua, pidato pertama di pertemuan kami dimulai dengan presentasi mini oleh Alexey Kalaida dari perusahaan Stream, yang menunjukkan bagaimana mereka membagi aplikasi mereka ke dalam modul berdasarkan artikel Zhenya (dan beberapa poin bagi saya mirip dengan pendekatan Vladimir). </p><br><p>  Fitur utama dari pendekatan ini mengikat ke UI: setiap modul terhubung sebagai layar terpisah - sebuah fragmen di mana dependensi ditransfer dari modul aplikasi utama, termasuk FragmentManager.  Pertama, kolega mencoba menerapkan multi-modularitas melalui injector proxy, yang diusulkan Zhenya dalam artikel tersebut.  Tetapi pendekatan ini tampak luar biasa: ada masalah ketika satu fitur bergantung pada yang lain, yang, pada gilirannya, tergantung pada yang ketiga - kami harus menulis injector proxy untuk setiap modul fitur.  Pendekatan yang didasarkan pada komponen UI memungkinkan Anda untuk tidak menulis injektor, memungkinkan dependensi pada tingkat ketergantungan fragmen target. </p><br><p>  Batasan utama yang dimiliki oleh implementasi ini: fitur harus berupa fragmen (atau tampilan lain);  Kehadiran fragmen bersarang, yang mengarah ke pelat ketel besar.  Jika suatu fitur mengimplementasikan fitur lain, itu harus ditambahkan ke peta ketergantungan, yang diperiksa oleh Belati ketika mengompilasinya.  Ketika ada banyak fitur seperti itu, kesulitan muncul pada saat menghubungkan grafik ketergantungan. </p><br><a name="hh"></a><br><p>  Setelah laporan Alexey, Alexander Blinov naik ke lantai.  Menurutnya, implementasi terkait dengan UI akan cocok untuk wadah DI di Flutter.  Kemudian diskusi beralih ke diskusi multi-modul di HeadHunter.  Tujuan dari pembagian mereka ke dalam modul adalah kemungkinan isolasi fitur dan meningkatkan kecepatan perakitan. </p><br><p>  Sebelum membaginya menjadi modul, penting untuk mempersiapkan.  Pertama, Anda bisa membuat grafik dependensi - misalnya, menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat tersebut</a> .  Ini akan membantu mengisolasi komponen dengan jumlah dependensi minimum dan menyingkirkan yang tidak perlu (chop).  Hanya setelah ini, komponen yang paling sedikit terhubung dapat dipilih menjadi modul. </p><br><p>  Alexander mengingat hal-hal utama yang ia bicarakan dengan lebih terperinci di Mobius.  Salah satu tugas kompleks yang harus dipertimbangkan arsitektur adalah menggunakan kembali satu modul dari berbagai tempat dalam aplikasi.  Dalam contoh dengan aplikasi jam, ini adalah modul resume, yang harus dapat diakses baik ke modul daftar lowongan (VacanciesList), ketika pengguna pergi ke resume yang ia kirimkan untuk lowongan ini, dan ke modul respon negatif (Negosiasi).  Untuk lebih jelasnya, saya menggambar ulang gambar yang Sasha gambarkan di flipchart. </p><br><p><img src="https://habrastorage.org/webt/e8/yv/jj/e8yvjjob9amuir_xu9693i2qisk.png"></p><br><p>  Setiap modul berisi dua entitas utama: Dependensi - dependensi yang dibutuhkan modul ini, dan API - metode yang disediakan modul ke modul lainnya.  Komunikasi antara modul dilakukan oleh mediator, yang merupakan struktur datar di modul aplikasi utama.  Setiap fitur memiliki satu pilihan.  Mediator sendiri termasuk dalam MediatorManager tertentu dalam modul aplikasi proyek.  Dalam kode, tampilannya seperti ini: </p><br><pre><code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> MediatorManager { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> chatMediator: ChatMediator <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> lazy { ChatMediator() } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someMediator: ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TechSupportMediator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SuppportComponent { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> deps = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : SuppportComponentDependencies { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> getInternalChat{ MediatorManager.rootMediator.api.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openInternalChat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } } } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuppportComponent</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dependencies) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> api: SupportComponentApi = ... <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { SupportDI.keeper.installComponent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuppportComponentDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getSmth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { scopeHolder.destroyCoordinator &lt; -ref count } }</code> </pre> <br><p>  Alexander berjanji akan segera menerbitkan plug-in untuk membuat modul di Android Studio, yang digunakan untuk menghilangkan copy-paste di perusahaan mereka, serta contoh proyek multi-modul konsol. </p><br><p>  Beberapa fakta lagi tentang hasil pemisahan modul aplikasi hh saat ini: </p><br><ul><li>  ~ 83 modul fitur. </li><li>  Untuk melakukan uji A / B, fitur dapat diganti seluruhnya oleh modul fitur di tingkat mediator. </li><li>  Grafik Pemindaian Gradle menunjukkan bahwa setelah kompilasi modul secara paralel, proses dexing yang agak lama terjadi (dalam hal ini, dua: untuk pencari kerja dan pemberi kerja): <br><img src="https://habrastorage.org/webt/4a/wj/xz/4awjxzwf4ohdfdayj7xt591ekf0.png"></li></ul><br><a name="tinkoff"></a><br><p>  Yang berikut mengambil lantai dari Alexander dan Vladimir dari Tinkoff: <br>  Skema arsitektur multi-modul mereka terlihat seperti ini: <br><img src="https://habrastorage.org/webt/4x/p-/t0/4xp-t0r5xgdc2rhssvrzv0zqaco.png"></p><br><p>  Modul dibagi menjadi dua kategori: modul fitur dan modul domain. <br>  Modul fitur berisi logika bisnis dan fitur UI.  Mereka bergantung pada modul domain, tetapi tidak dapat saling bergantung. </p><br><p>  Modul domain berisi kode untuk bekerja dengan sumber data, yaitu, beberapa model, DAO (untuk bekerja dengan database), API (untuk bekerja dengan jaringan) dan repositori (menggabungkan karya API dan DAO).  Modul-domain, tidak seperti modul-fitur, dapat saling bergantung. </p><br><p>  Koneksi antara domain dan modul fitur terjadi sepenuhnya di dalam modul fitur (yaitu, dalam terminologi hh, Dependecies dan dependensi API dari modul Domain sepenuhnya diselesaikan dalam modul fitur yang menggunakannya, tanpa menggunakan entitas tambahan seperti mediator). </p><br><p>  Ini diikuti oleh serangkaian pertanyaan, yang saya akan taruh hampir tidak berubah di sini dalam format "tanya-jawab": </p><br><blockquote>  - Bagaimana otorisasi dilakukan?  Bagaimana Anda menyeretnya ke modul fitur? <br>  - Fitur dengan kami tidak bergantung pada otorisasi, karena hampir semua tindakan aplikasi terjadi di zona resmi. <br><br>  - Bagaimana cara melacak dan membersihkan komponen yang tidak digunakan? <br>  - Kami memiliki entitas seperti InjectorRefCount (diimplementasikan melalui WeakHashMap), yang ketika menghapus Aktivitas terakhir (atau fragmen) menggunakan komponen ini, menghapusnya. <br><br>  - Bagaimana mengukur pemindaian dan pembersihan waktu "bersih"?  Jika cache diaktifkan, pemindaian yang agak kotor diperoleh. <br>  - Anda dapat menonaktifkan Gradle Cache (org.gradle.caching di gradle.properties). <br><br>  - Bagaimana menjalankan tes Unit dari semua modul dalam mode debug?  Jika Anda menjalankan uji gradle saja, tes dari semua rasa dan buildType ditarik. <br>  (Pertanyaan ini memicu diskusi banyak peserta dalam pertemuan itu.) <br>  - Anda dapat mencoba menjalankan testDebug. <br>  - Kemudian modul yang tidak ada konfigurasi debug tidak akan diperketat.  Mulai terlalu banyak atau terlalu sedikit. <br>  - Anda dapat menulis tugas Gradle, yang akan mengesampingkan testDebug untuk modul tersebut, atau membuat konfigurasi debug palsu di modul build.gradle. <br>  - Anda dapat menerapkan pendekatan ini seperti ini: </blockquote><br><pre> <code class="plaintext hljs">withAndroidPlugin(project) { _, applicationExtension -&gt; applicationExtension.testVariants.all { testVariant -&gt; val testVariantSuffix = testVariant.testedVariant.name.capitalize() } } val task = project.tasks.register &lt; SomeTask &gt; ( "doSomeTask", SomeTask::class.java ) { task.dependsOn("${project.path}:taskName$testVariantSuffix") }</code> </pre> <br><p><img src="https://habrastorage.org/webt/oy/gc/68/oygc68_brbzgxgzfh_wztse_na8.jpeg"></p><br><a name="avito"></a><br><p>  Presentasi improvisasi berikutnya dibuat oleh Evgeny Krivobokov dan Mikhail Yudin dari Avito. <br>  Mereka menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mindmap</a> untuk memvisualisasikan cerita mereka. </p><br><p>  Sekarang proyek perusahaan memiliki&gt; 300 modul, dengan 97% basis kode ditulis di Kotlin.  Tujuan utama pengelompokan ke dalam modul adalah untuk mempercepat perakitan proyek.  Penguraian modul terjadi secara bertahap, dengan bagian kode yang paling tidak tergantung dialokasikan ke modul.  Untuk melakukan ini, alat dikembangkan untuk menandai ketergantungan kode sumber dalam grafik untuk analisis dampak ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">laporan tentang analisis dampak di Avito</a> ). </p><br><p>  Dengan menggunakan alat ini, Anda dapat menandai modul fitur sebagai final sehingga modul lain tidak dapat bergantung padanya.  Properti ini akan diperiksa selama analisis dampak dan memberikan penunjukan dependensi dan perjanjian eksplisit dengan tim yang bertanggung jawab atas modul.  Berdasarkan grafik yang dikonstruksi, distribusi perubahan juga diperiksa untuk menjalankan tes unit untuk kode yang terpengaruh. </p><br><p>  Perusahaan menggunakan repositori mono, tetapi hanya untuk sumber Android.  Kode platform lain hidup terpisah. </p><br><p>  Gradle digunakan untuk membangun proyek (meskipun rekan kerja sudah memikirkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pembangun</a> seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buck</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bazel</a> yang lebih cocok untuk proyek multi-modul).  Mereka sudah mencoba Kotlin DSL, dan kemudian kembali ke Groovy dalam skrip Gradle, karena tidak nyaman untuk mendukung berbagai versi Kotlin di Gradle dan dalam proyek - logika umum dimasukkan ke dalam plugin. </p><br><p>  Gradle dapat memparalelkan tugas, cache, dan tidak mengkompilasi ulang dependensi biner jika ABI mereka tidak berubah, yang memastikan perakitan proyek multi-modul yang lebih cepat.  Untuk caching yang lebih efisien, Mainfraimer dan beberapa solusi yang ditulis sendiri digunakan: </p><br><ul><li>  Saat beralih dari cabang ke cabang, Git dapat meninggalkan folder kosong yang memecah caching ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Masalah tingkat # 2463</a> ).  Oleh karena itu, mereka dihapus secara manual menggunakan kait Git. </li><li>  Jika Anda tidak mengontrol lingkungan pada mesin pengembang, maka berbagai versi Android SDK dan parameter lainnya dapat menurunkan caching.  Selama pembangunan proyek, skrip membandingkan parameter lingkungan dengan yang diharapkan: jika versi atau parameter yang salah dipasang, versi tersebut akan turun. </li><li>  Analytics sedang mengaktifkan / menonaktifkan parameter dan lingkungan.  Ini untuk memonitor dan membantu pengembang. </li><li>  Kesalahan build juga dikirim ke analytics.  Masalah yang dikenal dan populer dimasukkan pada halaman khusus dengan solusi. </li></ul><br><p>  Semua ini membantu mencapai 15% cache miss pada CI dan 60-80% secara lokal. </p><br><p>  Kiat Gradle berikut juga dapat berguna jika sejumlah besar modul muncul di proyek Anda: </p><br><ul><li>  Menonaktifkan modul melalui flag IDE tidak nyaman, flag ini dapat diatur ulang.  Oleh karena itu, modul dinonaktifkan melalui settings.gradle. </li><li>  Di studio 3.3.1 ada kotak centang "Lewati pembuatan sumber di sinkronisasi Gradle jika proyek memiliki lebih dari 1 modul".  Secara default tidak aktif, lebih baik untuk mengaktifkannya. </li><li>  Dependensi terdaftar di buildSrc untuk digunakan kembali di semua modul.  Pilihan lain adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Plugins DSL</a> , tetapi Anda tidak dapat memasukkan aplikasi plugin ke file yang terpisah. </li></ul><br><a name="pr4"></a><br><p>  Pertemuan kami berakhir dengan Vladimir dari Tinkoff dengan judul clickbait laporan, <strong>"Cara Mengurangi</strong> Majelis <strong>pada PR dari 40 Menit menjadi Empat</strong> . <strong>"</strong>  Bahkan, kami berbicara tentang distribusi mulai dari plug-grade: membangun apk, tes, dan analisis statis. </p><br><p>  Awalnya, orang-orang di setiap permintaan tarik menjalankan analisis statis, langsung perakitan dan tes.  Proses ini memakan waktu 40 menit, dimana hanya Lint dan SonarQube yang mengambil 25 dan hanya turun 7% dari peluncuran. </p><br><p>  Dengan demikian, diputuskan untuk menempatkan peluncuran mereka di Ayub terpisah, yang berjalan sesuai jadwal setiap dua jam dan, jika terjadi kesalahan, mengirim pesan ke Slack. </p><br><p>  Situasi sebaliknya menggunakan Detect.  Itu jatuh hampir terus-menerus, itulah sebabnya itu dimasukkan ke dalam pemeriksaan pra-push pendahuluan. </p><br><p>  Jadi, hanya rakitan apk dan pengujian unit yang tetap dalam verifikasi permintaan tarik.  Tes mengkompilasi sumber sebelum berjalan, tetapi tidak mengumpulkan sumber daya.  Karena penggabungan sumber daya hampir selalu berhasil, perakitan apk itu sendiri juga ditinggalkan. </p><br><p>  Akibatnya, hanya peluncuran unit tes yang tetap pada permintaan tarik, yang memungkinkan kami untuk mencapai 4 menit yang ditunjukkan.  Build apk dilakukan dengan permintaan tarik merger di dev. </p><br><a name="end"></a><br><p>  Terlepas dari kenyataan bahwa pertemuan berlangsung hampir 4 jam, kami tidak punya waktu untuk membahas masalah pembakaran pengorganisasian navigasi dalam proyek multi-modul.  Mungkin ini adalah topik untuk Pembicaraan Seluler Kaspersky berikutnya.  Apalagi para peserta sangat menyukai formatnya.  Beri tahu kami apa yang ingin Anda bicarakan dalam survei atau di komentar. </p><br><p>  Dan akhirnya, tautan bermanfaat dari obrolan yang sama: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Definisi grafik konektivitas monolit</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aturan untuk menulis kode dalam jam dan utilitas untuk membantu mereka mendukung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mirakle - plugin untuk mentransfer build ke mainframe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hasil Survei Modularisasi Aplikasi Android</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446626/">https://habr.com/ru/post/id446626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446614/index.html">Sistem file virtual Linux: mengapa mereka diperlukan dan bagaimana cara kerjanya? Bagian 1</a></li>
<li><a href="../id446616/index.html">Bagaimana kami melakukan cloud FaaS di dalam Kubernetes dan menang di Tinkoff Hackathon</a></li>
<li><a href="../id446620/index.html">DataGrip 2019.1: dukungan untuk database baru, skrip inisialisasi, inspeksi baru dan banyak lagi</a></li>
<li><a href="../id446622/index.html">Berita di 11</a></li>
<li><a href="../id446624/index.html">Indeks dalam PostgreSQL - 6 (SP-GiST)</a></li>
<li><a href="../id446628/index.html">Beri lebih banyak HighLoad ++: mulai Senin di St. Petersburg</a></li>
<li><a href="../id446630/index.html">Bagaimana memilih printer 3D, atau mengapa Anda membutuhkan meja pemanas dan kamera tertutup</a></li>
<li><a href="../id446632/index.html">Dari Hukum ke Pengembangan Data Besar</a></li>
<li><a href="../id446634/index.html">Digest SDN - Enam Emulator Open Source</a></li>
<li><a href="../id446638/index.html">Cisco HyperFlex vs. pesaing: menguji kinerja</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>