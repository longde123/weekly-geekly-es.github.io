<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßî üéÉ ü§≤üèº Architecture de couche d'ex√©cution de t√¢che asynchrone üìá üë¥ üêè</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les applications mobiles des r√©seaux sociaux, l'utilisateur aime, √©crit un commentaire, puis parcourt le flux, d√©marre la vid√©o et remet le m√™me....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Architecture de couche d'ex√©cution de t√¢che asynchrone</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/437592/">  Dans les applications mobiles des r√©seaux sociaux, l'utilisateur aime, √©crit un commentaire, puis parcourt le flux, d√©marre la vid√©o et remet le m√™me.  Tout cela est rapide et presque simultan√©.  Si la mise en ≈ìuvre de la logique m√©tier de l'application est compl√®tement bloqu√©e, l'utilisateur ne pourra pas acc√©der √† la bande tant que les √©l√©ments similaires pour l'enregistrement avec des scell√©s n'auront pas √©t√© t√©l√©charg√©s.  Mais l'utilisateur n'attendra pas, par cons√©quent, dans la plupart des applications mobiles, les t√¢ches asynchrones fonctionnent, qui sont d√©marr√©es et termin√©es ind√©pendamment les unes des autres.  L'utilisateur effectue plusieurs t√¢ches en m√™me temps et ne se bloque pas.  Une t√¢che asynchrone d√©marre et s'ex√©cute tandis que l'utilisateur d√©marre la suivante. <br><br><img src="https://habrastorage.org/webt/on/8u/ys/on8uys9oib69dbqrfu4xfnnq-0u.png"><br><br>  En d√©chiffrant le rapport de <b>Stepan Goncharov</b> sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AppsConf,</a> nous aborderons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'</a> asynchronie: nous nous plongerons dans l'architecture des applications mobiles, discuterons de la raison pour laquelle nous devrions s√©parer une couche pour effectuer des t√¢ches asynchrones, nous analyserons les exigences et les solutions existantes, nous passerons en revue les avantages et les inconv√©nients, et envisagerons l'une des impl√©mentations de cette approche.  Nous apprenons √©galement comment g√©rer les t√¢ches asynchrones, pourquoi chaque t√¢che a son propre ID, quelles sont les strat√©gies d'ex√©cution et comment elles aident √† simplifier et acc√©l√©rer le d√©veloppement de l'application enti√®re. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/tBC5Zoxcgbk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <b>√Ä propos de l'orateur: Stepan Goncharov</b> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">stepango</a> ) travaille chez Grab - c'est comme Uber, mais en Asie du Sud-Est.  Il est impliqu√© dans le d√©veloppement Android depuis plus de 9 ans.  Int√©ress√© par Kotlin depuis 2014 et depuis 2016 - l'utilise dans la prod.  Organis√© par Kotlin User Group √† Singapour.  C'est l'une des raisons pour lesquelles tous les exemples de code seront sur Kotlin, et non pas parce que c'est √† la mode. <br><br>  Nous examinerons une approche pour concevoir les composants de votre application.  Il s'agit d'un guide d'action pour ceux qui souhaitent ajouter de nouveaux composants √† l'application, les concevoir facilement, puis les d√©velopper.  Les d√©veloppeurs iOS peuvent utiliser l'approche iOS.  L'approche s'applique √©galement √† d'autres plateformes.  Je m'int√©resse √† Kotlin depuis 2014, donc tous les exemples seront dans cette langue.  Mais ne vous inqui√©tez pas - vous pouvez √©crire la m√™me chose en Swift, Objective-C et dans d'autres langages. <br><br>  Commen√ßons par les probl√®mes et les inconv√©nients des <b>extensions r√©actives</b> .  Les probl√®mes sont typiques pour d'autres primitives asynchrones, donc nous disons RX - gardez √† l'esprit l'avenir et la promesse, et tout fonctionnera de la m√™me mani√®re. <br><br><h2>  Probl√®mes de r√©ception </h2><br>  <b>Seuil d'entr√©e √©lev√©</b> .  Le RX est assez complexe et volumineux - il compte 270 op√©rateurs, et il n'est pas facile d'apprendre √† toute l'√©quipe comment les utiliser correctement.  Nous ne discuterons pas de ce probl√®me - il d√©passe la port√©e du rapport. <br><br>  Dans RX, vous devez <b>g√©rer manuellement vos abonnements, ainsi que surveiller le cycle de vie de l'application</b> .  Si vous √™tes d√©j√† abonn√© √† Single ou Observable, vous <b>ne pouvez pas le comparer avec un autre SIngle</b> , car vous recevrez toujours un nouvel objet et il y aura toujours des abonnements diff√©rents pour l'ex√©cution.  <b>Dans RX, il n'y a aucun moyen de comparer les abonnements et les flux</b> . <br><br>  Nous essaierons de r√©soudre certains de ces probl√®mes.  Nous allons r√©soudre chaque probl√®me une fois, puis r√©utiliser le r√©sultat. <br><br><h2>  Probl√®me num√©ro 1: effectuer une t√¢che plus d'une fois </h2><br>  Un probl√®me courant dans le d√©veloppement est le travail inutile et la r√©p√©tition des m√™mes t√¢ches plus d'une fois.  Imaginez que nous ayons un formulaire pour entrer des donn√©es et un bouton d'enregistrement.  Lorsque vous appuyez sur, une demande est envoy√©e, mais si vous cliquez plusieurs fois pendant l'enregistrement du formulaire, plusieurs demandes identiques seront envoy√©es.  Nous avons donn√© le bouton pour tester l'AQ, ils ont appuy√© 40 fois en une seconde - nous avons re√ßu 40 demandes, parce que, par exemple, l'animation n'avait pas le temps de fonctionner. <br><br>  Comment r√©soudre le probl√®me?  Chaque d√©veloppeur a sa propre approche pr√©f√©r√©e pour r√©soudre: l'un collera un anti- <code>debounce</code> , l'autre bloquera le bouton au cas o√π par <code>clickable = false</code> .  Il n'y a pas d'approche g√©n√©rale, donc ces bogues appara√Ætront ou dispara√Ætront de notre application.  Nous ne r√©solvons le probl√®me que lorsque l'AQ nous dit: ¬´Oh, j'ai cliqu√© ici, et √ßa s'est cass√©¬ª! <br><br><h3>  Une solution √©volutive? </h3><br>  Pour √©viter de telles situations, nous encapsulerons RX ou un autre framework asynchrone - <b>nous ajouterons des ID √† toutes les op√©rations asynchrones</b> .  L'id√©e est simple - nous avons besoin d'un moyen de les comparer, car g√©n√©ralement cette m√©thode n'est pas dans les cadres.  Nous pouvons terminer la t√¢che, mais nous ne savons pas si elle est d√©j√† termin√©e ou non. <br><br>  Appelons notre wrapper ¬´Act¬ª - d'autres noms sont d√©j√† pris.  Pour ce faire, cr√©ez une petite <code>typealias</code> et une <code>interface</code> simple dans laquelle il n'y a qu'un seul champ: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">typealias</span></span> Id = String <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id }</code> </pre> <br>  C'est pratique et r√©duit l√©g√®rement la quantit√© de code.  Plus tard, si String ne l'aime pas, nous le remplacerons par autre chose.  Dans ce petit morceau de code, nous observons un fait amusant. <br><br><blockquote>  Les interfaces peuvent contenir des propri√©t√©s. </blockquote><br>  Pour les programmeurs qui viennent de Java, c'est inattendu.  Habituellement, ils ajoutent des m√©thodes <code>getId()</code> √† l'int√©rieur de l'interface, mais ce n'est pas la bonne solution, du point de vue de Kotlin. <br><br><h3>  Comment allons-nous concevoir? </h3><br>  Une petite digression.  Lors de la conception, j'adh√®re √† deux principes.  La premi√®re consiste √† <b>d√©composer les exigences des composants et leur mise en ≈ìuvre en petits morceaux</b> .  Cela permet un contr√¥le granulaire de l'√©criture de code.  Lorsque vous cr√©ez un gros composant et essayez de tout faire en m√™me temps, c'est mauvais.  Habituellement, ce composant ne fonctionne pas et vous commencez √† ins√©rer des b√©quilles, je vous invite donc √† √©crire par petites √©tapes contr√¥l√©es et √† en profiter.  Le deuxi√®me principe consiste <b>√† v√©rifier l'op√©rabilit√©</b> apr√®s chaque √©tape et √† <b>r√©p√©ter la proc√©dure</b> . <br><br><h3>  Pourquoi ne suffit-il pas d'une pi√®ce d'identit√©? </h3><br>  Revenons au probl√®me.  Nous avons fait le premier pas - nous avons ajout√© un identifiant, et tout √©tait simple - l'interface et le champ.  Cela ne nous a rien donn√©, car l'interface ne contient aucune impl√©mentation et ne fonctionne pas seule, mais vous permet de comparer les op√©rations. <br><br>  Ensuite, nous ajouterons des composants qui nous permettront d'utiliser l'interface et de comprendre que nous voulons ex√©cuter une sorte de demande une deuxi√®me fois lorsque cela n'est pas n√©cessaire.  La premi√®re chose que nous ferons est d' <b>introduire de nouvelles abstractions</b> . <br><br><h3>  Pr√©sentation de nouvelles abstractions: MapDisposable </h3><br>  Il est important de choisir le bon nom et l'abstraction familiers aux d√©veloppeurs qui travaillent dans votre base de code.  Puisque j'ai des exemples sur RX, nous utiliserons le concept RX et des noms similaires √† ceux utilis√©s par les d√©veloppeurs de la biblioth√®que.  Nous pouvons donc facilement expliquer √† nos coll√®gues ce qu'ils ont fait, pourquoi et comment cela devrait fonctionner.  Pour s√©lectionner un nom, consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation CompositeDiposable</a> . <br><br>  Cr√©ons une petite interface MapDisposable qui <b>contient des informations</b> sur les t√¢ches en cours et les <b>appels dispose () lors de la suppression</b> .  Je ne donnerai pas l'impl√©mentation, vous pouvez voir toutes les sources <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sur mon GitHub</a> . <br><br>  Nous appelons MapDisposable de cette fa√ßon car le composant fonctionnera comme une Map, mais il aura des propri√©t√©s CompositeDiposable. <br><br><h3>  Pr√©sentation de nouvelles abstractions: ActExecutor </h3><br>  Le composant abstrait suivant est <b>ActExecutor.</b>  Il d√©marre ou ne d√©marre pas de nouvelles t√¢ches, d√©pend de MapDisposable et d√©l√®gue la gestion des erreurs.  Comment choisir un nom - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voir la documentation</a> . <br><br>  Prenez l'analogie la plus proche du JDK.  Il a un ex√©cuteur dans lequel vous pouvez passer le fil et faire quelque chose.  Il me semble que c'est un composant sympa et bien con√ßu, prenons-le comme base. <br><br>  Nous cr√©ons ActExecutor et une interface simple pour cela, en adh√©rant au principe de petites √©tapes simples.  Le nom lui-m√™me dit que c'est un composant auquel nous transmettons quelque chose et qu'il commence √† faire quelque chose.  ActExecutor a une m√©thode dans laquelle nous passons <code>Act</code> et, au cas o√π, g√©rons les erreurs, car sans elles, il n'y a aucun moyen. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> = ::logError) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapDisposable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">, disposable: ()</span></span></span></span> -&gt; T) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> }</code> </pre> <br>  MapDisposable est √©galement limit√©: prenez l'interface Carte et copiez les contenus, <code>add</code> et <code>remove</code> m√©thodes.  La m√©thode <code>add</code> diff√®re de Map: le deuxi√®me argument est le lambda pour la beaut√© et la commodit√©.  La commodit√© est que nous pouvons synchroniser le lambda pour √©viter des <b>conditions de course</b> inattendues.  Mais nous n'en parlerons pas, nous continuerons sur l'architecture. <br><br><h3>  Impl√©mentation de l'interface </h3><br>  Nous avons d√©clar√© toutes les interfaces et essaierons d'impl√©menter quelque chose de simple.  Prenez <b>CompletableAct</b> et <b>SingleAct</b> . <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompletableAct</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable ) : Act <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SingleAct</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T : Any</span></span></span><span class="hljs-class">&gt;</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: Id, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> single: Single&lt;T&gt; ) : Act</code> </pre> <br>  CompletableAct est un wrapper sur Completable.  Dans notre cas, il contient simplement un ID - c'est ce dont nous avons besoin.  SingleAct est presque le m√™me.  Nous pouvons √©galement impl√©menter Maybe et Flowable, mais nous attarder sur les deux premi√®res impl√©mentations. <br><br>  Pour Single, nous avons sp√©cifi√© le type g√©n√©rique <code>&lt;T : Any&gt;</code> .  En tant que d√©veloppeur Kotlin, je pr√©f√®re utiliser une telle approche. <br><br><blockquote>  Essayez d'utiliser des g√©n√©riques non nuls. </blockquote><br>  Maintenant que nous avons un ensemble d'interfaces, nous impl√©mentons une logique pour emp√™cher l'ex√©cution des m√™mes requ√™tes. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span><span class="hljs-class"> </span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> map: MapDisposable ): ActExecutor { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span> ) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; { log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - in progress"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> startExecution(act, e) log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Started"</span></span>) } }</code> </pre> <br>  Nous prenons une carte et v√©rifions s'il y a une demande.  Sinon, nous commen√ßons √† ex√©cuter la demande et l'ajoutons √† la carte juste au moment de l'ex√©cution.  Apr√®s l'ex√©cution avec n'importe quel r√©sultat: erreur ou succ√®s, supprimez la demande de la carte. <br><br>  Pour tr√®s attentif - il n'y a pas de synchronisation, mais la synchronisation est dans le code source sur GitHub. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startExecution</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> removeFromMap = { mapDisposable.remove(act.id) } mapDisposable.add(act.id) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> CompletableAct -&gt; act.completable .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SingleAct&lt;*&gt; -&gt; act.single .doFinally(removeFromMap) .subscribe({}, e) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> IllegalArgumentException() } }</code> </pre> <br><blockquote>  Utilisez lambdas comme dernier argument pour am√©liorer la lisibilit√© du code.  C'est magnifique et vos coll√®gues vous remercieront. </blockquote><br>  Nous utiliserons d'autres puces Kotlin et ajouterons des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonctions d'extension</a> pour Completable et Single.  Avec eux, nous n'avons pas besoin de chercher une m√©thode d'usine pour cr√©er un CompletableAct et SingleAct - nous les cr√©erons via des fonctions d'extension. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> Completable.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = CompletableAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T: Any&gt;</span></span></span><span class="hljs-function"> Single</span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toAct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Id</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Act = SingleAct(id, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><blockquote>  Les fonctions d'extension peuvent √™tre ajout√©es √† n'importe quelle classe. </blockquote><br><h3>  R√©sultat </h3><br>  Nous avons impl√©ment√© plusieurs composants et une logique tr√®s simple.  Maintenant, la r√®gle principale que nous devons suivre est de <b>ne pas forcer un abonnement √† la main</b> .  Lorsque nous voulons ex√©cuter quelque chose - nous le donnons via Executor.  Ainsi qu'avec du fil - personne ne les d√©marre eux-m√™mes. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>) executor.apply { execute(act()) execute(act()) execute(act()) } Hello - Act Started Hello - Act Duplicate Hello - Act Duplicate Hello - Act Finished</code> </pre> <br>  Nous avons convenu une fois au sein de l'√©quipe, et maintenant il y a toujours une garantie que les ressources de notre application ne seront pas d√©pens√©es pour l'ex√©cution de demandes identiques et inutiles. <br><br>  Le premier probl√®me a √©t√© r√©solu.  D√©veloppons maintenant la solution pour lui donner de la flexibilit√©. <br><br><h2>  Probl√®me num√©ro 2: quelle t√¢che annuler? </h2><br>  Ainsi que dans les cas o√π il est n√©cessaire d' <b>annuler une demande ult√©rieure</b> , il se peut que nous devions annuler la pr√©c√©dente.  Par exemple, nous avons modifi√© les informations sur notre utilisateur pour la premi√®re fois et les avons envoy√©es au serveur.  Pour une raison quelconque, l'envoi a pris beaucoup de temps et n'a pas abouti.  Nous avons √† nouveau modifi√© le profil utilisateur et envoy√© la m√™me demande une deuxi√®me fois.  Dans ce cas, cela n'a aucun sens de g√©n√©rer un ID sp√©cial pour la demande - les informations de la deuxi√®me tentative sont plus pertinentes et la <b>demande pr√©c√©dente est annul√©e</b> . <br><br>  La solution actuelle ne fonctionnera pas, car elle annulera toujours l'ex√©cution de la demande avec les informations pertinentes.  Nous devons en quelque sorte √©tendre la solution pour contourner le probl√®me et ajouter de la flexibilit√©.  Pour ce faire, comprendre ce que nous voulons tous?  Mais nous voulons comprendre quelle t√¢che annuler, comment ne pas copier-coller et comment l'appeler. <br><br><h3>  Ajouter des composants </h3><br>  Nous appelons des strat√©gies de comportement de requ√™te et cr√©ons deux interfaces pour elles: <b>StrategyHolder</b> et <b>Strategy</b> .  Nous cr√©ons √©galement 2 objets qui sont responsables de la strat√©gie √† appliquer. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Strategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KillMe</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Strategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SaveMe : Strategy()</code> </pre> <br>  Je n'utilise pas d' <b>√©num√©ration</b> - j'aime plus la <b>classe scell√©e</b> .  Ils sont plus l√©gers, consomment moins de m√©moire et sont plus faciles et plus pratiques √† √©tendre. <br><br><blockquote>  La classe scell√©e est plus facile √† √©tendre et √† √©crire plus courte. </blockquote><br><h3>  Mise √† jour des composants existants </h3><br>  √Ä ce stade, tout est simple.  Nous avions une interface simple, maintenant ce sera l'h√©ritier de StrategyHolder.  Comme ce sont des interfaces, il n'y a pas de probl√®me d'h√©ritage.  Dans l'impl√©mentation de CompletableAct, nous allons ins√©rer un autre <code>override</code> et y ajouter la valeur par d√©faut pour nous assurer que les modifications resteront compatibles avec le code existant. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe ) : Act</code> </pre> <br><h3>  Strat√©gies </h3><br>  J'ai choisi la strat√©gie <b>SaveMe</b> , qui me semble √©vidente.  Cette strat√©gie n'annule que les demandes suivantes - la premi√®re demande sera toujours active jusqu'√† ce qu'elle soit termin√©e. <br><br>  Nous avons travaill√© un peu sur notre impl√©mentation.  Nous avions une m√©thode d'ex√©cution et nous y avons maintenant ajout√© une v√©rification de strat√©gie. <br><br><ul><li>  Si la strat√©gie <b>SaveMe</b> est la m√™me que ce que nous faisions auparavant, alors rien n'a chang√©. <br></li><li>  Si la strat√©gie est <b>KillMe</b> , supprimez la demande pr√©c√©dente et lancez-en une nouvelle. <br></li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) = <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { map.contains(act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { map.remove(act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) }</code> </pre> <br><h3>  R√©sultat </h3><br>  Nous avons pu g√©rer facilement les strat√©gies en √©crivant un minimum de code.  En m√™me temps, nos coll√®gues sont heureux et nous pouvons faire quelque chose comme √ßa. <br><br><pre> <code class="kotlin hljs">executor.apply { execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>, KillMe)) execute(Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS) .toAct(<span class="hljs-string"><span class="hljs-string">"Hello¬´, KillMe)) } Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Canceled Hello - Act Started Hello - Act Finished</span></span></code> </pre> <br>  Nous cr√©ons une t√¢che asynchrone, passons la strat√©gie et chaque fois que nous d√©marrons une nouvelle t√¢che, toutes les pr√©c√©dentes, et non les suivantes, seront annul√©es. <br><br><h2>  Probl√®me num√©ro 3: les strat√©gies ne suffisent pas </h2><br>  Passons √† un probl√®me int√©ressant que j'ai rencontr√© sur quelques projets.  Nous √©largirons notre solution pour traiter des cas plus compliqu√©s.  Un de ces cas, particuli√®rement pertinent pour les r√©seaux sociaux, est <b>¬´j'aime / je n'aime pas¬ª</b> .  Il y a un message et nous voulons l'aimer, mais en tant que d√©veloppeurs, nous ne voulons pas bloquer l'int√©gralit√© de l'interface utilisateur et afficher la bo√Æte de dialogue en plein √©cran avec chargement jusqu'√† ce que la demande soit termin√©e.  Oui, et l'utilisateur sera m√©content.  Nous voulons tromper l'utilisateur: il appuie sur le bouton et, comme si cela s'√©tait d√©j√† produit - une belle animation a commenc√©.  Mais en fait, il n'y avait pas de pareil - nous attendons que la tromperie devienne vraie.  Pour pr√©venir la fraude, nous devons g√©rer de mani√®re transparente l'aversion pour l'utilisateur. <br><br>  Ce serait bien de g√©rer cela correctement afin que l'utilisateur obtienne le r√©sultat souhait√©.  Mais il nous est difficile, en tant que d√©veloppeurs, de traiter √† chaque fois <b>des demandes diff√©rentes et mutuellement exclusives</b> . <br><br>  Il y a trop de questions.  Comment comprendre que les requ√™tes sont li√©es?  Comment stocker ces connexions?  Comment g√©rer des scripts complexes et non copier-coller?  Comment nommer de nouveaux composants?  Les t√¢ches sont complexes et ce que nous avons d√©j√† mis en ≈ìuvre ne convient pas √† la solution. <br><br><h3>  Groupes et strat√©gies pour les groupes </h3><br>  Cr√©ez une interface simple appel√©e <b>GroupStrategyHolder</b> .  C'est un peu plus compliqu√© - deux champs au lieu d'un. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategyHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String } <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GroupStrategy</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategy</span></span></span></span>() <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> KillGroup : GroupStrategy()</code> </pre> <br>  En plus de la strat√©gie pour une demande sp√©cifique, nous introduisons une nouvelle entit√© - un groupe de demandes.  Ce groupe aura √©galement des strat√©gies.  Nous ne consid√©rerons que l'option la plus simple avec deux strat√©gies: <b>Default</b> - la strat√©gie par d√©faut lorsque nous ne faisons rien avec les requ√™tes, et <b>KillGroup</b> - tue toutes les requ√™tes existantes du groupe et en lance une nouvelle. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Act</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StrategyHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GroupStrategyHolder { val id: String } class CompletableAct</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> id: String, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> completable: Completable, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> strategy: Strategy = SaveMe, <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupStrategy: GroupStrategy = Default <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> groupKey: String = <span class="hljs-string"><span class="hljs-string">""</span></span> ) : Act</code> </pre><br>  Nous r√©p√©tons les √©tapes dont j'ai parl√© plus t√¥t: nous prenons l'interface, d√©veloppons et ajoutons deux champs suppl√©mentaires √† CompletableAct et SingleAct. <br><br><h3>  Mettre √† jour l'impl√©mentation </h3><br>  Nous revenons √† la m√©thode Execute.  La troisi√®me t√¢che est plus compliqu√©e, mais la solution est assez simple: nous v√©rifions la strat√©gie de groupe pour une demande sp√©cifique et, s'il s'agit de KillGroup, nous tuons tout le groupe et ex√©cutons la logique habituelle. <br><br><pre> <code class="kotlin hljs">MapDisposable -&gt; GroupDisposable ... <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(act: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Act</span></span></span></span><span class="hljs-function"><span class="hljs-params">, e: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (act.groupStrategy == KillGroup) groupDisposable.removeGroup(act.groupKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> { groupDisposable.contains(act.groupKey, act.id) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (act.strategy) { KillMe -&gt; { stop(act.groupKey, act.id) startExecution(act, e) } SaveMe -&gt; log(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${act.id}</span></span></span><span class="hljs-string"> - Act duplicate"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> -&gt; startExecution(act, e) } }</code> </pre> <br>  Le probl√®me est complexe, mais nous avons d√©j√† une infrastructure assez ad√©quate - nous pouvons l'√©tendre et r√©soudre le probl√®me.  Si vous regardez notre r√©sultat, que devons-nous faire maintenant? <br><br><h3>  R√©sultat </h3><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">act</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>= Completable.timer(<span class="hljs-number"><span class="hljs-number">2</span></span>, SECONDS).toAct( id = id, groupStrategy = KillGroup, groupKey = <span class="hljs-string"><span class="hljs-string">"Like-Dislike-PostId-1234"</span></span> ) executor.apply { execute(act(‚ÄúLike‚Äù)) execute(act(‚ÄúDislike‚Äù)) execute(act(‚ÄúLike‚Äù)) } Like - Act Started Like - Act Canceled Dislike - Act Started Dislike - Act Canceled Like - Act Started Like - Act Finished</code> </pre> <br>  Si nous avons besoin de requ√™tes aussi complexes, nous ajoutons deux champs: groupStrategy et group ID.  L'ID de groupe est un param√®tre sp√©cifique, car pour prendre en charge de nombreuses demandes similaires de type ¬´J'aime / Je n'aime pas¬ª, vous devez cr√©er un groupe pour chaque paire de demandes qui appartiennent au m√™me objet.  Dans ce cas, vous pouvez nommer le groupe Like-Dislike-PostId et y ajouter l'ID de publication.  Chaque fois que nous aimons les messages voisins, nous serons s√ªrs que tout fonctionne correctement pour le message pr√©c√©dent et pour le suivant. <br><br>  Dans notre exemple synth√©tique, nous essayons d'ex√©cuter une s√©quence semblable √† ne pas aimer.  Lorsque nous effectuons la premi√®re action, puis la seconde - la pr√©c√©dente est annul√©e et la suivante comme annule la pr√©c√©dente aversion.  Voil√† ce que je voulais. <br><br>  Dans le dernier exemple, nous avons utilis√© des param√®tres nomm√©s pour cr√©er des actes.  Cela aide √† refroidir la lisibilit√© du code, surtout quand il y a beaucoup de param√®tres. <br><br><blockquote>  Pour une lecture plus facile, utilisez des param√®tres nomm√©s. </blockquote><br><h2>  L'architecture </h2><br>  Voyons comment cette d√©cision peut affecter notre architecture.  Sur les projets, je vois souvent que le mod√®le de vue ou le pr√©sentateur assument de nombreuses responsabilit√©s, telles que des hacks, pour g√©rer la situation avec ou non.  Habituellement, toute cette logique dans le mod√®le d'affichage: beaucoup de code en double avec verrouillage de bouton, gestionnaires LifeCycle, abonnements. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d2c/a94/35b/d2ca9435bf58a6a261edbf1e7eb046ba.png"><br><br>  Tout ce que notre ex√©cuteur fait maintenant √©tait une fois dans Presenter ou View Model.  Si l'architecture est mature, les d√©veloppeurs pourraient amener cette logique √† une sorte d'interacteurs ou de cas d'utilisation, mais la logique a √©t√© dupliqu√©e √† plusieurs endroits. <br><br>  Apr√®s avoir adopt√© Executor, le mod√®le de vue devient plus simple et toute la logique leur est cach√©e.  Si vous avez apport√© cela √† Presenter et √† l'interacteur, vous savez que l'interaction et le pr√©sentateur deviennent plus faciles.  En g√©n√©ral, j'√©tais satisfait. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ef8/215/4c3/ef82154c3a09b62d063ed02ff4d40267.png"><br><br><h2>  Quoi d'autre √† ajouter? </h2><br>  Un autre avantage de la solution actuelle est qu'elle est extensible.  Que souhaiterions-nous ajouter en tant que d√©veloppeurs qui travaillent sur une application mobile et luttent chaque jour avec des bogues et de nombreuses demandes simultan√©es? <br><br><h3>  Les possibilit√©s </h3><br>  La <b>mise en ≈ìuvre du cycle de vie</b> est rest√©e dans les coulisses, mais en tant que d√©veloppeurs mobiles, nous y pensons toujours et nous inqui√©tons pour que rien ne s'√©coule.  Je souhaite <b>enregistrer et restaurer les</b> demandes de red√©marrage des applications. <br><br>  <b>Cha√Ænes d'appels.</b>  En raison de l'encapsulation des cha√Ænes RX, il devient possible de les s√©rialiser, car par d√©faut RX ne s√©rialise pas. <br><br>  Peu de gens savent combien de demandes simultan√©es sont en cours d'ex√©cution √† un moment donn√© dans leurs applications.  Je ne dirais pas que c'est un gros probl√®me pour les petites et moyennes applications.  Mais pour une grande application qui fait beaucoup de travail en arri√®re-plan, il est agr√©able de comprendre les causes des plantages et des plaintes des utilisateurs.  Sans infrastructure suppl√©mentaire, les d√©veloppeurs n'ont tout simplement pas d'informations pour comprendre la raison: peut-√™tre que la raison est dans l'interface utilisateur, ou peut-√™tre dans un grand nombre de demandes constantes en arri√®re-plan.  Nous pouvons √©tendre notre solution et ajouter une sorte de <b>m√©triques</b> . <br><br>  Examinons les possibilit√©s plus en d√©tail. <br><br><h3>  Traitement du cycle de vie </h3><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActExecutorImpl</span></span></span></span>( lifecycle: Lifecycle ) : ActExecutor { inir { lifecycle.doOnDestroy { cancelAll() } } ...</code> </pre> <br>  Ceci est un exemple d'impl√©mentation du cycle de vie.  Dans le cas le plus simple - avec <code>Destroy</code> fragments ou annul√© avec <code>Activity</code> , nous <b>transmettons le gestionnaire de cycle de vie √† notre ex√©cuteur</b> , et lorsque <b>l'√©v√©nement onDestroy se produit, nous supprimons toutes les demandes</b> .  Il s'agit d'une solution simple qui √©limine le besoin de copier-coller un code similaire dans View Models.  LifeData fait √† peu pr√®s la m√™me chose. <br><br><h3>  Sauvegarde / restauration </h3><br>  Puisque nous avons des wrappers, nous pouvons cr√©er <b>des classes distinctes pour les actes</b> , √† l'int√©rieur desquelles il y aura une logique pour cr√©er des t√¢ches asynchrones.  De plus, nous pouvons <b>enregistrer</b> ce nom dans la base de donn√©es et le <b>restaurer √† partir de la base de donn√©es au d√©marrage de l'application en</b> utilisant la m√©thode d'usine ou quelque chose de similaire. <br><br>  Dans le m√™me temps, nous aurons la possibilit√© de travailler hors ligne et nous red√©marrerons les demandes qui se sont termin√©es avec des erreurs lorsque Internet appara√Æt.  En l'absence d'Internet ou avec des erreurs de demande, nous les enregistrons dans la base de donn√©es, puis les restaurons et les ex√©cutons √† nouveau.  Si vous pouvez le faire avec un RX r√©gulier sans wrappers suppl√©mentaires, veuillez √©crire dans les commentaires, ce serait int√©ressant. <br><br><h3>  Cha√Ænes d'appel </h3><br>  Nous pouvons √©galement <b>lier nos lois</b> .  Une autre option d'extension consiste <b>√† ex√©cuter des cha√Ænes de requ√™te</b> .  Par exemple, vous avez une entit√© qui doit √™tre cr√©√©e sur le serveur, et une autre entit√©, qui d√©pend de la premi√®re, doit √™tre cr√©√©e exactement au moment o√π nous sommes s√ªrs que la premi√®re demande a r√©ussi.  Cela peut √©galement √™tre fait.  Bien s√ªr, ce n'est pas si trivial, mais avoir une classe qui contr√¥le le lancement de toutes les t√¢ches asynchrones est possible.  L'utilisation de RX nu est plus difficile √† faire. <br><br><h3>  Mesures </h3><br>  Il est int√©ressant de voir <b>combien de requ√™tes parall√®les sont effectu√©es en moyenne en arri√®re-plan</b> .  Ayant des mesures, vous pouvez comprendre la cause des plaintes des utilisateurs concernant la l√©thargie.  ,         ,    . <br><br>          ,  , , <b>   </b>  ,   -    -    10%   .    ,    . <br><br><h2>  Conclusion </h2><br> <b>  </b> ‚Äî  ,    . ¬´¬ª      .       ,         ,  ,  ,    . <br><br>       ,      ,   .   ‚Äî   - , ,  ‚Äî   .    ‚Äî .  ,           .       . <b>      </b> . <br><br> <b>     </b> .    Kotlin,              . , <b>    </b> . <br><br><blockquote>       AppsConf 2018,      <b> AppsConf 2019</b> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>  38 : ,  Android, UX, , - , , Kotlin. <br><br>   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">youtube-</a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>    <b>22‚Äì23 </b>    . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437592/">https://habr.com/ru/post/fr437592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437582/index.html">Pr√©sentation de Vue.js 2.6</a></li>
<li><a href="../fr437584/index.html">Les bases math√©matiques de la mise en page automatique</a></li>
<li><a href="../fr437586/index.html">Nous cr√©ons une application vocale en utilisant l'exemple de Google Assistant</a></li>
<li><a href="../fr437588/index.html">Est-ce plus amusant √† d√©velopper pour les t√©l√©phones portables que pour le web?</a></li>
<li><a href="../fr437590/index.html">Num√©ros de latence sur iPhone</a></li>
<li><a href="../fr437594/index.html">Comment j'ai √©radiqu√© la cause du b√©gaiement et du saut de trame dans tous les jeux, et aussi abaiss√© accidentellement la temp√©rature de 15 degr√©s</a></li>
<li><a href="../fr437596/index.html">OTRS: authentification, autorisation et synchronisation LDAP (FreeIPA, AD)</a></li>
<li><a href="../fr437598/index.html">Comment enregistrer le syst√®me de jeu √† partir d'un PC personnel au moyen de la virtualisation</a></li>
<li><a href="../fr437600/index.html">opencv4arts: Dessine ma ville, Vincent</a></li>
<li><a href="../fr437602/index.html">Profil d'un projet Unity avec Android Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>