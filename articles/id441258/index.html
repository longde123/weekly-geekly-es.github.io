<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📇 💾 👊🏼 Penelusuran dinamis berfitur lengkap di Linux menggunakan eBPF dan bpftrace 🗿 👍🏻 🧑🏾‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="“Dalam mode penelusuran, programmer melihat urutan eksekusi perintah dan nilai-nilai variabel pada langkah eksekusi program ini, yang membuatnya lebih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Penelusuran dinamis berfitur lengkap di Linux menggunakan eBPF dan bpftrace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/441258/"><img src="https://habrastorage.org/webt/gd/t6/e_/gdt6e_wwaanx1prvqkhdhj5ptss.jpeg"><br><br>  “Dalam mode penelusuran, programmer melihat urutan eksekusi perintah dan nilai-nilai variabel pada langkah eksekusi program ini, yang membuatnya lebih mudah untuk mendeteksi kesalahan,” kata Wikipedia kepada kami.  Sebagai penggemar Linux sendiri, kami secara teratur menemukan pertanyaan tentang alat spesifik mana yang terbaik untuk mengimplementasikannya.  Dan kami ingin membagikan terjemahan artikel oleh programmer Hongley Lai yang merekomendasikan bpftrace.  Ke depan, saya akan mengatakan bahwa artikel itu berakhir dengan ringkas: "bpftrace adalah masa depan".  Jadi mengapa dia begitu mengesankan rekan Lai?  Jawaban terperinci di bawah potongan. <br><a name="habracut"></a><br>  Ada dua alat penelusuran utama di Linux: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">strace</a> memungkinkan Anda untuk melihat panggilan sistem mana yang sedang dibuat; <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ltrace</a> memungkinkan Anda melihat perpustakaan dinamis mana yang dipanggil. <br><br>  Terlepas dari kegunaannya, alat-alat ini terbatas.  Dan jika Anda perlu mencari tahu apa yang terjadi di dalam sistem atau panggilan perpustakaan?  Dan jika Anda tidak hanya perlu menyusun daftar panggilan, tetapi juga, misalnya, mengumpulkan statistik tentang perilaku tertentu?  Dan jika Anda perlu melacak beberapa proses dan membandingkan data dari beberapa sumber? <br><br>  Pada tahun 2019, kami akhirnya mendapatkan jawaban yang layak untuk pertanyaan-pertanyaan ini di Linux: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bpftrace</a> berdasarkan teknologi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eBPF</a> .  Bpftrace memungkinkan Anda menulis program kecil yang berjalan setiap kali suatu peristiwa terjadi. <br><br>  Pada artikel ini saya akan menjelaskan cara menginstal bpftrace dan mengajarkan aplikasi dasarnya.  Saya juga akan memberikan gambaran tentang seperti apa jejak ekosistem itu (misalnya, "apa itu eBPF?") Dan bagaimana ia telah berevolusi menjadi apa yang kita miliki sekarang. <br><br><img src="https://habrastorage.org/webt/v9/vp/di/v9vpdivpv8a6roolw_kiz7wtnfs.png"><br><br><h3>  Apa itu jejak? </h3><br>  Seperti disebutkan sebelumnya, bpftrace memungkinkan Anda untuk menulis program kecil yang berjalan setiap kali suatu peristiwa terjadi. <br><br>  Apa itu acara?  Ini bisa berupa panggilan sistem, panggilan fungsi, atau bahkan sesuatu yang terjadi di dalam permintaan tersebut.  Ini juga bisa berupa penghitung waktu atau peristiwa perangkat keras, misalnya, "50 ms telah berlalu sejak peristiwa yang sama", "kegagalan halaman terjadi", "terjadi perubahan konteks" atau "prosesor kehilangan uang terjadi". <br><br>  Apa yang bisa dilakukan sebagai respons terhadap suatu peristiwa?  Anda dapat berjanji sesuatu, mengumpulkan statistik dan menjalankan perintah shell sewenang-wenang.  Anda akan memiliki akses ke berbagai informasi kontekstual, seperti PID saat ini, jejak stack, waktu, argumen panggilan, nilai balik, dll. <br><br>  Kapan menggunakannya?  Dalam banyak.  Anda dapat mengetahui mengapa aplikasi ini lambat dengan menyusun daftar panggilan paling lambat.  Anda dapat menentukan apakah ada kebocoran memori dalam aplikasi, dan jika demikian, di mana.  Saya menggunakannya untuk memahami mengapa Ruby menggunakan begitu banyak memori. <br><br>  Nilai tambah besar dari bpftrace adalah Anda tidak perlu mengkompilasi ulang aplikasi.  Tidak perlu menulis panggilan cetak secara manual atau kode debug lain dalam kode sumber aplikasi yang sedang dipelajari.  Bahkan tidak perlu me-restart aplikasi.  Dan semua ini dengan overhead yang sangat rendah.  Ini membuat bpftrace sangat berguna untuk sistem debugging langsung pada prod atau dalam situasi lain di mana ada kesulitan dengan kompilasi. <br><br><h3>  DTrace: bapak jejak </h3><br>  Untuk waktu yang lama, alat penelusuran terbaik adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DTrace</a> , kerangka penelusuran dinamis lengkap yang awalnya dikembangkan oleh Sun Microsystems (pembuat Java).  Seperti bpftrace, DTrace memungkinkan Anda untuk menulis program kecil yang berjalan sebagai respons terhadap peristiwa.  Faktanya, banyak elemen kunci ekosistem sebagian besar dikembangkan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brendan Gregg</a> , pakar DTrace terkenal yang saat ini bekerja di Netflix.  Yang menjelaskan persamaan antara DTrace dan bpftrace. <br><br><img src="https://habrastorage.org/webt/2p/wc/4w/2pwc4wawnfzibvlwt7ia0xibodc.jpeg"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengenalan Solaris DTrace (2009)</a> oleh S. Tripathi, Sun Microsystems</i> <br><br>  Pada titik tertentu, Sun membuka sumber untuk DTrace.  Saat ini, DTrace tersedia di Solaris, FreeBSD, dan macOS (walaupun versi macOS umumnya tidak dapat dioperasikan karena System Integrity Protection, SIP, telah melanggar banyak prinsip yang dijalankan oleh DTrace). <br><br>  Ya, Anda memperhatikan dengan benar ... Linux tidak ada dalam daftar ini.  Ini bukan masalah teknik, ini masalah lisensi.  DTrace dibuka di bawah CDDL, bukan GPL.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Port Linux DTrace</a> telah tersedia sejak 2011, tetapi belum pernah didukung oleh pengembang Linux utama.  Pada awal 2018, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Oracle membuka kembali DTrace di bawah GPL</a> , tetapi pada saat itu sudah terlambat. <br><br><h3>  Linux Tracing Ecosystem </h3><br>  Tidak diragukan lagi pelacakan sangat berguna, dan komunitas Linux telah berusaha mengembangkan solusi sendiri untuk topik ini.  Tetapi, tidak seperti Solaris, Linux tidak diatur oleh satu vendor tertentu, dan oleh karena itu tidak ada upaya yang disengaja untuk mengembangkan pengganti DTrace yang berfungsi penuh.  Ekosistem jejak Linux telah berevolusi secara perlahan dan alami, memecahkan masalah yang muncul.  Dan baru-baru ini saja ekosistem ini tumbuh cukup untuk bersaing secara serius dengan DTrace. <br><br>  Karena pertumbuhan alami, ekosistem ini mungkin tampak sedikit kacau, terdiri dari banyak komponen berbeda.  Untungnya, Julia Evans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menulis tinjauan ekosistem ini</a> (perhatian, tanggal publikasi - 2017, sebelum munculnya bpftrace). <br><br><img src="https://habrastorage.org/webt/io/km/zq/iokmzq2fmqyechm1boqeks-w2za.png"><br>  <i>Ekosistem jejak Linux dijelaskan oleh Julia Evans</i> <br><br>  Tidak semua elemen sama pentingnya.  Biarkan saya meringkas secara singkat elemen mana yang saya anggap paling penting. <br><br>  <b>Sumber acara</b> <br><br>  Data acara dapat berasal dari kernel atau ruang pengguna (aplikasi dan perpustakaan).  Beberapa dari mereka tersedia secara otomatis, tanpa upaya pengembang tambahan, sementara yang lain memerlukan pengumuman manual. <br><br><img src="https://habrastorage.org/webt/2t/xm/mm/2txmmm6rz5xfcwcglsxy8zopr6q.jpeg"><br>  <i>Tinjauan tentang sumber paling penting dari peristiwa yang dilacak di Linux</i> <br><br>  Di sisi kernel, ada kprobes ( <i>dari "kernel probes", "sensor kernel", sekitar Per.</i> ) - sebuah mekanisme yang memungkinkan Anda untuk melacak setiap panggilan fungsi di dalam kernel.  Dengannya, Anda tidak hanya dapat melacak panggilan sistem, tetapi juga apa yang terjadi di dalamnya (karena titik masuk panggilan sistem memanggil fungsi internal lainnya).  Anda juga dapat menggunakan kprobes untuk melacak peristiwa kernel yang bukan panggilan sistem, misalnya, "data buffer sedang ditulis ke disk", "paket TCP dikirim melalui jaringan" atau "pengalihan konteks sedang berlangsung". <br><br>  Kernel tracepoints memungkinkan penelusuran peristiwa non-standar yang ditentukan oleh pengembang kernel.  Peristiwa ini tidak pada tingkat panggilan fungsi.  Untuk membuat poin seperti itu, pengembang kernel secara manual menempatkan makro TRACE_EVENT dalam kode kernel. <br><br>  Kedua sumber memiliki pro dan kontra.  Kprobes bekerja "secara otomatis" karena  tidak memerlukan pengembang kernel untuk secara manual kode kode.  Tetapi acara kprobe dapat berubah secara sewenang-wenang dari satu versi kernel ke versi lain, karena fungsinya terus berubah - mereka ditambahkan, dihapus, diganti namanya. <br><br>  Titik jejak kernel umumnya lebih stabil dari waktu ke waktu dan dapat memberikan informasi kontekstual yang berguna yang mungkin tidak tersedia jika kprobes digunakan.  Menggunakan kprobes, Anda dapat mengakses argumen panggilan fungsi.  Tetapi dengan bantuan titik jejak, Anda bisa mendapatkan informasi apa pun yang diputuskan oleh pengembang kernel untuk dijelaskan secara manual. <br><br>  Di ruang pengguna ada analog dari kprobes - jubah.  Ini dirancang untuk melacak panggilan fungsi di ruang pengguna. <br><br>  Sensor USDT ("Jejak Ruang Pengguna Yang Didefinisikan Statis") adalah analog dari titik jejak kernel di ruang pengguna.  Pengembang aplikasi harus secara manual menambahkan sensor USDT ke kode mereka. <br><br>  Fakta menarik: DTrace telah lama menyediakan C API untuk mendefinisikan sendiri analog sensor USDT (menggunakan makro DTRACE_PROBE).  Lacak pengembang ekosistem di Linux memutuskan untuk meninggalkan kode sumber yang kompatibel dengan API ini, sehingga makro DTRACE_PROBE apa pun secara otomatis dikonversi ke sensor USDT! <br><br>  Oleh karena itu, secara teori, strace dapat diimplementasikan menggunakan kprobes, dan ltrace dapat diimplementasikan menggunakan uprobe.  Saya tidak yakin apakah ini sudah dipraktikkan atau belum. <br><br>  <b>Antarmuka</b> <br><br>  Antarmuka adalah aplikasi yang memungkinkan pengguna untuk dengan mudah menggunakan sumber acara. <br><br>  Mari kita lihat bagaimana sumber acara bekerja.  Alur kerjanya adalah sebagai berikut: <br><br><ol><li>  Kernel merepresentasikan mekanisme - biasanya file / proc atau / sys yang terbuka untuk ditulis - yang merekam niat untuk melacak acara dan apa yang harus mengikuti acara tersebut. </li><li>  Setelah terdaftar, kernel melokalisasi kernel / fungsi dalam memori di ruang pengguna / melacak titik / sensor USDT dan mengubah kode mereka sehingga sesuatu yang lain terjadi. </li><li>  Hasil dari "sesuatu yang lain" ini dapat dikumpulkan kemudian menggunakan beberapa mekanisme. </li></ol><br>  Saya tidak ingin melakukan semua ini secara manual!  Oleh karena itu, antarmuka datang untuk menyelamatkan: mereka melakukan semua ini untuk Anda. <br><br>  Ada antarmuka untuk setiap selera dan warna.  Di bidang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka berbasis eBPF,</a> ada yang tingkat rendah yang membutuhkan pemahaman mendalam tentang bagaimana berinteraksi dengan sumber acara dan bagaimana bytecode eBPF bekerja.  Dan ada tingkat tinggi dan mudah dioperasikan, meskipun selama keberadaannya mereka tidak menunjukkan fleksibilitas yang besar. <br><br>  Itu sebabnya bpftrace - antarmuka terbaru - adalah favorit saya.  Ini ramah pengguna dan fleksibel seperti DTrace.  Tetapi ini cukup baru dan membutuhkan pemolesan. <br><br><h3>  eBPF </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">eBPF</a> adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bintang jejak Linux baru</a> yang menjadi basis bpftrace.  Ketika Anda melacak suatu peristiwa, Anda ingin sesuatu terjadi di kernel.  Bagaimana cara fleksibel untuk menentukan apa ini "sesuatu"?  Tentu saja, menggunakan bahasa pemrograman (atau menggunakan kode mesin). <br><br>  eBPF (versi yang disempurnakan dari Berkeley Packet Filter).  Ini adalah mesin virtual kinerja tinggi yang berjalan di kernel dan memiliki properti / batasan berikut: <br><br><ul><li>  Semua interaksi ruang pengguna terjadi melalui "kartu" eBPF, yang merupakan penyimpanan data bernilai kunci. </li><li>  Tidak ada siklus sehingga setiap program eBPF berakhir pada waktu tertentu. </li><li>  Tunggu, kami katakan Batch Filter?  Anda benar: mereka awalnya dirancang untuk menyaring paket jaringan.  Ini adalah tugas yang serupa: ketika meneruskan paket (terjadinya suatu peristiwa) Anda perlu melakukan beberapa tindakan administratif (menerima, membuang, jurnal atau mengarahkan paket, dll.) Mesin virtual diciptakan untuk mempercepat tindakan seperti itu (dengan kemampuan JIT) kompilasi).  Versi "extended" dianggap karena fakta bahwa, dibandingkan dengan versi asli dari Berkeley Packet Filter, eBPF dapat digunakan di luar konteks jaringan. </li></ul><br>  Itu dia.  Dengan bpftrace, Anda dapat menentukan acara mana yang harus dilacak dan apa yang harus terjadi sebagai respons.  Bpftrace mengkompilasi program bpftrace tingkat tinggi Anda menjadi bytecode eBPF, melacak peristiwa, dan memuat bytecode ke dalam kernel. <br><br><h3>  Hari-hari gelap sebelum eBPF </h3><br>  Sebelum eBPF, opsi solusinya, secara sederhana, canggung.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SystemTap</a> adalah sedikit pendahulu "paling serius" untuk bpftrace dalam keluarga Linux.  Skrip SystemTap diterjemahkan ke dalam bahasa C dan dimuat ke dalam kernel sebagai modul.  Modul kernel yang dihasilkan kemudian dimuat. <br><br>  Pendekatan ini sangat rapuh dan kurang didukung di luar Red Hat Enterprise Linux.  Bagi saya, itu tidak pernah bekerja dengan baik di Ubuntu, yang cenderung merusak SystemTap pada setiap pembaruan kernel karena perubahan dalam struktur data kernel.  Dikatakan juga bahwa pada masa awal keberadaannya, SystemTap <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dengan mudah menyebabkan panik kernel</a> . <br><br><h3>  Instalasi Bpftrace </h3><br>  Saatnya menyingsingkan lengan baju Anda!  Dalam panduan ini, kita akan melihat menginstal bpftrace di Ubuntu 18.04.  Versi distribusi yang lebih baru tidak diinginkan, karena  selama instalasi, kita akan membutuhkan paket yang belum dikompilasi untuk mereka. <br><br>  <b>Instalasi Ketergantungan</b> <br><br>  Pertama, instal Clang 5.0, lbclang 5.0, dan LLVM 5.0, termasuk semua file header.  Kami akan menggunakan paket yang disediakan oleh llvm.org, karena yang ada di repositori Ubuntu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bermasalah</a> . <br><br><pre><code class="plaintext hljs">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - cat &lt;&lt;EOF | sudo tee -a /etc/apt/sources.list deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main EOF sudo apt update sudo apt install clang-5.0 libclang-5.0-dev llvm-5.0 llvm-5.0-dev</code> </pre> <br>  Selanjutnya: <br><br><pre> <code class="plaintext hljs">sudo apt install bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev</code> </pre> <br>  Dan akhirnya, instal libbfcc-dev dari hulu, bukan dari repositori Ubuntu.  Tidak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ada file header</a> dalam paket yang ada di Ubuntu.  Dan masalah ini tidak terpecahkan bahkan pada pukul 18.10. <br><br><pre> <code class="plaintext hljs">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo "deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list sudo apt update sudo apt install bcc-tools libbcc-examples linux-headers-$(uname -r)</code> </pre> <br>  <b>Instalasi utama Bpftrace</b> <br><br>  Saatnya untuk menginstal bpftrace sendiri dari sumber!  Mari kita mengkloningnya, merakitnya dan menginstalnya di / usr / local: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/iovisor/bpftrace cd bpftrace mkdir build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=DEBUG .. make -j4 sudo make install</code> </pre> <br>  Dan kamu selesai!  Eksekusi akan diinstal di / usr / local / bin / bpftrace.  Anda dapat mengubah tujuan menggunakan argumen cmake, yang terlihat seperti ini secara default: <br><br><pre> <code class="plaintext hljs">DCMAKE_INSTALL_PREFIX=/usr/local.</code> </pre> <br>  <b>Contoh satu baris</b> <br><br>  Mari kita jalankan beberapa bpftrace single-liners untuk memahami kemampuan kita.  Saya mengambil ini dari panduan <a href="">Brendan Gregg</a> , yang memiliki deskripsi rinci tentang masing-masing. <br><br>  # 1. Tampilkan daftar sensor <br><br><pre> <code class="plaintext hljs">bpftrace -l 'tracepoint:syscalls:sys_enter_*'</code> </pre> <br>  # 2. Salam <br><br><pre> <code class="plaintext hljs">bpftrace -e 'BEGIN { printf("hello world\n"); }'</code> </pre> <br>  # 3. Membuka file <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args-&gt;filename)); }'</code> </pre> <br>  # 4. Jumlah panggilan sistem per proses <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code> </pre> <br>  # 5. Distribusi panggilan read () dengan jumlah byte <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args-&gt;retval); }'</code> </pre> <br>  # 6. Pelacakan dinamis konten read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'</code> </pre> <br>  # 7. Waktu yang dihabiskan untuk panggilan read () <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</code> </pre> <br>  # 8. Menghitung acara tingkat proses <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched* { @[name] = count(); } interval:s:5 { exit(); }'</code> </pre> <br>  # 9. Membuat profil tumpukan kerja kernel <br><br><pre> <code class="plaintext hljs">bpftrace -e 'profile:hz:99 { @[stack] = count(); }'</code> </pre> <br>  # 10. Lacak perencana <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched_switch { @[stack] = count(); }'</code> </pre> <br>  # 11. Melacak pemblokiran I / O <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:block:block_rq_complete { @ = hist(args-&gt;nr_sector * 512); }'</code> </pre> <br>  Lihatlah situs web Brendan Gregg untuk mengetahui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">output apa yang dapat dihasilkan oleh tim-tim di atas</a> . <br><br>  <b>Sintaksis Script dan Contoh Timing I / O</b> <br><br>  String yang melewati saklar '-e' adalah isi skrip bpftrace.  Sintaks dalam kasus ini adalah, kondisional, seperangkat konstruksi: <br><br><pre> <code class="plaintext hljs">&lt;event source&gt; /&lt;optional filter&gt;/ { &lt;program body&gt; }</code> </pre> <br>  Mari kita lihat contoh ketujuh, tentang timing operasi sistem baca file: <br><br><pre> <code class="plaintext hljs">kprobe:vfs_read { @start[tid] = nsecs; } &lt;- 1 -&gt;&lt;-- 2 -&gt; &lt;---------- 3 ---------&gt;</code> </pre> <br>  Kami melacak acara dari mekanisme <i>kprobe</i> , yaitu, kami melacak awal dari fungsi kernel. <br>  Fungsi kernel untuk tracing adalah <i>vfs_read</i> , fungsi ini dipanggil ketika kernel melakukan operasi baca dari sistem file (VFS dari "Virtual FileSystem", abstraksi dari sistem file di dalam kernel). <br><br>  Ketika <i>vfs_read</i> mulai <i>dijalankan</i> (mis. Sebelum fungsi melakukan pekerjaan yang bermanfaat), program bpftrace dimulai.  Menghemat cap waktu saat ini (dalam nanodetik) ke array asosiatif global yang disebut <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">st</a> art</i> .  Kuncinya adalah <i>tid</i> , referensi ke id utas saat ini. <br><br><pre> <code class="plaintext hljs">kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); } &lt;-- 1 --&gt; &lt;-- 2 -&gt; &lt;---- 3 ----&gt; &lt;----------------------------- 4 -----------------------------&gt;</code> </pre> <br>  1. Kami melacak acara dari mekanisme <i>kretprobe</i> , yang mirip dengan <i>kprobe</i> , kecuali bahwa itu dipanggil ketika fungsi mengembalikan hasil eksekusi. <br><br>  2. Fungsi kernel untuk tracing adalah <i>vfs_read</i> . <br><br>  3. Ini adalah filter opsional.  Ia memeriksa apakah waktu mulai telah direkam sebelumnya.  Tanpa filter ini, program dapat dimulai saat membaca dan hanya menangkap akhir, menghasilkan <i>perkiraan</i> waktu <i>nsecs - 0</i> , bukannya <i>nsecs - mulai</i> . <br><br>  4. Badan program. <br><br>  <i>nsecs - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">st</a> art [tid]</i> menghitung berapa banyak waktu yang telah berlalu sejak awal fungsi vfs_read. <br>  <i>@ns [comm] = hist (...)</i> menambahkan data yang ditentukan ke histogram dua dimensi yang disimpan dalam <i>@ns</i> .  Kunci <i>comm</i> mengacu pada nama aplikasi saat ini.  Jadi kita akan memiliki perintah histogram dengan perintah. <br><br>  <i>delete (...)</i> menghapus waktu mulai dari array asosiatif, karena kita tidak lagi membutuhkannya. <br><br>  Ini adalah kesimpulan terakhir.  Harap dicatat bahwa semua histogram ditampilkan secara otomatis.  Penggunaan eksplisit perintah histogram cetak tidak diperlukan.  <i>@ns</i> bukan variabel khusus, jadi histogram tidak ditampilkan karena itu. <br><br><pre> <code class="plaintext hljs">@ns[snmp-pass]: [0, 1] 0 | | [2, 4) 0 | | [4, 8) 0 | | [8, 16) 0 | | [16, 32) 0 | | [32, 64) 0 | | [64, 128) 0 | | [128, 256) 0 | | [256, 512) 27 |@@@@@@@@@ | [512, 1k) 125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | [1k, 2k) 22 |@@@@@@@ | [2k, 4k) 1 | | [4k, 8k) 10 |@@@ | [8k, 16k) 1 | | [16k, 32k) 3 |@ | [32k, 64k) 144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| [64k, 128k) 7 |@@ | [128k, 256k) 28 |@@@@@@@@@@ | [256k, 512k) 2 | | [512k, 1M) 3 |@ | [1M, 2M) 1 | |</code> </pre> <br><br>  <b>Contoh Sensor USDT</b> <br><br>  Mari kita ambil kode C ini dan simpan dalam file <i>tracetest.c</i> : <br><br><pre> <code class="plaintext hljs">#include &lt;sys/sdt.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; static long myclock() { struct timeval tv; gettimeofday(&amp;tv, NULL); DTRACE_PROBE1(tracetest, testprobe, tv.tv_sec); return tv.tv_sec; } int main(int argc, char **argv) { while (1) { myclock(); sleep(1); } return 0; }</code> </pre> <br>  Program ini berjalan tanpa henti dengan menelepon <i>myclock ()</i> sekali per detik.  <i>myclock ()</i> menanyakan waktu saat ini dan mengembalikan jumlah detik sejak awal era. <br><br>  Panggilan ke <i>DTRACE_PROBE1 di</i> sini mendefinisikan titik jejak USDT statis. <br><br><ul><li>  Makro <i>DTRACE_PROBE1</i> diambil dari <i>sys / sdt.h.</i>  Makro resmi USDT, yang melakukan hal yang sama, disebut <i>STAP_PROBE1</i> (STAP dari SystemTap, yang merupakan mekanisme Linux pertama yang didukung dalam USDT).  Tetapi karena USDT kompatibel dengan sensor ruang pengguna DTrace, <i>DTRACE_PROBE1</i> hanyalah referensi ke <i>STAP_PROBE1</i> . </li><li>  Parameter pertama adalah nama penyedia.  Saya percaya ini adalah sisa dari DTrace, karena bpftrace sepertinya tidak melakukan sesuatu yang berguna dengannya.  Namun, ada nuansa ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang saya temukan ketika men-debug masalah pada permintaan 328</a> ): nama penyedia harus identik dengan nama file aplikasi biner, jika tidak bpftrace tidak akan dapat menemukan titik jejak. </li><li>  Parameter kedua adalah nama titik jejak. </li><li>  Setiap parameter tambahan adalah konteks yang disediakan oleh pengembang.  Angka <i>1</i> di <i>DTRACE_PROBE1</i> berarti bahwa kami ingin memberikan satu parameter tambahan. </li></ul><br>  Mari kita pastikan sys / sdt.h tersedia untuk kita, dan menyusun program: <br><br><pre> <code class="plaintext hljs">sudo apt install systemtap-sdt-dev gcc tracetest.c -o tracetest -Wall -g</code> </pre> <br>  Kami menginstruksikan bpftrace untuk mengeluarkan PID dan "waktu adalah [angka]" setiap kali <i>testprobe</i> tercapai: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/full-path-to/tracetest:testprobe { printf("%d: time is %d\n", pid, arg0); }'</code> </pre> <br>  Bpftrace terus bekerja sementara kami menekan Ctrl-C.  Oleh karena itu, buka terminal baru dan jalankan <i>tracetest di</i> sana: <br><br>  # Di terminal baru <br>  ./tracetest <br><br>  Kembali ke terminal pertama dengan bpftrace, di sana Anda akan melihat sesuatu seperti: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... 30909: time is 1549023215 30909: time is 1549023216 30909: time is 1549023217 ... ^C</code> </pre> <br>  <b>Contoh alokasi memori menggunakan glibc ptmalloc</b> <br><br>  Saya menggunakan bpftrace untuk memahami mengapa Ruby menggunakan begitu banyak memori.  Dan sebagai bagian dari penelitian saya, saya perlu pemahaman tentang bagaimana pengalokasi memori glibc menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">daerah memori</a> . <br><br>  Untuk mengoptimalkan kinerja multi-core, pengalokasi memori glibc mengalokasikan beberapa "area" dari OS.  Ketika aplikasi meminta alokasi memori, pengalokasi memilih area yang tidak digunakan, dan menandai bagian dari area ini sebagai "bekas".  Karena utas menggunakan area yang berbeda, jumlah kunci berkurang, yang mengarah pada peningkatan kinerja multi-utas. <br><br>  Tetapi pendekatan ini menghasilkan banyak sampah, dan tampaknya konsumsi memori yang begitu tinggi di Ruby justru karena itu.  Untuk lebih memahami sifat sampah ini, saya bertanya-tanya: apa artinya “memilih area yang tidak digunakan”?  Ini bisa berarti salah satu dari: <br><br><ul><li>  Setiap kali <i>malloc ()</i> dipanggil, pengalokasi akan beralih ke semua area dan menemukan area yang saat ini tidak dikunci.  Dan hanya jika mereka semua diblokir, dia akan mencoba membuat yang baru. </li><li>  <i>Malloc</i> pertama kali <i>()</i> dipanggil pada utas tertentu (atau ketika utas dimulai), pengalokasi akan memilih salah satu yang saat ini tidak diblokir.  Dan jika mereka semua diblokir, ia akan mencoba membuat yang baru. </li><li>  <i>Malloc</i> pertama kali <i>()</i> dipanggil pada utas tertentu (atau ketika utas dimulai), pengalokasi akan mencoba membuat wilayah baru, terlepas dari apakah ada daerah yang tidak dikunci.  Hanya jika area baru tidak dapat dibuat (misalnya, ketika batasnya habis), itu akan menggunakan kembali yang sudah ada. </li><li>  Mungkin ada lebih banyak opsi yang belum saya pertimbangkan. </li></ul><br>  Tidak ada jawaban khusus dalam dokumentasi, yang mana dari fitur-fitur ini memungkinkan Anda untuk memilih area yang tidak digunakan.  Saya mempelajari kode sumber untuk glibc, yang menyarankan opsi 3 bisa melakukan ini.  Tapi saya ingin secara eksperimental memverifikasi bahwa saya menafsirkan kode sumber dengan benar, tanpa perlu kode debugging di glibc. <br><br>  Berikut adalah fungsi pengalokasi memori glibc yang menciptakan area baru.  Tetapi Anda dapat memanggilnya hanya setelah memeriksa batas. <br><br><pre> <code class="plaintext hljs">static mstate _int_new_arena(size_t size) { mstate arena; size = calculate_how_much_memory_to_ask_from_os(size); arena = do_some_stuff_to_allocate_memory_from_os(); LIBC_PROBE(memory_arena_new, 2, arena, size); do_more_stuff(); return arena; }</code> </pre> <br>  Bisakah saya menggunakan <i>uprobes</i> untuk melacak fungsi <i>_int_new_arena</i> ?  Sayangnya tidak.  Untuk beberapa alasan simbol ini tidak tersedia di glibc Ubuntu 18.04.  Bahkan setelah menginstal simbol debugging. <br><br>  Untungnya, ada sensor USDT dalam fungsi ini.  <i>LIBC_PROBE</i> adalah alias makro untuk <i>STAP_PROBE</i> . <br>  Nama penyedia adalah libc. <br>  Nama sensor adalah memory_arena_new. <br>  Angka 2 berarti ada 2 argumen tambahan yang ditentukan oleh pengembang. <br>  arena adalah alamat area yang diekstrak dari OS, dan ukurannya adalah ukurannya. <br><br>  Sebelum kita dapat menggunakan sensor ini, kita perlu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyiasati masalah 328</a> .  Kita perlu membuat tautan simbolik dengan glibc di suatu tempat dengan nama <i>libc</i> , karena bpftrace mengharapkan nama pustaka (yang sebaliknya akan menjadi <i>libc-2.27.so</i> ) untuk menjadi identik dengan nama penyedia <i>(libc)</i> . <br><br><pre> <code class="plaintext hljs">ln -s /lib/x86_64-linux-gnu/libc-2.27.so /tmp/libc</code> </pre> <br>  Sekarang kami menginstruksikan bpftrace untuk menghubungkan ke sensor USDT memory_arena_new, yang nama vendornya adalah <i>libc</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/tmp/libc:memory_arena_new { printf("PID %d: created new arena at %p, size %d\n", pid, arg0, arg1); }'</code> </pre> <br>  Di terminal lain, kita akan menjalankan Ruby, yang akan membuat tiga utas yang tidak melakukan apa pun dan berakhir dalam sedetik.  Karena pemblokiran global penerjemah, Ruby <i>malloc ()</i> tidak boleh dipanggil secara paralel oleh utas yang berbeda. <br><br><pre> <code class="plaintext hljs">ruby -e '3.times { Thread.new { } }; sleep 1'</code> </pre> <br>  Kembali ke terminal dengan bpftrace, kita akan melihat: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... PID 431: created new arena at 0x7f40e8000020, size 576 PID 431: created new arena at 0x7f40e0000020, size 576 PID 431: created new arena at 0x7f40e4000020, size 576</code> </pre> <br>  Inilah jawaban untuk pertanyaan kami!  Setiap kali Anda membuat utas baru di Ruby, glibc menyoroti area baru terlepas dari daya saing. <br><br>  <b>Apa titik jejak yang tersedia?</b>  <b>Apa yang harus saya lacak?</b> <br><br>  Anda dapat membuat daftar semua perangkat keras, timer, kprobe, dan titik jejak kernel statis dengan menjalankan perintah: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l</code> </pre> <br>  Anda dapat membuat daftar semua titik jejak uprobe (karakter fungsi) aplikasi atau perpustakaan dengan melakukan: <br><br><pre> <code class="plaintext hljs">nm /path-to-binary</code> </pre> <br>  Anda dapat membuat daftar semua titik jejak aplikasi atau perpustakaan USDT dengan menjalankan perintah berikut: <br><br><pre> <code class="plaintext hljs">/usr/share/bcc/tools/tplist -l /path-to/binary</code> </pre> <br>  Mengenai titik jejak mana yang digunakan: tidak ada salahnya untuk memahami kode sumber apa yang akan Anda lacak.  Saya sarankan Anda mempelajari kode sumber. <br><br>  <b>Tip: format struktural untuk melacak titik di kernel</b> <br><br>  Berikut ini tip bermanfaat tentang titik jejak kernel.  Anda dapat memeriksa kolom argumen mana yang tersedia dengan membaca file / sys / kernel / debug / tracing / events! <br><br>  Misalnya, Anda ingin melacak panggilan ke <i>madvise (..., MADV_DONTNEED)</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l | grep madvise</code> </pre> <br>  - akan memberi tahu kami bahwa kami dapat menggunakan tracepoint: syscalls: sys_enter_madvise. <br><br><pre> <code class="plaintext hljs">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_madvise/format</code> </pre> <br>  - akan memberi kami informasi berikut: <br><br><pre> <code class="plaintext hljs">name: sys_enter_madvise ID: 569 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:unsigned long start; offset:16; size:8; signed:0; field:size_t len_in; offset:24; size:8; signed:0; field:int behavior; offset:32; size:8; signed:0; print fmt: "start: 0x%08lx, len_in: 0x%08lx, behavior: 0x%08lx", ((unsigned long)(REC-&gt;start)), ((unsigned long)(REC-&gt;len_in)), ((unsigned long)(REC-&gt;behavior))</code> </pre> <br>  Madvise tanda tangan sesuai dengan manual: <i>(void * addr, size_t length, int advice)</i> .  Tiga bidang terakhir dari struktur ini sesuai dengan parameter ini! <br><br>  Apa arti dari MADV_DONTNEED?  Dinilai oleh grep MADV_DONTNEED / usr / include, itu sama dengan 4: <br><br><pre> <code class="plaintext hljs">/usr/include/x86_64-linux-gnu/bits/mman-linux.h:80:# define MADV_DONTNEED 4 /* Don't need these pages. */</code> </pre> <br>  Jadi tim bpftrace kami menjadi: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'tracepoint:syscalls:sys_enter_madvise /args-&gt;behavior == 4/ { printf("madvise DONTNEED called\n"); }'</code> </pre> <br><h3>  Kesimpulan </h3><br>  Bpftrace luar biasa!  Bpftrace adalah masa depan! <br><br>  Jika Anda ingin tahu lebih banyak tentang dia, maka saya sarankan Anda membiasakan diri dengan <a href="">kepemimpinannya</a> , serta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting pertama tahun 2019</a> di blog Brendan Gregg. <br><br>  Debugging yang bagus! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441258/">https://habr.com/ru/post/id441258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441244/index.html">Kerentanan WinRar, tidak tertutup selama 19 tahun, memungkinkan Anda untuk menempatkan file yang sudah dibongkar di mana saja</a></li>
<li><a href="../id441248/index.html">Rusia menempati peringkat ke-9 dalam peringkat SSL global, di atas Cina, Denmark, dan Swiss</a></li>
<li><a href="../id441250/index.html">Mulai Cepat: Buka + Apache Kafka + Redis</a></li>
<li><a href="../id441252/index.html">"Artikel mengisap penis": para ilmuwan memproses 109 jam seks oral untuk mengembangkan AI yang mengisap anggota</a></li>
<li><a href="../id441254/index.html">Seminar “Mengapa kami menghubungi Kubernetes dan apa yang kami dapatkan darinya”, 28 Februari, Moskow</a></li>
<li><a href="../id441260/index.html">Bagaimana grafik jaringan saraf membantu</a></li>
<li><a href="../id441262/index.html">Tugas yang sederhana dan panjang menyingkirkan kandidat lebih baik daripada yang pendek dan kompleks</a></li>
<li><a href="../id441264/index.html">Panduan Pengguna Kibana. Visualisasi. Bagian 2</a></li>
<li><a href="../id441266/index.html">Bagaimana kerangka kerja tiOPF untuk delphi / lazarus bekerja. Template Pengunjung</a></li>
<li><a href="../id441268/index.html">Ceedling + Eclipse atau unit test untuk mikrokontroler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>