<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëåüèΩ üöù ü§Ωüèæ Adaptador USB-SATA inverso (historial de un interno) üòü ‚õ≥Ô∏è üêô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antecedentes 


 La pasant√≠a es el proceso de adquirir conocimiento y experiencia. Nuestro equipo de Raccoon Security cree que es imposible mejorar la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Adaptador USB-SATA inverso (historial de un interno)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ntc-vulkan/blog/485966/"><h1 id="predystoriya">  Antecedentes </h1><br><p>  La pasant√≠a es el proceso de adquirir conocimiento y experiencia.  Nuestro equipo de Raccoon Security cree que es imposible mejorar la seguridad de la informaci√≥n de los dispositivos y el software que nos rodea sin transmitir este conocimiento y experiencia a las futuras generaciones de especialistas.  Es por eso que hemos estado organizando pasant√≠as individuales para estudiantes talentosos y graduados durante muchos a√±os. </p><br><p>  La investigaci√≥n de seguridad es una habilidad que no se ense√±a en la universidad.  Puede aprenderlo de ejemplos concretos y bajo la gu√≠a de mentores experimentados.  Cada a√±o, nuestros pasantes resuelven problemas t√©cnicos complejos, logran sus objetivos y siguen adelante, ampliando sus horizontes profesionales y haciendo que el mundo sea un poco m√°s seguro.  Cada uno de ellos tiene su propia historia de convertirse en un especialista, y bajo el corte: el comienzo de uno de ellos. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/eu/dr/h-/eudrh-mevrjhfjo4jfjouffyyk4.png"></div><a name="habracut"></a><br><h1 id="vvedenie">  Introduccion </h1><br><p>  En octubre del a√±o pasado, vine para una pasant√≠a t√©cnica en la empresa NTC Vulkan.  Mi inter√©s se dirigi√≥ al campo de la ingenier√≠a inversa.  Sab√≠a lo que era, ya hab√≠a intentado investigar independientemente crackme bajo x86, pero entend√≠ que lo m√°s interesante radica precisamente en la uni√≥n del software y el hardware.  No ten√≠a experiencia en esta √°rea, pero ten√≠a el deseo de probar suerte. </p><br><p> No ten√≠a ninguna expectativa espec√≠fica de este evento: amigos y conocidos a menudo hablan de pasant√≠as t√©cnicas en varias empresas conocidas.  Y cuando me ofrecieron probar suerte en la b√∫squeda de un adaptador USB-SATA, me alegr√© de la nueva oportunidad de aprender algo.  La experiencia adquirida y el resultado que obtuve hicieron posible verificar la exactitud de la elecci√≥n del lugar de la pasant√≠a y la futura profesi√≥n. </p><br><p>  Y el estudio comenz√≥ con la disponibilidad de un adaptador USB-SATA normal.  Esto es lo que hice a continuaci√≥n. </p><br><h1 id="vizualnyy-shemotehnicheskiy-analiz">  An√°lisis de circuito visual. </h1><br><p>  Primero debe inspeccionar la placa del adaptador y determinar los elementos b√°sicos del dispositivo.  En las siguientes figuras, se marcan los bloques principales de componentes que son importantes para el funcionamiento del dispositivo.  Fotos tomadas despu√©s de la investigaci√≥n: </p><br><img src="https://habrastorage.org/webt/9x/1n/ej/9x1nejzyxjz-zpfnb_d_v9y9giy.jpeg"><br><p>  <em>Adaptador USB a SATA.</em>  <em>Vista superior</em> </p><br><img src="https://habrastorage.org/webt/tx/ra/je/txrajeoqdj1x7ytwn7huh0gdy6g.jpeg"><br><p>  <em>Adaptador USB a SATA.</em>  <em>Vista inferior</em> </p><br><p>  Despu√©s de pasar un tiempo en Google, descubr√≠ que hay dos convertidores de voltaje en la placa: uno a 3.3 V, el otro a 1.2 V. Tambi√©n es muy f√°cil determinar la memoria flash instalada en la placa.  La ROM funciona en la interfaz SPI y la capacidad de memoria es de 512 Kbps. </p><br><p>  Parece que la etapa de inteligencia de circuito est√° casi completa, pero una b√∫squeda r√°pida en Internet no arroj√≥ ning√∫n resultado a petici√≥n de "ASM1051".  No se encontraron documentos para el chip instalado en el tablero.  Es cierto, a√∫n logr√≥ encontrar software que le permite actualizarlo.  Adem√°s, hay una peque√±a <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">hoja</a> de <a href="https://datasheetspdf.com/pdf-file/917641/ASMedia/ASM1053/1">datos</a> para el modelo anterior <strong>ASM1053</strong> . </p><br><h1 id="usb">  USB </h1><br><p>  Cuando se conecta a una computadora, el adaptador aparece como un dispositivo de almacenamiento USB.  Decid√≠ que un conocimiento m√°s profundo de <a href="https://ru.wikipedia.org/wiki/USB">USB</a> probablemente ser√≠a √∫til para mi investigaci√≥n, por lo que pas√© las siguientes horas estudiando la interfaz. <br>  En general, los dispositivos USB pueden ser de diferentes clases, dependiendo de su funcionalidad.  Por ejemplo, las unidades flash son el dispositivo de almacenamiento masivo, y los teclados y ratones son el <a href="https://ru.wikipedia.org/wiki/USB_HID">dispositivo de interfaz humana (HID)</a> .  Y dado que mi adaptador es visible en el administrador de dispositivos como un dispositivo de almacenamiento, significa que est√° definido como Almacenamiento masivo y deber√≠a funcionar con comandos SCSI. </p><br><div class="spoiler">  <b class="spoiler_title">Literatura USB b√°sica que fue √∫til</b> <div class="spoiler_text"><ul><li><p>  <a href="https://pierrelib.pagesperso-orange.fr/buses/USB_in_a_Nutshell.pdf">USB en una c√°scara de nuez</a> </p><br></li><li><p>  <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">Clase de almacenamiento masivo de bus serie universal</a> </p><br></li><li><p>  <a href="http://ww1.microchip.com/downloads/en/appnotes/01169a.pdf">Clase de almacenamiento masivo USB en un dispositivo integrado</a> </p><br></li><li><p>  <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Manual de referencia de comandos SCSI</a> </p><br></li></ul></div></div><br><h1 id="chtenie-pamyati-iz-pzu">  Leer memoria de ROM </h1><br><p>  Como no se sabe nada sobre el ASM1051 instalado en la placa, la memoria de la ROM se consider√≥ la acci√≥n m√°s obvia.  Me mud√© al laboratorio.  Separ√≥ el chip de memoria flash con un secador de cabello para soldar, lo conect√≥ al programador USB ChipProg-48.  No hubo problemas para leer, y ten√≠a un archivo binario en mis manos.  En ese momento, no pod√≠a decir qu√© hab√≠a en la unidad flash y comenc√© a analizar los datos. </p><br><h1 id="analiz-binarnogo-fayla">  An√°lisis de archivo binario </h1><br><p>  En primer lugar, abr√≠ un volcado de memoria desde la ROM usando WinHex, pero puedes usar cualquier editor HEX.  Comenz√≥ a mirar los bytes: </p><br><img src="https://habrastorage.org/webt/fz/g8/v7/fzg8v7gjqsop97y-kgybcmudrqa.jpeg"><br><p>  <em>Inicio de un volcado de memoria le√≠do desde la ROM</em> </p><br><p> La captura de pantalla de arriba es una captura de pantalla del editor.  La l√≠nea <code>ASMT1051</code> , que comienza con la direcci√≥n 0x44, es inmediatamente evidente.  Tambi√©n puede ver la l√≠nea <code>asmedia</code> desde la direcci√≥n 0x18.  Para el an√°lisis de datos inicial, utilic√© la herramienta de an√°lisis de frecuencia, que est√° disponible en WinHex. </p><br><img src="https://habrastorage.org/webt/ui/r9/ad/uir9adkobpc6gnl55k6vjnaf65i.jpeg"><br><p>  <em>Histograma de an√°lisis de frecuencia de memoria ROM</em> </p><br><p>  El histograma muestra los bytes que est√°n m√°s en el archivo.  Adem√°s del mont√≥n 0x00 y 0xFF (las columnas extremas en el histograma), los siguientes bytes a menudo se encuentran en la memoria: </p><br><ul><li>  0x02; </li><li>  0x74; </li><li>  0x90; </li><li>  0xA3; </li><li>  0xE0; </li><li>  0xF0. </li></ul><br><p>  Ser√≠a posible confirmar mi suposici√≥n de que hay firmware en la ROM.  Una manera f√°cil de hacer esto es intentar comparar los <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25B8">c√≥digos de operaci√≥n de</a> diferentes arquitecturas adecuadas para microcontroladores (en adelante, MC) con bytes que a menudo se encuentran en la memoria. </p><br><p>  Si se estima de forma aproximada, muy a menudo en cualquier c√≥digo del ensamblador debe cumplir comandos tales como: </p><br><ul><li>  mov; </li><li>  jmp; </li><li>  llamada </li><li>  ret. </li></ul><br><p>  Por supuesto, en diferentes arquitecturas estos comandos pueden tener diferentes variaciones, pero hay un sentido com√∫n. </p><br><p>  Tuve que pasar por varios conjuntos de instrucciones para diferentes n√∫cleos antes de encontrar los correctos.  La comparaci√≥n con la arquitectura de <a href="https://ru.wikipedia.org/wiki/Intel_8051">Intel 8051</a> dio un resultado muy plausible.  Los c√≥digos de operaci√≥n de algunos <a href="http://www.keil.com/support/man/docs/is51/is51_opcodes.htm">comandos</a> coinciden con bytes populares de un archivo, por ejemplo: </p><br><ul><li>  0x02 - LJMP addr16; </li><li>  0x74 - MOV A, #immed; </li><li>  0x90 - MOV DPTR, #immed; </li><li>  0xA3 - INC DPTR; </li><li>  0xE0 - MOVX A, @DPTR; </li><li>  0xF0 - MOVX @DPTR, A. </li></ul><br><p>  Realmente parece que hay firmware para MK en la ROM.  Uno podr√≠a cargar inmediatamente el binario en el desensamblador <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA Pro</a> , pero en el almuerzo uno de los colegas pregunt√≥: </p><br><blockquote>  <em>"¬øEst√°s seguro de que el c√≥digo en la memoria comienza exactamente desde la direcci√≥n cero?"</em> </blockquote><p>  Y realmente, debe tener en cuenta que algunos "basura" o datos de la direcci√≥n 0x00 pueden estar en la memoria. </p><br><p>  En general, me enfrent√© a la tarea de determinar la direcci√≥n inicial del c√≥digo.  Para lograr este objetivo, era mejor usar el emulador <a href="https://www.eltan.com/products/spi-flash-tools/46-em100-emulator.html">EM100</a> SPI.  El emulador reemplaza el chip de memoria en la placa, con √©l no hay necesidad de soldar la ROM cada vez con firmware, adem√°s, el EM100 puede grabar un registro de acceso a la memoria.  Dado que el firmware de la ROM ya se ha le√≠do, ahora puede descargarlo al emulador SPI.  A continuaci√≥n, debe soldar el emulador a la placa del adaptador y grabar un registro al conectar el adaptador a trav√©s de USB a una PC. </p><br><img src="https://habrastorage.org/webt/8i/rp/f2/8irpf2mpqht4crvi8aqwcj3ot7s.jpeg"><br><p>  <em>El emulador SPI est√° soldado a la placa del adaptador USB-SATA</em> </p><br><p>  Solde el cableado del emulador a los pads de la memoria flash y flashe√© el emulador con algunos firmware.  Ahora queda por ver si MK direcciona memoria, y si es as√≠, en qu√© direcciones. </p><br><img src="https://habrastorage.org/webt/yc/v6/te/ycv6teqfm5n_7gzvwgss1d6ycwk.png"><br><p>  <em>ROM de acceso a la memoria ROM (obtenida utilizando el software emulador SPI)</em> </p><br><p>  La figura anterior muestra que cuando se conecta la alimentaci√≥n al adaptador, el controlador ASM1051 instalado en la placa env√≠a varios comandos 0x03 (Leer datos). </p><br><p>  Primero, el ASM1051 lee 0x80 bytes, comenzando en 0x0000.  Los siguientes son dos bytes, comenzando en la direcci√≥n 0x0080, luego dos bytes m√°s desde la direcci√≥n 0x8082.  Luego lee la mayor parte de la memoria de la ROM, comenzando en la direcci√≥n 0x0082. </p><br><p>  Podemos suponer que una gran cantidad de bytes que se leen desde la ROM al final, comenzando con la direcci√≥n 0x0082, es probablemente el c√≥digo.  Qu√© y por qu√© se solicita antes de esto a√∫n no est√° claro.  Solo se sabe que en respuesta a la primera solicitud, el ASM1051 recibir√° l√≠neas de la memoria flash que est√°n marcadas en la figura anterior.  Solo se ubicaron en los primeros 0x80 bytes. </p><br><p>  Es hora de comprobar si la memoria externa en la placa contiene firmware para MK con el n√∫cleo 8051, y el c√≥digo en s√≠ se encuentra en la direcci√≥n 0x0082.  Abra el volcado de memoria en IDA Pro, especifique el tipo de procesador Intel 8051 y desplace el c√≥digo 0x0082. </p><br><img src="https://habrastorage.org/webt/r8/fy/pl/r8fyplytapyh-i_lfgazwcsoxga.png"><br><p>  <em>Archivo binario abierto en IDA Pro con desplazamiento 0x82</em> </p><br><p>  No hubo problemas al abrir el binario en el desensamblador. </p><br><p>  <strong><em>Conclusiones:</em></strong> </p><br><ol><li>  MK ASM1051 tiene una arquitectura 8051. </li><li>  En ROM hay un c√≥digo que comienza con la direcci√≥n 0x82.  Hay algo m√°s adem√°s del c√≥digo. </li><li>  Los primeros 0x80 bytes atraen la atenci√≥n. </li></ol><br><h1 id="analiz-koda">  An√°lisis de c√≥digo </h1><br><p>  Ahora que me he asegurado de que el c√≥digo en la IDA se carga correctamente, puede comenzar a analizarlo y comentarlo en paralelo. </p><br><p>  Durante el estudio del c√≥digo, se encontraron funciones simples, como restar n√∫meros de 32 bits, se encontraron varios controladores, similares a <code>switch ()</code> en S. Melkali, y funciones muy simples, como almacenar un valor del registro R7 en la memoria en alguna direcci√≥n.  Los hallazgos m√°s significativos que describir√© a continuaci√≥n. </p><br><h2 id="nahodka--1">  Encuentra el n. ¬∞ 1 </h2><br><p>  Curiosamente, en respuesta a mi solicitud INQUIRY ( <a href="https://en.wikipedia.org/wiki/SCSI_command">comando SCSI</a> ), recib√≠ una respuesta que conten√≠a dos l√≠neas que vimos al comienzo de la memoria ROM.  Por supuesto, inmediatamente cambi√© estas l√≠neas en la memoria del emulador, esperando una solicitud de consulta para ver lo que escrib√≠.  Un sue√±o tan ingenuo se derrumb√≥ r√°pidamente.  Ahora, en respuesta al comando, vi otra l√≠nea, el ASM1051 no solicit√≥ la mayor parte de la memoria de la ROM.  MK ley√≥ solo los primeros 0x80 bytes y todo.  En la arquitectura de 8051, se puede usar el firmware de m√°scara (hardware), aparentemente, ASM1051 comenz√≥ a arrancar desde √©l. </p><br><p>  Entonces qued√≥ claro que los primeros 0x80 bytes son realmente importantes, y cambiarlos simplemente no funcionar√°.  Decid√≠ estudiar con m√°s detalle las solicitudes que MK hace en SPI antes de descargar el c√≥digo. </p><br><img src="https://habrastorage.org/webt/ep/cl/8i/epcl8it0d2d63f8oq1tctpmfvii.png"><br><p>  <em>Solicitud de datos SPI en ROM</em> </p><br><p>  Dos solicitudes de dos bytes parec√≠an interesantes.  La b√∫squeda en IDA 0x00, 0x80 y 0xEB arroj√≥ una gran cantidad de resultados que no analic√©, pero el byte 0x5A se encontr√≥ con menos frecuencia. </p><br><img src="https://habrastorage.org/webt/sv/ym/kf/svymkfdb-0nsj764k8igczukjj0.png"><br><p>  <em>Comparaci√≥n con el byte 0x5A.</em>  <em>Contando suma de comprobaci√≥n-8</em> </p><br><p>  Literalmente, el sexto clic me llev√≥ a la secci√≥n de c√≥digo que se muestra en la figura anterior.  Se puede ver que el valor del registro con la direcci√≥n 0x80 <strong>7E se</strong> compara con 0x5A.  Luego, la suma de comprobaci√≥n-8 se lee para los valores ubicados desde la direcci√≥n 0x80 <strong>04</strong> a 0x80 <strong>7E</strong> .  Luego, el valor a 0x80 <strong>7F se</strong> compara con la cantidad recibida previamente. </p><br><img src="https://habrastorage.org/webt/j4/ao/x2/j4aox2tkbow4wzw57rrbprixw9u.png"><br><p>  <em>El comienzo de la memoria en ROM</em> </p><br><p>  Tales compensaciones se parec√≠an al comienzo de un volcado de memoria desde la ROM.  La figura anterior muestra que la direcci√≥n 0x7E contiene el byte 0x5A.  Y si cuenta la suma de comprobaci√≥n 8 para bytes desde la posici√≥n 0x04 a 0x7E, entonces obtenemos 0xA7, y este valor solo se encuentra en la direcci√≥n 0x7F. </p><br><p>  De manera similar, logramos encontrar el c√°lculo de la suma de verificaci√≥n para bytes de la direcci√≥n 0x0082 a 0x807F (aparentemente este es el c√≥digo completo), que se verifica con el byte en la direcci√≥n 0x8083.  Y en 0x8082 nuevamente se encuentra el valor 0x5A. </p><br><p>  S√≠, esto es un poco m√°s complicado que simplemente cambiar las l√≠neas en la memoria.  Tambi√©n los cambi√©, pero tambi√©n calcul√© y anot√© las sumas de verificaci√≥n para el nuevo archivo en los lugares correctos.  Despu√©s de eso, en respuesta al comando SCSI INQUIRY, vi mis l√≠neas. </p><br><p>  <strong><em>Conclusiones:</em></strong> </p><br><ol><li>  Durante el arranque, el ASM1051 intenta descargar el c√≥digo de la ROM. </li><li>  Primero, el ASM1051 compara el byte de suma de comprobaci√≥n-8 de la direcci√≥n 0x04 a 0x7E con el valor en 0x7F. </li><li>  Si la comparaci√≥n de la suma de verificaci√≥n para el pre√°mbulo es exitosa, entonces podemos considerarla para el "c√≥digo" (direcciones de 0x0082 a 0x807F).  ASM1051 compara esta cantidad con el valor en la direcci√≥n 0x8083 y verifica que el byte 0x5A se encuentra en la direcci√≥n 0x8082. </li><li>  Si todas las comprobaciones son correctas, el ASM1051 se carga desde la ROM; de lo contrario, utiliza el firmware de m√°scara. </li></ol><br><h2 id="nahodka--2">  Encuentra el n√∫mero 2 </h2><br><p>  Mientras revisaba y comentaba las funciones, descubr√≠ que muy a menudo la funci√≥n PRINTF se usa en el c√≥digo (lo llam√© as√≠).  Lo interesante de esto es que antes de que se llame, se escribe un car√°cter <strong>impreso</strong> en el registro R7. </p><br><img src="https://habrastorage.org/webt/fn/0a/9a/fn0a9aafvgus1v4emxuf6j9kbea.png"><br><p>  <em>Funci√≥n PRINTF en IDA Pro</em> </p><br><p>  La funci√≥n en s√≠ se present√≥ en la figura anterior.  Tratemos con ella.  En primer lugar, debe mover el valor del registro con la direcci√≥n 0x7F6 a la bater√≠a.  Si hay cero, salga de la funci√≥n.  Lo m√°s interesante sucede si no hay cero.  Luego, el valor del registro R7 se mueve al registro con la direcci√≥n 0xC001 y, como recordamos, antes de llamar a esta funci√≥n, se escribe un car√°cter impreso en R7.  Luego, verifique si el valor en R7 es igual al c√≥digo de car√°cter "." O "-", si no, salga de la funci√≥n.  Pero si la comparaci√≥n result√≥ ser exitosa, entonces la funci√≥n toma el valor del registro con la direcci√≥n 0x16A y lo mueve a 0xC001, pero lo hace complicado.  Por ejemplo, en lugar del byte <strong>0x41</strong> (car√°cter "A" en ASCII), la funci√≥n se mover√° a 0xC001 byte 0x34 (car√°cter <strong>"4"</strong> en ASCII) y luego 0x31 (car√°cter <strong>"1"</strong> en ASCII).  Salga de la funci√≥n nuevamente. </p><br><p>  Descubr√≠ que la verificaci√≥n al comienzo de la funci√≥n no se puede pasar, ya que el registro con la direcci√≥n 0x7F6 se inicializa a cero, luego no cambia en el c√≥digo.  Es decir, el programador deshabilita esta funci√≥n, aunque permanece compilada.  El hecho de que los bytes solo se escriban en el registro 0xC001 (y, a veces, dos seguidos) sugiere que es muy probable que sea un registro de hardware. </p><br><p>  Todo esto se parece a UART.  Para saber si esto es as√≠, debe hacer lo siguiente: </p><br><ol><li>  Identifique las patas en el ASM1051 donde se emite el UART. </li><li>  Defina los par√°metros UART (velocidad, paridad, n√∫mero de bits de parada). </li><li>  Ser√≠a bueno habilitar UART en el c√≥digo (aparentemente, est√° desactivado). </li></ol><br><p>  Todo parece bastante simple: puede turnarse para tocar las piernas con un analizador l√≥gico y buscar aquel en el que sea visible el momento de enviar el UART.  En presencia de una se√±al, la velocidad puede determinarse por el tiempo de los pulsos.  Con el resto de los par√°metros, todo tambi√©n est√° claro, solo vea el momento de enviar un byte en el analizador. </p><br><p>  Para "habilitar" esta funci√≥n, puede escribir ceros en lugar de las primeras tres l√≠neas, donde el valor se verifica en el registro con la direcci√≥n 0x7F6.  Para hacer esto, nuevamente abro el firmware en WinHex. </p><br><img src="https://habrastorage.org/webt/rm/rw/mg/rmrwmgen5bw46g0r1a7uchsnkog.png"><br><p>  <em>Se asignan seis bytes para restablecer.</em> </p><br><p>  En el editor, cambio los seis bytes deseados a ceros.  Ahora el firmware est√° listo y se puede descargar al emulador de ROM.  Si suponemos que la funci√≥n para generar bytes en el UART est√° activada y su llamada se encuentra muy a menudo en todo el c√≥digo, entonces podemos esperar que los bytes "vuelen" desde el UART cuando el adaptador se est√° ejecutando.  Espero ver un marcador que se√±ale en bytes en el UART cu√°nto del c√≥digo se est√° ejecutando. </p><br><p>  Como escrib√≠ anteriormente, para encontrar las patas Rx y Tx necesarias, puede mirar el analizador l√≥gico uno por uno.  Sin embargo, supuse que el Rx y el Tx en el ASM1051 est√°n en el mismo lugar que el ASM1053: las patas 40 y 41, respectivamente.  Puse la sonda del analizador en el pin 41 (supuesto Tx) y veo algo similar a la se√±al deseada: </p><br><img src="https://habrastorage.org/webt/qn/s7/rq/qns7rq-nxvqvqcgzlo4hwqb7spc.png"><br><p>  <em>Diagrama de tiempos con la pierna 41 - Tx</em> </p><br><p>  Para conectar el convertidor USB-UART y observar los caracteres impresos entrantes en el terminal, tuve que soldar dos cables delgados directamente a la placa del adaptador y fijarlo con pegamento caliente. </p><br><img src="https://habrastorage.org/webt/jn/x2/-f/jnx2-fwuhcewoy4aodelx7ugqbk.jpeg"><br><p>  <em>Dos cables soldados a RX y TX</em> </p><br><p>  Estudi√© un poco el diagrama de la figura "Diagrama de temporizaci√≥n de la etapa 41 - Tx": el tiempo de un pulso, aparentemente, es de 1 Œºs, y para seis bits: 6.3 Œºs.  Habiendo recalculado el valor en baudios, recib√≠ unos 950,000 baudios, la velocidad UART est√°ndar m√°s cercana es 921600 baudios.  Creo que esta discrepancia se obtiene debido al error de medici√≥n del analizador l√≥gico, no tom√© el dispositivo m√°s valioso, sino el "beb√©" chino.  Despu√©s de configurar los par√°metros en la ventana del programa Terminal 1.9b, pude observar los bytes entrantes del ASM1051 MK durante su funcionamiento. </p><br><img src="https://habrastorage.org/webt/fa/de/pc/fadepckvko4t2dyacaqt93hidao.png"><br><p>  <em>Ventana de programa del terminal 1.9b durante la operaci√≥n del adaptador</em> </p><br><p>  <strong><em>Conclusi√≥n</em></strong> </p><br><p>  El ASM1051 MK tiene un m√≥dulo de hardware UART.  El registro para enviar datos tiene la direcci√≥n 0xC001.  La velocidad de datos es de 921600 baudios.  Hay un poco de parada.  La pierna 41 es Tx y la pierna 40 es Rx (aunque esto no es exacto). </p><br><h2 id="nahodka--3">  Encuentra el n√∫mero 3 </h2><br><p>  Desplaz√°ndose por el c√≥digo en el desensamblador, agregando comentarios, puede encontrar construcciones m√°s dif√≠ciles que escribir un n√∫mero en un registro.  As√≠ que me encontr√© con un controlador interesante, parte del cual en C, parec√≠a un <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/zq/ra/nr/zqranrtexseqh7xpj0ynpjav9su.png"><br><p>  <em>El controlador de comandos del registro con la direcci√≥n 0x800F</em> </p><br><p>  Comprendiendo que en alg√∫n lugar en alg√∫n lugar se deben procesar <a href="https://en.wikipedia.org/wiki/SCSI_command">los comandos SCSI</a> , comenc√© a buscar entre ellos bytes con los que se compara el contenido del registro con la direcci√≥n 0x800F en la figura anterior.  Result√≥ que las primeras cuatro ramas verifican los comandos Leer (10), Escribir (10), Leer (16), Escribir (16).  No hay duda de que este es un controlador de comandos SCSI.  Luego, mir√© una funci√≥n que se llama si el comando que entr√≥ no es de lectura / escritura (u_Switch).  Dependiendo del byte en el registro con la direcci√≥n 0x16A (el valor se toma de 0x800F), lee la direcci√≥n a la que llegaremos cuando salgan de esta funci√≥n.  Esto es similar a <code>switch ()</code> . </p><br><img src="https://habrastorage.org/webt/8c/ni/xf/8cnixfxf9a1bcyzv0ttlsgpmcqo.png"><br><p>  <em>Cambiar comandos SCSI</em> </p><br><p>  Como ya determin√© el byte con el que comparo el comando SCSI que entr√≥ en el adaptador, r√°pidamente arregl√© la correspondencia de direcciones por comandos.  Entonces, por ejemplo, en la figura anterior se puede ver que si el byte 0x1A estuviera en el registro con la direcci√≥n 0x16A, luego de salir de la funci√≥n u_Switch ir√≠amos a la direcci√≥n 0x1B85.  Curiosamente, no todos los bytes en comparaci√≥n con u_Switch est√°n definidos en el est√°ndar SCSI.  Es decir, el adaptador puede procesar los bytes 0xE6 o 0xDF, pero el est√°ndar no los fija. </p><br><p>  Como puede ver, el adaptador puede ejecutar comandos personalizados y hay funciones de controlador para ellos. </p><br><img src="https://habrastorage.org/webt/4m/kn/bz/4mknbzam6xol2fhb750trvrxs_c.png"><br><p>  <em>P√°gina 13 de <a href="https://usb.org/sites/default/files/usbmassbulk_10.pdf">la clase de almacenamiento masivo de bus serie universal</a></em> </p><br><p>  Preste atenci√≥n al desplazamiento <strong>0x0F</strong> relativo a la direcci√≥n 0x8000.  Antes del procesador, es desde el registro con la direcci√≥n 0x800F donde se lee el comando SCSI.  Si lees detenidamente la tabla de la figura anterior, puedes ver que en el Command Block Wrapper (CBW), el campo CBWCB tambi√©n tiene un desplazamiento de <strong>0x0F</strong> .  Resulta que las direcciones de la memoria RAM ASM1051, que comienzan con 0x8000, pueden ser un b√∫fer USB, como se muestra en la tabla a continuaci√≥n. </p><br><div class="scrollable-table"><table><thead><tr><th>  Direcci√≥n de memoria </th><th>  Descripci√≥n </th></tr></thead><tbody><tr><td>  0x8000-0x8003 </td><td>  dCBWSignature (USBC - en caso de recibir un paquete) </td></tr><tr><td>  0x8004-0x8007 </td><td>  dCBWTag </td></tr><tr><td>  0x8008-0x800B </td><td>  dCBWDataTransferLength </td></tr><tr><td>  0x800C </td><td>  bmdCBWFlag </td></tr><tr><td>  0x800D </td><td>  bCBWLUN </td></tr><tr><td>  0x800E </td><td>  bCBWCBLength </td></tr><tr><td>  0x800F-0x801F </td><td>  CBWCB: comando SCSI y sus par√°metros </td></tr></tbody></table></div><br><p>  La figura siguiente muestra la secci√≥n de c√≥digo donde se produce la comparaci√≥n con la cadena USBC (como deber√≠a ser la firma dCBWSignature) y la firma propuesta se encuentra en la direcci√≥n 0x8000.  Creo que esto es suficiente para asegurarse de que el b√∫fer USB est√© ubicado en la memoria RAM a partir de 0x8000. </p><br><img src="https://habrastorage.org/webt/-t/et/eo/-teteok9i6rotmpp1w6wxy0bun4.png"><br><p>  <em>Compruebe el campo dCBWSignature para que coincida con la cadena USBC</em> </p><br><p>  <strong><em>Conclusiones:</em></strong> </p><br><ol><li>  MK ASM1051 puede manejar no solo los comandos SCSI, que se describen en el est√°ndar. </li><li>  La direcci√≥n inicial del b√∫fer USB es 0x8000.  El comando SCSI se encuentra en el registro con la direcci√≥n 0x800F, lo que significa que habr√° m√°s datos / argumentos de los comandos. </li></ol><br><h2 id="nahodka--4">  Encuentra el n√∫mero 4 </h2><br><p>  Sabiendo que MK puede procesar equipos no est√°ndar, quer√≠a saber qu√© estaban haciendo.  La mayor√≠a de ellos r√°pidamente me obedecieron.  No citar√© el estudio del c√≥digo de estos comandos, ya que esto puede llevar mucho tiempo y puede ser material para un art√≠culo separado titulado "El ensamblador es simple". Describir√© los resultados en la tabla a continuaci√≥n. </p><br><div class="scrollable-table"><table><thead><tr><th>  Comando SCSI </th><th>  Descripci√≥n del equipo </th></tr></thead><tbody><tr><td>  0xE0 </td><td>  Le permite leer los primeros 0x80 bytes de la ROM.  En el futuro, llamar√© a esta parte de la memoria el <em>pre√°mbulo</em> (s√≠, esos mismos 0x80 bytes en los que hay l√≠neas <code>asmedia</code> y <code>ASM1051</code> ) </td></tr><tr><td>  0xE1 </td><td>  Escribe los primeros 0x80 bytes en ROM </td></tr><tr><td>  0xE3 </td><td>  Escribe en la memoria ROM desde 0x80 direcciones cualquier n√∫mero de bytes.  El argumento (como result√≥) es el tama√±o del paquete </td></tr><tr><td>  0xE4 </td><td>  Lee el bloque de bytes de la RAM ASM1051.  Como argumento, toma la direcci√≥n inicial y el n√∫mero de bytes que leemos </td></tr><tr><td>  0xE5 </td><td>  Escribe un byte en RAM en </td></tr><tr><td>  0xE7 </td><td>  Lee el √∫ltimo paquete recibido en el b√∫fer ATA. </td></tr><tr><td>  0xE8 </td><td>  Reinicia el dispositivo </td></tr></tbody></table></div><br><p>  Admito que no descubr√≠ todos los comandos leyendo funciones en la IDA.  Cuando me top√© con la pared durante la investigaci√≥n, record√© que vi <a href="https://www.usbdev.ru/files/asmedia/asm105mptool/">software y muchos firmware</a> para el ASM1051 cuando buscaba documentaci√≥n sobre √©l.  Con el software encontrado, puede actualizar el firmware y reiniciar el dispositivo.  Por lo tanto, decid√≠ que era hora de usar <a href="https://www.syssoft.ru/HHD-Software/Device-Monitoring-Studio/">Device Monitoring Studio</a> y ver qu√© env√≠a la PC al adaptador durante la actualizaci√≥n. </p><br><p>  Por lo tanto, fue posible entender c√≥mo ocurre el proceso de actualizaci√≥n del firmware: primero se env√≠a el pre√°mbulo (con el comando 0xE1), luego el c√≥digo se escribe con el comando 0xE3, luego todo esto se pule reiniciando (el comando 0xE8).  Para una actualizaci√≥n r√°pida y conveniente, escrib√≠ un script de Python que inserta las l√≠neas necesarias en el pre√°mbulo, luego lee las sumas de verificaci√≥n y actualiza el dispositivo.  Ahora ya no necesito un emulador, tuve la oportunidad de cargar firmware al ASM1051 a trav√©s de USB, puede devolver la ROM nativa a la placa. </p><br><p>  <strong><em>Conclusiones</em></strong> </p><br><p>  Para actualizar el firmware, se deben ejecutar tres comandos SCSI secuencialmente: 0xE1, 0xE3 y 0xE8. </p><br><h2 id="nahodka--5">  Encuentra el n√∫mero 5 </h2><br><p>  Adem√°s de los comandos no documentados, fue interesante observar los controladores de los comandos est√°ndar. </p><br><img src="https://habrastorage.org/webt/be/9e/st/be9estiir9g45o0thkj4bacvsmm.png"><br><p>  <em>Mover el tercer bit del registro 0xC884 al s√©ptimo bit del registro 0x8002</em> </p><br><p>  Hay una prueba interesante en el controlador del comando SCSI MODE SENSE (10).  La figura anterior muestra parte del c√≥digo de funci√≥n.  Se puede ver que el tercer bit se lee desde el registro <strong>0xC884</strong> .  Luego, el valor de este bit se establece en el registro en 0x8002. </p><br><p>  Lo interesante aqu√≠ es que el registro <strong>0xC884</strong> no se inicializa en ninguna parte del c√≥digo, lo que significa que lo m√°s probable es que sea hardware. </p><br><img src="https://habrastorage.org/webt/fc/mw/sh/fcmwsh6pa3zzkpbsfxxici-t4g4.jpeg"><br><p>  <em>Tabla 362 del <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">Manual de referencia de comandos SCSI</a></em> </p><br><p>  Adem√°s, si mira la documentaci√≥n para <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">el comando</a> 0x5A <a href="https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%2520manuals/100293068j.pdf">SCSI</a> (MODE SENSE), queda claro que el adaptador USB-SATA debe responder a la solicitud MODE SENSE.  El tercer byte de la respuesta contiene el s√©ptimo bit de WP (protecci√≥n de escritura - protecci√≥n de escritura).  Por cierto, ya vi el <strong>s√©ptimo</strong> bit en 0x8002, y el <strong>desplazamiento</strong> desde el comienzo del b√∫fer USB (0x8000) es exactamente <strong>3 aqu√≠</strong> . </p><br><p>  <strong><em>Conclusi√≥n</em></strong> </p><br><p>  El adaptador USB-SATA probado lee el tercer bit del registro de hardware en <strong>0xC884</strong> y lo env√≠a al host USB como un bit WP. </p><br><h2 id="nahodka--6">  Encuentra el n√∫mero 6 </h2><br><p>  El registro de hardware encontrado durante la investigaci√≥n del controlador de comando MODE SENSE SCSI es muy similar al GPIO.  Para confirmar esto, decid√≠ tocar las patas ASM1051 con una resistencia activa y leer el valor de registro (comando SCSI 0xE4) con la direcci√≥n <strong>0xC884</strong> .  Para hacer esto, escrib√≠ un script de Python usando comandos SCSI personalizados que monitorean el valor en el registro <strong>0xC884</strong> y lo muestran en la PC. </p><br><div class="scrollable-table"><table><thead><tr><th>  Bits 0xC884 </th><th>  7 7 </th><th>  6 6 </th><th>  5 5 </th><th>  4 4 </th><th>  3 </th><th>  2 </th><th>  1 </th><th>  0 0 </th></tr></thead><tbody><tr><td>  Pierna ASM1051 </td><td>  - </td><td>  - </td><td>  37 </td><td>  - </td><td>  9 9 </td><td>  10 </td><td>  45 </td><td>  44 </td></tr></tbody></table></div><br><p>  Despu√©s de realizar tal experimento, compil√© una tabla en la que mostraba qu√© bits en el registro <strong>0xC884</strong> cambiaron cuando la resistencia ASM1051 toc√≥ las patas.  Resulta que el registro en estudio est√° estrechamente relacionado con el GPIO, pero el intento de escribir en √©l (con el comando SCSI 0xE5) no tuvo √©xito: el valor no cambi√≥. </p><br><p>  Entonces decid√≠ que este registro es de solo lectura o que en alg√∫n lugar est√° prohibido escribir en √©l a nivel de hardware.  Si, por ejemplo, las patas MK se configuraron inicialmente solo para lectura, entonces, probablemente, la escritura en el registro <strong>0xC884</strong> podr√≠a no estar disponible. </p><br><p>  En general, para encontrar los registros asociados con el GPIO, revis√© el c√≥digo de inicializaci√≥n MK.  Escrib√≠ todos los registros cuyas direcciones est√°n cerca de <strong>0xC884</strong> .  Tengo alrededor de 10 de ellos. Les recuerdo que el d√©cimo tramo del MK est√° conectado al LED en el tablero, corresponde al segundo bit en el registro <strong>0xC884</strong> .          ‚Äì <strong>0880</strong> ,            (,    ).  ,   ,   <strong>0880</strong>      (/),   <strong>0884</strong>   ,  - . </p><br><p>         <strong>0880</strong>    ,    <strong>0884</strong>    .     <strong>0884</strong>  .           ASM1051. </p><br><p> <strong><em>:</em></strong> </p><br><p>    GPIO  ASM1051.    <strong>0880</strong>   /   I/O.  0884    I/O. </p><br><h2 id="nahodka--5-prodolzhenie">  ‚Ññ 5.  </h2><br><p>   GPIO-  ,  45-           <strong>0884</strong> .           <strong>WP</strong> ,    USB.       45-    ,    HDD,     ,  . </p><br><img src="https://habrastorage.org/webt/9m/yq/lv/9myqlvzd8guku1qfcllendjrtcc.png"><br><p> <em>     HDD,      45-  </em> </p><br><p>     .       GND 45-      ,      HDD.     . </p><br><p> <strong><em></em></strong> </p><br><p>   45-  ASM1051         HDD. </p><br><h1 id="razrabotka-sobstvennogo-ustroystva">    </h1><br><p>       USB-SATA-.           ASM1051.   ,  -  ,     .   ,     GPIO.    ‚Äì  ASM1051  ,         HDD. ,   ,     (¬´     ¬ª),     ,  ,         USB-SATA-   ASM1051. </p><br><p> ,           footprint  ASM1051,       datasheet  ASM1053.     ,        ASM1051   . </p><br><img src="https://habrastorage.org/webt/mf/9k/pi/mf9kpiav5oxxejflxjfndixzccy.jpeg"><br><p> <em>ASM1051     </em> </p><br><p>    ,       3D- ,    . </p><br><img src="https://habrastorage.org/webt/4n/vk/ea/4nvkearirndsx2wx6lzbv2--iu0.png"><br><p> <em>3D-      </em> </p><br><p>            <strong>WP</strong> .  GPIO ASM1051      ,   UART.  ,      SATA,     HDD.      USB 3.0 Micro-B     Type-C.  HDD      USB,   HDD 3.5"  +12 ,           12  21 .     . </p><br><img src="https://habrastorage.org/webt/zh/ji/wu/zhjiwuyqzibs09gswjbdlths-_g.jpeg"><br><p> <em>    </em> </p><br><h1 id="zaklyuchenie">  Conclusi√≥n </h1><br><p>       ,       . </p><br><p>           -,    ,   .         ¬´ ¬´¬ª,          .        ,       . </p><br><p>   ,    (,   )   embedded-. ,  ,       .      ,    ,    , ,         . </p><br><p>       ,   datasheets,    ,   .       ,  <strong>   !</strong> </p><br><p> <a href="https://raccoonsecurity.ru/"><img src="https://habrastorage.org/webt/6d/ts/lv/6dtslv2uikkshhl7tmsi7fgjp0y.png"></a> </p><br><p> <em>Raccoon Security ‚Äì     ¬´¬ª     , , ,       .</em> <br> <em>        ,         ,     .       <a href="https://raccoonsecurity.ru/internship/"></a> .</em> </p><cut></cut></div></div><p>Source: <a href="https://habr.com/ru/post/485966/">https://habr.com/ru/post/485966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../485950/index.html">Epidemia y censura: ¬øest√°n las autoridades chinas tratando de restringir la difusi√≥n de informaci√≥n sobre el coronavirus?</a></li>
<li><a href="../485952/index.html">Interfaz CLI para Laravel Artisan</a></li>
<li><a href="../485954/index.html">Resumen de Java para el 28 de enero</a></li>
<li><a href="../485958/index.html">[Resumen del administrador] ¬øQu√© sucede si el programa quiere derechos de administrador y usted no</a></li>
<li><a href="../485962/index.html">Investigaci√≥n personal sobre 2019-nCoV</a></li>
<li><a href="../485968/index.html">Y de nuevo eludir las cerraduras. RouterOS + BGP + OSPF</a></li>
<li><a href="../485970/index.html">Treinta entrevistas principales recientemente: desarrollo, dise√±o, ciencia y estilo de vida</a></li>
<li><a href="../485972/index.html">M√©todos de an√°lisis de regresi√≥n en ciencia de datos</a></li>
<li><a href="../485974/index.html">Raspberry Pi y SIM7600E 4G HAT Modem</a></li>
<li><a href="../485986/index.html">Las 5 principales tendencias de localizaci√≥n en 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>