<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌰 🚷 👩🏾 Cloud Key: Cómo construir sus aplicaciones nativas de la nube 🤯 🧛🏿 🈲</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En una publicación anterior, hablamos sobre cómo los servicios en la nube se han convertido en un estándar no escrito para proporcionar servicios de T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cloud Key: Cómo construir sus aplicaciones nativas de la nube</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/437488/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">En una publicación anterior, hablamos sobre</a> cómo los servicios en la nube se han convertido en un estándar no escrito para proporcionar servicios de TI.  Es fácil adivinar que las empresas que aún quieren ganar dinero con las aplicaciones de los usuarios deben adaptarse y crear nuevos productos teniendo en cuenta el enfoque nativo de la nube.  Sin embargo, para los desarrolladores esta es definitivamente una noticia positiva, ya que el uso de tecnologías en la nube les abre nuevas y enormes oportunidades.  Lo principal es poder deshacerse de ellos correctamente. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ze/ib/hs/zeibhsxcrek600zsdhzogdrn4kw.jpeg"></div><a name="habracut"></a><br><h3>  Cuando una aplicación ordena un entorno </h3><br>  Si ya ha leído la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">guía de</a> tecnología en la nube, probablemente recordará que la tecnología de virtualización es una de las "fuentes mágicas" de las nubes.  Gracias a esto, el desarrollador prácticamente no necesita pensar en los parámetros de los servidores en los que funcionará su aplicación.  ¿Por qué dedicar tiempo a esto si un hipervisor o contenedor configurado correctamente puede configurar una máquina con casi cualquier característica que la aplicación necesite para funcionar? <br><br>  El desarrollo de esta idea es el enfoque de Infraestructura como código (IAC).  Su esencia es permitir que los desarrolladores o servicios operativos usen los mismos enfoques que se usan durante la fase de desarrollo para mantener la infraestructura.  Le permite preparar unidades de control de software comunes por adelantado e integrar fácilmente dichos componentes en nuevos proyectos. <br><br>  Las capacidades de los centros de datos modernos ya nos permiten pasar al lenguaje declarativo de la gestión de la infraestructura.  Idealmente, la aplicación debería administrar el grupo de recursos que ocupa en el centro de datos.  Esto permitirá que el desarrollador no quede bloqueado en las limitaciones asociadas con el proceso de trabajar con la infraestructura, cuando sea necesario ordenar y diseñar con anticipación o si los mismos componentes de la infraestructura se repiten en diferentes proyectos. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d_/vy/cn/d_vycnmf4jynq80jkbl0mamnz7w.jpeg"></div><br>  De hecho, el desarrollador o ingeniero realiza una solicitud de extracción, que contiene la configuración de la máquina virtual (kernel, memoria, red, plantilla, etc.), luego el administrador del entorno virtual crea la máquina de forma independiente o crea una nueva instancia de base de datos o inicia el servicio preinstalado, de acuerdo con la configuración en archivo.  Este enfoque es una verdadera salvación cuando se trabaja con big data y redes neuronales.  Las aplicaciones asociadas con estas tecnologías, en algunos casos, requieren cantidades dinámicamente cambiantes de memoria y potencia del procesador. <br><br>  Por ejemplo, para entrenar una red, es necesario "manejar" cientos de gigabytes de información a través de ella, y las nubes le permiten obtener la capacidad requerida para esto a pedido.  Una vez completada la capacitación, los recursos se devuelven al grupo de proveedores y el desarrollador no necesita pensar qué hacer con ellos o cómo configurar la aplicación de otra manera para que continúe funcionando a menor capacidad. <br><br><h3>  Monolito vs.  caos ordenado </h3> <br>  Debido al hecho de que las nubes pueden adaptarse de manera flexible a las necesidades del desarrollador, esto, en teoría, simplifica otra tarea: el problema de escalar aplicaciones.  ¿Por qué teóricamente? <br><br>  Desafortunadamente, la tarea de escalar aplicaciones no es lineal.  Para que la aplicación pueda hacer frente a grandes cargas durante los períodos de máxima asistencia (o computación), no es suficiente solo darle memoria adicional y potencia de procesador.  Absolutamente cada aplicación tradicional tiene un umbral, después del cual ya no puede "digerir" nuevos recursos y demostrar un aumento en el rendimiento.  El problema en este caso no son los recursos, sino la arquitectura de la mayoría de los programas. <br><br>  Este problema es especialmente grave para aplicaciones con una arquitectura monolítica, que, de hecho, son archivos binarios únicos.  Las ventajas de este enfoque son obvias: las aplicaciones monolíticas son bastante simples y lineales.  Todos los escenarios de comportamiento del usuario pueden predecirse, rastrearse y, si es necesario, depurarse. <br><br>  Sin embargo, tal simplicidad tiene un precio.  En primer lugar, estos son los problemas de escalamiento mencionados anteriormente.  En algún momento, incluso la aplicación monolítica más considerada deja de funcionar de manera más eficiente a partir de una actualización de la configuración del servidor en la que se ejecuta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/v8/tg/2k/v8tg2ksy2xlbqhflzrjea4qtzom.jpeg"></div><br>  En segundo lugar, una aplicación monolítica no es tan fácil de transferir a nuevos servidores y esto puede requerir una recompilación completa del programa. <br>  En tercer lugar, dicha aplicación es difícil de mantener y desarrollar.  Cualquier cambio de actualización requiere el ensamblaje completo de todo el programa, y ​​un error en uno de los bloques de código puede provocar la caída de todo el sistema. <br><br>  En busca de ideas sobre cómo resolver estos problemas, se desarrolló otro concepto: la arquitectura orientada a servicios (SOA).  Implica que la aplicación se divide en varios módulos, cada uno de los cuales proporciona a los demás algún tipo de funcionalidad.  Los módulos interactúan entre sí a través de un conjunto de servicios web y pueden acceder de forma independiente a una o sus propias bases de datos. <br><br>  Este enfoque realmente simplifica el soporte del programa y no convierte su actualización "en el trabajo de un zapador", en el que no hay lugar para el error;  pero él también tiene sus defectos.  La clave son los problemas para escalar el desarrollo de tales aplicaciones.  A medida que el programa crece, se hace cada vez más difícil "insertar" nuevas características en los paquetes 5-10 aprobados originalmente por el arquitecto.  Su número está creciendo, lo que se convierte en problemas con el apoyo. <br><br><h3>  El microservicio como elemento de evolución de la aplicación. </h3><br>  El resultado de la evolución de SOA es la idea de la arquitectura de microservicios, que se utiliza en el diseño de aplicaciones en la nube.  Conceptualmente, las ideas de ambos enfoques son extremadamente similares, y algunos arquitectos ni siquiera seleccionan la arquitectura de microservicios como un paradigma separado, considerándolo un caso especial de SOA. <br><br>  La arquitectura de microservicios implica que la aplicación no consta de una pequeña cantidad de módulos grandes, sino de muchas partes independientes.  A diferencia de un monolito, en una aplicación de microservicio, puede usar varios métodos para la interacción de componentes entre sí.  El sistema no tiene un solo estado predeterminado.  En cambio, cada componente funciona "de acuerdo con la situación": tan pronto como recibe un evento, comienza a funcionar.  Esto permite una arquitectura muy flexible e independiente. <br>  Al mismo tiempo, la cantidad de servicios en la aplicación de microservicios cambia constantemente: algunos se agregan y otros se eliminan.  En el nuevo enfoque, cualquier microservicio puede ser reemplazado y una cadena de microservicios incrustada en su lugar.  Otros servicios continúan funcionando de manera estable, porque no están directamente relacionados.  Esta es la evolución natural del programa.  Gracias a esto, los desarrolladores y arquitectos tienen la oportunidad de cambiar algo rápidamente para responder a los cambios en los requisitos comerciales y superar a los competidores. <br><br>  Además de aumentar la velocidad de actualización de actualizaciones, el uso de la arquitectura de microservicios permite una administración descentralizada.  El equipo responsable del desarrollo de un servicio tiene derecho a determinar su arquitectura interna y sus características.  Tal enfoque, por cierto, ahora está siendo implementado por el Consejo de Arquitectura de Sberbank en el Bloque de Tecnología. <br><br>  Al mismo tiempo, siéntate a desarrollar tu aplicación en la nube, no debes apresurarte con la rapidez de aplastarla en sus elementos constitutivos.  El principal oponente de un enfoque tan irreflexivo es Martin Fowler;  Es uno de los autores de la idea de la arquitectura de microservicios.  Es más fácil usar inicialmente un enfoque monolítico, y luego estimular la evolución de la aplicación de una manera "natural", enfocándose en la ruptura de cuellos de botella y la adición de funciones adicionales. <br><br>  Como resultado, podemos formular la siguiente regla: la tarea del programador cuando trabaja con la arquitectura de microservicios no es solo dividir la aplicación en el número máximo de componentes, sino distinguir deliberadamente entre su responsabilidad de recibir y procesar datos. <br><br><h3>  Cuatro detalles </h3><br>  Además de las muchas ventajas obvias, la arquitectura de microservicios tiene sus propias características, que deben tenerse en cuenta al desarrollar su aplicación en la nube.  En particular, para respaldar el funcionamiento de una aplicación de este tipo, es necesario mantener constantemente requisitos crecientes para la calidad de la gestión de las API internas. <br><br>  Cuando uno de los componentes cambia su interfaz, debe admitir la compatibilidad con versiones anteriores para admitir la versión anterior de su propia API.  Si se observa esta regla, puede cambiar dinámicamente de la versión anterior a la nueva sin fallas.  Si no se resuelve el soporte para la versión anterior de la API, esto amenaza, en el mejor de los casos, con la pérdida de parte de la funcionalidad de la aplicación y, en el peor de los casos, con bloqueos permanentes en su funcionamiento. <br><br>  La segunda característica importante de las aplicaciones de microservicios es la dificultad de encontrar errores en ellas.  Si una aplicación escrita en lógica monolítica o SOA se bloquea, no será difícil encontrar la fuente del problema.  En una aplicación que consta de muchos servicios, la búsqueda de la causa del error puede llevar mucho tiempo debido al hecho de que los datos del usuario a menudo pasan por varios microservicios, y es difícil determinar cuál falla.  Al mismo tiempo, el proceso de búsqueda de errores debe llevarse a cabo con mucho cuidado: cualquier refactorización fallida puede conducir a un colapso del módulo de trabajo y, además del problema inicial, el desarrollador recibirá un segundo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qx/c3/y5/qxc3y5jtqsk6acyimohwkouoils.jpeg"></div><br>  El tercer detalle importante que debe tenerse en cuenta al desarrollar una aplicación en la nube es la forma en que sus componentes interactúan entre sí.  Al igual que en SOA, los servicios utilizan servicios web para intercambiar datos, pero los patrones de interacción, como la transmisión, CQRS, el abastecimiento de eventos, han aparecido en la arquitectura de microservicios.  Por lo general, los desarrolladores esperan que el tiempo de respuesta entre la solicitud y la respuesta en la aplicación sea bastante pequeño.  En un sistema distribuido, uno ni siquiera puede confiar en el hecho de que la respuesta llegará en absoluto. <br><br>  Además, en la arquitectura de las aplicaciones en la nube, los microservicios utilizan varias bases de datos que son las más adecuadas para resolver sus problemas específicos.  Por ejemplo, las cuadrículas pueden leer rápidamente, pero difícilmente pueden hacer frente a una gran cantidad de operaciones de cambio de datos.  Tal base es muy adecuada para mantener cuentas de depósito; rara vez cambian.  Otro tipo de operación es el procesamiento;  puede haber docenas de cambios en cada mapa en él todos los días y, por el contrario, hay pocas lecturas de datos. <br><br>  Finalmente, el cuarto hecho que debe recordar al desarrollar una aplicación en la nube es que la arquitectura de microservicios se centra principalmente en el uso de servicios sin estado.  En este caso, no vayas a los extremos.  Algunos servicios, si es necesario, aún pueden proporcionar apoyo estatal si la lógica empresarial lo requiere, y deben diseñarse con especial cuidado. <br><br>  Por ejemplo: si el usuario solicita un préstamo, el sistema que recibió la solicitud debe guardar este estado para transferirlo a otros servicios.  Pero el servicio responsable de encontrar información en el archivo interno de historiales crediticios puede no guardar su estado y olvidarse de los datos sobre el nombre de usuario que buscó hace un par de minutos; de todos modos, después de un momento llegará una nueva solicitud (aunque en este proceso puede ser diferente comportamiento del servicio). <br><br>  Todos los ejemplos y prácticas descritos anteriormente ya son utilizados activamente por los líderes de la industria global de TI.  Por ejemplo, Netflix es pionero en el desarrollo de la arquitectura de microservicios.  La compañía ha lanzado muchas aplicaciones de código abierto, bibliotecas y un marco para monitorear, equilibrar y registrar aplicaciones de microservicios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/437488/">https://habr.com/ru/post/437488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../437478/index.html">Que debemos construir un camino. Parte 1</a></li>
<li><a href="../437480/index.html">4 novelas visuales para aprender inglés</a></li>
<li><a href="../437482/index.html">Pregúntele a Ethan: si la luz se contrae y se expande con el espacio, ¿cómo podemos detectar ondas gravitacionales?</a></li>
<li><a href="../437484/index.html">Cómo realicé con éxito seis entrevistas en Silicon Valley</a></li>
<li><a href="../437486/index.html">AlphaStar: un nuevo sistema de inteligencia artificial para StarCraft II de DeepMind (traducción completa)</a></li>
<li><a href="../437492/index.html">Conferencia Lua en Moscú 2019</a></li>
<li><a href="../437494/index.html">Conferencia Lua en Moscú 2019</a></li>
<li><a href="../437496/index.html">Sobre variables en programación</a></li>
<li><a href="../437500/index.html">Acerca de cosas "invisibles" importantes: confianza, cultura y valores</a></li>
<li><a href="../437502/index.html">Dejaré de tirar lo bueno a la basura</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>