<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèª üëäüèø ‚ÜôÔ∏è Automa√ß√£o para os mais pequenos. Parte 1.1. No√ß√µes b√°sicas de virtualiza√ß√£o üïê üëÉüèº üçâ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O artigo anterior analisou a arquitetura de uma rede virtualizada, underlay overlay, o caminho do pacote entre VMs e muito mais. 
 Roman Gorge foi ins...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Automa√ß√£o para os mais pequenos. Parte 1.1. No√ß√µes b√°sicas de virtualiza√ß√£o</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467801/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O artigo anterior</a> analisou a arquitetura de uma rede virtualizada, underlay overlay, o caminho do pacote entre VMs e muito mais. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Roman Gorge foi</a> inspirado por ela e decidiu escrever um problema de revis√£o sobre virtualiza√ß√£o em geral. <br><br>  Neste artigo, abordaremos (ou tentaremos abordar) as perguntas: como a virtualiza√ß√£o das fun√ß√µes de rede realmente ocorre, como o back-end dos principais produtos para iniciar e gerenciar VMs √© implementado e como a comuta√ß√£o virtual funciona (ponte OVS e Linux). <br><br>  O t√≥pico da virtualiza√ß√£o √© amplo e profundo, √© imposs√≠vel explicar todos os detalhes do trabalho do hypervisor (e n√£o √© necess√°rio).  N√≥s nos limitaremos ao conjunto m√≠nimo de conhecimentos necess√°rio para entender a opera√ß√£o de qualquer solu√ß√£o virtualizada, n√£o necessariamente a Telco. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6a7/8ec/aa6/6a78ecaa6f26c867f0a37f010511ef7a.png" width="800"></a> <br><br><h1>  Conte√∫do </h1><br><ul><li>  <b>Introdu√ß√£o e uma breve hist√≥ria da virtualiza√ß√£o</b> </li><li>  <b>Tipos de recursos virtuais - computa√ß√£o, armazenamento, rede</b> </li><li>  <b>Comuta√ß√£o virtual</b> </li><li>  <b>Ferramentas de virtualiza√ß√£o - libvirt, virsh e mais</b> </li><li>  <b>Conclus√£o</b> </li></ul><br><hr><br><br><a name="habracut"></a><br><br><h1>  Introdu√ß√£o e uma breve hist√≥ria da virtualiza√ß√£o </h1><br><br>  A hist√≥ria das modernas tecnologias de virtualiza√ß√£o data de 1999, quando a jovem empresa VMware lan√ßou um produto chamado VMware Workstation.  Este era um produto de virtualiza√ß√£o para aplicativos de desktop / cliente.  A virtualiza√ß√£o do servidor veio um pouco mais tarde na forma do produto ESX Server, que depois evoluiu para o ESXi (ou seja, integrado) - este √© o mesmo produto que √© usado universalmente na TI e na Telco como um hipervisor de aplicativo para servidor. <br><br>  No lado Opensource, dois grandes projetos trouxeram virtualiza√ß√£o para o Linux: <br><ul><li>  KVM (M√°quina Virtual Baseada em Kernel) √© um m√≥dulo do kernel do Linux que permite que o kernel funcione como um hypervisor (cria a infraestrutura necess√°ria para iniciar e gerenciar VMs).  Foi adicionado na vers√£o 2.6.20 do kernel em 2007. </li><li>  QEMU (Quick Emulator) - emula diretamente o hardware de uma m√°quina virtual (CPU, disco, RAM, qualquer coisa, incluindo uma porta USB) e √© usado em conjunto com o KVM para obter um desempenho quase "nativo". </li></ul><br><br><blockquote>  De fato, no momento, toda a funcionalidade do KVM est√° dispon√≠vel no QEMU, mas isso n√£o √© importante, pois a maioria dos usu√°rios de virtualiza√ß√£o Linux n√£o usa diretamente o KVM / QEMU, mas os acessa por pelo menos um n√≠vel de abstra√ß√£o, mas mais tarde. <br></blockquote><br><br>  Hoje, o VMware ESXi e o Linux QEMU / KVM s√£o os dois principais hipervisores que dominam o mercado.  Eles tamb√©m s√£o representantes de dois tipos diferentes de hipervisores: <br><ul><li>  Tipo 1 - o hipervisor √© executado diretamente no hardware (bare-metal).  Este √© VMware ESXi, Linux KVM, Hyper-V </li><li>  Tipo 2 - o hypervisor √© iniciado dentro do SO Host (sistema operacional).  Esta √© a VMware Workstation ou Oracle VirtualBox. </li></ul><br><br>  Uma discuss√£o sobre o que √© melhor e o que √© pior est√° al√©m do escopo deste artigo. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d74/dfe/fa6/d74dfefa6a9c07a43bca6f4a07db1a3d.gif" width="600"><br><br>  Os produtores de ferro tamb√©m tiveram que fazer sua parte para garantir um desempenho aceit√°vel. <br><br>  Talvez o mais importante e mais usado seja o Intel VT (Virtualization Technology) - um conjunto de extens√µes desenvolvido pela Intel para seus processadores x86 que s√£o usados ‚Äã‚Äãpara a opera√ß√£o efetiva do hipervisor (e, em alguns casos, s√£o necess√°rios, por exemplo, o KVM n√£o funcionar√° sem o VT ativado -x e sem ele, o hipervisor √© for√ßado a se envolver em emula√ß√£o puramente de software, sem acelera√ß√£o de hardware). <br>  Duas dessas extens√µes s√£o mais conhecidas - VT-x e VT-d.  O primeiro √© importante para melhorar o desempenho da CPU durante a virtualiza√ß√£o, pois fornece suporte de hardware para algumas de suas fun√ß√µes (com o c√≥digo VT-x 99,9% de SO convidado √© executado diretamente no processador f√≠sico, produzindo sa√≠das para emula√ß√£o apenas nos casos mais necess√°rios), o segundo √© para conectar dispositivos f√≠sicos diretamente para uma m√°quina virtual (para fun√ß√µes virtuais de encaminhamento (VF) SRIOV, por exemplo, o VT-d <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">deve estar ativado</a> ). <br><br>  O pr√≥ximo conceito importante √© a diferen√ßa entre virtualiza√ß√£o completa e para-virtualiza√ß√£o. <br>  A virtualiza√ß√£o completa √© boa, pois permite executar qualquer sistema operacional em qualquer processador; no entanto, √© extremamente ineficiente e absolutamente inadequado para sistemas altamente carregados. <br>  Para-virtualiza√ß√£o, em resumo, √© quando o SO convidado entende que est√° sendo executado em um ambiente virtual e coopera com o hipervisor para obter maior efici√™ncia.  Ou seja, a interface guest-hypervisor √© exibida. <br>  A grande maioria dos sistemas operacionais usados ‚Äã‚Äãhoje tem suporte para para-virtualiza√ß√£o - no kernel do Linux, isso apareceu desde a vers√£o 2.6.20 do kernel. <br><br>  Para que uma m√°quina virtual funcione, n√£o s√£o necess√°rios apenas um processador virtual (vCPU) e mem√≥ria virtual (RAM); tamb√©m √© necess√°ria a emula√ß√£o de dispositivos PCI.  Na verdade, √© necess√°rio um conjunto de drivers para gerenciar interfaces de rede virtual, discos e assim por diante. <br>  No hypervisor KVM do Linux, essa tarefa foi resolvida implementando o <b>virtio</b> , uma estrutura para desenvolver e usar dispositivos de E / S virtualizados. <br>  O Virtio √© um n√≠vel adicional de abstra√ß√£o, que permite emular v√°rios dispositivos de E / S em um hypervisor para-virtualizado, fornecendo uma interface unificada e padronizada para o lado da m√°quina virtual.  Isso permite reutilizar o c√≥digo do driver virtio para v√°rios dispositivos inerentes.  Virtio consiste em: <br><ul><li>  Driver front-end - o que h√° na m√°quina virtual </li><li>  Driver de backend - o que h√° no hypervisor </li><li>  Driver de transporte - o que conecta o back-end e o front-end </li></ul><br>  Essa modularidade permite alterar as tecnologias usadas no hipervisor sem afetar os drivers na m√°quina virtual (esse momento √© muito importante para as tecnologias de acelera√ß√£o de rede e solu√ß√µes em nuvem em geral, mas mais sobre isso posteriormente). <br>  Ou seja, existe uma conex√£o convidado-hipervisor quando o SO convidado "sabe" que est√° sendo executado em um ambiente virtual. <br><blockquote>  Se voc√™ alguma vez escreveu uma pergunta na RFP ou respondeu a uma pergunta na RFP "O virtio √© suportado no seu produto?"  Era apenas para dar suporte ao driver virtio do front-end. <br></blockquote><br><br><h1>  Tipos de recursos virtuais - computa√ß√£o, armazenamento, rede </h1><br>  Em que consiste uma m√°quina virtual? <br>  Existem tr√™s tipos principais de recursos virtuais: <br><br><ul><li>  computa√ß√£o - processador e RAM </li><li>  storage - disco do sistema da m√°quina virtual e armazenamento em bloco </li><li>  rede - placas de rede e dispositivos de entrada / sa√≠da </li></ul><br><br><hr><br><br><h1>  Computar </h1><br><br><h2>  CPU </h2><br>  Teoricamente, o QEMU √© capaz de emular qualquer tipo de processador e seus sinalizadores e funcionalidades correspondentes; na pr√°tica, eles usam o modelo de host e desativam os sinalizadores no sentido hor√°rio antes de transferi-los para o SO convidado, ou usam o modelo nomeado e ativam / desativam sinalizadores no sentido hor√°rio. <br><br>  Por padr√£o, o QEMU emular√° um processador que o SO convidado reconhecer√° como CPU virtual do QEMU.  Esse n√£o √© o tipo mais ideal de processador, especialmente se um aplicativo em execu√ß√£o em uma m√°quina virtual usa sinalizadores de CPU para seu trabalho.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Saiba mais sobre os diferentes modelos de CPU no QEMU</a> . <br><br>  O QEMU / KVM tamb√©m permite controlar a topologia do processador, o n√∫mero de threads, o tamanho do cache, vincular a vCPU ao n√∫cleo f√≠sico e muito mais. <br><br>  Se isso √© necess√°rio para uma m√°quina virtual ou n√£o, depende do tipo de aplicativo em execu√ß√£o no SO convidado.  Por exemplo, √© um fato bem conhecido que, para aplicativos que processam pacotes com alto PPS, √© importante fazer a <b>fixa√ß√£o da CPU</b> , ou seja, para n√£o permitir que o processador f√≠sico seja transferido para outras m√°quinas virtuais. <br><br><h2>  Mem√≥ria </h2><br>  O pr√≥ximo na fila √© a RAM.  Do ponto de vista do Host OS, uma m√°quina virtual lan√ßada usando QEMU / KVM n√£o √© diferente de nenhum outro processo em execu√ß√£o no espa√ßo do usu√°rio do sistema operacional.  Assim, o processo de aloca√ß√£o de mem√≥ria para uma m√°quina virtual √© realizado pelas mesmas chamadas no SO do kernel, como se voc√™ tivesse lan√ßado, por exemplo, um navegador Chrome. <br><br><blockquote>  Antes de continuar a hist√≥ria da RAM em m√°quinas virtuais, voc√™ precisa discernir e explicar o termo <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NUMA</a></b> - Acesso n√£o uniforme √† mem√≥ria. <br>  A arquitetura dos servidores f√≠sicos modernos envolve a presen√ßa de dois ou mais processadores (CPU) e associados a ela (RAM).  Um monte de processador + mem√≥ria √© chamado de n√≥ ou n√≥.  A comunica√ß√£o entre v√°rios n√≥s NUMA √© realizada atrav√©s de um barramento especial - <b>QPI</b> (QuickPath Interconnect) <br><br>  O n√≥ NUMA local √© alocado - quando o processo em execu√ß√£o no sistema operacional usa o processador e a RAM localizados no mesmo n√≥ NUMA e o n√≥ NUMA remoto - quando o processo em execu√ß√£o no sistema operacional usa o processador e a RAM localizados em diferentes n√≥s da NUMA, isto √©, para a intera√ß√£o do processador e da mem√≥ria, √© necess√°ria a transfer√™ncia de dados atrav√©s do barramento QPI. <br></blockquote><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea3/360/7e9/ea33607e91282db8bda346d7f63cf9fd.png" width="600"><br><br>  Do ponto de vista da m√°quina virtual, a mem√≥ria j√° estava alocada para ela no momento do seu lan√ßamento, mas, na realidade, n√£o √© assim, e o Host OS do kernel aloca novas se√ß√µes de mem√≥ria para o processo QEMU / KVM, pois o aplicativo no SO convidado solicita mem√≥ria adicional (embora tamb√©m possa haver uma exce√ß√£o se voc√™ especificar diretamente QEMU / KVM para alocar toda a mem√≥ria para a m√°quina virtual diretamente na inicializa√ß√£o). <br><br>  A mem√≥ria √© alocada n√£o byte a byte, mas com um determinado tamanho - <b>p√°gina</b> .  O tamanho da p√°gina √© configur√°vel e, teoricamente, pode ser qualquer, mas, na pr√°tica, o tamanho √© de 4kB (padr√£o), 2MB e 1GB.  Os dois √∫ltimos tamanhos s√£o chamados de <b>HugePages</b> e geralmente s√£o usados ‚Äã‚Äãpara alocar mem√≥ria para m√°quinas virtuais que consomem <b>muita</b> mem√≥ria.  O motivo para usar o HugePages no processo de encontrar uma correspond√™ncia entre o endere√ßo virtual da p√°gina e a mem√≥ria f√≠sica no <b>Translation Lookaside Buffer</b> ( <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TLB</a></b> ), que por sua vez √© limitado e armazena informa√ß√µes apenas sobre as √∫ltimas p√°ginas usadas.  Se n√£o houver informa√ß√µes sobre a p√°gina desejada no TLB, ocorrer√° um processo chamado <b>miss TLB</b> e voc√™ precisar√° usar o processador Host OS para encontrar a c√©lula de mem√≥ria f√≠sica correspondente √† p√°gina desejada. <br><br>  Esse processo √© ineficiente e lento, portanto, menos p√°ginas de tamanho maior s√£o usadas. <br>  O QEMU / KVM tamb√©m permite emular v√°rias topologias NUMA para SO convidado, recuperar mem√≥ria para uma m√°quina virtual apenas de um SO Host de n√≥ NUMA espec√≠fico e assim por diante.  A pr√°tica mais comum √© levar a mem√≥ria para uma m√°quina virtual de um n√≥ NUMA local para os processadores alocados √† m√°quina virtual.  O motivo √© o desejo de evitar carga desnecess√°ria no barramento <b>QPI que</b> conecta os soquetes da CPU do servidor f√≠sico (√© claro, isso √© l√≥gico se o servidor tiver 2 ou mais soquetes). <br><br><hr><br><br><h1>  Armazenamento </h1><br>  Como voc√™ sabe, a RAM √© chamada de mem√≥ria operacional porque seu conte√∫do desaparece quando a energia √© desligada ou o sistema operacional √© reiniciado.  Para armazenar informa√ß√µes, voc√™ precisa de um dispositivo de armazenamento persistente (ROM) ou <b>armazenamento persistente</b> . <br>  Existem dois tipos principais de armazenamento persistente: <br><ul><li>  Armazenamento em bloco - um bloco de espa√ßo em disco que pode ser usado para instalar o sistema de arquivos e criar parti√ß√µes.  Se for grosseiro, voc√™ poder√° consider√°-lo um disco comum. </li><li>  Armazenamento de objetos - as informa√ß√µes podem ser salvas apenas como um objeto (arquivo), acess√≠vel via HTTP / HTTPS.  Exemplos t√≠picos de armazenamento de objetos s√£o o AWS S3 ou o Dropbox. </li></ul><br><br>  A m√°quina virtual precisa de <b>armazenamento persistente</b> ; no entanto, como fazer isso se a m√°quina virtual "viver" na RAM do sistema operacional host?  Em resumo, qualquer chamada do SO convidado para o controlador de disco virtual √© interceptada pelo QEMU / KVM e transformada em um registro no disco f√≠sico do SO host.  Esse m√©todo √© ineficiente e, portanto, aqui, assim como para dispositivos de rede, o driver virtio √© usado em vez de emular totalmente um dispositivo IDE ou iSCSI.  Leia mais sobre isso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> .  Assim, a m√°quina virtual acessa seu disco virtual atrav√©s de um driver virtio e, em seguida, o QEMU / KVM faz com que as informa√ß√µes transferidas sejam gravadas no disco f√≠sico.  √â importante entender que, no host OS, um back-end de disco pode ser implementado como uma prateleira CEPH, NFS ou iSCSI. <br><br>  A maneira mais f√°cil de emular o armazenamento persistente √© usar o arquivo em algum diret√≥rio do Host OS como espa√ßo em disco de uma m√°quina virtual.  O QEMU / KVM suporta muitos formatos diferentes desse tipo de arquivo - raw, vdi, vmdk e outros.  No entanto, o formato mais utilizado √© o <b>qcow2</b> (vers√£o 2 do QEMU copy-on-write).  Em geral, qcow2 √© um arquivo estruturado de uma certa maneira, sem qualquer sistema operacional.  Um grande n√∫mero de m√°quinas virtuais √© distribu√≠do na forma de qcow2-images (images) e √© uma c√≥pia do disco do sistema de uma m√°quina virtual, compactada no formato qcow2.  Isso tem v√°rias vantagens - a codifica√ß√£o qcow2 ocupa muito menos espa√ßo do que uma c√≥pia n√£o processada de um disco de bytes em bytes, o QEMU / KVM pode redimensionar um arquivo qcow2, o que significa que √© poss√≠vel alterar o tamanho do disco de uma m√°quina virtual, a criptografia AES qcow2 tamb√©m √© suportada (isso faz sentido, pois a imagem de uma m√°quina virtual pode conter propriedade intelectual). <br><br>  Al√©m disso, quando a m√°quina virtual √© iniciada, o QEMU / KVM usa o arquivo qcow2 como um disco do sistema (eu omito o processo de carregar a m√°quina virtual aqui, embora isso tamb√©m seja uma tarefa interessante), e a m√°quina virtual tem a capacidade de ler / gravar dados no arquivo qcow2 via virtio motorista.  Assim, o processo de captura de imagens de m√°quinas virtuais funciona, pois a qualquer momento o arquivo qcow2 cont√©m uma c√≥pia completa do disco do sistema da m√°quina virtual e a imagem pode ser usada para backup, transfer√™ncia para outro host e muito mais. <br><br>  Em geral, esse arquivo qcow2 ser√° definido no SO convidado como um <i>dispositivo / dev / vda</i> , e o SO convidado particionar√° o espa√ßo em disco em parti√ß√µes e instalar√° o sistema de arquivos.  Da mesma forma, os seguintes arquivos qcow2 conectados pelo QEMU / KVM como <i>dispositivos / dev / vdX</i> podem ser usados ‚Äã‚Äãcomo <b>armazenamento</b> em <b>bloco</b> em uma m√°quina virtual para armazenar informa√ß√µes (√© exatamente assim que o componente Openstack Cinder funciona). <br><hr><br><br><h1>  Rede </h1><br>  Os √∫ltimos da nossa lista de recursos virtuais s√£o placas de rede e dispositivos de E / S.  Uma m√°quina virtual, como um host f√≠sico, precisa de um <b>barramento PCI / PCIe</b> para conectar dispositivos de E / S.  O QEMU / KVM pode emular diferentes tipos de chipsets - q35 ou i440fx (o primeiro suporta PCIe, o segundo suporta PCI herdado), bem como v√°rias topologias PCI, por exemplo, criam barramentos PCI separados (barramento expansor PCI) para os n√≥s NUMA Guest OS. <br><br>  Ap√≥s criar o barramento PCI / PCIe, voc√™ deve conectar um dispositivo de E / S a ele.  Em geral, pode ser qualquer coisa, de uma placa de rede a uma GPU f√≠sica.  E, √© claro, uma placa de rede, totalmente virtualizada (interface e1000 totalmente virtualizada, por exemplo) e para-virtualizada (virtio, por exemplo) ou uma NIC f√≠sica.  A √∫ltima op√ß√£o √© usada para m√°quinas virtuais de plano de dados em que voc√™ precisa obter taxas de pacotes com taxa de linha - roteadores, firewalls etc. <br><br>  Existem duas abordagens principais aqui - <b>passagem de PCI</b> e <b>SR-IOV</b> .  A principal diferen√ßa entre eles √© que, para o PCI-PT, o driver √© usado apenas dentro do SO convidado, e para o SRIOV, o driver SO host (para criar <b>VF - Fun√ß√µes Virtuais</b> ) e o driver SO convidado s√£o usados ‚Äã‚Äãpara controlar o SR-IOV VF.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Juniper escreveu</a> excelentes detalhes sobre PCI-PT e SRIOV. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff1/380/fb7/ff1380fb7061d5294514b79b4a368cfb.png" width="600"><br><br><blockquote>  Para esclarecimento, vale ressaltar que a passagem do PCI e o SR-IOV s√£o tecnologias complementares.  O SR-IOV est√° dividindo uma fun√ß√£o f√≠sica em fun√ß√µes virtuais.  Isso √© feito no n√≠vel do sistema operacional host.  Ao mesmo tempo, o Host OS v√™ as fun√ß√µes virtuais como outro dispositivo PCI / PCIe.  O que ele faz a seguir com eles n√£o √© importante. <br><br>  E o PCI-PT √© um mecanismo para encaminhar qualquer dispositivo PCI do sistema operacional host no sistema operacional convidado, incluindo a fun√ß√£o virtual criada pelo dispositivo SR-IOV <br></blockquote><br><br>  Assim, examinamos os principais tipos de recursos virtuais e o pr√≥ximo passo √© entender como a m√°quina virtual se comunica com o mundo externo por meio de uma rede. <br><hr><br><br><h1>  Comuta√ß√£o virtual </h1><br><br>  Se houver uma m√°quina virtual e houver uma interface virtual nela, √© √≥bvio que surge o problema de transferir um pacote de uma VM para outra.  Nos hipervisores baseados em Linux (KVM, por exemplo), esse problema pode ser resolvido usando a ponte Linux; no entanto, o projeto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Open vSwitch</a> (OVS) ganhou ampla aceita√ß√£o. <br>  Existem v√°rias funcionalidades principais que permitiram que o OVS se espalhasse amplamente e se tornasse o m√©todo de troca de pacotes prim√°rio de fato usado em muitas plataformas de computa√ß√£o em nuvem (como Openstack) e solu√ß√µes virtualizadas. <br><ul><li>  Transfer√™ncia de estado da rede - ao migrar uma VM entre hipervisores, surge a tarefa de transferir ACLs, QoSs, tabelas de encaminhamento L2 / L3 e muito mais.  E o OVS pode fazer isso. </li><li>  Implementa√ß√£o do mecanismo de transfer√™ncia de pacotes (caminho de dados) no kernel e no espa√ßo do usu√°rio </li><li>  Arquitetura CUPS (separa√ß√£o de controle / plano de usu√°rio) - permite transferir a funcionalidade do processamento de pacotes para um chipset especializado (o chipset Broadcom e Marvell, por exemplo, pode fazer isso), controlando-o atrav√©s do OVS do plano de controle. </li><li>  Suporte para m√©todos de controle remoto de tr√°fego - protocolo OpenFlow (oi, SDN). </li></ul><br><br>  A arquitetura OVS √† primeira vista parece bastante assustadora, mas √© apenas √† primeira vista. <br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/18f/4fa/e1e18f4fa99d66a99a4da3c06e1df33a.png" width="600"><br><br>  Para trabalhar com o OVS, voc√™ precisa entender o seguinte: <br><ul><li>  <b>Datapath</b> - pacotes s√£o processados ‚Äã‚Äãaqui.  A analogia √© o tecido de um interruptor de ferro.  O Datapath inclui pacotes de recebimento, processamento de cabe√ßalhos, correspond√™ncias correspondentes na tabela de fluxo, que j√° est√° programada no Datapath.  Se o OVS for executado no kernel, ele ser√° implementado como um m√≥dulo do kernel.  Se o OVS for executado no espa√ßo do usu√°rio, esse √© um processo no Linux do espa√ßo do usu√°rio. </li><li>  <b>vswitchd</b> e <b>ovsdb</b> s√£o daemons no espa√ßo do usu√°rio, que implementa diretamente a funcionalidade do comutador, armazena a configura√ß√£o, define o fluxo para o caminho de dados e o programa. </li><li>  Kit de ferramentas de configura√ß√£o e solu√ß√£o de problemas do OVS - <b>ovs-vsctl, ovs-dpctl, ovs-ofctl, ovs-appctl</b> .  Tudo o que √© necess√°rio para registrar a configura√ß√£o da porta no ovsdb, registrar para qual fluxo deve ser alternado, coletar estat√≠sticas e assim por diante.  Boas pessoas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">escreveram um artigo</a> sobre isso. </li></ul><br><br>  <b>Como o dispositivo de rede de uma m√°quina virtual acaba no OVS?</b> <br><br>  Para resolver esse problema, precisamos interconectar de alguma forma a interface virtual localizada no espa√ßo do usu√°rio do sistema operacional com o caminho de dados OVS localizado no kernel. <br><br>  No sistema operacional Linux, os pacotes s√£o transferidos entre os processos do kernel e do espa√ßo do usu√°rio por meio de duas interfaces especiais.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambas as interfaces usam a grava√ß√£o / leitura de um pacote para / de um arquivo especial para transferir pacotes do processo de espa√ßo do usu√°rio para o kernel e vice-versa - descritor de arquivo (FD) (esse √© um dos motivos para um desempenho ruim de comuta√ß√£o virtual se o caminho de dados OVS estiver no kernel - cada pacote precisa escrever / ler o FD) </font></font><br><br><ul><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TUN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (t√∫nel) - um dispositivo que funciona no modo L3 e permite gravar / ler apenas pacotes IP de / para o FD.</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (toque na rede) - o mesmo que a interface tun + pode executar opera√ß√µes com quadros Ethernet, ou seja, </font><font style="vertical-align: inherit;">trabalhar no modo L2.</font></font></li></ul><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5a2/3fc/fc8/5a23fcfc86e0c6cbfdf8dc80cc562bbf.png" width="800"><br><br>        Host OS    TAP-  <i>ip link</i>  <i>ifconfig</i> ‚Äî  ¬´¬ª  virtio,  ¬´¬ª  kernel Host OS.    ,  TAP-    MAC-   virtio-   . <br><br> TAP-     OVS    <i>ovs-vsctl</i> ‚Äî   ,  OVS  TAP-,       file descriptor. <br><br><blockquote>          , ..    OVS bridge,      ,    OVS,    . <br></blockquote><br><br> ,             ,     ,     OVS bridge     TAP-    ovs-vsctl.        . <br><br>      OVS bridges, ,   Openstack Neutron,         namespace   multi-tenancy. <br><br> <b>       OVS bridges?</b> <br><br>        ‚Äî <b>veth pair</b> . Veth pair       ,   ‚Äî  ,  ¬´¬ª   , ¬´¬ª  . Veth pair       OVS bridges  Linux bridges.      veth pair     namespace Linux OS,   veth pair       namespace     . <br><br><h1>   ‚Äî libvirt, virsh   </h1><br><br>        ,       ,            KVM-. <br>     ,   90      : <br><br><ul><li> libvirt </li><li> virsh CLI </li><li> virt-install </li></ul><br><br><blockquote> ,      CLI-,    , ,     qemu_system_x86_64    virt manager,    .      Cloud-, Openstack, ,    libvirt. <br></blockquote><br><br><h2> libvirt </h2><br> libvirt ‚Äî   open-source ,          .     QEMU/KVM,   ESXi, LXC    . <br>     ‚Äî        XML-     API.    libvirt      ,       <b></b> ,     ,  . <br><br>  , libvirt  -     .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> ,   libvirt. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/115/f2f/b6f115f2f06f3fe06ee4727ec121c865.png" width="700"><br><br>    libvirt ‚Äî           Host OS ‚Äî Ubuntu, CentOS  RHEL, ,  ,       libvirt   .         (apt, yum   ). <br><br>      libvirt    Linux bridge virbr0    . <br><br><blockquote>     Ubuntu Server, ,      ifconfig Linux bridge virbr0 ‚Äî     libvirtd <br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essa ponte do Linux n√£o ser√° conectada a nenhuma interface f√≠sica; no entanto, pode ser usada para comunicar m√°quinas virtuais em um √∫nico hipervisor. O Libvirt certamente pode ser usado junto com o OVS, no entanto, para isso, o usu√°rio deve criar pontes OVS de forma independente usando os comandos OVS apropriados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualquer recurso virtual necess√°rio para criar uma m√°quina virtual (computa√ß√£o, rede, armazenamento) √© representado como um objeto na libvirt. Um conjunto de arquivos XML diferentes √© respons√°vel pelo processo de descri√ß√£o e cria√ß√£o desses objetos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o faz muito sentido descrever o processo de cria√ß√£o de redes virtuais e armazenamentos virtuais em detalhes, pois esse aplicativo est√° bem descrito na documenta√ß√£o da libvirt:</font></font><br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Trabalho em rede</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Armazenamento</a> </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A pr√≥pria m√°quina virtual com todos os dispositivos PCI conectados √© chamada de dom√≠nio na terminologia libvirt. Este tamb√©m √© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um objeto dentro da libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que √© descrito por um arquivo XML separado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este arquivo XML √©, estritamente falando, uma m√°quina virtual com todos os recursos virtuais - RAM, processador, dispositivos de rede, discos e muito mais. Geralmente, esse arquivo XML √© chamado libvirt XML ou dump XML. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â improv√°vel que haja uma pessoa que entenda todos os par√¢metros do libvirt XML, no entanto, isso n√£o √© necess√°rio quando houver documenta√ß√£o.</font></font><br><br>   , libvirt XML  Ubuntu Desktop Guest OS    ‚Äî 40-50 .        libvirt XML (NUMA-, CPU-, CPU pinning  ),    libvirt XML         .    ,        ,    libvirt XML. <br><br><h2> virsh CLI </h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O utilit√°rio virsh √© uma linha de comando "nativa" para gerenciar a libvirt. </font><font style="vertical-align: inherit;">Seu principal objetivo √© gerenciar objetos libvirt descritos como arquivos XML. </font><font style="vertical-align: inherit;">Exemplos t√≠picos s√£o iniciar, parar, definir, destruir e assim por diante. </font><font style="vertical-align: inherit;">Ou seja, o ciclo de vida dos objetos - gerenciamento do ciclo de vida. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma descri√ß√£o de todos os comandos e sinalizadores virsh tamb√©m est√° dispon√≠vel na documenta√ß√£o da </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libvirt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virt-install </font></font></h2><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outro utilit√°rio usado para interagir com libvirt. Uma das principais vantagens √© que voc√™ n√£o precisa lidar com o formato XML, mas conv√©m com os sinalizadores dispon√≠veis no virsh-install. O segundo ponto importante √© o mar de exemplos e informa√ß√µes na Web. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Portanto, n√£o importa qual utilit√°rio voc√™ use, em √∫ltima an√°lise, ser√° a libvirt que controlar√° o hipervisor; portanto, √© importante entender a arquitetura e os princ√≠pios de sua opera√ß√£o.</font></font><br><hr><br><br><h1>  Conclus√£o </h1><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neste artigo, examinamos o conjunto m√≠nimo de conhecimento te√≥rico necess√°rio para trabalhar com m√°quinas virtuais. </font><font style="vertical-align: inherit;">Intencionalmente, n√£o dei exemplos pr√°ticos e conclus√µes dos comandos, pois esses exemplos podem ser encontrados na Web e quantos voc√™ quiser, e n√£o me propus a tarefa de escrever um ‚Äúguia passo a passo‚Äù. </font><font style="vertical-align: inherit;">Se voc√™ estiver interessado em um t√≥pico ou tecnologia espec√≠fica, deixe seus coment√°rios e escreva perguntas.</font></font><br><hr><br><br><h1>  Links √∫teis </h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No√ß√µes b√°sicas sobre dispositivos QEMU</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVM / SR-IOV</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li></ul><br><hr><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obrigado </font></font></h1><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexander Shalimov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , meu colega e especialista no desenvolvimento de redes virtuais. </font><font style="vertical-align: inherit;">Para coment√°rios e edi√ß√µes.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yevgeny Yakovlev, meu colega e especialista na √°rea de virtualiza√ß√£o, para coment√°rios e corre√ß√µes. </font></font></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt467801/">https://habr.com/ru/post/pt467801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt467789/index.html">Acabou de chegar o Java 13. O ZGC come√ßou a compartilhar mem√≥ria, o pr√≥prio CDS se lembra de classes e outras maravilhas t√©cnicas</a></li>
<li><a href="../pt467791/index.html">An√°lise de rolagem de p√°gina no Google Data Studio</a></li>
<li><a href="../pt467793/index.html">Pilha de tecnologia chata da empresa de internet one-man</a></li>
<li><a href="../pt467795/index.html">Nota sobre criptomoedas e regulamenta√ß√£o estadual</a></li>
<li><a href="../pt467797/index.html">"Ria por uma quest√£o de": por que voc√™ pode precisar de ferramentas de software que n√£o possuem um aplicativo de "combate"</a></li>
<li><a href="../pt467803/index.html">Simula√ß√£o elementar da intera√ß√£o f√≠sica personalizada em python + matplotlib</a></li>
<li><a href="../pt467807/index.html">Compra e venda de criptomoedas na R√∫ssia: m√©todos, legaliza√ß√£o, riscos</a></li>
<li><a href="../pt467811/index.html">Arquitetura e programa√ß√£o Fairchild Channel F</a></li>
<li><a href="../pt467813/index.html">Revis√£o das mudan√ßas na 17¬™ ordem do FSTEC</a></li>
<li><a href="../pt467815/index.html">A m√≠dia levantou p√¢nico de que "os endere√ßos IP est√£o acabando na R√∫ssia". Como realmente?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>