<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏻 🛎️ 🍰 Lambda：从C ++ 11到C ++ 20。 第二部分 🏺 🧑🏽 👩🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨哈布罗夫斯克 关于开始在“ C ++开发人员”课程中招募新成员的事宜 ，我们与您分享文章“ Lambdas：从C ++ 11到C ++ 20”的第二部分的翻译。 第一部分可以在这里阅读。 



 在本系列的第一部分中，我们从C ++ 03，C ++ 11和C ++ 14的角度看了lambda。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lambda：从C ++ 11到C ++ 20。 第二部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/455978/"> 嗨哈布罗夫斯克 关于开始在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“ C ++开发人员”</a>课程中招募新成员的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事宜</a> ，我们与您分享文章“ Lambdas：从C ++ 11到C ++ 20”的第二部分的翻译。 第一部分可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>阅读。 <br><br><img src="https://habrastorage.org/webt/1v/wn/ec/1vwnecq2qaxmin6vtdxqcuv77ja.png"><br><br> 在本<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">系列</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分中，</a>我们从C ++ 03，C ++ 11和C ++ 14的角度看了lambda。 在本文中，我描述了此强大的C ++功能背后的动机，基本用法，语法以及每种语言标准中的改进。 我还提到了一些临界情况。 <br> 现在是时候进入C ++ 17并展望未来（非常接近！）：C ++ 20。 <a name="habracut"></a><br><br>  <b>参赛作品</b> <br><br> 快速提醒一下：本系列的想法是在我们最近在克拉科夫举行的C ++用户组会议之后提出的。 <br><br> 我们进行了有关lambda表达式“历史”的现场编程会议。 对话是由C ++专家Thomas Kaminsky主持的（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅Thomas的Linkedin个人资料</a> ）。 这是事件： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lambda：从C ++ 11到C ++ 20-C ++用户组克拉科夫</a> 。 <br><br> 我决定从Thomas那里获得代码（在他的允许下！），并以此为基础编写文章在本系列的第一部分中，我谈到了lambda表达式，如下所示： <br><br><ul><li> 基本语法 </li><li>  λ型 </li><li> 呼叫接线员 </li><li> 捕获变量（可变，全局，静态变量，类成员和此指针，仅可移动对象，存储常量）： <br><br><ul><li> 返回类型 </li><li>  IIFE-立即调用函数表达式 </li><li> 转换为函数指针 </li><li> 返回类型 </li><li>  IIFE-立即调用的表达式 </li><li> 转换为函数指针 </li></ul></li><li>  C ++ 14的改进 <br><br><ul><li> 返回类型输出 </li><li> 用初始化器捕获 </li><li> 捕获成员变量 </li><li> 通用Lambda表达式 </li></ul></li></ul><br> 上面的列表只是lambda表达式历史的一部分！ <br><br> 现在，让我们看看C ++ 17中发生了什么变化以及C ++ 20中有什么变化！ <br><br>  <b>C ++ 17的改进</b> <br><br> 关于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Lambda的</a>标准（发布前起草） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">N659</a>部分： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> 。  C ++ 17对lambda表达式进行了两项重大改进： <br><br><ul><li>  constexpr lambda </li><li> 捕捉*这个 </li></ul><br> 这些创新对我们意味着什么？ 让我们弄清楚。 <br><br>  <i><b>constexpr lambda表达式</b></i> <br><br> 从C ++ 17开始，如果可能，该标准将lambda类型的<code>operator()</code>隐式定义为<code>constexpr</code> ： <br><blockquote> 来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">expr.prim.lambda＃4</a> ： <br> 如果相应的lambda表达式的条件参数的声明后跟constexpr，或者它满足constexpr函数的要求，则函数调用运算符是constexpr函数。 </blockquote><br> 例如： <br><br><pre> <code class="bash hljs">constexpr auto Square = [] (int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n*n; }; // implicitly constexpr static_assert(Square(2) == 4);</code> </pre> <br> 回想一下，在C ++ 17 <code>constexpr</code>函数必须遵循以下规则： <br><br><ul><li> 它不应该是虚拟的； <br><br><ul><li> 它的返回类型必须是文字类型； </li><li> 其参数的每种类型都必须是文字类型； </li><li> 它的主体必须是= delete，= default或不包含的复合语句 <br><ul><li>  asm定义 </li><li>  goto表达式， </li><li> 标签 </li><li> 尝试阻止或 </li><li> 不执行初始化的非文字变量，静态变量或流存储变量的定义。 </li></ul></li></ul></li></ul><br> 那一个更实际的例子呢？ <br><br><pre> <code class="bash hljs">template&lt;typename Range, typename Func, typename T&gt; constexpr T SimpleAccumulate(const Range&amp; range, Func func, T init) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;&amp;elem: range) { init += func(elem); } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> init; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr std::array arr{ 1, 2, 3 }; static_assert(SimpleAccumulate(arr, [](int i) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> i * i; }, 0) == 14); }</code> </pre><br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br> 该代码使用<code>constexpr</code> lambda，然后将其传递给简单的<code>SimpleAccumulate</code>算法。 该算法使用了几个C ++ 17元素： <code>constexpr</code>添加到<code>std::array</code> ， <code>std::begin</code>和<code>std::end</code> （在带范围的<code>for</code>循环中使用）现在也都是<code>constexpr</code> ，因此这意味着可以执行所有代码在编译时。 <br><br> 当然，这还不是全部。 <br><br> 您可以捕获变量（前提是它们也为<code>constexpr</code> ）： <br><br><pre> <code class="bash hljs">constexpr int add(int const&amp; t, int const&amp; u) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> t + u; } int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> add(x, n); }; static_assert(lam(10) == 10); }</code> </pre><br> 但是有一种有趣的情况，就是您不进一步传递捕获的变量，例如： <br><br><pre> <code class="bash hljs">constexpr int x = 0; constexpr auto lam = [x](int n) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> n + x };</code> </pre> <br> 在这种情况下，在Clang中我们会收到以下警告： <br><br> <code>warning: lambda capture 'x' is not required to be captured for this use</code> <br> <br> 这可能是由于x在每次使用时都可以更改的事实（除非您进一步转让x或使用此名称的地址）。 <br><br> 但是，请告诉我您是否知道此行为的官方规则。 我仅从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cppreference</a>找到了（但在草案中找不到...） <br><br>  <i><b>（译者注：正如我们的读者所写，我可能是想在每个使用“ x”的地方替换它的值。绝对不可能更改它。）</b></i> <br><br>  <i>Lambda表达式可以读取变量的值，而无需捕获该变量的值</i> <i><br></i>  <i>*具有常量<code>non-volatile</code>整数或枚举类型，并已使用<code>constexpr</code>或</i> <i><br></i>  <i>*是<code>constexpr</code> ，没有可变成员。</i> <br><br> 为未来做好准备： <br><br> 在C ++ 20中，我们将拥有<code>constexpr</code>标准算法，甚至可能还有一些容器，因此<code>constexpr</code> lambda在这种情况下将非常有用。 对于运行时版本和<code>constexpr</code>版本（编译时版本），您的代码看起来都一样！ <br><br> 简而言之： <br><br>  <code>constexpr</code> lambda允许您与样板编程保持一致，并且代码可能更短。 <br><br> 现在让我们继续了解C ++ 17中可用的第二个重要功能： <br><br>  <b>*这里的捕获</b> <br>  <i><b>捕捉*这个</b></i> <br><br> 当我们想吸引班级成员时，您还记得我们的问题吗？ 默认情况下，我们捕获此对象（作为指针！），因此当临时对象超出范围时，我们可能会遇到问题...这可以使用带有初始化程序的capture方法来解决（请参阅本系列的第一部分）。 但是现在，在C ++ 17中，我们有了另一种方式。 我们可以包装*这样的副本： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include &lt;iostream&gt; struct Baz { auto foo() { return [*this] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></code> </pre> <br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br> 使用带有初始值设定项的捕获来捕获所需的成员变量可以保护您避免出现带有临时值的错误，但是当我们要调用类似这样的方法时，我们不能做同样的事情： <br><br> 例如： <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; } void <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>() const { std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } std::string s; };</code> </pre> <br> 在C ++ 14中，使代码更安全的唯一方法是使用初始化程序捕获<code>this</code> ： <br><br><pre> <code class="bash hljs">auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [self=*this] { self.print(); }; }   C ++ 17    : auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [*this] { <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(); }; }</code> </pre> <br> 还有一件事： <br><br> 请注意，如果您在成员函数中编写<code>[=]</code> ，则将隐式捕获它！ 这可能会在将来导致错误...并且它将在C ++ 20中过时。 <br><br> 因此，我们进入下一部分：未来。 <br><br>  <b>C ++ 20的未来</b> <br><br> 在C ++ 20中，我们获得以下功能： <br><br><ul><li> 允许<code>[=, this]</code>作为lambda捕获<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-P0409R2，</a>并通过<code>[=]</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P0806</a>取消对此的隐式捕获 </li><li>  <code>lambda init-capture: ... args = std::move (args)] () {}</code>包扩展<code>lambda init-capture: ... args = std::move (args)] () {}</code> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P0780</a> </li><li> 用于结构化绑定的静态， <code>thread_local</code>和lambda捕获<code>thread_local</code> </li><li>  λ模式（也带有概念） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-P0428R2</a> </li><li> 简化隐式Lambda捕获<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-P0588R1</a> </li><li> 可构造且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可分配的</a> Lambda，但不保存默认状态<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-P0624R2</a> </li><li> 未<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">计算</a>上下文中的Lambda- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P0315R4</a> </li></ul><br> 在大多数情况下，新引入的功能“清除”了lambda的使用，并且允许某些高级用例。 <br><br> 例如，使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P1091，</a>您可以捕获结构化绑定。 <br><br> 我们也有与此相关的说明。 在C ++ 20中，如果在方法中捕获<code>[=]</code> ，则会收到警告： <br><br><pre> <code class="bash hljs">struct Baz { auto <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; GCC 9: warning: implicit capture of <span class="hljs-string"><span class="hljs-string">'this'</span></span> via <span class="hljs-string"><span class="hljs-string">'[=]'</span></span> is deprecated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> C++20</code> </pre> <br> 如果确实需要捕获此内容，则应编写<code>[=, this]</code> 。 <br><br> 还存在与高级用例相关的更改，例如可以默认构造的无状态上下文和无状态lambda。 <br><br> 通过这两项更改，您可以编写： <br><br><pre> <code class="bash hljs">std::map&lt;int, int, decltype([](int x, int y) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> x &gt; y; })&gt; map;</code> </pre> <br> 在句子的第一个版本中阅读这些功能的动机： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P0315R0</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">P0624R0</a> 。 <br><br> 但是，让我们看一下一个有趣的功能：lambda模板。 <br><br>  <b>羔羊图案</b> <br><br> 在C ++ 14中，我们得到了广义的lambda，这意味着声明为auto的参数是模板参数。 <br><br> 对于lambda： <br><br><pre> <code class="bash hljs">[](auto x) { x; }</code> </pre> <br> 编译器生成与以下样板方法匹配的调用语句： <br><br><pre> <code class="bash hljs">template&lt;typename T&gt; void operator(T x) { x; }</code> </pre> <br> 但是无法更改此模板参数并使用实际的模板参数。 在C ++ 20中，这是可能的。 <br><br> 例如，如何限制lambda仅适用于某种类型的向量？ <br><br> 我们可以写一个一般的lambda： <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(const auto&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br> 但是，如果使用int参数调用它（例如<code>foo(10);</code> ），则可能会遇到一些难以理解的错误： <br><br><pre> <code class="bash hljs">prog.cc: In instantiation of <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda(const auto:1&amp;)&gt; [with auto:1 = int]'</span></span>: prog.cc:16:11: required from here prog.cc:11:30: error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to <span class="hljs-string"><span class="hljs-string">'size(const int&amp;)'</span></span> 11 | std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>;</code> </pre><br> 在C ++ 20中，我们可以编写： <br><br><pre> <code class="bash hljs">auto foo = []&lt;typename T&gt;(std::vector&lt;T&gt; const&amp; vec) { std::cout&lt;&lt; std::size(vec) &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; std::cout&lt;&lt; vec.capacity() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; };</code> </pre> <br> 上面的lambda允许模板调用语句： <br><br><pre> <code class="bash hljs">&lt;typename T&gt; void operator(std::vector&lt;T&gt; const&amp; s) { ... }</code> </pre> <br>  template参数在capture子句<code>[]</code> 。 <br><br> 如果使用<code>int (foo(10);)</code>调用它，则会得到更好的消息： <br><br><pre> <code class="bash hljs">note: mismatched types <span class="hljs-string"><span class="hljs-string">'const std::vector&lt;T&gt;'</span></span> and <span class="hljs-string"><span class="hljs-string">'int'</span></span></code> </pre> <br><br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br> 在上面的示例中，编译器可以警告我们有关lambda接口而不是主体内部代码中的不一致之处。 <br><br> 另一个重要方面是，在通用lambda中，您只有变量，而没有模板类型。 因此，如果要访问它，则必须使用decltype（x）（对于带有参数（auto x）的lambda表达式）。 这使某些代码更加冗长和复杂。 <br><br> 例如（使用来自P0428的代码）： <br><br><pre> <code class="bash hljs">auto f = [](auto const&amp; x) { using T = std::decay_t&lt;decltype(x)&gt;; T copy = x; T::static_function(); using Iterator = typename T::iterator; }</code> </pre> <br> 现在您可以这样写： <br><br><pre> <code class="bash hljs">auto f = []&lt;typename T&gt;(T const&amp; x) { T::static_function(); T copy = x; using Iterator = typename T::iterator; }</code> </pre> <br> 在上面的部分中，我们对C ++ 20进行了简要概述，但是我还有另外一个用例。 在C ++ 14中甚至可以使用此技术。 继续阅读。 <br><br>  <b>奖金-使用Lambdas提升</b> <br><br> 当前，当您有函数重载并且想要将其传递给标准算法（或任何需要一些称为对象的东西）时，我们会遇到一个问题： <br><br><pre> <code class="bash hljs">// two overloads: void foo(int) {} void foo(<span class="hljs-built_in"><span class="hljs-built_in">float</span></span>) {} int <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { std::vector&lt;int&gt; vi; std::for_each(vi.begin(), vi.end(), foo); }</code> </pre> <br> 我们从GCC 9（货车）中收到以下错误： <br><br><pre> <code class="bash hljs">error: no matching <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> call to for_each(std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, &lt;unresolved overloaded <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>&gt;) std::for_each(vi.begin(), vi.end(), foo); ^^^^^</code> </pre> <br> 但是，有一个技巧，我们可以使用lambda然后调用所需的重载函数。 <br><br> 以基本形式，对于简单的值类型，对于我们的两个函数，我们可以编写以下代码： <br><br><pre> <code class="bash hljs">std::for_each(vi.begin(), vi.end(), [](auto x) { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> foo(x); });</code> </pre> <br> 以最一般的形式，我们需要再输入一些： <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#define LIFT(foo) \ [](auto&amp;&amp;... x) \ noexcept(noexcept(foo(std::forward&lt;decltype(x)&gt;(x)...))) \ -&gt; decltype(foo(std::forward&lt;decltype(x)&gt;(x)...)) \ { return foo(std::forward&lt;decltype(x)&gt;(x)...); }</span></span></code> </pre> <br> 非常复杂的代码...对吗？  :) <br><br> 让我们尝试解密它： <br><br> 我们创建一个通用的lambda，然后传递我们得到的所有参数。 为了正确地确定它，我们需要指定noexcept和返回值的类型。 这就是为什么我们必须复制调用代码-为了获得正确的类型。 <br> 这样的LIFT宏可在任何支持C ++ 14的编译器中使用。 <br><br> 您可以在此处使用代码： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Wandbox</a> <br><br>  <b>结论</b> <br><br> 在本文中，我们研究了C ++ 17中的重大变化，并概述了C ++ 20中的新功能。 <br><br> 您可能会注意到，随着语言的每次迭代，lambda表达式会与其他C ++元素混合在一起。 例如，在C ++ 17之前，我们不能在constexpr的上下文中使用它们，但是现在有可能。 与以C ++ 14开始的通用lambda相似，它们以模板lambda的形式演变为C ++ 20。 我想念什么吗？ 也许您有一些令人兴奋的例子？ 请在评论中让我知道！ <br><br>  <b>参考文献</b> <br><br>  C ++ 11- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 14- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> <br>  C ++ 17- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">[expr.prim.lambda]</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++中的Lambda表达式|</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">微软文档</a> <br>  Simon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Brand-将重载集传递给函数</a> <br>  Jason Turner- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++每周-剧集128-Lambda的C ++ 20模板语法</a> <br>  Jason Turner- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">C ++每周-剧集41-C ++ 17的constexpr Lambda支持</a> <br><br> 我们邀请所有人参加将于6月14日举行的传统<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">免费网络研讨会</a> 。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN455978/">https://habr.com/ru/post/zh-CN455978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN455966/index.html">英国排名前五的移动应用开发公司</a></li>
<li><a href="../zh-CN455968/index.html">我用25万卢布（1个零件）在太阳能电池板上做一个半齿轮</a></li>
<li><a href="../zh-CN455970/index.html">您想知道的有关SwiftUI的所有信息，但又害怕问</a></li>
<li><a href="../zh-CN455972/index.html">lur嘴：毛毛虫变成了蝴蝶</a></li>
<li><a href="../zh-CN455976/index.html">机柜，模块或单元-数据中心的电源管理应选择什么？</a></li>
<li><a href="../zh-CN455980/index.html">iOS摘要7（5月31日至6月13日）</a></li>
<li><a href="../zh-CN455982/index.html">现在该用AV1视频替换GIF了</a></li>
<li><a href="../zh-CN455984/index.html">如何理解链接有效：指标和KPI链接构建</a></li>
<li><a href="../zh-CN455986/index.html">IT技术人员为什么要动脑子？</a></li>
<li><a href="../zh-CN455988/index.html">血浆现金区块链状态的数据结构</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>