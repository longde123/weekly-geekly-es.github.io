<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂üèæ üéª üèÜ Detalle din√°mico: juegos encubiertos del compilador, p√©rdida de memoria, matices de rendimiento üòä ü§Ωüèª üëÉüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Juegos previos 

 Considere el siguiente c√≥digo: 



//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detalle din√°mico: juegos encubiertos del compilador, p√©rdida de memoria, matices de rendimiento</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466657/"><h2>  Juegos previos </h2><br><br>  Considere el siguiente c√≥digo: <br><br><pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  La firma del m√©todo <i>Marshal.FinalReleaseComObject</i> es la siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FinalReleaseComObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Object o</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><br>  Creamos un objeto COM simple, hacemos algo de trabajo y lo lanzamos inmediatamente.  Parece que lo que podr√≠a salir mal?  S√≠, crear un objeto dentro de un bucle infinito no es una buena pr√°ctica, pero el <i>GC</i> asumir√° todo el trabajo sucio.  La realidad es ligeramente diferente: <br><br><img src="https://habrastorage.org/webt/mt/xo/rx/mtxorxomorvksyskqgtn3b3z7_g.png"><br><br>  Para comprender por qu√© se pierde la memoria, debe comprender c√≥mo funciona la <i>din√°mica</i> .  Ya hay varios art√≠culos sobre este tema en Habr√©, por ejemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este</a> , pero no detallan la implementaci√≥n, por lo que llevaremos a cabo nuestra propia investigaci√≥n. <br><br><a name="habracut"></a><br><br>  Primero, examinaremos en detalle el mecanismo de trabajo <i>din√°mico</i> , luego reduciremos el conocimiento adquirido en una sola imagen y al final discutiremos las razones de esta filtraci√≥n y c√≥mo evitarla.  Antes de sumergirnos en el c√≥digo, aclaremos los datos de origen: ¬øqu√© combinaci√≥n de factores conduce a la fuga? <br><br><h2>  Los experimentos </h2><br><br>  ¬øQuiz√°s crear muchos objetos <i>COM nativos</i> es una mala idea en s√≠ misma?  Vamos a ver: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any native COM object var comType = Type.GetTypeFromCLSID(new Guid("E13B6688-3F39-11D0-96F6-00A0C9191601")); while (true) { dynamic com = Activator.CreateInstance(comType); }</span></span></code> </pre> <br><br>  Todo esta bien esta vez: <br><br><img src="https://habrastorage.org/webt/l2/x4/01/l2x401f_4vsbrysnx1zctwoyfjk.png"><br><br>  Volvamos a la versi√≥n original del c√≥digo, pero cambie el tipo de objeto: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Any managed type include managed COM var type = typeof(int); while (true) { dynamic com = Activator.CreateInstance(type); //do some work Marshal.FinalReleaseComObject(com); }</span></span></code> </pre> <br><br>  Y de nuevo, sin sorpresas: <br><br><img src="https://habrastorage.org/webt/09/lm/bv/09lmbvpiklt9lo43b1fv9wzhdhu.png"><br><br>  Probemos con la tercera opci√≥n: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); while (true) { dynamic com = Activator.CreateInstance(comType); //do some work Marshal.FinalReleaseComObject((object) com); }</span></span></code> </pre> <br><br>  Bueno, ¬°definitivamente deber√≠amos tener el mismo comportamiento!  ¬øEh?  No :( <br><br><img src="https://habrastorage.org/webt/uu/2p/l1/uu2pl1_xtrmpc4kuuy3mwdh_7la.png"><br><br>  Una imagen similar ser√° si declaras com como un <i>objeto</i> o si trabajas con <i>COM administrado</i> .  Resuma los resultados experimentales: <br><br><ol><li>  La creaci√≥n de instancias de objetos <i>COM nativos</i> por s√≠ sola no genera fugas: <i>GC</i> se enfrenta con √©xito a la eliminaci√≥n de memoria </li><li>  Al trabajar con cualquier clase <i>administrada</i> , no se producen fugas </li><li>  Al lanzar expl√≠citamente un objeto a <i>objeto</i> , todo est√° bien tambi√©n </li></ol><br><br>  Mirando hacia el futuro, al primer punto podemos agregar el hecho de que trabajar con objetos <i>din√°micos</i> (m√©todos de llamada o trabajar con propiedades) por s√≠ mismo tampoco causa fugas.  La conclusi√≥n se sugiere a s√≠ misma: se produce una p√©rdida de memoria cuando pasamos un objeto <i>din√°mico</i> (sin conversi√≥n de tipo "manual") que contiene <i>COM nativo</i> , como par√°metro de m√©todo. <br><br><h2>  Necesitamos profundizar </h2><br><br>  Es hora de recordar de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">qu√© se trata</a> esta <i>din√°mica</i> : <br><br><div class="spoiler">  <b class="spoiler_title">Referencia r√°pida</b> <div class="spoiler_text"><blockquote>  C # 4.0 proporciona un nuevo tipo de <b>din√°mica</b> .  Este tipo evita la comprobaci√≥n de tipo est√°tico por parte del compilador.  En la mayor√≠a de los casos, funciona como un tipo de <b>objeto</b> .  En tiempo de compilaci√≥n, se supone que un elemento declarado como <b>din√°mico</b> admite cualquier operaci√≥n.  Esto significa que no necesita pensar de d√≥nde proviene el objeto: desde la API COM, un lenguaje din√°mico como IronPython, usando la reflexi√≥n, o desde otro lugar.  Adem√°s, si el c√≥digo no es v√°lido, se generar√°n errores en tiempo de ejecuci√≥n. <br><br>  Por ejemplo, si el m√©todo <b>exampleMethod1</b> en el siguiente c√≥digo tiene exactamente un par√°metro, el compilador reconoce que la primera llamada al <b>m√©todo ec.exampleMethod1 (10, 4)</b> no es v√°lida porque contiene dos par√°metros.  Esto dar√° como resultado un error de compilaci√≥n.  El compilador no verifica la segunda llamada de m√©todo, <b>dynamic_ec.exampleMethod1 (10, 4)</b> , ya que, por lo tanto, <b>dynamic_ec se</b> declara como <b>din√°mico</b> .  No habr√° errores de compilaci√≥n.  Sin embargo, el error no pasar√° desapercibido para siempre: se detectar√° en tiempo de ejecuci√≥n. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ExampleClass ec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExampleClass(); <span class="hljs-comment"><span class="hljs-comment">//      ,  exampleMethod1    . //ec.exampleMethod1(10, 4); dynamic dynamic_ec = new ExampleClass(); //      ,  //      dynamic_ec.exampleMethod1(10, 4); //        ,  //  ,      dynamic_ec.someMethod("some argument", 7, null); dynamic_ec.nonexistentMethod(); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExampleClass</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExampleClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exampleMethod2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br></blockquote><br></div></div><br><br>  El c√≥digo que usa variables <i>din√°micas</i> sufre cambios significativos durante la compilaci√≥n.  Este c√≥digo: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); Marshal.FinalReleaseComObject(com);</code> </pre> <br><br>  Se convierte en lo siguiente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(typeFromClsid); <span class="hljs-comment"><span class="hljs-comment">// ISSUE: reference to a compiler-generated field if (Foo.o__0.p__0 == null) { // ISSUE: reference to a compiler-generated field Foo.o__0.p__0 = CallSite&lt;Action&lt;CallSite, Type, object&gt;&gt;.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "FinalReleaseComObject", (IEnumerable&lt;Type&gt;) null, typeof (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null) })); } // ISSUE: reference to a compiler-generated field // ISSUE: reference to a compiler-generated field Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, typeof (Marshal), instance);</span></span></code> </pre> <br><br>  Donde <b>o__0</b> es la clase est√°tica generada, y <b>p__0</b> es el campo est√°tico en ella: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">o__0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> CallSite&lt;Action&lt;CallSite, Type, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt; p__0; }</code> </pre> <br><br>  <i>Nota: para cada interacci√≥n con <i>Dynamic</i> , se crea un campo CallSite.</i>  <i>Esto, como se ver√° m√°s adelante, es necesario para optimizar el rendimiento.</i> <br><br>  Tenga en cuenta que no queda ninguna menci√≥n de <i>din√°mica</i> : nuestro objeto ahora se almacena en una variable de tipo <i>objeto</i> .  Veamos el c√≥digo generado.  Primero, se crea un enlace, que describe qu√© y qu√© estamos haciendo: <br><br><pre> <code class="cs hljs">Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"FinalReleaseComObject"</span></span>, (IEnumerable&lt;Type&gt;) <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Foo), (IEnumerable&lt;CSharpArgumentInfo&gt;) <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-literal"><span class="hljs-literal">null</span></span>) })</code> </pre> <br><br>  Esta es una descripci√≥n de nuestra operaci√≥n din√°mica.  Perm√≠tame recordarle que pasamos una variable <i>din√°mica</i> al m√©todo <i>FinalReleaseComObject</i> . <br><br><ul><li>  CSharpBinderFlags.ResultDiscarded: el resultado de la ejecuci√≥n del m√©todo no se utiliza en el futuro </li><li>  "FinalReleaseComObject": el nombre del m√©todo llamado </li><li>  typeof (Foo) - contexto de operaci√≥n;  el tipo de llamada </li></ul><br><br>  <b>CSharpArgumentInfo</b> : descripci√≥n de los par√°metros de enlace.  En nuestro caso: <br><br><ul><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null) - descripci√≥n del primer par√°metro - la clase Marshal: es est√°tica y su tipo debe tenerse en cuenta al vincular </li><li>  CSharpArgumentInfo.Create (CSharpArgumentInfoFlags.None, (string) null): descripci√≥n del par√°metro del m√©todo, generalmente no hay informaci√≥n adicional. </li></ul><br><br>  Si no se trata de llamar a un m√©todo, sino de, por ejemplo, llamar a una propiedad desde un objeto <i>din√°mico</i> , entonces solo habr√° un <b>CSharpArgumentInfo</b> que describa el objeto <i>din√°mico en</i> s√≠. <br><br>  <b>CallSite</b> es un contenedor sobre una expresi√≥n din√°mica.  Contiene dos campos importantes para nosotros: <br><br><ul><li>  Actualizaci√≥n T p√∫blica </li><li>  P√∫blico T Target </li></ul><br><br>  Del c√≥digo generado, est√° claro que cuando se realiza cualquier operaci√≥n, se llama a <b>Target</b> con los par√°metros que lo describen: <br><br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (Marshal), instance);</code> </pre> <br><br>  Junto con el <b>CSharpArgumentInfo</b> descrito anteriormente <b>,</b> este c√≥digo significa lo siguiente: debe llamar al m√©todo FinalReleaseComObject en la clase Marshal est√°tica con el par√°metro de instancia.  En el momento de la primera llamada, el mismo delegado se almacena en <b>Target</b> como en <b>Update</b> .  El delegado de <b>actualizaci√≥n</b> es responsable de dos tareas importantes: <br><br><ol><li>  Vinculando una operaci√≥n din√°mica a una est√°tica (el mecanismo de licitaci√≥n en s√≠ est√° m√°s all√° del alcance de este art√≠culo) </li><li>  Formaci√≥n de cach√© </li></ol><br><br>  Estamos interesados ‚Äã‚Äãen el segundo punto.  Cabe se√±alar aqu√≠ que cuando trabajamos con un objeto din√°mico, necesitamos verificar la validez de la operaci√≥n cada vez.  Esta es una tarea bastante intensiva en recursos, por lo que quiero almacenar en cach√© los resultados de tales comprobaciones.  Con respecto a llamar a un m√©todo con un par√°metro, debemos recordar lo siguiente: <br><br><ol><li>  El tipo en el que se llama el m√©todo </li><li>  El tipo de objeto que pasa el par√°metro (para asegurarse de que se puede convertir al tipo del par√°metro) </li><li>  ¬øEs v√°lida la operaci√≥n? </li></ol><br><br>  Luego, al volver a llamar a <b>Target</b> , no necesitamos realizar enlaces relativamente caros: solo compare los tipos y, si coinciden, llame a la funci√≥n objetivo.  Para resolver este problema, se crea un <i>ExpressionTree</i> para cada operaci√≥n din√°mica, que almacena las <i>restricciones</i> y la <i>funci√≥n objetivo</i> a la que estaba vinculada la expresi√≥n din√°mica. <br><br>  Esta funci√≥n puede ser de dos tipos: <br><br><ul><li>  <i>Error de enlace</i> : por ejemplo, se llama a un m√©todo en un objeto <i>din√°mico</i> que no existe o un objeto <i>din√°mico</i> no se puede convertir al tipo del par√°metro al que se pasa: entonces debe lanzar una excepci√≥n como <i>Microsoft.CSharp.RuntimeBinderException: 'NoSuchMember'</i> </li><li>  El desaf√≠o es legal: entonces solo realice la acci√≥n requerida </li></ul><br><br>  Este <i>ExpressionTree</i> se forma cuando el delegado de <b>actualizaci√≥n</b> se ejecuta y se almacena en <b>Target</b> .  <b>Objetivo</b> : cach√© <i>L0</i> , hablaremos m√°s sobre la cach√© m√°s adelante. <br><br>  Entonces, <b>Target</b> almacena el √∫ltimo <i>ExpressionTree</i> generado a trav√©s del delegado de <b>actualizaci√≥n</b> .  Veamos c√≥mo se ve esta <i>regla</i> como un ejemplo de un tipo <i>administrado</i> pasado al m√©todo <i>Boo</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Foo</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> instance = Activator.CreateInstance(type); Boo(instance); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Boo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> o</span></span></span><span class="hljs-function">)</span></span> { } }</code> </pre> <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso ($arg1 TypeEqual Int32)), returnUnamedLabel_0 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  El bloque m√°s importante para nosotros: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; $$arg1 .TypeEqual System.Int32)</code> </pre> <br><br>  <i>$$ arg0</i> y <i>$$ arg1</i> son los par√°metros con los que se llama <b>Target</b> : <br><pre> <code class="cs hljs">Foo.o__0.p__0.Target((CallSite) Foo.o__0.p__0, &lt;b&gt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;);</code> </pre> <br><br>  Traducido al ser humano, esto significa lo siguiente: <br><br>  Ya hemos verificado que si el primer par√°metro es del tipo <i>Foo</i> y el segundo es <i>Int32</i> , puede llamar a <i>Boo ((objeto) $$ arg1) de</i> forma segura. <br><br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.Object)((System.Int32)$$arg1)); .Default(System.Object) }</span></span></code> </pre> <br><br>  <i>Nota: en caso de un error de enlace, el bloque Label1 se ve as√≠:</i> <br><pre> <code class="cs hljs">.Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Throw .New Microsoft.CSharp.RuntimeBinderException("NoSuchMember")</span></span></code> </pre> <br><br>  Estas comprobaciones se llaman <b>restricciones</b> .  <b>Hay</b> dos tipos de <b>restricciones</b> : por tipo de objeto y por instancia espec√≠fica del objeto (el objeto debe ser exactamente el mismo).  Si falla al menos una de las restricciones, tendremos que volver a verificar la validez de la expresi√≥n din√°mica, para esto llamaremos al delegado de <b>Actualizaci√≥n</b> .  Seg√∫n el esquema que ya conocemos, realizar√° un enlace con nuevos tipos y guardar√° el nuevo <i>ExpressionTree</i> en <b>Target</b> . <br><br><h2>  Cach√© </h2><br><br>  Ya descubrimos que <b>Target</b> es un <b>cach√© L0</b> .  Cada vez que se llama a <b>Target</b> , lo primero que haremos es revisar las restricciones ya almacenadas en √©l.  Si las restricciones fallan y se genera un nuevo enlace, la regla anterior va simult√°neamente a <b>L1</b> y <b>L2</b> .  En el futuro, cuando pierda el cach√© <i>L0</i> , se buscar√°n las reglas de <i>L1</i> y <i>L2</i> hasta que se encuentre una adecuada. <br><br><ul><li>  <i>L1</i> : Las √∫ltimas diez reglas que han dejado <i>L0</i> (almacenadas directamente en <i>CallSite</i> ) </li><li>  <i>L2</i> : las √∫ltimas 128 reglas creadas utilizando una instancia de carpeta espec√≠fica (que es <i>CallSiteBinder</i> , √∫nica para cada <i>CallSite</i> ) </li></ul><br><br>  Ahora finalmente podemos agregar estos detalles en un solo conjunto y describir en forma de algoritmo lo que sucede cuando se <i>llama a Foo.Bar (someDynamicObject)</i> : <br><br>  1. Se crea una carpeta que recuerda el contexto y el m√©todo llamado a nivel de sus firmas <br><br>  2. La primera vez que se llama a la operaci√≥n, se crea <i>ExpressionTree</i> , que almacena: <br>  2.1 <b>Limitaciones</b> .  En este caso, ser√°n dos restricciones sobre el tipo de par√°metros de enlace actuales <br>  2.2 <b>Funci√≥n objetivo</b> : <i>lanzar alguna excepci√≥n</i> (en este caso es imposible, ya que cualquier <i>din√°mica</i> conducir√° con √©xito al objeto) o una llamada al m√©todo <i>Bar</i> <br><br>  3. Compile y ejecute el ExpressionTree resultante <br><br>  4. Cuando recuerde la operaci√≥n, hay dos opciones posibles: <br>  4.1 <b>Limitaciones trabajadas</b> : solo llame a <i>Bar</i> <br>  4.2 Las <b>limitaciones no funcionaron</b> : repita el paso 2 para los nuevos par√°metros de enlace <br><br>  Entonces, con el ejemplo del tipo <i>Gestionado</i> , qued√≥ aproximadamente claro c√≥mo funciona la <i>din√°mica</i> desde adentro.  En el caso descrito, nunca perderemos el cach√©, ya que los tipos son siempre iguales *, por lo tanto, <b>Update se</b> llamar√° exactamente una vez cuando <i>CallSite se</i> inicialice.  Luego, para cada llamada, solo se verificar√°n las restricciones y la funci√≥n objetivo se llamar√° de inmediato.  Esto est√° en excelente acuerdo con nuestras observaciones de memoria: sin c√°lculo, sin fugas. <br><br>  <i>* Por esta raz√≥n, el compilador genera sus CallSites para cada uno: la probabilidad de perder el cach√© L0 se reduce extremadamente</i> <br><br>  Es hora de descubrir c√≥mo este esquema difiere en el caso de <i>los</i> objetos <i>COM nativos</i> .  Echemos un vistazo a <i>ExpressionTree</i> : <br><br><pre> <code class="cs hljs">.Lambda CallSite.Target&lt;System.Action`<span class="hljs-number"><span class="hljs-number">3</span></span>[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]&gt;( Actionsss.CallSite $$site, ConsoleApp12.Foo $$arg0, System.Object $$arg1) { .Block() { .If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 }) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Block() { .Call $$arg0.Boo((System.__ComObject)$$arg1); .Default(System.Object) } } } .Else { .Default(System.Void) }; .Block() { .Constant&lt;Actionsss.Ast.Expression&gt;(IIF((($arg0 TypeEqual Foo) AndAlso {var Param_0; ... }), returnUnamedLabel_1 ({ ... }) , default(Void))); .Label .LabelTarget CallSiteBinder.UpdateLabel: }; .Label .If ( .Call Actionsss.CallSiteOps.SetNotMatched($$site) ) { .Default(System.Void) } .Else { .Invoke (((Actionsss.CallSite`1[System.Action`3[Actionsss.CallSite,ConsoleApp12.Foo,System.Object]])$$site).Update)( $$site, $$arg0, $$arg1) } .LabelTarget #Label1: } }</span></span></code> </pre> <br><br>  Se puede ver que la diferencia est√° solo en la segunda restricci√≥n: <br><br><pre> <code class="cs hljs">.If ($$arg0 .TypeEqual ConsoleApp12.Foo &amp;&amp; .Block(System.Object $var1) { $var1 = .Constant&lt;System.WeakReference&gt;(System.WeakReference).Target; $var1 != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; (System.Object)$$arg1 == $var1 })</code> </pre> <br><br>  Si en el caso del c√≥digo <i>administrado</i> tuvimos dos restricciones en el tipo de objetos, entonces aqu√≠ vemos que la segunda restricci√≥n verifica la equivalencia de instancias a trav√©s de <i>WeakReference</i> . <br><br>  <i>Nota: La restricci√≥n de instancias adem√°s de los objetos COM tambi√©n se usa para TransparentProxy</i> <br><br>  En la pr√°ctica, seg√∫n nuestro conocimiento del funcionamiento de la memoria cach√©, esto significa que cada vez que volvamos a crear un objeto <i>COM</i> en un bucle, <i>perderemos la</i> memoria cach√© <i>L0</i> (y tambi√©n <i>L1 / L2</i> , porque las viejas reglas con enlaces se almacenar√°n all√≠). a instancias antiguas).  La primera suposici√≥n que le pregunta en la cabeza es que el cach√© de reglas est√° fluyendo.  Pero el c√≥digo all√≠ es bastante simple y todo est√° bien all√≠: las viejas reglas se eliminan correctamente.  Al mismo tiempo, usar <i>WeakReference</i> en <i>ExpressionTree</i> no <i>impide</i> que el <i>GC</i> <i>recopile</i> objetos innecesarios. <br><br>  <i>El mecanismo para guardar reglas en el cach√© L1:</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MaxRules = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddRule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T newRule</span></span></span><span class="hljs-function">)</span></span> { T[] rules = Rules; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { Rules = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { newRule }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } T[] temp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rules.Length &lt; (MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>)) { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[rules.Length + <span class="hljs-number"><span class="hljs-number">1</span></span>]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, rules.Length); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { temp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> T[MaxRules]; Array.Copy(rules, <span class="hljs-number"><span class="hljs-number">0</span></span>, temp, <span class="hljs-number"><span class="hljs-number">1</span></span>, MaxRules - <span class="hljs-number"><span class="hljs-number">1</span></span>); } temp[<span class="hljs-number"><span class="hljs-number">0</span></span>] = newRule; Rules = temp; }</code> </pre> <br><br>  Entonces, ¬øcu√°l es el trato?  Intentemos aclarar la hip√≥tesis: se produce una p√©rdida de memoria en alg√∫n lugar al vincular un objeto <i>COM</i> . <br><br><h2>  Experimentos, parte 2 </h2><br><br>  Nuevamente, pasemos de las conclusiones especulativas a los experimentos.  Primero, repitamos lo que el compilador hace por nosotros: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//Simple COM object var comType = Type.GetTypeFromCLSID(new Guid("435356F9-F33F-403D-B475-1E4AB512FF95")); var autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, "Boo", null, typeof(Foo), new CSharpArgumentInfo[2] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, null), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, null) }); var callSite = CallSite&lt;Action&lt;CallSite, Foo, object&gt;&gt;.Create(autogeneratedBinder); while (true) { object instance = Activator.CreateInstance(comType); callSite.Target(callSite, this, instance); }</span></span></code> </pre> <br><br>  Comprobamos: <br><br><img src="https://habrastorage.org/webt/bf/-u/k6/bf-uk6jtzrfh8_pyzaagi0p8cr4.png"><br><br>  La fuga ha sido preservada.  Justo  Pero cual es la razon?  Despu√©s de estudiar el c√≥digo de las carpetas (que dejamos entre par√©ntesis), est√° claro que lo √∫nico que afecta el tipo de nuestro objeto es la opci√≥n de restricci√≥n.  ¬øQuiz√°s no se trata de objetos <i>COM</i> , sino de una carpeta?  No hay muchas opciones, provoquemos enlaces m√∫ltiples para el tipo <i>Gestionado</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> instance = Activator.CreateInstance(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> autogeneratedBinder = Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, <span class="hljs-string"><span class="hljs-string">"Boo"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Foo), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CSharpArgumentInfo[<span class="hljs-number"><span class="hljs-number">2</span></span>] { CSharpArgumentInfo.Create( CSharpArgumentInfoFlags.UseCompileTimeType, <span class="hljs-literal"><span class="hljs-literal">null</span></span>), CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, <span class="hljs-literal"><span class="hljs-literal">null</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> callSite = CallSite&lt;Action&lt;CallSite, Foo, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;&gt;.Create(autogeneratedBinder); callSite.Target(callSite, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, instance); }</code> </pre> <br><br><img src="https://habrastorage.org/webt/-y/an/hj/-yanhjj9jkmqr8bl2adf9rvjsvs.png"><br><br>  Wow!  Parece que lo atrapamos.  El problema no est√° en absoluto con el <i>objeto COM</i> , como nos pareci√≥ inicialmente, solo debido a las limitaciones de la instancia, este es el √∫nico caso en el que el enlace ocurre muchas veces dentro de nuestro bucle.  En todos los dem√°s casos, levant√© el <i>cach√© L0</i> y lo vincul√© una vez. <br><br><h2>  Conclusiones </h2><br><br><h3>  P√©rdida de memoria </h3><br><br>  Si trabaja con variables <i>din√°micas</i> que contienen <i>COM nativo</i> o <i>TransparentProxy</i> , nunca las pase como par√°metros de m√©todo.  Si a√∫n necesita hacer esto, use la conversi√≥n expl√≠cita para <i>objetar</i> y luego el compilador se retrasar√°. <br><br>  <b>Equivocado</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject(com);</span></span></code> </pre> <br><br>  <b>Correctamente</b> : <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = Activator.CreateInstance(comType); <span class="hljs-comment"><span class="hljs-comment">//do some work Marshal.FinalReleaseComObject((object) com);</span></span></code> </pre><br><br>  Como precauci√≥n adicional, intente instanciar tales objetos tan raramente como sea posible.  Actual para todas las versiones de <i>.NET Framework</i> .  (Por ahora) no es muy relevante para.  <i>NET Core</i> , ya que no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hay soporte para</a> objetos <i>COM din√°micos</i> . <br><br><h3>  Rendimiento </h3><br><br>  Es de su inter√©s que las fallas de cach√© ocurran tan raramente como sea posible, ya que en este caso no hay necesidad de encontrar una regla adecuada en cach√©s de alto nivel.  Las fallas en el cach√© <i>L0</i> ocurrir√°n principalmente en el caso de una falta de coincidencia del tipo del objeto <i>din√°mico</i> con las restricciones preservadas. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">dynamic</span></span> com = GetSomeObject(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSomeObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//:      //:         }</span></span></code> </pre> <br><br>  Sin embargo, en la pr√°ctica, probablemente no notar√° la diferencia en el rendimiento a menos que el n√∫mero de llamadas a esta funci√≥n se mida en millones o si la variabilidad de los tipos no es inusualmente grande.  Los costos en caso de fallo en el cach√© <i>L0</i> son tales, <i>N</i> es el n√∫mero de tipos: <br><br><ul><li>  <i>N</i> &lt;10.  Si falla, solo repita las reglas de cach√© <i>L1</i> existentes </li><li>  10 &lt; <i>N &lt;128</i> .  Enumeraci√≥n de cach√© <i>L1</i> y <i>L2</i> (m√°ximo 10 y <i>N</i> iteraciones).  Crear y completar una matriz de 10 elementos. </li><li>  <i>N</i> &gt; 128.  Iterar sobre cach√© <i>L1</i> y <i>L2</i> .  Crear y completar matrices de 10 y 128 elementos.  Si pierde el cach√© <i>L2</i> , vuelva a vincular </li></ul><br><br>  En el segundo y tercer casos, la carga en el GC aumentar√°. <br><br><h2>  Conclusi√≥n </h2><br><br>  Desafortunadamente, no encontramos una raz√≥n real para la p√©rdida de memoria, esto requerir√° un estudio separado de la carpeta.  Afortunadamente, <i>WinDbg</i> proporciona una pista para una mayor investigaci√≥n: algo malo sucede en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DLR</a> .  La primera columna es el n√∫mero de objetos. <br><br><img src="https://habrastorage.org/webt/n_/6g/xf/n_6gxf7etpsj2fg17odfa0varvy.png"><br><br><h2>  Bono </h2><br><br>  <b>¬øPor qu√© la conversi√≥n al <i>objeto</i> evita expl√≠citamente una fuga?</b> <br>  Cualquier tipo puede convertirse en <i>objeto</i> , por lo que la operaci√≥n deja de ser din√°mica. <br><br>  <b>¬øPor qu√© no hay fugas cuando se trabaja con campos y m√©todos de un objeto COM?</b> <br>  As√≠ es como se ve <i>ExpressionTree</i> para el acceso de campo: <br><br><pre> <code class="cs hljs">.If ( .Call System.Dynamic.ComObject.IsComObject($$arg0) ) { .Return <span class="hljs-meta"><span class="hljs-meta">#Label1 { .Dynamic GetMember ComMarks(.Call System.Dynamic2.ComObject.ObjectToComObject($$arg0)) } }</span></span></code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/466657/">https://habr.com/ru/post/466657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../466643/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 314 (del 2 al 8 de septiembre)</a></li>
<li><a href="../466647/index.html">Tel√©fono para caballo y orquesta sin pianista. C√≥mo desarrollar tareas deportivas en la parte delantera</a></li>
<li><a href="../466649/index.html">Fin de semana en auto el√©ctrico</a></li>
<li><a href="../466651/index.html">Elegir entre XML y SQL para rodar scripts LiquiBase usando Java / Spring / H2 como ejemplo</a></li>
<li><a href="../466653/index.html">Juegos de depuraci√≥n para NES: c√≥mo sucede hoy</a></li>
<li><a href="../466659/index.html">Revisi√≥n de Kubecost para ahorrar dinero en Kubernetes en las nubes</a></li>
<li><a href="../466661/index.html">M√°ster a distancia en el extranjero: notas antes de la tesis</a></li>
<li><a href="../466663/index.html">Experimentos simples con el microcontrolador STM32F103 (Blue Tablet)</a></li>
<li><a href="../466665/index.html">Desbordamiento de CSS y p√©rdida de datos</a></li>
<li><a href="../466667/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 379 (del 2 al 8 de septiembre de 2019)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>