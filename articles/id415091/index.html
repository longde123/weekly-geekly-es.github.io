<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§€ ğŸ‘‰ğŸ¼ ğŸŒ¤ï¸ Rust 1.27 Release ğŸ†™ ğŸŒ‡ ğŸ”¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tim pengembangan Rust dengan bangga mengumumkan rilis versi baru Rust: 1.27.0. Rust adalah bahasa pemrograman sistem yang ditujukan untuk keamanan, ke...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.27 Release</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415091/"><p>  Tim pengembangan Rust dengan bangga mengumumkan rilis versi baru Rust: 1.27.0.  Rust adalah bahasa pemrograman sistem yang ditujukan untuk keamanan, kecepatan, dan eksekusi kode paralel. </p><br><p>  Jika Anda memiliki versi Rust sebelumnya yang diinstal menggunakan rustup, maka untuk meningkatkan versi Rust ke versi 1.27.0 Anda hanya perlu melakukan: </p><br><pre><code class="bash hljs">$ rustup update stable</code> </pre> <br><p>  Jika Anda belum menginstal rustup, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menginstalnya</a> dari halaman yang sesuai di situs web kami.  <a href="">Catatan rilis terperinci untuk Rust 1.27.0</a> tersedia di GitHub. </p><br><p>  Kami juga ingin menarik perhatian Anda pada hal ini: sebelum rilis versi 1.27.0, kami menemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kesalahan</a> dalam pemetaan <code>match</code> diperkenalkan di versi 1.26.0, yang dapat menyebabkan perilaku tidak benar.  Karena ditemukan sangat terlambat, sudah dalam proses merilis versi ini, meskipun sudah ada sejak versi 1.26.0, kami memutuskan untuk tidak menghentikan rutinitas dan menyiapkan versi tetap 1.27.1, yang akan dirilis dalam waktu dekat.  Dan tambahan, jika perlu, versi 1.26.3.  Detail dapat ditemukan di catatan rilis yang sesuai. </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1270">  Apa yang termasuk dalam versi stabil 1.27.0 </h2><br><p>  Dalam masalah ini, dua peningkatan bahasa yang besar dan lama ditunggu-tunggu muncul. <a name="habracut"></a>  Tapi pertama-tama, komentar kecil pada dokumentasi: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian</a> sekarang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tersedia</a> di semua buku di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perpustakaan Rust</a> !  Misalnya, Anda dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menemukan "pinjam" di buku "Bahasa Pemrograman Karat"</a> .  Kami harap ini memudahkan Anda menemukan informasi yang Anda butuhkan.  Selain itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Buku</a> baru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tentang rustc telah muncul</a> .  Buku ini menjelaskan cara menggunakan <code>rustc</code> secara langsung, dan cara mendapatkan informasi bermanfaat lainnya, seperti daftar semua pemeriksaan statis. </p><br><h3 id="simd">  SIMD </h3><br><p>  Jadi, sekarang yang penting: mulai sekarang, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur dasar menggunakan SIMD</a> tersedia di Rust!  SIMD berarti "instruksi tunggal, banyak aliran data" (instruksi tunggal, banyak data).  Pertimbangkan fungsinya: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>], b: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>], c: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ((a, b), c) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a.iter().zip(b).zip(c) { *c = *a + *b; } }</code> </pre> <br><p>  Di sini kita mengambil dua irisan integer, menjumlahkan elemen mereka dan menempatkan hasilnya di irisan ketiga.  Kode di atas menunjukkan cara termudah untuk melakukan ini: Anda harus melalui seluruh rangkaian elemen, menyatukannya dan menyimpan hasilnya.  Namun, kompiler sering menemukan solusi yang lebih baik.  LLVM sering "secara otomatis membuat vektor" kode yang sama, di mana kata rumit seperti itu berarti "menggunakan SIMD."  Bayangkan irisan <code>a</code> dan <code>b</code> terdiri dari 16 elemen, keduanya.  Setiap elemen adalah <code>u8</code> , yang berarti irisan akan berisi 128 bit data masing-masing.  Dengan menggunakan SIMD, kita dapat menempatkan irisan <code>a</code> dan <code>b</code> dalam register 128-bit, menambahkannya bersama dengan <em>satu</em> instruksi, dan kemudian menyalin 128 bit yang dihasilkan ke <code>c</code> .  Ini akan bekerja lebih cepat! </p><br><p>  Terlepas dari kenyataan bahwa versi stabil Rust selalu dapat mengambil keuntungan dari vektorisasi otomatis, kadang-kadang kompiler tidak cukup pintar untuk memahami bahwa itu dapat diterapkan dalam kasus ini.  Selain itu, tidak semua CPU mendukung fitur ini.  Oleh karena itu, LLVM tidak selalu dapat menggunakannya, karena program Anda dapat berjalan di berbagai platform perangkat keras.  Oleh karena itu, dalam Rust 1.27, dengan penambahan modul <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>std::arch</code></a> , menjadi mungkin untuk menggunakan instruksi semacam ini <em>secara langsung</em> , yaitu, sekarang kita tidak berkewajiban untuk hanya mengandalkan kompilasi cerdas.  Selain itu, kami memiliki kesempatan untuk memilih implementasi tertentu, tergantung pada berbagai kriteria.  Sebagai contoh: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[cfg(all(any(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">, target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">), target_feature = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"avx2"</span></span></span><span class="hljs-meta">))]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::arch::x86::_mm256_add_epi64; <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::arch::x86_64::_mm256_add_epi64; <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { _mm256_add_epi64(...); } }</code> </pre> <br><p>  Di sini kita menggunakan flag <code>cfg</code> untuk memilih versi kode yang benar tergantung pada platform target: pada <code>x86</code> versinya sendiri akan digunakan, dan pada <code>x86_64</code> sendiri.  Kami juga dapat memilih saat runtime: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>() { <span class="hljs-meta"><span class="hljs-meta">#[cfg(any(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">, target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86_64"</span></span></span><span class="hljs-meta">))]</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_x86_feature_detected!(<span class="hljs-string"><span class="hljs-string">"avx2"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { foo_avx2() }; } } foo_fallback(); }</code> </pre> <br><p>  Di sini kami memiliki dua versi fungsi: satu menggunakan <code>AVX2</code> - jenis SIMD tertentu yang memungkinkan Anda untuk melakukan operasi 256-bit.  Makro <code>is_x86_feature_detected!</code>  akan menghasilkan kode yang memeriksa apakah prosesor mendukung AVX2, dan jika demikian, fungsi <code>foo_avx2</code> akan dipanggil.  Jika tidak, kami akan menggunakan implementasi tanpa AVX, <code>foo_fallback</code> .  Jadi kode kami akan bekerja sangat cepat pada prosesor yang mendukung AVX2, tetapi juga akan bekerja pada prosesor lain, meskipun lebih lambat. </p><br><p>  Semuanya terlihat agak rendah dan tidak nyaman - ya, benar!  <code>std::arch</code> adalah <em>primitif</em> untuk hal semacam ini.  Kami berharap bahwa di masa depan kami akan tetap menstabilkan <code>std::simd</code> dengan kemampuan tingkat tinggi.  Tetapi kemunculan kemampuan SIMD dasar sekarang memungkinkan Anda untuk bereksperimen dengan dukungan tingkat tinggi untuk berbagai perpustakaan.  Misalnya, lihat paket yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih cepat</a> .  Berikut cuplikan kode tanpa SIMD: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lots_of_3s = (&amp;[-<span class="hljs-number"><span class="hljs-number">123.456f32</span></span>; <span class="hljs-number"><span class="hljs-number">128</span></span>][..]).iter() .map(|v| { <span class="hljs-number"><span class="hljs-number">9.0</span></span> * v.abs().sqrt().sqrt().recip().ceil().sqrt() - <span class="hljs-number"><span class="hljs-number">4.0</span></span> - <span class="hljs-number"><span class="hljs-number">2.0</span></span> }) .collect::&lt;<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f32</span></span>&gt;&gt;();</code> </pre> <br><p>  Untuk menggunakan SIMD dalam kode ini dengan <code>faster</code> , Anda perlu mengubahnya seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> lots_of_3s = (&amp;[-<span class="hljs-number"><span class="hljs-number">123.456f32</span></span>; <span class="hljs-number"><span class="hljs-number">128</span></span>][..]).simd_iter() .simd_map(f32s(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), |v| { f32s(<span class="hljs-number"><span class="hljs-number">9.0</span></span>) * v.abs().sqrt().rsqrt().ceil().sqrt() - f32s(<span class="hljs-number"><span class="hljs-number">4.0</span></span>) - f32s(<span class="hljs-number"><span class="hljs-number">2.0</span></span>) }) .scalar_collect();</code> </pre> <br><p>  Itu terlihat hampir sama: <code>simd_iter</code> bukan <code>iter</code> , <code>simd_map</code> bukan <code>map</code> , <code>f32s(2.0)</code> bukannya <code>2.0</code> .  Tetapi pada akhirnya, Anda mendapatkan versi kode SIMD Anda yang bersertifikat. </p><br><p>  Selain <em>itu</em> , Anda tidak akan pernah bisa menulis ini sendiri, tetapi, seperti biasa, perpustakaan tempat Anda bergantung dapat melakukannya.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan telah ditambahkan <code>  regex</code></a> , dan versi barunya akan memiliki akselerasi SIMD tanpa Anda perlu melakukan apa pun! </p><br><h3 id="dyn-trait"> <code>dyn Trait</code> </h3> <br><p>  Pada akhirnya, kami menyesali sintaksis objek objek yang awalnya dipilih di Rust.  Seperti yang Anda ingat, untuk <code>Foo</code> Anda dapat mendefinisikan objek sifat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;Foo&gt;</code> </pre> <br><p>  Namun, jika <code>Foo</code> adalah struktur, itu hanya berarti menempatkan struktur di dalam <code>Box&lt;T&gt;</code> .  Ketika mengembangkan bahasa, kami berpikir bahwa kesamaan seperti itu akan menjadi ide yang baik, tetapi pengalaman menunjukkan bahwa ini mengarah pada kebingungan.  Dan ini bukan hanya <code>Box&lt;Trait&gt;</code> : <code>impl SomeTrait for SomeOtherTrait</code> juga sintaks yang benar secara formal, tetapi Anda hampir selalu perlu menulis <code>impl&lt;T&gt; SomeTrait for T where T: SomeOtherTrait</code> sebagai gantinya.  Ini sama dengan <code>impl SomeTrait</code> , yang terlihat seperti menambahkan metode atau kemungkinan implementasi standar untuk tipe tersebut, tetapi sebenarnya ia menambahkan metode sendiri ke objek tipe.  Akhirnya, dibandingkan dengan sintaks <code>impl Trait</code> baru ditambahkan, sintaks <code>Trait</code> terlihat lebih pendek dan lebih disukai untuk digunakan, tetapi pada kenyataannya ini tidak selalu benar. </p><br><p>  Oleh karena itu, di Rust 1.27, kami menstabilkan sintaks <a href=""><code>dyn Trait</code></a> baru.  Objek sifat sekarang terlihat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  =&gt;  Box&lt;Foo&gt; =&gt; Box&lt;dyn Foo&gt; &amp;Foo =&gt; &amp;dyn Foo &amp;mut Foo =&gt; &amp;mut dyn Foo</span></span></code> </pre> <br><p>  Demikian pula untuk jenis pointer lainnya: <code>Arc&lt;Foo&gt;</code> sekarang <code>Arc&lt;dyn Foo&gt;</code> , dll.  Karena persyaratan kompatibilitas ke belakang, kami tidak dapat menghapus sintaks lama, tetapi kami telah menambahkan pemeriksaan statis <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>bare-trait-object</code></a> , yang secara default menyelesaikan sintaks lama.  Jika Anda ingin melarangnya, maka Anda dapat mengaktifkan pemeriksaan ini.  Kami berpikir bahwa dengan cek dihidupkan secara default, sekarang terlalu banyak peringatan akan ditampilkan. </p><br><blockquote>  Omong-omong, kami sedang mengerjakan alat yang disebut <code>rustfix</code> , yang dapat secara otomatis memperbarui kode Anda ke idiom yang lebih baru.  Dia akan menggunakan pemeriksaan statis serupa untuk ini.  Nantikan pengumuman <code>rustfix</code> di pengumuman mendatang. </blockquote><br><h3 id="must_use-dlya-funkciy">  <code>#[must_use]</code> untuk fungsi </h3><br><p>  Kesimpulannya, efek dari atribut <code>#[must_use]</code> diperluas: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sekarang dapat digunakan untuk fungsi</a> . </p><br><p>  Sebelumnya, ini hanya berlaku untuk jenis, seperti <code>Result &lt;T, E&gt;</code> .  Tetapi sekarang Anda dapat melakukan ini: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[must_use]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">double</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-number"><span class="hljs-number">2</span></span> * x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { double(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">// warning: unused return value of `double` which must be used let _ = double(4); // (no warning) }</span></span></code> </pre> <br><p>  Dengan atribut ini, kami juga <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sedikit meningkatkan pustaka standar</a> : <code>Clone::clone</code> , <code>Iterator::collect</code> dan <code>ToOwned::to_owned</code> akan memberikan peringatan jika Anda tidak menggunakan nilai pengembaliannya, yang akan membantu Anda melihat operasi mahal yang hasilnya Anda abaikan secara tidak sengaja. </p><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h3 id="stabilizaciya-bibliotek">  Stabilisasi perpustakaan </h3><br><p>  API baru berikut telah distabilkan dalam rilis ini: </p><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>DoubleEndedIterator::rfind</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>DoubleEndedIterator::rfold</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>DoubleEndedIterator::try_rfold</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Duration::from_micros</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Duration::from_nanos</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Duration::subsec_micros</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Duration::subsec_millis</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>HashMap::remove_entry</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Iterator::try_fold</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Iterator::try_for_each</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>NonNull::cast</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Option::filter</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>String::replace_range</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>Take::set_limit</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>slice::rsplit_mut</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>slice::rsplit</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>slice::swap_with_slice</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>hint::unreachable_unchecked</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>os::unix::process::parent_id</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>ptr::swap_nonoverlapping</code></a> </li> <li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>process::id</code></a> </li> </ul><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h3 id="uluchsheniya-v-cargo">  Peningkatan Kargo </h3><br><p>  Cargo telah menerima dua peningkatan kecil dalam rilis ini.  Pertama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>  --target-dir</code></a> , yang dapat digunakan untuk mengubah direktori eksekusi target. </p><br><p>  Selain itu, pendekatan Cargo untuk bagaimana menangani target telah diselesaikan.  Cargo mencoba mendeteksi tes, contoh, dan yang dapat dieksekusi dalam proyek Anda.  Namun, konfigurasi eksplisit terkadang diperlukan.  Tetapi dalam implementasi awal, ini bermasalah.  Katakanlah Anda memiliki dua contoh, dan Cargo mendeteksi keduanya.  Anda ingin mengonfigurasi salah satunya, yang Anda tambahkan <code>[[example]]</code> ke <code>Cargo.toml</code> untuk menentukan parameter contoh.  Saat ini, Cargo akan melihat bahwa Anda telah mendefinisikan contoh secara eksplisit, dan karenanya tidak akan mencoba mendeteksi orang lain secara otomatis.  Ini agak menjengkelkan. </p><br><p>  Karenanya, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>  'auto'-  Cargo.toml</code></a> .  Kami tidak dapat memperbaiki perilaku ini tanpa kemungkinan gangguan proyek yang mengandalkannya secara tidak sengaja.  Oleh karena itu, jika Anda ingin mengonfigurasi beberapa sasaran, tetapi tidak semua, Anda dapat mengatur kunci <code>autoexamples</code> menjadi <code>true</code> di bagian <code>[package]</code> . </p><br><p>  Lihat <a href="">catatan rilis untuk lebih</a> jelasnya. </p><br><h2 id="razrabotchiki-1270">  Pengembang 1.27.0 </h2><br><p>  Banyak orang berpartisipasi dalam pengembangan Rust 1.27.  Kami tidak dapat menyelesaikan pekerjaan tanpa Anda masing-masing. </p><br><p>  <a href="">Terima kasih</a> </p><br><p>  <em>Dari seorang penerjemah: Saya mengucapkan terima kasih kepada anggota komunitas ruRust dan secara pribadi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ozkriff</a> atas bantuan mereka dengan terjemahan dan proofreading</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id415091/">https://habr.com/ru/post/id415091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id415075/index.html">Versi ketiga reCAPTCHA berfungsi di latar belakang tanpa disadari oleh pengguna</a></li>
<li><a href="../id415079/index.html">Satu Metrik Untuk Memerintah Mereka Semua - Apakah ada satu metrik universal tunggal?</a></li>
<li><a href="../id415083/index.html">5. Periksa Point ke maksimum. IPS Bagian 1</a></li>
<li><a href="../id415085/index.html">Apa itu CISSP, bagaimana cara mendapatkannya, tidak kehilangan itu dan mengapa itu tidak diperlukan</a></li>
<li><a href="../id415087/index.html">[KASUS] Pencetakan 3D SLA di pabrik elektronik kapal</a></li>
<li><a href="../id415093/index.html">PVT: mengapa menyuntikkan lem secara intravena</a></li>
<li><a href="../id415153/index.html">Persyaratan ideal akan datang kembali</a></li>
<li><a href="../id415155/index.html">Performa di iOS atau cara membongkar utas utama. Bagian 1</a></li>
<li><a href="../id415159/index.html">Pengumuman DevOps-conference DevOops 2018</a></li>
<li><a href="../id415163/index.html">Jaringan nirkabel di pabrik farmasi yang dijaga khusus dan terlindung secara khusus di beberapa tempat di Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>