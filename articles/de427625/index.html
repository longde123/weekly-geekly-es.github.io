<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📮 👩🏿‍🎨 🎅 So schreiben Sie einen Schwachstellenscanner und verdienen Geld mit Exploits 👓 🈺 👩🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TLDR : Wie ich meinen Job als Sicherheitsbeamter kündigte und meinen eigenen Schwachstellenscanner schrieb. 
 Und wie Sie damit Geld verdienen können....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So schreiben Sie einen Schwachstellenscanner und verdienen Geld mit Exploits</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427625/"><p>  <strong>TLDR</strong> : Wie ich meinen Job als Sicherheitsbeamter kündigte und meinen eigenen Schwachstellenscanner schrieb. <br>  Und wie Sie damit Geld verdienen können.  Am Ende befinden sich Teile des Scannercodes und der Spezifikation. </p><br><h3 id="kto-i-chto-vzlamyvaet">  Wer und was bricht </h3><br><p>  In den 1970er Jahren, vor langer Zeit, sah das Internet so aus. </p><br><img src="https://habrastorage.org/webt/ag/00/f-/ag00f-ex3-whltqssyjcwzhkvji.png"><br><p>  Die Hauptbedrohung für ihn waren die Forscher und Enthusiasten, die als erste an die Dokumentation und Netzwerke großer Unternehmen gelangten. </p><br><p>  Seitdem hat sich das Internet stark verändert.  Angriffe auf Netzwerke, Dienste und Webanwendungen sind an der Tagesordnung.  Jeden Tag finden Entwickler und Forscher Dutzende von Schwachstellen.  Parallel dazu werden Zehntausende von Websites gehackt. </p><a name="habracut"></a><br><p>  Dies ist auf der Angriffskarte von Kaspersky Lab deutlich sichtbar.  Es zeigt IDS-Trigger, Schwachstellen-Scans und Botnet-Angriffe an.  Die Karte sieht aus wie ein wunderschönes Bild und hat nur in Russland Millionen von Angriffen pro Tag. </p><br><img src="https://habrastorage.org/webt/se/gc/ob/segcobnpxl3rvjo-x95qb05slay.png"><br><br><p>  Cyberkriminalität wird nicht von Amateuren begangen, sondern von organisierten Gruppen von Dutzenden von Menschen.  Sie tun dies aus Interesse.  Das ist ein Geschäft.  Es sind keine Typen in schwarzen Kapuzen, die nachts "BLACK K0d" vor dem Monitor schreiben.  Dies sind sozial aktive Menschen, die in Büros in verschiedenen Ländern der Welt arbeiten. </p><br><p>  Meine Karriere war so, dass ich mehrere Jahre für die Sicherheit des Netzwerkumfangs und den Schutz von Webanwendungen verantwortlich war.  Über die Erfahrungen aus dieser Zeit werde ich in diesem Artikel berichten. </p><br><p>  Wenn Sie in einer Telekommunikation, einer Bank, einem Anbieter oder einem Entwickler in einem großen Unternehmen arbeiten, und insbesondere wenn Sie eine Sicherheitsperson sind, wissen Sie, dass Sicherheit in einem Unternehmen mit mehr als 10 bis 15 Standorten Müll, Hölle, Tod ist. </p><br><p>  Versuchen wir, die Situation zu verbessern.  Sie sagen, dass Sicherheit ein Prozess ist. <br>  Und es gibt viele Prozesse. </p><br><p>  Listen Sie sie kurz auf: </p><br><ul><li>  Bedrohungsmanagement </li><li>  Schwachstellenmanagement </li><li>  Risikomanagement </li><li>  Patch-Verwaltung </li><li>  Identity &amp; Acess Management </li><li>  Sicherheitsbewusstsein </li><li>  Verwaltung von Sicherheitsanbietern <br>  Und andere. </li></ul><br><p>  Wir werden die im Artikel aufgeführten Arten nicht berücksichtigen, Prost. <br>  Es gibt viele davon, und die Vorteile hängen von der Größe des Unternehmens, den Arten von Assets und ihrer Kritikalität ab. </p><br><p>  Wir werden über einen Prozess sprechen, von dem auch kleine Unternehmen profitieren werden. <br>  Von einem Online-Shop mit Hunderttausenden Rubel Umsatz bis zu einem riesigen Unternehmen mit Dutzenden von Rechenzentren. </p><br><h3 id="obnaruzhenie-uyazvimostey">  Erkennung von Sicherheitslücken </h3><br><p>  Um zu verstehen, wie es Möglichkeiten gibt, uns zu knacken, betrachten wir uns selbst mit den Augen eines Angreifers. </p><br><p>  Die Sicherheitsanalyse besteht aus mehreren Phasen.  Für jede Phase werde ich einen grundlegenden Satz von Dienstprogrammen angeben, die Sie verwenden können. </p><br><ul><li>  Es ist unser Ziel, Informationen darüber zu sammeln, welche IPs, Domänen und Subnetze es sind.  Anstatt an die Haustür zu klopfen, ist es besser, weniger sichere Einstiegspunkte zu finden. <br><pre><code class="hljs powershell">dnsrecon, Fierce, Censys, reverse<span class="hljs-literal"><span class="hljs-literal">-PTR</span></span><span class="hljs-literal"><span class="hljs-literal">-lookup</span></span>.</code> </pre> </li><li>  Analyse von Diensten auf bekannte Schwachstellen (CVE).  Öffentliche Exploits sind für sie üblich. <br><pre> <code class="hljs powershell">Vulners, exploit<span class="hljs-literal"><span class="hljs-literal">-DB</span></span>, NIST, CVEdetails</code> </pre> </li><li>  Analyse von Diensten für schwache Passwörter. <br><pre> <code class="hljs">potator, hydra</code> </pre> </li><li>  Schwachstellenanalyse von Webanwendungen <br><pre> <code class="hljs">Zap, Burp, w3af, Arachni</code> </pre> </li></ul><br><h3 id="kruto">  Cool </h3><br><p>  Ok cool.  Wir haben einen Weg und Werkzeuge, um 1 Site zu überprüfen. <br>  Es wird mehrere Tage dauern, einen Service zu überprüfen und zu analysieren, um ihn gründlich herauszufinden - eine Woche oder länger. </p><br><h3 id="ne-kruto">  Nicht cool </h3><br><p>  Das Problem ist, dass wir möglicherweise mehr als einen Dienst haben.  Und zum Beispiel / 20 Subnetz. <br>  4096 Adressen.  Jeder kann 65535 Dienste haben.  Nicht cool. </p><br><p>  Ja, es gibt automatisierte Lösungen.  Qualys, Acunetix, Nessus, es gibt inländische Anbieter.  Analyse, was sie gut und was schlecht sind, schlage ich vor, für einen anderen Artikel zu verlassen. </p><br><p>  Sie haben meine Probleme nicht gelöst.  Ich entschied, dass ich es reparieren muss.  Er kündigte seinen Job und für ungefähr ein Jahr gingen er und meine Kameraden zur Entwicklung. </p><br><h3 id="kak-napisat-skaner-uyazvimostey">  So schreiben Sie einen Schwachstellenscanner </h3><br><p>  Beginnen wir mit den Anforderungen für das System, das wir erhalten wollten: </p><br><ul><li>  Führt Aufklärung durch und lokalisiert Zieldomänen und IP </li><li>  Überwacht den Netzwerkumfang.  Er sieht, wenn eine neue Adresse im Bereich oder eine Subdomain am geschützten Standort angezeigt wird </li><li>  Überprüft ständig Adressen und sieht, wann Netzwerkports geöffnet und geschlossen werden </li><li>  Findet Schwachstellen und bekannte Banner- / CPE-Exploits </li><li>  Nimmt schwache Passwörter auf </li><li>  Findet Anwendungs- und Betriebssystemkonfigurationsfehler </li><li>  Findet Schwachstellen in CMS und deren Plugins </li><li>  Findet interaktiv XSS, SQLi, XXE, RCE, LFI, RFI und die von OWASP bis 10, die automatisch durchsucht werden können </li><li>  Er tut dies mehr als einmal, überprüft jedoch ständig meine Ressourcen und reagiert, wenn neue Schwachstellen auftreten </li></ul><br><p>  Benutzer sind Eigentümer großer Netzwerkbereiche, dh solcher mit 10 oder mehr Webanwendungen. <br>  Es ist notwendig, täglich parallel nach Web-Schwachstellen, schwachen Passwörtern und Konfigurationsfehlern zu suchen und ausgehende Exploits für Hunderte von IP-Adressen und Websites anzuzeigen. </p><br><p>  Verwenden Sie dazu ein horizontal skalierbares System.  Sie können im laufenden Betrieb neue Knoten und neue Scannertypen hinzufügen.  Jetzt verwendet der Scanner 7 Knoten und ist in 2 interagierende Standorte in Deutschland und den USA unterteilt.  Bei Interesse werden wir darüber in einem anderen Artikel schreiben. </p><br><p>  Wir haben darüber nachgedacht, wie man einen solchen Scanner schreibt.  Wir haben erkannt, dass das Schreiben eines solchen Systems von Grund auf wenig Sinn macht.  Es erforderte umfassende Erfahrung und Verständnis für verschiedene Plattformen, eine eigene Datenbank mit Netzwerkfingerabdrücken, eine eigene Datenbank mit CVE und Exploits für diese sowie ein riesiges System zur Analyse der Sicherheit von Webanwendungen. </p><br><p>  Wo die Produktlizenz dies zulässt, haben wir uns für Open Source-Entwicklungen entschieden.  Es gibt Komponenten, die Closed Source sind, aber für den kommerziellen Gebrauch kostenlos sind.  Es gibt einige selbst geschriebene Open-Source-Projekte. </p><br><p>  Wir haben also ungefähr 20 verschiedene Anwendungen, die die Komponenten sind, die erforderlich sind, um die L3-L7-Niveaus für den automatisierten Pentest abzudecken. </p><br><h3 id="interfeys-dlya-skanera">  Schnittstelle für Scanner </h3><br><p>  Jedes Skript, jeder PoC-Split oder jede Binärdatei akzeptiert unterschiedliche Parameter, um den Scanvorgang zu starten.  Nicht sehr praktisch.  Ich wollte ein einheitliches Format für den Start eines möglichen Scanners. </p><br><p>  Wir haben darüber nachgedacht, was ein möglicher Scanner wissen muss, um das Ziel zu identifizieren.  Eine Tabelle zusammengestellt. </p><br><table><thead><tr><th>  Typ prüfen </th><th>  Daten eingeben </th></tr></thead><tbody><tr><td>  Integration in Exploit- und CVE-Datenbanken </td><td>  Anbieter: Produkt: Version (CPE) </td></tr><tr><td>  PoC-Exploit für den Service </td><td>  IP, Port, CVE </td></tr><tr><td>  Brutilka </td><td>  IP-, Port- und Anwendungsschichtprotokoll </td></tr><tr><td>  CMS-Scanner </td><td>  Domänenport </td></tr><tr><td>  Web Vulnerability Scanner </td><td>  Domäne oder IP-Port </td></tr><tr><td>  Sicherheitslücken im PoC-Web </td><td>  URI </td></tr><tr><td>  Port-Scanner </td><td>  IP </td></tr></tbody></table><br><p>  Nach einer ersten nmap-Prüfung und einem Plugin, das für jeden Host auf CVEdetails zugreift, erhalten wir eine Reihe solcher Objekte.  Wir nennen sie Metadaten. </p><br><p>  JSON-Darstellung: </p><br><pre> <code class="hljs json">           {             <span class="hljs-attr"><span class="hljs-attr">"cves"</span></span>: [],             <span class="hljs-attr"><span class="hljs-attr">"service"</span></span>: <span class="hljs-string"><span class="hljs-string">"mysql"</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"protocol"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"example.com"</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"time"</span></span>: <span class="hljs-string"><span class="hljs-string">"1513941789"</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"product"</span></span>: <span class="hljs-string"><span class="hljs-string">"mysql"</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"vendor"</span></span>: <span class="hljs-string"><span class="hljs-string">"mysql"</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"5.1.63-community"</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-number"><span class="hljs-number">3306</span></span>,             <span class="hljs-attr"><span class="hljs-attr">"uri"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>           }</code> </pre> <br><p>  Für jeden Port auf Target erhalten wir einen Satz solcher Metadaten.  Jetzt müssen Sie verstehen, welche unserer Scanner für diesen Zweck arbeiten möchten. </p><br><p>  Alle Scanner haben einen übergeordneten ScanManager, der ihn elegant macht: </p><br><pre> <code class="hljs lisp">product(<span class="hljs-name"><span class="hljs-name">scanners</span></span>, metadata_as_list)</code> </pre> <br><p>  Es nimmt alle Dienste in Anspruch und überprüft für jeden von ihnen alle möglichen Scanner. <br>  Jeder Scanner bietet eine Funktion, die bestimmt, ob er mit einem solchen Ziel arbeiten möchte. </p><br><p>  Lassen Sie uns darüber sprechen, was der Scanner ist. <br>  Drei Optionen wurden in Betracht gezogen: </p><br><ul><li>  Implementieren Sie jeden Scanner als Microservice, der unseren RPC unterstützt </li><li>  Implementieren Sie jeden Scanner als Dienst und verwenden Sie einen gemeinsamen Nachrichtenbus </li><li>  Dritte Option </li></ul><br><p>  Wir sind jedoch sehr faul und haben festgestellt, dass Sie bei den ersten beiden Optionen neben den Scannern selbst auch eine Art Bereitstellungsinfrastruktur benötigen, die RPC schreibt und Fehler dieses RPC abfängt.  Außerdem wollten wir alles in Python schreiben. </p><br><p>  Wir haben verschiedene Lösungen ausprobiert.  Wir haben uns ähnliche Scanner-Management-Projekte wie Yandex Molly und Minion von Mozilla angesehen.  Wir haben uns angesehen, wie w3af, Zap funktioniert.  Burp hat eine sehr interessante Plugin-Architektur. </p><br><p>  Wir haben beschlossen, dass jeder Scanner als serialisierbare Funktion in Python implementiert werden soll.  Auf diese Weise können Sie sie direkt in rabbit-mq speichern, schnell an verschiedene Knoten liefern und atomar ausführen.  Wir können neue Scanner hinzufügen, ohne Anwendungen erstellen und freigeben zu müssen.  Tatsächlich haben wir einen Dienst für die verteilte und asynchrone Ausführung von Funktionen auf Python erhalten. </p><br><h3 id="format-skanerov">  Scannerformat </h3><br><p>  Der auf unserer Plattform gestartete Scanner sollte ein Objekt sein, das von der Scanner-Basisklasse geerbt wurde. </p><br><p>  Jeder Scanner sollte ein Objekt vom Typ Metadaten als Eingabe- und Rückgabeobjekte vom Typ Vulnerability akzeptieren. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scanner</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>   name = <span class="hljs-string"><span class="hljs-string">"scanner_base"</span></span>   vuln_type = <span class="hljs-string"><span class="hljs-string">"default_vuln_type"</span></span>   user_options = {}   Vulnerability_body_fields_to_web_interface = []   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, opts, target, metadata)</span></span></span><span class="hljs-function">:</span></span>       self.metadata = metadata       self.opts = opts       self.target = target   @staticmetod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">circuit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Metadata)</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-string"><span class="hljs-string">'''         .            Metadata.             CVE.       '''</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [Vulnerability(), Vulnerability()]   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">check_start_condition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-string"><span class="hljs-string">'''        ,    Target          True,    .    False.       '''</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>   <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerError</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Exception)</span></span></span><span class="hljs-class">:</span></span>       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, value)</span></span></span><span class="hljs-function">:</span></span>           self.value = value       <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__str__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span>           <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> repr(self.value)</code> </pre> <br><h3 id="format-uyazvimostey">  Sicherheitsanfälligkeitsformat </h3><br><p>  Die nächste Aufgabe bestand darin, ein einheitliches Format zu erstellen, in dem wir die Ausgabe jedes Scanners speichern können.  Egal, ob es sich um einen Web-Harvester, eine Verzeichnis-Brutilka oder einen zwischengespeicherten PoC-Exploit handelt. </p><br><p>  Wir haben uns entschieden, nicht unsere eigenen Formate zu fechten, sondern den Industriestandard zu verwenden - das CVE-Format.  Wir bereichern CVE mit den Metadaten unserer Sicherheitsanfälligkeit zum einfachen Speichern und Abrufen.  Fügen Sie das Körperfeld hinzu, um scannerspezifische Daten zu speichern.  Welche Tasten des Körpers in der Weboberfläche angezeigt werden sollen, wird vom Scanner festgelegt. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vulnerability</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span>   <span class="hljs-string"><span class="hljs-string">'''           body     .   '''</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, target, port, scanner, text, VulnerabilityTypes, Score, protocol,                UpdateDate=None, scan_date=None, Complexity=None, Access=None, CWEID=None, Authentication=None,                Integ=None, PublishDate=None, Conf=None, ofExploits=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Avail=None,                CVEID=None, references=None, GainedAccessLevel=None, false_positive=False,                fixed=None, body=None)</span></span></span><span class="hljs-function">:</span></span>       scan_date = scan_date <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> scan_date <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> calendar.timegm(gmtime())       references = references <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> []       body = body <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> {}       self.name = self.construct_cve_name(VulnerabilityTypes, protocol, target, port, credentials, uri, params)       self.data = {           <span class="hljs-string"><span class="hljs-string">"target"</span></span> : target,           <span class="hljs-string"><span class="hljs-string">"port"</span></span> : int(port),           <span class="hljs-string"><span class="hljs-string">"Scanner"</span></span>: scanner,           <span class="hljs-string"><span class="hljs-string">"Scan_date"</span></span>: scan_date,           <span class="hljs-string"><span class="hljs-string">"Name"</span></span>: name,           <span class="hljs-string"><span class="hljs-string">"UpdateDate"</span></span>: UpdateDate,           <span class="hljs-string"><span class="hljs-string">"VulnerabilityTypes"</span></span>: VulnerabilityTypes,           <span class="hljs-string"><span class="hljs-string">"Complexity"</span></span>: Complexity,           <span class="hljs-string"><span class="hljs-string">"text"</span></span>: text,           <span class="hljs-string"><span class="hljs-string">"Access"</span></span>: Access,           <span class="hljs-string"><span class="hljs-string">"CWEID"</span></span>: CWEID,           <span class="hljs-string"><span class="hljs-string">"Hash"</span></span>: sha1(self.name.encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>)).hexdigest(),           <span class="hljs-string"><span class="hljs-string">"Authentication"</span></span>: Authentication,           <span class="hljs-string"><span class="hljs-string">"Integ"</span></span>: Integ,           <span class="hljs-string"><span class="hljs-string">"PublishDate"</span></span>: PublishDate,           <span class="hljs-string"><span class="hljs-string">"Conf"</span></span>: Conf,           <span class="hljs-string"><span class="hljs-string">"ofExploits"</span></span>: ofExploits,           <span class="hljs-string"><span class="hljs-string">"Score"</span></span>: Score,           <span class="hljs-string"><span class="hljs-string">"Avail"</span></span>: Avail,           <span class="hljs-string"><span class="hljs-string">"CVEID"</span></span>: CVEID,           <span class="hljs-string"><span class="hljs-string">"References"</span></span>: references,           <span class="hljs-string"><span class="hljs-string">"GainedAccessLevel"</span></span>: GainedAccessLevel,           <span class="hljs-string"><span class="hljs-string">"FalsePositive"</span></span>: false_positive,           <span class="hljs-string"><span class="hljs-string">"Fixed"</span></span>: fixed,           <span class="hljs-string"><span class="hljs-string">"Body"</span></span>: body       }   @staticmethod   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">construct_cve_name</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(VulnerabilityTypes, protocol, target, port, credentials, uri, params)</span></span></span><span class="hljs-function">:</span></span>       <span class="hljs-comment"><span class="hljs-comment"># vuln_type:host:port:protocol:credentials:uri:params       return "{}:{}:{}:{}:{}:{}:{}".format(           VulnerabilityTypes,           target,           port,           protocol,           credentials,           uri,           params)   def __str__(self):       return self.data   def __repr__(self):       return self.name</span></span></code> </pre> <br><p>  Wir haben versucht, den Autoren von Scannern maximale Freiheit bei der Implementierung zu geben. <br>  Und wir laden Sie ein, sich an der Entwicklung zu beteiligen. </p><br><h3 id="kak-zarabatyvat-na-eksploytah">  Wie man mit Exploits Geld verdient. </h3><br><p>  Wir möchten, dass Menschen, die an Sicherheit interessiert sind, Autoren von Dienstprogrammen und Skripten sowie Forscher die Möglichkeit haben, die Ergebnisse ihrer Arbeit absolut legal zu monetarisieren. </p><br><p>  Der Scanner heißt METASCAN.  Wenn Sie über eigene Skripte oder eintägige PoC-Exploits verfügen oder selbst der Autor des Scanners sind.  Senden Sie uns die Module im Scannerformat an david.ordyan@metascan.ru! </p><br><p>  Wir zahlen den Autoren der Module monatlich eine Vergütung und geben die Annahme der Module bis zum 30. November bekannt. <br>  Wir werden sie testen, indem wir unseren Kundenstamm an mehr als 2000 Standorten durchlaufen und die Anzahl der Erkennungen zählen. </p><br><p>  Die Autoren der ersten drei Scanner erhalten nach Anzahl der gefundenen Schwachstellen: </p><br><ul><li>  31 337 Rubel für den 1. Platz. </li><li>  13.370 Rubel für den 2. und 3. Platz. </li></ul><br><p>  Außerdem bieten wir ihnen an, Verträge abzuschließen und eine Belohnung für die monatliche Verwendung ihrer Scanner zu erhalten, bis sie Schwachstellen finden. </p><br><p>  Nach November werden wir das Programm für den Empfang von Scannern erweitern. </p><br><p>  Schreiben Sie an david.ordyan@metascan.ru oder TG <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://t.me/METASCAN</a> <br>  BB8E 3D9B 04FF 70C9 A260 CD45 E0BF 4EB4 9838 A7EC </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispiele und Code werden hier angezeigt</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427625/">https://habr.com/ru/post/de427625/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427611/index.html">Die Geschichte, wie ich Yandex MapKit auf iOS oder Karten aktualisiert habe, Geld, 2 Mappits</a></li>
<li><a href="../de427613/index.html">10 nützliche Blogs für Programmierer in Englisch</a></li>
<li><a href="../de427615/index.html">Hören Sie auf, endlose Bildlaufseiten zu erstellen</a></li>
<li><a href="../de427617/index.html">Eisenbahnwagenentwicklung</a></li>
<li><a href="../de427623/index.html">3 Bücher über C ++ 17 (auf Englisch)</a></li>
<li><a href="../de427629/index.html">Esoterische Sprache LMCode</a></li>
<li><a href="../de427631/index.html">Studie: Kollegen sollten nicht geholfen werden, wenn sie nicht gefragt werden</a></li>
<li><a href="../de427633/index.html">Fintech Digest: Regulierung des Kryptowährungsmarktes in der Russischen Föderation, ein Telefon anstelle einer Karte für einen Geldautomaten, das Interesse am Bergbau nimmt ab</a></li>
<li><a href="../de427635/index.html">Richard Stallman hat den GNU Project Pleasant Communication Guide veröffentlicht</a></li>
<li><a href="../de427637/index.html">Der hochsichere Messenger von Signal speichert heimlich Verlaufs- und Verschlüsselungsschlüssel im Klartext</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>