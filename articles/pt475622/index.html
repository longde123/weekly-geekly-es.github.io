<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçé üëà üö≤ Estendendo o UObject no Unreal Engine 4 üàöÔ∏è üë©üèª ü•Ö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° pessoal! Meu nome √© Alexander, trabalho com a Unreal Engine h√° mais de 5 anos e quase todo esse tempo - em projetos de rede. 

 Como os projetos d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Estendendo o UObject no Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/475622/"><p>  Ol√° pessoal!  Meu nome √© Alexander, trabalho com a Unreal Engine h√° mais de 5 anos e quase todo esse tempo - em projetos de rede. <br><br>  Como os projetos de rede diferem em seus requisitos de desenvolvimento e desempenho, geralmente √© necess√°rio trabalhar com objetos mais simples, como as classes UObject, mas sua funcionalidade √© inicialmente truncada, o que pode criar uma estrutura s√≥lida.  Neste artigo, falarei sobre como ativar v√°rias fun√ß√µes na classe base UObject no Unreal Engine 4. <br><br><img src="https://habrastorage.org/webt/fe/7o/ui/fe7ouisyxz09hjfen72lsdvx5ae.png"><br><br></p><p>  De fato, escrevi o artigo mais como refer√™ncia.  A maioria das informa√ß√µes √© extremamente dif√≠cil de encontrar na documenta√ß√£o ou na comunidade, e aqui voc√™ pode abrir rapidamente o link e copiar o c√≥digo desejado.  Decidi ao mesmo tempo compartilhar com voc√™!  O artigo √© direcionado para aqueles que j√° est√£o um pouco familiarizados com o UE4.  O c√≥digo C ++ ser√° considerado, embora n√£o seja necess√°rio conhec√™-lo.  Voc√™ pode simplesmente seguir as instru√ß√µes se precisar de algo para conversar.  Al√©m disso, n√£o √© necess√°rio copiar tudo, voc√™ pode colar o c√≥digo da se√ß√£o com as propriedades necess√°rias e deve funcionar. <a name="habracut"></a></p><br><br><h2>  Um pouco sobre o UObject </h2><br>  <b>UObject</b> √© a classe base de quase tudo o que existe no Unreal Engine 4. A grande maioria dos objetos criados em seu mundo ou apenas na mem√≥ria √© herdada dele: objetos no palco (AActor), componentes (UActorComponent), tipos diferentes para trabalhar com dados e outros. <br><br>  A classe em si, embora mais f√°cil do que derivadas, √© ao mesmo tempo bastante funcional.  Por exemplo, ele cont√©m muitos eventos √∫teis, como alterar os valores de vari√°veis ‚Äã‚Äãno editor e fun√ß√µes b√°sicas da rede, que n√£o est√£o ativas por padr√£o. <br><br>  Os objetos criados por esta classe n√£o podem estar no palco e existir exclusivamente na mem√≥ria.  Eles n√£o podem ser adicionados como componentes aos atores, embora possa ser um tipo de componente se voc√™ implementar a funcionalidade necess√°ria. <br><br><p>  Por que preciso do UObject se o AActor j√° suporta tudo o que preciso?  Em geral, existem muitos exemplos de uso.  O mais f√°cil s√£o os itens de invent√°rio.  No palco, em algum lugar do c√©u, √© impratic√°vel armazen√°-los, para que voc√™ possa armazen√°-los na mem√≥ria sem carregar a renderiza√ß√£o e sem criar propriedades desnecess√°rias.  Para quem gosta de compara√ß√µes t√©cnicas, o AActor ocupa um kilobyte (1016 bytes) e um UObject vazio tem apenas 56 bytes. </p><br><br><h2>  O que √© um problema do UObject? </h2><br>  Em geral, n√£o h√° problemas, ou simplesmente n√£o os encontrei.  Tudo o que incomoda o UObject √© a falta de v√°rios recursos dispon√≠veis por padr√£o no AActor ou nos componentes.  Aqui est√£o os problemas que eu identifiquei para a minha pr√°tica: <br><br><ul><li>  UObjects n√£o s√£o replicados pela rede; </li><li>  por causa do primeiro ponto, n√£o podemos disparar eventos RPC; </li><li>  Voc√™ n√£o pode usar um conjunto extenso de fun√ß√µes que requerem um link para o mundo no Blueprints; </li><li>  eles n√£o t√™m eventos padr√£o como BeginPlay e Tick; </li><li>  voc√™ n√£o pode adicionar componentes do UObjects ao AActor no Blueprints. </li></ul><br><p>  A maioria das coisas pode ser facilmente resolvida.  Mas alguns ter√£o que mexer. </p><br><br><h2>  Criando UObject </h2><br>  Antes de expandir nossa classe com recursos, precisamos cri√°-la.  Vamos usar o editor para que o gerador grave automaticamente tudo o que √© necess√°rio para trabalhar no cabe√ßalho (.h). <br><br>  Podemos criar uma nova classe no editor do Navegador de conte√∫do, clicando no bot√£o <i>Novo</i> e selecionando <i>Nova classe C ++</i> . <br><br><img src="https://habrastorage.org/webt/x3/7r/8d/x37r8d1ahvstuxtpdnafshrnp9m.png"><br><br>  Em seguida, precisamos escolher a pr√≥pria classe.  Pode n√£o estar na lista geral; portanto, abra-o e selecione UObject. <br><br><img src="https://habrastorage.org/webt/p2/7d/dh/p27ddhbtq9bxgmjzobmozoa1tlk.png"><br><br>  Nomeie sua turma e selecione em qual pasta ela ser√° armazenada.  Quando criamos a classe, voc√™ pode entrar no est√∫dio, encontr√°-la e come√ßar a incorporar todas as fun√ß√µes necess√°rias. <br><br>  <i>Iniciantes, observe que dois arquivos s√£o criados: .h e .ccp.</i>  <i>Em .h, voc√™ declarar√° vari√°veis ‚Äã‚Äãe fun√ß√µes e, em .cpp, definir√° sua l√≥gica.</i>  <i>Encontre os dois arquivos no seu projeto.</i>  <i>Se voc√™ n√£o alterou o caminho, eles devem estar em Projeto / Origem / Projeto /.</i> <br><br>  At√© continuarmos, vamos escrever o par√¢metro <i>Blueprintable</i> na macro UCLASS () acima da declara√ß√£o da classe.  Voc√™ deve obter algo como isto: <br><br>  <b>.h</b> <br><br><pre><code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() }</code> </pre> <br><p>  Gra√ßas a isso, voc√™ pode criar Blueprints que herdar√£o tudo o que fazemos com esse objeto. </p><br><br><h2>  Replica√ß√£o de UObject </h2><br>  Por padr√£o, os UObjects n√£o s√£o replicados pela rede.  Como descrevi acima, v√°rias restri√ß√µes s√£o criadas quando voc√™ precisa sincronizar dados ou l√≥gica entre as partes, mas n√£o armazena lixo no mundo. <br><br>  No Unreal Engine 4, a replica√ß√£o ocorre precisamente devido a objetos do mundo.  Isso significa que simplesmente criar um objeto na mem√≥ria e replic√°-lo falhar√°.  De qualquer forma, voc√™ precisar√° de um propriet√°rio que gerencie a transfer√™ncia de dados do objeto entre o servidor e os clientes.  Por exemplo, se o seu objeto √© a habilidade de um personagem, ele deve se tornar o propriet√°rio.  Ele tamb√©m ser√° o condutor da transmiss√£o de informa√ß√µes pela rede. <br><br>  Prepare nosso objeto para replica√ß√£o.  At√© agora, no cabe√ßalho, precisamos definir apenas uma fun√ß√£o: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; }</code> </pre><br>  <i>IsSupportedForNetworking ()</i> determinar√° que o objeto suporta a rede e pode ser replicado. <br><br>  No entanto, nem tudo √© t√£o simples.  Como escrevi acima, voc√™ precisa de um propriet√°rio que controle a transfer√™ncia do objeto.  Para a pureza do experimento, crie um AActor que o replique.  Isso pode ser feito exatamente da mesma maneira que UObject, apenas a classe pai, naturalmente, AActor. <br><br>  <i>Iniciantes, se voc√™ precisar replicar um objeto em um caractere, controlador ou outro local, crie a classe base apropriada por meio do editor, adicione a l√≥gica necess√°ria e j√° herda dessa classe no Blueprints.</i> <br><br>  Dentro de n√≥s precisamos de 3 fun√ß√µes: um construtor, uma fun√ß√£o para replicar subobjetos, uma fun√ß√£o que determina o que √© replicado dentro deste AActor (vari√°veis, refer√™ncias a objetos, etc.) e o local onde criamos nosso objeto. <br><br>  N√£o se esque√ßa de criar uma vari√°vel pela qual nosso objeto ser√° armazenado: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: AMyActor(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReplicateSubobjects</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(class UActorChannel *Channel, class FOutBunch *Bunch, FReplicationFlags *RepFlags)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginPlay</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; UPROPERTY(Replicated, BlueprintReadOnly, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObject</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br>  Dentro do arquivo de origem, temos que escrever tudo: <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyActor.h" #include "Net/UnrealNetwork.h" #include "Engine/World.h" #include "Engine/ActorChannel.h" #include "   UObject/MyObject.h" AMyActor::AMyActor() { //  Actor  . bReplicates = true // . NetCullDistanceSquared = 99999; //  (  ). NetUpdateFrequency = 1.f; } void AMyActor::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //       .           . DOREPLIFETIME(AMyActor, MyObject); } bool AMyActor::ReplicateSubobjects(UActorChannel * Channel, FOutBunch * Bunch, FReplicationFlags * RepFlags) { bool WroteSomething = Super::ReplicateSubobjects(Channel, Bunch, RepFlags); //   . if (MyObject ) WroteSomething |= Channel-&gt;ReplicateSubobject(MyObject , *Bunch, *RepFlags); return WroteSomething; } AMyActor::BeginPlay() { /*       (  )  .    this.        . ,       ,     . */ if(HasAuthority()) { MyObject = NewObject&lt;UMyObject&gt;(this); //       if(MyObject) UE_LOG(LogTemp, Log, TEXT("%s created"), *MyObject-&gt;GetName()); } }</span></span></code> </pre><br><p>  Agora seu objeto ser√° replicado com este ator.  Voc√™ pode exibir o nome dele no tick, mas j√° no cliente.  Observe que, no Begin Play, √© improv√°vel que um objeto chegue antes do cliente; portanto, n√£o faz sentido escrever um log nele. </p><br><br><h2>  Replica√ß√£o de vari√°veis ‚Äã‚Äãno UObject </h2><br>  Na maioria dos casos, n√£o faz sentido replicar um objeto se ele n√£o contiver informa√ß√µes que tamb√©m ser√£o sincronizadas entre o servidor e os clientes.  Como nosso objeto j√° est√° replicado, a passagem de vari√°veis ‚Äã‚Äãn√£o √© dif√≠cil.  Isso √© feito da mesma maneira que dentro do nosso ator: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSupportedForNetworking</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLifetimeReplicatedProps</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override</span></span>; UPROPERTY(Replicated, BlueprintReadWrite, Category=<span class="hljs-string"><span class="hljs-string">"Object"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MyInteger; <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #include "MyObject.h" #include "Net/UnrealNetwork.h" UMyObject ::UMyObject () { //  Object  .     . bReplicates = true //       ,     . } void UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); //   Integer  . DOREPLIFETIME(UMyObject, MyInteger); } }</span></span></code> </pre><br>  Ao adicionar uma vari√°vel e sinaliz√°-la para replica√ß√£o, podemos replic√°-la.  Tudo √© simples e o mesmo que no AActor. <br><br>  No entanto, existe uma pequena armadilha que n√£o √© imediatamente vis√≠vel, mas pode ser enganosa.  Isso ser√° especialmente percept√≠vel se voc√™ estiver criando seu UObject n√£o para trabalhar em C ++, mas preparando-o para heran√ßa e trabalho em Blueprints. <br><br>  A conclus√£o √© que as vari√°veis ‚Äã‚Äãcriadas no herdeiro do Blueprints n√£o ser√£o replicadas.  O mecanismo n√£o as marca automaticamente e a altera√ß√£o de um par√¢metro no servidor no BP n√£o altera nada no valor no cliente.  Mas existe uma cura para isso.  Para a replica√ß√£o correta das vari√°veis ‚Äã‚ÄãBP, √© necess√°rio marc√°-las com anteced√™ncia.  Adicione algumas linhas ao GetLifetimeReplicatedProps (): <br><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject ::GetLifetimeReplicatedProps (TArray&lt;FLifetimeProperty&gt;&amp; OutLifetimeProps) { Super::GetLifetimeReplicatedProps(OutLifetimeProps); <span class="hljs-comment"><span class="hljs-comment">//   Integer  . DOREPLIFETIME(UMyObject, MyInteger); //       UBlueprintGeneratedClass* BPClass = Cast&lt;UBlueprintGeneratedClass&gt;(GetClass()); if (BPClass) BPClass-&gt;GetLifetimeBlueprintReplicationList(OutLifetimeProps); }</span></span></code> </pre><br><p>  Vari√°veis ‚Äã‚Äãnas classes filho Blueprint agora ser√£o replicadas conforme o esperado. </p><br><br><h2>  Eventos RPC no UObject </h2><br>  Eventos RPC (chamada de procedimento remoto) s√£o fun√ß√µes especiais chamadas no outro lado da intera√ß√£o de rede de um projeto.  Utilizando-os, voc√™ pode chamar a fun√ß√£o do servidor em outros clientes e do cliente no servidor.  Muito √∫til e frequentemente usado ao escrever projetos de rede. <br><br>  <i>Se voc√™ n√£o estiver familiarizado com eles, recomendo a leitura de um artigo.</i>  <i>Ele descreve o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uso em C ++ e em Blueprints</a> .</i> <br><br>  Embora n√£o haja problemas no Actor ou nos componentes com sua chamada, os eventos do UObject s√£o acionados do mesmo lado em que foram chamados, o que torna imposs√≠vel fazer uma chamada remota quando necess√°rio. <br><br>  Observando o c√≥digo do componente (UActorComponent), podemos encontrar v√°rias fun√ß√µes que permitem transferir chamadas pela rede.  Como o UActorComponent √© herdado do UObject, podemos simplesmente copiar as se√ß√µes necess√°rias de c√≥digo e colar em nosso objeto para que ele funcione da seguinte maneira: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/EngineTypes.h" UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() public: virtual bool CallRemoteFunction (UFunction * Function, void * Parms, struct FOutParmRec * OutParms, FFrame * Stack) override; virtual int32 GetFunctionCallspace (UFunction* Function, void* Parameters, FFrame* Stack) override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Engine/NetDriver.h" //       . bool UMyObject::CallRemoteFunction(UFunction * Function, void * Parms, FOutParmRec * OutParms, FFrame * Stack) { if (!GetOuter()) return false; UNetDriver* NetDriver = GetOuter()-&gt;GetNetDriver(); if (!NetDriver) return false; NetDriver-&gt;ProcessRemoteFunction(GetOuter(), Function, Parms, OutParms, Stack, this); return true; } int32 UMyObject::GetFunctionCallspace(UFunction * Function, void * Parameters, FFrame * Stack) { return (GetOuter() ? GetOuter()-&gt;GetFunctionCallspace(Function, Parameters, Stack) : FunctionCallspace::Local); }</span></span></code> </pre><br>  Com essas fun√ß√µes, poderemos acionar eventos RPC n√£o apenas no c√≥digo, mas tamb√©m nos blueprints. <br><br><p>  Observe que, para acionar eventos de cliente ou servidor, voc√™ precisa de um propriet√°rio cujo propriet√°rio seja nosso jogador.  Por exemplo, o objeto pertence ao personagem do usu√°rio ou ao objeto em que Owner √© o Player Controller do jogador. </p><br><br><h2>  Recursos globais em projetos </h2><br>  Se voc√™ j√° criou um Object Blueprint, pode ter notado que n√£o pode chamar fun√ß√µes globais (est√°ticas, mas por uma quest√£o de clareza, chamamos isso) dispon√≠veis em outras classes, por exemplo, GetGamemode ().  Parece que voc√™ simplesmente n√£o pode fazer aulas nas classes Object, pelas quais voc√™ precisa passar todos os links ao criar, ou de alguma forma perverter, e √†s vezes a escolha recai completamente na classe Actor que √© criada no palco e suporta tudo. <br><br>  Mas em C ++, √© claro, n√£o existem esses problemas.  No entanto, o designer do jogo, que brinca com as configura√ß√µes e adiciona pequenas coisas diferentes, n√£o pode dizer que voc√™ precisa abrir o Visual Studio, encontrar a classe apropriada e obter o modo de jogo na fun√ß√£o doSomething () alterando os pontos nela.  Portanto, √© imperativo que o designer possa fazer login no Bluprint e, com dois cliques, fazer o que √© seu trabalho.  Economize o tempo dele e o seu.  No entanto, os Blueprints foram inventados para isso. <br><br>  A conclus√£o √© que, quando voc√™ procura ou chama fun√ß√µes no menu de contexto no Bluprint, essas mesmas fun√ß√µes globais que exigem uma refer√™ncia ao mundo tentam chamar uma fun√ß√£o dentro do seu objeto que se refere a ela.  E se o editor v√™ que n√£o h√° fun√ß√£o, ele entende que n√£o pode us√°-lo e n√£o o mostra na lista. <br><br><img src="https://habrastorage.org/webt/bb/mj/gu/bbmjguakea7gkb-roirojnwnrsg.png"><br><br>  No entanto, existe uma cura para isso.  At√© dois. <br><br>  Vamos primeiro considerar uma op√ß√£o para uso mais conveniente no editor.  Precisamos redefinir uma fun√ß√£o que retorne um link para o mundo e, em seguida, o editor entender√° que no pr√≥prio jogo ele pode funcionar: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//  GetWorld()    . virtual UWorld* GetWorld() const override; //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs">UWorld* UMyObject::GetWorld() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       ,    . if (GIsEditor &amp;&amp; !GIsPlayInEditorWorld) return nullptr; else if (GetOuter()) return GetOuter()-&gt;GetWorld(); else return nullptr; }</span></span></code> </pre><br>  Agora est√° definido e o editor entender√° que, em geral, o objeto √© capaz de obter o ponteiro desejado (embora n√£o seja v√°lido) e usar fun√ß√µes globais no BP. <br><br>  <i>Observe que o propriet√°rio (GetOuter ()) tamb√©m deve ter acesso ao mundo.</i>  <i>Pode ser outro UObject com um objeto GetWorld (), componente ou ator espec√≠fico na cena.</i> <br><br><img src="https://habrastorage.org/webt/7x/wu/w3/7xwuw3u7qkekz9m6-bnhdfd0o10.png"><br><br>  Existe outro caminho.  Basta adicionar um r√≥tulo √† macro UCLASS () ao declarar a classe que o par√¢metro WorldContextObject ser√° adicionado √†s fun√ß√µes est√°ticas no BP, nas quais qualquer objeto que sirva como condutor do "mundo" e as fun√ß√µes globais do mecanismo sejam alimentados.  Essa op√ß√£o √© adequada para quem no projeto pode ter v√°rios mundos ao mesmo tempo (por exemplo, o mundo do jogo e o mundo para o espectador): <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   WorldContext      UCLASS(Blueprintable, meta=(ShowWorldContextPin)) class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() //   }</span></span></code> </pre><br>  Se voc√™ digitar GetGamemode na pesquisa no BP, ele aparecer√° na lista, como outras fun√ß√µes semelhantes, e o par√¢metro ser√° WorldContextObject, no qual voc√™ precisar√° passar um link para o Actor. <br><br><img src="https://habrastorage.org/webt/nn/uo/xg/nnuoxgsfj912bnoa5fheedsz3yk.png"><br><br>  A prop√≥sito, voc√™ pode simplesmente registrar o propriet√°rio de nossa propriedade l√°.  Eu recomendo criar uma fun√ß√£o no Actor, sempre ser√° √∫til para o objeto: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, meta=(ShowWorldContextPin)) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      ,     . public: UFUNCTION(BlueprintPure) AActor* GetOwner() const {return Cast&lt;AActor&gt;(GetOuter());}; //   }</span></span></code> </pre><br>  Agora voc√™ pode simplesmente usar as fun√ß√µes globais em combina√ß√£o com a nossa fun√ß√£o Pure para obter o propriet√°rio. <br><br><img src="https://habrastorage.org/webt/ux/22/7w/ux227wpx_b6yp8l8vnlutwxywu8.png"><br><br>  Se voc√™ tamb√©m declarar GetWorld () na segunda variante como na primeira variante, poder√° enviar uma refer√™ncia a si mesmo (Pr√≥prio ou Este) no par√¢metro WorldContextObject. <br><br><p><img src="https://habrastorage.org/webt/op/jh/mb/opjhmbcmm5jsktm_gtxk-jkgzyy.png"></p><br><br><h2>  Eventos BeginPlay e Tick </h2><br>  Outro problema que os desenvolvedores do Blueprint podem encontrar √© que n√£o h√° eventos BeginPlay e Tick na classe Object.  Claro, voc√™ pode cri√°-los e ligar de outra classe.  Mas voc√™ deve admitir que √© muito mais conveniente quando tudo funciona imediatamente. <br><br>  Vamos come√ßar entendendo como fazer o Begin Play.  Podemos criar uma fun√ß√£o dispon√≠vel para reescrita no BP e cham√°-la no construtor da classe, mas existem v√°rios problemas, pois no momento do construtor seu objeto ainda n√£o foi totalmente inicializado. <br><br>  Em todas as classes, existe a fun√ß√£o PostInitProperties (), que √© chamada ap√≥s a inicializa√ß√£o da maioria dos par√¢metros e o registro do objeto em v√°rios sistemas internos, por exemplo, para o coletor de lixo.  Nele, voc√™ pode simplesmente chamar nosso evento, que ser√° usado no Blueprints: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> UObject { GENERATED_BODY() <span class="hljs-comment"><span class="hljs-comment">//      . virtual void PostInitProperties() override; // ,      . UFUNCTION(BlueprintImplementableEvent) void BeginPlay(); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::PostInitProperties() { Super::PostInitProperties(); <span class="hljs-comment"><span class="hljs-comment">//   ,   .   BeginPlay    if(GetOuter() &amp;&amp; GetOuter()-&gt;GetWorld()) BeginPlay(); }</span></span></code> </pre><br>  <i>Em vez de if (GetOuter () &amp;&amp; GetOuter () -&gt; GetWorld ()), voc√™ pode simplesmente colocar if (GetWorld ()) se voc√™ j√° o redefiniu.</i> <i><br><br></i>  <i>Cuidado!</i>  <i>Por padr√£o, PostInitProperties () tamb√©m √© chamado no editor.</i> <i><br></i> <br>  Agora podemos entrar no nosso objeto BP e chamar o evento BeginPlay.  Ser√° chamado quando o objeto for criado. <br><br>  Vamos para o evento Tick.  N√£o existe uma fun√ß√£o simples para n√≥s.  Assinale os objetos no mecanismo que chama um gerente especial, para o qual voc√™ precisa, de alguma forma, buscar.  No entanto, h√° um truque muito conveniente aqui - heran√ßa adicional de FTickableGameObject.  Isso permitir√° que voc√™ fa√ßa automaticamente tudo o que precisa e, em seguida, ser√° suficiente apenas para captar as fun√ß√µes necess√°rias: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   #include "Tickable.h" //   c FTickableGameObject UCLASS(Blueprintable) class MYPROPJECT_API UMyObject : public UObject, public FTickableGameObject { GENERATED_BODY() public: //   virtual void Tick(float DeltaTime) override; virtual bool IsTickable() const override; virtual TStatId GetStatId() const override; protected: //     UFUNCTION(BlueprintImplementableEvent) void EventTick(float DeltaTime); //   }</span></span></code> </pre><br>  <b>.cpp</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UMyObject::Tick(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime) { <span class="hljs-comment"><span class="hljs-comment">//       . EventTick(DeltaTime); //     . } //     bool UMyObject::IsTickable() const { return true; } TStatId UMyObject::GetStatId() const { return TStatId(); }</span></span></code> </pre><br><p>  Se voc√™ herdar do seu objeto e criar uma classe BP, um evento EventTick estar√° dispon√≠vel, o que causar√° l√≥gica para cada quadro. </p><br><br><h2>  Adicionando componentes de UObjects </h2><br>  No UObject Blueprints, voc√™ n√£o pode gerar componentes para atores.  O mesmo problema √© inerente √†s plantas do ActorComponent.  A l√≥gica da Epic Games n√£o √© muito clara, pois em C ++ isso pode ser feito.  Al√©m disso, voc√™ pode adicionar um componente do Actor a outro objeto do Actor simplesmente especificando um link.  Mas isso n√£o pode ser feito. <br><br>  Infelizmente, n√£o consegui descobrir este item.  Se algu√©m tiver instru√ß√µes sobre como fazer isso, ficarei feliz em public√°-lo aqui. <br><br><p>  A √∫nica op√ß√£o que posso oferecer no momento √© criar um inv√≥lucro na classe UObject, fornecendo acesso a uma simples adi√ß√£o de componentes.  Assim, ser√° poss√≠vel adicionar componentes ao ator, mas voc√™ n√£o ter√° par√¢metros de entrada criados dinamicamente da semente.  Muitas vezes, isso pode ser negligenciado. </p><br><br><h2>  Configurando uma Inst√¢ncia Atrav√©s do Editor </h2><br>  No UE4, h√° outro "recurso" conveniente para trabalhar com objetos - essa √© a capacidade de criar uma inst√¢ncia durante a inicializa√ß√£o e alterar seus par√¢metros atrav√©s do editor, definindo assim suas propriedades, sem criar uma classe filho apenas por uma quest√£o de configura√ß√µes.  Especialmente √∫til para designers de jogos. <br><br>  Suponha que voc√™ tenha um gerenciador de modificadores para um personagem e os pr√≥prios modificadores sejam representados por classes que descrevem os efeitos sobrepostos.  O designer do jogo criou um par de modificadores e indica no gerente quais s√£o usados. <br><br>  Em uma situa√ß√£o normal, ficaria assim: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere) TSubclassOf&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UMyObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyObjectClass</span></span></span><span class="hljs-class">;</span></span> }</code> </pre><br><img src="https://habrastorage.org/webt/hd/rx/zc/hdrxzc1qsu2d9htiydsmgfy1t-0.png"><br><br>  No entanto, h√° um problema, pois ele n√£o pode configurar modificadores e voc√™ deve criar uma classe adicional para outros valores.  Concordo, n√£o √© muito conveniente ter dezenas de classes no Navegador de conte√∫do que diferem apenas em valores.  Consertar isso √© f√°cil.  Voc√™ pode adicionar alguns campos dentro de USTRUCT () e tamb√©m indicar no objeto cont√™iner que nossos objetos ser√£o inst√¢ncias, e n√£o apenas refer√™ncias a objetos ou classes inexistentes: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs">UCLASS(Blueprintable, DefaultToInstanced, EditInlineNew) <span class="hljs-comment"><span class="hljs-comment">//  -        class MYPROPJECT_API UMyObject : public UObject { GENERATED_BODY() UPROPERTY(EditAnywhere) //       uint8 MyValue; // ,    //   }</span></span></code> </pre><br>  Isso por si s√≥ n√£o √© suficiente, agora √© necess√°rio indicar que a mesma vari√°vel com a classe ser√° uma inst√¢ncia.  Isso j√° foi feito onde voc√™ armazena o objeto, por exemplo, no gerenciador de modificadores de caracteres: <br><br>  <b>.h</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MYPROPJECT_API</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AMyActor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AActor { GENERATED_BODY() <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UPROPERTY(EditAnywhere, Instanced) <span class="hljs-comment"><span class="hljs-comment">//   Instanced    class UMyObject* MyObject; //    }</span></span></code> </pre><br>  Observe que usamos a refer√™ncia ao objeto, e n√£o √† classe, pois a inst√¢ncia ser√° criada imediatamente ap√≥s a inicializa√ß√£o.  Agora podemos entrar na janela do editor para selecionar uma classe e ajustar os valores dentro da inst√¢ncia.  √â muito mais conveniente e mais flex√≠vel. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ee4/1cd/e76/ee41cde76aed943c03f0a15ff2e903f6.png" alt="imagem"></p><br><br><h2>  Informa√ß√µes </h2><br>  H√° outra classe interessante no Unreal Engine.  Isto √© AInfo.  Uma classe herdada do AActor que n√£o possui representa√ß√£o visual no mundo.  O Info usa classes como: modo de jogo, GameState, PlayerState e outras.  Ou seja, classes que suportam chips diferentes do AActor, por exemplo, replica√ß√£o, mas n√£o s√£o colocadas em cena. <br><br>  Se voc√™ precisar criar um gerente global adicional que deva suportar a rede e todas as classes de atores resultantes, poder√° us√°-lo.  Voc√™ n√£o precisa manipular a classe UObject conforme descrito acima para for√ß√°-la, por exemplo, a replicar dados. <br><br><p>  No entanto, lembre-se de que, embora o objeto n√£o tenha coordenadas, componentes visuais e n√£o seja renderizado na tela, ele ainda √© um descendente da classe Actor, o que significa que √© t√£o pesado quanto o pai.  Usado razoavelmente em pequenas quantidades e por conveni√™ncia. </p><br><br><h2>  Conclus√£o </h2><br>  O UObject √© necess√°rio com muita frequ√™ncia e eu aconselho voc√™ a us√°-lo sempre que o Ator n√£o for realmente necess√°rio.  √â uma pena que seja um pouco limitado, mas tamb√©m √© uma vantagem.  √Äs vezes, √© necess√°rio mexer na necessidade de usar um modelo personalizado, mas o mais importante √© que todas as principais restri√ß√µes podem ser removidas. <br><br>         ,            ,      UObject,   ,      ,           . <br><br> ,    ,      Unreal Engine 4.   -   ,          .    ,  -    ,   UObject. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt475622/">https://habr.com/ru/post/pt475622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt475608/index.html">Gerenciador de tags do Google: configura√ß√µes de gatilho n√£o √≥bvias e √∫teis</a></li>
<li><a href="../pt475610/index.html">Candeeiros de mesa LED seguros que mant√™m a vis√£o</a></li>
<li><a href="../pt475612/index.html">Dado, quando, afirma√ß√µes e confian√ßa na implementa√ß√£o</a></li>
<li><a href="../pt475614/index.html">Automa√ß√£o para os mais pequenos. Parte Dois. Projeto de rede</a></li>
<li><a href="../pt475618/index.html">Como escrever um contrato Python inteligente na rede Ontology. Parte 2: API de armazenamento</a></li>
<li><a href="../pt475624/index.html">PHP-Watcher: uma ferramenta que simplifica o desenvolvimento de aplicativos de longa dura√ß√£o</a></li>
<li><a href="../pt475626/index.html">Os autotestes podem substituir uma pessoa em busca de vulnerabilidades: entrevista com Alexandra Svatikova</a></li>
<li><a href="../pt475630/index.html">Knative - uma plataforma baseada em k8s como um servi√ßo com suporte sem servidor</a></li>
<li><a href="../pt475636/index.html">Elementos do vetor de incremento</a></li>
<li><a href="../pt475640/index.html">Se voc√™ estiver criando algo, evite a programa√ß√£o do gerente.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>