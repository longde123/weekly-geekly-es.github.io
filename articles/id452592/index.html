<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§˜ğŸ½ ğŸ¤¾ ğŸ”ï¸ Bagian 0. Membutuhkan peri untuk bekerja di Matrix. Relokasi dimungkinkan ğŸ™Œ ğŸ•Œ ğŸ–ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perhatian: berisi pemrograman sistem. Ya, pada dasarnya, itu tidak mengandung apa pun. 


 Mari kita bayangkan bahwa Anda diberi tugas untuk menulis g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagian 0. Membutuhkan peri untuk bekerja di Matrix. Relokasi dimungkinkan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452592/"><p>  <strong>Perhatian: berisi pemrograman sistem.</strong>  <strong>Ya, pada dasarnya, itu tidak mengandung apa pun.</strong> </p><br><p> Mari kita bayangkan bahwa Anda diberi tugas untuk menulis game fantasi fantasi.  Nah, ada tentang para elf.  Dan tentang realitas virtual.  Sejak kecil, Anda bermimpi menulis sesuatu seperti itu dan, tanpa ragu, setuju.  Segera Anda menyadari bahwa Anda tahu sebagian besar dunia peri dari lelucon dari bashorgh tua dan sumber berbeda lainnya.  <em>Ups, masalah.</em>  Nah, di mana milik kami tidak hilang ... Diajarkan oleh pengalaman pemrograman yang kaya, Anda pergi ke Google, masukkan "spesifikasi Elf" dan ikuti tautannya.  Oh!  Yang ini mengarah ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semacam PDF</a> ... jadi apa yang kita miliki di sini ... semacam <code>Elf32_Sword</code> - pedang elven - sepertinya yang Anda butuhkan.  32 rupanya level karakter, dan dua merangkak di kolom berikut mungkin rusak.  Persis apa yang Anda butuhkan, dan selain bagaimana sistematis! .. </p><a name="habracut"></a><br><p>  Seperti yang dinyatakan dalam satu tugas pemrograman Olimpiade, setelah beberapa paragraf teks terperinci tentang topik Jepang, samurai dan geisha: "Seperti yang sudah Anda pahami, tugas itu tidak akan sama sekali tentang hal itu."  Oh ya, kontes itu, tentu saja, untuk sementara waktu.  Secara umum, saya menyatakan lima menit keuletan ditutup. </p><br><p>  Hari ini saya akan mencoba berbicara tentang mem-parsing file dalam format <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ELF</a> 64-bit.  Pada prinsipnya, apa yang mereka tidak simpan di dalamnya adalah program asli, perpustakaan statis, perpustakaan dinamis, setiap implementasi spesifik, seperti crashdumps ... Ini digunakan, misalnya, di Linux dan banyak sistem mirip Unix lainnya, ya, kata mereka, bahkan pada ponsel dukungannya secara aktif dimasukkan dalam firmware yang ditambal sebelumnya.  Tampaknya mendukung format untuk menyimpan program dari sistem operasi yang serius seharusnya sulit.  Jadi saya pikir.  Ya, mungkin memang begitu.  Tetapi kami akan mendukung use case yang sangat spesifik: memuat bytecode eBPF dari file <code>.o</code> .  Kenapa begitu  Hanya untuk percobaan lebih lanjut, saya akan memerlukan beberapa bytecode lintas-platform yang serius (yaitu, tidak <em>setinggi lutut</em> ), yang dapat diperoleh dari C daripada ditulis secara manual, sehingga eBPF sederhana dan ada backend LLVM untuk itu.  Dan saya hanya perlu menguraikan ELF sebagai wadah di mana bytecode ini dimasukkan oleh kompiler. </p><br><p>  Untuk berjaga-jaga, saya akan mengklarifikasi: artikel ini adalah program eksplorasi dan tidak mengklaim sebagai panduan lengkap.  Tujuan utamanya adalah membuat bootloader yang memungkinkan Anda membaca program C yang dikompilasi dalam eBPF menggunakan Dentang - yang saya miliki - dalam volume yang cukup untuk melanjutkan percobaan. </p><br><h1 id="zagolovok">  Berita utama </h1><br><p>  Mulai dari titik nol di ELF terletak tajuk.  Ini berisi huruf E, L, F, yang dapat dilihat jika Anda mencoba membukanya dengan editor teks, dan beberapa variabel global.  Sebenarnya, header adalah satu-satunya struktur dalam file yang terletak pada offset tetap, dan berisi informasi untuk menemukan sisa struktur.  <em>(Selanjutnya, saya dipandu oleh dokumentasi untuk format 32-bit dan <code>elf.h</code> , yang tahu tentang 64-bit. Jadi, jika Anda melihat kesalahan, silakan memperbaikinya)</em> </p><br><p>  Hal pertama yang memenuhi kita dalam file adalah bidang <code>unsigned char e_ident[16]</code> .  Ingat artikel-artikel menyenangkan ini dalam seri "semua pernyataan berikut ini salah"?  Ini hampir sama: ELF dapat berisi kode 32 atau 64-bit, Little atau Big Endian, dan bahkan selusin arsitektur prosesor.  Anda akan membacanya sebagai Elf64 di bawah Little endian - well, semoga sukses ... Array byte ini adalah semacam tanda tangan dari apa yang ada di dalamnya dan bagaimana menguraikannya. </p><br><p>  Dengan empat byte pertama, semuanya sederhana - yaitu <code>[0x7f, 'E', 'L', 'F']</code> .  Jika mereka tidak cocok, maka ada alasan untuk percaya bahwa mereka adalah sejenis lebah yang salah.  Byte berikutnya berisi kelas <del>  karakter </del>  File: <code>ELFCLASS32</code> atau <code>ELFCLASS64</code> - kedalaman bit.  Untuk mempermudah, kami hanya akan bekerja dengan file 64-bit (adakah eBPF 32-bit?).  Jika kelas ternyata <code>ELFCLASS32</code> , kita cukup keluar dengan kesalahan: semua sama, struktur akan "mengambang", dan pemeriksaan kewarasan tidak ada salahnya untuk melakukannya.  Byte terakhir yang menarik bagi kami dalam struktur ini menunjukkan endianness file - kami hanya akan bekerja dengan urutan byte asli untuk prosesor kami. </p><br><p>  Untuk berjaga-jaga, saya akan mengklarifikasi: ketika bekerja dengan format ELF di C, Anda tidak boleh mengurangi setiap int dengan offset yang dihitung dengan cerdik - <code>elf.h</code> berisi struktur yang diperlukan, dan nomor byte genap di <code>e_ident</code> : <code>EI_MAG0</code> , <code>EI_MAG1</code> , <code>EI_MAG2</code> , <code>EI_MAG3</code> , <code>EI_CLASS</code> , Anda hanya perlu membawa <code>EI_DATA</code> ... pointer ke data yang dibaca dari atau dipetakan ke dalam memori dari file ke pointer ke struktur dan membaca. </p><br><p>  Selain <code>e_ident</code> tajuk berisi bidang lain, beberapa hanya akan kami periksa, dan beberapa akan digunakan untuk analisis lebih lanjut, tetapi nanti.  Yaitu, kami memeriksa bahwa <code>e_machine == EM_BPF</code> (yaitu, "di bawah arsitektur prosesor eBPF"), <code>e_type == ET_REL</code> , <code>e_shoff != 0</code> .  Pemeriksaan terakhir memiliki arti sebagai berikut: file dapat berisi informasi untuk menautkan (tabel bagian dan bagian), untuk meluncurkan (tabel program dan segmen), atau keduanya.  Dengan dua pemeriksaan terakhir, kami memverifikasi bahwa informasi yang kami butuhkan (seolah-olah untuk ditautkan) ada dalam file.  Periksa juga apakah formatnya adalah <code>EV_CURRENT</code> . </p><br><p>  <strong>Segera melakukan reservasi, saya tidak akan memeriksa validitas file, dengan asumsi bahwa jika kita memuatnya ke dalam proses kita, maka kita mempercayainya.</strong>  Dalam kode kernel atau program lain yang bekerja dengan file yang tidak terpercaya, secara alami <strong>tidak mungkin melakukan hal ini</strong> . </p><br><h1 id="tablica-sekciy">  Tabel bagian </h1><br><p>  Seperti yang saya katakan, kami tertarik pada tampilan tautan dari file, yaitu, tabel bagian dan bagian itu sendiri.  Informasi tentang tempat mencari tabel bagian ada di header.  Ukurannya juga ditunjukkan di sana, serta <strong>ukuran satu elemen</strong> - itu bisa lebih besar dari <code>sizeof(Elf64_Shdr)</code> (karena mempengaruhi nomor versi format, jujur â€‹â€‹saya tidak tahu).  Beberapa nomor bagian utama dicadangkan, dan sebenarnya tidak ada dalam tabel.  Merujuk mereka memiliki arti khusus.  Kami tampaknya hanya tertarik pada <code>SHN_UNDEF</code> (nol juga disediakan - bagian yang hilang; omong-omong, seperti yang Anda tahu, judulnya masih ada di tabel) <code>SHN_ABS</code> .  Simbol "didefinisikan di bagian <code>SHN_UNDEF</code> " sebenarnya tidak terdefinisi, dan di <code>SHN_ABS</code> sebenarnya memiliki nilai absolut dan tidak dipindahkan.  Namun, <code>SHN_ABS</code> juga tidak <code>SHN_ABS</code> untukku. </p><br><h2 id="tablica-strok">  Tabel baris </h2><br><p>  Di sini kita menemukan untuk pertama kalinya tabel string - tabel string yang digunakan dalam file.  Bahkan, jika <code>const char *strtab</code> adalah tabel string, maka nama <code>sh_name</code> hanyalah <code>strtab + sh_name</code> .  Ya, itu hanya garis yang dimulai dengan indeks tertentu dan berlanjut ke nol byte.  Garis-garis mungkin bersilangan (lebih tepatnya, yang satu mungkin merupakan akhiran yang lain).  Bagian dapat memiliki nama, maka dalam ELF Header bidang <code>e_shstrndx</code> akan menunjuk ke bagian dari tabel baris (yang untuk nama bagian, jika ada beberapa), dan bidang <code>sh_name</code> di header bagian ke baris tertentu. </p><br><p>  Bytes pertama (nol) dan terakhir dari tabel baris berisi karakter nol.  Yang terakhir dapat dimengerti mengapa: nilai-jam, mengakhiri baris terakhir.  Tetapi offset nol menentukan nama <em>tidak ada</em> atau <em>kosong</em> - tergantung pada konteksnya. </p><br><h2 id="zagruzka-sekciy">  Memuat bagian </h2><br><p>  Ada dua alamat di header setiap bagian: satu, <code>sh_addr</code> adalah alamat muat (di mana bagian akan ditempatkan dalam memori), yang lain, <code>sh_offset</code> adalah offset dalam file di mana bagian ini terletak di sana.  Saya tidak tahu bagaimana keduanya, tetapi masing-masing nilai-nilai ini secara individual dapat 0: dalam satu kasus, bagian "tetap pada disk", karena ada beberapa jenis informasi layanan.  Di bagian lain, bagian <em>tidak dimuat dari disk</em> , misalnya, Anda hanya perlu memilihnya dan memberi skor dengan angka nol ( <code>.bss</code> ).  Jujur saja, walaupun saya tidak harus memproses alamat unduhan - di mana itu diunggah, di sana itu diunggah :) Namun, kami memiliki program khusus, terus terang juga. </p><br><h1 id="relokaciya">  Relokasi </h1><br><p>  Dan sekarang hal yang menarik: menurut langkah-langkah keamanan, seperti yang Anda tahu, mereka tidak pergi ke Matrix tanpa operator yang tersisa di pangkalan.  Dan karena kita masih memiliki fantasi di sini, koneksi dengan operator akan bersifat telepati.  Oh ya, saya mengumumkan lima menit keuletan selesai.  Secara umum, kami akan secara singkat membahas proses penautan. </p><br><p>  Untuk percobaan saya, saya perlu sepotong kode dikompilasi menjadi boot biasa, dimuat dengan <code>libdl</code> biasa.  Di sini saya bahkan tidak akan menjelaskan secara detail - cukup buka <code>dlopen</code> , tarik karakter melalui <code>dlsym</code> , tutup dengan <code>dlclose</code> ketika program <code>dlclose</code> .  Namun, bahkan ini adalah detail implementasi yang tidak terkait dengan pemuat file ELF <em>kami</em> .  Ada beberapa <em>konteks</em> : kemampuan untuk mendapatkan pointer dengan nama. </p><br><p>  Secara umum, set instruksi eBPF adalah kemenangan dari kode mesin yang disejajarkan: instruksi selalu membutuhkan 8 byte dan memiliki struktur </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p>  Selain itu, banyak bidang dalam setiap instruksi spesifik mungkin tidak digunakan - menghemat ruang untuk kode "mesin" bukan tentang kami. </p><br><p>  Bahkan, instruksi pertama dapat segera mengikuti yang kedua, yang tidak mengandung opcodes, tetapi hanya memperluas bidang langsung dari 32 hingga 64 bit.  Berikut adalah tambalan untuk instruksi majemuk yang disebut <code>R_BPF_64_64</code> . </p><br><p>  Untuk melakukan relokasi, sekali lagi kita akan melihat tabel bagian untuk <code>sh_type == SHT_REL</code> .  Bidang <code>sh_info</code> dari header akan menunjukkan bagian mana yang kita tambal, dan <code>sh_link</code> - dari tabel mana untuk mengambil deskripsi karakter. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Elf64_Addr r_offset; Elf64_Xword r_info; } Elf64_Rel;</code> </pre> <br><p>  Sebenarnya, ada dua jenis bagian relokasi: <code>REL</code> dan <code>RELA</code> - yang kedua secara eksplisit berisi istilah tambahan, tapi saya belum melihatnya, jadi kami hanya menambahkan pernyataan bahwa ia tidak bertemu, dan kami akan memprosesnya.  Selanjutnya, saya akan menambah nilai yang tertulis dalam instruksi, alamat simbol.  Dan di mana mendapatkannya?  Di sini, seperti yang sudah kita ketahui, opsi dimungkinkan: </p><br><ul><li>  Simbol mengacu pada bagian <code>SHN_ABS</code> .  Maka ambil saja <code>st_value</code> </li><li>  Karakter merujuk ke bagian `SHN_UNDEF.  Kemudian tarik simbol luar </li><li>  Dalam kasus lain, cukup tambal tautan ke bagian lain dari file yang sama` </li></ul><br><h1 id="kak-poprobovat-samomu">  Cara mencobanya sendiri </h1><br><p>  Pertama, apa yang harus dibaca?  Selain spesifikasi yang sudah ditentukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">,</a> masuk akal untuk membaca <a href="">file ini</a> , di mana tim iovisor mengumpulkan informasi yang diekstrak dari kernel Linux melalui eBPF. </p><br><p>  Kedua, bagaimana seharusnya setiap orang bekerja dengan ini?  Pertama, Anda perlu mendapatkan file ELF dari suatu tempat.  Seperti yang dinyatakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di StackOverfow</a> , tim akan membantu kami. </p><br><pre> <code class="bash hljs">clang -O2 -emit-llvm -c bpf.c -o - | llc -march=bpf -filetype=obj -o bpf.o</code> </pre> <br><p>  Kedua, Anda perlu entah bagaimana mendapatkan analisis referensi file menjadi beberapa bagian.  Dalam situasi normal, perintah <code>objdump</code> akan membantu kami: </p><br><pre> <code class="plaintext hljs">$ objdump : objdump &lt;&gt; &lt;()&gt;     &lt;()&gt;.          : -a, --archive-headers Display archive header information -f, --file-headers Display the contents of the overall file header -p, --private-headers Display object format specific file header contents -P, --private=OPT,OPT... Display object format specific contents -h, --[section-]headers Display the contents of the section headers -x, --all-headers Display the contents of all headers -d, --disassemble Display assembler contents of executable sections -D, --disassemble-all Display assembler contents of all sections --disassemble=&lt;sym&gt; Display assembler contents from &lt;sym&gt; -S, --source Intermix source code with disassembly -s, --full-contents Display the full contents of all sections requested -g, --debugging Display debug information in object file -e, --debugging-tags Display debug information using ctags style -G, --stabs Display (in raw form) any STABS info in the file -W[lLiaprmfFsoRtUuTgAckK] or --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames, =frames-interp,=str,=loc,=Ranges,=pubtypes, =gdb_index,=trace_info,=trace_abbrev,=trace_aranges, =addr,=cu_index,=links,=follow-links] Display DWARF info in the file -t, --syms Display the contents of the symbol table(s) -T, --dynamic-syms Display the contents of the dynamic symbol table -r, --reloc Display the relocation entries in the file -R, --dynamic-reloc Display the dynamic relocation entries in the file @&lt;file&gt; Read options from &lt;file&gt; -v, --version Display this program's version number -i, --info List object formats and architectures supported -H, --help Display this information</code> </pre> <br><p>  Tetapi dalam kasus ini, tidak berdaya: </p><br><pre> <code class="plaintext hljs">$ objdump -d test-bpf.o test-bpf.o:   elf64-little objdump:      UNKNOWN!</code> </pre> <br><p>  Lebih tepatnya, itu akan menampilkan bagian, tetapi pembongkaran adalah masalah.  Di sini kita mengingat apa yang kami kumpulkan menggunakan LLVM.  LLVM memiliki analog utilities yang diperluas dari binutils, dengan nama form <code>llvm-&lt; &gt;</code> .  Mereka, misalnya, memahami bitcode LLVM.  Dan mereka juga mengerti eBPF - pasti tergantung pada opsi kompilasi, tetapi karena dikompilasi, itu mungkin harus selalu diurai.  Karena itu, untuk kenyamanan, saya sarankan membuat skrip: </p><br><pre> <code class="bash hljs">vim <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-bpf.c <span class="hljs-comment"><span class="hljs-comment">#     clang -Oz -emit-llvm -c test-bpf.c -o - | llc -march=bpf -filetype=obj -o test-bpf.o llvm-objdump -d -t -r test-bpf.o</span></span></code> </pre> <br><p>  Kemudian untuk sumber seperti itu: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint64_t z; uint64_t func(uint64_t x, uint64_t y) { return x + y + z; }</span></span></span></span></code> </pre> <br><p>  Akan ada hasil seperti itu: </p><br><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 func: 0: bf 20 00 00 00 00 00 00 r0 = r2 1: 0f 10 00 00 00 00 00 00 r0 += r1 2: 18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r1 = 0 ll 0000000000000010: R_BPF_64_64 z 4: 79 11 00 00 00 00 00 00 r1 = *(u64 *)(r1 + 0) 5: 0f 10 00 00 00 00 00 00 r0 += r1 6: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 g F .text 00000038 func 0000000000000000 *UND* 00000000 z</code> </pre> <br><p>  <a href="">Kode</a> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1. QInst: lebih baik kehilangan satu hari, kemudian terbang dalam lima menit (alat tulis itu sepele)</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452592/">https://habr.com/ru/post/id452592/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452576/index.html">Tentang Introvert di TI</a></li>
<li><a href="../id452580/index.html">20 proyek, 20 bahasa, batas waktu kemarin. Bagian 3</a></li>
<li><a href="../id452584/index.html">Pemrogram kesalahpahaman tentang waktu Unix</a></li>
<li><a href="../id452586/index.html">Cara memulai pemrograman di Adobe Illustrator. Bagian satu</a></li>
<li><a href="../id452590/index.html">Amerika menciptakan ruang kelas mobile untuk mengajar anak-anak di sekolah percetakan 3D anggaran rendah, proyek ini telah mengumpulkan lebih dari 100.000</a></li>
<li><a href="../id452596/index.html">735.000 alamat IPv4 diambil dari scammer dan dikembalikan ke registri</a></li>
<li><a href="../id452598/index.html">Manajemen tim pemrogram: bagaimana dan bagaimana memotivasi mereka dengan benar? Bagian satu</a></li>
<li><a href="../id452602/index.html">Cisco Hyperflex untuk Sistem Manajemen Basis Data Beban Tinggi</a></li>
<li><a href="../id452606/index.html">UDB. Apa ini Bagian 8. Mengatasi UDB</a></li>
<li><a href="../id452608/index.html">Bagian 1. QInst: lebih baik kehilangan satu hari, kemudian terbang dalam lima menit (alat tulis itu sepele)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>