<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåò üë©‚Äçüîß üóìÔ∏è Meta-Grammatik f√ºr PEG-Parser üßùüèº ü§∞üèΩ üõåüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Woche machen wir den Parser-Generator "unabh√§ngig", das hei√üt, er wird seinen eigenen Parser generieren. 
 Inhalt der Python PEG Parser-Serie 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta-Grammatik f√ºr PEG-Parser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471990/"><p>  Diese Woche machen wir den Parser-Generator "unabh√§ngig", das hei√üt, er wird seinen eigenen Parser generieren. </p><br><div class="spoiler">  <b class="spoiler_title">Inhalt der Python PEG Parser-Serie</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peg Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Implementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Generierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Visualisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linke rekursive PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinzuf√ºgen von Aktionen zur PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Grammatik f√ºr PEG-Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der verbleibenden Funktionen von PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG auf Core Developer Sprint</a> </li></ul></div></div><br><p> Wir haben also bereits einen Parser-Generator, von dem ein Teil ein Grammatik-Parser ist.  Wir k√∂nnten es einen Meta-Parser nennen.  Der Meta-Parser funktioniert √§hnlich wie der generierte: <code>GrammarParser</code> erbt von <code>Parser</code> und verwendet denselben Mechanismus <code>mark()</code> / <code>reset()</code> / <code>hope()</code> .  Dort wurde jedoch alles von Hand geschrieben.  Aber ist das richtig? </p><a name="habracut"></a><br><p>  Beim Entwerfen eines Compilers ist es √ºblich, dass der Compiler in der Sprache geschrieben wird, die er kompiliert.  Ich erinnere mich mit Liebe daran, dass der Pascal-Compiler, den ich beim ersten Programmieren verwendet habe, in Pascal selbst geschrieben wurde, GCC in C und der Rust-Compiler in Rust. </p><br><p>  Wie kann man das machen?  Implementieren Sie zu Beginn einen Compiler f√ºr eine Teilmenge oder eine fr√ºhere Version einer Sprache in einer anderen Sprache.  (Ich m√∂chte Sie daran erinnern, dass der urspr√ºngliche Pascal-Compiler in FORTRAN geschrieben wurde!) Dann wird der neue Compiler in der Zielsprache geschrieben und mit dem zu Beginn implementierten Bootstrap-Compiler kompiliert.  Sobald der neue Compiler gut genug funktioniert, wird der Bootstrap-Compiler entfernt und jede nachfolgende Version der Sprache oder des Compilers ist auf das beschr√§nkt, was mit der vorherigen Version des Compilers kompiliert werden kann. </p><br><p>  Machen wir es f√ºr unseren Meta-Parser.  Wir werden eine Grammatik f√ºr die Grammatiken schreiben (Meta-Grammatik) und daraus einen neuen Meta-Parser generieren.  Gl√ºcklicherweise habe ich diesen Schritt von Anfang an geplant, so dass es ganz einfach sein wird.  Die Aktionen, die wir in der vorherigen Episode hinzugef√ºgt haben, sind eine wichtige Komponente, da wir den Generator nicht √§ndern m√ºssen und daher eine kompatible Datenstruktur erstellen m√ºssen. </p><br><p>  Hier ist eine vereinfachte Version des Metagramms ohne Aktionen: </p><br><pre> <code class="plaintext hljs">start: rules ENDMARKER rules: rule rules | rule rule: NAME ":" alts NEWLINE alts: alt "|" alts | alt alt: items items: item items | item item: NAME | STRING</code> </pre> <br><p>  Ich zeige Ihnen, wie Sie Aktionen von unten nach oben hinzuf√ºgen.  Erinnern Sie sich an Teil 3, dass es <code>alts</code> gibt, die die <code>alts</code> <code>name</code> und <code>alts</code> .  Anfangs war <code>alts</code> nur eine Liste von <code>alts</code> (eine externe Liste f√ºr Alternativen und eine interne Liste f√ºr jedes Element der Alternative), aber um Aktionen zu implementieren, habe ich sie so ge√§ndert, dass die Alternativen durch <code>Alt</code> Objekte mit <code>items</code> und <code>action</code> .  Elemente werden weiterhin als einfache Zeichenfolgen dargestellt.  F√ºr <code>item</code> wir: </p><br><pre> <code class="plaintext hljs">item: NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  Dies erfordert eine kleine Erkl√§rung: Wenn der Analysator das Token verarbeitet, gibt er ein <code>TokenInfo</code> Objekt mit <code>type</code> , <code>string</code> und anderen Attributen zur√ºck.  Wir m√∂chten nicht, dass der Generator mit <code>TokenInfo</code> Objekten arbeitet, daher extrahieren die Aktionen hier die Zeichenfolge aus dem Token.  Beachten Sie, dass der generierte Parser f√ºr alle Token in Gro√übuchstaben, z. B. <code>NAME</code> , die Zeichenfolgenversion (hier <code>name</code> ) als Namen der Variablen verwendet. </p><br><p>  Als n√§chstes folgen <code>items</code> , die eine Liste von Zeichenfolgen zur√ºckgeben sollen: </p><br><pre> <code class="plaintext hljs">items: item items { [item] + items } | item { [item] }</code> </pre> <br><p>  Hier verwende ich rechtsrekursive Regeln, damit wir nicht von der Verarbeitung der linken Rekursion abh√§ngig sind, die in Teil 5 hinzugef√ºgt wurde. (Warum nicht? Es ist immer gut, die Dinge so einfach wie m√∂glich zu halten, und diese Grammatik wird von einer √Ñnderung unter der linken Rekursion nicht wesentlich profitieren.) Beachten Sie diese <code>item</code> aufgelistet, rekursiv jedoch nicht, da es sich bereits um eine Liste handelt. </p><br><p>  <code>alt</code> Regel zum Erstellen eines <code>Alt</code> Objekts: </p><br><pre> <code class="plaintext hljs">alt: items { Alt(items) }</code> </pre> <br><p>  Ich werde die Aktionen f√ºr <code>rules</code> weglassen und <code>start</code> , wie sie auf diese Weise definiert sind. </p><br><p>  Es gibt jedoch zwei offene Fragen.  Wie finde ich zuerst die Definition der Klassen <code>Rule</code> und <code>Alt</code> ?  Dazu m√ºssen wir dem generierten Code mehrere <code>import</code> hinzuf√ºgen.  Am einfachsten w√§re es, das Flag an den Generator zu √ºbergeben, der besagt, dass dies eine Meta-Grammatik ist, und den Generator zu Beginn des generierten Programms einen zus√§tzlichen <code>import</code> einf√ºgen zu lassen.  Aber jetzt, da wir die Aktionen haben, werden viele andere Parser auch ihren Import anpassen wollen. Warum also nicht sehen, ob wir einen allgemeineren Ansatz implementieren k√∂nnen? </p><br><p>  Es gibt viele M√∂glichkeiten, dies zu implementieren.  Ein einfacher und allgemeiner Mechanismus besteht darin, oben in der Grammatik einen Abschnitt ‚ÄûVariablendefinitionen‚Äú hinzuzuf√ºgen und dem Generator zu erm√∂glichen, diese Variablen zur Steuerung verschiedener Aspekte des generierten Codes zu verwenden.  Ich entschied mich, das <code>@</code> -Symbol zu verwenden, um mit der Definition der Variablen zu beginnen, gefolgt vom Variablennamen ( <code>NAME</code> ) und dem Wert ( <code>STRING</code> ).  Zum Beispiel k√∂nnen wir den folgenden Codeblock oben in die Meta-Grammatik einf√ºgen: </p><br><pre> <code class="plaintext hljs">@subheader "from grammar import Rule, Alt"</code> </pre> <br><p>  Der Parser-Generator druckt den Wert der <code>subheader</code> Variablen nach dem Standardimport, der standardm√§√üig hinzugef√ºgt wird (z. B. zum Importieren von <code>memoize</code> ).  Wenn Sie mehrere <code>import</code> m√∂chten, k√∂nnen Sie eine Zeichenfolge mit dreifachen Anf√ºhrungszeichen verwenden, z. </p><br><pre> <code class="plaintext hljs">@subheader """ from token import OP from grammar import Rule, Alt """</code> </pre> <br><p>  Dies l√§sst sich leicht zur Meta-Grammatik hinzuf√ºgen: Wir werden die <code>start</code> folgt aufteilen: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER | rules ENDMARKER metas: meta metas | meta meta: "@" NAME STRING NEWLINE</code> </pre> <br><p>  (Ich kann mich nicht erinnern, warum ich es "Meta" genannt habe, aber ich habe diesen Namen gew√§hlt, als ich den Code geschrieben habe, und ich werde mich daran halten. :-) </p><br><p>  Wir m√ºssen dies dem Bootstrap-Metaparser hinzuf√ºgen.  Da die Grammatik nicht nur eine Liste von Regeln ist, f√ºgen wir ein Grammatikobjekt mit den Attributen <code>metas</code> und <code>rules</code> .  Wir k√∂nnen die folgenden Aktionen festlegen: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING { (name.string, eval(string.string)) }</code> </pre> <br><p>  (Beachten Sie, dass <code>meta</code> ein Tupel zur√ºckgibt und <code>eval()</code> zum Verarbeiten von Zeichenfolgen in Anf√ºhrungszeichen verwendet.) </p><br><p>  Ich habe die Umsetzung von Ma√ünahmen in den Regeln f√ºr <code>alt</code> !  Der Grund ist, dass sie etwas chaotisch herauskommen.  Aber es macht keinen Sinn, weiter zu verschieben, also hier: </p><br><pre> <code class="plaintext hljs">alt: items action { Alt(items, action) } | items { Alt(items, None) } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Der Schmutz in der Definition wird durch meinen Wunsch verursacht, beliebigen Python-Code zwischen geschweiften Klammern g√ºltig zu machen, einschlie√ülich verschachtelter geschweifter Klammern.  Zu diesem Zweck verwenden wir ein spezielles <code>OP</code> Token, das unseren Tokenizer f√ºr alle von Python erkannten Interpunktionen generiert (R√ºckgabe eines einzelnen Tokens vom Typ <code>OP</code> f√ºr mehrstellige Operatoren wie <code>&lt;=</code> oder <code>**</code> ).  Die einzigen anderen Token, die in Python-Ausdr√ºcken vorkommen k√∂nnen, sind Namen, Zahlen und Zeichenfolgen.  Somit kann der Code zwischen den √§u√üeren Klammern der Aktion anscheinend durch Wiederholungen von <code>NAME | NUMBER | STRING | OP</code> ausgedr√ºckt werden <code>NAME | NUMBER | STRING | OP</code>  <code>NAME | NUMBER | STRING | OP</code> . </p><br><p>  Leider funktioniert dies nicht, da das <code>OP</code> auch mit geschweiften Klammern √ºbereinstimmt. Da der PEG-Analysator immer gierig ist, wird die schlie√üende Klammer erfasst, und wir werden niemals das Ende der Aktion sehen.  Aus diesem Grund f√ºgen wir eine kleine Optimierung hinzu, damit die Aktion einen alternativen Auswahlfehler ausl√∂sen und None zur√ºckgeben kann.  Ich wei√ü nicht, ob dies ein Standardph√§nomen bei anderen PEG-Parsern ist. Ich habe es sofort gefunden, als ich das Problem des Erkennens der schlie√üenden Klammer l√∂sen musste (auch ohne verschachtelte Paare).  Dies scheint gut zu funktionieren, und ich denke, es passt in die allgemeine Philosophie der PEG-Analyse.  Dies kann als eine besondere Form der Voraussicht angesehen werden (auf die ich weiter unten eingehen werde). </p><br><p>  Mit diesem kleinen Hack k√∂nnen wir den Vergleich auf dem <code>OP</code> auf eine geschweifte Klammer fallen lassen.  Dann wird ein Vergleich von <code>stuff</code> und <code>action</code> m√∂glich sein. </p><br><p>  Mit diesen Dingen kann eine Meta-Grammatik von einem Bootstrap-Metaparser analysiert werden, und der Generator kann sie in einen neuen Meta-Parser verwandeln, der sich selbst analysieren kann.  Und vor allem kann der neue Meta-Parser immer noch dieselbe Meta-Grammatik analysieren.  Wenn wir die Meta-Grammatik mit dem neuen Meta-Compiler kompilieren, ist das Ergebnis dasselbe: Dies beweist, dass der generierte Meta-Parser korrekt funktioniert. </p><br><p>  Hier ist die vollst√§ndige Aktions-Meta-Grammatik.  Er kann sich selbst analysieren, da er wei√ü, wie man lange Schlangen kombiniert: </p><br><pre> <code class="plaintext hljs">@subheader """ from grammar import Grammar, Rule, Alt from token import OP """ start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING NEWLINE { (name.string, eval(string.string)) } rules: rule rules { [rule] + rules } | rule { [rule] } rule: NAME ":" alts NEWLINE { Rule(name.string, alts) } alts: alt "|" alts { [alt] + alts } | alt { [alt] } alt: items action { Alt(items, action) } | items { Alt(items, None) } items: item items { [item] + items } | item { [item] } item: NAME { name.string } | STRING { string.string } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Jetzt, da wir eine funktionierende Meta-Grammatik haben, sind wir fast bereit, einige Verbesserungen vorzunehmen. </p><br><p>  Aber zuerst m√ºssen Sie ein wenig nachdenken: leere Zeilen!  Es stellt sich heraus, dass das Modul stdlib tokenize zus√§tzliche Token erstellt, um unbedeutende <code>tokenize</code> ( <code>NL</code> Token) und Kommentare ( <code>COMMENT</code> Token) zu <code>COMMENT</code> .  Anstatt sie in die Grammatik aufzunehmen (ich habe es versucht, es macht wenig Spa√ü!), Gibt es einen sehr einfachen Code, den wir unserer Tokenizer-Klasse hinzuf√ºgen k√∂nnen, um sie zu filtern.  Hier ist die verbesserte <code>peek_token</code> Methode: </p><br><pre> <code class="plaintext hljs"> def peek_token(self): if self.pos == len(self.tokens): while True: token = next(self.tokengen) if token.type in (NL, COMMENT): continue break self.tokens.append(token) self.report() return self.tokens[self.pos]</code> </pre> <br><p>  Dadurch werden die <code>COMMENT</code> und <code>COMMENT</code> Token vollst√§ndig entfernt, sodass wir uns in der Grammatik nicht mehr um sie k√ºmmern m√ºssen. </p><br><p>  Lassen Sie uns zum Schluss die Meta-Grammatik verbessern!  Sie werden rein kosmetisch sein: Ich mag es nicht, wenn ich gezwungen bin, alle Alternativen in einer Zeile zu schreiben.  Die Meta-Grammatik, die ich oben gezeigt habe, analysiert sich aufgrund solcher Dinge nicht selbst: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  Dies liegt an der Tatsache, dass der Tokenizer am Ende der ersten Zeile ein <code>NEWLINE</code> Token erstellt. <code>NEWLINE</code> diesem Moment betrachtet der Meta-Parser dies als das Ende der Regel.  Dar√ºber hinaus folgt auf diese <code>NEWLINE</code> das <code>INDENT</code> Token, da die n√§chste Zeile einger√ºckt ist.  Bis zum Beginn der n√§chsten Regel ist auch ein <code>DEDENT</code> Token vorhanden. </p><br><p>  Hier erfahren Sie, wie Sie damit umgehen.  Um das Verhalten des <code>tokenize</code> Moduls zu verstehen, k√∂nnen wir uns die Reihenfolge der Token ansehen, die f√ºr einger√ºckte Bl√∂cke generiert werden, indem das <code>tokenize</code> Modul als Skript ausgef√ºhrt und Text √ºbergeben wird: </p><br><pre> <code class="plaintext hljs">$ python -m tokenize foo bar baz dah dum ^D</code> </pre> <br><p>  Wir sehen, dass dies die folgende Folge von Token erzeugt (ich habe die Ausgabe des obigen Codes etwas vereinfacht): </p><br><pre> <code class="plaintext hljs">NAME 'foo' NAME 'bar' NEWLINE INDENT NAME 'baz' NEWLINE NAME 'dah' NEWLINE DEDENT NAME 'dum' NEWLINE</code> </pre> <br><p>  Somit wird eine ausgew√§hlte Gruppe von Zeichenfolgen durch <code>INDENT</code> und <code>DEDENT</code> .  Jetzt k√∂nnen wir die Meta-Grammatik- <code>rule</code> f√ºr die <code>rule</code> wie folgt umschreiben: </p><br><pre> <code class="plaintext hljs">rule: NAME ":" alts NEWLINE INDENT more_alts DEDENT { Rule(name.string, alts + more_alts) } | NAME ":" alts NEWLINE { Rule(name.string, alts) } | NAME ":" NEWLINE INDENT more_alts DEDENT { Rule(name.string, more_alts) } more_alts: "|" alts NEWLINE more_alts { alts + more_alts } | "|" alts NEWLINE { alts }</code> </pre> <br><p>  (Ich teile die Aktionen in Zeilen ein, damit sie normal in einer engen Textspalte gelesen werden. Dies ist m√∂glich, weil der Tokenizer Zeilenumbr√ºche in den entsprechenden geschweiften Klammern ignoriert.) </p><br><p>  Das Sch√∂ne daran ist, dass wir den Generator nicht einmal √§ndern m√ºssen: Die Datenstruktur, die durch diese verbesserte Meta-Grammatik erstellt wird, ist dieselbe wie zuvor.  Beachten Sie auch die dritte Option f√ºr die <code>rule</code> : Dies erm√∂glicht uns zu schreiben: </p><br><pre> <code class="plaintext hljs">start: | metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  dass einige es sauberer finden als die Version, die ich zuvor gezeigt habe.  Beide Formen sind leicht zu l√∂sen, sodass wir uns nicht √ºber den Stil streiten m√ºssen. </p><br><p>  Im n√§chsten Beitrag werde ich zeigen, wie ich verschiedene PEG-Funktionen implementiert habe, z. B. optionale Elemente, Wiederholungen und QuickInfos.  (Um ehrlich zu sein, hatte ich vor, in diesem Artikel dar√ºber zu sprechen, aber es ist bereits zu gro√ü. Also werde ich es in zwei Teile teilen.) </p><br><p>  Lizenz f√ºr diesen Artikel und zitierten Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471990/">https://habr.com/ru/post/de471990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471978/index.html">Wir k√∂nnen KI-Systemen nicht vertrauen, die allein auf tiefem Lernen basieren</a></li>
<li><a href="../de471980/index.html">Telefonbetr√ºger. Vierter Akt, Finale ...</a></li>
<li><a href="../de471982/index.html">Die Zukunft von PHP diskutieren</a></li>
<li><a href="../de471986/index.html">Linke rekursive PEG-Grammatik</a></li>
<li><a href="../de471988/index.html">Hinzuf√ºgen von Aktionen zur PEG-Grammatik</a></li>
<li><a href="../de471992/index.html">Implementierung der verbleibenden Funktionen von PEG</a></li>
<li><a href="../de471994/index.html">Arbeiten Sie an PEG im Core Developer Sprint</a></li>
<li><a href="../de471998/index.html">F # 10: Listen</a></li>
<li><a href="../de472000/index.html">‚ÄûF√ºr die Community ist es wichtig, Standards zu setzen‚Äú: Marchin Moskala √ºber Kotlin</a></li>
<li><a href="../de472002/index.html">Umpacken von Paketen in Gradle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>