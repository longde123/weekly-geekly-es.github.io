<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌘 👩‍🔧 🗓️ Meta-Grammatik für PEG-Parser 🧝🏼 🤰🏽 🛌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Woche machen wir den Parser-Generator "unabhängig", das heißt, er wird seinen eigenen Parser generieren. 
 Inhalt der Python PEG Parser-Serie 

...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Meta-Grammatik für PEG-Parser</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471990/"><p>  Diese Woche machen wir den Parser-Generator "unabhängig", das heißt, er wird seinen eigenen Parser generieren. </p><br><div class="spoiler">  <b class="spoiler_title">Inhalt der Python PEG Parser-Serie</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Peg Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Implementierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Generierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG-Parser-Visualisierung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Linke rekursive PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hinzufügen von Aktionen zur PEG-Grammatik</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Meta-Grammatik für PEG-Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementierung der verbleibenden Funktionen von PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEG auf Core Developer Sprint</a> </li></ul></div></div><br><p> Wir haben also bereits einen Parser-Generator, von dem ein Teil ein Grammatik-Parser ist.  Wir könnten es einen Meta-Parser nennen.  Der Meta-Parser funktioniert ähnlich wie der generierte: <code>GrammarParser</code> erbt von <code>Parser</code> und verwendet denselben Mechanismus <code>mark()</code> / <code>reset()</code> / <code>hope()</code> .  Dort wurde jedoch alles von Hand geschrieben.  Aber ist das richtig? </p><a name="habracut"></a><br><p>  Beim Entwerfen eines Compilers ist es üblich, dass der Compiler in der Sprache geschrieben wird, die er kompiliert.  Ich erinnere mich mit Liebe daran, dass der Pascal-Compiler, den ich beim ersten Programmieren verwendet habe, in Pascal selbst geschrieben wurde, GCC in C und der Rust-Compiler in Rust. </p><br><p>  Wie kann man das machen?  Implementieren Sie zu Beginn einen Compiler für eine Teilmenge oder eine frühere Version einer Sprache in einer anderen Sprache.  (Ich möchte Sie daran erinnern, dass der ursprüngliche Pascal-Compiler in FORTRAN geschrieben wurde!) Dann wird der neue Compiler in der Zielsprache geschrieben und mit dem zu Beginn implementierten Bootstrap-Compiler kompiliert.  Sobald der neue Compiler gut genug funktioniert, wird der Bootstrap-Compiler entfernt und jede nachfolgende Version der Sprache oder des Compilers ist auf das beschränkt, was mit der vorherigen Version des Compilers kompiliert werden kann. </p><br><p>  Machen wir es für unseren Meta-Parser.  Wir werden eine Grammatik für die Grammatiken schreiben (Meta-Grammatik) und daraus einen neuen Meta-Parser generieren.  Glücklicherweise habe ich diesen Schritt von Anfang an geplant, so dass es ganz einfach sein wird.  Die Aktionen, die wir in der vorherigen Episode hinzugefügt haben, sind eine wichtige Komponente, da wir den Generator nicht ändern müssen und daher eine kompatible Datenstruktur erstellen müssen. </p><br><p>  Hier ist eine vereinfachte Version des Metagramms ohne Aktionen: </p><br><pre> <code class="plaintext hljs">start: rules ENDMARKER rules: rule rules | rule rule: NAME ":" alts NEWLINE alts: alt "|" alts | alt alt: items items: item items | item item: NAME | STRING</code> </pre> <br><p>  Ich zeige Ihnen, wie Sie Aktionen von unten nach oben hinzufügen.  Erinnern Sie sich an Teil 3, dass es <code>alts</code> gibt, die die <code>alts</code> <code>name</code> und <code>alts</code> .  Anfangs war <code>alts</code> nur eine Liste von <code>alts</code> (eine externe Liste für Alternativen und eine interne Liste für jedes Element der Alternative), aber um Aktionen zu implementieren, habe ich sie so geändert, dass die Alternativen durch <code>Alt</code> Objekte mit <code>items</code> und <code>action</code> .  Elemente werden weiterhin als einfache Zeichenfolgen dargestellt.  Für <code>item</code> wir: </p><br><pre> <code class="plaintext hljs">item: NAME { name.string } | STRING { string.string }</code> </pre> <br><p>  Dies erfordert eine kleine Erklärung: Wenn der Analysator das Token verarbeitet, gibt er ein <code>TokenInfo</code> Objekt mit <code>type</code> , <code>string</code> und anderen Attributen zurück.  Wir möchten nicht, dass der Generator mit <code>TokenInfo</code> Objekten arbeitet, daher extrahieren die Aktionen hier die Zeichenfolge aus dem Token.  Beachten Sie, dass der generierte Parser für alle Token in Großbuchstaben, z. B. <code>NAME</code> , die Zeichenfolgenversion (hier <code>name</code> ) als Namen der Variablen verwendet. </p><br><p>  Als nächstes folgen <code>items</code> , die eine Liste von Zeichenfolgen zurückgeben sollen: </p><br><pre> <code class="plaintext hljs">items: item items { [item] + items } | item { [item] }</code> </pre> <br><p>  Hier verwende ich rechtsrekursive Regeln, damit wir nicht von der Verarbeitung der linken Rekursion abhängig sind, die in Teil 5 hinzugefügt wurde. (Warum nicht? Es ist immer gut, die Dinge so einfach wie möglich zu halten, und diese Grammatik wird von einer Änderung unter der linken Rekursion nicht wesentlich profitieren.) Beachten Sie diese <code>item</code> aufgelistet, rekursiv jedoch nicht, da es sich bereits um eine Liste handelt. </p><br><p>  <code>alt</code> Regel zum Erstellen eines <code>Alt</code> Objekts: </p><br><pre> <code class="plaintext hljs">alt: items { Alt(items) }</code> </pre> <br><p>  Ich werde die Aktionen für <code>rules</code> weglassen und <code>start</code> , wie sie auf diese Weise definiert sind. </p><br><p>  Es gibt jedoch zwei offene Fragen.  Wie finde ich zuerst die Definition der Klassen <code>Rule</code> und <code>Alt</code> ?  Dazu müssen wir dem generierten Code mehrere <code>import</code> hinzufügen.  Am einfachsten wäre es, das Flag an den Generator zu übergeben, der besagt, dass dies eine Meta-Grammatik ist, und den Generator zu Beginn des generierten Programms einen zusätzlichen <code>import</code> einfügen zu lassen.  Aber jetzt, da wir die Aktionen haben, werden viele andere Parser auch ihren Import anpassen wollen. Warum also nicht sehen, ob wir einen allgemeineren Ansatz implementieren können? </p><br><p>  Es gibt viele Möglichkeiten, dies zu implementieren.  Ein einfacher und allgemeiner Mechanismus besteht darin, oben in der Grammatik einen Abschnitt „Variablendefinitionen“ hinzuzufügen und dem Generator zu ermöglichen, diese Variablen zur Steuerung verschiedener Aspekte des generierten Codes zu verwenden.  Ich entschied mich, das <code>@</code> -Symbol zu verwenden, um mit der Definition der Variablen zu beginnen, gefolgt vom Variablennamen ( <code>NAME</code> ) und dem Wert ( <code>STRING</code> ).  Zum Beispiel können wir den folgenden Codeblock oben in die Meta-Grammatik einfügen: </p><br><pre> <code class="plaintext hljs">@subheader "from grammar import Rule, Alt"</code> </pre> <br><p>  Der Parser-Generator druckt den Wert der <code>subheader</code> Variablen nach dem Standardimport, der standardmäßig hinzugefügt wird (z. B. zum Importieren von <code>memoize</code> ).  Wenn Sie mehrere <code>import</code> möchten, können Sie eine Zeichenfolge mit dreifachen Anführungszeichen verwenden, z. </p><br><pre> <code class="plaintext hljs">@subheader """ from token import OP from grammar import Rule, Alt """</code> </pre> <br><p>  Dies lässt sich leicht zur Meta-Grammatik hinzufügen: Wir werden die <code>start</code> folgt aufteilen: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER | rules ENDMARKER metas: meta metas | meta meta: "@" NAME STRING NEWLINE</code> </pre> <br><p>  (Ich kann mich nicht erinnern, warum ich es "Meta" genannt habe, aber ich habe diesen Namen gewählt, als ich den Code geschrieben habe, und ich werde mich daran halten. :-) </p><br><p>  Wir müssen dies dem Bootstrap-Metaparser hinzufügen.  Da die Grammatik nicht nur eine Liste von Regeln ist, fügen wir ein Grammatikobjekt mit den Attributen <code>metas</code> und <code>rules</code> .  Wir können die folgenden Aktionen festlegen: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING { (name.string, eval(string.string)) }</code> </pre> <br><p>  (Beachten Sie, dass <code>meta</code> ein Tupel zurückgibt und <code>eval()</code> zum Verarbeiten von Zeichenfolgen in Anführungszeichen verwendet.) </p><br><p>  Ich habe die Umsetzung von Maßnahmen in den Regeln für <code>alt</code> !  Der Grund ist, dass sie etwas chaotisch herauskommen.  Aber es macht keinen Sinn, weiter zu verschieben, also hier: </p><br><pre> <code class="plaintext hljs">alt: items action { Alt(items, action) } | items { Alt(items, None) } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Der Schmutz in der Definition wird durch meinen Wunsch verursacht, beliebigen Python-Code zwischen geschweiften Klammern gültig zu machen, einschließlich verschachtelter geschweifter Klammern.  Zu diesem Zweck verwenden wir ein spezielles <code>OP</code> Token, das unseren Tokenizer für alle von Python erkannten Interpunktionen generiert (Rückgabe eines einzelnen Tokens vom Typ <code>OP</code> für mehrstellige Operatoren wie <code>&lt;=</code> oder <code>**</code> ).  Die einzigen anderen Token, die in Python-Ausdrücken vorkommen können, sind Namen, Zahlen und Zeichenfolgen.  Somit kann der Code zwischen den äußeren Klammern der Aktion anscheinend durch Wiederholungen von <code>NAME | NUMBER | STRING | OP</code> ausgedrückt werden <code>NAME | NUMBER | STRING | OP</code>  <code>NAME | NUMBER | STRING | OP</code> . </p><br><p>  Leider funktioniert dies nicht, da das <code>OP</code> auch mit geschweiften Klammern übereinstimmt. Da der PEG-Analysator immer gierig ist, wird die schließende Klammer erfasst, und wir werden niemals das Ende der Aktion sehen.  Aus diesem Grund fügen wir eine kleine Optimierung hinzu, damit die Aktion einen alternativen Auswahlfehler auslösen und None zurückgeben kann.  Ich weiß nicht, ob dies ein Standardphänomen bei anderen PEG-Parsern ist. Ich habe es sofort gefunden, als ich das Problem des Erkennens der schließenden Klammer lösen musste (auch ohne verschachtelte Paare).  Dies scheint gut zu funktionieren, und ich denke, es passt in die allgemeine Philosophie der PEG-Analyse.  Dies kann als eine besondere Form der Voraussicht angesehen werden (auf die ich weiter unten eingehen werde). </p><br><p>  Mit diesem kleinen Hack können wir den Vergleich auf dem <code>OP</code> auf eine geschweifte Klammer fallen lassen.  Dann wird ein Vergleich von <code>stuff</code> und <code>action</code> möglich sein. </p><br><p>  Mit diesen Dingen kann eine Meta-Grammatik von einem Bootstrap-Metaparser analysiert werden, und der Generator kann sie in einen neuen Meta-Parser verwandeln, der sich selbst analysieren kann.  Und vor allem kann der neue Meta-Parser immer noch dieselbe Meta-Grammatik analysieren.  Wenn wir die Meta-Grammatik mit dem neuen Meta-Compiler kompilieren, ist das Ergebnis dasselbe: Dies beweist, dass der generierte Meta-Parser korrekt funktioniert. </p><br><p>  Hier ist die vollständige Aktions-Meta-Grammatik.  Er kann sich selbst analysieren, da er weiß, wie man lange Schlangen kombiniert: </p><br><pre> <code class="plaintext hljs">@subheader """ from grammar import Grammar, Rule, Alt from token import OP """ start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) } metas: meta metas { [meta] + metas } | meta { [meta] } meta: "@" NAME STRING NEWLINE { (name.string, eval(string.string)) } rules: rule rules { [rule] + rules } | rule { [rule] } rule: NAME ":" alts NEWLINE { Rule(name.string, alts) } alts: alt "|" alts { [alt] + alts } | alt { [alt] } alt: items action { Alt(items, action) } | items { Alt(items, None) } items: item items { [item] + items } | item { [item] } item: NAME { name.string } | STRING { string.string } action: "{" stuffs "}" { stuffs } stuffs: stuff stuffs { stuff + " " + stuffs } | stuff { stuff } stuff: "{" stuffs "}" { "{" + stuffs + "}" } | NAME { name.string } | NUMBER { number.string } | STRING { string.string } | OP { None if op.string in ("{", "}") else op.string }</code> </pre> <br><p>  Jetzt, da wir eine funktionierende Meta-Grammatik haben, sind wir fast bereit, einige Verbesserungen vorzunehmen. </p><br><p>  Aber zuerst müssen Sie ein wenig nachdenken: leere Zeilen!  Es stellt sich heraus, dass das Modul stdlib tokenize zusätzliche Token erstellt, um unbedeutende <code>tokenize</code> ( <code>NL</code> Token) und Kommentare ( <code>COMMENT</code> Token) zu <code>COMMENT</code> .  Anstatt sie in die Grammatik aufzunehmen (ich habe es versucht, es macht wenig Spaß!), Gibt es einen sehr einfachen Code, den wir unserer Tokenizer-Klasse hinzufügen können, um sie zu filtern.  Hier ist die verbesserte <code>peek_token</code> Methode: </p><br><pre> <code class="plaintext hljs"> def peek_token(self): if self.pos == len(self.tokens): while True: token = next(self.tokengen) if token.type in (NL, COMMENT): continue break self.tokens.append(token) self.report() return self.tokens[self.pos]</code> </pre> <br><p>  Dadurch werden die <code>COMMENT</code> und <code>COMMENT</code> Token vollständig entfernt, sodass wir uns in der Grammatik nicht mehr um sie kümmern müssen. </p><br><p>  Lassen Sie uns zum Schluss die Meta-Grammatik verbessern!  Sie werden rein kosmetisch sein: Ich mag es nicht, wenn ich gezwungen bin, alle Alternativen in einer Zeile zu schreiben.  Die Meta-Grammatik, die ich oben gezeigt habe, analysiert sich aufgrund solcher Dinge nicht selbst: </p><br><pre> <code class="plaintext hljs">start: metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  Dies liegt an der Tatsache, dass der Tokenizer am Ende der ersten Zeile ein <code>NEWLINE</code> Token erstellt. <code>NEWLINE</code> diesem Moment betrachtet der Meta-Parser dies als das Ende der Regel.  Darüber hinaus folgt auf diese <code>NEWLINE</code> das <code>INDENT</code> Token, da die nächste Zeile eingerückt ist.  Bis zum Beginn der nächsten Regel ist auch ein <code>DEDENT</code> Token vorhanden. </p><br><p>  Hier erfahren Sie, wie Sie damit umgehen.  Um das Verhalten des <code>tokenize</code> Moduls zu verstehen, können wir uns die Reihenfolge der Token ansehen, die für eingerückte Blöcke generiert werden, indem das <code>tokenize</code> Modul als Skript ausgeführt und Text übergeben wird: </p><br><pre> <code class="plaintext hljs">$ python -m tokenize foo bar baz dah dum ^D</code> </pre> <br><p>  Wir sehen, dass dies die folgende Folge von Token erzeugt (ich habe die Ausgabe des obigen Codes etwas vereinfacht): </p><br><pre> <code class="plaintext hljs">NAME 'foo' NAME 'bar' NEWLINE INDENT NAME 'baz' NEWLINE NAME 'dah' NEWLINE DEDENT NAME 'dum' NEWLINE</code> </pre> <br><p>  Somit wird eine ausgewählte Gruppe von Zeichenfolgen durch <code>INDENT</code> und <code>DEDENT</code> .  Jetzt können wir die Meta-Grammatik- <code>rule</code> für die <code>rule</code> wie folgt umschreiben: </p><br><pre> <code class="plaintext hljs">rule: NAME ":" alts NEWLINE INDENT more_alts DEDENT { Rule(name.string, alts + more_alts) } | NAME ":" alts NEWLINE { Rule(name.string, alts) } | NAME ":" NEWLINE INDENT more_alts DEDENT { Rule(name.string, more_alts) } more_alts: "|" alts NEWLINE more_alts { alts + more_alts } | "|" alts NEWLINE { alts }</code> </pre> <br><p>  (Ich teile die Aktionen in Zeilen ein, damit sie normal in einer engen Textspalte gelesen werden. Dies ist möglich, weil der Tokenizer Zeilenumbrüche in den entsprechenden geschweiften Klammern ignoriert.) </p><br><p>  Das Schöne daran ist, dass wir den Generator nicht einmal ändern müssen: Die Datenstruktur, die durch diese verbesserte Meta-Grammatik erstellt wird, ist dieselbe wie zuvor.  Beachten Sie auch die dritte Option für die <code>rule</code> : Dies ermöglicht uns zu schreiben: </p><br><pre> <code class="plaintext hljs">start: | metas rules ENDMARKER { Grammar(rules, metas) } | rules ENDMARKER { Grammar(rules, []) }</code> </pre> <br><p>  dass einige es sauberer finden als die Version, die ich zuvor gezeigt habe.  Beide Formen sind leicht zu lösen, sodass wir uns nicht über den Stil streiten müssen. </p><br><p>  Im nächsten Beitrag werde ich zeigen, wie ich verschiedene PEG-Funktionen implementiert habe, z. B. optionale Elemente, Wiederholungen und QuickInfos.  (Um ehrlich zu sein, hatte ich vor, in diesem Artikel darüber zu sprechen, aber es ist bereits zu groß. Also werde ich es in zwei Teile teilen.) </p><br><p>  Lizenz für diesen Artikel und zitierten Code: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de471990/">https://habr.com/ru/post/de471990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de471978/index.html">Wir können KI-Systemen nicht vertrauen, die allein auf tiefem Lernen basieren</a></li>
<li><a href="../de471980/index.html">Telefonbetrüger. Vierter Akt, Finale ...</a></li>
<li><a href="../de471982/index.html">Die Zukunft von PHP diskutieren</a></li>
<li><a href="../de471986/index.html">Linke rekursive PEG-Grammatik</a></li>
<li><a href="../de471988/index.html">Hinzufügen von Aktionen zur PEG-Grammatik</a></li>
<li><a href="../de471992/index.html">Implementierung der verbleibenden Funktionen von PEG</a></li>
<li><a href="../de471994/index.html">Arbeiten Sie an PEG im Core Developer Sprint</a></li>
<li><a href="../de471998/index.html">F # 10: Listen</a></li>
<li><a href="../de472000/index.html">„Für die Community ist es wichtig, Standards zu setzen“: Marchin Moskala über Kotlin</a></li>
<li><a href="../de472002/index.html">Umpacken von Paketen in Gradle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>