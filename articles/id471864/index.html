<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸ”¬ âš—ï¸ ğŸ¤±ğŸ¼ Generasi parser PEG ğŸ¥Ÿ ğŸšˆ ğŸ‘©â€ğŸ‘§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sekarang saya telah membuat sketsa dasar-dasar parser berpemilik, mari beralih ke menghasilkan metodenya dari tata bahasa, seperti yang saya janjikan....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Generasi parser PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471864/"><p> Sekarang saya telah membuat sketsa dasar-dasar parser berpemilik, mari beralih ke menghasilkan metodenya dari tata bahasa, seperti yang saya janjikan.  Saya juga akan menunjukkan bagaimana menerapkan parser packrat menggunakan dekorator <code>@memoize</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Konten Seri Parser Python PEG</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengurai pasak</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Generasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Visualisasi parser PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata Bahasa PEG Rekursif Kiri</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menambahkan Tindakan ke Tata Bahasa PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tata bahasa meta untuk pengurai PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menerapkan fitur PEG yang tersisa</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PEG pada Core Developer Sprint</a> </li></ul></div></div><br><p>  Terakhir kali, kami melihat beberapa metode parser.  Dengan beberapa batasan yang akan kami hapus sedikit kemudian, mereka mudah dihasilkan dari tata bahasa secara otomatis. </p><a name="habracut"></a><br><p>  Kami membutuhkan dua hal: sesuatu yang membaca tata bahasa dan membangun struktur data yang sesuai;  dan sesuatu yang mengambil struktur data ini dan menghasilkan parser.  Kami juga membutuhkan metode pembantu lain, tetapi mereka tidak menarik, jadi saya akan menghilangkannya. </p><br><p>  Jadi, kami membuat kompiler kompiler sederhana.  Saya akan sedikit menyederhanakan notasi tata bahasa sejauh kita hanya memiliki aturan dan alternatif;  ini sebenarnya cukup untuk tata bahasa mainan yang saya gunakan di bagian sebelumnya: </p><br><pre> <code class="plaintext hljs">statement: assignment | expr | if_statement expr: expr '+' term | expr '-' term | term term: term '*' atom | term '/' atom | atom atom: NAME | NUMBER | '(' expr ')' assignment: target '=' expr target: NAME if_statement: 'if' expr ':' statement</code> </pre> <br><p>  Menggunakan notasi penuh, kita dapat menggambarkan tata bahasa sebagai: </p><br><pre> <code class="plaintext hljs">grammar: rule+ ENDMARKER rule: NAME ':' alternative ('|' alternative)* NEWLINE alternative: item+ item: NAME | STRING</code> </pre> <br><p>  Ini adalah meta-grammar pertama kami (tata bahasa untuk tata bahasa), dan generator parser kami akan menjadi kompiler meta (kompiler adalah program yang menerjemahkan program dari satu bahasa ke bahasa lain; meta-kompiler adalah kompiler di mana inputnya adalah tata bahasa, dan outputnya adalah parser). </p><br><p>  Cara mudah untuk menggambarkan tata bahasa meta adalah dengan hanya menggunakan tipe data bawaan: sisi kanan aturan adalah daftar daftar elemen, yang masing-masing dapat berupa string.  (Omong-omong, kami dapat memisahkan <code>NAME</code> dan <code>STRING</code> dengan memeriksa apakah karakter pertama adalah tanda kutip) </p><br><p>  Untuk aturan, saya menggunakan kelas <code>Rule</code> sederhana, dan seluruh tata bahasa adalah daftar objek seperti itu.  Ini adalah kelas <code>Rule</code> , tidak termasuk <code>__repr__</code> dan <code>__eq__</code> : </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rule</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, alts)</span></span></span><span class="hljs-function">:</span></span> self.name = name self.alts = alts</code> </pre> <br><p>  Dan di sini adalah kelas <code>GrammarParser</code> yang menggunakannya: </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GrammarParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grammar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rule := self.rule(): rules = [rule] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> rule := self.rule(): rules.append(rule) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.expect(ENDMARKER): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rules <span class="hljs-comment"><span class="hljs-comment"># &lt;------------- final result self.reset(pos) return None def rule(self): pos = self.mark() if name := self.expect(NAME): if self.expect(":"): if alt := self.alternative(): alts = [alt] apos = self.mark() while (self.expect("|") and (alt := self.alternative())): alts.append(alt) apos = self.mark() self.reset(apos) if self.expect(NEWLINE): return Rule(name.string, alts) self.reset(pos) return None def alternative(self): items = [] while item := self.item(): items.append(item) return items def item(self): if name := self.expect(NAME): return name.string if string := self.expect(STRING): return string.string return None</span></span></code> </pre> <br><p>  Perhatikan penggunaan <code>ENDMARKER</code> .  Di sana saya memastikan bahwa tidak ada yang tersisa setelah aturan terakhir (dan ini bisa terjadi jika ada kesalahan ketik dalam tata bahasa).  Saya juga menunjuk ke tempat di mana metode <code>grammar()</code> mengembalikan daftar aturan.  Segala sesuatu yang lain sangat mirip dengan kelas <code>ToyParser</code> dari artikel terakhir, jadi saya tidak akan memikirkannya.  Hanya perhatikan bahwa <code>item()</code> mengembalikan string, <code>alternative()</code> mengembalikan daftar string, dan variabel <code>alts</code> di dalam <code>rule()</code> mengumpulkan daftar daftar string.  Kemudian, metode <code>rule()</code> menggabungkan nama aturan (string) dan mengubahnya menjadi objek <code>Rule</code> . </p><br><p>  Jika kami menerapkan algoritma ini ke tata bahasa mainan kami, maka metode <code>grammar()</code> akan mengembalikan daftar aturan berikut: </p><br><pre> <code class="plaintext hljs">[ Rule('statement', [['assignment'], ['expr'], ['if_statement']]), Rule('expr', [['term', "'+'", 'expr'], ['term', "'-'", 'term'], ['term']]), Rule('term', [['atom', "'*'", 'term'], ['atom', "'/'", 'atom'], ['atom']]), Rule('atom', [['NAME'], ['NUMBER'], ["'('", 'expr', "')'"]]), Rule('assignment', [['target', "'='", 'expr']]), Rule('target', [['NAME']]), Rule('if_statement', [["'if'", 'expr', "':'", 'statement']]), ]</code> </pre> <br><p>  Sekarang kita memiliki bagian parsing dari kompiler meta kita, mari kita membuat generator kode.  Bersama-sama mereka membentuk kompiler meta dasar: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate_parser_class</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rules)</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">f"class ToyParser(Parser):"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rules: print() print(<span class="hljs-string"><span class="hljs-string">f" @memoize"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" def </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name}</span></span></span><span class="hljs-string">(self):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" pos = self.mark()"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: items = [] print(<span class="hljs-string"><span class="hljs-string">f" if (True"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> alt: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'"'</span></span>, <span class="hljs-string"><span class="hljs-string">"'"</span></span>): print(<span class="hljs-string"><span class="hljs-string">f" and self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: var = item.lower() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> var <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> items: var += str(len(items)) items.append(var) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> item.isupper(): print(<span class="hljs-string"><span class="hljs-string">" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.expect(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">))"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"and (</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{var}</span></span></span><span class="hljs-string"> := self.</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{item}</span></span></span><span class="hljs-string">())"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" ):"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" "</span></span> + <span class="hljs-string"><span class="hljs-string">f"return Node(</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{rule.name!r}</span></span></span><span class="hljs-string">, [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">', '</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.join(items)}</span></span></span><span class="hljs-string">])"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" self.reset(pos)"</span></span>) print(<span class="hljs-string"><span class="hljs-string">f" return None"</span></span>)</code> </pre> <br><p>  Kode ini cukup jelek, tetapi berhasil (semacam), dan di masa depan saya akan menulis ulang. </p><br><p>  Beberapa baris di dalam <code>for alt in rule.alts</code> mungkin memerlukan penjelasan: untuk setiap elemen dalam alternatif, kami memilih satu dari 3 opsi: </p><br><ul><li>  jika elemen tersebut adalah string literal, misalnya <code>'+'</code> , kami menghasilkan <code>self.expect('+')</code> </li><li>  jika elemen huruf besar sepenuhnya, misalnya <code>NAME</code> , kami menghasilkan <code>(name := self.expect(NAME))</code> </li><li>  jika tidak, misalnya, jika <code>expr</code> , kami menghasilkan <code>(expr := self.expr())</code> </li></ul><br><p>  Jika ada beberapa elemen dengan nama yang sama dalam satu varian (misalnya, <code>term '-' term</code> ), maka kami menambahkan digit ke yang kedua.  Ada juga kesalahan kecil di sini yang akan saya koreksi di episode berikutnya. </p><br><p>  Ini sedikit hasil karyanya (seluruh kelas akan sangat membosankan).  Jangan khawatir tentang redundan <code>if (True and</code> ... <code>)</code> kode yang diperlukan sehingga setiap kondisi yang dihasilkan dapat dimulai dengan <code>and</code> .  Kompiler byte Python mengoptimalkan ini. </p><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ToyParser</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Parser)</span></span></span><span class="hljs-class">:</span></span> @memoize <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">statement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (assignment := self.assignment()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [assignment]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (expr := self.expr()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [expr]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (if_statement := self.if_statement()) ): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Node(<span class="hljs-string"><span class="hljs-string">'statement'</span></span>, [if_statement]) self.reset(pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ...</code> </pre> <br><p>  Perhatikan dekorator <code>@memoize</code> : Saya memperkenalkannya untuk beralih ke topik lain: menggunakan memoisasi untuk membuat parser yang dihasilkan cukup cepat. </p><br><p>  Berikut adalah fungsi <code>memoize()</code> yang mengimplementasikan dekorator ini: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  Seperti pada dekorator lainnya, ini berisi fungsi bersarang yang menggantikan (atau membungkus) fungsi yang didekorasi, misalnya, metode <code>statement()</code> dari kelas <code>ToyParser</code> .  Karena fungsi yang dibungkus adalah sebuah metode, wrapper sebenarnya juga adalah sebuah metode: argumen pertamanya disebut <code>self</code> dan merujuk ke instance <code>ToyParser</code> yang disebut metode yang didekorasi. </p><br><p>  Wrapper melakukan cache hasil dari pemanggilan metode untuk setiap posisi input - inilah mengapa ini disebut pengurai packrat!  [sekitar  trans.  packrat adalah "pencuri," tetapi istilah ini tidak diterjemahkan dalam sumber berbahasa Rusia.] Cache adalah kamus kamus, yang disimpan dalam contoh <code>Parser</code> .  Kunci kamus eksternal adalah posisi dalam aliran data input;  Saya juga menambahkan <code>self.memos = {}</code> ke <code>Parser .__ init__()</code> untuk menginisialisasi.  Kamus internal ditambahkan sesuai kebutuhan;  kunci mereka terdiri dari metode dan argumennya.  (Tidak ada argumen dalam desain saat ini, tetapi kami dapat memoisasi fungsi <code>expect()</code> yang memiliki satu, yang cukup sepele) </p><br><p>  Hasil dari metode parser disajikan dalam bentuk tuple, karena sebenarnya ada dua nilai: hasil itu sendiri (untuk metode yang kami hasilkan, ini adalah <code>Node</code> untuk aturan yang cocok) dan sebuah penunjuk ke posisi saat ini di aliran input, yang kami dapatkan dari <code>self.mark()</code> .  Dengan demikian, kami menyimpan nilai kembalian ( <code>res</code> ) dan posisi baru ( <code>endpos</code> ) dalam kamus internal dengan nilai yang di-memo.  Pada panggilan selanjutnya ke metode parsing yang sama dengan argumen yang sama di posisi input yang sama, kami akan mengambilnya dari cache.  Untuk melakukan ini, cukup gerakkan pointer ke posisi input menggunakan <code>self.reset()</code> dan lihat di cache. </p><br><p>  Penting juga untuk men-cache hasil negatif - pada kenyataannya, sebagian besar panggilan akan negatif.  Dalam hal ini, nilai kembali adalah <code>None</code> , dan posisi input tidak berubah.  Anda dapat menambahkan <code>assert</code> untuk memeriksa ini. </p><br><p>  Catatan  Dalam Python, sudah biasa menerapkan cache dalam variabel lokal di fungsi <code>memoize()</code> .  Dalam kasus kami, ini tidak akan berfungsi: seperti yang saya temukan di akhir debugging, setiap instance <code>Parser</code> harus memiliki cache sendiri.  Namun, Anda dapat menyingkirkan kamus bersarang dengan menggunakan ( <code>pos</code> , <code>func</code> , <code>args</code> ) sebagai kuncinya. </p><br><p>  Minggu depan saya akan menyiapkan kode dan jejak untuk menunjukkan bagaimana semua ini sebenarnya dirakit dan dieksekusi ketika mem-parsing contoh program.  Saya masih mencari cara yang lebih baik untuk memvisualisasikan kolaborasi buffer tokenization, parser dan cache.  Mungkin saya akan dapat membuat animasi gif di ASCII alih-alih hanya menampilkan daftar jejak sebagai teks. </p><br><p>  Lisensi untuk artikel ini dan kode yang dikutip: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id471864/">https://habr.com/ru/post/id471864/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id471854/index.html">Heat Death 5G</a></li>
<li><a href="../id471856/index.html">Kami memecahkan semua 42 versi dari teka-teki ramuan Harry Potter</a></li>
<li><a href="../id471858/index.html">RabbitMQ vs Kafka: Kegagalan dan Ketersediaan Tinggi di Cluster</a></li>
<li><a href="../id471860/index.html">Pengurai pasak</a></li>
<li><a href="../id471862/index.html">Implementasi parser PEG</a></li>
<li><a href="../id471866/index.html">Visualisasi parser PEG</a></li>
<li><a href="../id471868/index.html">Genetika cinta: konflik antar gender sebagai dasar kerja sama dalam pasangan burung monogami</a></li>
<li><a href="../id471870/index.html">Penggunaan libdispatch yang efektif</a></li>
<li><a href="../id471872/index.html">Antarmuka dalam C # 8: Asumsi Berbahaya dalam Implementasi Default</a></li>
<li><a href="../id471874/index.html">Bagaimana Kami Melewati Pedoman Peninjauan dan Meluncurkan Server di Telepon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>