<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨ğŸ½â€ğŸ’¼ ğŸš ğŸ—ºï¸ Jam pada lampu pelepasan gas (GRI), mereka adalah jam Nixie ğŸ“‚ ğŸ˜ˆ ğŸ‘©ğŸ¼â€ğŸ”¬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Konsep proyek 
 Konsep produk ini adalah untuk memenuhi kebutuhan untuk melihat nyala api yang sebenarnya. Pelepasan cahaya dalam gas, sebenarnya, buk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jam pada lampu pelepasan gas (GRI), mereka adalah jam Nixie</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431868/"><h3>  Konsep proyek </h3><br>  Konsep produk ini adalah untuk memenuhi kebutuhan untuk melihat nyala api yang sebenarnya.  Pelepasan cahaya dalam gas, sebenarnya, bukan nyala api, meskipun nyalanya seperti nyala api yang nyata. <br>  Saya suka warnanya dan ini adalah satu-satunya motif untuk mulai membuat jam tangan seperti itu untuk saya sendiri dalam satu salinan. <br><br>  Tugas menciptakan perangkat untuk produksi massal tidak dilakukan. <br><br>  Karena itu, anggaran proyek jauh lebih masuk akal.  Keputusan dibuat berdasarkan ide kami sendiri tentang kecantikan, biaya komponen tidak diperhitungkan.  Tentu saja, selalu ada batasan, misalnya, saya tidak membeli GRI (indikator pengeluaran gas) besar seperti IN18 - harganya lebih dari batas yang ditentukan secara intuitif dan tidak sesuai dengan konsep saya tentang penampilan produk.  Saya menggunakan tipe GRI IN-12. <br><a name="habracut"></a><br>  IN12 diisi dengan campuran neon (atau campuran gas inert) dan uap merkuri.  Uap merkuri memberikan peningkatan yang signifikan dalam daya tahan perangkat dan memberikan warna kebiruan pada cahaya plasma.  GRI lain mungkin bebas merkuri dan memberikan cahaya neon yang jernih. <br><br>  Fungsi utama arloji adalah untuk menunjukkan waktu yang tepat (CEP, halo!).  Sangat diinginkan bahwa waktu saat startup diatur secara otomatis dan tidak memerlukan manipulasi dari pengguna.  Dari sudut pandang pribadi saya, tombol pada perangkat semacam itu tidak diperlukan sama sekali.  Perangkat serupa dengan selusin tombol dan ratusan fungsi yang disebabkan oleh berbagai kombinasi penekanan dan waktu pers membuat saya sedih.  Pertama - GRI disesuaikan dengan baik untuk hanya menampilkan angka.  Tidak ada hal lain yang dibayangkan, dan upaya untuk menampilkan item menu, dll., Menurut pendapat saya, gunakan alat yang tidak sesuai.  Hal yang sama berlaku untuk fungsi tambahan seperti jam alarm, dll. <br><br>  Kedua, jelas bahwa tidak realistis untuk mengingat kombinasi penekanan tombol mana yang mengaktifkan fungsi tertanam yang lain.  Program menulis untuk perangkat semacam itu menyenangkan dan menyenangkan, tetapi kemudian mustahil untuk digunakan. <br><br>  Pertanyaan ini sangat dipertimbangkan dalam buku Donald A. Norman Desain hal-hal yang akrab.  Saya akan mengutip satu bagian: <br><br>  <i>â€œSelama perjalanan saya, saya menggunakan proyektor geser Leitz beberapa kali.</i>  <i>Pertama kali adalah mimpi terburuk.</i>  <i>Saya mulai memberi kuliah dan menunjukkan slide pertama.</i>  <i>Ketika perlu untuk pindah ke slide berikutnya, siswa yang bertanggung jawab atas pertunjukan dengan lembut menekan tombol dan mulai menonton dengan ngeri ketika dudukannya bergerak ke arah yang berlawanan, menyelinap keluar dari proyektor slide dan jatuh dari meja ke lantai, mencampur semua slide.</i>  <i>Butuh 15 menit untuk mengatur slide agar.</i>  <i>Bukan siswa yang harus disalahkan untuk ini, tetapi proyektor slide yang elegan ini.</i>  <i>Bagaimana satu tombol dapat melakukan dua fungsi yang berlawanan?</i>  <i>Tidak ada yang bisa melakukannya dengan benar pertama kali. "</i> <i><br><br></i>  <i>Masalahnya adalah bahwa satu tombol melakukan dua fungsi yang berlawanan - tekan sebentar menggeser slide ke depan, yang panjang - kembali. "</i> <br><br>  Kami melanjutkan diskusi pengaturan jam.  Perangkat ini dikonfigurasi secara optimal dari halaman web mereka sendiri menggunakan komputer, tablet, atau smartphone. <br><br>  Saya tidak memerlukan jam alarm untuk jam tangan dengan GRI - pertama, selalu ada telepon seluler dengan fungsi seperti itu dan antarmuka yang jauh lebih nyaman.  Kedua, jam pada GRI tidak dapat menggunakan sumber daya otonom karena konsumsi daya tipikal (200 Volt * 7 mA = 1400 mW atau 1,4 watt) cukup besar dan melampaui batas yang wajar untuk sumber arus kimia.  Oleh karena itu, jam dengan GRI akan diaktifkan oleh jaringan, dan fungsi alarm akan tergantung pada keandalan jaringan. <br><br>  Dari alasan di atas, sistem berikut muncul: <br><br>  Jam GRI dengan daya dari jaringan, dengan kemampuan untuk mengambil waktu yang tepat dari Internet, dengan pengaturan dari halaman webnya sendiri.  Tidak diperlukan fitur tambahan. <br><br>  Meskipun demikian, saya melanggar ketatnya aturan ini dengan menambahkan fitur berikut: <br><br>  Sebuah arloji dapat menunjukkan suhu jalan, kelembaban dan tekanan atmosfer.  Fungsi ini memenuhi kebutuhan pribadi saya untuk mengetahui suhu luar ketika saya mulai bekerja di pagi hari.  Saya mengikatkan baju saya setiap hari di tempat yang sama dan ketika arloji menemukan saya di sana - mereka secara konsisten menunjukkan suhu luar, kelembaban dan tekanan udara dalam milimeter air raksa.  Fungsi ini ternyata sukses dan sangat diminati oleh saya dan anggota keluarga saya.  Data tentang suhu jalan, tekanan dan kelembaban secara otomatis diambil dan disimpan untuk waktu antara paket dari sumber eksternal.  Jika batas waktu terlampaui (data sudah usang), jam menunjukkan tanggal saat ini.  Di sistem rumah saya, data pada parameter lingkungan eksternal tiba pada interval 10 menit, batas waktu "data usang" diatur ke 30 menit.  Ketika merancang arloji, diasumsikan bahwa tim eksternal dapat diberi suara, misalnya, katakan: "Jam, cuaca!".  Namun, selama prototyping, ternyata metode ini tidak dapat diandalkan dan tidak nyaman.  Oleh karena itu, di masa depan, kontrol suara diganti dengan metode untuk menentukan keberadaan seseorang di depan arloji sesuai dengan lokasi pelacak laser waktu terbang.  Jam akan menunjukkan data cuaca jika Anda berdiri di depannya sekitar satu detik. <br><br>  Jam dengan perintah eksternal melalui antarmuka HTTP dapat menampilkan data yang diterima dalam perintah ini.  Tim mentransfer data itu sendiri dan waktu yang ditampilkan di layar.  Itu dikandung sebagai kesempatan untuk menampilkan sesuatu dari komputer oleh peristiwa, misalnya, terlalu panas dari prosesor server rumah atau beberapa parameter lainnya.  Antarmuka tertanam memungkinkan Anda untuk menampilkan kode tujuh digit dari luar, termasuk dua titik.  Dalam praktiknya, itu tidak diterapkan sama sekali. <br><br>  Persyaratan wajib juga mencakup efek pergantian angka yang lancar.  Efek inilah, satu-satunya, saya sangat suka! <br><br>  Kecerahan indikator harus disesuaikan dengan cahaya sekitar, sambil mempertahankan kontras gambar tidak berubah. <br><br>  Jam harus menampilkan enam digit dan satu nilai tambahan di depan digit untuk menunjukkan apa yang sedang ditampilkan. <br><br><h3>  Implementasi dari solusi perangkat keras yang disusun </h3><br><h3>  Temukan GRI </h3><br>  Untuk menampilkan waktu dan data lainnya, empat GRI IN-12A, dua IN-12B dan satu IN-15A digunakan. <br><br>  IN-12B berisi titik-titik yang saya gunakan untuk memisahkan jam-menit-detik. <br><br>  GRI IN-15A dapat menunjukkan sejumlah tanda khusus â€œ+â€, â€œ-â€œ, â€œ%â€, â€œPâ€, dll., Ditempatkan di awal baris. <br><br><h3>  Jarak optimal antara indikator. </h3><br>  Agar arloji terlihat harmonis, jarak tertentu antara indikator harus dipastikan, seperti antara huruf dalam satu baris.  Studi pertanyaan memberi informasi berikut: jarak optimal antara angka-angka adalah 4 mm, antara kata-kata 8 mm.  Jarak optimal antara angka-angka dipastikan dengan indikator pas di panel.  Saya percaya ini bukan kebetulan, insinyur Soviet berpikir dengan kepala mereka selama pengembangan dan membuat jarak yang tepat. <br><br><h3>  Sinkronisasi dengan server waktu </h3><br>  Pertimbangkan cara untuk mendapatkan waktu yang tepat secara otomatis: <br><br><ol><li>  Permintaan melalui Internet ke server waktu yang tepat. </li><li>  Penerima Glonass \ GPS.  Sayangnya, dalam beberapa kasus itu tidak berfungsi: misalnya, di apartemen saya di bagian bawah ruangan sinyal dari satelit menghilang, konfigurasi yang gagal dari bangunan sekitarnya mempengaruhi saya, di mana langit yang jernih hanya terlihat langsung di jendela. </li><li>  Jaringan sel.  Secara teori, Anda dapat meminta waktu dari stasiun seluler tanpa mendaftar (mis., Tanpa kartu SIM).  Saya belum mencoba.  Secara teoritis, cara paling universal yang tidak memerlukan apa pun dari pengguna. </li><li>  Sinyal waktu yang tepat pada panjang gelombang yang panjang.  Sulit untuk aplikasi, tidak ada solusi siap pakai portabel. </li></ol><br>  Menurut pendapat saya, cara terbaik adalah meminta waktu yang tepat melalui Internet.  Perlu dicatat bahwa fungsi bawaan untuk menyimpan waktu saat ini dari ESP8266 ternyata cukup akurat: dalam satu bulan tanpa sengaja memutuskan jalur akses ke jaringan di mana jam yang dijelaskan terhubung ke Internet, keberangkatan kurang dari satu menit.  Saya menentukan ini berdasarkan kebetulan jam dan waktu komputer.  Setelah daya pulih, titik akses disinkronkan secara otomatis. <br><br><h3>  Pilihan prosesor dan sirkuit kontrol GRI </h3><br>  Untuk mengontrol jam diperlukan prosesor dengan kemampuan mengakses Internet.  Dari yang tersedia, ini adalah papan berdasarkan ESP8266.  Studi masalah menunjukkan bahwa papan murah, luas, memiliki perangkat lunak siap pakai yang dibuat oleh penggemar, dapat diprogram di lingkungan Arduino. <br><br><h3>  Pilihan sistem (microcircuit) dari kontrol </h3><br>  GRI ditenagai oleh tegangan yang cukup tinggi sekitar 200 volt.  Menurut paspor (lihat Gbr. 1), IN12 membutuhkan setidaknya 170 volt untuk kemunculan cahaya yang normal pada arus hingga 2 mA.  Sistem kontrol harus dapat mengalihkan arus beberapa miliamp dan menahan tegangan di wilayah 200 volt.  Di Uni Soviet, sirkuit mikro K155ID1 (133ID1, dll.) Diproduksi (decoder decimal biner tegangan tinggi).  Mereka bekerja dengan sempurna dalam mode statis, diperlukan satu decoder per lampu.  Sekarang sirkuit mikro ini tersedia dari stok lama dan bahkan diproduksi dalam batch kecil oleh pabrik Integral Minsk.  Pada prinsipnya, pilihan yang baik untuk jam tangan di sirkuit mikro.  Namun, mereka sulit digunakan dalam sistem mikroprosesor karena terbatasnya jumlah keluaran pada mikroprosesor.  Jadi, jam ESP8266, yang diambil sebagai dasarnya, hanya memiliki selusin kesimpulan, dan beberapa di antaranya memiliki batasan tertentu.  Untuk 7 decoder, diperlukan 28 output, atau register perantara, di mana data harus secara berurutan keluaran dan kemudian output secara paralel dengan K155ID1, yang sangat menyulitkan rangkaian. <br><br><img src="https://habrastorage.org/webt/99/81/ve/9981vejezvjuviohr0l_8xauc_8.gif"><br>  <i>Gambar 1. Paspor indikator debit cahaya IN-12</i> <br><br><img src="https://habrastorage.org/webt/ij/w7/dv/ijw7dvvzivci68gogd0tcyjigfe.jpeg"><br>  <i>Gambar 2. Paspor indikator debit cahaya IN-15</i> <br><br>  Saat menggunakan 155ID1, efek perubahan angka yang mulus membutuhkan indikasi dinamis.  Faktanya adalah bahwa GRI adalah perangkat nonlinier tajam dan sangat sulit untuk mengontrol kecerahannya dengan cara analog dengan mengubah tegangan - sangat sulit karena kemiringan tinggi karakteristik tegangan yang diterapkan saat ini.  Di wilayah dengan kecerahan rendah, pelepasan gas menjadi tidak stabil.  Juga, penerangan eksternal mempengaruhi nyalakan lampu secara stabil - dengan penurunan penerangan eksternal, baik tegangan rusak maupun peningkatan indikator tepat waktu.  Foton eksternal berfungsi sebagai semacam pemantik, penggagas pelepasan.  Omong-omong, kecuraman tinggi dari ketergantungan arus melalui alat pelepasan gas pada tegangan yang diberikan digunakan untuk memperoleh tegangan yang stabil, pada kenyataannya, alat pelepasan gas tersebut adalah penstabil tegangan.  Oleh karena itu, untuk mengontrol kecerahan GDI, penggunaan mode daya berdenyut diperlukan, di mana kecerahan sebanding dengan arus rata-rata melalui GDI, yang pada gilirannya sebanding dengan lebar pulsa. <br><br>  Indikasi dinamis ketika menggunakan 155ID1 + GRI sangat mungkin, tetapi memiliki sejumlah keterbatasan.  Jadi, karena kekhasan sirkuit 155ID1 (elemen kunci bertegangan relatif rendah - hanya 60 volt), flash dari angka tetangga dan efek yang tidak diinginkan lainnya dimungkinkan.  Efek ini diperjuangkan dengan berbagai trik - baik perangkat keras maupun perangkat lunak.  Ada topik besar di situs web RADIOKOT.RU (https://radiokot.ru/forum/viewtopic.php?f=3&amp;t=3210) yang didedikasikan untuk NIXIE CLOCK, saya membaca semuanya dan membuat kesimpulan untuk diri saya sendiri - indikasi dinamis tidak cocok untuk tujuan saya . <br><br>  Pencarian di Internet memberikan pengganti 155ID1 yang sangat baik - ini adalah chip HV5622, yang mewakili register geser 32-bit dengan output tegangan tinggi.  Diagram blok ditunjukkan pada Gambar. 3. <br><br><img src="https://habrastorage.org/webt/rb/nu/xc/rbnuxc9pdbdqrtxg5epadxwbtg8.png"><br>  <i>Gambar 3. Diagram struktural HV5622, Supertex inc.</i>  <i>Â©</i> <br><br>  HV5622 mampu mengalihkan voltase hingga 230 volt, menerima data melalui antarmuka serial dengan frekuensi clock hingga 8 MHz.  Microcircuits dapat dihubungkan secara seri dalam suatu rantai.  Untuk kontrol, hanya 4 output dari MK yang diperlukan: data, sinyal clock, sinyal tulis ke register output, dan sinyal yang diaktifkan.  Satu-satunya hal yang menyebabkan beberapa keraguan adalah ketegangan bergizi.  Menurut manual, itu harus setidaknya 8 volt.  Dan saya ingin memberi daya pada chip dari 5 volt, dan bahkan mengendalikannya dengan sinyal logis dengan level 3.3V.  Di internet, saya menemukan beberapa contoh penggunaan sirkuit mikro semacam itu dan memberi daya dari 5 volt.  Oleh karena itu, selama pengembangan, untuk berjaga-jaga, saya memberikan kesempatan untuk menginstal konverter level logika dan catu daya 5622 dengan tegangan yang lebih tinggi, tetapi tidak segera menginstal node ini.  Praktek telah menunjukkan bahwa semuanya bekerja dengan baik mulai dari 5 volt. <br><br><h3>  Perhatikan Nutrisi </h3><br>  Untuk menyalakan clock pada GRI, diperlukan catu daya dengan dua output: 5 volt dengan arus di wilayah setengah ampere dan 180-200 volt dengan arus sekitar 10 mA.  Secara default, pembuat skema jam tangan tersebut memecahkan masalah daya sebagai berikut: mereka menggunakan catu daya switching eksternal 220 -&gt; 12 volt, yang 5 volt dibuat di dalam jam, dan 180 volt untuk catu daya diperoleh oleh konverter pulsa kedua dari input 12 volt.  Yaitu  sebenarnya, 2 konverter pulsa digunakan dalam rangkaian catu daya umum, yang pertama menghasilkan 220 - 12, dan yang kedua 12 - 180. Menurut pendapat saya, ini tidak efisien.  Oleh karena itu, saya memilih cara tradisional menggunakan transformator toroidal siap pakai TorAN15.  Tampilan transformator ini ditunjukkan pada Gambar. 4. <br><br><img src="https://habrastorage.org/webt/1e/uv/f_/1euvf_52xjsdpo-m64pa5dgxqwy.jpeg"><br>  <i>Gambar 4. Transformator TorAN15</i> <br><br>  Saya membeli transformator ini di situs web ISTOK2.COM.  Trafo memiliki dua gulungan sekunder - satu di 170 volt, yang kedua di 6,3 volt.  Ini memungkinkan untuk bertahan dengan sirkuit catu daya yang paling sederhana.  GRI catu daya tinggi diperbaiki oleh jembatan dioda dan disaring pada kapasitor.  Bagian-bagian ini digunakan dari penghemat lampu neon yang tidak perlu.  Rendah untuk catu daya sirkuit mikro juga diperbaiki oleh jembatan dioda, disaring pada kapasitor elektrolitik dan distabilkan pada penstabil integral 7805. Efisiensi rangkaian semacam itu jauh lebih tinggi daripada sistem dengan dua konversi, keandalan sistem jauh lebih tinggi.  Ditambah lagi tidak adanya gangguan frekuensi tinggi.  Minusnya tidak modis dan transformatornya berat.  Tapi beratnya transformator dalam kasus ini agak plus - saya ingin arloji menjadi sangat besar. <br><br>  Jadi, skema jam didefinisikan: ini adalah modul yang sudah jadi yang didasarkan pada ESP12E, tiga sirkuit mikro HV5622, sensor cahaya berdasarkan MAX44009 dan catu daya tradisional (saya bahkan akan mengatakan konservatif).  Selanjutnya, sebuah simpul untuk menentukan seseorang di depan arloji ditambahkan berdasarkan modul laser pengintai waktu terbang VL53L0X.  Diagram skematik jam ditunjukkan pada Gambar. 5. <br><br><img src="https://habrastorage.org/webt/uo/n7/oy/uon7oyahasvsbxnkajvzm-bz0oi.jpeg"><br>  <i>Gambar 5. Jam Dronsky Nixie.</i>  <i>Diagram skematik</i> <br><br>  Saya membagi pin switching sebagai berikut: tiga lampu pertama - HV5622 pertama, tiga lampu kedua - HV5622 kedua, HV5622 sisanya mengontrol lampu dengan karakter khusus dan titik-titik dalam dua IN12B. <br><br>  Pada tahap desain, tidak jelas apakah saluran SPI akan memiliki kecepatan yang cukup untuk menampilkan data untuk perubahan digit yang lancar.  Fakta bahwa satu detik sekali untuk menghasilkan 96 bit tidak sulit untuk ESP12E tidak diragukan.  Tetapi apakah ada kecepatan yang cukup untuk efek keluaran?  Menurut perhitungan harus cukup dengan margin.  Tapi seperti yang Anda tahu, itu halus di atas kertas ... <br><br>  Oleh karena itu, pada awalnya direncanakan untuk mengeluarkan data dalam tiga tahap, secara terpisah untuk setiap chip.  Tes praktis menunjukkan bahwa saluran SPI memiliki kecepatan yang cukup dengan margin efek yang besar, bahkan dengan frekuensi clock 4 MHz.  Bahkan kemampuan menggandakan kecepatan tidak diklaim.  Akibatnya, semua sirkuit mikro terhubung dalam rantai dan output dari 96 bit dibuat dengan satu perintah.  Menurut perhitungan, waktu keluaran 96 bit harus 24 Î¼s.  Gambar 6 menunjukkan catatan penganalisis logis yang mengeluarkan tujuh karakter pada GRI.  Total waktu output, dengan mempertimbangkan generasi sinyal LE, kurang dari 30 Î¼S. <br><br><img src="https://habrastorage.org/webt/my/iw/-m/myiw-mjjwbqh8sghcw2no7obnzo.png"><br>  <i>Gambar 6. Logic analyzer output HSPI saluran keluaran 96-bit dengan frekuensi clock 4 MHz</i> <br><br>  Pin JAM semua chip digabungkan.  Terminal DI (Input Data) dari sirkuit mikro kedua dan ketiga terhubung ke terminal DO (Data Out) masing-masing dari rangkaian mikro pertama dan kedua.  Pin LE (memungkinkan kait) digabungkan, mereka menerima pulsa yang mentransfer data dari shift ke register output.  Sampai lampu dipindahkan, apa yang disimpan dalam register keluaran adalah keluaran.  Pin BLOCK digabungkan, dihubungkan ke ground melalui resistor 1k, untuk menjaga agar tahap output HV5622 tidak aktif sampai program dimulai pada MK.  Manual merekomendasikan menerapkan daya, membuat output data pertama, dan kemudian menyalakan tahapan output. <br><br><h3>  Kontrol kecerahan </h3><br>  Untuk mengontrol kecerahan GRI untuk menjaga kontras optimal yang konstan dari indikator, output BLOCK digunakan, yang mana sinyal PWM dengan frekuensi 2500 Hz disediakan.  Frekuensi yang cukup tinggi dari sinyal kontrol PWM digunakan, yang menjamin tidak adanya efek strobo, dll. Sesuai dengan norma-norma (Norma dan Peraturan Konstruksi (Norma dan Peraturan Konstruksi) 23 - 05 - 2010 (versi terbaru SNiP 23 - 05 - 95) dan Aturan Sanitasi dan Norma SNPiN 2.21 /2.1.1.1278-03) diyakini bahwa seseorang tidak merasakan frekuensi getaran pencahayaan di atas 300 Hz.  Dalam hal ini, kelebihan frekuensi PWM oleh hampir suatu urutan memberikan tingkat kenyamanan visual yang tepat. <br><br><h3>  Efek dari perubahan angka yang mulus </h3><br>  Untuk mendapatkan efek visual dari perubahan digit yang halus, perlu untuk mengaktifkan digit lama dan baru secara bergantian pada saat mengubah satu digit ke yang lain (biasanya 200-250 ms), dan waktu pembakaran dari digit yang lama akan berkurang, dan yang baru harus meningkat.  Algoritma untuk mengubah digit (perubahan subrutin ()) melakukan 60 siklus.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat memulai algoritme perubahan digit, digit pertama termasuk 100% dari waktu siklus, dan 0% kedua. Ketika siklus berlalu, tepat waktu digit pertama berkurang dari 100% menjadi 0%, dan tepat waktu digit kedua meningkat dari 0% menjadi 100%). Dengan demikian, algoritma untuk mengubah digit dengan lancar lebih dari 200 ms dan 60 siklus mengurangi kecerahan dari digit pertama ke mati, dan yang kedua ke kecerahan penuh. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sisa waktu interval kedua, angka-angka dihidupkan terus menerus dan statis, kecerahan keseluruhan dikurangi dengan mengendalikan indikasi nyala / padam umum sinyal PWM pada terminal BL.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 7 menunjukkan sinyal yang direkam oleh penganalisa logika ketika mengubah angka. </font><font style="vertical-align: inherit;">Dapat dilihat bahwa pada awal subrutin shift, angka lama dihidupkan untuk waktu maksimum, dan yang baru adalah minimum, dan selama shift (sekitar 250 ms), waktu pembakaran dari angka lama berkurang menjadi 0, dan yang baru tumbuh hingga maksimum. </font><font style="vertical-align: inherit;">Secara visual, ini memanifestasikan dirinya sebagai penurunan halus dalam kecerahan gambar lama dengan "pencairan" simultan dari yang baru. </font></font><br><br><img src="https://habrastorage.org/webt/q9/ic/db/q9icdb570c3qwwi3cdxxpoji5tk.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gbr. 7. Merekam sinyal kontrol selama perubahan digit dengan lancar.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rekaman video dari efek diberikan di sini.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1d2PpXAWdis" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan disini </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/iLqac4LQwv8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  dan di sini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/jb82CykLpQA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sinkronisasi dengan server waktu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah mempelajari masalah ini di Internet, saya menyimpulkan bahwa pada dasarnya penulis program sendiri menulis (atau menggunakan pihak ketiga yang sudah jadi) rutin untuk protokol NTP. Ini agak mengejutkan saya, karena Espressif SDK menyebutkan fungsi bawaan untuk bekerja dengan waktu nyata. Fungsionalitas bawaan menyediakan permintaan untuk server waktu (hingga tiga), koreksi waktu (menurut pengamatan saya - permintaan ke server waktu berlangsung setiap 4-6 jam), konversi nilai dalam bentuk waktu Unix ke bentuk yang dapat dibaca manusia, koreksi sesuai dengan waktu yang diberikan- zona. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dari fitur-fitur menggunakan fungsi real-time built-in: nol dikembalikan untuk permintaan waktu pertama dan berikutnya dan diagnostik "jalankan rtc pertama" dikeluarkan. Bagaimana melakukan ini - saya tidak menemukannya dan karenanya hanya menunggu (beberapa detik) hingga waktu selain nol muncul.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algoritma Peluncuran Jam </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika jam dihidupkan, sistem menyala dalam mode klien dan upaya dilakukan untuk menghubungkan ke titik akses dengan rincian yang tersimpan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP8266 mengingat detail ini setelah koneksi sebelumnya yang sukses dengan sendirinya dalam memori layanan. </font><font style="vertical-align: inherit;">Ini adalah fitur yang diterapkan di SDK. </font><font style="vertical-align: inherit;">Jika koneksi ini tidak berhasil, upaya berikutnya dilakukan, tetapi nama dan kata sandi untuk titik akses dibaca dari EEPROM. </font><font style="vertical-align: inherit;">EEPROM juga menyimpan zona waktu (angka dalam rentang -12 - +12), yang kemudian digunakan untuk mengkonversi waktu dengan benar ke format lokal.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika koneksi ini juga tidak berhasil, mode operasi berubah menjadi "titik akses" dan halaman web jam tangan menjadi tersedia di alamat standar 192.168.4.1 untuk perangkat apa pun yang terhubung ke titik akses ini. Dalam kasus saya, nama titik akses adalah ESP_D. Dari ponsel cerdas, tablet, atau laptop, buka halaman perangkat, pilih titik akses dan masukkan kata sandi. Saat mode titik akses aktif, mode klien mati. Ini disebabkan oleh kekhasan perilaku sistem dalam situasi di mana koneksi ke titik akses gagal. Sistem akan terus mengulangi upaya untuk bergabung, hanya akan diisi dengan ini dan praktis tidak ada sumber daya yang tersisa untuk hal lain. Secara lahiriah, ini akan memanifestasikan dirinya sebagai penghambat antarmuka yang tidak menyenangkan. Tampilan halaman ditunjukkan pada Gambar. 8.</font></font><br><br><img src="https://habrastorage.org/webt/8o/am/ie/8oamiekijplb_n_aoqwaj6o9l_a.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 8. Tampilan antarmuka jam WEB dan baris perintah, menunjukkan respons terhadap perintah ping</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada halaman ini semua titik akses yang ditemukan ditampilkan. Titik akses diurutkan berdasarkan kekuatan sinyal, baris teratas adalah titik akses dengan sinyal terkuat dan sangat mungkin yang terdekat (yaitu yang harus Anda ikuti). Anda harus memasukkan kata sandi, pilih zona waktu dan klik OK. Sistem akan mengaktifkan mode "klien" (bersamaan dengan "titik akses"), dan akan mencoba bergabung. Jika koneksi berhasil, maka parameter akan disimpan di EEPROM. Jika koneksi gagal, pesan muncul di halaman dan Anda dapat mencoba lagi untuk memasukkan kata sandi, dll.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah berhasil masuk ke jaringan, mode titik akses akan dimatikan dan hanya mode klien yang akan tetap, yaitu. Halaman tontonan hanya dapat diakses dari jaringan internal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar dapat mengakses arloji dengan nama (dalam kasus saya "esp"), perpustakaan NBNS diluncurkan, yang memberikan respons melalui protokol NetBios. Perpustakaan memungkinkan arloji untuk menanggapi perintah seperti ping esp dan mengaksesnya hanya dengan nama </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk alasan yang tidak jelas bagi saya, ini adalah perpustakaan yang luar biasa yang membentuk respons terhadap permintaan siaran seperti "di alamat apa" nama "itu?" </font><font style="vertical-align: inherit;">dan memungkinkan Anda untuk melupakan prosedur suram menentukan alamat IP perangkat sesuai dengan data internal router (switch), ini digunakan sangat jarang. </font><font style="vertical-align: inherit;">Hampir semua perangkat pada ESP8266 yang dijelaskan di Internet tidak menggunakan mekanisme yang sederhana dan nyaman ini. </font><font style="vertical-align: inherit;">Kemalasan harus memajukan kemajuan - tetapi dalam hal ini itu tidak bergerak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selanjutnya, siklus program utama dimulai, di mana terjadi hal berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Waktu saat ini diinterogasi dan ketika detik berlalu, perubahan tampilan waktu dimulai. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sensor cahaya disurvei dan siklus tugas sinyal PWM disesuaikan, yang mengontrol kecerahan jam. </font><font style="vertical-align: inherit;">Tujuan penyesuaian adalah untuk mempertahankan kontras angka yang konstan saat mengubah pencahayaan di ruangan.</font></font></li><li>    VL53L0X.       ,       2 . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eksperimen menunjukkan bahwa 2 meter berada dalam kondisi ideal ketika selembar kertas putih atau aluminium foil dengan koefisien refleksi mendekati satu digunakan sebagai reflektor. Untuk objek biasa dengan koefisien refleksi tidak sempurna (jaringan, kulit manusia, dll), jarak penentuan percaya diri sedikit lebih dari 1 meter. Jika sensor menunjukkan keberadaan objek di depan arloji, subrutin mulai menampilkan suhu luar ruangan, kelembaban dan tekanan udara. Langkah-langkah diambil untuk beberapa peningkatan kekebalan kebisingan - algoritma paling sederhana "lebih dari 50% operasi" digunakan. Ini berarti bahwa untuk interval 800 ms target harus dideteksi pada jarak kurang dari 1 meter di lebih dari setengah pengukuran rentang. Saat debugging, sistem menunjukkan bahwa biasanya 50-60 operasi diperoleh ketika target berada di bidang pandang sensor.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem deteksi manusia hanya berfungsi ketika target muncul di bidang pandang. Untuk memulai pertunjukan lagi, Anda harus mundur dan kembali. Hal ini dilakukan untuk menghilangkan situasi yang sambil berdiri di depan jam sepanjang waktu parameter eksternal ditampilkan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sensor Laser VL53L0X menggunakan dioda laser IR yang memancarkan pada panjang gelombang 940 nm, aman untuk mata. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video ini menunjukkan reaksi sistem terhadap munculnya hambatan di bidang pandangan laser locator:</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/He5ZtJGpG68" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana awal untuk memicu tampilan data eksternal adalah menggunakan chip pengenalan suara. Untuk melakukan ini, saya menggunakan chip WTK6900B02 (pengenal perintah suara), yang disediakan oleh Sound Technologies. Menurut deskripsi, rangkaian mikro harus mengenali selusin perintah audio dan mengeluarkan kode biner yang sesuai dengan perintah yang diterima. Pulsa dari sirkuit mikro terhubung ke salah satu output ESP8266 dan pengendali interupsi perangkat keras terpasang padanya. Dengan gangguan perangkat keras, fakta pengakuan perintah suara direkam. Sejumlah perintah dalam bahasa Inggris telah direkam sebelumnya dalam chip yang saya terima. Saya berlatih keras dalam "pengucapan yang benar" dari perintah, sehingga mereka dikenali. Ternyata orang harus berbicara bukan dengan pengucapan Oxford, tetapi dengan aksen Cina :)), cukup keras.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun menghabiskan banyak waktu, saya tidak dapat mencapai pengenalan perintah suara yang andal. Yang terbaik yang saya dapatkan adalah sekitar 50% pengakuan yang benar. Oleh karena itu, saya terpaksa menggunakan mekanisme lain untuk memicu tampilan data eksternal - meter jarak laser VL53L0X. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program utama arloji meninggalkan jejak menggunakan sistem kontrol suara.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Program ini juga memiliki bagian untuk membaca data dari sensor ultraviolet VEML6070 mereka. </font><font style="vertical-align: inherit;">Faktanya adalah bahwa saya men-debug program jam secara bergantian di rumah dan di tempat kerja, dan saya hanya memiliki satu sensor MAX44009. </font><font style="vertical-align: inherit;">Oleh karena itu, di tempat kerja, sensor ultraviolet VEML6070 dihubungkan ke ESP8266 dan bagian dari program ditulis yang menentukan sensor mana yang saat ini terhubung. </font><font style="vertical-align: inherit;">Untuk mengetahui algoritma penyesuaian kontras, ini ternyata cukup, dan saya tidak mengubah apa pun di versi final program.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Output data ke register HV5622 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang saya sebutkan di atas, untuk mengontrol lampu pelepasan gas, diperlukan sirkuit mikro yang mampu mengganti tegangan yang cukup tinggi. Saya memilih chip HV5622, yang merupakan register 32-bit dengan penulisan berurutan dan pembacaan paralel. Katoda lampu masing-masing terhubung ke terminal HV5622 mereka. Untuk menyalakan angka tertentu, perlu untuk menghasilkan 0. Untuk dua HV5622 pertama terhubung katoda enam GRI, ke HV5622 ketiga adalah pemisah titik jam-menit dan menit-detik dan katoda lampu ketujuh dengan karakter khusus. Untuk memasukkan angka yang diperlukan dalam lampu, angka 32-bit harus ditampilkan dalam register, di mana log 1 (data di dalam HV5622 terbalik) sesuai dengan katoda yang diperlukan dari lampu. Program ini memiliki array dimensi 10 variabel 32-bit.Setiap elemen dari array tersebut mengandung angka biner dengan log 1 di salah satu posisi, yang hasilnya akan didaftarkan ke pengapian digit yang diinginkan. Karena setiap rangkaian mikro mengontrol beberapa GDI, untuk keluaran, perlu membentuk satu variabel 32-bit dari beberapa elemen, yang sebagian besar terdiri dari logik 0, di mana log 1 berhubungan dengan angka-angka yang diperlukan pada setiap lampu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlu disebutkan bahwa keputusan untuk menggunakan array untuk mengontrol katoda GRI memiliki keuntungan yang serius: jika kesalahan dibuat dan kesimpulan GRI dicampur ketika menyolder kabel dari soket GRI ke soket HV5622, maka untuk memperbaikinya, hanya mengubah konstanta dalam program tanpa menyolder apa pun. Jumlah yang signifikan dan tata letak yang ketat dari kabel HV5622 membuat menyolder dua kabel yang berdekatan menjadi operasi yang sulit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melengkapi ketiga register, perlu untuk menghasilkan 3 variabel 32-bit (total 96 bit). Tidak masuk akal untuk melakukan ini dengan "leverage" - terlalu lama, memakan waktu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untungnya, ESP8266 menggabungkan mekanisme perangkat keras (HSPI) untuk komunikasi serial, dan SDK memiliki fungsi akses ke mekanisme ini. Dengan diluncurkannya mekanisme ini, saya harus menderita. Kesulitannya adalah tidak jelas di mana harus meletakkan variabel 32-bit untuk output dalam mode HSPI. Untuk memahami mekanisme HSPI, saya menggunakan penganalisa logika. Setelah serangkaian percobaan, saya menyadari bahwa 96 bit adalah output, namun, ini adalah nomor 32-bit yang diinginkan di awal dan dua angka 32-bit yang mengandung sampah sembarang. Pencarian di Internet tidak memberikan apa-apa, tetapi pada titik apa saya menyadari bahwa jika ada instruksi seperti WRITE_PERI_REG (SPI_W0 (HSPI), d0); maka Anda dapat mencoba menulis WRITE_PERI_REG (SPI_W1 (HSPI), d1); dan selanjutnya WRITE_PERI_REG (SPI_W2 (HSPI), d2); di mana d0, d1, d2 adalah variabel 32-bit.</font></font> Yaitu<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda harus terlebih dahulu menguraikan data menjadi register SPI_W0 - SPI_W2, dan kemudian mengeluarkan perintah untuk memulai pertukaran. </font><font style="vertical-align: inherit;">Saya juga mencatat bahwa modul HSPI dapat menghasilkan hingga 512 bit dan hanya ada 16 register: W0 - W15. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinyal LE, dimana data ditransfer ke register keluaran HV5622, dihasilkan secara programatik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sistem debugging </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak berani men-debug sistem segera dengan tegangan tinggi penuh (230 volt) dan membuat selusin LED sebagai indikator debug dengan tegangan operasi 5 volt. </font><font style="vertical-align: inherit;">Setelah debugging, ketika saya yakin bahwa LED yang tepat dihidupkan dengan benar, GRI dipasang di panel dan yang tinggi diterapkan. </font><font style="vertical-align: inherit;">Sebagai hasil dari urutan debugging, tidak satu chip atau lampu indikator tunggal rusak :). </font><font style="vertical-align: inherit;">Foto node yang digunakan untuk debugging ditunjukkan pada Gambar 9. </font></font><br><br><img src="https://habrastorage.org/webt/7r/k9/8v/7rk98vqof6l_pkxyrkgqkvrjkja.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gambar 9. Foto perakitan LED debug. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proses debug video singkat di sini</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QJY9gOSSuRQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perumahan </font></font></h3><br>  Gagasan orisinalnya adalah membuat kasus brutal yang terbuat dari logam tebal seperti tembaga, kuningan, atau perunggu.  Namun, karena koneksi Wi-Fi memerlukan rumahan dielektrik, pada versi final hanya panel depan dari logam tebal yang tersisa.  Pencarian sepintas di Internet perusahaan yang melakukan lampiran custom-made menghasilkan angka sekitar 5000 r per enclosure.  Menurut pendapat saya, ini adalah jumlah yang tidak masuk akal dalam situasi saat ini.  Jadi saya mengambil bangunan yang sudah jadi (Gainta G2119C), membelinya dalam perjalanan ke pondok di toko Chip-i-Deep di Shcherbinsk dan berhenti di sana, meninggalkan sejenak pertanyaan dari panel depan dan mungkin bangunan lain. <br><br>  Terlepas dari kekurangan pada bagian dari kotak arloji, saya memutuskan untuk menyatakan hasil yang dicapai dalam artikel tersebut, percaya bahwa solusi sirkuit dan perangkat lunak yang dikembangkan dan diterapkan akan menarik bagi publik. <br><br>  Tampilan kasing hari ini disajikan pada Gambar. 10. <br><br><img src="https://habrastorage.org/webt/ze/bn/4v/zebn4v6lvphsgy-eovfqp6kdi9a.jpeg"><br><br><img src="https://habrastorage.org/webt/rx/jo/gh/rxjoghkpz0xhrl5_j2fvlj0losm.jpeg"><br>  <i>Gambar 10. Tampilan kotak arloji</i> <br><br><h3>  Kesimpulan </h3><br>  Arloji telah bekerja lebih dari satu tahun, tidak ada kegagalan, tugas telah selesai.  Saya akan mencantumkan lagi fitur yang membedakan varian jam tangan saya: <br><br><ul><li>  Mode tampilan statis dengan efek simultan dari perubahan angka yang mulus </li><li>  Menggunakan HV5622 Chips untuk Mengontrol GRI </li><li>  Data HV5622 ditulis menggunakan mesin perangkat keras HSPI </li><li>  Waktu yang tepat diambil dari server waktu yang tepat dari Internet. </li><li>  Akses ke jam dimungkinkan dengan nama dari jaringan internal </li><li>  Pengaturan diperlukan sekali pada awal pertama. </li><li>  Tidak adanya tombol, alarm, dll. </li><li>  Penyesuaian kecerahan cahaya GRI secara bertahap untuk menjaga kontras gambar konstan pada batas perubahan cahaya ambient yang diberikan </li><li>  Arloji bereaksi terhadap pendekatan seseorang dan menunjukkan suhu jalan, kelembaban, tekanan udara. </li></ul><br>  Saya puas :) <br><br>  â†’ Arsip dengan program ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431868/">https://habr.com/ru/post/id431868/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431858/index.html">Mitap Sbertekh di Rostov-on-Don</a></li>
<li><a href="../id431860/index.html">Pada opsi driver Linux, atau bagaimana saya menghabiskan akhir pekan</a></li>
<li><a href="../id431862/index.html">Mitap Sbertekh di Yekaterinburg</a></li>
<li><a href="../id431864/index.html">PVS-Studio ROI: bagaimana tidak kehilangan jutaan (draft versi artikel)</a></li>
<li><a href="../id431866/index.html">Pemrogram kesalahpahaman tentang nama - dengan contoh</a></li>
<li><a href="../id431870/index.html">Pengembang buku interaktif dengan LED mengeluh tentang pencurian ide oleh karyawan Google</a></li>
<li><a href="../id431872/index.html">Panduan JavaScript Bagian 9: Tinjauan Umum tentang Standar ES7, ES8, dan ES9</a></li>
<li><a href="../id431874/index.html">Imba: Bahasa yang kompatibel dengan JavaScript untuk kerja cepat dengan DOM</a></li>
<li><a href="../id431876/index.html">Optimalisasi aplikasi Angular</a></li>
<li><a href="../id431878/index.html">Fitur JavaScript yang kurang dikenal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>