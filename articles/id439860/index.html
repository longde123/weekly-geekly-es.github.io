<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌘 🈴 🧚🏾 Ubuntu 18,04 Root pada ZFS 🚂 🐻 👨🏾‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tahun lalu saya perlu membuat instruksi untuk menginstal sistem operasi Ubuntu 18.04. Omong-omong, tidak ada yang rumit dalam menginstal Ubuntu, tetap...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ubuntu 18,04 Root pada ZFS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439860/"><p>  Tahun lalu saya perlu membuat instruksi untuk menginstal sistem operasi Ubuntu 18.04.  Omong-omong, tidak ada yang rumit dalam menginstal Ubuntu, tetapi ada nuansa: Saya ingin menggunakan sistem file ZFS sebagai basis.  Di satu sisi, Ubuntu mendukung ZFS di tingkat kernel, tetapi belum ada installer untuk itu, tetapi ada instruksi, ya: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/zfsonlinux/zfs/wiki/Ubuntu-18.04-Root-on-ZFS</a> </p><br><p>  Urutan tindakan dalam manual ini umumnya benar, tetapi beberapa poin memerlukan penyesuaian.  Jadi yang berikut ini bukan terjemahan langsung dari instruksi, tetapi gratis, dengan mempertimbangkan koreksi akun, pengalaman saya dengan ZFS dan hal-hal lain.  Saya juga tidak mempertimbangkan masalah enkripsi disk dan menggunakan bootloader MBR.  Instruksi instalasi saya dapat diperoleh di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> </p><br><a name="habracut"></a><br><h2><blockquote>  0. Persiapan server </blockquote></h2><br><p> Hal pertama yang hilang dalam instruksi dan tidak dipertimbangkan dengan cara apa pun adalah bahwa ZFS tidak bekerja dengan baik dengan array RAID perangkat keras, khususnya, itu terhubung dengan cache Write, yang dapat dimengerti: sistem file ZFS dijurnal dan memerlukan kontrol penuh atas operasi penulisan.  Juga, ketika menggunakan array RAID perangkat keras yang sudah jadi, kemampuan ZFS hilang dalam hal Cache, Spare, dan banyak lagi.  Oleh karena itu, semua disk harus ditransfer ke Mode HBA, dan jika tidak memungkinkan untuk melakukan ini, buat RAID terpisah untuk setiap disk dan nonaktifkan pengontrol Write Cache. </p><br><p>  Juga, ketika menggunakan agregasi port jaringan, Anda dapat menonaktifkannya pada tahap instalasi, agar tidak menyulitkannya (saya akan melakukan semua operasi lebih lanjut tanpa ikatan). </p><br><h2>  1. Mempersiapkan lingkungan instalasi </h2><br><h3>  1.1.  Livecd </h3><br><p>  Seperti yang disebutkan sebelumnya, sayangnya, tidak ada penginstal Ubuntu yang sudah jadi menggunakan root pada ZFS, jadi penginstalan dilakukan menggunakan disk LiveCD: </p><br><p>  Unduh dari sini: <a href="">http://releases.ubuntu.com/18.04/ubuntu-18.04.1-desktop-amd64.iso</a> </p><br><blockquote>  Pada saat yang sama, saya mencoba dengan rekan-rekan untuk menggunakan berbagai gambar disk karena saya tidak benar-benar ingin menggunakan shell grafis, tetapi ini tidak mengarah pada sesuatu yang baik. </blockquote><br><p>  Kami boot dari LiveCD, pilih Coba Ubuntu dan buka terminal (Ctrl + Alt + T). </p><br><h3>  1.2.  Memperbarui dan menginstal repositori </h3>  '' <br><pre><code class="bash hljs">sudo apt-add-repository universe sudo apt update</code> </pre> <br><blockquote>  Di sini kita menunggu gelandangan pertama jika pengaturan jaringan server tidak ditentukan oleh DHCP.  Memperbarui repositori tidak akan berfungsi, jadi mari kita atur jaringan. </blockquote><br><p>  Kami melihat antarmuka jaringan dan menemukan yang melaluinya kami akan terhubung: </p><br><pre> <code class="bash hljs">sudo ip a</code> </pre> <br><p>  Konfigurasikan antarmuka jaringan: </p><br><pre> <code class="bash hljs">sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"auto {{ NAME }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"iface {{ NAME }} inet static"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" address {{ IP }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" netmask {{ NETMASK }}"</span></span> &gt;&gt; /etc/network/interfaces sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">" gateway {{ GATEWAY }}"</span></span> &gt;&gt; /etc/network/interfaces sudo service networking restart</code> </pre><br><p>  Dan penyelesai DNS: </p><br><pre> <code class="bash hljs">sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'nameserver 8.8.8.8'</span></span> &gt;&gt; /etc/resolv.conf</code> </pre> <br><p>  Memperbarui repositori: </p><br><pre> <code class="bash hljs">sudo apt update</code> </pre> <br><h3>  1.3.  Server SSH (opsional) </h3><br><p>  Untuk kemudahan instalasi, Anda dapat meningkatkan server OpenSSH dan melakukan semua operasi lebih lanjut melalui klien SSH </p><br><p>  Tetapkan kata sandi untuk pengguna ubuntu: </p><br><pre> <code class="bash hljs">passwd</code> </pre> <br><blockquote>  Ini penting!  Karena sebaliknya, akses melalui ssh akan dilakukan tanpa kata sandi dengan hak sudo.  Namun, Anda tidak dapat mengatur kata sandi sederhana. </blockquote><br><p>  Instal dan jalankan OpenSSH: </p><br><pre> <code class="bash hljs">sudo apt install openssh-server sudo service ssh start</code> </pre> <br><p>  Dan di terminal workstation: </p><br><pre> <code class="bash hljs">ssh ubuntu@{{ ip server }}</code> </pre> <br><h3>  1.4.  Menjadi root </h3><br><pre> <code class="bash hljs">sudo -s</code> </pre> <br><h3>  1.5.  Menginstal Dukungan ZFS di Lingkungan LiveCD </h3><br><pre> <code class="bash hljs">apt install --yes debootstrap gdisk zfs-initramfs</code> </pre> <br><h2>  2. Mempartisi dan memformat hard drive </h2><br><h3><blockquote>  2.0.  Menentukan Array Disk </blockquote></h3><br><p>  Instruksi utama tidak mengandung poin penting tentang cara menentukan array disk. </p><br><p>  Biasanya, jumlah disk di server adalah: </p><br><ul><li>  2 disk; </li><li>  4 disc; </li><li>  banyak disk; </li></ul><br><p>  Kami tidak menganggap 1 disk karena umumnya anomali. </p><br><h4>  2.0.1.  2 disc </h4><br><p>  Semuanya sederhana di sini, satu array MIRROR (RAID1).  Jika ada drive ketiga lain, Anda dapat memasukkannya ke cadangan panas (SPARE) atau merakit array RAIDZ (RAID5).  Tetapi 3 disk di server sangat jarang. </p><br><h4>  2.0.2.  4 disc </h4><br><p>  Jika semua drive sama, hanya ada tiga opsi (RAID0 keempat pada dasarnya saya tidak mempertimbangkan): </p><br><ul><li>  MIRROR + MIRROR adalah analog dari RAID10, lebih tepatnya RAID01, karena di ZFS itu adalah mirror + mirror.  50% dari ruang disk yang tersedia; </li><li>  RAIDZ adalah analog dari RAID5.  75% dari ruang disk yang tersedia; </li><li>  RAIDZ2 adalah analog dari RAID6.  50% dari ruang disk yang tersedia; </li></ul><br><p>  Dalam prakteknya, saya menggunakan array MIRROR + MIRROR, sementara itu jelas bahwa array RAIDZ paling menguntungkan, karena menyediakan lebih banyak ruang disk, tetapi ada nuansa </p><br><p>  Dalam hal toleransi kesalahan, susunan diatur dalam urutan ini (dari yang terbaik ke yang terburuk): </p><br><ul><li>  RAIDZ2 - dua disk dapat hilang tanpa kehilangan data; </li><li>  MIRROR + MIRROR - satu disk dapat hilang tanpa kehilangan data, dan dengan probabilitas 66%, disk kedua dapat hilang tanpa kehilangan data; </li><li>  RAIDZ - hanya satu disk yang bisa hilang tanpa kehilangan data; </li></ul><br><p>  Dalam hal kecepatan, susunan diatur dalam urutan ini: </p><br><ul><li>  CERMIN + CERMIN - baik dalam hal menulis dan membaca; </li><li>  RAIDZ - dalam hal perekaman lebih lambat, karena selain merekam, diperlukan untuk menghitung checksum; </li><li>  RAIDZ2 - dalam hal penulisan lebih lambat karena membutuhkan perhitungan checksum yang lebih kompleks; </li></ul><br><p>  Dalam hal kecepatan array selama degradasi satu disk: </p><br><ul><li>  CERMIN + CERMIN - ketika satu drive jatuh, pada dasarnya hanya pembacaan paralel dari satu cermin yang hilang, cermin kedua bekerja tanpa degradasi kinerja; </li><li>  RAIDZ2 - degradasi dalam degradasi kinerja lebih tinggi karena memerlukan alokasi mundur blok dari checksum untuk 1/4 dari data + pencarian blok </li><li>  RAIDZ - degradasi jauh lebih besar, karena membutuhkan perhitungan ulang blok dari checksum untuk 1/3 dari pencarian data + blok; </li></ul><br><p>  Perbandingan karakteristik bersifat subyektif, tetapi cukup mencerminkan pilihan saya sebagai jalan tengah. </p><br><p>  Pada saat yang sama, Anda perlu memahami bahwa "lebih lambat" dan "bahkan lebih lambat" tidak kadang-kadang, tetapi hanya 10-20% dalam kasus terburuk, oleh karena itu, jika database atau aplikasi Anda untuk bekerja dengan disk tidak dioptimalkan, maka Anda akan menurunkan kecepatan pada prinsipnya, jangan perhatikan.  Faktor kecepatan perekaman harus dipertimbangkan hanya ketika Anda benar-benar membutuhkannya. </p><br><h4>  2.0.2.  Banyak cakram </h4><br><p>  Masalah utama adalah bahwa jika kita memiliki banyak disk dan kita ingin membuat satu array umum untuk semuanya, kita perlu menandai setiap disk dengan sektor boot atau melakukan sedikit tipuan dengan telinga kita.  Dalam praktiknya, untuk platform multi-disk, saya mencoba membangun konfigurasi ini: </p><br><ul><li>  2 disk SSD - kami menjadikan mirror dan sebagai larik boot utama dengan sistem operasi dan cache ZFS untuk larik disk kedua; </li><li>  Sisanya tersumbat dengan disk SATA atau SAS dan tanpa markup kami mengumpulkan array disk ZFS; </li></ul><br><p>  Hal yang sama berlaku untuk server 4-disk jika kita ingin mendapatkan platform yang cukup universal; </p><br><p>  Jika semua disk sama, dan tidak masuk akal untuk mengalokasikan dua disk untuk array terpisah (misalnya, masing-masing 6 disk masing-masing 8 Tb), maka Anda dapat membuat disk yang dapat di-boot dari grup pertama array.  Artinya, jika Anda akan membuat array seperti: MIRROR + MIRROR + MIRROR atau RAIDZ + RAIDZ, maka kami menandai sektor boot hanya untuk grup pertama.  Pada prinsipnya, dimungkinkan untuk mempartisi hanya satu drive sama sekali, bahkan untuk MIRROR dan RAIDZ, dan mengganti sisanya dalam bentuk mentah, ZFS akan membuat array dengan elemen yang lebih kecil itu sendiri, tetapi dalam kasus ini, jika drive pertama gagal, Anda kehilangan satu-satunya disk boot, jadi Anda tidak perlu layak dilakukan. </p><br><p>  Penting untuk dipahami bahwa dalam sistem file ZFS-stripe ini bukan RAID0, dan bekerja sedikit berbeda dan tidak memerlukan ukuran disk yang sama, jadi mengalokasikan ruang kecil untuk sektor boot cuaca tidak akan banyak, hal utama adalah untuk menunjukkan di BIOS disk yang benar untuk boot . </p><br><h3>  2.1.  Partisi dan Pembersihan Disk </h3><br><p>  Paket mdadm digunakan untuk menandai disk, taruh: </p><br><pre> <code class="bash hljs">apt install --yes mdadm</code> </pre> <br><p>  Kami melihat cakram mana yang kami miliki: </p><br><pre> <code class="bash hljs">lsblk</code> </pre> <br><p>  Dan bersihkan mereka: </p><br><pre> <code class="bash hljs">sgdisk --zap-all /dev/{{ disk name }}</code> </pre> <br><h3>  2.2.  Tata letak disk </h3><br><p>  Sebenarnya, partisi boot: </p><br><pre> <code class="bash hljs">sgdisk -a1 -n1:34:2047 -t1:EF02 /dev/{{ disk name }}</code> </pre> <br><p>  Bagian utama. </p><br><blockquote>  Di sini mungkin ada variasi: jika Anda perlu mengalokasikan partisi tambahan disk SSD, misalnya, untuk ZFS Cache atau untuk Aerospike, maka Anda membuat partisi utama dengan volume terbatas: </blockquote><br><pre> <code class="bash hljs">sgdisk -n2:0:+100GB -t2:BF01 /dev/{{ disk name }} sgdisk -n3:0:0 -t2:BF01 /dev/{{ disk name }}</code> </pre><br><p>  Jika kami menggunakan semua ruang, maka cukup buat bagian untuk ruang yang tersisa: </p><br><pre> <code class="bash hljs">sgdisk -n2:0:0 -t2:BF01 /dev/{{ disk name }}</code> </pre> <br><p>  Jangan lupa untuk memeriksa bagaimana hasilnya: </p><br><pre> <code class="bash hljs">lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 1.8T 0 disk ├─sda1 8:1 0 1007K 0 part └─sda2 8:2 0 1.8T 0 part sdb 8:16 0 1.8T 0 disk ├─sdb1 8:17 0 1007K 0 part └─sdb2 8:18 0 1.8T 0 part ...</code> </pre><br><h3>  2.3.  Membuat ZFS Array </h3><br><pre> <code class="bash hljs">zpool create \ -o ashift=12 \ -O atime=off \ -O canmount=off \ -O compression=lz4 \ -O checksum=fletcher4 \ -O normalization=formD \ -m legacy \ -R /mnt \ -f \ tank \ mirror \ /dev/{{ disk a part 2}} \ /dev/{{ disk b part 2}}</code> </pre> <br><blockquote>  Penggaruk pertama di mana salah satu admin saya yang akrab segera melangkah, itu adalah bahwa ketika membuat array ZFS, diperlukan untuk menentukan bukan disk tetapi partisi pada disk, jika itu khusus dibuat untuk ini. </blockquote><br><p>  Selanjutnya, dalam urutan: </p><br><ul><li>  ashift = 12 - gunakan ukuran blok dalam 4K, pada prinsipnya, saya masih tidak mengerti mengapa sering dalam sistem operasi ukuran blok default adalah 512 byte ketika praktis tidak ada disk seperti itu; </li><li>  atime = off - nonaktifkan pembaruan tanggal akses ke file, saya selalu mematikannya karena saya tidak pernah benar-benar membutuhkan informasi ini dan tidak perlu memuat kernel lagi; </li><li>  canmount = off - menonaktifkan kemampuan untuk me-mount partisi root; </li><li>  compression = lz4 - mengaktifkan kompresi data dengan algoritma LZ4.  Parameter ini direkomendasikan untuk dimasukkan tidak hanya untuk menghemat ruang disk, tetapi juga untuk mengurangi jumlah operasi I / O.  Pada saat yang sama, untuk aglomerasi kompresi ini, utilisasi CPU sangat rendah </li><li>  checksum = fletcher4 - algoritma checksum default, dan karenanya fletcher4 layak untuk diperiksa lagi; </li><li>  normalisasi = formD - digunakan untuk meningkatkan kerja dengan UTF-8, pada kenyataannya membatasi kemungkinan menggunakan nama file non-UTF-8.  Di sini setiap orang memutuskan sendiri, dalam pekerjaan kami, kami selalu menggunakan hanya pengkodean UTF-8; </li><li>  xattr = sa - Mempercepat kerja dengan atribut yang diperluas.  Saya tidak menggunakan opsi ini karena ketika opsi ini digunakan, kompatibilitas dengan implementasi OpenZFS lainnya dinonaktifkan (misalnya: FreeBSD).  Dan kompatibilitas dengan Windows dan omong-omong, saya perlu.  Selain itu, opsi ini dapat diaktifkan di bagian akhir; </li><li>  -m legacy - mount point ke mana-mana, dan tidak perlu me-mount partisi root; </li><li>  -R / mnt - awalan pemasangan partisi sementara untuk menginstal kernel; </li><li>  -f - memaksa pembuatan array.  Jika array ZFS dikumpulkan pada disk sebelumnya, maka perintah create tidak akan berfungsi, Anda tidak pernah tahu, mungkin Anda membuat kesalahan dan ingin menghapus data penting; </li></ul><br><blockquote><p>  Saya biasanya menunjukkan nama array disk sistem root sebagai tangki, meskipun saat ini mereka lebih suka menggunakan nama rpool (root pool) di lingkungan Linux.  Dalam praktik saya, saya biasanya menggunakan penamaan array ini: </p><br><ul><li>  tangki - susunan sistem utama; </li><li>  store - array tambahan dengan disk besar untuk penyimpanan data; </li><li>  cache - array tambahan disk SSD, jika partisi utama tidak ada di dalamnya; </li></ul><br><p>  Secara umum, saya sangat merekomendasikan segera mengembangkan praktik penamaan sesuatu yang tidak akan membingungkan. </p></blockquote><br><h2>  3. Instalasi Sistem </h2><br><h3>  3.1.  dan 3.2.  Membuat sistem file root </h3><br><blockquote>  Saya secara khusus menggabungkan paragraf 3.1.  dan 3.2.  karena saya percaya bahwa menentukan partisi root di tingkat ketiga benar-benar berlebihan.  Itu benar, selama beberapa tahun bekerja dengan ZFS, saya tidak pernah perlu melakukan manipulasi dengan partisi root.  Selain itu, ada gambar yang dapat digunakan untuk membuat titik kontrol.  Karena itu, bagian root saya adalah tangki / root: </blockquote><br><pre> <code class="bash hljs">zfs create -o mountpoint=/ tank/root</code> </pre> <br><blockquote>  Pada saat yang sama, kesalahan fatal pertama terdeteksi dalam instruksi asli, yaitu kurangnya partisi boot untuk array disk: </blockquote><br><pre> <code class="bash hljs">zpool <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> bootfs=tank/root tank</code> </pre> <br><h3>  3.3.  Buat partisi tambahan </h3><br><blockquote><p>  Di bagian instruksi dasar ini Anda bisa melempar semuanya dan melupakan.  Orang-orang jelas overdid dengan penghancuran dan pilihan, karena itu, di sepanjang jalan, saya harus memperbaiki sesuatu.  Benar, itu tidak banyak membantu.  Karena masalah kemudian muncul lagi dan pada akhirnya ternyata ini semua tidak berfungsi, oleh karena itu, dalam paragraf 4.11.  ini diperbaiki lagi. </p><br><p>  Memisahkan bagian yang terpisah untuk / var / game terlihat cukup epik.  Saya tidak keberatan, tapi ini jelas terlalu banyak. </p><br><p>  Fakta bahwa partisi dibuat dalam ZFS sederhana dan mendukung hierarki tidak berarti bahwa direktori klasik harus ditinggalkan.  Contoh sederhana: Saya pernah memiliki lebih dari 4K ZFS partisi di grup server, itu perlu, tetapi server reboot melambat selama beberapa menit karena pemasangan partisi ini. </p></blockquote><br><p>  Mari kita mulai dengan yang bersih. </p><br><p>  Ada partisi file statis dan dinamis. </p><br><p>  Bagian file statis termasuk bagian dengan program dan pengaturannya, mereka diisi sekali dan tidak berubah selama operasi.  Pada saat yang sama, partisi statis sebelumnya dibagi menjadi partisi sistem dan pengguna (/ usr), tetapi saat ini mereka dicampur dalam sistem operasi Linux dan tidak ada gunanya memisahkannya, dan itu tidak akan berhasil. </p><br><p>  Bagian file dinamis termasuk bagian yang disimpan: </p><br><ul><li>  Data sementara - persamaan: tmp, swap; </li><li>  Log kerja - mis.: Var / log; </li><li>  Data pengguna - mis.: Rumah; </li><li>  Data - persamaan: var / db dan betapa beruntungnya; </li><li>  Hasil program lainnya dalam bentuk file; </li></ul><br><p>  Dalam keluarga Linux, partisi dinamis termasuk / tmp dan / var, tetapi ini tidak akurat, karena mereka dapat masuk ke / var / lib, program dan perpustakaan, secara umum, semuanya tercampur, tetapi tetap ... </p><br><p>  Pertama, Anda perlu memutuskan apakah akan membuat partisi / tmp pada disk atau dalam memori sebagai tmpfs.  Jika kita buat di disk, lalu buat partisi terpisah untuk itu: </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=legacy tank/tmp</code> </pre> <br><blockquote>  Pilihan com.sun: snapshot otomatis = false setuid = mati dengan baik, tidak peduli bagaimana cuaca dilakukan, jangan menyulitkan.  Tetapi dengan SWAP kita akan lakukan nanti pada langkah 7. </blockquote><br><p>  Pisahkan bagian var secara terpisah: </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=legacy tank/var</code> </pre> <br><p>  Dan bagian pengguna: </p><br><pre> <code class="bash hljs">zfs create -o mountpoint=/home tank/home zfs create -o mountpoint=legacy tank/home/root</code> </pre> <br><blockquote>  Masuk akal untuk mengalokasikan partisi pengguna, karena dalam praktiknya mereka secara berkala tersumbat dengan artefak yang berbeda dan untuk membuatnya lebih mudah untuk memantau mereka, lebih baik untuk membuat partisi yang terpisah untuk mereka, serta direktori home pengguna root (terutama bagi mereka yang suka bekerja sebagai root).  Menggunakan kuota pada direktori pengguna tidak hanya tidak membantu untuk menyumbat ruang disk, tetapi juga mengganggu, karena dalam kasus seperti itu, pengguna mulai meninggalkan artefak di mana saja dan itu bisa sangat sulit untuk menemukannya nanti.  Ini tidak dirawat, jadi Anda hanya perlu mengontrol dan memukul tangan. </blockquote><br><p>  mount point tank / home / root terdaftar sebagai legacy, bukan sebagai / root.  Ini benar, karena pemasangan bagian ini dilakukan di bagian 4.11 </p><br><p>  Sekarang kita perlu me-mount sementara partisi dinamis kita di / mnt: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> /mnt/ mkdir var tmp root mount -t zfs tank/var /mnt/var/ mount -t zfs tank/tmp /mnt/tmp/ mount -t zfs tank/home/root /mnt/root/</code> </pre> <br><h3>  3.4 Memasang kernel </h3><br><blockquote>  Dalam instruksi utama ada beberapa perintah yang tidak perlu, kami tidak memperhatikan, tampaknya artefak percobaan: </blockquote><br><pre> <code class="bash hljs">debootstrap bionic /mnt</code> </pre> <br><p>  Akibatnya, Anda harus mendapatkan sesuatu seperti ini: </p><br><pre> <code class="bash hljs">zfs list NAME USED AVAIL REFER MOUNTPOINT tank 213M 1.76T 96K legacy tank/home 208K 1.76T 96K /mnt/home tank/home/root 112K 1.76T 112K legacy tank/root 147M 1.76T 147M /mnt tank/tmp 96K 1.76T 96K legacy tank/var 64.6M 1.76T 64.6M legacy</code> </pre><br><p>  Ukuran partisi 96K yang kosong, masing-masing, hanya tangki / tmp yang tetap kosong, dan sisanya dicatat selama instalasi kernel, yang berarti bahwa partisi-partisi dipasang dengan benar. </p><br><h2>  4. Konfigurasi sistem </h2><br><h3>  4.1.  Konfigurasikan host dan nama host </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> HOSTNAME &gt; /mnt/etc/hostname <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> “127.0.0.1 localhost” &gt; /mnt/etc/hosts <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> “127.0.0.1 HOSTNAME” &gt;&gt; /mnt/etc/hosts</code> </pre> <br><h3>  4.2.  Konfigurasikan antarmuka jaringan </h3><br><blockquote>  Jadi ya, kami sudah memiliki netplan di sini: </blockquote><br><pre> <code class="bash hljs">nano /mnt/etc/netplan/setup.yaml network: version: 2 renderer: networkd ethernets: eno2: dhcp4: no dhcp6: no addresses: [ {{ IP }}/{{ netmask }}, ] gateway4: {{ gateway IP }} nameservers: addresses: [8.8.8.8]</code> </pre> <br><h3>  4.3.  Konfigurasikan repositori apt </h3><br><pre> <code class="bash hljs">nano /mnt/etc/apt/sources.list deb http://archive.ubuntu.com/ubuntu/ bionic main restricted universe deb http://security.ubuntu.com/ubuntu/ bionic-security main restricted universe deb http://archive.ubuntu.com/ubuntu/ bionic-updates main restricted universe</code> </pre> <br><blockquote>  src - kebanyakan tidak diperlukan </blockquote><br><h3>  4.4.  Kami memasang bagian file virtual LiveCD dan "pergi" ke sistem baru </h3><br><pre> <code class="bash hljs">mount --rbind /dev /mnt/dev mount --rbind /proc /mnt/proc mount --rbind /sys /mnt/sys chroot /mnt /bin/bash --login</code> </pre><br><blockquote>  diperlukan untuk menggunakan - rbind, tetapi tidak - bind </blockquote><br><p>  Kami sudah berada di sistem baru ... </p><br><h3>  4.5.  Atur lingkungan dasar </h3><br><pre> <code class="bash hljs">ln -s /proc/self/mounts /etc/mtab chmod 1777 /tmp apt update</code> </pre> <br><p>  Lokal dan waktu: </p><br><pre> <code class="bash hljs">dpkg-reconfigure locales * en_US.UTF-8 * ru_RU.UTF-8 dpkg-reconfigure tzdata</code> </pre> <br><p>  Dan editor tambahan yang suka apa: </p><br><pre> <code class="bash hljs">apt install --yes vim nano</code> </pre> <br><h3>  4.6.  Menginstal Dukungan ZFS </h3><br><pre> <code class="bash hljs">apt install --yes --no-install-recommends linux-image-generic apt install --yes zfs-initramfs</code> </pre> <br><h3>  4.8.  Instal bootloader </h3><br><p>  Seperti yang dikatakan sebelumnya, saya menggunakan MBR yang sudah ketinggalan zaman: </p><br><pre> <code class="bash hljs">apt install --yes grub-pc</code> </pre> <br><blockquote>  Selama instalasi bootloader, diperlukan untuk memilih semua disk kami yang kami identifikasi sebagai bootable, sementara installer bersumpah pada semua disk lain kecuali yang pertama, kami setuju dan melakukan langkah 5 (tidak jelas mengapa sisanya dibiarkan nanti): </blockquote><br><h4>  4.8.1.  (5.1) Periksa apakah sistem file root dikenali: </h4><br><pre> <code class="bash hljs">grub-probe / zfs</code> </pre> <br><h4>  4.8.2.  (5.2) Memperbarui initrd </h4><br><pre> <code class="bash hljs">update-initramfs -u -k al</code> </pre> <br><h4>  4.8.3.  (5.3) Sederhanakan Debugging GRUB </h4><br><pre> <code class="bash hljs">vi /etc/default/grub ... GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string"><span class="hljs-string">""</span></span> GRUB_CMDLINE_LINUX=<span class="hljs-string"><span class="hljs-string">"console"</span></span> ...</code> </pre><br><h4>  4.8.4.  (5.4.) Memperbarui konfigurasi bootloader </h4><br><pre> <code class="bash hljs">update-grub</code> </pre> <br><h4>  4.8.5.  (5.5.) Instal bootloader pada setiap disk yang ditandai sebagai bootable </h4><br><pre> <code class="bash hljs">grub-install /dev/sda grub-install /dev/sdb ...</code> </pre><br><blockquote>  Penting bahwa perintah ini bekerja dengan benar.  Sejujurnya, saya tidak bisa mendapatkan sebaliknya setidaknya sekali, jadi saya tidak tahu harus berbuat apa, tetapi kemungkinan besar, jika Anda memiliki kesalahan, Anda mungkin melakukan sesuatu yang salah ketika menandai disk (Bagian 2.2.). </blockquote><br><h4>  4.8.6.  (5.6.) Periksa apakah modul ZFS diinstal </h4><br><pre> <code class="bash hljs">ls /boot/grub/*/zfs.mod /boot/grub/i386-pc/zfs.mod</code> </pre> <br><h3>  4.10.  Setel kata sandi root (sulit!) </h3><br><pre> <code class="bash hljs">passwd</code> </pre> <br><blockquote>  Dan ya, kami akan segera menginstal openssh, jika tidak kami akan mendapat kejutan setelah restart jika kami bekerja dari jarak jauh: </blockquote><br><pre> <code class="bash hljs">apt install --yes openssh-server</code> </pre> <br><p>  Jangan lupa untuk memperbaiki konfigurasi sshd: </p><br><pre> <code class="bash hljs">vi /etc/ssh/sshd_config ... PermitRootLogin yes ... PasswordAuthentication yes ...</code> </pre> <br><h3>  4.11.  Memperbaiki sistem file mount </h3><br><blockquote>  Di sini kita sampai pada yang paling menarik.  Faktanya adalah partisi ZFS di-mount setelah dimulainya beberapa daemon (kami juga mengayunkan ZFS_INITRD_ADDITIONAL_DATASETS di / etc / default / zfs), yang, pada gilirannya, membuat beberapa struktur sendiri di / var mulai mengisi log sistem.  Ketika tiba saatnya untuk me-mount partisi ZFS, ternyata titik mount tidak kosong dan tidak ada mount, data tersebar, semuanya buruk.  Oleh karena itu, Anda perlu menentukan titik mount di / etc / fstab karena systemd terutama berfokus pada mereka ketika mengakses folder: </blockquote><br><pre> <code class="bash hljs">vi /etc/fstab tank/var /var zfs noatime,nodev 0 0 tank/tmp /tmp zfs noatime,nodev 0 0 tank/home/root /root zfs noatime,nodev 0 0</code> </pre> <br><blockquote>  Sisanya hingga klausa 6.  sudah selesai </blockquote><br><h2>  6. Reboot pertama </h2><br><h3>  6.1.  Ambil gambar partisi root </h3><br><pre> <code class="bash hljs">zfs snapshot tank/root@setup</code> </pre> <br><blockquote>  Tidak ada artinya dari dia, dalam prakteknya saya tidak pernah mengguncang partisi root dari sistem dan tidak pernah menggunakan snapshot dari partisi ini, tetapi tetap saja bohong, mungkin berguna </blockquote><br><h3>  6.2.  Keluar dari chroot </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> <br><h3>  6.3.  Lepaskan partisi LiveCD dan ekspor larik ZFS </h3><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> mount | grep -v zfs | tac | awk <span class="hljs-string"><span class="hljs-string">'/\/mnt/ {print $3}'</span></span> | xargs -i{} umount -lf {} umount /mnt/root umount /mnt/var umount /mnt/tmp zpool <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> tank</code> </pre> <br><blockquote>  Ekspor array disk diperlukan untuk menghapus cache zfs </blockquote><br><h3>  6.4 Reboot </h3><br><blockquote>  Mem-boot ulang paling baik dilakukan di terminal LiveCD, karena jika Anda bekerja melalui klien ssh, mem-boot ulang itu dapat menyebabkan server "membeku". </blockquote><br><pre> <code class="bash hljs">reboot</code> </pre> <br><blockquote>  Namun, jika ada yang tidak beres dan server tidak mau reboot, maka Anda dapat mem-boot ulang dengan cara apa pun, karena array ZFS diekspor dan sulit untuk merusaknya. </blockquote><br><h3>  6.5.  Kami sedang menunggu untuk reboot dan pergi sebagai root </h3><br><h3>  6.6.  Buat akun pengguna Anda </h3><br><pre> <code class="bash hljs">zfs create tank/home/{{ LOGIN }} useradd -u {{ UID }} -G adm,sudo -d /home/{{ LOGIN }}/ -s /bin/bash {{ LOGIN }} cp -a /etc/skel/.[!.]* /home/{{ LOGIN }} chown -R {{ LOGIN }}:{{ LOGIN }} /home/{{ LOGIN }}</code> </pre> <br><p>  Tambahkan kunci ssh publik ke pengguna dan atur kata sandi untuknya: </p><br><pre> <code class="bash hljs">su - {{ LOGIN }} mkdir .ssh chmod 0700 .ssh vi .ssh/authorized_keys <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> passwd {{ LOGIN }}</code> </pre> <br><blockquote>  Di OpenSSH kami menghapus kemampuan untuk login sebagai otentikasi root dan kata sandi: </blockquote><br><pre> <code class="bash hljs">vi /etc/ssh/sshd_config ... PermitRootLogin no ... PubkeyAuthentication yes ... PasswordAuthentication no ... service ssh restart</code> </pre> <br><h3>  6.7.  6.8.  Tidak lagi diperlukan </h3><br><h2>  7. Mengkonfigurasi swap </h2><br><h3>  7.1.  Buat partisi ZFS </h3><br><pre> <code class="bash hljs">zfs create \ -V 32G \ -b $(getconf PAGESIZE) \ -o compression=<span class="hljs-built_in"><span class="hljs-built_in">zle</span></span> \ -o logbias=throughput \ -o sync=always \ -o primarycache=metadata \ -o secondarycache=none \ tank/swap</code> </pre> <br><ul><li>  -V 32G - Ukuran SWAP kami, Anda dapat menentukan yang benar-benar dibutuhkan; </li><li>  -b $ (getconf PAGESIZE) - ukuran blok (4K dengan ashift = 12); </li><li>  compression = zle - pilih algoritma kompresi yang minimal dalam hal konsumsi sumber daya, pada kenyataannya, karena ukuran blok adalah 4K, kompresi seperti itu tidak akan memungkinkan pemanfaatan I / O, tetapi dimungkinkan untuk menghemat nol blok; </li><li>  logbias = throughput - pengaturan bandwidth untuk mengoptimalkan operasi sinkron; </li><li>  sync = selalu - selalu menyinkronkan catatan.  Ini sedikit mengurangi kinerja, tetapi sepenuhnya menjamin keandalan data; </li><li>  primarycache = metadata - hanya metadata cache, karena swap tidak akan digunakan untuk membaca blok yang sama beberapa kali; </li><li>  secondarycache = none - menonaktifkan cache sekunder sama sekali untuk alasan yang disebutkan di atas; </li></ul><br><h3>  7.2.  Siapkan partisi swap </h3><br><pre> <code class="bash hljs">mkswap -f /dev/zvol/tank/swap <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> /dev/zvol/tank/swap none swap defaults 0 0 &gt;&gt; /etc/fstab <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> RESUME=none &gt; /etc/initramfs-tools/conf.d/resume</code> </pre><br><h3>  7.3.  Aktifkan swap </h3><br><pre> <code class="bash hljs">swapon -av</code> </pre> <br><blockquote><p>  Mengikuti petunjuk, tidak banyak yang menarik, karena sangat tergantung pada preferensi administrator tertentu dan tugas server secara keseluruhan, kecuali satu titik, yaitu: "Boot darurat" </p><p>  Dan jangan lupa untuk memasang Firewall </p></blockquote><br><h2>  R. Boot darurat </h2><br><p>  Kami menyiapkan lingkungan instalasi (item 1.) </p><br><p>  Selama persiapan, array ZFS diimpor, jadi Anda perlu mengimpornya kembali, tetapi dengan titik pemasangan yang benar: </p><br><pre> <code class="bash hljs">zpool <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> -a zpool import -N -R /mnt tank zfs mount -a</code> </pre> <br><blockquote> , ,      ,        fstab,    : </blockquote><br><pre> <code class="bash hljs">mount -t zfs tank/var /mnt/var/ mount -t zfs tank/tmp /mnt/tmp/ mount -t zfs tank/home/root /mnt/root/</code> </pre> <br><p> ,   ,   chroot   .4.4.,          . 6.3. </p><br><h2> D.   </h2><br><p>   3.3.             .      ,        : ,       /spool,      /data.       ZFS     . </p><br><h2>  Ringkasan </h2><br><ul><li>       ZFS  ,     ,     ; </li><li>        ZFS,                 ,     .    ZFS —       ,   ; </li><li>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">.</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439860/">https://habr.com/ru/post/id439860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439850/index.html">Deteksi Emosi Kontekstual dalam Percakapan Tekstual Menggunakan Jaringan Saraf Tiruan</a></li>
<li><a href="../id439852/index.html">Aplikasi Remote Control Rilis: Aspia 1.1.0</a></li>
<li><a href="../id439854/index.html">Eh, sekali, sekali lagi: apa yang harus dilakukan dengan klien di CRM setelah dia membeli</a></li>
<li><a href="../id439856/index.html">Yandex! Terima kasih untuk Uber</a></li>
<li><a href="../id439858/index.html">Prometheus + Grafana + Eksportir Node + Docker di Azure dengan pemberitahuan di Telegram</a></li>
<li><a href="../id439862/index.html">Acara digital di Moskow dari 11-17 Februari</a></li>
<li><a href="../id439864/index.html">Manajemen pengetahuan, mengapa dan bagaimana kami melakukannya</a></li>
<li><a href="../id439866/index.html">Prinsip-prinsip merancang direktori tata nama dalam 1C Enterprise Management 2 (ERP 2.4.6)</a></li>
<li><a href="../id439868/index.html">Hidup tanpa Facebook: pandangan yang kurang radikal, suasana hati yang baik, lebih banyak waktu untuk orang yang dicintai. Sekarang dibuktikan oleh sains</a></li>
<li><a href="../id439870/index.html">Video sebagai mesin kemajuan: evolusi sistem pengawasan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>