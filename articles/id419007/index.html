<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🔧 👼🏼 🥞 Tekstur untuk intro 64k: bagaimana hal itu dilakukan hari ini 💃🏾 🍅 👩🏿‍🚒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini adalah bagian kedua dari seri H-Immersion kami . Bagian pertama dapat dibaca di sini: Immersion in Immersion . 

 Saat membuat animasi han...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tekstur untuk intro 64k: bagaimana hal itu dilakukan hari ini</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419007/">  <i>Artikel ini adalah bagian kedua dari seri</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>H-Immersion kami</i></a> <i>.</i>  <i>Bagian pertama dapat dibaca di sini:</i> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>Immersion in Immersion</i></a> <i>.</i> <br><br>  Saat membuat animasi hanya 64 KB, sulit untuk menggunakan gambar yang sudah jadi.  Kami tidak dapat menyimpannya dengan cara tradisional, karena tidak cukup efisien, bahkan jika Anda menerapkan kompresi, misalnya JPEG.  Solusi alternatif adalah pembuatan prosedural, yaitu, penulisan kode yang menjelaskan pembuatan gambar selama eksekusi program.  Implementasi kami atas solusi ini adalah generator tekstur - bagian mendasar dari rantai alat kami.  Dalam posting ini kami akan menjelaskan bagaimana kami mengembangkan dan menggunakannya dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>H - Immersion</i></a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/2ee/a7e/6a82eea7ea42a6ca5cf4b437545b3893.jpg"></div><br>  <i>Lampu sorot bawah laut menerangi detail dasar laut.</i> <br><a name="habracut"></a><br><h2>  Versi awal </h2><br>  Generasi tekstur adalah salah satu elemen paling awal dari basis kode kami: tekstur prosedural sudah digunakan dalam pengantar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>B - Inkubasi</i></a> pertama kami.  <a href="">Kode</a> terdiri dari serangkaian fungsi yang mengisi, menyaring, mengubah, dan menggabungkan tekstur, serta satu loop besar yang mem-bypass semua tekstur.  Fungsi-fungsi ini ditulis dalam C ++ murni, tetapi interaksi C API kemudian ditambahkan sehingga mereka dapat dievaluasi oleh penerjemah C <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PicoC</a> .  Pada saat itu, kami menggunakan PicoC untuk mengurangi waktu yang dibutuhkan oleh setiap iterasi: dengan cara ini kami dapat mengubah dan memuat ulang tekstur selama pelaksanaan program.  Beralih ke subset C adalah pengorbanan kecil dibandingkan dengan kenyataan bahwa sekarang kita dapat mengubah kode dan melihat hasilnya segera, tanpa repot dengan menutup, mengkompilasi ulang, dan memuat ulang seluruh demo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70d/88e/4c9/70d88e4c948bfbd24f7d003b5a92f6af.png"></div><br>  <i>Menggunakan pola sederhana, sedikit suara dan deformasi, kita bisa mendapatkan tekstur kayu bergaya.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e28/a67/83b/e28a6783bd53715bb1514bc6aa2c655f.jpg"></div><br>  <i>Dalam adegan ini dari</i> bengkel F - Felix, <i>berbagai tekstur kayu digunakan.</i> <br><br>  Untuk beberapa waktu, kami menjelajahi kemampuan generator ini, dan sebagai hasilnya diposting di server web dengan skrip PHP kecil dan antarmuka web sederhana.  Kita bisa menulis kode tekstur dalam bidang teks, dan skrip meneruskannya ke generator, yang kemudian membuang hasilnya sebagai file PNG untuk ditampilkan pada halaman.  Segera, kami mulai membuat sketsa di tempat kerja saat istirahat makan siang dan berbagi karya kecil kami dengan anggota kelompok lainnya.  Interaksi ini memotivasi kami untuk proses kreatif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/be6/722/f15be672247f38176102734d115a5001.png"></div><br>  <i>Galeri web generator tekstur lama kami.</i>  <i>Semua tekstur dapat diedit di browser.</i> <br><br><h2>  Desain ulang penuh </h2><br>  Untuk waktu yang lama, penghasil tekstur hampir tidak berubah;  kami pikir itu baik, dan efektivitas kami berhenti meningkat.  Tetapi begitu kami mengetahui bahwa ada banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seniman</a> di forum Internet yang menunjukkan tekstur yang dihasilkan sepenuhnya secara prosedural, serta mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tantangan</a> pada berbagai topik.  Konten prosedural pernah menjadi fitur adegan demo, tetapi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Allegorithmic</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ShaderToy</a> dan alat serupa membuatnya dapat diakses oleh masyarakat umum.  Kami tidak memperhatikan hal ini, dan mereka mulai dengan mudah menempatkan kami di tulang belikat.  Tidak bisa diterima <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/12a/7cb/e33/12a7cbe33257454ca8e23c53dd84ef00.jpg"></div><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sofa kain</a></i>  <i>Tekstur kain yang sepenuhnya prosedural dibuat di Substance Designer.</i>  <i>Dikirim oleh: Imanol Delgado.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.artstation.com/imanoldelgado</a></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b3e/25a/47e/b3e25a47ed73c407de4335f5e58cc87b.jpg" alt="gambar"></div><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lantai Hutan</a> .</i>  <i>Tekstur tanah hutan sepenuhnya prosedural dibuat oleh Substance Designer.</i>  <i>Diposting oleh Daniel Thiger.</i>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.artstation.com/dete</a></i> <br><br>  Kami telah lama perlu memikirkan kembali alat kami.  Untungnya, bertahun-tahun bekerja dengan generator tekstur yang sama memungkinkan kami untuk mengenali kekurangannya.  Selain itu, generator mesh kami yang baru lahir juga memberi tahu kami seperti apa tampilan pipa konten prosedural. <br><br>  Kesalahan arsitektur yang paling penting adalah implementasi generasi sebagai serangkaian operasi dengan objek tekstur.  Dari sudut pandang perspektif tingkat tinggi, ini mungkin pendekatan yang tepat, tetapi dari sudut pandang implementasi, fungsi-fungsi seperti <b>tekstur. Melakukan sesuatu ()</b> atau <b>Menggabungkan (tekstur A, tekstur B)</b> memiliki kelemahan serius. <br><br>  Pertama, gaya OOP mengharuskan Anda untuk mendeklarasikan fungsi-fungsi ini sebagai bagian dari API, tidak peduli sesederhana apa mereka.  Ini adalah masalah serius karena tidak skala dengan baik dan, yang lebih penting, menciptakan gesekan yang tidak perlu dalam proses kreatif.  Kami tidak ingin mengubah API setiap kali kami perlu mencoba sesuatu yang baru.  Ini menyulitkan eksperimen dan membatasi kebebasan kreatif. <br><br>  Kedua, dalam hal kinerja, pendekatan ini mengharuskan Anda untuk memproses data tekstur dalam siklus sebanyak operasi.  Ini tidak akan terlalu penting jika operasi ini mahal sehubungan dengan biaya mengakses fragmen memori yang besar, tetapi biasanya tidak demikian.  Dengan pengecualian pada sebagian kecil operasi, misalnya, menghasilkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kebisingan</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengisian</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Perlin</a> , mereka pada dasarnya sangat sederhana dan hanya memerlukan beberapa instruksi pada titik tekstur.  Artinya, kami mengelak data tekstur untuk melakukan operasi sepele, yang sangat tidak efisien dari sudut pandang caching. <br><br>  Struktur baru memecahkan masalah-masalah ini melalui reorganisasi logika.  Sebagian besar fungsi dalam praktik secara independen melakukan operasi yang sama untuk setiap elemen tekstur.  Oleh karena itu, alih-alih menulis fungsi tekstur. Melakukan sesuatu <b>()</b> yang memintas semua elemen, kita dapat menulis tekstur. <b>Menerapkan</b> Fungsi <b>(f)</b> , di mana <b>f (elemen)</b> bekerja hanya untuk elemen tekstur tunggal.  Kemudian <b>f (elemen)</b> dapat ditulis sesuai dengan tekstur tertentu. <br><br>  Ini sepertinya perubahan kecil.  Namun, struktur ini menyederhanakan API, membuat kode generasi lebih fleksibel dan ekspresif, lebih ramah cache, dan memungkinkan pemrosesan paralel dengan mudah.  Banyak pembaca sudah menyadari bahwa ini pada dasarnya adalah shader.  Namun, implementasi yang sebenarnya tetap kode C ++ dieksekusi pada prosesor.  Kami masih mempertahankan kemampuan untuk melakukan operasi di luar loop, tetapi gunakan opsi ini hanya bila perlu, misalnya, dengan konvolusi. <br><br><h3>  Itu: </h3><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . // API . //    -  API. //      . class ProceduralTexture { void DoSomething(parameters) { for (int i = 0; i &lt; size; ++i) { //   . (*this)[i] = … } } void PerlinNoise(parameters) { … } void Voronoi(parameters) { … } void Filter(parameters) { … } void GenerateNormalMap() { … } }; void GenerateSomeTexture(texture t) { t.PerlinNoise(someParameter); t.Filter(someOtherParameter); … //  .. t.GenerateNormalMap(); }</span></span></code> </pre> <br><h3>  Itu menjadi: </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       . // API . //     . //      . class ProceduralTexture { void ApplyFunction(functionPointer f) { for (int i = 0; i &lt; size; ++i) { //    . (*this)[i] = f((*this)[i]); } } }; void GenerateNormalMap(ProceduralTexture t) { … } void SomeTextureGenerationPass(void* out, PixelInfo in) { result = PerlinNoise(in); result = Filter(result); … //  .. *out = result; } void GenerateSomeTexture(texture t) { t.ApplyFunction(SomeTextureGenerationPass); GenerateNormalMap(t); }</span></span></code> </pre> <br><h2>  Paralelisasi </h2><br>  Pembuatan tekstur membutuhkan waktu, dan kandidat yang jelas untuk mengurangi waktu ini adalah eksekusi kode paralel.  Paling tidak, Anda dapat mempelajari cara membuat beberapa tekstur sekaligus.  Inilah yang kami lakukan untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>bengkel F <em>-</em> Felix</i></a> , dan ini sangat mengurangi waktu muat. <br><br>  Namun, ini tidak menghemat waktu di tempat yang paling dibutuhkan.  Masih membutuhkan banyak waktu untuk menghasilkan satu tekstur.  Ini berlaku untuk perubahan karena kami terus memuat ulang tekstur berulang kali sebelum setiap modifikasi.  Sebagai gantinya, lebih baik untuk memparalelkan kode penghasil tekstur internal.  Karena sekarang kode pada dasarnya terdiri dari satu fungsi besar yang diterapkan dalam satu loop ke setiap texel, paralelisasi menjadi sederhana dan efisien.  Mengurangi biaya percobaan, penyetelan, dan konsep, yang secara langsung memengaruhi proses kreatif. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/cb7/21f/ac9cb721febdfc0b32300bb02f84fefe.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/191/c1e/a6d/191c1ea6de84670abe256fb67e7dc165.jpg"></div><br>  <i>Ilustrasi sebuah ide yang kami eksplorasi dan dibuang untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>H - Immersion</i></a> : dekorasi mosaik dengan lapisan orichalcon.</i>  <i>Ini ditunjukkan di alat penyuntingan interaktif kami.</i> <br><br><h2>  Pembuatan sisi GPU </h2><br>  Jika ini masih belum jelas, maka saya akan mengatakan bahwa generasi tekstur sepenuhnya dilakukan dalam CPU.  Mungkin beberapa dari Anda membaca kalimat-kalimat ini sekarang dan bingung “tetapi mengapa?!”.  Tampaknya langkah yang jelas adalah menghasilkan tekstur pada prosesor video.  Untuk memulainya, itu akan meningkatkan tingkat generasi dengan urutan besarnya.  Jadi mengapa kita tidak menggunakannya? <br><br>  Alasan utamanya adalah tujuan desain ulang kecil kami adalah tetap menggunakan CPU.  Beralih ke GPU akan berarti lebih banyak pekerjaan.  Kami harus menyelesaikan masalah tambahan yang masih belum cukup berpengalaman.  Bekerja dengan CPU, kami memiliki pemahaman yang jelas tentang apa yang kami inginkan, dan kami tahu cara memperbaiki kesalahan sebelumnya. <br><br>  Namun, kabar baiknya adalah, berkat struktur baru, bereksperimen dengan GPU sekarang tampaknya cukup sepele.  Menguji kombinasi kedua jenis prosesor akan menjadi percobaan yang menarik untuk masa depan. <br><br><h2>  Generasi tekstur dan bayangan fisik yang akurat </h2><br>  Keterbatasan lain dari desain lama adalah bahwa tekstur dianggap hanya sebagai gambar RGB.  Jika kami perlu menghasilkan lebih banyak informasi, katakanlah tekstur difus dan tekstur normals untuk permukaan yang sama, maka tidak ada yang mencegah kami melakukan ini, tetapi API tidak banyak membantu.  Ini menjadi sangat penting dalam konteks Fisik Berbasis Shading (PBR). <br><br>  Dalam pipa tradisional tanpa PBR, tekstur warna biasanya digunakan, di mana banyak informasi dipanggang.  Tekstur seperti itu sering mewakili penampilan akhir permukaan: mereka sudah memiliki volume tertentu, retakan menjadi gelap, dan bahkan mungkin ada refleksi pada mereka.  Jika beberapa tekstur digunakan secara bersamaan, maka detail skala besar dan kecil biasanya digabungkan untuk menambah peta normal atau reflektifitas permukaan. <br><br>  Konveyor PBR permukaan biasanya menggunakan beberapa set tekstur yang mewakili nilai fisik daripada hasil artistik yang diinginkan.  Tekstur warna difus, yang paling dekat dengan apa yang sering disebut "warna" permukaan, biasanya datar dan tidak menarik.  Specular warna ditentukan oleh indeks bias permukaan.  Sebagian besar detail dan variabilitas diambil dari tekstur normals dan roughness (kekasaran) (yang seseorang dapat anggap sama, tetapi dengan dua skala yang berbeda).  Reflektivitas yang dirasakan dari suatu permukaan menjadi konsekuensi dari tingkat kekasarannya.  Pada tahap ini, akan lebih logis untuk berpikir dalam hal bukan material, tetapi material. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e6/ad2/e95/2e6ad2e9555afadc279ff0227d1ff54a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2d/3a4/71f/c2d3a471f7fb9a352db83454e0288a91.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/446/8d1/52c/4468d152ce8ba5b8a4f563c8cc428533.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b58/dad/d05/b58dadd05ca838c5fdc4ec5daec0855b.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6a8/2ee/a7e/6a82eea7ea42a6ca5cf4b437545b3893.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/156/2a7/53f/1562a753fe3172e4add501ed110d3f7d.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f1e/91d/c4e/f1e91dc4ec162b76e1ba139f22e0e1d9.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/627/9e8/cf56279e8263eaea1411824f60d10503.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a9/525/b03/0a9525b03c6033b76587107f7a87a4bf.jpg"></div><br>  Struktur baru memungkinkan kita untuk mendeklarasikan format piksel sembarang untuk tekstur.  Setelah menjadikannya bagian dari API, kami mengizinkannya untuk menangani semua kode boilerplate.  Setelah mendeklarasikan format piksel, kami dapat fokus pada kode materi iklan tanpa menghabiskan terlalu banyak upaya memproses data ini.  Pada saat dijalankan, itu akan menghasilkan beberapa tekstur dan secara transparan mentransfernya ke GPU. <br><br>  Dalam beberapa pipa PBR, warna difus dan specular tidak ditransmisikan secara langsung.  Sebagai gantinya, parameter "warna dasar" dan "logam" digunakan, yang memiliki kelebihan dan kekurangan.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>H - Immersion,</i></a> kami menggunakan model specular difus +, dan material biasanya terdiri dari lima lapisan: <br><br><ol><li>  Warna difus (RGB; 0: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Vantablack</a> ; 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salju segar</a> ). </li><li>  Warna specular (RGB: fraksi cahaya dipantulkan pada 90 °, juga dikenal sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><i>F0</i> atau <i>R0</i></a> ). </li><li>  Kekasaran (A; 0: sangat halus; 1: seperti karet). </li><li>  Normal (XYZ; vektor satuan). </li><li>  Elevation of terrain (A; digunakan untuk pemetaan oklusi paralaks). </li></ol><br>  Saat digunakan, informasi emisi cahaya ditambahkan langsung ke shader.  Kami tidak merasa perlu untuk memiliki oklusi ambien, karena di sebagian besar adegan tidak ada pencahayaan sama sekali.  Namun, saya tidak akan terkejut bahwa kita akan memiliki lapisan tambahan atau jenis informasi lainnya, misalnya, anisotropi atau opacity. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b8/185/de9/8b8185de93298b085276109a8f30efef.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2c/6bb/876/a2c6bb876297e1b0a21fbe8463e19b66.jpg"></div><br>  Gambar di atas menunjukkan percobaan terbaru dengan menghasilkan oklusi ambien lokal berdasarkan ketinggian.  Untuk setiap arah, kita melalui jarak yang telah ditentukan dan mempertahankan kemiringan terbesar (perbedaan ketinggian dibagi dengan jarak).  Kemudian kami menghitung oklusi dari kemiringan rata-rata. <br><br><h2>  Kendala dan pekerjaan di masa depan </h2><br>  Seperti yang Anda lihat, struktur baru telah menjadi peningkatan besar dari yang lama.  Selain itu, ia mendorong ekspresi kreatif.  Namun, dia masih memiliki keterbatasan yang ingin kita hilangkan di masa depan. <br><br>  Sebagai contoh, meskipun tidak ada masalah dalam pengantar ini, kami perhatikan bahwa alokasi memori bisa menjadi kendala.  Saat menghasilkan tekstur, satu array nilai float digunakan.  Dengan tekstur besar dengan banyak lapisan, Anda dapat dengan cepat menemukan masalah dengan alokasi memori.  Ada berbagai cara untuk menyelesaikannya, tetapi mereka semua memiliki kekurangan.  Sebagai contoh, kita dapat menghasilkan tekstur ubin per ubin, sementara skalabilitas akan lebih baik, namun implementasi beberapa operasi, seperti konvolusi, menjadi kurang jelas. <br><br>  Selain itu, dalam artikel ini, terlepas dari kata "bahan" yang digunakan, kami hanya berbicara tentang tekstur, tetapi tidak tentang shader.  Namun, penggunaan material juga harus mengarah pada shader.  Kontradiksi ini mencerminkan keterbatasan struktur yang ada: pembentukan tekstur dan bayangan adalah dua bagian terpisah yang dipisahkan oleh jembatan.  Kami mencoba membuatnya mudah untuk menyeberangi jembatan ini, tetapi sebenarnya kami ingin bagian ini menjadi satu.  Misalnya, jika suatu material memiliki parameter statis dan dinamis, maka kami ingin menggambarkannya di satu tempat.  Ini adalah topik yang kompleks dan kami belum tahu apakah ada solusi yang baik, tapi jangan maju dulu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a5/ee7/42d/0a5ee742d8f5f83b3f0255176caa90c3.jpg" alt="gambar"></div><br>  <i>Eksperimen untuk membuat tekstur kain yang mirip dengan karya Imadol Delgado yang ditunjukkan di atas.</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id419007/">https://habr.com/ru/post/id419007/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418997/index.html">Kontribusi Nyata ke Sumber Terbuka Nyata</a></li>
<li><a href="../id418999/index.html">[Pengumuman, Peter] JUG.ru bertemu dengan Andrei Belyaev dan Alexei Stukalov - Troll menekan CUBA: FAQ</a></li>
<li><a href="../id419001/index.html">5 "keterampilan super" diperlukan untuk pekerjaan di masa depan</a></li>
<li><a href="../id419003/index.html">Intisari Blockchain</a></li>
<li><a href="../id419005/index.html">Wisata ke gardu 220/110/20</a></li>
<li><a href="../id419009/index.html">dentang dan IDE: sebuah cerita tentang persahabatan dan persahabatan</a></li>
<li><a href="../id419011/index.html">Jinja2 di dunia C ++, bagian dua. Rendering</a></li>
<li><a href="../id419013/index.html">Atribusi berbasis corong untuk bisnis SaaS B2B - karena kami mempertimbangkan nilai semua upaya pemasaran</a></li>
<li><a href="../id419017/index.html">Apa yang Baru di ConstraintLayout 1.1</a></li>
<li><a href="../id419019/index.html">AlterEgo: perangkat yang dapat membaca (beberapa) pikiran</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>