<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍⚖️ 👨🏾‍🏫 🍀 Réutilisation des formulaires sur React 🐓 👼 🦏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut 

 Nous avons un panneau d'administration et de nombreux formulaires dans le BCS, mais dans la communauté React il n'y a pas de méthode générale...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Réutilisation des formulaires sur React</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bcs_company/blog/461919/">  Salut <br><br>  Nous avons un panneau d'administration et de nombreux formulaires dans le BCS, mais dans la communauté React il n'y a pas de méthode généralement acceptée - comment les concevoir pour les réutiliser.  Le guide Facebook officiel ne dispose pas d'informations détaillées sur la façon de travailler avec des formulaires en conditions réelles, où la validation et la réutilisation sont nécessaires.  Quelqu'un utilise redux-form, formik, final-form, ou même écrit sa propre solution. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ep/ec/ua/epecuahbjt-y0jqwtoighctntzo.png" width="350"></div><br>  Dans cet article, nous allons montrer l'une des options pour travailler avec des formulaires sur React.  Notre pile sera comme ceci: React + formik + Typescript.  Nous montrerons: <br><br><ul><li>  Ce qu'un composant doit faire. </li><li>  Config, champs et validation au niveau des accessoires. </li><li>  Comment rendre un formulaire réutilisable. </li><li>  Optimisation du rendu. </li><li>  Que notre méthode n'est pas pratique. </li></ul><br>  Avec la nouvelle tâche commerciale, nous avons appris que nous devrons créer 15 à 20 formulaires similaires, et il pourrait y en avoir encore plus.  Nous avions une forme de dinosaure dans la config, qui fonctionnait avec les données du «magasin», envoyait des actions pour enregistrer et exécuter les demandes via «sagas».  Elle était merveilleuse, faisant de la valeur commerciale.  Mais il était déjà non extensible et non réutilisable, seulement avec un mauvais code et l'ajout de béquilles. <br><br>  La tâche est la suivante: réécrire le formulaire afin qu'il puisse être réutilisé un nombre illimité de fois.  Eh bien, rappelez-vous la programmation fonctionnelle, elle a des fonctions pures qui n'utilisent pas de données externes, dans notre cas «redux», seulement ce qu'elles sont envoyées en arguments (accessoires). <br><br>  Et c'est ce qui s'est passé. <br><a name="habracut"></a><br>  L'idée de notre composant est de créer un wrapper (conteneur) et d'y écrire la logique de travailler avec le monde extérieur (recevoir des données du magasin Redux et envoyer des actions).  Pour cela, le composant conteneur doit pouvoir recevoir des informations via les rappels.  La liste complète des accessoires de formulaire: <br><br><pre><code class="javascript hljs">interface IFormProps { <span class="hljs-comment"><span class="hljs-comment">//          IsSubmitting?: boolean; //     submitText?: string; //    resetText?: string; //       (  ) validateOnChange?: boolean; //     blur'e  (  ) validateOnBlur?: boolean; // ,      . config: IFieldsFormMetaModel[]; //  . fields: FormFields; //    validationSchema: Yup.MidexSchema; //     onSubmit?: () =&gt; void; //     reset  onReset?: (e: React.MouseEvent&lt;HTMLElement&gt;) =&gt; void; //    onChangeField?: ( e: React.SyntaticEvent&lt;HTMLInputElement, name: string; value: string ) =&gt; void; //      +    onChangeFields?: (values: FormFields, prop: { isValid }) =&gt; void; }</span></span></code> </pre> <br><h2>  Utilisation de Formik </h2><br>  Nous utilisons le composant &lt;Formik /&gt;. <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { fields, validationSchema, validateOnBlur = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, validateOnChange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Formik</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">initialValues</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{fields}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">render</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.renderForm}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onSubmit</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleSubmitForm}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">validationSchema</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{validationSchema}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">validateOnBlur</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{validateOnBlur}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">validateOnChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{validateOnChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">validate</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.validateFormLevel}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ); }</span></span></code> </pre><br>  Dans le cadre du formulaire `validate`, nous appelons la méthode` this.validateFormLevel`, dans laquelle nous donnons au composant conteneur la possibilité d'obtenir tous les champs modifiés et de vérifier s'ils sont valides. <br><br><pre> <code class="javascript hljs">private validateFormLevel = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values: FormFields</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { onChangeFields, validationSchema } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onChangeFields) { validationSchema .validate(values) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { onChangeFields(values, { <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }); }) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { onChangeFields(values, { <span class="hljs-attr"><span class="hljs-attr">isValid</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); }); } }</code> </pre><br>  Ici, nous devons à nouveau appeler la validation afin d'indiquer clairement au conteneur si les champs sont valides.  Lors de la soumission d'un formulaire, nous appelons simplement prop `onSubmit`: <br><br><pre> <code class="javascript hljs">private handleSubmitForm = (): <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">void</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { onSubmit } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onSubmit) { onSubmit(); } }</code> </pre><br>  Avec les accessoires 1 à 5, tout devrait être clair.  Passons maintenant à «config», «fields» et «validationSchema». <br><br><h2>  Configuration des accessoires </h2><br><pre> <code class="javascript hljs">interface IFieldsFormMetaModel { <span class="hljs-comment"><span class="hljs-comment">/**   */</span></span> sectionName?: string; sectionDescription?: string; fieldsForm?: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>&lt;{ <span class="hljs-comment"><span class="hljs-comment">/**    */</span></span> name?: string; <span class="hljs-comment"><span class="hljs-comment">//          prop 'fields' /**    checked */ checked?: boolean; /** enum,      */ type?: ElementTypes; /**    */ label?: string; /**    */ helperText?: string; /**      */ required?: boolean; /**      */ disabled?: boolean; /**  -    */ minLength?: number; /**            */ initialValue?: IInitialValue; /**      */ selectItems?: ISelectItems[]; //   select, dropdown   }&gt;; }</span></span></code> </pre> <br>  Sur la base de cette interface, nous créons un tableau d'objets et rendons «section» -&gt; «champs de section» selon ce schéma.  Nous pouvons donc afficher plusieurs champs pour la section ou dans chacun à la fois, si vous avez besoin d'un titre et d'une note.  Comment le rendu fonctionne, nous le montrerons un peu plus tard. <br>  Un petit exemple de configuration: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> config: IFieldsFormMetaModel[] = [ { <span class="hljs-attr"><span class="hljs-attr">sectionName</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-attr"><span class="hljs-attr">fieldsForm</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'subject'</span></span>, <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ElementTypes.Text, }], }, { <span class="hljs-attr"><span class="hljs-attr">sectionName</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">sectionDescription</span></span>: <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-attr"><span class="hljs-attr">fieldsForm</span></span>: [{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'reminder'</span></span>, <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: ElementTypes.CheckBox, <span class="hljs-attr"><span class="hljs-attr">checked</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }], }, ];</code> </pre> <br>  Sur la base des données d'entreprise, les valeurs des clés `nom` sont définies.  Les mêmes valeurs sont utilisées dans les clés prop `fields` pour transmettre les valeurs originales ou modifiées pour le formic. <br><br>  Pour l'exemple ci-dessus, `champs` pourrait ressembler à ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fields: SomeBusinessApiFields = { <span class="hljs-attr"><span class="hljs-attr">subject</span></span>: <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-attr"><span class="hljs-attr">reminder</span></span>: <span class="hljs-string"><span class="hljs-string">'yes'</span></span>, }</code> </pre> <br>  Pour la validation, nous devons passer le schéma Yup.  Nous donnons le formulaire au formulaire avec les accessoires de conteneur, décrivant là les interactions avec les données externes, par exemple, les demandes. <br><br>  Le formulaire ne peut en aucun cas influencer le schéma, par exemple: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CreateClientSchema: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> props: CreateClientProps, </span></span></span><span class="hljs-function">) =&gt;</span></span> Yup.MixedSchema = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props: CreateClientProps</span></span></span><span class="hljs-function">) =&gt;</span></span> Yup.object( { <span class="hljs-attr"><span class="hljs-attr">subject</span></span>: Yup.string(), <span class="hljs-attr"><span class="hljs-attr">description</span></span>: Yup.string(), <span class="hljs-attr"><span class="hljs-attr">date</span></span>: dateSchema, <span class="hljs-attr"><span class="hljs-attr">address</span></span>: addressSchema(props), }, );</code> </pre> <br><h2>  Optimisation du rendu et des champs </h2><br>  Pour le rendu, nous avons fait une carte pour une recherche rapide par clé.  Il semble concis et la recherche est plus rapide que par `switch`. <br><br><pre> <code class="javascript hljs">fieldsMap: Record&lt; ElementTypes, ( state: FormikFieldState, <span class="hljs-attr"><span class="hljs-attr">handlers</span></span>: FormikHandlersState, <span class="hljs-attr"><span class="hljs-attr">field</span></span>: IFieldsFormInfo, ) =&gt; JSX.Element &gt; = { [ElementTypes.Text]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> state: FormikFieldState, handlers: FormikHandlersState, field: IFieldsFormInfo </span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { values, errors, touched } = state; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;FormTextField key={field.name} element={field} handleChange={</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.handleChangeField(handlers.setFieldValue, field.name</span></span></span><span class="hljs-function">)} </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">handleBlur</span></span></span><span class="hljs-function">={</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">handlers</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">handleBlur</span></span></span><span class="hljs-function">} </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">={</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">field</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">]} </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">={</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">touched</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">field</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">] &amp;&amp; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">errors</span></span></span><span class="hljs-function">[</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">field</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">] || ''} /&gt; ); }, [</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ElementTypes</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TextSearch</span></span></span><span class="hljs-function">]: (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> {...}, [ElementTypes.TextArea]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> {...}, [ElementTypes.Date]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> {...}, [ElementTypes.CheckBox]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> {...}, [ElementTypes.RadioButton]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> {...}, [ElementTypes.Select]: <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...</span></span></span><span class="hljs-function">) =&gt;</span></span> {...}, };</code> </pre> <br>  Chaque champ de composant est avec état.  Il se trouve dans un fichier séparé et est enveloppé dans `React.memo`.  Toutes les valeurs sont transmises via des accessoires, en contournant les `enfants`, pour éviter un rendu inutile. <br><br><h2>  Conclusion </h2><br>  Notre formulaire n'est pas idéal, pour chaque cas, nous devons créer un emballage de conteneur pour travailler avec les données.  Enregistrez-les dans le `store`, convertissez et faites des demandes.  Il y a une répétition de code dont vous voulez vous débarrasser.  Nous essayons de trouver une nouvelle solution dans laquelle le formulaire, selon les accessoires, prendra la clé souhaitée du magasin avec des champs, des actions, des diagrammes et une configuration.  Dans l'un des articles suivants, nous vous dirons ce qui en est sorti. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr461919/">https://habr.com/ru/post/fr461919/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr461901/index.html">Trois ans d'autotests: comment augmenter la vitesse et pas seulement</a></li>
<li><a href="../fr461903/index.html">Adversaire mystérieux: emprunts flous</a></li>
<li><a href="../fr461905/index.html">Tic Tac Toe, partie 7: pytest et Travis CI</a></li>
<li><a href="../fr461907/index.html">Analyse de produits dans un studio à cycle complet</a></li>
<li><a href="../fr461913/index.html">Utilisation mobile dans le commerce électronique: analyse des TOP-20 boutiques en ligne en Russie</a></li>
<li><a href="../fr461921/index.html">HDMI-LVDS. Développement sur TSUMV59 de MStar</a></li>
<li><a href="../fr461923/index.html">Journée portes ouvertes JetBrains à Saint-Pétersbourg: vidéo</a></li>
<li><a href="../fr461927/index.html">Apprentissage par classement actif</a></li>
<li><a href="../fr461929/index.html">Surveillance et vérification de l'état SSD sous Linux</a></li>
<li><a href="../fr461935/index.html">Comment travailler avec Postgres in Go: pratiques, fonctionnalités, nuances</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>