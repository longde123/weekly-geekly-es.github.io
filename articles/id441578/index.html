<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤— ğŸ’´ ğŸ“ Bereaksi Tutorial Bagian 19: Metode Siklus Hidup Komponen ğŸ‘©ğŸ¼â€ğŸ¨ ğŸ‚ğŸ½ ğŸ‘©â€â¤ï¸â€ğŸ’‹â€ğŸ‘¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di bagian terjemahan React tutorial hari ini, Anda akan diberikan ikhtisar metode siklus hidup komponen. 

  

 â†’ Bagian 1: ikhtisar kursus, alasan po...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bereaksi Tutorial Bagian 19: Metode Siklus Hidup Komponen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/441578/">  Di bagian terjemahan React tutorial hari ini, Anda akan diberikan ikhtisar metode siklus hidup komponen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/kv/3m/yg/kv3mygzwigixivdzbagb80fvlvi.png" alt="gambar"></a> <br><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: ikhtisar kursus, alasan popularitas React, ReactDOM dan JSX</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: komponen fungsional</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: file komponen, struktur proyek</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4: komponen induk dan anak</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5: mulai bekerja pada aplikasi TODO, dasar-dasar gaya</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 6: tentang beberapa fitur kursus, JSX dan JavaScript</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 7: gaya inline</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 8: terus bekerja pada aplikasi TODO, terbiasa dengan sifat-sifat komponen</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 9: properti komponen</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 10: Workshop bekerja dengan properti komponen dan gaya</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 11: pembuatan markup dinamis dan metode susunan peta</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 12: lokakarya, pekerjaan tahap ketiga pada aplikasi TODO</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 13: komponen berbasis kelas</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 14: lokakarya tentang komponen berbasis kelas, status komponen</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 15: bengkel kesehatan komponen</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 16: tahap keempat dari pengerjaan aplikasi TODO, penanganan acara</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 17: tahap kelima bekerja pada aplikasi TODO, memodifikasi status komponen</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 18: tahap keenam dari pengerjaan aplikasi TODO</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 19: metode siklus hidup komponen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 20: pelajaran pertama dalam rendering bersyarat</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 21: pelajaran kedua dan lokakarya tentang rendering bersyarat</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 22: tahap ketujuh bekerja pada aplikasi TODO, mengunduh data dari sumber eksternal</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 23: pelajaran pertama tentang bekerja dengan formulir</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 24: Pelajaran Bentuk Kedua</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 25: Workshop bekerja dengan formulir</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 26: arsitektur aplikasi, pola Container / Komponen</a> <br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 27: proyek kursus</a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Pelajaran 34. Metode Siklus Hidup Komponen, Bagian 1</font> </h2><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asli</a> <br><br>  Salah satu fitur pengembangan aplikasi React adalah kenyataan bahwa kita menulis kode JavaScript yang cukup sederhana yang menggerakkan mekanisme internal React dan dengan demikian memberi kita peluang besar untuk mengembangkan antarmuka aplikasi dan bekerja dengan data.  Pada saat yang sama, komponen yang kami gunakan selama siklus hidup mereka melewati tahap-tahap tertentu.  Seringkali, apa yang terjadi pada komponen dalam aplikasi dibandingkan dengan kehidupan seseorang.  Orang dilahirkan, hidup, dalam hidup mereka beberapa peristiwa penting terjadi, setelah itu mereka mati.  Komponen Bereaksi dalam hal ini mirip dengan orang, karena mereka juga "lahir", "hidup" dan "mati".  Ketika bekerja dengan komponen, kita dapat menanggapi apa yang terjadi pada mereka, berkat metode siklus hidup mereka yang dipanggil pada saat-saat khusus "kehidupan" mereka. <br><br>  Baru-baru ini, tim pengembangan Bereaksi telah ketinggalan zaman tiga metode siklus komponen.  Namun demikian, kami akan mempertimbangkan metode ini, karena mereka masih dapat digunakan, dan karena mereka dapat ditemukan dalam kode yang ada.  Selain itu, dua metode siklus hidup komponen baru ditambahkan ke Bereaksi, yang akan kita bahas dalam pelajaran berikutnya. <br><br>  Kami hanya akan mempertimbangkan metode yang paling penting yang paling relevan bagi mereka yang baru mulai belajar Bereaksi.  Ketika Anda terus menguasai perpustakaan ini, Anda akan dapat bereksperimen dengan metode lain. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> beberapa bahan yang baik tentang metode siklus hidup komponen Bereaksi yang relevan sebelum Bereaksi 16.3.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> , dalam publikasi dari blog resmi Bereaksi pengembang, Anda dapat mengetahui tentang perubahan yang telah terjadi di Bereaksi 16.3. <br><br>  Sekarang, mari kita mulai diskusi tentang metode siklus hidup dari komponen Bereaksi yang paling sering Anda temui. <br><br>  Kami akan, seperti biasa, menggunakan proyek demo di sini.  Dalam hal ini, kita mulai dengan proyek standar yang dibuat menggunakan create-react-app, dalam file <code>App.js</code> yang berisi kode berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     render() {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (           <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">               Code goes here           </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>       )   } } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> App</code> </pre> <br>  Untuk memulai, mari kita lihat metode yang telah Anda gunakan dengan komponen berbasis kelas.  Ini adalah metode <code>render()</code> . <br><br>  Seringkali, dia tidak disebutkan ketika berbicara tentang komponen metode siklus hidup.  Saya pikir metode ini, ketika membandingkan komponen dengan seseorang, dapat dibandingkan dengan berpakaian sebelum pergi.  Tujuan dari metode ini adalah untuk menentukan apa yang akan ditampilkan di layar, yaitu bagaimana komponen akan terlihat.  Metode <code>render()</code> dapat dipanggil beberapa kali selama umur komponen.  Jadi, ketika Bereaksi menentukan bahwa sesuatu yang berhubungan dengan komponen telah berubah, seperti keadaan atau properti, yaitu, sesuatu yang dapat mempengaruhi penampilan komponen, Bereaksi dapat memanggil metode ini.  Ini bisa dibandingkan, jika kita melanjutkan analogi dengan orang, sehingga seseorang dapat memutuskan untuk berganti pakaian.  Misalnya, untuk, setelah hari kerja, bersiaplah untuk semacam acara liburan. <br><br>  Sekarang mari kita lihat metode siklus hidup komponen lain - <code>componentDidMount()</code> .  Metode ini dideklarasikan, sama seperti metode komponen berbasis kelas lainnya, di tubuh kelas komponen: <br><br><pre> <code class="javascript hljs">componentDidMount() { }</code> </pre> <br>  Metode ini disebut pada saat siklus hidup komponen, yang dapat dibandingkan dengan "kelahiran" komponen ini.  Metode ini dipicu sekali setelah komponen dipasang (dimasukkan) di pohon DOM.  Dalam kasus ini, misalnya, jika setelah mengubah beberapa data yang mempengaruhi penampilan komponen, itu akan dirender kembali, metode <code>componentDidMount()</code> tidak akan dipanggil.  Ini terjadi karena fakta bahwa ketika melakukan operasi seperti itu, komponen tidak dihapus dari pohon DOM dan kemudian dimasukkan lagi ke dalam pohon. <br><br>  Metode <code>componentDidMount()</code> biasanya digunakan untuk melakukan panggilan ke API tertentu jika pengembang membutuhkan data dari sumber eksternal.  Misalkan komponen yang kita pertimbangkan di sini sebenarnya disebut <code>TodoList</code> dan merupakan komponen yang membentuk daftar yang harus dilakukan dalam aplikasi Todo.  Metode <code>componentDidMount()</code> seperti itu dapat memuat bahan dari database server yang diperlukan untuk tampilan yang benar dari daftar yang harus dilakukan yang disimpan di server.  Akibatnya, setelah pemasangan komponen selesai, kami, dalam metode <code>componentDidMount()</code> , dapat memuat data yang diperlukan agar komponen dapat ditampilkan dengan benar di halaman.  Kami juga akan berbicara tentang memuat data yang diperlukan oleh komponen, tetapi untuk sekarang Anda dapat mengingat bahwa ini adalah kasus penggunaan paling umum untuk <code>componentDidMount()</code> . <br><br>  Metode siklus hidup komponen berikutnya yang kita bahas disebut <code>componentWillReceiveProps()</code> .  Metode ini dapat dibandingkan dengan apa yang terjadi ketika seseorang menerima hadiah dari seseorang.  Jadi, komponen dapat menerima properti dari komponen induk.  Setiap kali komponen mengambil properti, metode ini disebut.  Pada saat yang sama, metode ini dipanggil setiap kali komponen induk meneruskan properti ke komponen anak, dan tidak hanya ketika ini terjadi untuk pertama kalinya.  Misalnya, jika komponen induk memutuskan untuk mengubah properti yang diteruskan ke komponen turunan, maka, dalam metode <code>componentWillReceiveProps()</code> , kita dapat, misalnya, memeriksa apakah properti baru berbeda dari yang sudah diteruskan ke komponen.  Faktanya adalah bahwa jika properti baru tidak berbeda dari yang lama, ini berarti bahwa penerimaan mereka tidak mengubah apa pun, yang berarti bahwa, setelah mengetahuinya, kita tidak bisa berbuat apa-apa lagi.  Jika properti baru berbeda dari yang lama, kami dapat melakukan tindakan tertentu.  Biasanya, metode ini dideklarasikan di tubuh kelas komponen sebagai berikut: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) { }</code> </pre> <br>  Ini biasanya digunakan, sebagai nama parameter, <code>nextProps</code> , tetapi Anda dapat memberi nama parameter ini sesuka Anda.  Untuk membandingkan beberapa properti tertentu yang sudah ditransfer ke komponen dengan apa yang sudah diteruskan sebelumnya, dan memutuskan tindakan lebih lanjut, Anda dapat menggunakan konstruksi ini: <br><br><pre> <code class="javascript hljs">componentWillReceiveProps(nextProps) {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextProps.whatever !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.whatever) {       <span class="hljs-comment"><span class="hljs-comment">//   -    } }</span></span></code> </pre> <br>  Biasanya metode ini digunakan seperti itu. <br><br>  Namun, seperti yang telah disebutkan, setelah rilis Bereaksi 16.3, beberapa metode siklus hidup komponen tidak digunakan lagi, dan <code>componentWillReceiveProps()</code> adalah salah satu metode tersebut. <br><br>  Sampai Bereaksi 17, metode warisan ini masih dapat digunakan, meskipun lebih baik tidak melakukannya.  Jika Anda tidak dapat melakukannya tanpa metode yang dipermasalahkan, Anda perlu menyebutnya <code>UNSAFE_componentWillReceiveProps()</code> .  Mengikuti Bereaksi 17, nama metode <code>componentWillReceiveProps()</code> tidak akan berarti sesuatu yang istimewa. <br><br>  Sangat berguna untuk mengetahui tentang metode ini agar dapat memahami kode yang sudah ketinggalan zaman, tetapi tidak akan digunakan dalam pengembangan aplikasi Bereaksi modern. <br><br>  Metode siklus hidup komponen lain yang menarik disebut <code>shouldComponentUpdate()</code> .  Dia, jika kita terus membandingkan komponen dengan seseorang, ingat saat ketika seseorang berpikir tentang apakah dia perlu berganti pakaian atau tidak.  Dalam kondisi normal, jika Bereaksi tidak sepenuhnya yakin apakah akan merender ulang suatu komponen, itu akan membuatnya untuk berjaga-jaga.  Tidak masalah apakah ini perlu, sesuai dengan logika aplikasi, atau tidak. <br><br>  Ini menyebabkan Bereaksi untuk merender ulang komponen, bahkan ketika tidak ada yang terkait dengan perubahan komponen.  Ini dapat memperlambat aplikasi, karena dengan prinsip ini Bereaksi memproses semua komponen yang membentuk aplikasi.  Metode <code>shouldComponentUpdate()</code> memungkinkan pengembang untuk mengoptimalkan aplikasi.  Di sini Anda dapat menerapkan beberapa logika yang membantu untuk mengetahui perlunya memperbarui komponen.  Metode ini biasanya dinyatakan seperti ini: <br><br><pre> <code class="javascript hljs">shouldComponentUpdate(nextProps, nextState) {   <span class="hljs-comment"><span class="hljs-comment">//  true        //  false    }</span></span></code> </pre> <br>  Selain itu, dari metode ini, jika komponen perlu dirender ulang, dengan mempertimbangkan properti dan status baru, Anda harus mengembalikan <code>true</code> .  Kalau tidak, <code>false</code> harus dikembalikan darinya.  Sebenarnya, mengembalikan <code>false</code> dari metode ini mengarah pada fakta bahwa komponen tidak diperbarui dan aplikasi berjalan lebih cepat, tetapi dengan melakukan ini, Anda perlu memastikan bahwa komponen tidak benar-benar perlu dirender ulang.  Jika komponen perlu diperbarui, dan metode ini kembali <code>false</code> , ini akan menyebabkan kesalahan yang akan sulit dihadapi. <br><br>  Metode siklus hidup komponen lain yang akan kita bicarakan disebut <code>componentWillUnmount()</code> .  Metode ini menandai akhir dari "masa hidup" komponen - saat ketika dihapus dari pohon DOM dan menghilang dari layar. <br><br>  Metode ini terutama digunakan untuk membebaskan sumber daya yang ditempati oleh komponen dan menertibkan sebelum menghapusnya.  Misalnya, jika metode <code>componentDidMount()</code> dikonfigurasikan dengan sesuatu seperti pendengar peristiwa, yang karenanya, ketika pengguna menggulir halaman, beberapa kode dieksekusi, itu adalah dalam <code>componentWillUnmount()</code> Anda dapat menghapus pendengar acara tersebut.  Bahkan, metode ini memiliki banyak aplikasi yang bertujuan untuk menghapus segala sesuatu dari aplikasi yang ternyata tidak diperlukan setelah komponen hilang. <br><br>  Berikut ini adalah kode lengkap komponen <code>App</code> kami, di mana metode siklus hidup ditambahkan: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, {Component} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() {       <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>()       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = {}   }     componentDidMount() {       <span class="hljs-comment"><span class="hljs-comment">//  ,        }     componentWillReceiveProps(nextProps) {       if (nextProps.whatever !== this.props.whatever) {           //   -        }   }     shouldComponentUpdate(nextProps, nextState) {       //  true            //  false      }     componentWillUnmount() {       //            // ( -   )   }     render() {       return (           &lt;div&gt;               Code goes here           &lt;/div&gt;       )   } } export default App</span></span></code> </pre> <br>  Ini menyimpulkan pelajaran ini, meskipun harus dicatat bahwa metode siklus hidup dari komponen Bereaksi tidak terbatas pada yang kami ulas hari ini. <br><br><h2>  <font color="#3AC1EF">Pelajaran 35. Metode Siklus Hidup Komponen, Bagian 2</font> </h2><br>  â†’ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Asli</a> <br><br>  Seperti yang telah disebutkan dalam pelajaran sebelumnya, ketika Bereaksi 16.3 keluar, dilaporkan bahwa tiga metode siklus hidup komponen sudah usang.  Metode-metode ini adalah <code>componentWillMount()</code> , <code>componentWillReceiveProps()</code> dan <code>componentWillUpdate()</code> .  Dua metode baru juga dilaporkan.  Ini adalah metode <code>getDerivedStateFromProps()</code> statis dan metode <code>getSnapshotBeforeUpdate()</code> .  Tidak dapat dikatakan bahwa metode ini akan memainkan peran penting dalam kelas-kelas yang akan datang dari kursus ini, tetapi meskipun demikian, kita akan mengenalnya di sini. <br><br>  Kami akan bereksperimen dalam proyek yang sama yang kami gunakan terakhir kali. <br><br>  Berikut ini deklarasi metode <code>getDerivedStateFromProps()</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> getDerivedStateFromProps(props, state) { }</code> </pre> <br>  Catat <code>static</code> sebelum nama metode.  Dia, berdasarkan properti yang diterima olehnya, harus mengembalikan keadaan yang diperbarui.  Ini digunakan dalam kasus-kasus ketika komponen tertentu harus menerima properti yang masuk yang diterima dari komponen induk dan mengkonfigurasi keadaannya berdasarkan properti ini.  Detail tentang metode ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Materi ini, yang diterbitkan di blog React, mengatakan bahwa penggunaan metode ini jauh dari dibenarkan dalam semua situasi yang tampaknya bermanfaat.  Penggunaannya yang tidak tepat dapat menyebabkan berbagai kesalahan, hingga penurunan kinerja aplikasi, jadi gunakan dengan hati-hati.  Anda seharusnya tidak mencoba memecahkan masalah dengan bantuannya, untuk solusi yang tidak dimaksudkan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Berikut adalah</a> dokumentasi untuk metode ini. <br><br>  Sekarang mari kita bicara tentang metode <code>getSnapshotBeforeUpdate()</code> .  Inilah deklarasi yang terlihat di badan kelas: <br><br><pre> <code class="javascript hljs">getSnapshotBeforeUpdate() { }</code> </pre> <br>  Ini dapat dianggap sebagai metode siklus hidup yang memungkinkan Anda untuk membuat sesuatu seperti cadangan dari apa yang ada di komponen sebelum memperbaruinya.  Ini menyerupai snapshot keadaan aplikasi.  Perlu dicatat bahwa pengembang Bereaksi mengatakan bahwa ruang lingkup metode ini terbatas.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini</a> dokumentasi untuknya. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Hari ini kita berbicara tentang metode siklus hidup komponen.  Ketika Anda maju dalam pengembangan aplikasi Bereaksi, mereka pasti akan berguna.  Di kelas lebih lanjut dari kursus ini, kita akan bertemu dengan metode ini, khususnya, dengan <code>componentDidMount()</code> .  Lain kali kita akan berbicara tentang rendering bersyarat. <br><br>  <b>Pembaca yang budiman!</b>  Jika Anda mengembangkan aplikasi Bereaksi secara profesional, beri tahu kami tentang cara Anda menggunakan metode siklus hidup komponen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id441578/">https://habr.com/ru/post/id441578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id441568/index.html">Manajemen memori python</a></li>
<li><a href="../id441570/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 353 (17 - 24 Februari 2019)</a></li>
<li><a href="../id441572/index.html">Frontend Weekly Digest (18 - 24 Feb 2019)</a></li>
<li><a href="../id441574/index.html">Learning Docker Bagian 6: Bekerja dengan Data</a></li>
<li><a href="../id441576/index.html">Kubernetes Networks: Pods</a></li>
<li><a href="../id441580/index.html">React Tutorial Bagian 20: Pelajaran Rendering Bersyarat Pertama</a></li>
<li><a href="../id441582/index.html">Optimalisasi sistem kontrol LQR</a></li>
<li><a href="../id441584/index.html">PHP Digest No. 150 (11 - 25 Februari 2019)</a></li>
<li><a href="../id441586/index.html">Cara merekomendasikan musik yang hampir tidak ada yang mendengarkan. Laporan Yandex</a></li>
<li><a href="../id441590/index.html">Evolusi interaksi cluster. Bagaimana kami menerapkan ActiveMQ dan Hazelcast</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>