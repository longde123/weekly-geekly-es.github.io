<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêî „äóÔ∏è üëÉüèø Pensamiento funcional Parte 9 üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® üö© ü§Ø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¬°Esto ya es parte 9 de una serie de art√≠culos sobre programaci√≥n funcional en F #! Estoy seguro de que en Habr√© no hay muchos ciclos tan largos. Pero ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamiento funcional Parte 9</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433406/"><p>  ¬°Esto ya es parte 9 de una serie de art√≠culos sobre programaci√≥n funcional en F #!  Estoy seguro de que en Habr√© no hay muchos ciclos tan largos.  Pero no vamos a parar.  Hoy hablaremos sobre funciones anidadas, m√≥dulos, espacios de nombres y tipos y funciones de mezcla en m√≥dulos. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Primera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tercera parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cuarta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Quinta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sexta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">S√©ptima parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Octava parte</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Ahora sabes c√≥mo definir funciones, pero ¬øc√≥mo organizarlas? </p><br><p>  F # tiene tres opciones: </p><br><ul><li>  Las funciones se pueden anidar en otras funciones. </li><li>  a nivel de aplicaci√≥n, las funciones de nivel superior se agrupan en "m√≥dulos". </li><li>  o puede seguir un enfoque orientado a objetos y adjuntar funciones a los tipos como m√©todos. </li></ul><br><p>  En este art√≠culo, consideraremos los dos primeros m√©todos y el restante en el siguiente. </p><br><h2>  Funciones anidadas </h2><br><p>  En F #, puede definir funciones dentro de otras funciones.  Esta es una buena manera de encapsular funciones auxiliares que solo son necesarias para la funci√≥n principal y que no deber√≠an ser visibles desde el exterior. </p><br><p> En el siguiente ejemplo, <code>add</code> anidado en <code>addThreeNumbers</code> : </p><br><pre> <code class="plaintext hljs">let addThreeNumbers xyz = //     let add n = fun x -&gt; x + n //    x |&gt; add y |&gt; add z addThreeNumbers 2 3 4</code> </pre> <br><p>  Las funciones anidadas pueden acceder a los par√°metros principales directamente, porque est√°n dentro de su alcance. <br>  Entonces, en el ejemplo a continuaci√≥n, la funci√≥n anidada <code>printError</code> no necesita par√°metros, porque  ella puede acceder a <code>n</code> <code>max</code> directamente. </p><br><pre> <code class="plaintext hljs">let validateSize max n = //       let printError() = printfn "Oops: '%i' is bigger than max: '%i'" n max //    if n &gt; max then printError() validateSize 10 9 validateSize 10 11</code> </pre> <br><p>  Un patr√≥n muy com√∫n es la funci√≥n principal que define la funci√≥n auxiliar recursiva anidada, que se llama con los valores iniciales correspondientes. <br>  El siguiente es un ejemplo de dicho c√≥digo: </p><br><pre> <code class="plaintext hljs">let sumNumbersUpTo max = //      let rec recursiveSum n sumSoFar = match n with | 0 -&gt; sumSoFar | _ -&gt; recursiveSum (n-1) (n+sumSoFar) //       recursiveSum max 0 sumNumbersUpTo 10</code> </pre> <br><p>  Intente evitar el anidamiento profundo, especialmente en casos de acceso directo (no en forma de par√°metros) a las variables principales. <br>  Las funciones demasiado anidadas ser√°n tan dif√≠ciles de entender como la peor de muchas ramas imperativas anidadas. </p><br><p>  Un ejemplo de c√≥mo <em>no</em> hacer: </p><br><pre> <code class="plaintext hljs">// wtf,    ? let fx = let f2 y = let f3 z = x * z let f4 z = let f5 z = y * z let f6 () = y * x f6() f4 y x * f2 x</code> </pre> <br><h2>  M√≥dulos </h2><br><p>  Un m√≥dulo es simplemente una colecci√≥n de funciones que se agrupan juntas, generalmente porque funcionan con el mismo tipo o tipos de datos. </p><br><p>  Una definici√≥n de m√≥dulo es muy similar a una definici√≥n de funci√≥n.  Comienza con la palabra clave del <code>module</code> , luego viene el signo <code>=</code> , seguido del contenido del m√≥dulo. <br>  El contenido del m√≥dulo <em>debe</em> formatearse con un desplazamiento, as√≠ como las expresiones en la definici√≥n de funciones. </p><br><p>  Definici√≥n de un m√≥dulo que contiene dos funciones: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Si abre este c√≥digo en Visual Studio, cuando pasa el cursor sobre <code>add</code> puede ver el nombre completo <code>add</code> , que en realidad es <code>MathStuff.add</code> , como si <code>MastStuff</code> fuera una clase, y <code>add</code> era un m√©todo. </p><br><p>  De hecho, esto es exactamente lo que sucede.  Detr√°s de escena, el compilador de F # crea una clase est√°tica con m√©todos est√°ticos.  El equivalente de C # se ver√≠a as√≠: </p><br><pre> <code class="plaintext hljs">static class MathStuff { static public int add(int x, int y) { return x + y; } static public int subtract(int x, int y) { return x - y; } }</code> </pre> <br><p>  Reconocer que los m√≥dulos son solo clases est√°ticas y las funciones son m√©todos est√°ticos proporcionar√° una buena comprensi√≥n de c√≥mo funcionan los m√≥dulos en F #, ya que la mayor√≠a de las reglas que se aplican a las clases est√°ticas tambi√©n se aplican a los m√≥dulos. </p><br><p>  Y al igual que en C #, cada funci√≥n independiente debe ser parte de la clase, en F #, cada funci√≥n independiente <em>debe</em> ser parte del m√≥dulo. </p><br><h3>  Acceso a funciones fuera del m√≥dulo. </h3><br><p>  Si necesita acceder a una funci√≥n desde otro m√≥dulo, puede consultarla a trav√©s de su nombre completo. </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y module OtherStuff = //     MathStuff let add1 x = MathStuff.add x 1</code> </pre> <br><p>  Tambi√©n puede importar todas las funciones de otro m√≥dulo usando la directiva <code>open</code> , despu√©s de lo cual puede usar el nombre corto en lugar del completo. </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff //      let add1 x = add x 1</code> </pre> <br><p>  Las reglas para usar nombres son bastante esperadas.  Siempre puede acceder a una funci√≥n por su nombre completo, o puede usar nombres relativos o incompletos dependiendo del alcance actual. </p><br><h3>  M√≥dulos Anidados </h3><br><p>  Al igual que las clases est√°ticas, los m√≥dulos pueden contener m√≥dulos anidados: </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Otros m√≥dulos pueden referirse a funciones en m√≥dulos anidados utilizando el nombre completo o relativo, seg√∫n corresponda: </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff let add1 x = add x 1 //   let add1Float x = MathStuff.FloatLib.add x 1.0 //   let sub1Float x = FloatLib.subtract x 1.0</code> </pre> <br><h3>  M√≥dulos de nivel superior </h3><br><p>  Por lo tanto, dado que los m√≥dulos se pueden anidar, por lo tanto, subiendo la cadena, puede llegar a alg√∫n m√≥dulo principal del nivel superior.  Realmente lo es </p><br><p>  Los m√≥dulos de nivel superior se definen de manera diferente, a diferencia de los m√≥dulos que se mostraron anteriormente. </p><br><ul><li>  La <code>module MyModuleName</code> <em>debe</em> ser la primera declaraci√≥n en el archivo </li><li>  Signo <code>=</code> faltante </li><li>  El contenido del m√≥dulo <em>no</em> debe sangrarse </li></ul><br><p>  En general, debe existir una declaraci√≥n de "nivel superior" en cada archivo <code>.FS</code> origen.  Hay algunas excepciones, pero sigue siendo una buena pr√°ctica.  El nombre del m√≥dulo no tiene que coincidir con el nombre del archivo, pero dos archivos no pueden contener m√≥dulos con el mismo nombre. </p><br><p>  Para archivos <code>.FSX</code> , la declaraci√≥n del m√≥dulo no es necesaria, en este caso el nombre del archivo de script se convierte autom√°ticamente en el nombre del m√≥dulo. </p><br><p>  Un ejemplo de un <code>MathStuff</code> declarado como m√≥dulo "m√≥dulo superior": </p><br><pre> <code class="plaintext hljs">//    module MathStuff let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Tenga en cuenta que no hay sangr√≠a en el c√≥digo de "nivel superior" ( <code>module MathStuff</code> ), mientras que el contenido de un m√≥dulo <code>FloatLib</code> anidado todav√≠a tiene que <code>FloatLib</code> . </p><br><h3>  Otros contenidos del m√≥dulo </h3><br><p>  Adem√°s de las funciones, los m√≥dulos pueden contener otras declaraciones, como declaraciones de tipo, valores simples y c√≥digo de inicializaci√≥n (por ejemplo, constructores est√°ticos) </p><br><pre> <code class="plaintext hljs">module MathStuff = //  let add xy = x + y let subtract xy = x - y //   type Complex = {r:float; i:float} type IntegerFunction = int -&gt; int -&gt; int type DegreesOrRadians = Deg | Rad // "" let PI = 3.141 // "" let mutable TrigType = Deg //  /   do printfn "module initialized"</code> </pre><br><p>  Por cierto, si ejecuta estos ejemplos de forma interactiva, es posible que deba reiniciar la sesi√≥n con la frecuencia suficiente para que el c√≥digo permanezca "actualizado" y no se infecte con c√°lculos anteriores. </p><br><h3>  Ocultamiento (superposici√≥n, sombreado) </h3><br><p>  Este es nuevamente nuestro m√≥dulo de muestra.  Tenga en cuenta que <code>MathStuff</code> contiene la funci√≥n de <code>add</code> <em>, as√≠</em> como <code>FloatLib</code> . </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  ¬øQu√© sucede si abre <em>ambos</em> m√≥dulos en el alcance actual y llama a <code>add</code> ? </p><br><pre> <code class="plaintext hljs">open MathStuff open MathStuff.FloatLib let result = add 1 2 // Compiler error: This expression was expected to // have type float but here has type int</code> </pre> <br><p>  Y sucedi√≥ que el m√≥dulo <code>MathStuff.FloatLib</code> redefini√≥ el <code>MathStuff</code> original, que fue bloqueado (oculto) por el m√≥dulo <code>FloatLib</code> . </p><br><p>  Como resultado, obtenemos el error del compilador FS0001, porque el primer par√°metro <code>1</code> se esperaba como flotante.  Para solucionar esto, debe cambiar <code>1</code> a <code>1.0</code> . </p><br><p>  Desafortunadamente, en la pr√°ctica esto se pasa por alto <em>discreta</em> y f√°cilmente.  A veces, utilizando esta t√©cnica, puedes hacer trucos interesantes, casi como subclases, pero la mayor√≠a de las veces la presencia de funciones del mismo nombre es molesta (por ejemplo, en el caso de la funci√≥n de <code>map</code> extremadamente com√∫n). </p><br><p>  Si desea evitar este comportamiento, hay una manera de detenerlo con el atributo <code>RequireQualifiedAccess</code> .  El mismo ejemplo en el que ambos m√≥dulos est√°n decorados con este atributo: </p><br><pre> <code class="plaintext hljs">[&lt;RequireQualifiedAccess&gt;] module MathStuff = let add xy = x + y let subtract xy = x - y //   [&lt;RequireQualifiedAccess&gt;] module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p>  Ahora la directiva <code>open</code> no est√° disponible: </p><br><pre> <code class="plaintext hljs">open MathStuff //  open MathStuff.FloatLib // </code> </pre> <br><p>  Pero a√∫n puede acceder a las funciones (sin ninguna ambig√ºedad) a trav√©s de sus nombres completos: </p><br><pre> <code class="plaintext hljs">let result = MathStuff.add 1 2 let result = MathStuff.FloatLib.add 1.0 2.0</code> </pre> <br><h3>  Control de acceso </h3><br><p>  F # admite el uso de operadores de control de acceso est√°ndar .NET como <code>public</code> , <code>private</code> e <code>internal</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El art√≠culo de MSDN</a> contiene informaci√≥n completa. </p><br><ul><li>  Estos especificadores de acceso se pueden aplicar a ("dejar ligar") funciones, valores, tipos y otras declaraciones de nivel superior en un m√≥dulo.  Tambi√©n se pueden especificar para los propios m√≥dulos (por ejemplo, puede ser necesario un m√≥dulo anidado privado). </li><li>  Por defecto, todo tiene acceso p√∫blico (con la excepci√≥n de varios casos), por lo que para protegerlos necesitar√° usar <code>private</code> o <code>internal</code> . </li></ul><br><p>  Estos especificadores de acceso son solo una forma de controlar la visibilidad en F #.  Una forma completamente diferente es utilizar archivos de firma que se asemejan a los archivos de encabezado C. Describen de manera abstracta el contenido del m√≥dulo.  Las firmas son muy √∫tiles para la encapsulaci√≥n seria, pero para considerar sus capacidades, tendr√° que esperar la serie planificada sobre encapsulaci√≥n y <em>seguridad basada en las capacidades</em> . </p><br><h2>  Espacios de nombres </h2><br><p>  Los espacios de nombres en F # son similares a los espacios de nombres de C #.  Se pueden usar para organizar m√≥dulos y tipos para evitar conflictos de nombres. </p><br><p>  Un espacio de nombres declarado con la palabra clave de <code>namespace</code> : </p><br><pre> <code class="plaintext hljs">namespace Utilities module MathStuff = //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  Debido a este espacio de nombres, el nombre completo del m√≥dulo <code>MathStuff</code> se <code>MathStuff</code> convertido en <code>Utilities.MathStuff</code> , y el nombre completo es <code>Utilities.MathStuff.add</code> . </p><br><p>  Las mismas reglas de sangr√≠a se aplican a los m√≥dulos dentro de un espacio de nombres que se muestran arriba para los m√≥dulos. </p><br><p>  Tambi√©n puede declarar un espacio de nombres expl√≠citamente agregando un punto en el nombre del m√≥dulo.  Es decir  El c√≥digo anterior se puede reescribir as√≠: </p><br><pre> <code class="plaintext hljs">module Utilities.MathStuff //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  El nombre completo del m√≥dulo <code>MathStuff</code> sigue siendo <code>Utilities.MathStuff</code> , pero ahora es un m√≥dulo de nivel superior y su contenido no necesita sangr√≠a. </p><br><p>  Algunas caracter√≠sticas adicionales para usar espacios de nombres: </p><br><ul><li>  Los espacios de nombres son opcionales para los m√≥dulos.  A diferencia de C #, para los proyectos de F # no hay un espacio de nombres predeterminado, por lo que un m√≥dulo de nivel superior sin un espacio de nombres ser√° global.  Si planea crear bibliotecas reutilizables, debe agregar varios espacios de nombres para evitar conflictos con el c√≥digo de otras bibliotecas. </li><li>  Los espacios de nombres pueden contener directamente declaraciones de tipo, pero no declaraciones de funci√≥n.  Como se se√±al√≥ anteriormente, todas las declaraciones de funciones y valores deben ser parte de un m√≥dulo. </li><li>  Finalmente, tenga en cuenta que los espacios de nombres no funcionan en los scripts.  Por ejemplo, si intenta enviar una declaraci√≥n de espacio de nombres, como <code>namespace Utilities</code> , a una ventana interactiva, se recibe un error. </li></ul><br><h3>  Jerarqu√≠a de espacio de nombres </h3><br><p>  Puede crear una jerarqu√≠a de espacios de nombres simplemente dividiendo los nombres con puntos: </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y</code> </pre> <br><p>  Tambi√©n puede declarar <em>dos</em> espacios de nombres en un archivo si lo desea.  Debe tenerse en cuenta que todos los espacios de nombres <em>deben</em> declararse por su nombre completo; no admiten la anidaci√≥n. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core.Extra module MoreMathStuff = let add xy = x + y</code> </pre> <br><p>  No es posible un conflicto de nombres entre el espacio de nombres y el m√≥dulo. </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core //    - Core.Utilities //     ! module Utilities = let add xy = x + y</code> </pre> <br><h2>  Mezcla de tipos y funciones en m√≥dulos </h2><br><p>  Como hemos visto, los m√≥dulos generalmente consisten en muchas funciones interdependientes que interact√∫an con un tipo de datos en particular. </p><br><p>  En OOP, las estructuras de datos y las funciones por encima de ellas se combinar√≠an en una clase.  Y en F # funcional, las estructuras de datos y las funciones por encima de ellas se combinan en un m√≥dulo. </p><br><p>  Hay dos patrones para combinar tipos y funciones: </p><br><ul><li>  tipo se declara por separado de las funciones </li><li>  El tipo se declara en el mismo m√≥dulo que las funciones </li></ul><br><p>  En el primer caso, el tipo se declara <em>fuera de</em> cualquier m√≥dulo (pero en el espacio de nombres), despu√©s de lo cual las funciones que funcionan con este tipo se colocan en el m√≥dulo del mismo tipo. </p><br><pre> <code class="plaintext hljs">//    namespace Example //      type PersonType = {First:string; Last:string} //    ,     module Person = //  let create first last = {First=first; Last=last} // ,     let fullName {First=first; Last=last} = first + " " + last let person = Person.create "john" "doe" Person.fullName person |&gt; printfn "Fullname=%s"</code> </pre> <br><p>  Alternativamente, el tipo se declara <em>dentro del</em> m√≥dulo y tiene un nombre simple como " <code>T</code> " o el nombre del m√≥dulo.  El acceso a las funciones es aproximadamente como sigue: <code>MyModule.Func</code> y <code>MyModule.Func2</code> , y acceso al tipo: <code>MyModule.T</code> : </p><br><pre> <code class="plaintext hljs">module Customer = // Customer.T -      type T = {AccountId:int; Name:string} //  let create id name = {T.AccountId=id; T.Name=name} // ,     let isValid {T.AccountId=id; } = id &gt; 0 let customer = Customer.create 42 "bob" Customer.isValid customer |&gt; printfn "Is valid?=%b"</code> </pre> <br><p>  Tenga en cuenta que en ambos casos debe haber una funci√≥n de constructor que cree una nueva instancia del tipo (f√°brica).  Luego, en el c√≥digo del cliente, apenas tiene que acceder al nombre del tipo expl√≠citamente, y no tendr√° que preguntarse si el tipo est√° dentro del m√≥dulo o no. </p><br><p>  Entonces, ¬øqu√© manera de elegir? </p><br><ul><li>  El primer enfoque es m√°s parecido al .NET cl√°sico, y deber√≠a preferirse si planea usar esta biblioteca para c√≥digo fuera de F #, donde se espera una clase existente por separado. </li><li>  El segundo enfoque es m√°s com√∫n en otros lenguajes funcionales.  El tipo dentro del m√≥dulo se compila como una clase anidada, que generalmente no es muy conveniente para los lenguajes OOP. </li></ul><br><p>  Por ti mismo, puedes experimentar con ambos m√©todos.  En el caso del desarrollo del equipo, se debe elegir un estilo. </p><br><h3>  M√≥dulos que contienen solo tipos </h3><br><p>  Si hay muchos tipos que deben declararse sin ninguna funci√≥n, no se moleste en usar el m√≥dulo.  Puede declarar tipos directamente en el espacio de nombres sin recurrir a clases anidadas. </p><br><p>  Por ejemplo, es posible que desee hacer esto: </p><br><pre> <code class="plaintext hljs">//    module Example //     type PersonType = {First:string; Last:string} //    ,  ...</code> </pre> <br><p>  Y aqu√≠ hay otra forma de hacer lo mismo.  El <code>module</code> palabras simplemente se reemplaza con el <code>namespace</code> palabras. </p><br><pre> <code class="plaintext hljs">//    namespace Example //     type PersonType = {First:string; Last:string}</code> </pre> <br><p>  En ambos casos, <code>PersonType</code> tendr√° el mismo nombre completo. </p><br><p>  Tenga en cuenta que este reemplazo solo funciona con tipos.  Las funciones <strong>siempre</strong> deben declararse dentro del m√≥dulo. </p><br><h1>  Recursos Adicionales </h1><br><p>  Hay muchos tutoriales para F #, incluidos los materiales para aquellos que vienen con experiencia en C # o Java.  Los siguientes enlaces pueden ser √∫tiles a medida que profundiza en F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # por diversi√≥n y ganancias</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aprenda X en minutos Y: F #</a> </li></ul><br><p>  Tambi√©n se describen varias otras formas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de comenzar a aprender F #</a> . </p><br><p>  Finalmente, la comunidad F # es muy amigable para principiantes.  Hay un chat muy activo en Slack, respaldado por la F # Software Foundation, con salas para principiantes a las que puedes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">unirte libremente</a> .  ¬°Recomendamos encarecidamente que haga esto! </p><br><p>  ¬°No te olvides de visitar el sitio de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de habla rusa F #</a> !  Si tiene alguna pregunta sobre el aprendizaje de un idioma, estaremos encantados de discutirlo en las salas de chat: </p><br><ul><li>  room <code>#ru_general</code> en el <code>#ru_general</code> de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en Telegram</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">chatear en gitter</a> </li><li>  room #en_general en el chat flojo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">F # Software Foundation</a> </li></ul><br><h2>  Sobre autores de traducci√≥n </h2><br><p>  Traducido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  La traducci√≥n y los cambios editoriales fueron realizados por los esfuerzos de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">comunidad de desarrolladores de F # de habla rusa</a> .  Tambi√©n agradecemos a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@schvepsss</em></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>@shwars</em></a> por preparar este art√≠culo para su publicaci√≥n. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433406/">https://habr.com/ru/post/es433406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433396/index.html">Frontend 2018: resultados del a√±o</a></li>
<li><a href="../es433398/index.html">Pensamiento funcional Parte 7</a></li>
<li><a href="../es433400/index.html">Tutorial React Parte 2: Componentes funcionales</a></li>
<li><a href="../es433402/index.html">Pensamiento funcional Parte 8</a></li>
<li><a href="../es433404/index.html">Tutorial React Parte 3: Archivos de componentes, estructura del proyecto</a></li>
<li><a href="../es433408/index.html">Manejo eficiente de la memoria en Node.js</a></li>
<li><a href="../es433410/index.html">Pensamiento funcional Parte 10</a></li>
<li><a href="../es433412/index.html">Pensamiento funcional Parte 11: Final</a></li>
<li><a href="../es433414/index.html">Prueba de PRTG Network Monitor y comparaci√≥n con Zabbix</a></li>
<li><a href="../es433420/index.html">Resultados de ZeroNights 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>