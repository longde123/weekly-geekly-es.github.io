<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤™ğŸ¿ ğŸš° ğŸ¤¦ğŸ¾ ref penduduk setempat dan pengembalian ref dalam C #: jebakan kinerja ğŸ’ª ğŸ´ â—¼ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sejak awal, C # mendukung argumen lewat nilai atau referensi. Tetapi sebelum versi 7, kompiler C # hanya mendukung satu cara untuk mengembalikan nilai...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ref penduduk setempat dan pengembalian ref dalam C #: jebakan kinerja</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423061/">  Sejak awal, C # mendukung argumen lewat nilai atau referensi.  Tetapi sebelum versi 7, kompiler C # hanya mendukung satu cara untuk mengembalikan nilai dari metode (atau properti) - kembali dengan nilai.  Dalam C # 7, situasinya telah berubah dengan diperkenalkannya dua fitur baru: pengembalian ref dan penduduk lokal ref.  Lebih banyak tentang mereka dan kinerja mereka - di bawah potongan. <br><br><img src="https://habrastorage.org/webt/gi/7e/dd/gi7eddufiqnmiqtmtby4nrkxclw.jpeg"><a name="habracut"></a><br><br><h2>  Alasan </h2><br>  Ada banyak perbedaan antara array dan koleksi lainnya dalam hal runtime bahasa umum.  Sejak awal, CLR mendukung array, dan mereka dapat dianggap sebagai fungsi bawaan.  Lingkungan CLR dan kompiler JIT dapat bekerja dengan array, dan mereka juga memiliki satu fitur lagi: pengindeks array mengembalikan elemen dengan referensi, dan bukan dengan nilai. <br><br>  Untuk mendemonstrasikan ini, kita harus beralih ke metode terlarang - gunakan tipe nilai yang bisa diubah: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Mutable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mutable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X =&gt; _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncrementX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _x++; } } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutability</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ma = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)}; ma[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed! Assert.That(ma[0].X, Is.EqualTo(2)); var ml = new List&lt;Mutable&gt; {new Mutable(1)}; ml[0].IncrementX(); // X hasn't been changed! Assert.That(ml[0].X, Is.EqualTo(1)); }</span></span></code> </pre> <br>  Pengujian akan berhasil karena pengindeks array berbeda secara signifikan dari pengindeks Daftar. <br><br>  Kompiler C # memberikan instruksi khusus kepada pengindeks array - ldelema, yang mengembalikan tautan terkelola ke elemen array ini.  Pada dasarnya, pengindeks array mengembalikan elemen dengan referensi.  Namun, Daftar tidak dapat berperilaku dengan cara yang sama, karena dalam C # itu tidak mungkin * untuk mengembalikan alias keadaan internal.  Oleh karena itu, pengindeks daftar mengembalikan elemen dengan nilai, yaitu, mengembalikan salinan elemen ini. <br><br>  * Seperti yang akan segera kita lihat, pengindeks Daftar masih tidak dapat mengembalikan elemen dengan referensi. <br><br>  Ini berarti bahwa ma [0] .IncrementX () memanggil metode yang memodifikasi elemen pertama array, sementara ml [0] .IncrementX () memanggil metode yang memodifikasi salinan elemen tanpa mempengaruhi daftar asli. <br><br><h2>  Nilai Pengembalian dan Referensi Variabel Lokal: Dasar-dasar </h2><br>  Arti fungsi-fungsi ini sangat sederhana: mendeklarasikan nilai referensi yang dikembalikan memungkinkan Anda untuk mengembalikan alias dari variabel yang ada, dan variabel lokal referensi dapat menyimpan alias tersebut. <br><br>  1. Contoh sederhana: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefLocalsAndRefReturnsBasics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Capture an alias to the first element into a local ref int first = ref array[0]; first = 42; Assert.That(array[0], Is.EqualTo(42)); // Local function that returns the first element by ref ref int GetByRef(int[] a) =&gt; ref a[0]; // Weird syntax: the result of a function call is assignable GetByRef(array) = -1; Assert.That(array[0], Is.EqualTo(-1)); }</span></span></code> </pre> <br>  2. Nilai referensi yang dikembalikan dan pengubah hanya baca <br><br>  Nilai referensi yang dikembalikan dapat mengembalikan alias dari bidang contoh, dan mulai dengan C # versi 7.2, Anda dapat mengembalikan alias tanpa bisa menulis ke objek terkait menggunakan pengubah ref readonly: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationWentWrong</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Guid _guid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncapsulationWentWrong</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-comment"><span class="hljs-comment">// Return an alias to the private field. No encapsulation any more. public ref int X =&gt; ref _x; // Return a readonly alias to the private field. public ref readonly Guid Guid =&gt; ref _guid; } [Test] public void NoEncapsulation() { var instance = new EncapsulationWentWrong(42); instance.X++; Assert.That(instance.X, Is.EqualTo(43)); // Cannot assign to property 'EncapsulationWentWrong.Guid' because it is a readonly variable // instance.Guid = Guid.Empty; }</span></span></code> </pre> <br><ul><li>  Metode dan properti dapat mengembalikan "alias" dari keadaan internal.  Dalam hal ini, metode tugas tidak boleh ditentukan untuk properti. </li><li>  Kembali dengan referensi memecah enkapsulasi, karena klien mendapatkan kontrol penuh atas keadaan internal objek. </li><li>  Kembali melalui tautan hanya baca menghindari penyalinan jenis nilai yang tidak perlu, sambil tidak mengizinkan klien untuk mengubah keadaan internal. </li><li>  Tautan baca-saja dapat digunakan untuk jenis referensi, meskipun ini tidak masuk akal dalam kasus-kasus non-standar. </li></ul><br>  3. Batasan yang ada.  Mengembalikan alias bisa berbahaya: menggunakan alias untuk variabel yang ditempatkan di tumpukan setelah metode selesai akan membuat aplikasi macet.  Untuk membuat fungsi ini aman, kompiler C # menerapkan berbagai batasan: <br><br><ul><li>  Tidak dapat mengembalikan tautan ke variabel lokal. </li><li>  Tidak dapat mengembalikan referensi ke ini dalam struktur. </li><li>  Anda bisa mengembalikan tautan ke variabel yang terletak di heap (misalnya, ke anggota kelas). </li><li>  Anda dapat mengembalikan tautan ke parameter ref / out. </li></ul><br>  Untuk informasi lebih lanjut, kami sarankan Anda memeriksa publikasi yang sangat baik, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Aman untuk mengembalikan aturan pengembalian ref</a> .  Penulis artikel, Vladimir Sadov, adalah pencipta fungsi referensi balik untuk kompiler C #. <br><br>  Sekarang kita memiliki gagasan umum tentang nilai referensi yang dikembalikan dan referensi variabel lokal, mari kita lihat bagaimana mereka dapat digunakan. <br><br><h2>  Menggunakan nilai referensi yang dikembalikan dalam pengindeks </h2><br>  Untuk menguji dampak fungsi-fungsi ini terhadap kinerja, kami akan membuat koleksi unik dan tidak dapat diubah yang disebut NaiveImmutableList &lt;T&gt; dan membandingkannya dengan T [] dan Daftar untuk struktur dengan ukuran yang berbeda (4, 16, 32 dan 48). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NaiveImmutableList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T[] _data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T[] data</span></span></span><span class="hljs-function">)</span></span> =&gt; (_data, _length) = (data, data.Length); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx] <span class="hljs-comment"><span class="hljs-comment">// R# 2017.3.2 is completely confused with this syntax! // =&gt; ref (idx &gt;= _length ? ref Throw() : ref _data[idx]); { get { // Extracting 'throw' statement into a different // method helps the jitter to inline a property access. if ((uint)idx &gt;= (uint)_length) ThrowIndexOutOfRangeException(); return ref _data[idx]; } } private static void ThrowIndexOutOfRangeException() =&gt; throw new IndexOutOfRangeException(); } struct LargeStruct_48 { public int N { get; } private readonly long l1, l2, l3, l4, l5; public LargeStruct_48(int n) : this() =&gt; N = n; } // Other structs like LargeStruct_16, LargeStruct_32 etc</span></span></code> </pre> <br>  Tes kinerja dilakukan untuk semua koleksi dan menambahkan semua nilai properti N untuk setiap item: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elementsCount = <span class="hljs-number"><span class="hljs-number">100</span></span>_000; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> LargeStruct_48[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, elementsCount).Select(v =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LargeStruct_48(v)).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LargeStruct_48[] _array48 = CreateArray_48(); [BenchmarkCategory(<span class="hljs-string"><span class="hljs-string">"BigStruct_48"</span></span>)] [Benchmark(Baseline = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Using elementsCound but not array.Length to force the bounds check // on each iteration. for (int i = 0; i &lt; elementsCount; i++) { result = _array48[i].N; } return result; }</span></span></code> </pre> <br>  Hasilnya adalah sebagai berikut: <br><br><img src="https://habrastorage.org/webt/2k/5t/6i/2k5t6iq-egji_4h7wp8zgizndws.png"><br><br>  Rupanya, ada sesuatu yang salah!  Kinerja koleksi NaiveImmutableList &lt;T&gt; kami sama dengan Daftar.  Apa yang terjadi <br><br><h2>  Kembalikan Nilai dengan Pengubah baca saja: Cara Kerja </h2><br>  Seperti yang Anda lihat, pengindeks NaiveImmutableList &lt;T&gt; mengembalikan tautan read-only menggunakan pengubah readonly ref.  Ini sepenuhnya dibenarkan, karena kami ingin membatasi kemampuan pelanggan untuk mengubah kondisi mendasar dari koleksi yang tidak dapat diubah.  Namun, struktur yang kami gunakan dalam tes kinerja tidak hanya dapat dibaca. <br><br>  Tes ini akan membantu kita memahami perilaku dasar: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutabilityForNaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ml = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NaiveImmutableList&lt;Mutable&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)); ml[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed, right? Assert.That(ml[0].X, Is.EqualTo(2)); }</span></span></code> </pre> <br>  Tes gagal!  Tapi mengapa?  Karena struktur "read-only links" mirip dengan struktur dalam modifiers dan bidang readonly sehubungan dengan struktur: kompiler menghasilkan salinan pelindung setiap kali elemen struktur digunakan.  Ini berarti ml [0].  masih membuat salinan dari elemen pertama, tetapi ini tidak dilakukan oleh pengindeks: salinan dibuat di titik panggilan. <br><br>  Perilaku ini sebenarnya masuk akal.  Kompiler C # mendukung argumen yang lewat dengan nilai, dengan referensi, dan dengan â€œtautan baca-sajaâ€ menggunakan modifier in (untuk detail, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The-modifier dan struct readonly di C #</a> (â€œStruktur read-only in dan modifier di C # ")).  Sekarang kompiler mendukung tiga cara berbeda untuk mengembalikan nilai dari suatu metode: dengan nilai, dengan referensi, dan dengan tautan hanya-baca. <br><br>  Tautan baca-saja sangat mirip dengan tautan biasa sehingga kompiler menggunakan InAttribute yang sama untuk membedakan antara nilai pengembaliannya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _n; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ByReadonlyRef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _n;</code> </pre> <br>  Dalam hal ini, metode ByReadonlyRef mengkompilasi secara efisien menjadi: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">InAttribute</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: IsReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ByReadonlyRef() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._n; }</code> </pre> <br>  Kesamaan antara modifier in dan link read-only berarti bahwa fungsi-fungsi ini sangat tidak cocok untuk struktur reguler dan dapat menyebabkan masalah kinerja.  Pertimbangkan sebuah contoh: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BigStruct { <span class="hljs-comment"><span class="hljs-comment">// Other fields public int X { get; } public int Y { get; } } private BigStruct _bigStruct; public ref readonly BigStruct GetBigStructByRef() =&gt; ref _bigStruct; ref readonly var bigStruct = ref GetBigStructByRef(); int result = bigStruct.X + bigStruct.Y;</span></span></code> </pre> <br>  Selain sintaks yang tidak biasa ketika mendeklarasikan variabel untuk bigStruct, kodenya terlihat bagus.  Tujuannya jelas: BigStruct kembali dengan referensi untuk alasan kinerja.  Sayangnya, karena struktur BigStruct dapat ditulis, salinan pelindung dibuat setiap kali item diakses. <br><br><h2>  Menggunakan nilai referensi yang dikembalikan dalam pengindeks.  Percobaan nomor 2 </h2><br>  Mari kita coba serangkaian tes yang sama untuk struktur hanya-baca dengan ukuran berbeda: <br><br><img src="https://habrastorage.org/webt/8s/u5/je/8su5je3fe_-dhpjlf4f1bpeqoug.png"><br><br>  Sekarang hasilnya jauh lebih masuk akal.  Waktu pemrosesan masih meningkat untuk struktur besar, tetapi ini diharapkan, karena memproses lebih dari 100 ribu struktur lebih besar membutuhkan waktu lebih lama.  Tetapi sekarang runtime untuk NaiveimmutableList &lt;T&gt; sangat dekat dengan waktu T [] dan jauh lebih baik daripada dalam kasus Daftar. <br><br><h2>  Kesimpulan </h2><br><ul><li>  Nilai referensi yang dikembalikan harus ditangani dengan hati-hati karena dapat merusak enkapsulasi. </li><li>  Nilai referensi yang dikembalikan dengan pengubah readonly hanya efektif untuk struktur read-only.  Dalam kasus struktur konvensional, masalah kinerja dapat terjadi. </li><li>  Saat bekerja dengan struktur yang dapat ditulisi, mengembalikan nilai referensi dengan pengubah readonly membuat salinan pelindung setiap kali variabel digunakan, yang dapat menyebabkan masalah kinerja. </li></ul><br>  Nilai referensi yang dikembalikan dan variabel lokal yang dirujuk adalah fungsi yang berguna untuk pembuat perpustakaan dan pengembang kode infrastruktur.  Namun, mereka sangat berbahaya untuk digunakan dalam kode perpustakaan: untuk menggunakan koleksi yang secara efektif mengembalikan item menggunakan tautan baca-saja, setiap pengguna perpustakaan harus ingat: tautan baca-saja ke struktur yang dapat ditulis menciptakan salinan pelindung â€œpada titik panggilan ".  Dalam kasus terbaik, ini akan meniadakan kemungkinan peningkatan produktivitas, dan yang terburuk akan mengarah pada kemunduran serius jika pada saat yang sama sejumlah besar permintaan dilakukan ke satu variabel referensi lokal, hanya baca. <br><br>  Tautan baca-saja PS akan muncul di BCL.  Metode referensi yang hanya dapat dibaca untuk mengakses item dalam koleksi yang tidak berubah disajikan dalam permintaan berikut untuk menyertakan perubahan dalam repo corefx ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Menerapkan Proposal API ItemRef</a> ("Proposal untuk memasukkan API ItemRef")).  Karena itu, sangat penting bagi setiap orang untuk memahami fitur-fitur menggunakan fungsi-fungsi ini dan bagaimana dan kapan mereka harus diterapkan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id423061/">https://habr.com/ru/post/id423061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id423049/index.html">Proses Pembelajaran di Linux</a></li>
<li><a href="../id423051/index.html">Perjuangan untuk Sumber Daya, Bagian 1: Dasar-Dasar Kelompok</a></li>
<li><a href="../id423053/index.html">Struct and readonly: bagaimana cara menghindari penurunan kinerja</a></li>
<li><a href="../id423055/index.html">Analis Wall Street: "Apple membuat kami makan topi kami"</a></li>
<li><a href="../id423057/index.html">Python juga menolak sebagian istilah master / slave</a></li>
<li><a href="../id423063/index.html">Epson WorkForce Pro: Kronik tentang bagaimana kantor cetak inkjet â€œmenarik selimutâ€ dari laser dan apa yang terjadi hari ini</a></li>
<li><a href="../id423065/index.html">Pakar Positive Technologies menemukan kemungkinan pengungkapan kunci enkripsi di Intel ME</a></li>
<li><a href="../id423067/index.html">Alat Pengembang Python dari Microsoft. Memulai</a></li>
<li><a href="../id423069/index.html">Acara Istimewa Apple, September 2018 [arsip terjemahan teks]</a></li>
<li><a href="../id423071/index.html">Saya tidak takut dengan NDA Anda</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>