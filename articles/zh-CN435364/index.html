<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏽 😇 ⛹🏻 在Spring中自定义依赖项解析 🧜🏾 🕺🏽 🔍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="你好 我叫Andrey Nevedomsky，我是SberTekh的首席工程师。 我在一个团队中工作，该团队开发ESF（统一正面系统）的系统服务之一。 在我们的工作中，我们积极使用Spring框架，尤其是它的DI，并且不时遇到这样一个事实，即解决Spring中的依赖关系对我们来说不够聪明。 本文是我...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Spring中自定义依赖项解析</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/sberbank/blog/435364/"> 你好 我叫Andrey Nevedomsky，我是SberTekh的首席工程师。 我在一个团队中工作，该团队开发ESF（统一正面系统）的系统服务之一。 在我们的工作中，我们积极使用Spring框架，尤其是它的DI，并且不时遇到这样一个事实，即解决Spring中的依赖关系对我们来说不够聪明。 本文是我尝试使其变得更智能并大体上了解其工作原理的结果。 希望您可以从中学习有关弹簧装置的新知识。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ea/bbf/f4c/0eabbff4c25bb87806837c487f847fcc.png"><br><a name="habracut"></a><br> 在阅读本文之前，我强烈建议您阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">Boris</a> Yevgeny <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">EvgenyBorisov的</a>报告： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Spring Ripper，第1部分</a> ；  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">弹簧松土器，第2部分</a> 。 仍然有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">播放列表</a> 。 <br><br><h2> 引言 </h2><br> 假设我们被要求开发一种用于预测命运和星座的服务。 我们的服务有几个组成部分，但对我们来说主要是两个： <br><br><ul><li>  Globa，将实现FortuneTeller界面并预测命运； <br><br><img src="https://habrastorage.org/getpro/habr/post_images/301/c90/6f1/301c906f1584237b8bab4f8627484ff2.png" width="365" height="450"><br><br></li></ul><br><ul><li> 吉普赛人，它将实现HoroscopeTeller界面并创建星座。 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9f/520/3ad/d9f5203ad3b823ea61d5322655d2164d.png" width="365" height="450"><br><br></li></ul><br> 同样，在我们的服务中，实际上将有多个端点（控制器）用于获得算命和星座。 而且，我们还将使用将应用于控制器方法的方面来控制IP对应用程序的访问，如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">RestrictionAspect.java</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Aspect</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RestrictionAspect</span></span></span><span class="hljs-class"> </span></span>{    <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Predicate&lt;String&gt; ipIsAllowed;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestrictionAspect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Predicate&lt;String&gt; ipIsAllowed)</span></span></span><span class="hljs-function"> </span></span>{        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ipIsAllowed = ipIsAllowed;    }    <span class="hljs-meta"><span class="hljs-meta">@Before</span></span>(<span class="hljs-string"><span class="hljs-string">"execution(public * com.github.monosoul.fortuneteller.web.*.*(..))"</span></span>)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAccess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{        val ip = getRequestSourceIp();       log.debug(<span class="hljs-string"><span class="hljs-string">"Source IP: {}"</span></span>, ip);        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ipIsAllowed.test(ip)) {            <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AccessDeniedException(format(<span class="hljs-string"><span class="hljs-string">"Access for IP [%s] is denied"</span></span>, ip));        }    }    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRequestSourceIp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{        val requestAttributes = currentRequestAttributes();        Assert.state(requestAttributes <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ServletRequestAttributes,                <span class="hljs-string"><span class="hljs-string">"RequestAttributes needs to be a ServletRequestAttributes"</span></span>);        val request = ((ServletRequestAttributes) requestAttributes).getRequest();        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.getRemoteAddr();    } }</code> </pre> <br></div></div><br> 为了验证是否允许从这样的IP访问，我们将使用<code>ipIsAllowed</code>谓词的某些实现。 通常，在此方面的站点上，可能会有其他一些授权。 <br><br> 因此，我们开发了该应用程序，一切对我们来说都很好。 但是，让我们现在谈论测试。 <br><br><h2> 怎么测试呢？ </h2><br> 让我们谈谈如何测试方面的应用。 我们有几种方法可以做到这一点。 <br><br> 您可以为方面和控制器编写单独的测试，而无需提高spring上下文（这只会为控制器提供方面的代理，您可以在官方<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>阅读更多有关此内容的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> ），但是在这种情况下，我们将<u>无法准确测试</u>将<u>哪些方面正确应用于控制器和工作完全符合我们的期望</u> ; <br><br> 您可以编写测试以提高应用程序的完整上下文，但是在这种情况下： <br><br><ul><li> 运行测试将需要很长时间，因为 所有垃圾箱都将升起； </li><li> 我们将需要准备有效的测试数据，这些数据可以通过容器之间的整个调用链，而不会同时抛出NPE。 </li></ul><br> 但是，我们想准确测试方面已应用并正在执行的工作。 我们不想测试由控制器调用的服务，因此不想被测试数据所困扰并牺牲启动时间。 因此，我们将编写测试，仅在其中提出部分上下文。 即 在我们的上下文中，将有一个真正的Aspect Bean和一个真正的Controller Bean，其他所有东西都是mokami。 <br><br><h2> 如何制作摩卡豆？ </h2><br> 有几种方法可以在春季制作摩卡豆。 为了清楚起见，以一个示例为例，我们采用服务的一个控制器<code>PersonalizedHoroscopeTellController</code> ，其代码如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">PersonalizedHoroscopeTellController.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-meta"><span class="hljs-meta">@RestController</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequestMapping</span></span>( value = <span class="hljs-string"><span class="hljs-string">"/horoscope"</span></span>, produces = APPLICATION_JSON_UTF8_VALUE ) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HoroscopeTeller horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, ZodiacSign&gt; zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, String&gt; nameNormalizer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeTeller horoscopeTeller, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, ZodiacSign&gt; zodiacSignConverter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, String&gt; nameNormalizer )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.horoscopeTeller = horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.zodiacSignConverter = zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nameNormalizer = nameNormalizer; } <span class="hljs-meta"><span class="hljs-meta">@GetMapping</span></span>(value = <span class="hljs-string"><span class="hljs-string">"/tell/personal/{name}/{sign}"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PersonalizedHoroscope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@PathVariable </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String name, @PathVariable </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String sign)</span></span></span><span class="hljs-function"> </span></span>{ log.info(<span class="hljs-string"><span class="hljs-string">"Received name: {}; sign: {}"</span></span>, name, sign); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PersonalizedHoroscope.builder() .name( nameNormalizer.apply(name) ) .horoscope( horoscopeTeller.tell( zodiacSignConverter.apply(sign) ) ) .build(); } }</code> </pre> <br></div></div><br><h3> 在每个测试中具有依赖项的Java Config </h3><br> 对于每个测试，我们都可以编写Java Config，其中描述控制器和方面Bean以及具有控制器依赖项Moks的Bean。 这种描述bean的方法势在必行，因为我们将明确地告诉spring我们需要如何创建bean。 <br><br> 在这种情况下，针对我们控制器的测试将如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">javaconfig / PersonalizedHoroscopeTellControllerTest.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringJUnitConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LIMIT = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonalizedHoroscopeTellController controller; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Predicate&lt;String&gt; ipIsAllowed; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doNothingWhenAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwExceptionWhenNotAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); assertThatThrownBy(() -&gt; controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT))) .isInstanceOf(AccessDeniedException.class); } <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>(AspectConfiguration.class) <span class="hljs-meta"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> PersonalizedHoroscopeTellController </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">personalizedHoroscopeTellController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeTeller horoscopeTeller, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, ZodiacSign&gt; zodiacSignConverter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, String&gt; nameNormalizer )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonalizedHoroscopeTellController(horoscopeTeller, zodiacSignConverter, nameNormalizer); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HoroscopeTeller </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">horoscopeTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock(HoroscopeTeller.class); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Function&lt;String, ZodiacSign&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zodiacSignConverter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock(Function.class); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Function&lt;String, String&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nameNormalizer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mock(Function.class); } } }</code> </pre> <br></div></div><br> 这样的测试看起来很麻烦。 在这种情况下，我们将必须为每个控制器编写Java Config。 尽管其内容将有所不同，但其含义将相同：创建一个控制器bean和moki作为其依赖项。 因此，从本质上讲，所有控制器都是相同的。 我和任何程序员一样，都是一个懒惰的人，因此我立即拒绝了此选项。 <br><br><h3>  @MockBean在每个具有依赖项的字段上的注释 </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@MockBean批注</a>出现在Spring Boot Test版本1.4.0中。 它类似于Mockito中的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Mock</a> （事实上​​，它甚至在内部使用它），唯一的区别是，当使用<code>@MockBean</code> ，创建的模拟将自动放置在spring上下文中。 这种声明mok的方法将是声明性的，因为我们不必确切地告诉spring如何创建这些mok。 <br><br> 在这种情况下，测试将如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">模拟bean / PersonalizedHoroscopeTellControllerTest.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringJUnitConfig</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LIMIT = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> HoroscopeTeller horoscopeTeller; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Function&lt;String, ZodiacSign&gt; zodiacSignConverter; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Function&lt;String, String&gt; nameNormalizer; <span class="hljs-meta"><span class="hljs-meta">@MockBean</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Predicate&lt;String&gt; ipIsAllowed; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonalizedHoroscopeTellController controller; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doNothingWhenAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwExceptionWhenNotAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); assertThatThrownBy(() -&gt; controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT))) .isInstanceOf(AccessDeniedException.class); } <span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@Import</span></span>({PersonalizedHoroscopeTellController.class, RestrictionAspect.class, RequestContextHolderConfigurer.class}) <span class="hljs-meta"><span class="hljs-meta">@EnableAspectJAutoProxy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span><span class="hljs-class"> </span></span>{ } }</code> </pre> <br></div></div><br> 此选项仍具有Java Config，但更加紧凑。 缺点中-我必须声明具有控制器依赖性的字段（带有<code>@MockBean</code>批注的字段），即使在测试中不再使用它们。 好吧，如果由于某种原因您使用的Spring Boot版本低于1.4.0，那么您将无法使用此注释。 <br><br> 因此，我想到了另一种替代方案。 我希望它以这种方式工作... <br><br><h3> 通过@Automocked注释依赖组件 </h3><br> 我希望我们拥有<code>@Automocked</code>批注，该批注只能与控制器一起放在字段上方，然后会自动为该控制器创建moki并将其放置在上下文中。 <br><br> 这种情况下的测试如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">自动模拟/ PersonalizedHoroscopeTellControllerTest.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringJUnitConfig</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContextConfiguration</span></span>(classes = AspectConfiguration.class) <span class="hljs-meta"><span class="hljs-meta">@TestExecutionListeners</span></span>(listeners = AutomockTestExecutionListener.class, mergeMode = MERGE_WITH_DEFAULTS) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellControllerTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LIMIT = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Automocked</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PersonalizedHoroscopeTellController controller; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Predicate&lt;String&gt; ipIsAllowed; <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doNothingWhenAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT)); } <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwExceptionWhenNotAllowed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ when(ipIsAllowed.test(anyString())).thenReturn(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); assertThatThrownBy(() -&gt; controller.tell(randomAlphabetic(LIMIT), randomAlphabetic(LIMIT))) .isInstanceOf(AccessDeniedException.class); } }</code> </pre> <br></div></div><br> 如您所见，此选项是所提供选项中最紧凑的选项，只有一个控制器bean（外加一个方面的谓词）， <code>@Automocked</code>是<code>@Automocked</code>注解<u>，创建bean并将它们放置在上下文中的</u>所有<u>魔力都被编写了一次</u> ，可以在所有方法中使用测试。 <br><br><h2> 如何运作？ </h2><br> 让我们看看它是如何工作的以及我们需要什么。 <br><br><h3>  TestExecutionListener </h3><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">spring</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TestExecutionListener中</a>有这样的接口。 它提供了一个API，用于在各个阶段嵌入到测试执行过程中，例如，在创建测试类的实例时，调用测试方法之前或之后等。 他有几种开箱即用的实现。 例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DirtiesContextTestExecutionListener</a> ，如果放置了适当的注释，它将清理上下文；  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DependencyInjectionTestExecutionListener-</a>在测试等中执行依赖项注入。 要将自定义侦听器应用于测试，您需要在其上方放置<code>@TestExecutionListeners</code>批注并指示您的实现。 <br><br><h3> 已订购 </h3><br> 弹簧中还有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">订购</a>接口。 它用于指示应该以某种方式对对象进行排序。 例如，当您具有同一个接口的多个实现，并且想要将它们注入到一个集合中时，则将在此集合中根据Ordered对其进行排序。 就TestExecutionListener而言，此注释指示应按顺序应用它们。 <br><br> 因此，我们的监听器将实现2个接口： <b>TestExecutionListener</b>和<b>Ordered</b> 。 我们称其为<b>AutomockTestExecutionListener</b> ，它看起来像这样： <br><br><div class="spoiler">  <b class="spoiler_title">AutomockTestExecutionListener.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Slf</span></span>4j <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutomockTestExecutionListener</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestExecutionListener</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ordered</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1900</span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareTestInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TestContext testContext)</span></span></span><span class="hljs-function"> </span></span>{ val beanFactory = ((DefaultListableBeanFactory) testContext.getApplicationContext().getAutowireCapableBeanFactory()); setByNameCandidateResolver(beanFactory); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val field : testContext.getTestClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.getAnnotation(Automocked.class) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } log.debug(<span class="hljs-string"><span class="hljs-string">"Performing automocking for the field: {}"</span></span>, field.getName()); makeAccessible(field); setField( field, testContext.getTestInstance(), createBeanWithMocks(findConstructorToAutomock(field.getType()), beanFactory) ); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setByNameCandidateResolver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DefaultListableBeanFactory beanFactory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((beanFactory.getAutowireCandidateResolver() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> AutomockedBeanByNameAutowireCandidateResolver)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } beanFactory.setAutowireCandidateResolver( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutomockedBeanByNameAutowireCandidateResolver(beanFactory.getAutowireCandidateResolver()) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Constructor&lt;?&gt; findConstructorToAutomock(<span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Class&lt;?&gt; clazz) { log.debug(<span class="hljs-string"><span class="hljs-string">"Looking for suitable constructor of {}"</span></span>, clazz.getCanonicalName()); Constructor&lt;?&gt; fallBackConstructor = clazz.getDeclaredConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val constructor : clazz.getDeclaredConstructors()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constructor.getParameterTypes().length &gt; fallBackConstructor.getParameterTypes().length) { fallBackConstructor = constructor; } val autowired = getAnnotation(constructor, Autowired.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (autowired != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> constructor; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fallBackConstructor; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createBeanWithMocks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Constructor&lt;T&gt; constructor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DefaultListableBeanFactory beanFactory)</span></span></span><span class="hljs-function"> </span></span>{ createMocksForParameters(constructor, beanFactory); val clazz = constructor.getDeclaringClass(); val beanName = forClass(clazz).toString(); log.debug(<span class="hljs-string"><span class="hljs-string">"Creating bean {}"</span></span>, beanName); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { val bean = beanFactory.createBean(clazz); beanFactory.registerSingleton(beanName, bean); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> beanFactory.getBean(beanName, clazz); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createMocksForParameters</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Constructor&lt;T&gt; constructor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DefaultListableBeanFactory beanFactory)</span></span></span><span class="hljs-function"> </span></span>{ log.debug(<span class="hljs-string"><span class="hljs-string">"{} is going to be used for auto mocking"</span></span>, constructor); val constructorArgsAmount = constructor.getParameterTypes().length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorArgsAmount; i++) { val parameterType = forConstructorParameter(constructor, i); val beanName = parameterType.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { beanFactory.registerSingleton( beanName, mock(parameterType.resolve(), withSettings().stubOnly()) ); } log.debug(<span class="hljs-string"><span class="hljs-string">"Mocked {}"</span></span>, beanName); } } }</code> </pre> <br></div></div><br> 这是怎么回事 首先，在<code>prepareTestInstance()</code>方法中，它找到带有<code>@Automocked</code>批注的所有字段： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val field : testContext.getTestClass().getDeclaredFields()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (field.getAnnotation(Automocked.class) == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; }</code> </pre> <br> 然后使这些字段可写： <br><br><pre> <code class="java hljs">makeAccessible(field);</code> </pre> <br> 然后，在<code>findConstructorToAutomock()</code>方法中，找到合适的构造函数： <br><br><pre> <code class="java hljs">Constructor&lt;?&gt; fallBackConstructor = clazz.getDeclaredConstructors()[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (val constructor : clazz.getDeclaredConstructors()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (constructor.getParameterTypes().length &gt; fallBackConstructor.getParameterTypes().length) { fallBackConstructor = constructor; } val autowired = getAnnotation(constructor, Autowired.class); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (autowired != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> constructor; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fallBackConstructor;</code> </pre> <br> 在我们的情况下，合适的构造函数是带有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Autowired</a>批注的构造函数或带有最多参数的构造函数。 <br><br> 然后，将找到的构造函数作为参数传递给<code>createBeanWithMocks()</code>方法，该方法又调用<code>createMocksForParameters()</code>方法，在该方法中，将为构造函数参数创建<code>createBeanWithMocks()</code>并在上下文中注册： <br><br><pre> <code class="java hljs">val constructorArgsAmount = constructor.getParameterTypes().length; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; constructorArgsAmount; i++) { val parameterType = forConstructorParameter(constructor, i); val beanName = parameterType.toString(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { beanFactory.registerSingleton( beanName, mock(parameterType.resolve(), withSettings().stubOnly()) ); } }</code> </pre> <br> 重要的是要注意，参数类型的字符串表示形式（以及泛型）将用作bin的名称。 也就是说，对于类型为<u><code>packages.Function&lt;String, String&gt;</code>字符串表示形式将为字符串<code>"packages.Function&lt;java.lang.String, java.lang.String&gt;"</code></u> 。 这很重要，我们将回到这一点。 <br><br> 在为所有参数创建模拟并在上下文中注册它们之后，我们返回创建依赖类的Bean（即本例中的控制器）： <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!beanFactory.containsBean(beanName)) { val bean = beanFactory.createBean(clazz); beanFactory.registerSingleton(beanName, bean); }</code> </pre> <br> 您还应该注意我们使用<u>Order 1900</u>的事实。 这是必需的，因为必须在清除<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DirtiesContextBeforeModesTestExecutionListener'ohm</a>上下文（order = 1500）之后并在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DependencyInjectionTestExExcutionListener</a> '依赖项注入（order = 2000）之前调用我们的侦听器，因为我们的侦听器会创建新的bin。 <br><br><h2>  AutowireCandidateResolver </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AutowireCandidateResolver</a>用于确定<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BeanDefinition是否与</a>依赖项描述<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">匹配</a> 。 他具有“开箱即用”的几种实现，其中包括： <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">QualifierAnnotationAutowireCandidateResolver-</a>根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qualifier</a>确定依赖项是否合适； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">GenericTypeAwareAutowireCandidateResolver-</a>基于泛型确定依赖项是否合适； </li><li> 和其他。 </li></ul><br> 同时，“开箱即用”的实现是从继承的俄罗斯娃娃，即 他们彼此扩大。 我们将编写一个装饰器，因为 它更加灵活。 <br><br> 解析器的工作方式如下： <br><br><ol><li>  Spring需要一个依赖项描述符<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">-DependencyDescriptor</a> ; <br></li><li> 然后，它采用适当类的所有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BeanDefinition</a> ； <br></li><li> 迭代接收到的BeanDefinitions，调用解析器的<code>isAutowireCandidate()</code>方法。 <br></li><li> 根据bin的描述是否与依赖项的描述匹配，该方法返回true或false。 <br></li></ol><br><h2> 为什么需要您的解析器？ </h2><br> 现在，让我们看看为什么在控制器的示例中需要解析器。 <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> HoroscopeTeller horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, ZodiacSign&gt; zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Function&lt;String, String&gt; nameNormalizer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PersonalizedHoroscopeTellController</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeTeller horoscopeTeller, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, ZodiacSign&gt; zodiacSignConverter, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;String, String&gt; nameNormalizer )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.horoscopeTeller = horoscopeTeller; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.zodiacSignConverter = zodiacSignConverter; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.nameNormalizer = nameNormalizer; }</code> </pre> <br> 如您所见，它具有两个相同类型的依赖项<b>-Function</b> ，但具有不同的泛型。 在一种情况下，使用<b>String</b>和<b>ZodiacSign</b> ，在另一种情况下使用<b>String</b>和<b>String</b> 。 而且问题在于， <u>Mockito无法考虑泛型来创建moks</u> 。 即 如果我们为这些依赖关系创建mokas并将它们放在上下文中，那么Spring将无法将它们注入到此类中，因为它们将不包含有关泛型的信息。 我们将看到一个例外，即上下文中有多个<b>Function</b>类bean。 正是这个问题，我们将在解析器的帮助下解决。 毕竟，您还记得，在侦听器的实现中，我们使用了具有泛型的类型作为bin的名称，这意味着我们所需要做的就是教导spring将依赖类型与bin的名称进行比较。 <br><br><h2>  AutomockedBeanByNameAutowireCandidateResolver </h2><br> 因此，我们的解析器将完全按照我在上文中的描述进行操作，并且<code>isAutowireCandidate()</code>方法的实现如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">AutowireCandidateResolver.isAutowireCandidate（）</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAutowireCandidate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(BeanDefinitionHolder beanDefinitionHolder, DependencyDescriptor descriptor)</span></span></span><span class="hljs-function"> </span></span>{ val dependencyType = descriptor.getResolvableType().resolve(); val dependencyTypeName = descriptor.getResolvableType().toString(); val candidateBeanDefinition = (AbstractBeanDefinition) beanDefinitionHolder.getBeanDefinition(); val candidateTypeName = beanDefinitionHolder.getBeanName(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidateTypeName.equals(dependencyTypeName) &amp;&amp; candidateBeanDefinition.getBeanClass() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> candidateResolver.isAutowireCandidate(beanDefinitionHolder, descriptor); }</code> </pre> <br></div></div><br> 在这里，他从依赖项描述中获取依赖项类型的字符串表示形式，从BeanDefinition（已经包含Bean类型的字符串表示形式）中获取Bean名称，然后对其进行比较，如果匹配，则返回true。 如果它们不匹配，它将委派给内部解析器。 <br><br><h2> 测试箱润湿选项 </h2><br> 总体而言，在测试中，我们可以使用以下选项进行箱式润湿： <br><br><ul><li>  Java Config-必不可少的，很繁琐的，带有样板，但也许信息量尽可能大； <br></li><li>  <code>@MockBean</code>是声明性的，不如Java Config笨重，但是仍然会以字段形式出现一些小的样板，这些字段具有测试本身未使用的依赖项； <br></li><li>  <code>@Automocked</code> +自定义解析器-测试和样板中的最少代码，但范围可能很窄，仍然需要编写。 但是，如果要确保弹簧正确地创建代理，可能会非常方便。 <br></li></ul><br><h2> 添加装饰器 </h2><br> 我们的团队<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">喜欢Decorator</a>设计模板的灵活性。 实际上，各个方面都实现了这种特定模式。 但是，如果您使用批注配置spring上下文并使用程序包扫描，则会遇到问题。 如果您在上下文中具有同一接口的多个实现，则在应用程序<b>启动时</b> ，将发生<b>NoUniqueBeanDefinitionException异常</b> ，即 春天将无法弄清楚应该注入哪种豆。 这个问题有几种解决方案，然后我们将研究它们，但是首先让我们弄清楚我们的应用程序将如何变化。 <br><br> 现在， <b>FortuneTeller</b>和<b>HoroscopeTeller</b>接口具有一个实现，我们将为每个接口添加2个实现： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1b/efb/01b/f1befb01b6356587cfe2c1728c7f2b0f.png"><br><br><ul><li> 缓存...-缓存装饰器； <br></li><li>  Logging ...是日志装饰器。 <br></li></ul><br> 那么，如何解决确定豆类顺序的问题呢？ <br><br><h2> 带有顶级装饰器的Java Config </h2><br> 您可以再次使用Java Config。 在这种情况下，我们将把bean描述为config类的方法，并且必须指定调用bean的构造函数所需的参数作为该方法的参数。 由此可以得出，如果bin的构造函数发生变化，我们将不得不更改配置，这不是很酷。 此选项的优点： <br><br><ul><li> 装饰器之间的连接性将较低，因为 它们之间的连接将在配置中进行描述，即 他们对彼此一无所知； <br></li><li> 装饰器顺序的所有更改都将集中在一个位置-配置。 <br></li></ul><br> 在我们的例子中，Java Config将如下所示： <br><br><div class="spoiler">  <b class="spoiler_title">DomainConfig.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DomainConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> FortuneTeller </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fortuneTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Map&lt;FortuneRequest, FortuneResponse&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FortuneResponseRepository fortuneResponseRepository, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Function&lt;FortuneRequest, PersonalData&gt; personalDataExtractor, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> PersonalDataRepository personalDataRepository )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoggingFortuneTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachingFortuneTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Globa(fortuneResponseRepository, personalDataExtractor, personalDataRepository), cache ) ); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> HoroscopeTeller </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">horoscopeTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Map&lt;ZodiacSign, Horoscope&gt; cache, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> HoroscopeRepository horoscopeRepository )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoggingHoroscopeTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CachingHoroscopeTeller( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Gypsy(horoscopeRepository), cache ) ); } }</code> </pre> <br></div></div><br> 如您所见，对于每个接口，这里仅声明一个bean，并且方法在参数中包含内部创建的所有对象的依赖关系。 在这种情况下，创建bean的逻辑非常明显。 <br><br><h2> 预选赛 </h2><br> 您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Qualifier</a>批注。 这将比Java Config更具声明性，但是在这种情况下，您需要显式指定当前Bean所依赖的Bean的名称。 缺点意味着：增加垃圾箱之间的连接性。 并且由于连接性增加，即使在装饰器顺序发生更改的情况下，更改也会在代码上平均涂抹。 也就是说，例如，如果在链的中间添加了新的装饰器，则更改将影响至少2个类。 <br><br><div class="spoiler">  <b class="spoiler_title">LoggingFortuneTeller.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Primary</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggingFortuneTeller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FortuneTeller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FortuneTeller internal; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Logger logger; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoggingFortuneTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @Qualifier(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"cachingFortuneTeller"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> @NonNull </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> FortuneTeller internal ) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.internal = internal; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.logger = getLogger(internal.getClass()); }</code> </pre> <br></div></div><br>        , ,       (      ,  <b>FortuneTeller</b> ,   ),      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@Primary</a> .     <b>internal</b>   <code>@Qualifier</code>    ,     — <b>cachingFortuneTeller</b> .         . <br><br><h2> Custom qualifier </h2><br>    2.5       Qualifier',    .     . <br><br>     enum   : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DecoratorType { LOGGING, CACHING, NOT_DECORATOR }</code> </pre> <br>    ,    qualifier': <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Qualifier</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Decorator { <span class="hljs-function"><span class="hljs-function">DecoratorType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> NOT_DECORATOR</span></span>; }</code> </pre> <br>  :    ,       <code>@Qualifier</code> ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">CustomAutowireConfigurer</a> ,        . <br><br>         Qualifier'   : <br><br><div class="spoiler"> <b class="spoiler_title">CachingFortuneTeller.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Decorator</span></span>(CACHING) <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CachingFortuneTeller</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FortuneTeller</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> FortuneTeller internal; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Map&lt;FortuneRequest, FortuneResponse&gt; cache; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CachingFortuneTeller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( @Decorator(NOT_DECORATOR)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> FortuneTeller internal, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> Map&lt;FortuneRequest, FortuneResponse&gt; cache ) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.internal = internal; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = cache; }</code> </pre> <br></div></div><br>   –    ,      <code>@Decorator</code>   ,   ,     –      ,      <u> </u> ,     <b>FortuneTeller</b> ',    – <b>Globa</b> . <br><br>       Qualifier' - , - . ,          ,     . ,      -    –      ,     ,      . <br><br><h2> DecoratorAutowireCandidateResolver </h2><br>   –   !      ! :)   ,     -     ,   Java Config',        . ,   -    ,     .     : <br><br><div class="spoiler"> <b class="spoiler_title">DomainConfig.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DomainConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderConfig&lt;FortuneTeller&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fortuneTellerOrderConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () -&gt; asList( LoggingFortuneTeller.class, CachingFortuneTeller.class, Globa.class ); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrderConfig&lt;HoroscopeTeller&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">horoscopeTellerOrderConfig</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () -&gt; asList( LoggingHoroscopeTeller.class, CachingHoroscopeTeller.class, Gypsy.class ); } }</code> </pre> <br></div></div><br>     –    Java Config'       ,       – . ,     ! <br><br>     -   .   , ,    ,      .    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrderConfig</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ List&lt;Class&lt;? extends T&gt;&gt; getClasses(); }</code> </pre> <br><h3> BeanDefinitionRegistryPostProcessor </h3><br>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BeanDefinitionRegistryPostProcessor</a> ,   BeanFactoryPostProcessor,   , ,  ,      BeanDefinition'.  ,      BeanFactoryPostProcessor,    . <br><br>    : <br><br><ul><li>   BeanDefinition'; <br></li><li>  BeanDefinition' ,   <b>OrderConfig</b> '.  , ..              BeanDefinition'   ; <br></li><li>   ,   <b>OrderConfig</b> ',  BeanDefinition',    ,     () . <br></li></ul><br><h3> BeanFactoryPostProcessor </h3><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BeanFactoryPostProcessor</a> ,      BeanDefinition'  ,    . ,      « Spring-». <br><br><img src="https://habrastorage.org/getpro/habr/post_images/459/cac/4c5/459cac4c50791a09e9195d53fe51b9e0.png"><br><br> ,      , –       AutowireCandidateResolver': <br><br><div class="spoiler"> <b class="spoiler_title">DecoratorAutowireCandidateResolverConfigurer.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecoratorAutowireCandidateResolverConfigurer</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeanFactoryPostProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postProcessBeanFactory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ConfigurableListableBeanFactory configurableListableBeanFactory)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> BeansException </span></span>{ Assert.state(configurableListableBeanFactory <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> DefaultListableBeanFactory, <span class="hljs-string"><span class="hljs-string">"BeanFactory needs to be a DefaultListableBeanFactory"</span></span>); val beanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory; beanFactory.setAutowireCandidateResolver( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DecoratorAutowireCandidateResolver(beanFactory.getAutowireCandidateResolver()) ); } }</code> </pre> <br></div></div><br><br><h3> DecoratorAutowireCandidateResolver </h3><br>       : <br><div class="spoiler"> <b class="spoiler_title">DecoratorAutowireCandidateResolver.java</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecoratorAutowireCandidateResolver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutowireCandidateResolver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> AutowireCandidateResolver resolver; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAutowireCandidate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> BeanDefinitionHolder bdHolder, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DependencyDescriptor descriptor)</span></span></span><span class="hljs-function"> </span></span>{ val dependentType = descriptor.getMember().getDeclaringClass(); val dependencyType = descriptor.getDependencyType(); val candidateBeanDefinition = (AbstractBeanDefinition) bdHolder.getBeanDefinition(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dependencyType.isAssignableFrom(dependentType)) { val candidateQualifier = candidateBeanDefinition.getQualifier(OrderQualifier.class.getTypeName()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidateQualifier != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependentType.getTypeName().equals(candidateQualifier.getAttribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>)); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> resolver.isAutowireCandidate(bdHolder, descriptor); }</code> </pre> <br></div></div><br>    descriptor'   (dependencyType)     (dependentType): <br><br><pre> <code class="java hljs">val dependentType = descriptor.getMember().getDeclaringClass(); val dependencyType = descriptor.getDependencyType();</code> </pre> <br>    bdHolder' BeanDefinition: <br><br><pre> <code class="java hljs">val candidateBeanDefinition = (AbstractBeanDefinition) bdHolder.getBeanDefinition();</code> </pre> <br>       .    ,     : <br><br><pre> <code class="java hljs">dependencyType.isAssignableFrom(dependentType)</code> </pre> <br>    ,      , ..      . <br><br>   BeanDefinition'       : <br><br><pre> <code class="java hljs">val candidateQualifier = candidateBeanDefinition.getQualifier(OrderQualifier.class.getTypeName());</code> </pre> <br>    ,         : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (candidateQualifier != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dependentType.getTypeName().equals(candidateQualifier.getAttribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>)); }</code> </pre> <br>    –     (),   –  false. <br><br><h3>    </h3><br><ul><li> ,           <a href="">ConfigurationClassBeanDefinitionReader</a> '; <br></li><li>              ,   BeanDefintion'    Qualifier'.                 ,      . <br></li></ul><br><h2>     </h2><br> ,          : <br><br><ul><li> Java Config –   ,  ,      ,        ; <br></li><li> <code>@Qualifier</code> –  ,      -       ; <br></li><li> Custom qualifier –   ,     Qualifier',   ; <br></li><li>     - – ,  ,     ,     . <br></li></ul><br><h2> 结论 </h2><br>  ,          ,     .           – :   .    ,               , ,  .    –   ,            JRE.     ,      ,   . <br><br>   ,      –  ,   ,        - . 感谢您的阅读！ <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有资源均可在以下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网址</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">https</font></a><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">//github.com/monosoul/spring-di-customization</font></a><font style="vertical-align: inherit;">。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN435364/">https://habr.com/ru/post/zh-CN435364/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN435352/index.html">DEFCON Conference 18.使用手机进行的间谍活动。 第二部分</a></li>
<li><a href="../zh-CN435354/index.html">DEFCON Conference 18.使用手机进行的间谍活动。 第一部分</a></li>
<li><a href="../zh-CN435358/index.html">上古：iPod时代的微型磁盘</a></li>
<li><a href="../zh-CN435360/index.html">片段vs三叶草-击败最受欢迎的实时测验</a></li>
<li><a href="../zh-CN435362/index.html">速度哈希</a></li>
<li><a href="../zh-CN435368/index.html">工作场所的病理解剖</a></li>
<li><a href="../zh-CN435372/index.html">关于MikroTik的FastPath和FastTrack的几句话</a></li>
<li><a href="../zh-CN435374/index.html">Gamedev中的数学很简单。 Unity中的Triangulation和Triangle.Net</a></li>
<li><a href="../zh-CN435376/index.html">2019年太空：载人飞船，新火箭和月球探测器</a></li>
<li><a href="../zh-CN435380/index.html">GitHub上的免费帐户将能够[几乎]不受限制地与私有存储库一起使用</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>