<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïû üçΩÔ∏è üíÄ Parte 1. QInst: √© melhor perder um dia e depois voar em cinco minutos (instrumentos de escrita s√£o triviais) üî∫ üêπ ü§≥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na parte anterior, descrevi mais ou menos como voc√™ pode carregar fun√ß√µes eBPF a partir de um arquivo ELF. Agora √© hora de passar da fantasia para os ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Parte 1. QInst: √© melhor perder um dia e depois voar em cinco minutos (instrumentos de escrita s√£o triviais)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452608/"><p>  Na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">parte anterior,</a> descrevi mais ou menos como voc√™ pode carregar fun√ß√µes eBPF a partir de um arquivo ELF.  Agora √© hora de passar da fantasia para os desenhos animados sovi√©ticos, e seguindo conselhos s√°bios, depois de gastar uma certa quantidade de esfor√ßo uma vez, fa√ßa uma ferramenta de instrumenta√ß√£o universal <del>  <em>(ou, em suma, UII !!!)</em> </del>  .  Ao fazer isso, aproveitarei o design antipadr√£o do Golden Hammer e construirei uma ferramenta a partir do relativamente familiar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">QEMU</a> .  Como um b√¥nus para isso, obtemos instrumenta√ß√£o entre arquiteturas e instrumenta√ß√£o no n√≠vel de todo o computador virtual.  A instrumenta√ß√£o ter√° a forma ‚Äúum pequeno arquivo-so nativo + um pequeno arquivo -o com eBPF‚Äù.  Nesse caso, as fun√ß√µes do eBPF ser√£o substitu√≠das antes das instru√ß√µes correspondentes da representa√ß√£o interna do QEMU antes da otimiza√ß√£o e gera√ß√£o de c√≥digo. </p><br><p> Como resultado, a pr√≥pria instrumenta√ß√£o, que √© <strong>adicionada durante a gera√ß√£o do c√≥digo</strong> (ou seja, sem contar alguns kilobytes de tempo de execu√ß√£o normal do sistema), fica assim, e esse <strong>n√£o</strong> √© <strong>um</strong> pseudoc√≥digo: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Bem, √© hora de carregar nosso elfo na Matrix.  Bem, como baixar, em vez <del>  bater </del>  spray. </p><a name="habracut"></a><br><p>  Como j√° mencionado no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo sobre o QEMU.js</a> , um dos modos de opera√ß√£o do QEMU √© a gera√ß√£o JIT do c√≥digo da m√°quina host do convidado (potencialmente, para uma arquitetura completamente diferente).  Se na √∫ltima vez em que implementei meu back-end de gera√ß√£o de c√≥digo, desta vez processarei a representa√ß√£o interna agindo diretamente na frente do otimizador.  Esta √© uma decis√£o arbitr√°ria?  N√£o.  H√° uma esperan√ßa de que o otimizador corte cantos em excesso, jogue vari√°veis ‚Äã‚Äãdesnecess√°rias etc.  Tanto quanto eu entendo, ele, de fato, faz coisas simples e rapidamente vi√°veis: empurrar constantes, lan√ßar express√µes como ‚Äúx: = x + 0‚Äù e excluir c√≥digo inacess√≠vel.  E podemos obter uma quantidade decente disso. </p><br><h1 id="konfiguraciya-sborochnyh-skriptov">  Configura√ß√£o de script de montagem </h1><br><p>  Primeiro, vamos adicionar nossos arquivos de origem: <code>tcg/bpf-loader.c</code> e <code>tcg/instrument.c</code> aos Makefiles.  De um modo geral, h√° um desejo de empurrar isso para a montante, ent√£o voc√™ precisar√° fazer isso no final com sabedoria, mas por enquanto apenas adicionarei esses arquivos incondicionalmente ao assembly.  E tomarei os par√¢metros nas melhores tradi√ß√µes da AFL - atrav√©s de vari√°veis ‚Äã‚Äãde ambiente.  A prop√≥sito, testarei isso novamente na instrumenta√ß√£o para AFL. </p><br><p>  Basta procurar pela men√ß√£o do "vizinho" - o arquivo <code>optimize.c</code> com <code>grep -R</code> e n√£o encontraremos nada.  Porque era necess√°rio procurar <code>optimize.o</code> : </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/Makefile.target +++ b/Makefile.target @@ -110,7 +110,7 @@ obj-y += trace/ obj-y += exec.o obj-y += accel/ obj-$(CONFIG_TCG) += tcg/tcg.o tcg/tcg-op.o tcg/tcg-op-vec.o tcg/tcg-op-gvec.o -obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o +obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o tcg/instrument.o tcg/bpf-loader.o obj-$(CONFIG_TCG_INTERPRETER) += tcg/tci.o obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o obj-$(CONFIG_TCG) += fpu/softfloat.o</span></span></code> </pre> <br><h1 id="tak-vot-ty-kakoe-metaprogrammirovanie-na-c">  Ent√£o aqui est√° voc√™, metaprograma√ß√£o em C ... </h1><br><p>  Primeiro, vamos adicionar o <code>bpf-loader.c</code> da √∫ltima s√©rie com o c√≥digo que extrai os pontos de entrada correspondentes √†s opera√ß√µes do QEMU.  E o misterioso arquivo <code>tcg-opc.h</code> nos ajudar√° com isso.  √â assim: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * DEF(name, oargs, iargs, cargs, flags) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* predefined ops */</span></span> DEF(discard, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TCG_OPF_NOT_PRESENT) DEF(set_label, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT) <span class="hljs-comment"><span class="hljs-comment">/* variable number of parameters */</span></span> DEF(call, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, TCG_OPF_CALL_CLOBBER | TCG_OPF_NOT_PRESENT) DEF(br, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END) <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Que bobagem?  E o problema √© simplesmente que ele n√£o est√° conectado no cabe√ßalho de origem - voc√™ precisa definir a macro <code>DEF</code> , incluir esse arquivo e excluir imediatamente a macro.  Veja, ele nem tem guarda. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inst_function_names[] = { #define DEF(name, a, b, c, d) stringify(inst_qemu_##name), #include <span class="hljs-string"><span class="hljs-string">"tcg-opc.h"</span></span> #undef DEF <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><p>  Como resultado, obtemos uma matriz clara de nomes de fun√ß√µes de destino, indexados por opcodes e terminando com NULL, que podemos executar para cada caractere no arquivo.  Eu entendo que isso n√£o √© eficaz.  Mas √© simples, o que √© importante, dada a natureza √∫nica dessa opera√ß√£o.  Em seguida, pulamos todos os caracteres para os quais </p><br><pre> <code class="cpp hljs">ELF64_ST_BIND(sym-&gt;st_info) == STB_LOCAL || ELF64_ST_TYPE(sym-&gt;st_info) != STT_FUNC</code> </pre> <br><p>  O restante √© verificado na lista. </p><br><h1 id="privyazyvaemsya-k-potoku-vypolneniya">  Estamos ligados a um fluxo de execu√ß√£o </h1><br><p>  Agora voc√™ precisa subir em algum lugar no encadeamento do mecanismo de gera√ß√£o de c√≥digo e aguardar at√© que a instru√ß√£o de interesse passe.  Mas primeiro voc√™ precisa definir suas fun√ß√µes <code>instrumentation_init</code> , <code>tcg_instrument</code> e <code>instrumentation_shutdown</code> no <code>tcg/tcg.h</code> e anote as chamadas: inicializa√ß√£o - ap√≥s a inicializa√ß√£o do backend, instrumenta√ß√£o - logo antes da chamada <code>tcg_optimize</code> .  Parece que <code>instrumentation_shutdown</code> pode ser pendurado em <code>instrumentation_init</code> no <code>atexit</code> e n√£o ser elevado.  Eu tamb√©m pensava assim, e provavelmente funcionar√° no modo de emula√ß√£o de sistema completo, mas no modo de emula√ß√£o de modo de usu√°rio, o QEMU traduz as chamadas do sistema <code>exit_group</code> e √†s vezes <code>exit</code> na chamada de fun√ß√£o <code>_exit</code> , que ignora todos esses manipuladores atexit, portanto, vamos encontr√°-lo em <code>linux-user/syscall.c</code> e <code>linux-user/syscall.c</code> chamada para o nosso c√≥digo na frente dele. </p><br><h1 id="interpretiruem-baytkod">  Interpretando Bytecode </h1><br><p>  Ent√£o √© hora de ler o que o compilador gerou para n√≥s.  Isso √© feito convenientemente usando <code>llvm-objdump</code> com a op√ß√£o <code>-x</code> , ou melhor, imediatamente <code>-d -t -r</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Exemplo de sa√≠da</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 inst_brcond_i64: 0: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000000: R_BPF_64_64 prev 2: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 3: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 4: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 5: af 13 00 00 00 00 00 00 r3 ^= r1 6: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 7: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 0000000000000038: R_BPF_64_64 __afl_area_ptr 9: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 10: 0f 34 00 00 00 00 00 00 r4 += r3 11: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 12: 07 03 00 00 01 00 00 00 r3 += 1 13: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 14: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 15: 95 00 00 00 00 00 00 00 exit 0000000000000080 inst_brcond_i32: 16: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000080: R_BPF_64_64 prev 18: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 19: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 20: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 21: af 13 00 00 00 00 00 00 r3 ^= r1 22: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 23: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 00000000000000b8: R_BPF_64_64 __afl_area_ptr 25: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 26: 0f 34 00 00 00 00 00 00 r4 += r3 27: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 28: 07 03 00 00 01 00 00 00 r3 += 1 29: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 30: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 31: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 *UND* 00000000 __afl_area_ptr 0000000000000080 g F .text 00000080 inst_brcond_i32 0000000000000000 g F .text 00000080 inst_brcond_i64 0000000000000008 g O *COM* 00000008 prev</code> </pre> </div></div><br><p>  Se voc√™ tentar procurar uma descri√ß√£o dos c√≥digos de opera√ß√£o do eBPF, descobrir√° que em locais √≥bvios (p√°ginas de origem e manual do kernel do Linux) h√° descri√ß√µes de como us√°-lo, como compilar etc.  Em seguida, voc√™ encontra a <a href="">p√°gina da</a> equipe de ferramentas do iovisor com uma refer√™ncia conveniente e n√£o oficial do eBPF. </p><br><p>  A instru√ß√£o ocupa uma palavra de 64 bits (algumas duas) e tem o formato </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p>  Aqueles que ocupam duas palavras consistem simplesmente na primeira instru√ß√£o com toda a l√≥gica e em um "trailer" com mais 32 bits de valor imediato e s√£o claramente vis√≠veis no desmontador de objdump. </p><br><p>  Os pr√≥prios c√≥digos de opera√ß√£o tamb√©m t√™m uma estrutura regular: os tr√™s bits inferiores s√£o a classe de opera√ß√£o: ALU de 32 bits, ALU de 64 bits, carga / armazenamento, ramifica√ß√£o condicional.  Portanto, √© muito conveniente implement√°-los em macros nas melhores tradi√ß√µes do QEMU.  N√£o conduzirei instru√ß√µes detalhadas na base de c√≥digo <del>  n√£o estamos na revis√£o de c√≥digo </del>  √â melhor falar sobre as armadilhas. </p><br><p>  Meu primeiro problema foi que criei um alocador de registro lento do eBPF na forma de QEMU- <code>local_temp</code> e comecei a transferir, sem pensar, a chamada dessa fun√ß√£o para a macro.  Acabou como em um meme famoso: "Inserimos uma abstra√ß√£o em uma abstra√ß√£o para que voc√™ possa gerar uma instru√ß√£o enquanto gera uma instru√ß√£o".  P√≥s-factum, eu j√° n√£o entendi muito bem o que estava quebrado, mas algo estranho estava aparentemente acontecendo com a ordem das instru√ß√µes geradas.  Depois disso, fiz an√°logos das fun√ß√µes <code>tcg_gen_...</code> para <code>tcg_gen_...</code> novas instru√ß√µes no meio da lista, levando operandos como argumentos para a fun√ß√£o e a ordem tornou-se automaticamente como deveria (j√° que os argumentos s√£o completamente calculados exatamente uma vez antes da chamada). </p><br><p>  O segundo problema foi tentar empinar o TCG const como o operando de uma instru√ß√£o arbitr√°ria ao ver o operando imediato no eBPF.  Solicitando o <code>tcg-opc.h</code> j√° mencionado, a composi√ß√£o da lista de argumentos da opera√ß√£o √© estritamente fixa: <code>n</code> argumentos de entrada, <code>m</code> sa√≠da e constante <code>k</code> .  A prop√≥sito, ao depurar esse c√≥digo, ajuda a transmitir ao QEMU o argumento da linha de comandos <code>-d op,op_opt</code> ou mesmo <code>-d op,op_opt,out_asm</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Poss√≠veis argumentos</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./x86_64-linux-user/qemu-x86_64 -d help Log items (comma separated): out_asm show generated host assembly code for each compiled TB in_asm show target assembly code for each compiled TB op show micro ops for each compiled TB op_opt show micro ops after optimization op_ind show micro ops before indirect lowering int show interrupts/exceptions in short format exec show trace before each executed TB (lots of logs) cpu show CPU registers before entering a TB (lots of logs) fpu include FPU registers in the 'cpu' logging mmu log MMU-related activities pcall x86 only: show protected mode far calls/returns/exceptions cpu_reset show CPU state before CPU resets unimp log unimplemented functionality guest_errors log when the guest OS does something invalid (eg accessing a non-existent register) page dump pages at beginning of user mode emulation nochain do not chain compiled TBs so that "exec" and "cpu" show complete traces trace:PATTERN enable trace events Use "-d trace:help" to get a list of trace events.</code> </pre> </div></div><br><p>  Bem, n√£o repita meus erros: o desmontador de instru√ß√µes internas √© bastante avan√ßado e, se voc√™ <code>add_i64 loc15,loc15,$554412123213</code> algo como <code>add_i64 loc15,loc15,$554412123213</code> , esse <code>add_i64 loc15,loc15,$554412123213</code> depois do cifr√£o n√£o √© um ponteiro.  Mais precisamente, √© claro que isso √© um ponteiro, mas talvez pendurado com bandeiras e no papel do valor literal do operando, e n√£o do ponteiro.  Tudo isso se aplica, √© claro, se voc√™ sabe que deve haver um n√∫mero espec√≠fico, como <code>$0</code> ou <code>$ff</code> , n√£o precisa ter medo de indicadores.  :) Como <code>movi</code> com isso - voc√™ s√≥ precisa criar uma fun√ß√£o que retorne uma nova <code>temp</code> , na qual, por meio do <code>movi</code> coloque a constante desejada. </p><br><p>  A prop√≥sito, se voc√™ comentar <code>#define USE_TCG_OPTIMIZATIONS</code> no <code>#define USE_TCG_OPTIMIZATIONS</code> <code>tcg/tcg.c</code> , subitamente a otimiza√ß√£o ser√° desativada e ser√° mais f√°cil analisar as transforma√ß√µes de c√≥digo. </p><br><p>  Para sim, enviarei um leitor interessado em escolher o QEMU na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> , mesmo a oficial!  Quanto ao resto, demonstrarei a instrumenta√ß√£o prometida para a AFL. </p><br><h1 id="te-zhe-i-krolik">  O mesmo e o coelho </h1><br><p>  Para o texto completo do tempo de execu√ß√£o, eu, novamente, enviarei o leitor para o reposit√≥rio, uma vez que (o texto) n√£o tem valor art√≠stico e √© honestamente <code>qemu_mode</code> de <code>qemu_mode</code> da entrega da AFL e, em geral, √© uma parte regular do c√≥digo C. Mas aqui est√° como a pr√≥pria instrumenta√ß√£o se parece. : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  √â importante que as fun√ß√µes de gancho tenham tantos argumentos quanto <code>iargs</code> para a opera√ß√£o QEMU correspondente.  Duas <code>extern</code> no cabe√ßalho ser√£o vinculadas ao tempo de execu√ß√£o durante o processo de realoca√ß√£o.  Em princ√≠pio, <code>prev</code> pode ser definido aqui, mas precisa ser definido como <code>static</code> ; caso contr√°rio, cair√° na se√ß√£o COMUM que eu n√£o apoio.  Na verdade, n√≥s simplesmente reescrevemos o pseudo-c√≥digo da documenta√ß√£o, mas aqui √© leg√≠vel por m√°quina! </p><br><p>  Para verificar, crie o arquivo <code>bug.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char buf[16]; int res = read(0, buf, 4); if (buf[0] == 'T' &amp;&amp; buf[1] == 'E' &amp;&amp; buf[2] == 'S' &amp;&amp; buf[3] == 'T') abort(); return res * 0; }</span></span></span></span></code> </pre> <br><p>  E tamb√©m - arquivo <code>forksrv</code> , que √© conveniente para alimentar o AFL: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash export NATIVE_INST=./instrumentation-examples/afl/afl-native.so export BPF_INST=./instrumentation-examples/afl/afl-bpf.co exec ./x86_64-linux-user/qemu-x86_64 ./instrumentation-examples/afl/bug</span></span></code> </pre> <br><p>  E execute fuzzing: </p><br><pre> <code class="bash hljs">AFL_SKIP_BIN_CHECK=1 afl-fuzz -i ../input -o ../output -m none -- ./forksrv</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">American Fuzzy Lop</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1234 T234 TE34 TES4 TEST &lt;-     crashes,    2200  </code> </pre> </div></div><br><p>  At√© agora, a velocidade n√£o √© t√£o alta, mas como desculpa, direi que aqui (por enquanto) um recurso importante do <code>qemu_mode</code> original n√£o <code>qemu_mode</code> usado: o envio de endere√ßos de c√≥digo execut√°vel para o servidor fork.  Mas n√£o h√° nada AFL na base de c√≥digo QEMU agora, e h√° esperan√ßa de que esta instrumenta√ß√£o generalizada um dia seja amontoada no fluxo de dados. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Projeto GitHub</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt452608/">https://habr.com/ru/post/pt452608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt452592/index.html">Parte 0. Requer que um elfo trabalhe na Matrix. √â poss√≠vel realocar</a></li>
<li><a href="../pt452596/index.html">735.000 endere√ßos IPv4 foram retirados de um scammer e retornados ao registro</a></li>
<li><a href="../pt452598/index.html">Gerenciamento de uma equipe de programadores: como e como motiv√°-los corretamente? Parte um</a></li>
<li><a href="../pt452602/index.html">Cisco Hyperflex para sistemas de gerenciamento de banco de dados de alta carga</a></li>
<li><a href="../pt452606/index.html">UDB. O que √© isso? Parte 8. Endere√ßando UDB</a></li>
<li><a href="../pt452610/index.html">Ajuda e pedido para ela. Artigo sobre seguran√ßa da informa√ß√£o para usu√°rios comuns</a></li>
<li><a href="../pt452612/index.html">Aprendizado de m√°quina de rede neural profunda refor√ßada no tensorflow.js: truques</a></li>
<li><a href="../pt452614/index.html">Como iniciar a programa√ß√£o no Adobe Illustrator. Parte dois</a></li>
<li><a href="../pt452618/index.html">O que foi dito no Google I / O 2019: Android 10, aplicativos AR e muito mais</a></li>
<li><a href="../pt452620/index.html">Derivando um tipo de a√ß√£o usando o Typecript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>