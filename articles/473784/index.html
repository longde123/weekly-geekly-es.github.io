<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏽 🥕 🐸 ¿Cómo escribir un contrato inteligente para WebAssembly en una red Ontology? Parte 2: C ++ ㊗️ 😵 〽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este artículo, veremos dos ejemplos de cómo escribir un contrato inteligente en C ++ usando WASM basado en la red blockchain de Ontology. Hoy, desp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Cómo escribir un contrato inteligente para WebAssembly en una red Ontology? Parte 2: C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/473784/"><img src="https://habrastorage.org/getpro/habr/post_images/3e1/ec5/4dd/3e1ec54ddc0f1d35cad05f7f2b6e600e.png" alt="imagen"><br><br>  En este artículo, veremos dos ejemplos de cómo escribir un contrato inteligente en C ++ usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">WASM</a> basado en la red blockchain de Ontology.  Hoy, después de varios meses de operación estable en modo de prueba, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ontology lanzó WASM</a> en la red principal, lo que permite transferir contratos dApp con lógica empresarial compleja a la cadena de bloques sin dolor y a un costo menor, lo que enriquece significativamente el ecosistema dApp. <br><br>  Ontology Wasm también admite la creación de contratos inteligentes en el lenguaje Rust, puede leer sobre esto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . <br><br>  A continuación hay dos ejemplos de un contrato inteligente: primero, escriba "¡Hola, mundo!"  y luego cree un sobre de dinero virtual que se pueda enviar a un amigo como regalo. <br><br><h2>  Desarrollo de un contrato WASM usando C ++ </h2><br><a name="habracut"></a><br><h3>  Ejemplo 1. Hola mundo </h3><br>  Comencemos con Hello World: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; #include&lt;stdio.h&gt; using namespace ontio; class hello:public contract { public: using contract::contract: void sayHello(){ printf("hello world!"); } }; ONTIO_DISPATCH(hello, (sayHello));</span></span></span></span></code> </pre> <br><h3>  Creación de contrato </h3><br>  El compilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CDT de Ontology Wasm</a> contiene un punto de entrada y parámetros de análisis, por lo que los desarrolladores no necesitan redefinir los métodos de entrada.  Además, para escribir la lógica del servicio, puede llamar a los métodos API del contrato inteligente. <br><br><pre> <code class="cpp hljs">ONTIO_DISPATCH(hello, (sayHello));</code> </pre> <br>  En el ejemplo anterior, solo admitimos sayHello hasta ahora: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"hello world!"</span></span>);</code> </pre> <br>  "¡Hola mundo!"  se mostrará en el registro del nodo de depuración.  Al escribir un contrato inteligente directamente, printf solo se puede usar para depurar, ya que el contrato inteligente en sí contiene más comandos funcionales. <br><br><h3>  API de contrato inteligente </h3><br>  Ontology Wasm proporciona las siguientes API para interactuar con la cadena de bloques del servidor: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d29/dad/66d/d29dad66d40c938e872179cc3487172e.png" alt="imagen"><br><br><h2>  Ejemplo 2: sobre de dinero </h2><br>  Ahora veamos un ejemplo más complejo utilizando la API de contrato inteligente de Wasm. <br><br>  En este ejemplo, escribiremos un sobre de dinero virtual, un análogo del sobre rojo (hongbao) es una característica popular del mensajero chino Wechat, que le permite enviar dinero a amigos en un chat.  El usuario recibe un mensaje en forma de sobre rojo, lo abre y el dinero se acredita automáticamente al saldo de la cuenta. <br><br>  Como parte de un contrato inteligente, los usuarios pueden usar este contrato para enviar tokens ONT, ONG u OEP-4 usando sobres de dinero virtual a sus amigos, quienes luego pueden transferir tokens a sus billeteras blockchain. <br><br><h3>  Preparando para crear un contrato </h3><br>  Primero, cree el archivo del contrato fuente y asígnele el nombre redEnvelope.cpp.  A continuación, necesitamos tres API para este contrato: <br><br><ul><li>  <i>createRedEnvelope</i> : <i>crea</i> un sobre de dinero </li><li>  <i>queryEnvelope</i> : solicita información sobre </li><li>  <i>ClaimEnvelope</i> : abra un sobre y reciba dinero </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ontiolib/ontio.hpp&gt; using namespace ontio; class redEnvlope: public contract{ } ONTIO_DISPATCH(redEnvlope, (createRedEnvlope)(queryEnvlope)(claimEnvelope));</span></span></span></span></code> </pre> <br>  Ahora necesitamos guardar la clave-valor.  En un contrato inteligente, los datos se almacenan en el contexto del contrato como un valor clave, y necesitamos agregar un prefijo a los datos CLAVE para una solicitud posterior. <br><br>  A continuación definimos tres prefijos que utilizaremos: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> rePrefix = <span class="hljs-string"><span class="hljs-string">"RE_PREFIX_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> sentPrefix = <span class="hljs-string"><span class="hljs-string">"SENT_COUNT_"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> claimPrefix = <span class="hljs-string"><span class="hljs-string">"CLAIM_PREFIX_"</span></span>;</code> </pre><br>  Dado que el contrato es compatible con los tokens Ontology: ONT y ONG, podemos determinar la dirección de su contrato por adelantado.  A diferencia de un contrato inteligente estándar, la dirección del contrato de Ontology es fija y no se deriva del hash del contrato. <br><br><pre> <code class="cpp hljs">address ONTAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; address ONGAddress = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>};</code> </pre> <br>  A continuación, debe guardar información sobre el token utilizado en el contrato: la dirección del token del contrato, la cantidad total del sobre y la cantidad de sobres. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class">{</span></span> address account; <span class="hljs-comment"><span class="hljs-comment">//User address asset amount; //Received amount ONTLIB_SERIALIZE(receiveRecord,(account)(amount)) }; struct envlopeStruct{ address tokenAddress; //Token asset address asset totalAmount; //Total amount asset totalPackageCount; //Total number of red envelope asset remainAmount; //Remaining amount asset remainPackageCount; //Remaining number of red envelope std::vector&lt;struct receiveRecord&gt; records; //Received records ONTLIB_SERIALIZE( envlopeStruct, (tokenAddress)(totalAmount)(totalPackageCount)(remainAmount)(remainPackageCount)(records) ) };</span></span></code> </pre> <br>  La siguiente es la operación de macro definida por Ontology Wasm CDT, que se utiliza para la serialización antes de la estructuración de datos. <br><br><pre> <code class="cpp hljs">ONTLIB_SERIALIZE(receiveRecord,(account)(amount))</code> </pre> <br><h3>  Crear un sobre </h3><br>  Ahora que hemos completado los preparativos necesarios, comenzaremos el desarrollo de la lógica API. <br><br>  1. Al crear un sobre de dinero, es necesario indicar la dirección del propietario, el número y la cantidad de sobres, así como la dirección del token: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createRedEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address owner,asset packcount, asset amount,address tokenAddr )</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2. Verifique la firma del propietario; de lo contrario, revertiremos (revertiremos la transacción) y saldremos: <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(owner),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>);</code> </pre> <br>  <i>Nota</i> : ontio_assert (expr, errormsg): false expr devuelve un error y sale del contrato. <br><br>  3. Si se utiliza un token ONT en un sobre, es importante recordar que ONT no está fragmentado (al menos 1 ONT).  Entonces, la cantidad total del sobre de dinero debe ser mayor o igual que la cantidad de tokens para garantizar que haya al menos 1 ONT en cada sobre: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ ontio_assert(amount &gt;= packcount,<span class="hljs-string"><span class="hljs-string">"ont amount should greater than packcount"</span></span>); }</code> </pre> <br>  4. A continuación, determinamos para el titular del sobre el número total de sobres de dinero que envía: <br><br><pre> <code class="cpp hljs">key sentkey = make_key(sentPrefix,owner.tohexstring()); asset sentcount = <span class="hljs-number"><span class="hljs-number">0</span></span>; storage_get(sentkey,sentcount); sentcount += <span class="hljs-number"><span class="hljs-number">1</span></span>; storage_put(sentkey,sentcount);</code> </pre> <br>  5. Genere el hash del sobre: ​​el identificador que marca este sobre: <br><br><pre> <code class="cpp hljs">H256 hash ; hash256(make_key(owner,sentcount),hash) ; key rekey = make_key(rePrefix,hash256ToHexstring(hash));</code> </pre> <br>  6. Traduciremos los tokens al contrato.  Descubrimos la dirección del contrato que se está ejecutando actualmente usando el comando self_address (), luego transferiremos la cantidad asignada de tokens al contrato en función del tipo de tokens: <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(tokenAddr)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(owner,selfaddr ,amount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer native token failed!"</span></span>); }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),owner,selfaddr,amount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res; call_contract(tokenAddr,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  <u>Nota 1:</u> para ONT y ONG, Ontology Wasm CDT proporciona la API ont :: transfer para transferir tokens;  Los tokens OEP-4 deben enviarse utilizando el método convencional de llamada de contrato cruzado. <br><br>  <u>Nota 2:</u> como una dirección de billetera normal, la dirección del contrato puede aceptar cualquier tipo de token.  Sin embargo, la dirección del contrato se genera mediante un hash binario compilado y, por lo tanto, no tiene una clave privada correspondiente y no puede usar tokens de contrato.  Si no ha configurado una clave privada, no podrá administrar estos tokens. <br><br>  7. Guarde la información sobre el contrato en el almacén de datos: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class"> ;</span></span> es.tokenAddress = tokenAddr; es.totalAmount = amount; es.totalPackageCount = packcount; es.remainAmount = amount; es.remainPackageCount = packcount; es.records = {}; storage_put(rekey, es);</code> </pre> <br>  8. Envíe una notificación sobre la creación del sobre.  Este es un proceso asincrónico para invocar un contrato inteligente, el contrato también enviará una notificación del resultado de la ejecución.  El autor del contrato puede determinar el formato de ejecución. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\", \"%s\", \"%s\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"createEnvlope"</span></span>,owner.tohexstring().c_str(),hash256ToHexstring(hash).c_str()); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre> <br>  Hurra, el sobre del dinero está casi listo.  Ahora veamos cómo solicitar información sobre. <br><br><h3>  Sobre de consulta (consulta </h3><br>  La lógica de la solicitud es bastante simple, solo necesita obtener la información y el formato del almacén de datos y luego generar: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">queryEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> formatEnvlope(es); }</code> </pre> <br>  <u>Nota:</u> para operaciones de contrato inteligente de solo lectura (por ejemplo, consulta), puede verificar el resultado a través de pre-exec.  A diferencia de una llamada de contrato regular, pre-exec no requiere una firma de billetera y, por lo tanto, no requiere una comisión en ONG.  Una vez hecho esto, otros usuarios ahora pueden solicitar el sobre si tienen un hash de sobre (ID de sobre). <br><br><h3>  Recibiendo Sobre </h3><br>  En esta etapa, ya hemos transferido los tokens a un contrato inteligente, ahora, para que tus amigos puedan reclamar con éxito una parte del sobre, debes enviarles el identificador del sobre (hash). <br><br>  1. Para recibir un sobre, debe ingresar la dirección de su cuenta y el hash del sobre: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">claimEnvlope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address account, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hash)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  2. Luego, el contrato verificará la firma de su cuenta para asegurarse de que usted sea el propietario.  Cada cuenta puede solicitar un sobre solo una vez: <br><br><pre> <code class="cpp hljs">ontio_assert(check_witness(account),<span class="hljs-string"><span class="hljs-string">"checkwitness failed"</span></span>); key claimkey = make_key(claimPrefix,hash,account); asset claimed = <span class="hljs-number"><span class="hljs-number">0</span></span> ; storage_get(claimkey,claimed); ontio_assert(claimed == <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-string"><span class="hljs-string">"you have claimed this envlope!"</span></span>);</code> </pre><br>  3. Compruebe si el sobre se recibe de acuerdo con la información hash recibida de la tienda: <br><br><pre> <code class="cpp hljs">key rekey = make_key(rePrefix,hash); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">envlopeStruct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">es</span></span></span><span class="hljs-class">;</span></span> storage_get(rekey,es); ontio_assert(es.remainAmount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>); ontio_assert(es.remainPackageCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"the envlope has been claimed over!"</span></span>);</code> </pre> <br>  4. Crear un registro de reclamo: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">receiveRecord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">record</span></span></span><span class="hljs-class"> ;</span></span> record.account = account; asset claimAmount = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  5. Cálculo del importe de cada sobre solicitante. <br>  Para el último participante, se determina el monto del resto, para cualquier otro, el monto declarado se determina mediante un número aleatorio calculado por el hash del bloque actual y la información del sobre actual: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (es.remainPackageCount == <span class="hljs-number"><span class="hljs-number">1</span></span>){ claimAmount = es.remainAmount; record.amount = claimAmount; }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ H256 random = current_blockhash() ; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> part[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(part,&amp;random,<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> random_num = *(<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>*)part; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> percent = random_num % <span class="hljs-number"><span class="hljs-number">100</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; claimAmount = es.remainAmount * percent / <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-comment"><span class="hljs-comment">//ont case if (claimAmount == 0){ claimAmount = 1; }else if(isONTToken(es.tokenAddress)){ if ( (es.remainAmount - claimAmount) &lt; (es.remainPackageCount - 1)){ claimAmount = es.remainAmount - es.remainPackageCount + 1; } } record.amount = claimAmount; } es.remainAmount -= claimAmount; es.remainPackageCount -= 1; es.records.push_back(record);</span></span></code> </pre> <br><h3>  6. Fondos de crédito </h3><br>  La cantidad correspondiente de tokens se transfiere a la cuenta de los solicitantes de sobres de acuerdo con el resultado del cálculo: <br><br><pre> <code class="cpp hljs">address selfaddr = self_address(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONTToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ont::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ont token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isONGToken(es.tokenAddress)){ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ong::transfer(selfaddr,account ,claimAmount); ontio_assert(result,<span class="hljs-string"><span class="hljs-string">"transfer ong token failed!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; params = pack(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(<span class="hljs-string"><span class="hljs-string">"transfer"</span></span>),selfaddr,account,claimAmount); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> res = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; call_contract(es.tokenAddress,params, res ); ontio_assert(res,<span class="hljs-string"><span class="hljs-string">"transfer oep4 token failed!"</span></span>); }</code> </pre><br>  7. Anotaremos información sobre la recepción de fondos e información actualizada sobre el sobre en la bóveda y enviaremos una notificación sobre el cumplimiento del contrato: <br><br><pre> <code class="cpp hljs">storage_put(claimkey,claimAmount); storage_put(rekey,es); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer [<span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"{\"states\":[\"%s\",\"%s\",\"%s\",\"%lld\"]}"</span></span>,<span class="hljs-string"><span class="hljs-string">"claimEnvlope"</span></span>,hash.c_str(),account.tohexstring().c_str(),claimAmount); notify(buffer); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Como se mencionó anteriormente, este contrato puede enviar tokens desde el contrato a través de la API ClaimEnvelope.  Esto garantiza la seguridad de los tokens mientras están en el sobre, ya que nadie puede retirar activos sin cumplir los requisitos necesarios. <br><br>  Hecho  Escribiste tu primer contrato inteligente.  El código completo del contrato se puede encontrar en GitHub <a href="">aquí</a> . <br><br><h3>  Prueba de contrato </h3><br>  Hay dos formas de verificar un contrato: <br><br><ol><li>  Use <a href="">CLI</a> </li><li>  Use el <a href="">SDK de Golang</a> </li></ol><br><h2>  Conclusión </h2><br>  En este artículo, hablamos sobre cómo escribir un contrato inteligente para Ontolgy Wasm usando la API blockchain.  Queda por resolver el problema de privacidad para que el contrato inteligente se convierta en un producto completo.  En esta etapa del código, cualquiera puede obtener un hash del sobre rojo al rastrear los registros del contrato, lo que significa que cualquiera puede reclamar una parte del sobre.  Este problema se puede resolver simplemente: definimos una lista de cuentas que pueden solicitar un sobre cuando se crea.  Si lo desea, esta función también se puede probar. <br><br><hr><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Obtenga una subvención de</a> Ontología para el desarrollo de dApp de $ 20,000 <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Solicite el</a> Programa de Talento Estudiantil de Ontología <br><br><hr><br>  ¿Eres desarrollador?  Únete a nuestra comunidad tecnológica en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Discord</a> .  Además, eche un vistazo al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Centro de desarrolladores</a> en nuestro sitio web, donde puede encontrar herramientas para desarrolladores, documentación y mucho más. <br><br><h4>  Ontología </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sitio web de ontología</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Github</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discordia</a> </li><li>  Telegram <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Inglés</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ruso</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Twitter</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Reddit</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473784/">https://habr.com/ru/post/473784/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473770/index.html">Análisis estático de grandes volúmenes de código Python: experiencia de Instagram. Parte 2</a></li>
<li><a href="../473774/index.html">Secure Cloud en DF Cloud</a></li>
<li><a href="../473776/index.html">Unificación de reglas de validación por el ejemplo de Asp core + VueJS</a></li>
<li><a href="../473778/index.html">Optimización de imagen: cómo usar la IA de visión de Google para comprender los principios de clasificación de imágenes</a></li>
<li><a href="../473780/index.html">Detección rápida de contornos en video 4K: color y formas complejas</a></li>
<li><a href="../473786/index.html">La inscripción para el hackathon en Riga está terminando. Premio - entrenamiento a corto plazo en el PhysTech</a></li>
<li><a href="../473788/index.html">Las microproteínas descubren aspectos desconocidos de la biología moderna.</a></li>
<li><a href="../473790/index.html">Splines en gráficos 3D, la opción más automatizada</a></li>
<li><a href="../473794/index.html">Phishing móvil: amenazas infinitas</a></li>
<li><a href="../473796/index.html">Extensor óptico HDMI. 300 metros</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>