<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🍳 👩🏼‍🤝‍👨🏻 🧑🏽‍🤝‍🧑🏽 提早提示加速网站 ⚠️ 🚵🏽 ❄️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="网站仍然加载太慢。 在下载过程的最关键时刻，通道通常几乎完全处于空闲状态。 工程师Kazuho Oku提出的Fastly新技术将有助于更好地利用这一关键的前几秒钟。 

 您是否曾经在手机上下载过网站-并在没有文字的页面上浏览了10秒钟？ 在加载一些不寻常的字体时，没有人喜欢坐在空白屏幕上看。 因此...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>提早提示加速网站</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/421059/">网站仍然加载太慢。 在下载过程的最关键时刻，通道通常几乎完全处于空闲状态。 工程师Kazuho Oku提出的Fastly新技术将有助于更好地利用这一关键的前几秒钟。 <br><br> 您是否曾经在手机上下载过网站-并在没有文字的页面上浏览了10秒钟？ 在加载一些不寻常的字体时，没有人喜欢坐在空白屏幕上看。 因此，将此类重要事物的负载转移到最早可能的时间是有意义的。 预载<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接rel = preload</a>可以部分解决问题。 首先，浏览器解析HTTP标头，因此这是指向预加载以后肯定需要的资源的理想位置。 <br><a name="habracut"></a><br><h1> 默认情况下，互联网速度很慢 </h1><br> 让我们看看如果不使用预加载会发生什么。 浏览器只能在发现需要资源后才能开始加载资源。 对于文档的初始解析期间HTML中的资源（例如， <code>&lt;script&gt;</code> ， <code>&lt;link rel=stylesheet&gt;</code>和<code>&lt;img&gt;</code> ），这种情况最有可能发生。 <br><br> 构建渲染树后检测到的资源下载速度较慢（这是页面由于加载字体而变慢的地方，因为要理解这一点，您首先需要加载样式表，解析它，构建CSS对象模型，然后再渲染树）。 <br><br> 加载速度更慢的是使用由<code>DOMContentLoaded</code>类的事件触发的JavaScript加载器将资源添加到文档中。 如果将所有内容放在一起，我们会得到一个未经优化且毫无意义的瀑布。 大多数情况下，通道处于空闲状态，并且资源加载早于必要时间或太晚： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e8a/cb5/705/e8acb5705ec028771d0426c9e16b8635.png"><br><br><h1> 链接rel =预加载有很大帮助 </h1><br> 在过去的几年中，由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Link rel = preload</a> ，情况有所改善。 例如： <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">Link:</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/resources/fonts</span></span><span class="hljs-regexp"><span class="hljs-regexp">/myfont.woff&gt;; rel=preload; as=font; crossorigin Link: &lt;/resources</span></span><span class="hljs-regexp"><span class="hljs-regexp">/css/something</span></span>.css&gt;; rel=preload; as=style <span class="hljs-symbol"><span class="hljs-symbol">Link:</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/resources/js</span></span><span class="hljs-regexp"><span class="hljs-regexp">/main.js&gt;; rel=preload; as=script</span></span></code> </pre> <br> 由于有了这些指令，浏览器可以在接收到标头之后以及开始分析HTML主体之前立即开始加载资源： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/54c/fe2/727/54cfe2727bf9fdbb286acf29c173885b.png"><br><br> 这是一个重大的改进，尤其是对于大页面和关键资源（否则会发现得太晚）。 特别是对于字体，但是任何东西都可以成为关键资源，例如加载JavaScript应用程序所需的数据文件。 <br><br> 但是，我们可以做的更多。 毕竟，浏览器在完成发送请求的那一刻到接收到响应的第一个字节之间（从初始请求开始，绿色的较大片段较高）之间什么都不做。 <br><br><h1> 我们在“早期技巧”的帮助下使用“服务器思考”的时间 </h1><br> 另一方面，服务器确实很忙。 它生成一个响应并确定它是否成功。 访问数据库后，将进行API调用，身份验证等。 服务器可能会确定404错误是正确的答案。 <br><br> 有时服务器的冥想时间少于网络等待时间。 有时明显更多。 但重要的是要了解它们不会重叠。 当服务器在思考时，我们没有在向客户端发送数据。 <br><br> 但有趣的是，甚至在生成答案之前，您就已经知道了需要下载一些样式和字体才能显示页面。 毕竟，错误页面通常使用与常规页面相同的公司标识和设计。 最好<b>在服务器工作之前</b>发送这些<code>Link: rel=preload</code> 。 这就是HTTP工作组在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=http://">RFC8297中</a>构思的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://tools.ietf.org/html/draft-ietf-">Early Hints</a>标准由我的同事Kazuho Oku快速创建的原因。  <i>在一个答案中</i>评估<i>多个状态栏</i>的魔力： <br><br><pre> <code class="hljs pgsql">HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">103</span></span> Early Hints Link: &lt;<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-font-face.woff2&gt;; rel="preload"; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>="font"; crossorigin Link: &lt;main-styles.css&gt;; rel="preload"; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>="style" HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Found</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>: Fri, <span class="hljs-number"><span class="hljs-number">26</span></span> May <span class="hljs-number"><span class="hljs-number">2017</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">02</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> GMT Content-Length: <span class="hljs-number"><span class="hljs-number">1234</span></span> Content-<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>: <span class="hljs-type"><span class="hljs-type">text</span></span>/html; charset=utf<span class="hljs-number"><span class="hljs-number">-8</span></span> Link: &lt;<span class="hljs-keyword"><span class="hljs-keyword">some</span></span>-font-face.woff2&gt;; rel="preload"; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>="font"; crossorigin Link: &lt;main-styles.css&gt;; rel="preload"; <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>="style"</code> </pre> <br> 服务器可以在收到请求后立即记录第一个所谓的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“信息”响应代码</a> ，并将其发送到网络。 然后，他将处理一个真实反应及其产生的定义。 同时，在浏览器中，您可以更早地开始预加载： <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d9b/8ca/1cb/d9b8ca1cbb8fd4753bd037893ea92d1b.png"><br><br> 当然，这将需要对浏览器，服务器和CDN的操作进行某些更改，并且某些浏览器的开发人员对实现的困难表示了保留。 因此，尚不清楚何时可以运行这些标头。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Chrome</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Firefox的</a>公共跟踪器中跟踪进度。 <br><br> 我们希望最终，您将能够直接从Fastly发出Early Hints标头，而仍以标准方式发送请求。 我们尚未决定如何通过VCL设置界面，因此，如果您对此主题有任何希望，请告诉我！ <br><br><h1> 但是HTTP / 2 Server Push呢？ </h1><br> 使用HTTP / 2，有一种称为“服务器推送”的新技术似乎可以解决与“早期提示”答案中的Link rel = preload相同的问题。 尽管它确实有效（并且您甚至可以在Fastly中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.fastly.com/guides/performance-tuning/">从边缘服务器</a>快速生成<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://docs.fastly.com/guides/performance-tuning/">自定义推送</a> ），但在以下几点上仍存在重大差异： <br><br><ul><li> 服务器不知道客户端上资源的可用性，因此通常会不必要地推送资源。 由于网络缓冲和延迟，客户端通常无法在接收所有内容之前取消发送。  （尽管可以通过建议的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://tools.ietf.org/html/draft-ietf-">Cache Digest</a>标题的形式来解决此问题，但Kazuho正在与Akamai的Joam Weiss合作。） </li><li> 流式传输的资源与连接相关联，因此可以轻松启动客户端不使用的资源，因为它正尝试通过另一个连接获取资源。 客户端可能需要使用不同的连接，因为该资源位于具有不同TLS证书的不同来源中，或者因为该资源是以不同的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">凭证模式进行</a>检索的。 </li><li>  H2 Push在不同的浏览器中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">并不是很一致地实现</a> 。 因此，很难预测在您的特定情况下它是否会起作用。 </li></ul><br> 早期提示和服务器推送以一种或多种方式提供不同的权衡。 早期提示可以更有效地利用网络来交换其他数据包。 如果您希望网络延迟很短并且需要花费很长时间来考虑服务器，那么Early Hints是正确的解决方案。 <br><br> 但是，并非总是如此。 让我们乐观一点，想象人们很快就会安定在火星上。 对于每次交换软件包，他们将以20-45分钟的延迟浏览网络，因此额外的交换非常痛苦，与之相比，服务器时间可以忽略不计。 服务器推送在这里轻松获胜。 但是，如果我们看过火星的网页，就更有可能下​​载某种数据包，例如现在提供并<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://tools.ietf.org/id/draft-yasskin-">签署了交易的</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Web包</a> 。 <br><br><h1> 额外奖金：更快的请求崩溃 </h1><br> 尽管“早期提示”应该主要在浏览器中使用，但CDN有一个有趣的潜在好处。 当快速收到许多对同一资源的请求时，我们通常仅将其中一个发送到源，然后将其余请求放入等待队列。 此过程称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请求崩溃</a> 。 如果来自源的响应包括<code>Cache-Control: private</code> ，那么您应该从队列中删除所有请求并将它们分别发送到源，因为我们不能使用一个答案来满足多个请求。 <br><br> 在收到对第一个请求的响应之前，我们无法做出决定，但是在支持Early Hints的情况下，如果服务器以Cache-Control标题返回了Early Hints响应，我们将更早地知道队列无法折叠为单个请求，而是立即将所有请求从队列转发到源。 <br><br><h1> 使用优先提示订购不太重要的内容 </h1><br> 早期技巧是访问队列中一些最有价值的对象的好方法（瀑布）：当网络空闲时，用户等待，路上只有一个请求，而屏幕上没有任何内容。 但是，一旦加载HTML并分析了页面，则需要加载的资源数量将急剧增加。 现在重要的是不要尽快加载资源，而要以正确的顺序加载它们。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">浏览器使用令人惊讶的复杂启发式数组</a>来独立确定下载的优先级，但是如果您要重新定义它们，那么将来可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">优先级提示</a>来完成： <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">async</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">importance</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"high"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"non-critical-1.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">async</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">importance</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"low"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> 利用这一重要的新属性，开发人员可以在网络竞争的情况下控制资源的加载顺序。 可能会延迟低优先级的资源，直到处理器和网络空闲，或者取决于设备的类型。 <br><br><h1> 可以使用吗？ </h1><br> 早期的线索和优先的线索都尚未成为标准。 最近，由Fastly使用和支持的HTTP / 2服务器H2O开始使用Early Hints（请参阅PR <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1727</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1767</a> ），并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">打算在Chrome中实现Priority Hints</a> ，并积极跟踪1xx响应。 同时，立即开始发送“早期提示”没有害处-如果您想领先于潮流，那就去吧！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN421059/">https://habr.com/ru/post/zh-CN421059/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN421047/index.html">“命名法”中的类似物。 另一种明智的储蓄方式。 第一部分</a></li>
<li><a href="../zh-CN421049/index.html">设计应用程序屏幕：从计划到设计布局</a></li>
<li><a href="../zh-CN421051/index.html">我如何启动我的第一个SaaS项目以全天候招聘</a></li>
<li><a href="../zh-CN421055/index.html">定制Web开发：如何扩展不断增长的项目</a></li>
<li><a href="../zh-CN421057/index.html">如何为旅客列车组装货车</a></li>
<li><a href="../zh-CN421061/index.html">PostgreSQL：WAL膨胀的方式和原因</a></li>
<li><a href="../zh-CN421063/index.html">Scratch儿童编程新书</a></li>
<li><a href="../zh-CN421065/index.html">我如何教AI玩NES玩俄罗斯方块。 第2部分：AI</a></li>
<li><a href="../zh-CN421067/index.html">我们如何开发用于审查历史地点的AR应用程序</a></li>
<li><a href="../zh-CN421069/index.html">Bobby Urban背包：城堡里面</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>