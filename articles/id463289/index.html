<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❗️ 👨🏼 🎪 Matematika Terpisah untuk WMS: Clustering Stock Lot 👩🏾‍💼 🌠 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini menjelaskan bagaimana, ketika memperkenalkan sistem WMS , kami dihadapkan dengan kebutuhan untuk menyelesaikan masalah pengelompokan non-s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Matematika Terpisah untuk WMS: Clustering Stock Lot</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463289/"><img src="https://habrastorage.org/webt/pk/sw/xk/pkswxkfx_bl-w83edqla_aaq9vq.jpeg"><br><br>  Artikel ini menjelaskan bagaimana, ketika memperkenalkan sistem <i>WMS</i> , kami dihadapkan dengan kebutuhan untuk menyelesaikan masalah pengelompokan non-standar dan dengan algoritma apa kami menyelesaikannya.  Kami akan memberi tahu Anda bagaimana kami menerapkan pendekatan sistematis dan ilmiah untuk memecahkan masalah, kesulitan apa yang kami temui dan pelajaran apa yang kami pelajari. <br><br>  Publikasi ini memulai serangkaian artikel yang kami bagikan pengalaman sukses kami dalam menerapkan algoritma pengoptimalan dalam proses gudang.  Tujuan dari serangkaian artikel ini adalah untuk mengenalkan kepada khalayak dengan jenis-jenis tugas mengoptimalkan operasi gudang yang muncul di hampir semua gudang menengah dan besar, serta menceritakan pengalaman kami dalam memecahkan masalah-masalah seperti itu dan perangkap yang dijumpai di sepanjang jalan ini.  Artikel-artikel akan berguna bagi mereka yang bekerja di industri logistik gudang, menerapkan sistem <i>WMS</i> , serta programmer yang tertarik pada aplikasi matematika dalam bisnis dan optimasi proses di perusahaan. <br><br><a name="habracut"></a><h4>  Proses bottleneck </h4><br>  Pada tahun 2018, kami membuat proyek untuk memperkenalkan sistem <i>WMS</i> di gudang perusahaan LD Trading House di Chelyabinsk.  Memperkenalkan produk "1C-Logistik: Manajemen Gudang 3" untuk 20 pekerjaan: operator <i>WMS</i> , pemilik toko, pengemudi forklift.  Gudang memiliki rata-rata sekitar 4 ribu m2, jumlah sel adalah 5.000 dan jumlah SKU 4500. Katup bola dari produksi kami sendiri dengan ukuran berbeda dari 1 kg hingga 400 kg disimpan di gudang.  Persediaan di gudang disimpan dalam konteks bets karena kebutuhan untuk memilih barang sesuai dengan FIFO dan spesifik “in-line” penempatan produk (penjelasan di bawah). <br><br>  Ketika merancang skema otomasi untuk proses gudang, kami dihadapkan dengan masalah penyimpanan stok yang tidak optimal.  Penumpukan dan penyimpanan crane memiliki, seperti yang telah kita katakan, "baris" spesifik.  Artinya, produk-produk dalam sel ditumpuk dalam satu baris di atas yang lain, dan kemampuan untuk meletakkan sepotong pada sepotong sering tidak ada (mereka jatuh, dan beratnya tidak kecil).  Karena itu, ternyata hanya satu nomenklatur dari satu bets yang dapat berada dalam satu unit penyimpanan, jika tidak, nomenklatur lama tidak dapat ditarik keluar dari yang baru tanpa "menyekop" seluruh sel. <br><br>  Produk tiba di gudang setiap hari dan setiap kedatangan adalah batch yang terpisah.  Secara total, sebagai hasil dari operasi gudang selama 1 bulan, 30 lot terpisah dibuat, meskipun masing-masing harus disimpan dalam sel yang terpisah.  Barang sering dipilih bukan dalam palet utuh, tetapi dalam potongan, dan sebagai hasilnya, di daerah pemilihan potongan, dalam banyak sel gambar berikut diamati: dalam sel dengan volume lebih dari 1 m3 ada beberapa potongan crane yang menempati kurang dari 5-10% volume sel (lihat Gambar 1). ) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hx/qf/bx/hxqfbxlkzhrwql3k0hmcz9l2cem.jpeg"></div>  <i>Gambar 1. Foto beberapa potong barang di dalam sel</i> <br><br>  Di muka penggunaan kapasitas penyimpanan yang kurang optimal.  Untuk membayangkan skala bencana, saya dapat mengutip angka-angka: rata-rata ada antara 100 dan 300 sel seperti sel dengan sedikit sisa dalam periode yang berbeda dari operasi gudang.  Karena gudang relatif kecil, pada musim pemuatan gudang faktor ini menjadi "leher sempit" dan sangat menghambat proses gudang. <br><br><h4>  Gagasan memecahkan masalah </h4><br>  Idenya muncul: untuk membawa kumpulan residu dengan tanggal terdekat ke satu batch tunggal dan menempatkan keseimbangan tersebut dengan batch terpadu secara kompak dalam satu sel, atau dalam beberapa jika tidak ada ruang yang cukup dalam satu untuk mengakomodasi jumlah total saldo. <br><br><img src="https://habrastorage.org/webt/c-/cx/0g/c-cx0gs5mwn14uwupmefgmytzto.jpeg"><br>  <i>Fig. 2.</i>  <i>Skema kompresi sel</i> <br><br>  Ini memungkinkan Anda untuk secara signifikan mengurangi ruang gudang yang ditempati, yang akan digunakan untuk barang yang baru ditempatkan.  Dalam situasi dengan kapasitas gudang yang berlebihan, langkah seperti itu sangat diperlukan, jika tidak, mungkin tidak ada cukup ruang kosong untuk penempatan barang baru, yang akan menyebabkan penghenti dalam proses penempatan dan pengisian gudang.  Sebelumnya, sebelum implementasi sistem <i>WMS-</i> , operasi seperti itu dilakukan secara manual, yang tidak efektif, karena proses menemukan residu yang sesuai dalam sel cukup lama.  Sekarang, dengan diperkenalkannya sistem WMS, mereka memutuskan untuk mengotomatiskan proses, mempercepatnya dan membuatnya cerdas. <br><br>  Proses pemecahan masalah ini dibagi menjadi 2 tahap: <br><br><ul><li>  pada tahap pertama, kami menemukan kelompok-kelompok pihak yang tutup tanggal untuk kompresi; </li><li>  pada tahap kedua, untuk setiap kelompok batch kami menghitung penempatan residu produk yang paling kompak dalam sel. </li></ul><br>  Pada artikel saat ini, kami akan fokus pada tahap pertama algoritma, dan meninggalkan cakupan tahap kedua untuk artikel selanjutnya. <br><br><h4>  Cari model matematika dari suatu masalah </h4><br>  Sebelum kita duduk untuk menulis kode dan menemukan sepeda kita, kita memutuskan untuk mendekati masalah ini secara ilmiah, yaitu: merumuskannya secara matematis, menguranginya menjadi masalah optimalisasi diskrit yang terkenal dan menggunakan algoritma yang ada yang efektif untuk menyelesaikannya, atau mengambil algoritma yang ada ini sebagai dasar dan memodifikasinya di bawah spesifik tugas praktis yang harus diselesaikan. <br><br>  Karena jelas mengikuti dari pernyataan bisnis masalah yang kita hadapi dengan set, kita merumuskan masalah seperti itu dalam hal teori set. <br><br>  Biarkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-50" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> P </script>  - set semua banyak sisa-sisa beberapa barang dalam persediaan.  Biarkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> C </script>  - konstanta hari yang diberikan.  Biarkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">K</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.066ex" height="2.057ex" viewBox="0 -780.1 889.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-4B" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> K </script>  - subset batch di mana perbedaan tanggal untuk semua pasangan batch dari subset tidak melebihi konstanta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> C </script>  .  Temukan jumlah minimum subset yang terpisah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">K</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.066ex" height="2.057ex" viewBox="0 -780.1 889.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-4B" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> K </script>  sedemikian rupa sehingga semua himpunan bagian <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">K</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.066ex" height="2.057ex" viewBox="0 -780.1 889.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-4B" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> K </script>  secara kolektif akan memberi banyak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.745ex" height="2.057ex" viewBox="0 -780.1 751.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-50" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-7"> P </script>  . <br><br>  Selain itu, kita perlu menemukan tidak hanya jumlah minimum himpunan bagian, tetapi sehingga himpunan bagian tersebut akan sebesar mungkin.  Ini disebabkan oleh fakta bahwa setelah pengelompokan bets, kami akan "mengompres" sisa-sisa bets yang ditemukan dalam sel.  Mari kita ilustrasikan dengan sebuah contoh.  Misalkan ada banyak pihak yang terdistribusi pada sumbu waktu, seperti pada Gambar 3. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zt/-1/yt/zt-1ytuw7m6jtb4x6qtjafowvt8.jpeg"></div>  <i>Fig. 3.</i>  <i>Opsi Pemisahan Banyak</i> <br><br>  Dari dua opsi untuk memisahkan set P dengan jumlah himpunan bagian yang sama, partisi pertama <b>(a)</b> paling bermanfaat untuk tugas kita.  Karena, semakin banyak pihak dalam grup, semakin banyak kombinasi kompresi yang muncul, dan dengan demikian semakin besar kemungkinan untuk menemukan kompresi yang paling kompak.  Tentu saja, aturan seperti itu tidak lebih dari heuristik dan asumsi spekulatif kita.  Meskipun, seperti yang diperlihatkan percobaan komputasi, jika kondisi maksimalisasi diperhitungkan, kekompakan kompresi residu selanjutnya menjadi rata-rata 5-10% lebih tinggi daripada kompresi yang dibangun tanpa memperhitungkan kondisi seperti itu. <br><br>  Dengan kata lain, singkatnya, kita perlu menemukan kelompok atau kelompok pihak yang serupa di mana kriteria kesamaan ditentukan oleh konstanta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-15"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> C </script>  .  Tugas ini mengingatkan kita pada masalah pengelompokan yang terkenal.  Penting untuk mengatakan bahwa masalah yang dipertimbangkan berbeda dari masalah pengelompokan dalam bahwa dalam masalah kami ada kondisi yang didefinisikan secara ketat untuk kriteria kesamaan elemen-elemen kluster, yang ditentukan oleh konstanta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-17"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.766ex" height="2.057ex" viewBox="0 -780.1 760.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-43" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-9"> C </script>  , dan dalam masalah pengelompokan tidak ada kondisi seperti itu.  Pernyataan masalah pengelompokan dan informasi tentang tugas ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  Jadi, kami berhasil merumuskan masalah dan menemukan masalah klasik dengan formulasi serupa.  Sekarang Anda perlu mempertimbangkan algoritma terkenal untuk menyelesaikannya, agar tidak menemukan kembali roda, tetapi untuk mengambil praktik terbaik dan menerapkannya.  Untuk mengatasi masalah pengelompokan, kami mempertimbangkan algoritma yang paling populer, yaitu: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-19"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.211ex" height="2.057ex" viewBox="0 -780.1 521.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/463289/&amp;usg=ALkJrhijpnKMUjYlTY3dVgN2ni1OXwlyvg#MJMATHI-6B" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-10"> k </script>  -berarti <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">c</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> c </script>  -berarti, algoritma untuk memilih komponen yang terhubung, algoritma spanning tree minimal.  Deskripsi dan analisis algoritma semacam itu dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  Untuk mengatasi masalah kami, algoritma pengelompokan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-23"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> k </script>  -berarti dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-25"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">c</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> c </script>  -berarti tidak berlaku sama sekali, karena jumlah cluster tidak pernah diketahui sebelumnya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> k </script>  dan algoritma seperti itu tidak memperhitungkan pembatasan konstanta hari.  Algoritma tersebut pada awalnya dibuang. <br>  Untuk mengatasi masalah kami, algoritma untuk memilih komponen yang terhubung dan algoritma spanning tree minimum lebih cocok, tetapi ternyata tidak dapat diterapkan secara langsung pada masalah yang sedang dipecahkan dan mendapatkan solusi yang baik.  Untuk memperjelas hal ini, kami mempertimbangkan logika pengoperasian algoritma seperti yang diterapkan pada masalah kami. <br><br>  Pertimbangkan grafiknya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">G</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> G </script>  di mana puncaknya banyak pihak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-31"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> P </script>  , dan tepi antara simpul <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-msubsup" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-36" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> p_1 </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-37"><span class="MJXp-msubsup" id="MJXp-Span-38"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-40" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> p_2 </script>  memiliki berat yang sama dengan perbedaan hari antara batch <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-41"><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-44" style="vertical-align: -0.4em;">1</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> p_1 </script>  dan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-45"><span class="MJXp-msubsup" id="MJXp-Span-46"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-47" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-48" style="vertical-align: -0.4em;">2</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> p_2 </script>  .  Dalam algoritma untuk memilih komponen yang terhubung, parameter input ditentukan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-49"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> R </script>  dimana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-51"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">R</span><span class="MJXp-mtext" id="MJXp-Span-53">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> R \ leq C </script>  , dan dalam grafik <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-58"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59">G</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> G </script>  semua tepi yang beratnya dihilangkan dihapus <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> R </script>  .  Hanya pasangan benda terdekat yang tetap terhubung.  Arti dari algoritma ini adalah untuk memilih nilai seperti itu <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-62"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> R </script>  , di mana grafik "terpecah-pecah" menjadi beberapa komponen yang terhubung, di mana pihak-pihak yang termasuk dalam komponen ini memenuhi kriteria kesamaan kami, yang ditentukan oleh konstanta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-64"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> C </script>  .  Komponen yang dihasilkan adalah cluster. <br><br>  Algoritma spanning tree minimum pertama kali dibangun di atas grafik <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-66"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">G</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> G </script>  minimum spanning tree, dan kemudian secara berurutan menghilangkan ujung-ujungnya dengan bobot terbesar hingga grafik “pecah” menjadi beberapa komponen yang terhubung, di mana lot yang dimiliki komponen ini juga akan memenuhi kriteria kesamaan kami.  Komponen yang dihasilkan adalah cluster. <br><br>  Ketika menggunakan algoritme tersebut untuk menyelesaikan masalah yang sedang dipertimbangkan, sebuah situasi dapat muncul seperti pada Gambar 4. <br><br><img src="https://habrastorage.org/webt/px/c_/7g/pxc_7gzeqrp-gra6ahc_wostrac.jpeg"><br>  <i>Gambar 4. Aplikasi algoritma pengelompokan untuk masalah yang sedang dipecahkan.</i> <br><br>  Misalkan kita memiliki perbedaan konstan dari hari-hari para pihak adalah 20 hari.  Hitung <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-68"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">G</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> G </script>  digambarkan dalam bentuk spasial untuk kenyamanan persepsi visual.  Kedua algoritma memberikan solusi dengan 3 cluster, yang dapat dengan mudah ditingkatkan dengan menggabungkan batch yang ditempatkan di cluster terpisah di antara mereka!  Jelas, algoritma tersebut perlu dikembangkan lebih lanjut sesuai dengan spesifik masalah yang sedang dipecahkan dan aplikasi murni mereka untuk solusi masalah kita akan memberikan hasil yang buruk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lt/6v/ul/lt6vulnpbkgvkiaqoklpzfyrlde.jpeg"></div><br>  Jadi, sebelum mulai menulis kode algoritme grafik yang dimodifikasi untuk tugas kami dan menciptakan sepeda kami sendiri (di mana siluet garis-garis roda persegi sudah dapat ditebak), kami kembali memutuskan untuk mendekati masalah ini secara ilmiah, yaitu: mencoba menguranginya menjadi masalah diskrit lain. optimisasi, dengan harapan bahwa algoritma yang ada untuk solusinya dapat diterapkan tanpa modifikasi. <br><br>  Pencarian berikutnya untuk masalah klasik serupa berhasil!  Itu mungkin untuk menemukan masalah optimasi diskrit, pernyataan yang hampir 1 dalam 1 bertepatan dengan pernyataan masalah kita.  Masalah ini ternyata menjadi <b>masalah menutupi set</b> .  Kami menyajikan pernyataan masalah sebagaimana diterapkan pada spesifikasi kami. <br><br>  Ada satu set yang terbatas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-70"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> P </script>  dan keluarga <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-72"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">S</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> S </script>  dari semua subset pihak yang terpisah, sehingga perbedaan tanggal untuk semua pasangan partai dari setiap subset <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-74"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> I </script>  dari keluarga <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-76"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">S</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> S </script>  tidak melebihi konstanta <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-78"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> C </script>  .  Pelapisan disebut keluarga <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-80"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">U</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> U </script>  Setidaknya kekuatan yang elemennya termasuk <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-82"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-83">S</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> S </script>  sedemikian rupa sehingga persatuan set <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-84"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> I </script>  dari keluarga <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-86"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">U</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> U </script>  harus memberikan banyak dari semua pihak <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-88"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> P </script>  . <br><br>  Analisis terperinci tentang masalah ini dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a>  Pilihan lain untuk aplikasi praktis masalah cakupan dan modifikasinya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a> <br><br>  Satu-satunya perbedaan kecil antara masalah yang dipertimbangkan dan masalah klasik yang meliputi suatu himpunan adalah kebutuhan untuk memaksimalkan jumlah elemen dalam himpunan bagian.  Tentu saja, orang dapat mencari artikel di mana kasus khusus dipertimbangkan dan, kemungkinan besar, mereka akan ditemukan.  Tetapi, dari pencarian artikel selanjutnya, kami terselamatkan oleh fakta bahwa algoritma "serakah" yang terkenal untuk memecahkan masalah klasik dalam peliputan set membangun partisi hanya dengan mempertimbangkan maksimalisasi jumlah elemen dalam himpunan bagian.  Jadi, kami berlari sedikit ke depan, dan sekarang semuanya beres. <br><br><h4>  Algoritma untuk memecahkan masalah </h4><br>  Kami telah memutuskan pada model matematika masalah yang harus dipecahkan.  Sekarang kita mulai mempertimbangkan algoritma untuk solusinya.  Subset <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-90"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> I </script>  dari keluarga <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-92"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">S</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> S </script>  dapat dengan mudah ditemukan, misalnya, dengan prosedur seperti itu. <br><br><ol><li>  <b>Langkah 0.</b> Atur kumpulan dari set <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-94"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> P </script>  dalam urutan tanggal mereka.  Kami percaya bahwa semua pihak tidak ditandai sebagai dilihat. </li><li>  <b>Langkah 1.</b> Temukan pesta dengan tanggal terkecil dari para pihak yang belum dilihat. </li><li>  <b>Langkah 2.</b> Untuk pihak yang ditemukan, bergerak ke kanan, kami sertakan dalam subset <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> I </script>  semua pihak yang tanggalnya berbeda dari tanggal saat ini tidak lebih dari <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">C</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-43"> C </script>  hari.  Semua batch termasuk dalam set <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-100"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-44"> I </script>  tandai seperti yang dilihat. </li><li>  <b>Langkah 3.</b> Jika, ketika bergerak ke kanan, kumpulan berikutnya tidak dapat dimasukkan <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">I</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-45"> I </script>  , lalu lanjutkan ke langkah 1. </li></ol><br>  Masalah menutupi satu set adalah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">N</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">P</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46"> NP </script>  - sulit, yang berarti bahwa untuk solusinya tidak ada yang cepat (dengan waktu operasi sama dengan polinomial dari data input) dan algoritma yang akurat.  Oleh karena itu, untuk memecahkan masalah meliputi himpunan, dipilih algoritma serakah cepat, yang tentu saja tidak tepat, tetapi memiliki keuntungan sebagai berikut: <br><br><ul><li>  Untuk masalah dimensi kecil (dan ini hanya kasus kami), ini menghitung solusi yang cukup dekat ke optimal.  Ketika ukuran masalah bertambah, kualitas larutan memburuk, tetapi masih agak lambat; </li><li>  Sangat mudah diimplementasikan; </li><li>  Cepat, karena perkiraan waktu operasinya adalah <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">O</span><span class="MJXp-mo" id="MJXp-Span-109" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">n</span><span class="MJXp-mo" id="MJXp-Span-112" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47"> O (mn) </script>  . </li></ul><br>  Algoritma serakah memilih set yang dipandu oleh aturan berikut: pada setiap tahap, set dipilih yang mencakup jumlah maksimum elemen yang belum tercakup.  Penjelasan terperinci dari algoritma dan pseudo-code-nya dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini.</a>  Implementasi algoritma dalam bahasa <i>1C</i> dalam spoiler lebih rendah (tentang mengapa mereka mulai mengimplementasikannya dalam bahasa "kuning" pada bab berikutnya). <br><br><div class="spoiler">  <b class="spoiler_title">Kode algoritma 1C</b> <div class="spoiler_text"><pre><code class="1c hljs"><span class="hljs-comment"><span class="hljs-comment">//        //       ()   =  ;  .() &gt; 0   = (); .();       .(.()); ; ;  ;   ()  = 60*60*24;  = ._.();  =  ;  = 0;        = . + *;  = 0;  =  ; //           = .()  .() - 1   = .();  . &lt;=   .();  =  + 1;  //     ; ; ; //       &gt;    = ;  =  ;       .(); ; ; ;  ; </span></span></code> </pre> </div></div><br>  Tentu saja, optimalitas dari algoritma semacam itu tidak mungkin - heuristik, untuk mengatakan apa-apa.  Anda dapat menemukan contoh seperti itu di mana algoritma seperti itu salah.  Kesalahan semacam itu muncul ketika, pada beberapa iterasi, kami menemukan beberapa set dengan jumlah elemen yang sama dan memilih elemen pertama yang muncul, karena strateginya serakah: Saya mengambil hal pertama yang menarik perhatian saya dan "serakah" puas. <br><br>  Mungkin saja pilihan semacam itu dapat mengarah pada hasil suboptimal pada iterasi selanjutnya.  Tetapi akurasi dari algoritma yang sederhana masih cukup bagus dalam banyak kasus.  Jika Anda ingin mendapatkan solusi untuk masalah lebih akurat, maka Anda perlu menggunakan algoritma yang lebih kompleks, misalnya, seperti dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerjaan</a> : algoritma serakah probabilistik, algoritma koloni semut, dll.  Hasil membandingkan algoritma tersebut pada data acak yang dihasilkan dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam pekerjaan.</a> <br><br><h4>  Implementasi dan implementasi algoritma </h4><br>  Algoritme seperti itu diimplementasikan dalam bahasa <i>1C</i> dan dimasukkan dalam pemrosesan eksternal yang disebut "Kompresi residu", yang terhubung ke sistem <i>WMS</i> .  Kami tidak menerapkan algoritme dalam <i>C ++</i> dan menggunakannya dari komponen Native eksternal, yang akan lebih benar, karena kecepatan <i>kode C ++</i> beberapa kali dan dalam beberapa contoh bahkan sepuluh kali lebih cepat daripada kecepatan kode serupa di <i>1C</i> .  Di <i>1C,</i> algoritma ini diterapkan untuk menghemat waktu pengembangan dan kemudahan debugging di pangkalan kerja pelanggan.  Hasil algoritma ditunjukkan pada Gambar 6. <br><br><img src="https://habrastorage.org/webt/_y/8g/gg/_y8gggbigigzrjh4lpra5fwwlcc.jpeg"><br>  <i>Fig. 6.</i>  <i>Pemrosesan Kompresi Residu</i> <br><br>  Gambar 6 menunjukkan bahwa di gudang yang ditunjukkan stok barang saat ini dalam sel penyimpanan dibagi menjadi beberapa kelompok, di mana tanggal pengiriman berbeda dengan tidak lebih dari 30 hari.  Karena pelanggan memproduksi dan menyimpan katup bola logam dengan umur simpan bertahun-tahun, perbedaan tanggal ini dapat diabaikan.  Perhatikan bahwa saat ini pemrosesan tersebut digunakan dalam produksi secara sistematis, dan operator <i>WMS</i> mengkonfirmasi kualitas batch yang baik. <br><br><h4>  Kesimpulan dan lanjutan </h4><br>  Pengalaman utama yang kami peroleh dari penyelesaian masalah praktis seperti itu adalah untuk mengkonfirmasi keefektifan penggunaan paradigma: Mat.  pernyataan tugas <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-mtext" id="MJXp-Span-114">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-116">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-117">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-119">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-48"> \ rightarrow </script>  tikar terkenal.  model <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-mtext" id="MJXp-Span-126">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-129">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-130">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-131">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-132">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-133">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-135">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-136">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-49-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-49"> \ rightarrow </script>  algoritma terkenal <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-137"><span class="MJXp-mtext" id="MJXp-Span-138">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-139">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-141">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-143">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-144">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-145">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-146">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-147">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-50-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-50"> \ rightarrow </script>  algoritma dengan mempertimbangkan spesifikasi tugas.  Sudah ada lebih dari 300 tahun optimasi diskrit dan selama waktu ini orang berhasil mempertimbangkan banyak masalah dan mendapatkan banyak pengalaman dalam menyelesaikannya.  Pertama-tama, lebih disarankan untuk beralih ke pengalaman ini, dan baru kemudian mulai menciptakan kembali sepeda Anda. <br><br>  Penting juga untuk mengatakan bahwa solusi untuk masalah pengelompokan dapat dianggap tidak terpisah dari solusi untuk masalah mengompresi sisa batch, tetapi untuk menyelesaikan masalah tersebut bersama-sama.  Yaitu, untuk memilih partisi partai seperti itu ke dalam kelompok yang akan memberikan kompresi terbaik.  Tetapi solusi untuk masalah seperti itu diputuskan untuk dibagi karena alasan-alasan berikut: <br><br><ul><li>  <b>Anggaran terbatas</b> untuk pengembangan algoritma.  Pengembangan seperti umum, dan karenanya algoritma yang lebih kompleks akan lebih memakan waktu. </li><li>  <b>Kompleksitas debugging dan pengujian.</b>  Algoritma umum akan lebih sulit untuk menguji dan debug pada tahap penerimaan, dan bug di dalamnya akan lebih sulit dan lebih lama untuk debug dalam operasi real-time.  Misalnya, kesalahan terjadi dan tidak jelas di mana untuk menggali: kempa atap menuju pengelompokan, atap kempa menuju kompresi? </li><li>  <b>Transparansi dan pengelolaan.</b>  Pemisahan kedua tugas membuat proses kompresi lebih transparan, dan karenanya lebih mudah dikelola bagi pengguna akhir - operator WMS.  Mereka dapat menghapus beberapa sel dari kompresi atau mengedit kuantitas kompresibel untuk beberapa alasan. </li></ul><br>  Pada artikel berikutnya, kami akan melanjutkan diskusi tentang algoritma optimasi dan mempertimbangkan yang paling menarik dan jauh lebih kompleks: algoritma optimal untuk "kompresi" residu dalam sel, yang menggunakan input yang diterima dari algoritma pengelompokan batch sebagai input. <br><br>  <i>Mempersiapkan artikel</i> <i><br></i>  <i>Roman Shangin, Programmer, Departemen Proyek,</i> <i><br></i>  <i>Perusahaan BIT pertama, Chelyabinsk</i> <br><cut></cut></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id463289/">https://habr.com/ru/post/id463289/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id463275/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 375 (5 - 11 Agustus 2019)</a></li>
<li><a href="../id463277/index.html">Penugasan untuk pengembangan diri: Formulir HTML dengan daftar string acak dan seleksi oleh mereka</a></li>
<li><a href="../id463279/index.html">PHP Digest No. 162 (1 - 12 Agustus 2019)</a></li>
<li><a href="../id463281/index.html">Mengapa ada beberapa aplikasi inovatif di Google Play atau mengapa terkadang pemrograman itu ajaib</a></li>
<li><a href="../id463285/index.html">ShIoTiny: node, tautan, dan acara atau fitur program menggambar</a></li>
<li><a href="../id463291/index.html">Dadu atau Tulang</a></li>
<li><a href="../id463293/index.html">Pengumpul Sampah. Kursus lengkap + transfer dari BOTR</a></li>
<li><a href="../id463295/index.html">C ++ dan CMake - Brothers Forever, Bagian II</a></li>
<li><a href="../id463297/index.html">Kesetiaan dengan selera Anda</a></li>
<li><a href="../id463299/index.html">Kiat dan trik Kubernetes: cara meningkatkan produktivitas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>