<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöà üë®üèΩ‚Äçüî¨ ü§õüèø 10 beneficios obvios de usar Rust üèÇüèº üßô üçõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust es un lenguaje de programaci√≥n de sistemas joven y ambicioso. Implementa la administraci√≥n autom√°tica de memoria sin un recolector de basura y ot...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 beneficios obvios de usar Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust es un lenguaje de programaci√≥n de sistemas joven y ambicioso.  Implementa la administraci√≥n autom√°tica de memoria sin un recolector de basura y otros gastos generales de tiempo de ejecuci√≥n.  Adem√°s, el idioma predeterminado se usa en el idioma Rust, existen reglas sin precedentes para acceder a datos mutables y tambi√©n se tienen en cuenta las vidas de los enlaces.  Esto le permite garantizar la seguridad de la memoria y facilita la programaci√≥n de subprocesos m√∫ltiples, debido a la falta de carreras de datos. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> Todo esto ya es bien conocido por todos los que siguen el desarrollo de las tecnolog√≠as de programaci√≥n modernas al menos un poco.  Pero, ¬øqu√© sucede si no es un programador de sistemas y no hay muchos c√≥digos multiproceso en sus proyectos, pero todav√≠a se siente atra√≠do por el desempe√±o de Rust?  ¬øObtendr√° beneficios adicionales de su uso en aplicaciones?  ¬øO todo lo que √©l le dar√° adem√°s es una pelea dif√≠cil con el compilador, que lo obligar√° a escribir el programa para que siga constantemente las reglas del lenguaje sobre pr√©stamos y propiedad? </p><br><p>  Este art√≠culo ha recopilado docenas de ventajas no obvias y no especialmente publicitadas del uso de Rust, que, espero, lo ayudar√° a decidir la elecci√≥n de este idioma para sus proyectos. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. La universalidad del lenguaje. </h2><br><p>  A pesar de que Rust se posiciona como un lenguaje para la programaci√≥n del sistema, tambi√©n es adecuado para resolver problemas aplicados de alto nivel.  No tiene que trabajar con punteros sin procesar a menos que lo necesite para su tarea.  La biblioteca de idiomas est√°ndar ya ha implementado la mayor√≠a de los tipos y funciones que pueden ser necesarios en el desarrollo de aplicaciones.  Tambi√©n puede conectar f√°cilmente bibliotecas externas y usarlas.  El sistema de tipos y la programaci√≥n generalizada en Rust permiten el uso de abstracciones de un nivel bastante alto, aunque no hay soporte directo para OOP en el lenguaje. </p><br><p>  Veamos algunos ejemplos simples del uso de Rust. </p><br><p>  Un ejemplo de combinar dos iteradores en un iterador sobre pares de elementos: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><blockquote>  Nota: ¬°una llamada al <code>name!(...)</code> del formato <code>name!(...)</code> es una llamada a una macro funcional.  ¬°Los nombres de tales macros en Rust siempre terminan con un s√≠mbolo <code>!</code>  para que puedan distinguirse de los nombres de funciones y otros identificadores.  Los beneficios del uso de macros se discutir√°n a continuaci√≥n. </blockquote><p>  Un ejemplo de uso de la biblioteca externa de expresiones regulares para trabajar con expresiones regulares: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Un ejemplo de la implementaci√≥n del <code>Add</code> para la propia estructura <code>Point</code> para sobrecargar el operador de suma: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Un ejemplo de uso de un tipo gen√©rico en una estructura: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  En Rust puede escribir utilidades de sistema eficientes, grandes aplicaciones de escritorio, microservicios, aplicaciones web (incluida la parte del cliente, ya que Rust puede compilarse en Wasm), aplicaciones m√≥viles (aunque el ecosistema del lenguaje a√∫n est√° poco desarrollado en esta direcci√≥n).  Tal versatilidad puede ser una ventaja para los equipos de proyectos m√∫ltiples, ya que le permite utilizar los mismos enfoques y los mismos m√≥dulos en muchos proyectos diferentes.  Si est√° acostumbrado al hecho de que cada herramienta est√° dise√±ada para su campo de aplicaci√≥n limitado, intente ver a Rust como una caja de herramientas con la misma confiabilidad y conveniencia.  Quiz√°s esto es exactamente lo que te estabas perdiendo. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Herramientas convenientes de construcci√≥n y gesti√≥n de dependencias </h2><br><p>  Esto claramente no se anuncia, pero muchos notan que Rust tiene uno de los mejores sistemas de gesti√≥n de dependencia y compilaci√≥n disponibles en la actualidad.  Si program√≥ en C o C ++, y la cuesti√≥n del uso indoloro de bibliotecas externas fue bastante aguda para usted, entonces usar Rust con su herramienta de compilaci√≥n y el administrador de dependencia de Cargo ser√° una buena opci√≥n para sus nuevos proyectos. </p><br><p>  Adem√°s del hecho de que Cargo descargar√° las dependencias para usted y administrar√° sus versiones, crear√° y ejecutar√° sus aplicaciones, ejecutar√° pruebas y generar√° documentaci√≥n, tambi√©n se puede ampliar con complementos para otras funciones √∫tiles.  Por ejemplo, hay extensiones que le permiten a Cargo determinar las dependencias obsoletas de su proyecto, realizar an√°lisis est√°ticos del c√≥digo fuente, construir y volver a implementar partes del cliente de aplicaciones web y mucho m√°s. </p><br><p>  El archivo de configuraci√≥n de Cargo utiliza el lenguaje de marcado toml amigable y m√≠nimo para describir la configuraci√≥n del proyecto.  Aqu√≠ hay un ejemplo de un <code>Cargo.toml</code> configuraci√≥n t√≠pico de <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  Y a continuaci√≥n hay tres comandos t√≠picos para usar Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Con su ayuda, el c√≥digo fuente se verificar√° en busca de errores de compilaci√≥n, el ensamblaje del proyecto y el lanzamiento de las pruebas, el ensamblaje y el lanzamiento del programa para su ejecuci√≥n, respectivamente. </p><br><h2 id="3-vstroennye-testy">  3. Pruebas incorporadas </h2><br><p>  Escribir pruebas unitarias en Rust es tan f√°cil y simple que desea hacerlo una y otra vez.  :) A menudo ser√° m√°s f√°cil escribir una prueba unitaria que intentar probar la funcionalidad de otra manera.  Aqu√≠ hay un ejemplo de funciones y pruebas para ellos: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Las funciones en el m√≥dulo de <code>test</code> , marcadas con el atributo <code>#[test]</code> , son pruebas unitarias.  Se ejecutar√°n en paralelo cuando se llame al comando de <code>cargo test</code> .  El atributo de compilaci√≥n condicional <code>#[cfg(test)]</code> , que marca todo el m√≥dulo con pruebas, conducir√° al hecho de que el m√≥dulo se compilar√° solo cuando se ejecuten las pruebas, pero no entrar√° en el ensamblaje normal. </p><br><p>  Es muy conveniente colocar las pruebas en el mismo m√≥dulo que el funcional bajo prueba, simplemente agregando el subm√≥dulo de <code>test</code> .  Y si necesita pruebas de integraci√≥n, simplemente coloque sus pruebas en el directorio de <code>tests</code> en la ra√≠z del proyecto y use su aplicaci√≥n en ellas como un paquete externo.  No es necesario agregar un m√≥dulo de <code>test</code> separado y directivas de compilaci√≥n condicional en este caso. </p><br><p>  Ejemplos especiales de documentaci√≥n ejecutada como pruebas merecen especial atenci√≥n, pero esto se discutir√° a continuaci√≥n. </p><br><p>  Las pruebas de rendimiento incorporadas (puntos de referencia) tambi√©n est√°n disponibles, pero a√∫n no son estables, por lo tanto, solo est√°n disponibles en ensamblajes nocturnos del compilador.  En Rust estable, deber√° utilizar bibliotecas externas para este tipo de pruebas. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Buena documentaci√≥n con ejemplos actuales. </h2><br><p>  La biblioteca est√°ndar de Rust est√° muy bien documentada.  La documentaci√≥n HTML se genera autom√°ticamente a partir del c√≥digo fuente con descripciones de rebajas en los comentarios del muelle.  Adem√°s, los comentarios del documento en el c√≥digo Rust contienen c√≥digo de muestra que se ejecuta cuando se ejecutan las pruebas.  Esto asegura la relevancia de los ejemplos: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>La documentaci√≥n</em></a> </p><br><p>  Aqu√≠ hay un ejemplo del uso del m√©todo <code>as_bytes</code> de tipo <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  se ejecutar√° como prueba durante el lanzamiento de las pruebas. </p><br><p>  Adem√°s, la pr√°ctica de crear ejemplos de su uso en forma de peque√±os programas independientes ubicados en el directorio de <code>examples</code> en la ra√≠z del proyecto es com√∫n para las bibliotecas Rust.  Estos ejemplos tambi√©n son una parte importante de la documentaci√≥n y tambi√©n se compilan y ejecutan durante la ejecuci√≥n de la prueba, pero se pueden ejecutar independientemente de las pruebas. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Autodeducci√≥n inteligente de tipos </h2><br><p>  En un programa Rust, no puede especificar expl√≠citamente el tipo de expresi√≥n si el compilador puede generarlo autom√°ticamente en funci√≥n del contexto de uso.  Y esto se aplica no solo a aquellos lugares donde se declaran variables.  Veamos un ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Si organizamos las anotaciones de tipo, este ejemplo se ver√° as√≠: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Es decir, tenemos un vector de segmentos de cadena y una variable de tipo segmento de cadena.  Pero en este caso, la especificaci√≥n de tipos es completamente redundante, ya que el compilador puede generarlos por s√≠ mismo (usando la versi√≥n extendida del algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hindley-Milner</a> ).  El hecho de que <code>vec</code> es un vector ya est√° claro por el tipo del valor de retorno de <code>Vec::new()</code> , pero a√∫n no est√° claro qu√© tipo de elementos ser√°n.  El hecho de que el tipo de <code>text</code> sea ‚Äã‚Äãun segmento de cadena es comprensible por el hecho de que se le asigna un literal de este tipo.  Por lo tanto, despu√©s de <code>vec.push(text)</code> , el tipo de elementos vectoriales se vuelve obvio.  Tenga en cuenta que el tipo de la variable <code>vec</code> estaba completamente determinado por su uso en el hilo de ejecuci√≥n, y no en la etapa de inicializaci√≥n. </p><br><p>  Tal sistema de inferencia de tipos elimina el ruido del c√≥digo y lo hace tan conciso como el c√≥digo en alg√∫n lenguaje de programaci√≥n escrito din√°micamente.  ¬°Y esto mientras se mantiene una estricta escritura est√°tica! </p><br><p>  Por supuesto, no podemos deshacernos por completo de escribir en un idioma est√°ticamente escrito.  El programa debe tener puntos en los que se garantice que se conocen los tipos de objetos, de modo que en otros lugares se puedan mostrar estos tipos.  Dichos puntos en Rust son declaraciones de tipos de datos definidos por el usuario y firmas de funciones, en los que uno no puede sino especificar los tipos utilizados.  Pero puede ingresar "metavariables de tipos" en ellos, utilizando la programaci√≥n generalizada. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Coincidencia de patrones en puntos de declaraci√≥n variables </h2><br><p>  <code>let</code> operaci√≥n </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  en realidad no se limita a declarar nuevas variables.  Lo que realmente hace es unir la expresi√≥n a la derecha del signo igual con el patr√≥n de la izquierda.  Y se pueden introducir nuevas variables como parte de la muestra (y solo as√≠).  Eche un vistazo al siguiente ejemplo y le resultar√° m√°s claro: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  La desestructuraci√≥n se realiz√≥ aqu√≠: dicha comparaci√≥n introducir√° las variables <code>x</code> e <code>y</code> , que se inicializar√°n con el valor de los campos <code>x</code> e <code>y</code> del objeto de la estructura <code>Point</code> , que se devuelve llamando a <code>Point::new()</code> .  Al mismo tiempo, la comparaci√≥n es correcta, ya que el tipo de expresi√≥n a la derecha corresponde al patr√≥n de <code>Point</code> de tipo <code>Point</code> a la izquierda.  De manera similar, puede tomar, por ejemplo, los dos primeros elementos de una matriz: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Y mucho m√°s por hacer.  Lo m√°s notable es que tales comparaciones se realizan en todos los lugares donde se pueden ingresar nuevos nombres de variables en Rust, a saber: en el <code>match</code> , <code>let</code> , <code>if let</code> , <code>while let</code> <code>if let</code> , en el encabezado del bucle <code>for</code> , en los argumentos de funciones y cierres.  Aqu√≠ hay un ejemplo del uso elegante de la coincidencia de patrones en un bucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  El m√©todo de <code>enumerate</code> , llamado en el iterador, construye un nuevo iterador, que iterar√° no sobre los valores iniciales, sino sobre tuplas, pares "√≠ndice ordinal, valor inicial".  Cada una de estas tuplas durante la iteraci√≥n del ciclo se correlacionar√° con el patr√≥n especificado <code>(i, ch)</code> , como resultado de lo cual la variable <code>i</code> recibir√° el primer valor de la tupla, el √≠ndice, y la variable <code>ch</code> , el segundo, es decir, el car√°cter de la cadena.  Adem√°s en el cuerpo del bucle podemos usar estas variables. </p><br><p>  Otro ejemplo popular de usar un patr√≥n en un bucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Aqu√≠ simplemente ignoramos el valor del iterador usando el patr√≥n <code>_</code> .  Porque no usamos el n√∫mero de iteraci√≥n en el cuerpo del bucle.  Lo mismo se puede hacer, por ejemplo, con un argumento de funci√≥n: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  O cuando coincide en una declaraci√≥n de <code>match</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  La coincidencia de patrones hace que el c√≥digo sea muy compacto y expresivo, y en la declaraci√≥n de <code>match</code> generalmente es insustituible.  El operador de <code>match</code> es un operador de an√°lisis variativo completo, por lo que no podr√° olvidarse accidentalmente de verificar algunas de las posibles coincidencias para la expresi√≥n analizada en √©l. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Extensi√≥n de sintaxis y DSL personalizado </h2><br><p>  La sintaxis de Rust es limitada, en gran parte debido a la complejidad del sistema de tipos utilizado en el lenguaje.  Por ejemplo, Rust no tiene argumentos de funciones con nombre o funciones con un n√∫mero variable de argumentos.  Pero puede sortear estas y otras limitaciones con macros.  Rust tiene dos tipos de macros: declarativa y procesal.  Con las macros declarativas, nunca tendr√° los mismos problemas que con las macros en C, porque son higi√©nicas y no funcionan a nivel de reemplazo de texto, sino a nivel de reemplazo en el √°rbol de sintaxis abstracta.  Las macros le permiten crear abstracciones a nivel de sintaxis del lenguaje.  Por ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Adem√°s del hecho de que esta macro expande las capacidades sint√°cticas de llamar a la "funci√≥n" de imprimir una cadena con formato, tambi√©n en su implementaci√≥n verificar√° que los argumentos de entrada coincidan con la cadena de formato especificada en tiempo de compilaci√≥n y no en tiempo de ejecuci√≥n.  Usando macros, puede ingresar una sintaxis concisa para sus propias necesidades de dise√±o, crear y usar DSL.  Aqu√≠ hay un ejemplo del uso de c√≥digo JavaScript dentro de un programa Rust compilando en Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Macro <code>js!</code>  definido en el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>stdweb</code></a> y le permite incrustar c√≥digo JavaScript completo en su programa (con la excepci√≥n de cadenas entre comillas simples y operadores no completados con punto y coma) y usar objetos del c√≥digo Rust usando la sintaxis <code>@{expr}</code> . </p><br><p>  Las macros ofrecen enormes oportunidades para adaptar la sintaxis de los programas de Rust a las tareas espec√≠ficas de un √°rea tem√°tica particular.  Ahorrar√°n su tiempo y atenci√≥n al desarrollar aplicaciones complejas.  No aumentando la sobrecarga de tiempo de ejecuci√≥n, sino aumentando el tiempo de compilaci√≥n.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Autogeneraci√≥n de c√≥digo dependiente </h2><br><p>  Las macros de derivaci√≥n procesal de Rust se usan ampliamente para implementar autom√°ticamente rasgos y otra generaci√≥n de c√≥digo.  Aqu√≠ hay un ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Dado que todos estos tipos ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> y <code>Eq</code> ) de la biblioteca est√°ndar se implementan para el tipo de campos de la estructura <code>i32</code> , su implementaci√≥n se puede mostrar autom√°ticamente para toda la estructura como un todo.  Otro ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Aqu√≠, utilizando las <code>Deserialize</code> y <code>Deserialize</code> de la biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>serde</code></a> para la estructura <code>Point</code> , se generan autom√°ticamente m√©todos para su serializaci√≥n y deserializaci√≥n.  Luego puede pasar una instancia de esta estructura a varias funciones de serializaci√≥n, por ejemplo, convirti√©ndola en una cadena JSON. </p><br><p>  Puede crear sus propias macros de procedimiento que generar√°n el c√≥digo que necesita.  O use las muchas macros ya creadas por otros desarrolladores.  Adem√°s de salvar al programador de escribir c√≥digo repetitivo, las macros tambi√©n tienen la ventaja de que no necesita mantener diferentes secciones de c√≥digo en un estado coherente.  Por ejemplo, si se agrega un tercer campo <code>z</code> a la estructura de <code>Point</code> , entonces para hacer su serializaci√≥n correctamente, si usa derivar, no necesita hacer nada m√°s.  Si nosotros mismos implementamos los rasgos necesarios para la serializaci√≥n de <code>Point</code> , entonces tendremos que asegurarnos de que esta implementaci√≥n siempre sea consistente con los √∫ltimos cambios en la estructura de <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Tipo de datos algebraicos </h2><br><p>  En pocas palabras, un tipo de datos algebraicos es un tipo de datos compuesto que es una uni√≥n de estructuras.  M√°s formalmente, es una suma de tipos de tipos de productos.  En Rust, este tipo se define usando la palabra clave <code>enum</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  El tipo de un valor particular de una variable de tipo <code>Message</code> puede ser solo uno de los tipos de estructura enumerados en <code>Message</code> .  Esta es una estructura <code>Quit</code> campo tipo unidad, una de las estructuras de tupla <code>ChangeColor</code> o <code>Write</code> con campos sin nombre, o la estructura <code>Move</code> habitual.  Un tipo enumerado tradicional se puede representar como un caso especial de un tipo de datos algebraico: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  Es posible averiguar qu√© tipo realmente tom√≥ valor en un caso particular utilizando la coincidencia de patrones: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  En forma de tipos de datos algebraicos, Rust implementa tipos tan importantes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Option</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Result</code></a> , que se utilizan para representar el valor faltante y el resultado correcto / err√≥neo, respectivamente.  As√≠ es como se define la <code>Option</code> en la biblioteca est√°ndar: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust no tiene un valor nulo, al igual que los molestos errores de una llamada inesperada.  En cambio, donde es realmente necesario indicar la posibilidad de un valor faltante, <code>Option</code> usa la <code>Option</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  El tipo de datos algebraicos es una herramienta poderosa y expresiva que abre la puerta al desarrollo impulsado por tipos.  Un programa escrito de manera competente en este paradigma asigna la mayor√≠a de las comprobaciones de la correcci√≥n de su trabajo al sistema de tipos.  Por lo tanto, si le falta un poco de Haskell en la programaci√≥n industrial diaria, Rust puede ser su salida.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. Refactorizaci√≥n f√°cil </h2><br><p>  El estricto sistema de tipo est√°tico desarrollado en Rust y el intento de realizar tantas verificaciones como sea posible durante la compilaci√≥n, lleva al hecho de que modificar y refactorizar el c√≥digo se vuelve bastante simple y seguro.  Si, despu√©s de los cambios, se compil√≥ el programa, esto significa que solo dej√≥ errores l√≥gicos que no estaban relacionados con la funcionalidad cuya verificaci√≥n se asign√≥ al compilador.  Combinado con la facilidad de agregar pruebas unitarias a la l√≥gica de prueba, esto lleva a serias garant√≠as de la confiabilidad de los programas y a un aumento en la confianza del programador en la operaci√≥n correcta de su c√≥digo despu√©s de realizar cambios. </p><br><hr><br><p>  Quiz√°s esto es todo de lo que quer√≠a hablar en este art√≠culo.  Por supuesto, Rust tiene muchas otras ventajas, as√≠ como una serie de inconvenientes (cierta humedad del lenguaje, falta de modismos de programaci√≥n familiares y sintaxis "no literaria"), que no se mencionan aqu√≠.  Si tiene algo que contar sobre ellos, escriba los comentarios.  En general, prueba Rust en la pr√°ctica.  Y tal vez sus ventajas para usted superen todas sus deficiencias, como sucedi√≥ en mi caso.  Y finalmente, obtendr√° exactamente el conjunto de herramientas que necesitaba durante mucho tiempo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430294/">https://habr.com/ru/post/es430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430282/index.html">9 de cada 10 personas aceptan ganar menos en trabajos m√°s significativos</a></li>
<li><a href="../es430284/index.html">El resumen de materiales interesantes para el desarrollador m√≥vil # 275 (12-18 de noviembre)</a></li>
<li><a href="../es430286/index.html">Detalles del lado desordenado y oscuro de los juegos piratas para Nintendo Switch</a></li>
<li><a href="../es430290/index.html">Un intento de predecir la cuarta iteraci√≥n del proyecto SpaceX BFR</a></li>
<li><a href="../es430292/index.html">Electronic Frontier Foundation: el rendimiento de la red de matr√≠culas de la polic√≠a de los EE. UU. Es del 0,5%</a></li>
<li><a href="../es430296/index.html">Haz que tus ideas se hagan realidad. Aplicaci√≥n sin servidor: instrucciones paso a paso</a></li>
<li><a href="../es430300/index.html">Microservicios en Go con el kit Go: Introducci√≥n</a></li>
<li><a href="../es430302/index.html">Una introducci√≥n a ptrace o inyecci√≥n de c√≥digo en sshd por diversi√≥n</a></li>
<li><a href="../es430304/index.html">Un maravilloso puesto avanzado en √≥rbita</a></li>
<li><a href="../es430306/index.html">El primer t√∫nel de la Compa√±√≠a Aburrida perforado por Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>