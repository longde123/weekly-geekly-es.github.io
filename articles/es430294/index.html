<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚈 👨🏽‍🔬 🤛🏿 10 beneficios obvios de usar Rust 🏂🏼 🧙 🍛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust es un lenguaje de programación de sistemas joven y ambicioso. Implementa la administración automática de memoria sin un recolector de basura y ot...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>10 beneficios obvios de usar Rust</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430294/"><p>  Rust es un lenguaje de programación de sistemas joven y ambicioso.  Implementa la administración automática de memoria sin un recolector de basura y otros gastos generales de tiempo de ejecución.  Además, el idioma predeterminado se usa en el idioma Rust, existen reglas sin precedentes para acceder a datos mutables y también se tienen en cuenta las vidas de los enlaces.  Esto le permite garantizar la seguridad de la memoria y facilita la programación de subprocesos múltiples, debido a la falta de carreras de datos. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p> Todo esto ya es bien conocido por todos los que siguen el desarrollo de las tecnologías de programación modernas al menos un poco.  Pero, ¿qué sucede si no es un programador de sistemas y no hay muchos códigos multiproceso en sus proyectos, pero todavía se siente atraído por el desempeño de Rust?  ¿Obtendrá beneficios adicionales de su uso en aplicaciones?  ¿O todo lo que él le dará además es una pelea difícil con el compilador, que lo obligará a escribir el programa para que siga constantemente las reglas del lenguaje sobre préstamos y propiedad? </p><br><p>  Este artículo ha recopilado docenas de ventajas no obvias y no especialmente publicitadas del uso de Rust, que, espero, lo ayudará a decidir la elección de este idioma para sus proyectos. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. La universalidad del lenguaje. </h2><br><p>  A pesar de que Rust se posiciona como un lenguaje para la programación del sistema, también es adecuado para resolver problemas aplicados de alto nivel.  No tiene que trabajar con punteros sin procesar a menos que lo necesite para su tarea.  La biblioteca de idiomas estándar ya ha implementado la mayoría de los tipos y funciones que pueden ser necesarios en el desarrollo de aplicaciones.  También puede conectar fácilmente bibliotecas externas y usarlas.  El sistema de tipos y la programación generalizada en Rust permiten el uso de abstracciones de un nivel bastante alto, aunque no hay soporte directo para OOP en el lenguaje. </p><br><p>  Veamos algunos ejemplos simples del uso de Rust. </p><br><p>  Un ejemplo de combinar dos iteradores en un iterador sobre pares de elementos: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><blockquote>  Nota: ¡una llamada al <code>name!(...)</code> del formato <code>name!(...)</code> es una llamada a una macro funcional.  ¡Los nombres de tales macros en Rust siempre terminan con un símbolo <code>!</code>  para que puedan distinguirse de los nombres de funciones y otros identificadores.  Los beneficios del uso de macros se discutirán a continuación. </blockquote><p>  Un ejemplo de uso de la biblioteca externa de expresiones regulares para trabajar con expresiones regulares: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Un ejemplo de la implementación del <code>Add</code> para la propia estructura <code>Point</code> para sobrecargar el operador de suma: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Un ejemplo de uso de un tipo genérico en una estructura: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  En Rust puede escribir utilidades de sistema eficientes, grandes aplicaciones de escritorio, microservicios, aplicaciones web (incluida la parte del cliente, ya que Rust puede compilarse en Wasm), aplicaciones móviles (aunque el ecosistema del lenguaje aún está poco desarrollado en esta dirección).  Tal versatilidad puede ser una ventaja para los equipos de proyectos múltiples, ya que le permite utilizar los mismos enfoques y los mismos módulos en muchos proyectos diferentes.  Si está acostumbrado al hecho de que cada herramienta está diseñada para su campo de aplicación limitado, intente ver a Rust como una caja de herramientas con la misma confiabilidad y conveniencia.  Quizás esto es exactamente lo que te estabas perdiendo. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Herramientas convenientes de construcción y gestión de dependencias </h2><br><p>  Esto claramente no se anuncia, pero muchos notan que Rust tiene uno de los mejores sistemas de gestión de dependencia y compilación disponibles en la actualidad.  Si programó en C o C ++, y la cuestión del uso indoloro de bibliotecas externas fue bastante aguda para usted, entonces usar Rust con su herramienta de compilación y el administrador de dependencia de Cargo será una buena opción para sus nuevos proyectos. </p><br><p>  Además del hecho de que Cargo descargará las dependencias para usted y administrará sus versiones, creará y ejecutará sus aplicaciones, ejecutará pruebas y generará documentación, también se puede ampliar con complementos para otras funciones útiles.  Por ejemplo, hay extensiones que le permiten a Cargo determinar las dependencias obsoletas de su proyecto, realizar análisis estáticos del código fuente, construir y volver a implementar partes del cliente de aplicaciones web y mucho más. </p><br><p>  El archivo de configuración de Cargo utiliza el lenguaje de marcado toml amigable y mínimo para describir la configuración del proyecto.  Aquí hay un ejemplo de un <code>Cargo.toml</code> configuración típico de <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  Y a continuación hay tres comandos típicos para usar Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  Con su ayuda, el código fuente se verificará en busca de errores de compilación, el ensamblaje del proyecto y el lanzamiento de las pruebas, el ensamblaje y el lanzamiento del programa para su ejecución, respectivamente. </p><br><h2 id="3-vstroennye-testy">  3. Pruebas incorporadas </h2><br><p>  Escribir pruebas unitarias en Rust es tan fácil y simple que desea hacerlo una y otra vez.  :) A menudo será más fácil escribir una prueba unitaria que intentar probar la funcionalidad de otra manera.  Aquí hay un ejemplo de funciones y pruebas para ellos: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Las funciones en el módulo de <code>test</code> , marcadas con el atributo <code>#[test]</code> , son pruebas unitarias.  Se ejecutarán en paralelo cuando se llame al comando de <code>cargo test</code> .  El atributo de compilación condicional <code>#[cfg(test)]</code> , que marca todo el módulo con pruebas, conducirá al hecho de que el módulo se compilará solo cuando se ejecuten las pruebas, pero no entrará en el ensamblaje normal. </p><br><p>  Es muy conveniente colocar las pruebas en el mismo módulo que el funcional bajo prueba, simplemente agregando el submódulo de <code>test</code> .  Y si necesita pruebas de integración, simplemente coloque sus pruebas en el directorio de <code>tests</code> en la raíz del proyecto y use su aplicación en ellas como un paquete externo.  No es necesario agregar un módulo de <code>test</code> separado y directivas de compilación condicional en este caso. </p><br><p>  Ejemplos especiales de documentación ejecutada como pruebas merecen especial atención, pero esto se discutirá a continuación. </p><br><p>  Las pruebas de rendimiento incorporadas (puntos de referencia) también están disponibles, pero aún no son estables, por lo tanto, solo están disponibles en ensamblajes nocturnos del compilador.  En Rust estable, deberá utilizar bibliotecas externas para este tipo de pruebas. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Buena documentación con ejemplos actuales. </h2><br><p>  La biblioteca estándar de Rust está muy bien documentada.  La documentación HTML se genera automáticamente a partir del código fuente con descripciones de rebajas en los comentarios del muelle.  Además, los comentarios del documento en el código Rust contienen código de muestra que se ejecuta cuando se ejecutan las pruebas.  Esto asegura la relevancia de los ejemplos: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>La documentación</em></a> </p><br><p>  Aquí hay un ejemplo del uso del método <code>as_bytes</code> de tipo <code>String</code> </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  se ejecutará como prueba durante el lanzamiento de las pruebas. </p><br><p>  Además, la práctica de crear ejemplos de su uso en forma de pequeños programas independientes ubicados en el directorio de <code>examples</code> en la raíz del proyecto es común para las bibliotecas Rust.  Estos ejemplos también son una parte importante de la documentación y también se compilan y ejecutan durante la ejecución de la prueba, pero se pueden ejecutar independientemente de las pruebas. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Autodeducción inteligente de tipos </h2><br><p>  En un programa Rust, no puede especificar explícitamente el tipo de expresión si el compilador puede generarlo automáticamente en función del contexto de uso.  Y esto se aplica no solo a aquellos lugares donde se declaran variables.  Veamos un ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Si organizamos las anotaciones de tipo, este ejemplo se verá así: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  Es decir, tenemos un vector de segmentos de cadena y una variable de tipo segmento de cadena.  Pero en este caso, la especificación de tipos es completamente redundante, ya que el compilador puede generarlos por sí mismo (usando la versión extendida del algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hindley-Milner</a> ).  El hecho de que <code>vec</code> es un vector ya está claro por el tipo del valor de retorno de <code>Vec::new()</code> , pero aún no está claro qué tipo de elementos serán.  El hecho de que el tipo de <code>text</code> sea ​​un segmento de cadena es comprensible por el hecho de que se le asigna un literal de este tipo.  Por lo tanto, después de <code>vec.push(text)</code> , el tipo de elementos vectoriales se vuelve obvio.  Tenga en cuenta que el tipo de la variable <code>vec</code> estaba completamente determinado por su uso en el hilo de ejecución, y no en la etapa de inicialización. </p><br><p>  Tal sistema de inferencia de tipos elimina el ruido del código y lo hace tan conciso como el código en algún lenguaje de programación escrito dinámicamente.  ¡Y esto mientras se mantiene una estricta escritura estática! </p><br><p>  Por supuesto, no podemos deshacernos por completo de escribir en un idioma estáticamente escrito.  El programa debe tener puntos en los que se garantice que se conocen los tipos de objetos, de modo que en otros lugares se puedan mostrar estos tipos.  Dichos puntos en Rust son declaraciones de tipos de datos definidos por el usuario y firmas de funciones, en los que uno no puede sino especificar los tipos utilizados.  Pero puede ingresar "metavariables de tipos" en ellos, utilizando la programación generalizada. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Coincidencia de patrones en puntos de declaración variables </h2><br><p>  <code>let</code> operación </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  en realidad no se limita a declarar nuevas variables.  Lo que realmente hace es unir la expresión a la derecha del signo igual con el patrón de la izquierda.  Y se pueden introducir nuevas variables como parte de la muestra (y solo así).  Eche un vistazo al siguiente ejemplo y le resultará más claro: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  La desestructuración se realizó aquí: dicha comparación introducirá las variables <code>x</code> e <code>y</code> , que se inicializarán con el valor de los campos <code>x</code> e <code>y</code> del objeto de la estructura <code>Point</code> , que se devuelve llamando a <code>Point::new()</code> .  Al mismo tiempo, la comparación es correcta, ya que el tipo de expresión a la derecha corresponde al patrón de <code>Point</code> de tipo <code>Point</code> a la izquierda.  De manera similar, puede tomar, por ejemplo, los dos primeros elementos de una matriz: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  Y mucho más por hacer.  Lo más notable es que tales comparaciones se realizan en todos los lugares donde se pueden ingresar nuevos nombres de variables en Rust, a saber: en el <code>match</code> , <code>let</code> , <code>if let</code> , <code>while let</code> <code>if let</code> , en el encabezado del bucle <code>for</code> , en los argumentos de funciones y cierres.  Aquí hay un ejemplo del uso elegante de la coincidencia de patrones en un bucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  El método de <code>enumerate</code> , llamado en el iterador, construye un nuevo iterador, que iterará no sobre los valores iniciales, sino sobre tuplas, pares "índice ordinal, valor inicial".  Cada una de estas tuplas durante la iteración del ciclo se correlacionará con el patrón especificado <code>(i, ch)</code> , como resultado de lo cual la variable <code>i</code> recibirá el primer valor de la tupla, el índice, y la variable <code>ch</code> , el segundo, es decir, el carácter de la cadena.  Además en el cuerpo del bucle podemos usar estas variables. </p><br><p>  Otro ejemplo popular de usar un patrón en un bucle <code>for</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Aquí simplemente ignoramos el valor del iterador usando el patrón <code>_</code> .  Porque no usamos el número de iteración en el cuerpo del bucle.  Lo mismo se puede hacer, por ejemplo, con un argumento de función: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  O cuando coincide en una declaración de <code>match</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  La coincidencia de patrones hace que el código sea muy compacto y expresivo, y en la declaración de <code>match</code> generalmente es insustituible.  El operador de <code>match</code> es un operador de análisis variativo completo, por lo que no podrá olvidarse accidentalmente de verificar algunas de las posibles coincidencias para la expresión analizada en él. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Extensión de sintaxis y DSL personalizado </h2><br><p>  La sintaxis de Rust es limitada, en gran parte debido a la complejidad del sistema de tipos utilizado en el lenguaje.  Por ejemplo, Rust no tiene argumentos de funciones con nombre o funciones con un número variable de argumentos.  Pero puede sortear estas y otras limitaciones con macros.  Rust tiene dos tipos de macros: declarativa y procesal.  Con las macros declarativas, nunca tendrá los mismos problemas que con las macros en C, porque son higiénicas y no funcionan a nivel de reemplazo de texto, sino a nivel de reemplazo en el árbol de sintaxis abstracta.  Las macros le permiten crear abstracciones a nivel de sintaxis del lenguaje.  Por ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  Además del hecho de que esta macro expande las capacidades sintácticas de llamar a la "función" de imprimir una cadena con formato, también en su implementación verificará que los argumentos de entrada coincidan con la cadena de formato especificada en tiempo de compilación y no en tiempo de ejecución.  Usando macros, puede ingresar una sintaxis concisa para sus propias necesidades de diseño, crear y usar DSL.  Aquí hay un ejemplo del uso de código JavaScript dentro de un programa Rust compilando en Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Macro <code>js!</code>  definido en el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>stdweb</code></a> y le permite incrustar código JavaScript completo en su programa (con la excepción de cadenas entre comillas simples y operadores no completados con punto y coma) y usar objetos del código Rust usando la sintaxis <code>@{expr}</code> . </p><br><p>  Las macros ofrecen enormes oportunidades para adaptar la sintaxis de los programas de Rust a las tareas específicas de un área temática particular.  Ahorrarán su tiempo y atención al desarrollar aplicaciones complejas.  No aumentando la sobrecarga de tiempo de ejecución, sino aumentando el tiempo de compilación.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Autogeneración de código dependiente </h2><br><p>  Las macros de derivación procesal de Rust se usan ampliamente para implementar automáticamente rasgos y otra generación de código.  Aquí hay un ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Dado que todos estos tipos ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> y <code>Eq</code> ) de la biblioteca estándar se implementan para el tipo de campos de la estructura <code>i32</code> , su implementación se puede mostrar automáticamente para toda la estructura como un todo.  Otro ejemplo: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  Aquí, utilizando las <code>Deserialize</code> y <code>Deserialize</code> de la biblioteca de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>serde</code></a> para la estructura <code>Point</code> , se generan automáticamente métodos para su serialización y deserialización.  Luego puede pasar una instancia de esta estructura a varias funciones de serialización, por ejemplo, convirtiéndola en una cadena JSON. </p><br><p>  Puede crear sus propias macros de procedimiento que generarán el código que necesita.  O use las muchas macros ya creadas por otros desarrolladores.  Además de salvar al programador de escribir código repetitivo, las macros también tienen la ventaja de que no necesita mantener diferentes secciones de código en un estado coherente.  Por ejemplo, si se agrega un tercer campo <code>z</code> a la estructura de <code>Point</code> , entonces para hacer su serialización correctamente, si usa derivar, no necesita hacer nada más.  Si nosotros mismos implementamos los rasgos necesarios para la serialización de <code>Point</code> , entonces tendremos que asegurarnos de que esta implementación siempre sea consistente con los últimos cambios en la estructura de <code>Point</code> . </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Tipo de datos algebraicos </h2><br><p>  En pocas palabras, un tipo de datos algebraicos es un tipo de datos compuesto que es una unión de estructuras.  Más formalmente, es una suma de tipos de tipos de productos.  En Rust, este tipo se define usando la palabra clave <code>enum</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  El tipo de un valor particular de una variable de tipo <code>Message</code> puede ser solo uno de los tipos de estructura enumerados en <code>Message</code> .  Esta es una estructura <code>Quit</code> campo tipo unidad, una de las estructuras de tupla <code>ChangeColor</code> o <code>Write</code> con campos sin nombre, o la estructura <code>Move</code> habitual.  Un tipo enumerado tradicional se puede representar como un caso especial de un tipo de datos algebraico: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  Es posible averiguar qué tipo realmente tomó valor en un caso particular utilizando la coincidencia de patrones: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  En forma de tipos de datos algebraicos, Rust implementa tipos tan importantes como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Option</code></a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><code>Result</code></a> , que se utilizan para representar el valor faltante y el resultado correcto / erróneo, respectivamente.  Así es como se define la <code>Option</code> en la biblioteca estándar: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  Rust no tiene un valor nulo, al igual que los molestos errores de una llamada inesperada.  En cambio, donde es realmente necesario indicar la posibilidad de un valor faltante, <code>Option</code> usa la <code>Option</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><em>Correr</em></a> </p><br><p>  El tipo de datos algebraicos es una herramienta poderosa y expresiva que abre la puerta al desarrollo impulsado por tipos.  Un programa escrito de manera competente en este paradigma asigna la mayoría de las comprobaciones de la corrección de su trabajo al sistema de tipos.  Por lo tanto, si le falta un poco de Haskell en la programación industrial diaria, Rust puede ser su salida.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. Refactorización fácil </h2><br><p>  El estricto sistema de tipo estático desarrollado en Rust y el intento de realizar tantas verificaciones como sea posible durante la compilación, lleva al hecho de que modificar y refactorizar el código se vuelve bastante simple y seguro.  Si, después de los cambios, se compiló el programa, esto significa que solo dejó errores lógicos que no estaban relacionados con la funcionalidad cuya verificación se asignó al compilador.  Combinado con la facilidad de agregar pruebas unitarias a la lógica de prueba, esto lleva a serias garantías de la confiabilidad de los programas y a un aumento en la confianza del programador en la operación correcta de su código después de realizar cambios. </p><br><hr><br><p>  Quizás esto es todo de lo que quería hablar en este artículo.  Por supuesto, Rust tiene muchas otras ventajas, así como una serie de inconvenientes (cierta humedad del lenguaje, falta de modismos de programación familiares y sintaxis "no literaria"), que no se mencionan aquí.  Si tiene algo que contar sobre ellos, escriba los comentarios.  En general, prueba Rust en la práctica.  Y tal vez sus ventajas para usted superen todas sus deficiencias, como sucedió en mi caso.  Y finalmente, obtendrá exactamente el conjunto de herramientas que necesitaba durante mucho tiempo. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es430294/">https://habr.com/ru/post/es430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es430282/index.html">9 de cada 10 personas aceptan ganar menos en trabajos más significativos</a></li>
<li><a href="../es430284/index.html">El resumen de materiales interesantes para el desarrollador móvil # 275 (12-18 de noviembre)</a></li>
<li><a href="../es430286/index.html">Detalles del lado desordenado y oscuro de los juegos piratas para Nintendo Switch</a></li>
<li><a href="../es430290/index.html">Un intento de predecir la cuarta iteración del proyecto SpaceX BFR</a></li>
<li><a href="../es430292/index.html">Electronic Frontier Foundation: el rendimiento de la red de matrículas de la policía de los EE. UU. Es del 0,5%</a></li>
<li><a href="../es430296/index.html">Haz que tus ideas se hagan realidad. Aplicación sin servidor: instrucciones paso a paso</a></li>
<li><a href="../es430300/index.html">Microservicios en Go con el kit Go: Introducción</a></li>
<li><a href="../es430302/index.html">Una introducción a ptrace o inyección de código en sshd por diversión</a></li>
<li><a href="../es430304/index.html">Un maravilloso puesto avanzado en órbita</a></li>
<li><a href="../es430306/index.html">El primer túnel de la Compañía Aburrida perforado por Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>