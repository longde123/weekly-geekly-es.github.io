<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš£ ğŸ‘¨ğŸ¿â€âš–ï¸ ğŸ‘­ Pengembangan BPM muda yang modis, modis, di Camunda ğŸ¦“ ğŸ“— ğŸ‘ƒğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengembangan BPM tidak mudah. Hal ini disebabkan oleh fakta bahwa proses tersebut harus dapat dibaca dan dimengerti oleh pelanggan, dan tidak hanya be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan BPM muda yang modis, modis, di Camunda</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tinkoff/blog/455860/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/1j/oi/yt/1joiyt3a6d_durbq0kzzzat4e04.png" alt="gambar"></div><br>  Pengembangan BPM tidak mudah.  Hal ini disebabkan oleh fakta bahwa proses tersebut harus dapat dibaca dan dimengerti oleh pelanggan, dan tidak hanya benar dari sudut pandang teknis. <br><br>  Tidak semua alat untuk mengembangkan proses bisnis memungkinkan Anda menemukan kompromi antara deskripsi yang jelas dan fungsionalitas teknis.  Banyak alat pengembangan canggih dan deskripsi proses sering memiliki satu kelemahan lagi: mereka sangat keren, kuat, dan kompleks sehingga, ketika sedang dibuat, teknologi mengambil langkah besar ke depan dan pengembangan dengan alat seperti itu menjadi tidak relevan. <br><br>  2018 secara fundamental mengubah pendekatan kami pada pengembangan proses bisnis.  Di bawah ini adalah tentang bagaimana pendekatan ini telah berkembang dan bagaimana kami telah berubah. <br><a name="habracut"></a><br><h3>  Alih-alih prolog </h3><br>  Departemen kami bergerak dalam pengembangan proses bisnis - dari yang terkecil dan terkecil hingga besar dan sangat menguntungkan.  Hingga baru-baru ini, kami menggunakan produk dari IBM untuk pengembangan, yang memungkinkan kami untuk dengan cepat meluncurkan proses bisnis yang berjalan dalam produksi. <br><br>  IBM BPM adalah platform yang kuat yang mencakup serangkaian fitur yang kaya, seperti deskripsi proses itu sendiri, formulir UI, dan modul integrasi.  Selain itu, platform ini memiliki ambang masuk yang agak rendah, yang memungkinkan pengembang pemula untuk segera membenamkan diri dalam proyek.  Tetapi produk ini juga memiliki kelemahan yaitu, jika mereka tidak menghambat pengembangan, maka tentunya tidak berkontribusi terhadap kecepatan dan kualitas: <br><br><ul><li>  Tidak ada kontrol versi waras.  IBM BPM tidak memberikan kemampuan untuk menyimpan proses (kode) dengan benar dalam repositori dan menggunakan repositori sendiri, yang tidak tahu tentang konsep seperti penggabungan, misalnya. </li><li> Berkembang di Jawa 6. Mungkin pada saat penulisan ini, sudah dimungkinkan untuk berkembang di Jawa 7, tetapi pada tahun 2019 ini sedikit menghibur. </li><li>  IBM BPM berputar di WebSphere, sebagai akibatnya, pengembang harus bersabar dengan setiap pembaruan modul mereka.  Selain itu, ini adalah sakit kepala tambahan untuk administrator yang secara berkala harus menghidupkan kembali monster ini jika hang. </li><li>  Pengembangan modul integrasi di lingkungan Designer Integrasi, yang pada kenyataannya dikaburkan bukan untuk Eclipse yang lebih baik. </li><li>  Tidak ada kemampuan pengujian unit normal. </li><li>  Tingginya biaya platform. </li></ul><br>  Kekurangan-kekurangan ini, di samping ketidaknyamanan yang murni teknis dari pembangunan, telah menciptakan masalah lain, yang mungkin jauh lebih serius daripada semua hal di atas.  Pada zaman Jawa 12, Kotlin, layanan mikro, dan tren dan karya mode lainnya, semua nuansa ini sangat menurunkan motivasi tim.  Sulit untuk mengalami kegembiraan berkembang di Designer Integrasi yang selalu menggantung untuk Java 6 pada tahun 2019. <br><br><img src="https://habrastorage.org/webt/w-/vb/nv/w-vbnvq2nttuahmxuliqqatugng.png" alt="gambar"><br><br>  Dengan semua keterbatasan ini, sulit untuk tetap bertahan.  Kurang dari setahun yang lalu, ada tawaran untuk mencoba mesin Camunda untuk menggambarkan proses bisnis.  Untuk memulainya, dipilih proses yang tidak terlalu besar, tetapi agak penting untuk mendaftarkan terminal untuk badan hukum. <br><br>  Karena kami benar-benar menulis ulang, hampir tidak ada kode lama, kami praktis tidak dapat membatasi diri pada apa pun, dan karena itu kami memilih Kotlin sebagai bahasa pengembangan.  Sangat menarik untuk mencoba bahasa baru ini, yang didengar sebagian besar untuk ulasan positif.  Pada beberapa proyek lain di departemen kami ada pengalaman implementasi yang sukses.  Tumpukan terakhir ternyata seperti ini: Camunda, Spring Boot 2, Kotlin, Postgre. <br><br><h3>  Apa itu Camunda? </h3><br><img src="https://habrastorage.org/webt/n7/jx/jk/n7jxjkzverskjq-ljwnhpabcqpu.png" alt="gambar"><br><br>  Camunda adalah platform pemodelan proses bisnis sumber terbuka yang ditulis dalam Java dan menggunakan Java sebagai bahasa pengembangan.  Ini adalah satu set perpustakaan yang memungkinkan Anda untuk melakukan proses yang dijelaskan.  Untuk mengintegrasikan Camunda ke dalam proyek, cukup tambahkan beberapa dependensi.  Untuk menyimpan proses, Anda dapat memilih dalam memori atau DBMS persisten - tergantung pada tugas.  Kami memilih Postgre, karena cerita itu penting bagi kami untuk "pembekalan."  Secara default, platform menyebarkan ke H2. <br><br>  Pengembangan terdiri dari dua bagian: membuat proses aliran dalam utilitas Camunda Modeler khusus dan menulis kode java yang memproses langkah-langkah proses yang dijelaskan dalam diagram.  Untuk memanggil kode java dari proses, cukup untuk mengimplementasikan antarmuka JavaDelegate, naikkan Bean ini (Anda dapat menentukan delagate dengan nama lengkap, tetapi melalui Bean lebih mudah dan fleksibel) dalam konteks dan tentukan idnya pada langkah proses yang diinginkan.  Di Kotlin, delegasi terlihat lebih ringkas.  Logika para delegasi cukup sederhana: mereka mengurangi sesuatu dari konteks, melakukan beberapa tindakan dan memasukkannya kembali ke dalam konteks. <br><br><img src="https://habrastorage.org/webt/vr/13/sy/vr13syiaahlc4bxpf32jay7kzg8.png" alt="gambar"><br>  <i>Jendela sembulan Camunda Modeler</i> <br><br><h4>  Contoh delegasi Java: </h4><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.DelegateExecution; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.JavaDelegate; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JavaExampleDelegate</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JavaDelegate</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DelegateExecution execution)</span></span></span><span class="hljs-function"> </span></span>{ String someVar = (String) execution.getVariable(<span class="hljs-string"><span class="hljs-string">"someVariable"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// some actions execution.setVariable("otherVariable", "otherValue"); } }</span></span></code> </pre> <br><h4>  Contoh delegasi Kotlin: </h4><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.DelegateExecution <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.camunda.bpm.engine.delegate.JavaDelegate <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KotlinExampleDelegate</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">JavaDelegate { override fun execute</span></span></span></span>(execution: DelegateExecution) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someVar = execution.getVariable(<span class="hljs-string"><span class="hljs-string">"someVariable"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//some code execution.setVariable("otherVariable", "someValue") } }</span></span></code> </pre><br>  Dalam delegasi, Anda dapat menggambarkan logika bisnis, integrasi, dan segala sesuatu yang diinginkan hati Anda. <br><br>  Kami mencoba membuat lapisan dalam bentuk komponen bisnis dengan logika, dan menggunakan delegasi hanya sebagai tautan ke aliran proses sehingga kode dan proses tersebut dicampur sesedikit mungkin. <br><br>  Dalam kebanyakan kasus, pendekatan ini mudah digunakan dan berhasil.  Interaksi dengan proses terjadi melalui DelegateExecution, yang memungkinkan, misalnya, untuk bekerja dengan konteks, insiden, dan sebagainya. <br><br><h3>  Itukah yang kami inginkan? </h3><br>  Pada awalnya, ketika memilih alat, kami mencari solusi dengan fitur-fitur berikut: <br><br><ul><li>  Pemulihan proses tepat dari tempat di mana kegagalan terjadi, dan diharapkan bahwa itu keluar dari kotak. </li><li>  Beberapa GUI tempat Anda dapat melihat apa yang terjadi pada proses secara umum. </li><li>  Kemampuan menulis tes unit tidak hanya untuk logika dan integrasi, tetapi juga untuk proses itu sendiri. </li><li>  Java 8 ke atas. </li><li>  Komunitas maju. </li></ul><br>  Camunda baik-baik saja dengan pemulihan kesalahan dan analisis. <br><br>  Jejak yang mudah dibaca, kemampuan untuk mengatur jumlah upaya untuk mengambil langkah sebelum jatuh, penangan kustom saat jatuh - misalnya, jika selama jatuh kita ingin mengubah status beberapa entitas menjadi Kesalahan.  Yang terakhir ini mudah dilakukan hanya dengan mengimplementasikan DefaultIncidentHandler.  Benar, ada momen lucu ketika pawang ini bekerja: kode pemulihan kesalahan dipicu setiap kali Anda memasuki langkah proses.  Saya tidak bisa mengatakan bahwa ini adalah super atau masalah.  Sebaliknya, Anda hanya perlu mengingat dan mempertimbangkan ini ketika berkembang. <br><br>  Kami menyelesaikannya seperti ini: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolveIncident</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(context: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">IncidentContext</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> incidentList = Context.getCommandContext().incidentManager.findIncidentByConfiguration(context.configuration) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (incidentList.isNotEmpty()) { <span class="hljs-comment"><span class="hljs-comment">//      } }</span></span></code> </pre><br>  Camunda memiliki GUI dan itu tidak buruk. <br><br>  Tetapi jika Anda ingin sedikit lebih, misalnya, migrasi instance antara versi proses, maka Anda harus bekerja keras.  UI default hanya memiliki fungsi minimal, tetapi ada API Rest yang sangat kuat yang memungkinkan Anda membuat panel admin Anda sendiri - keren dan canggih. <br><br>  Di sepanjang jalur panel admin kami, kami pergi.  Arsitek proses bisnis kami dalam waktu yang agak singkat melihatnya turun, termasuk fungsi melihat sejarah proses yang sudah selesai, migrasi antar versi, dan sebagainya. <br><br>  Camunda's Rest sangat kuat dan memungkinkan Anda melakukan apa saja dengan proses.  Misalnya, Anda dapat memulai proses menggunakan <i>/ proses-definisi / kunci / aProcessDefinitionKey / mulai dengan</i> permintaan sederhana seperti: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"variables"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"aVariable"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-string"><span class="hljs-string">"aStringValue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"String"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"anotherVariable"</span></span> : { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"Boolean"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"businessKey"</span></span> : <span class="hljs-string"><span class="hljs-string">"myBusinessKey"</span></span> }</code> </pre><br>  Contohnya diambil dari dokumentasi resmi, yang berisi uraian luas tentang berbagai kasus penggunaan API ini. <br><br>  Untuk pengujian unit, kami menggunakan Junit yang biasa.  Plus ada perpustakaan yang agak menarik untuk menguji proses itu sendiri - 'org.camunda.bpm.extension', nama: 'camunda-bpm-assert'.  Dengan itu, Anda dapat mendeskripsikan tes untuk memverifikasi proses aliran. <br><br>  Ini cukup nyaman, karena seringkali lebih sulit untuk mencari masalah dengan bug yang mengalir daripada dalam kode.  Pengujian semacam itu melindungi, misalnya, dari refactoring yang tidak akurat dan sangat membantu kami beberapa kali. <br><br>  Kebutuhan untuk Java 8 sebagian telah hilang, karena penggunaan Kotlin pada banyak proses menghilangkan kebutuhan untuk G8.  Kotlin sangat cocok dengan proyek dan memungkinkan Anda untuk fokus hanya pada penulisan logika bisnis.  Sulit dipercaya, tetapi pada dasarnya semua yang Kotlin katakan tentang kesejukan itu benar.  Entitas dengan sejumlah besar bidang, yang dikenal untuk hampir semua aplikasi dengan integrasi, sekarang tidak terlihat begitu menakutkan, dan pemetaan antar entitas menjadi jauh lebih mudah dibaca.  Seringkali dikritik null safety benar-benar berfungsi dan membantu dalam banyak kasus. <br><br>  Komunitas di Camunda cukup berkembang.  Ini dibuktikan oleh fakta bahwa pustaka baru di GitHub terus muncul untuk pengujian dan metrik. <br><br>  Sangat menyenangkan bahwa Camunda terintegrasi sempurna dengan Spring.  Tambahkan dependensi yang diperlukan, beberapa anotasi dan beberapa konfigurasi kacang - pada kenyataannya, itu semua integrasi!  Sebagai hasilnya, kami menulis aplikasi pegas reguler yang digunakan semua orang, menambahkan alur proses bisnis.  Interaksi berlangsung melalui Java API, yang memungkinkan Anda untuk memanipulasi proses dari kode java. <br><br>  Misalnya, Anda dapat memulai proses hanya dengan satu perintah: <br><br><pre> <code class="kotlin hljs">runtimeService.startProcessInstanceByKey( <span class="hljs-string"><span class="hljs-string">"MyTestProcess"</span></span>, <span class="hljs-string"><span class="hljs-string">"MyBusinessKey"</span></span>, mapOf( <span class="hljs-string"><span class="hljs-string">"key1"</span></span> to <span class="hljs-string"><span class="hljs-string">"value1"</span></span>, <span class="hljs-string"><span class="hljs-string">"key2"</span></span> to <span class="hljs-string"><span class="hljs-string">"value2"</span></span>, ) )</code> </pre><br>  Di sini MyTestProcess adalah Id-shnik dari proses, bukan turunannya.  MyBusinessKey adalah kunci unik untuk instance proses yang sedang berjalan.  Kami biasanya menggunakan beberapa nilai bisnis untuk bidang ini - untuk navigasi yang lebih cepat antara instance dan pencarian. <br><br>  Dengan cara yang hampir sama, Anda dapat membangunkan proses "mengantuk". <br><br>  Minus yang terlihat atau masalah apa pun yang kami temui, khususnya tidak dapat ditarik kembali.  Akibatnya, untuk jangka waktu yang cukup singkat, itu ternyata menjadi proses yang sepenuhnya bekerja dan aman membawanya ke dalam produksi.  Proses lain sedang dilaksanakan pada platform dan cukup berhasil.  Sekarang di Camunda kami telah meluncurkan sekitar 15 aplikasi di mana sekitar 100 ribu proses berputar sekaligus. <br><br><img src="https://habrastorage.org/webt/w_/zz/rt/w_zzrtmrhavm1i-wld62ymbclng.png" alt="gambar"><br><br><h3>  Alih-alih sebuah epilog </h3><br>  Berikut adalah beberapa sumber yang telah membantu dalam mengimplementasikan tumpukan yang dijelaskan di atas.  Saya sarankan Anda membacanya jika Anda tertarik dengan informasi tambahan tentang topik tersebut. <br><br><ul><li>  Camunda didokumentasikan dengan baik - kami menemukan sebagian besar kasus yang diperlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam dokumentasi resmi</a> . </li><li>  Rincian lebih lanjut tentang platform, kasus menarik dan umumnya tentang bpm <a href="">dapat dilihat di saluran ini</a> .  Itu dipimpin oleh rekan kami, yang menyarankan menggunakan Camunda. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Laporan</a> bagus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari Pavel Finkelstein tentang implementasi Kotlin</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455860/">https://habr.com/ru/post/id455860/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455850/index.html">Kotak Alat untuk Peneliti - Edisi Ketiga: Mencari dan Bekerja dengan Sumber</a></li>
<li><a href="../id455852/index.html">Pengangkatan sinus dan implantasi simultan</a></li>
<li><a href="../id455854/index.html">Bagaimana menerapkan Menu Konteks di iOS 13</a></li>
<li><a href="../id455856/index.html">Suhu nirkabel, kelembaban dan sensor tekanan atmosfer pada nRF52832</a></li>
<li><a href="../id455858/index.html">Jaringan TV kabel untuk yang terkecil. Bagian 9: Headend</a></li>
<li><a href="../id455862/index.html">Apa yang Baru di AWS: DATA API, Analisis Data Kinesis, S3 Path</a></li>
<li><a href="../id455868/index.html">Mengatasi Hukum Moore: Teknologi Transistor Masa Depan</a></li>
<li><a href="../id455872/index.html">Taruhan apa yang dibuat Bezos pada tahun 1997 sehingga Amazon sekarang memegang 50% pasar e-commerce di AS dan 14% di dunia?</a></li>
<li><a href="../id455874/index.html">Prosedur pemberitahuan untuk aplikasi Electron untuk macOS 10.14.5</a></li>
<li><a href="../id455878/index.html">Skenario untuk penggunaan analitik video dalam ritel. Mengikuti jejak Video Analytics di Retail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>