<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöΩ üñïüèº üõÉ Intervalos: A pr√≥xima evolu√ß√£o do C ++ üêÅ üé® üòñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O padr√£o C ++ 20 aparecer√° em breve, no qual, provavelmente, o conceito de intervalos ser√° adicionado, mas poucas pessoas sabem o que s√£o e com o que ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Intervalos: A pr√≥xima evolu√ß√£o do C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/440388/">  O padr√£o C ++ 20 aparecer√° em breve, no qual, provavelmente, o conceito de <i>intervalos</i> ser√° adicionado, mas poucas pessoas sabem o que s√£o e com o que comem.  N√£o consegui encontrar fontes de l√≠ngua russa acess√≠veis sobre esta fera, e √© por isso que neste artigo gostaria de lhe contar mais sobre ela, com base em uma palestra de Arno Sch√∂dl <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"De Iteradores a Intervalos: A Pr√≥xima Evolu√ß√£o do STL"</a> da Conference Meeting C ++ 2015- do ano.  Tentarei deixar este artigo o mais claro poss√≠vel para aqueles que encontrarem esse conceito pela primeira vez e, ao mesmo tempo, falarei sobre todos os tipos de chips, como adaptadores de intervalo, para aqueles que j√° est√£o familiarizados com esse conceito e desejam saber mais. <br><br><h2>  Bibliotecas com intervalos </h2><br>  No momento da reda√ß√£o deste artigo, existem tr√™s bibliotecas principais que implementam intervalos: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Boost.range</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Range v3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">biblioteca p√∫blica do think-cell</a> </li></ul><br>  A primeira biblioteca, de fato, √© a progenitora desse conceito (o que n√£o √© surpreendente, porque n√£o h√° nada na cole√ß√£o de bibliotecas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Boost</a> :)).  A segunda √© a biblioteca de Eric Niebler, que ser√° descrita mais adiante.  E, finalmente, a √∫ltima biblioteca, como voc√™ pode imaginar, foi escrita pelo think-cell, que, podemos dizer, desenvolveu e melhorou o Boost.Range. <br><a name="habracut"></a><br><h2>  Por que intervalos √© o nosso futuro? </h2><br>  Para aqueles que n√£o est√£o familiarizados com o conceito de intervalo, definimos esse conceito n√£o trivial como aquele que tem um come√ßo e um fim (um <u>par de iteradores</u> ). <br><br>  Vamos agora considerar a seguinte tarefa: existe um vetor, √© necess√°rio remover todos os elementos repetidos dele.  Sob o padr√£o atual, resolver√≠amos assim: <br><br><pre><code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; vec=...; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::sort( vec.begin(), vec.end() ); vec.erase( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique( vec.begin(), vec.end() ), vec.end() );</code> </pre> <br>  Nesse caso, indicamos o nome do vetor em at√© <b>6</b> vezes!  No entanto, usando o conceito de intervalos (combinando iteradores no in√≠cio e no final do vetor em um objeto), podemos escrever muitas vezes mais facilmente especificando o vetor desejado apenas <b>uma vez</b> : <br><br><pre> <code class="cpp hljs">tc::unique_inplace( tc::sort(vec) );</code> </pre> <br><h2>  Quais dos intervalos est√£o atualmente dentro do padr√£o atual? </h2><br>  No padr√£o C ++ 11, um loop baseado em intervalo e acesso universal ao in√≠cio / fim de cont√™ineres foram adicionados e, no √∫ltimo padr√£o C ++ 17, nada de novo relacionado a intervalos foi adicionado. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&amp; i : &lt;range_expression&gt; ) { ... }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin/end(&lt;range_expression&gt;)</code> </pre> <br><h2>  Intervalos futuros </h2><br>  Vamos agora nos debru√ßar sobre a biblioteca Range V3 mencionada anteriormente.  Eric Nibler, seu criador, como seu projeto em casa, criou a <i>Especifica√ß√£o t√©cnica da gama</i> , modificando a biblioteca de <i>algoritmos</i> para suportar intervalos.  Parece algo como isto: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ranges { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> What &gt; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>) find( Rng &amp;&amp; rng, What <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; what ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find( ranges::begin(rng), ranges::end(rng), what ); } }</code> </pre> <br>  Em seu site, h√° uma pr√©via do que ele deseja padronizar, esse √© o <i>Range V3</i> . <br><br><h2>  O que pode ser considerado? </h2><br>  Primeiro de tudo, <i>cont√™ineres</i> (vetor, string, lista etc.), porque eles t√™m um come√ßo e um fim.  √â claro que os cont√™ineres t√™m seus pr√≥prios elementos, ou seja, quando nos referimos a cont√™ineres, ent√£o nos referimos a todos os seus elementos.  Da mesma forma, ao copiar e declarar uma constante (c√≥pia profunda e consist√™ncia).  Em segundo lugar, as <i>visualiza√ß√µes</i> tamb√©m podem ser consideradas intervalos.  As visualiza√ß√µes s√£o apenas um par de iteradores apontando para o in√≠cio e o fim, respectivamente.  Aqui est√° a implementa√ß√£o mais simples: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> It&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_range</span></span></span><span class="hljs-class"> {</span></span> It m_itBegin; It m_itEnd; <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itBegin; } <span class="hljs-function"><span class="hljs-function">It </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_itEnd; } };</code> </pre> <br>  As visualiza√ß√µes, por sua vez, referem-se apenas aos elementos, portanto, a c√≥pia e a consist√™ncia s√£o pregui√ßosas (isso n√£o afeta os elementos). <br><br><h2>  Adaptadores de intervalo </h2><br>  Os inventores de intervalos n√£o pararam nisso, porque, caso contr√°rio, esse conceito seria bastante in√∫til.  Portanto, eles introduziram um conceito como adaptadores de alcance. <br><br><h3>  Transformar adaptador </h3><br>  Considere a seguinte tarefa: seja dado um vetor <i>int</i> , no qual precisamos encontrar o primeiro elemento igual a 4: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find(v, <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  Agora vamos imaginar que o tipo do vetor n√£o seja int, mas algum tipo de estrutura auto-escrita complexa, mas na qual existe um int e a tarefa ainda √© a mesma: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find_if( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.id == <span class="hljs-number"><span class="hljs-number">4</span></span>; } );</code> </pre> <br>  √â claro que esses dois c√≥digos s√£o semelhantes na sem√¢ntica, no entanto, diferem significativamente na sintaxe, porque no √∫ltimo caso, tivemos que escrever manualmente uma fun√ß√£o que √© executada no campo <i>int</i> .  Mas se voc√™ usar um adaptador de transforma√ß√£o ( <i>adaptador de transforma√ß√£o</i> ), tudo parecer√° muito mais sucinto: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v={...}; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre><br>  De fato, o adaptador de transforma√ß√£o "transforma" nossa estrutura criando uma classe de wrapper em torno do campo int.  √â claro que o ponteiro aponta para o campo <i>id</i> , mas se queremos que ele aponte para toda a estrutura, precisamos adicionar no final de <i>.base ()</i> .  Este comando encapsula o campo, pelo qual o ponteiro pode percorrer toda a estrutura: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = ranges::find( tc::transform(v, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mem_fn(&amp;A::id)), <span class="hljs-number"><span class="hljs-number">4</span></span>).base();</code> </pre><br>  Aqui est√° um exemplo de implementa√ß√£o de um adaptador de transforma√ß√£o (consiste em iteradores, cada um dos quais com seu pr√≥prio functor): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">transform_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//    decltype( tc::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; public: decltype(auto) operator*() const { return m_func(*m_it); } decltype(auto) base() const { return (m_it); } ... }; };</span></span></code> </pre><br><h3>  Adaptador de filtro </h3><br>  E se na √∫ltima tarefa precisamos encontrar n√£o o primeiro elemento desse tipo, mas "filtrar" <b>todo o</b> campo de <i>ints</i> pela presen√ßa de tais elementos?  Nesse caso, usar√≠amos um adaptador de filtro: <br><br><pre> <code class="cpp hljs">tc::filter( v, [](A <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> == a.id; } );</code> </pre><br>  Observe que o filtro √© executado lentamente durante as itera√ß√µes. <br><br>  E aqui est√° sua implementa√ß√£o ing√™nua (algo como isso √© implementado no Boost.Range): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Func m_func; <span class="hljs-comment"><span class="hljs-comment">//     decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_it; decltype( ranges::begin(std::declval&lt;Base&amp;&gt;()) ) m_itEnd; public: iterator&amp; operator++() { ++m_it; while( m_it != m_itEnd &amp;&amp; !static_cast&lt;bool&gt;(m_func(*m_it)) ) ++m_it; return *this; } ... }; };</span></span></code> </pre><br>  Como podemos ver, dois iteradores s√£o necess√°rios aqui em vez de um, como no adaptador de transforma√ß√£o.  O segundo iterador √© necess√°rio para n√£o ir al√©m dos limites do cont√™iner acidentalmente durante as itera√ß√µes. <br><br><h2>  Algumas otimiza√ß√µes </h2><br>  Ok, mas como √© o iterador de <b>tc :: filter (tc :: filter (tc :: filter (...)))</b> ? <br><br><h3>  Boost.range </h3><br>  Como parte da implementa√ß√£o acima, √© assim: <br><br><div class="spoiler">  <b class="spoiler_title">Os fracos de cora√ß√£o n√£o assistem!</b> <div class="spoiler_text"> <code>m_func3 <br> m_it3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd3 <br> m_func2 <br> m_it2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br> m_itEnd2 <br> m_func1 <br> m_it1; <br> m_itEnd1; <br></code> <br></div></div><br>  Obviamente, isso √© <u>terrivelmente</u> ineficiente. <br><br><h3>  Range v3 </h3><br>  Vamos pensar em como otimizar esse adaptador.  A ideia de Eric Nibler era colocar informa√ß√µes gerais (um functor e um ponteiro para o final) no objeto adaptador, e ent√£o podemos armazenar um link para esse objeto adaptador e o iterador desejado <br> <code>*m_rng <br> m_it <br></code> <br>  Ent√£o, sob essa implementa√ß√£o, um filtro triplo ser√° algo como isto: <br><br><div class="spoiler">  <b class="spoiler_title">Tyk</b> <div class="spoiler_text"> <code>m_rng3 <br> m_it3 <br> m_rng2 <br> m_it2 <br> m_rng1 <br> m_it1 <br></code> <br></div></div><br>  Isso ainda n√£o √© perfeito, embora √†s vezes seja mais r√°pido que a implementa√ß√£o anterior. <br><br><h3>  think-cell, conceito de √≠ndice </h3><br>  Agora considere a solu√ß√£o think-cell.  Eles introduziram o chamado <i>conceito de √≠ndice</i> para resolver esse problema.  Um √≠ndice √© um iterador que executa as mesmas opera√ß√µes que um iterador regular, mas faz isso consultando intervalos. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">index_range</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = ...; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Index </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decrement_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">reference </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dereference</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... };</code> </pre><br>  Mostramos como combinar um √≠ndice com um iterador regular. <br><br>  √â claro que um iterador regular tamb√©m pode ser considerado um √≠ndice.  Na dire√ß√£o oposta, a compatibilidade pode ser implementada, por exemplo, da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; iterator&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++() { m_rng.increment_index(m_idx); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } ... };</code> </pre><br>  Em seguida, o filtro triplo ser√° implementado de maneira super eficiente: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">filter_range</span></span></span><span class="hljs-class"> {</span></span> Func m_func; Base&amp; m_base; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Index = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::Index; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Index&amp; idx )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m_base.increment_index(idx); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( idx != m_base.end_index() &amp;&amp; !m_func(m_base.dereference_index(idx)) ); } };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iterator_for_index</span></span></span><span class="hljs-class"> {</span></span> IndexRng* m_rng; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> IndexRng::Index m_idx; ... };</code> </pre><br>  Na estrutura dessa implementa√ß√£o, o algoritmo funcionar√° rapidamente, independentemente da profundidade do filtro. <br><br><h2>  Intervalos com cont√™ineres lvalue e rvalue </h2><br>  Agora vamos ver como os intervalos funcionam com os cont√™ineres lvalue e rvalue: <br><br><h3>  lvalue </h3><br>  O intervalo V3 e o think-cell se comportam da mesma forma com lvalue.  Suponha que tenhamos c√≥digo como este: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(vec, pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Aqui temos um vetor declarado anteriormente que est√° na mem√≥ria (lvalue) e precisamos criar um intervalo e, de alguma forma, trabalhar com ele.  Criamos uma view usando <i>view :: filter</i> ou <i>tc :: filter</i> e ficamos felizes, n√£o h√° erros, e podemos usar essa view, por exemplo, em any_of. <br><br><h3>  Faixa V3 e rvalue </h3><br>  No entanto, se nosso vetor ainda n√£o estivesse na mem√≥ria (por exemplo, se apenas o criassemos) e ter√≠amos enfrentado a mesma tarefa, tentar√≠amos escrever e encontramos um erro: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = view::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre><br>  Por que surgiu?  O View ser√° um link dangling para o rvalue devido ao fato de criarmos um vetor e o colocarmos diretamente em um filtro, ou seja, haver√° um link de rvalue no filtro, que apontar√° para algo desconhecido quando o compilador for para a pr√≥xima linha e ocorrer um erro.  Para resolver esse problema, o Range V3 apresentou a seguinte <i>a√ß√£o</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = action::filter(create_vector(), pred1); <span class="hljs-comment"><span class="hljs-comment">//   bool b = ranges::any_of(rng, pred2);</span></span></code> </pre> <br>  A a√ß√£o faz tudo de uma vez, ou seja, simplesmente pega um vetor, filtra por predicado e o coloca em um intervalo.  No entanto, o ponto negativo √© que ele n√£o √© mais pregui√ßoso, e o think-cell tentou corrigir esse ponto negativo. <br><br><h3>  think-cell e rvalue </h3><br>  O Think-cell fez com que, em vez de visualizar, um cont√™iner fosse criado: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> rng = tc::filter(creates_vector(), pred1); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = ranges::any_of(rng, pred2);</code> </pre><br>  Como resultado, n√£o encontramos um erro semelhante, porque, na implementa√ß√£o deles, o filtro coleta o cont√™iner rvalue em vez do link, o que ocorre pregui√ßosamente.  O intervalo V3 n√£o queria fazer isso porque temiam que houvesse erros devido ao filtro se comportar como uma exibi√ß√£o ou como um cont√™iner, no entanto, a think-cell est√° convencida de que os programadores entendem como o filtro se comporta e a maioria dos erros surge justamente por causa dessa "pregui√ßa". <br><br><h2>  Intervalos do gerador </h2><br>  Generalizamos o conceito de intervalos.  De fato, existem intervalos sem iteradores.  Eles s√£o chamados de <i>faixas de gerador</i> .  Suponha que tenhamos um widget da GUI (um elemento da interface) e chamamos um widget de movimenta√ß√£o.  Temos uma janela que pede para mover seu widget, tamb√©m temos um bot√£o na <i>caixa de listagem</i> e outra janela tamb√©m deve rolar por seus widgets, ou seja, chamamos <i>traverse_widgets</i> , que conecta os elementos a um functor ( <i>voc√™ pode dizer que h√° uma fun√ß√£o de enumera√ß√£o em que voc√™ conecte o functor, e a fun√ß√£o lista todos os elementos que ele possui neste functor</i> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Func&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">traverse_widgets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Func func )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window1) { window1-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } func(button1); func(listbox1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (window2) { window2-&gt;traverse_widgets(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(func)); } }</code> </pre><br>  Isso lembra o espa√ßamento entre widgets, mas n√£o h√° iteradores aqui.  Escrever diretamente seria ineficiente e, acima de tudo, muito dif√≠cil.  Nesse caso, podemos dizer que essas estruturas tamb√©m s√£o consideradas intervalos.  Ent√£o, nesses casos, h√° um uso de m√©todos de intervalo √∫teis, como <i>any_of</i> : <br><br><pre> <code class="cpp hljs">mouse_hit_any_widget=tc::any_of( [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> func) { traverse_widgets(func); }, [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; widget) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> widget.mouse_hit(); } );</code> </pre><br>  O think-cell tenta implementar m√©todos para que eles tenham a mesma interface para todos os tipos de intervalos: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tc { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Rng &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_of</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Rng </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> bResult = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tc::enumerate( rng, [&amp;](bool_context b) { bResult = bResult || b; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bResult; } }</code> </pre><br>  Usando <i>tc :: enumerate</i> , a diferen√ßa entre os intervalos fica oculta, pois essa implementa√ß√£o adere ao conceito de <i>itera√ß√£o interna</i> (que os conceitos de <i>itera√ß√£o</i> <i>externa</i> e <i>interna</i> s√£o descritos com mais detalhes na palestra); no entanto, essa implementa√ß√£o tem suas desvantagens, a saber: <i>std :: any_of</i> p√°ra assim que <i>true</i> for encontrado.  Eles tentam resolver esse problema, por exemplo, adicionando exce√ß√µes (os chamados <i>intervalos de gerador interrompidos</i> ). <br><br><h2>  Conclus√£o </h2><br>  Eu odeio o loop for baseado em intervalo, porque motiva as pessoas a escrev√™-lo sempre que necess√°rio e onde n√£o √© necess√°rio, por causa de que a concis√£o do c√≥digo geralmente piora, por exemplo, as pessoas escrevem isso: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n : rng) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( is_prime(n) ) { b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  em vez disso: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> b = tc::any_of( rng, is_prime );</code> </pre> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt440388/">https://habr.com/ru/post/pt440388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt440374/index.html">Fun√ß√µes Yandex enviam email</a></li>
<li><a href="../pt440376/index.html">20 jogos para ensinar a programa√ß√£o do seu filho</a></li>
<li><a href="../pt440378/index.html">Voltar aos microsservi√ßos com Istio. Parte 2</a></li>
<li><a href="../pt440382/index.html">200 √© bom ou ruim?</a></li>
<li><a href="../pt440386/index.html">Liberando a manipula√ß√£o de erros eliminando erros</a></li>
<li><a href="../pt440390/index.html">O mundo diversificado dos sistemas embarcados e o lugar da Embox nele</a></li>
<li><a href="../pt440392/index.html">WebRTC no seu site - sem bugs e sem or√ßamento</a></li>
<li><a href="../pt440394/index.html">Escalonamento de privil√©gios do PostgreSQL - an√°lise CVE-2018-10915</a></li>
<li><a href="../pt440398/index.html">Hist√≥rico de participa√ß√£o (e vit√≥ria) na Russian AI Cup 2018 - CodeBall</a></li>
<li><a href="../pt440400/index.html">Apache Kafka + Spring Boot: Ol√°, microsservi√ßos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>