<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📛 🔞 🍨 Und wieder können CAPTCHA oder Nginx auch sticken 🙎 👩🏼‍🤝‍👨🏻 🍤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einleitung 


 Ich ging nach Habr und fand in Entwürfen einen unveröffentlichten Artikel über Captcha. Ich wollte ihn formalisieren und veröffentliche...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Und wieder können CAPTCHA oder Nginx auch sticken</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485804/"><h2>  Einleitung </h2><br><p>  Ich ging nach Habr und fand in Entwürfen einen unveröffentlichten <a href="https://postgres.men/web/nginx/nginx-fast-captcha/">Artikel</a> über Captcha. Ich wollte ihn formalisieren und veröffentlichen, beschloss aber, einen neuen Artikel zu schreiben, indem ich den Mechanismus und die verwendeten Werkzeuge leicht änderte.  Meiner Meinung nach wird es nützlich sein, einen alten Artikel zu lesen, es wird nicht schlimmer sein. </p><br><p>  Das Hauptziel beim Schreiben eines neuen Artikels ist es nicht einmal, einen anderen Arbeitsmechanismus aufzuzeigen, wie sehr man die Fähigkeiten von Nginx zeigt, die manchmal völlig vergessen sind, wenn man es als banalen Proxyserver betrachtet. </p><a name="habracut"></a><br><h2>  Bedingungen </h2><br><p>  Um zu verhindern, dass Bots Dateien herunterladen, wird ein Test-Captcha verwendet. </p><br><p>  Wenn Sie ein Formular für einen Dateisprung erstellen, wird ein Bild mit einem Code und bestimmten Verzerrungen erstellt, um die automatische Erkennung zu erschweren.  Es gibt auch Speicherplatz für die Festlegung eines Schlüssel-Code-Paares zur Überprüfung. </p><br><p>  Nach Bestätigung des Formulars zum Herunterladen der Datei und Überprüfung des Captcha auf die Entsprechung des Codes wird die Datei dem Benutzer übergeben oder ein eindeutiger einmaliger Link zur Datei erstellt.  Die Eindeutigkeit des Links wird auch vom Backend gesteuert.  Das Schlüssel-Code-Paar wird ebenfalls entfernt, um seine Wiederverwendung zu verhindern. </p><br><p>  Es gibt einen Proxy, der alle Anfragen an das Backend weiterleitet. </p><br><h2>  Die Probleme </h2><br><p>  Die komplexe Bilderzeugung ist eine ziemlich ressourcenintensive Operation, und da nicht alle gezeigten Codes verwendet werden.  Es muss eine Art Caching-Mechanismus erstellt werden, damit nicht verwendete Bilder anderen Benutzern angezeigt werden können. </p><br><p>  Der Code und der Schlüssel werden vom Backend überprüft, aber es gibt Schwierigkeiten beim Übertragen großer Dateien über das Backend. Einmalige Verknüpfungen müssen auch auf Backend-Ebene überprüft werden. Ich möchte die zusätzliche Last auf ihnen loswerden. </p><br><h2>  Lösung </h2><br><h3>  Wählen Sie die Funktionalität </h3><br><p>  Tatsächlich besteht das Captcha selbst aus einem Bild und einem bestimmten Schlüssel, der dem Code im Bild entspricht, der im Backend gespeichert ist.  Das Bild ist nicht sehr groß, und wir übersetzen es in Base64 und geben entweder ein Stück Form: </p><br><pre><code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"data:image/png;base64,{{ IMAGE CODE BASE64 }}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hidden"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"key"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{{ KEY }}"</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Oder JSON: </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"data"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"image"</span></span>: <span class="hljs-string"><span class="hljs-string">"data:image/png;base64,{{ IMAGE CODE BASE64 }}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"key"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{ KEY }}"</span></span> } }</code> </pre> <br><p>  Wenn ein Teil des Formulars erstellt wird, können wir es mit <a href="http_ssi_module.html">SSI</a> in den Hauptteil der Seite einfügen. Dazu aktivieren wir den entsprechenden Modus in der Nginx-Konfiguration auf dem Proxy: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">ssi</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>;</code> </pre> <br><p>  Und in den Code der Formularseite fügen wir ein: </p><br><pre> <code class="xml hljs">... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"download"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"get"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">...</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-comment"><span class="hljs-comment">&lt;!--#include virtual="/x/captcha/generate"--&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span> ...</code> </pre><br><p>  Aus diesem Grund haben wir die Funktionen zum Zuordnen von Captcha in separate <i>Positionen</i> oder Methoden aufgeteilt.  Jetzt können Sie das Caching durchführen. </p><br><blockquote>  Ja, der <i>Server Side Include (SSI)</i> -Mechanismus ist fast vergessen, aber das Nginx-Modul ist lebendiger als alle lebenden und funktioniert sehr schnell.  Übrigens: Wenn proxy_pass_cache <i>die</i> gesamte Seite zwischenspeichert, wird das Ergebnis von <i>include virtual</i> nicht zwischengespeichert, sondern bei jeder Anforderung ausgeführt.  Auf diese Weise können Sie die Einfügung dynamisch gestalten. </blockquote><br><h3>  CAPTCHA CAPTCHA </h3><br><p>  Um das <i>Cachen</i> zu implementieren, benötigen wir etwas ziemlich Zufälliges, das durch die Anzahl der Optionen gesteuert wird. Die Variable <i>$ request_id</i> ist für diese Rolle geeignet. Sie ist ziemlich zufällig und hexadezimal, <i>dh</i> Sie können durch Auswahl eines bestimmten Teils dieser Variablen die Anzahl der Cache-Elemente auf 16 ^ n begrenzen n - die Anzahl der Zeichen, die wir von der Variablen nehmen müssen.  Also: </p><br><p>  Bestimmen Sie die Cache-Zone: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_path</span></span> /cache/nginx/captcha levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> keys_zone=captcha:<span class="hljs-number"><span class="hljs-number">10m</span></span> max_size=<span class="hljs-number"><span class="hljs-number">128m</span></span>;</code> </pre> <br><p>  Es ist wichtig zu bestimmen, welchen Wert von n wir wählen bzw. welche Parameter davon abhängen: </p><br><ul><li>  Stufen = 1: 2 </li><li>  max_size = 128 m </li><li>  keys_zone = captcha: 10m </li></ul><br><p>  Das war genug für alles, aber nichts war überflüssig.  Als nächstes bestimmen wir den Cache-Schlüssel: </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$captcha_salt</span></span> <span class="hljs-string"><span class="hljs-string">'salt'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$request_id</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* "(\w</span></span>{4})$" ) { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span>; } ...</code> </pre> <br><p>  Die <i>Variable $ captcha_salt</i> ist für uns immer noch nützlich, schützt aber jetzt vor möglichen Schlüsselüberschneidungen.  Ich habe n als 4 gewählt, was 16 ^ 4 Cache-Slots bedeutet, wobei jedem Slot durchschnittlich 2 <i>KB</i> aus der Gesamt-Cache-Größe ( <i>max_size = 128 m</i> ) <i>zugewiesen werden. Dies</i> sollte ausreichen, da Sie sonst die maximale Größe erhöhen müssen. </p><br><p>  Den richtigen <i>Ort finden</i> </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/generate { <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache</span></span> captcha; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">365d</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> any <span class="hljs-number"><span class="hljs-number">0s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-string"><span class="hljs-string">"captcha.service.domain.my"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://captcha_upstream/?cache_key=<span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span>; }</code> </pre> <br><p>  Die "guten" Backend-Antworten werden fast für immer zwischengespeichert, der Rest wird nicht zwischengespeichert.  Und ja, Sie können die Funktionalität der Arbeit mit Captcha sofort in einem separaten Dienst hervorheben. </p><br><blockquote>  Übrigens kann ein ähnlicher Mechanismus verwendet werden, um eine Pseudodynamik zu bilden, wenn der Benutzer F5 drückt und jedes Mal, wenn ihm ein neues zufälliges "Bild" gezeigt wird.  In diesem Fall ist das Backend praktisch nicht geladen. </blockquote><br><p>  Wir müssen auch den entsprechenden Cache zurücksetzen, wenn wir das Formular überprüfen. <i>Daher</i> muss das Backend unter anderem den Wert <i>cache_key angeben</i> , damit er als <i>verstecktes</i> Feld an das Formular zurückgegeben wird.  Leider ist die <i>proxy_cache_purge-</i> Direktive nur in der kommerziellen Version verfügbar.  Es spielt keine Rolle, dass es ein <a href="https://github.com/FRiCKLE/ngx_cache_purge">cache_purge-</a> Modul eines Drittanbieters <a href="https://github.com/FRiCKLE/ngx_cache_purge">gibt</a> , das zwar etwas einfacher ist, aber für uns ausreicht.  <i>Speicherort</i> für das Leeren des Caches: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/cache/purge { internal; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_cache_key</span></span></span><span class="hljs-string">"</span></span>; }</code> </pre> <br><p>  Es hat die <i>interne</i> Richtlinie, da wir sie nicht öffentlich verwenden werden.  <a href="http_mirror_module.html">Um</a> diesen <i>Speicherort</i> aufzurufen <i>, verwenden</i> wir die <i>mirror-</i> Direktive des <a href="http_mirror_module.html">http_mirror_module-</a> Moduls: </p><br><p>  Das heißt, wir fordern parallel dazu an, den Cache mit dem Schlüssel der Variablen <i>$ arg_cache_key zurückzusetzen</i> , der im Formular übertragen wird.  Als nächstes haben wir die Anfrage an unser Backend weitergeleitet, wo der Rest der Verarbeitung durchgeführt wird. </p><br><h3>  Der dornige Weg der Optimierung </h3><br><p>  Hier wollte ich eigentlich ein Thema entwickeln: Wie trenne ich die Überprüfung des Captcha-Codes und die Rückgabe der Datei?  Verhindert, dass der Cache bei falschen Anforderungen gelöscht wird.  Dann immer mehr zu optimieren, aber es kommt darauf an, dass wir das Backend im Allgemeinen nicht mehr brauchen ... überhaupt ... weil wir schon alles haben. </p><br><p>  Die Aufgabe, die bei der Captcha-Überprüfung auf dem Server verbleibt, besteht darin, den Schlüssel + Code zu überprüfen und dieses Paar aus dem Repository zu entfernen.  Das Überprüfen des Schlüssels + Codes kann ein einfacher Vergleich der md5-Menge mit dem Schlüssel sein.  Dafür reicht uns ein Modul: <a href="http_secure_link_module.html">http_secure_link_module</a> .  Das heißt, der Schlüssel kann als Formel dargestellt werden: </p><br> <code>key = md5_baseurl( salt + code )</code> <br> <p>  Gleichzeitig schadet das Binden an den Cache-Slot (Cache-Schlüssel) nicht, wir fügen es hinzu: </p><br> <code>key = md5_baseurl( salt + code + cache_key )</code> <br> <p>  Wir haben salt - das ist die Variable <i>$ captcha_salt</i> (so hat es sich als nützlich <i>erwiesen</i> ), aber das salt an zwei Stellen des Backends und des Proxys <i>aufzubewahren</i> ist schlecht, also lasst uns das machen: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/salt { <span class="hljs-section"><span class="hljs-section">allow</span></span> {{ <span class="hljs-attribute"><span class="hljs-attribute">captcha</span></span> backend IPs }}; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">"</span></span>; }</code> </pre> <br><p>  Und lassen Sie das Backend zum Proxy für das Salz gehen. </p><br><p>  Die Frage bleibt beim Speicher, in dem wir ein Schlüssel-Code-Paar speichern, das bereinigt werden muss.  Hierzu eignet sich für uns der bereits implementierte Caching-Mechanismus.  Das einzige, was wir tun, ist, dass wir das <i>cache_purge-</i> Ergebnis in <i>keiner Weise verarbeiten</i> , sondern einfach die Anfrage dafür spiegeln, aber das ist korrigierbar.  Und ja, das rechtfertigt die Verwendung eines Cache-Schlüssels beim Erstellen eines Captcha-Schlüssels. </p><br><h3>  Code überprüfen </h3><br><p>  Rewrite <i>Location</i> File Downloads: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download { <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Context download; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-File-Name <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Key <span class="hljs-variable"><span class="hljs-variable">$arg_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Code <span class="hljs-variable"><span class="hljs-variable">$arg_code</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Cache-Key <span class="hljs-variable"><span class="hljs-variable">$arg_cache_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/check; <span class="hljs-attribute"><span class="hljs-attribute">proxy_intercept_errors</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> = /download/fail; }</code> </pre> <br><p>  Ich übergebe die erforderlichen Parameter mit Überschriften.  Dies ist optional, aber für mich bequemer.  Wir übermitteln die Verarbeitung an den lokalen Speicherort der Captcha-Prüfung.  Zusätzlich wird <i>context = download</i> übergeben, so dass wir im Handler abhängig davon das eine oder andere Ergebnis erzeugen können.  In diesem Fall kann der Handler entweder zu uns zurückkehren: </p><br><ul><li>  403 - Codeüberprüfungsfehler.  Daher wird <i>proxy_intercept_errors</i> eingeschlossen und ein Speicherort für die Umleitung im Falle eines Fehlers deklariert. </li><li>  404 - Cache-Bereinigungsfehler.  Das <i>cache_purge-</i> Modul gibt 404 zurück, wenn sich mit einem solchen Schlüssel nichts im Cache befindet. </li><li>  200 + <i>Accel-Redirect</i> - am <i>Speicherort des</i> Datei-Uploads, falls die Captcha-Prüfung erfolgreich war.  In unserem Fall ist dies <i>X-Accel-Redirect: / store / file</i> </li></ul><br><blockquote>  Wenn <i>error_page 2XX-</i> Codes <i>verarbeiten</i> könnte, könnte man das alleine tun.  Andernfalls müssen Sie den <i>Accel-Redirect-</i> Mechanismus verwenden.  Wenn Sie wirklich möchten, können Sie die Fehlerbehandlungsroutinen 403 und 404 trennen. </blockquote><br><p>  Einen einfachen <i>Standortfehler machen</i> : </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download/fail { internal; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL DOWNLOAD"</span></span>; }</code> </pre> <br><p>  Sie können alles an diesem Ort zurückgeben, je nach Ihren Bedürfnissen. </p><br><p>  Wir machen den Ort des Dateiuploads: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /store/file { internal; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Content-Disposition <span class="hljs-string"><span class="hljs-string">"attachment; filename=\"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_filename</span></span></span><span class="hljs-string">\""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">alias</span></span> /spool/tmp/; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span> =<span class="hljs-number"><span class="hljs-number">404</span></span>; }</code> </pre> <br><p>  Erstens ist es wichtig, dass es sich um eine <i>interne</i> Datei handelt. Dies bedeutet, dass Sie die Datei nur durch Umleitung direkt herunterladen können.  Es kann auch je nach Bedarf geändert werden und die lokale Datei nicht weitergeben, sondern die Anforderung für den Dateispeicherdienst per Proxy weiterleiten. </p><br><p>  Den folgenden <i>Speicherort haben</i> wir für die Captcha-Überprüfung: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">secure_link_md5</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_code</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secure_link</span></span> <span class="hljs-variable"><span class="hljs-variable">$http_x_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$secure_link</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL CHECK CODE"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/purge; }</code> </pre> <br><p>  Es hat 2 Blöcke: Codeüberprüfung und Proxy-Zugriff, um den Cache zu leeren.  Wenn die Codeüberprüfung nicht bestanden wurde, wird sofort 403 zurückgegeben (der Text ist unwichtig, da er nicht weiter verwendet wird). </p><br><p>  Wenn Sie nach <i>/ x / captcha / purge gehen,</i> werden 2 Antwortoptionen zurückgegeben: </p><br><ul><li>  200 + <i>Accel-Redirect</i> - bei erfolgreicher Cache-Leerung.  Die Weiterleitung erfolgt zu <i>X-Accel-Redirect: / x / captcha / check / ok</i> ; </li><li>  404 - wenn es nichts zu reinigen gäbe.  Dieses Ergebnis wird oben an <i>/ download übergeben</i> und dort verarbeitet. <i>Error_page</i> ; </li></ul><br><p>  Ein separater Handler für die positive Antwort von <i>/ x / captcha / purge</i> wird erstellt, da zunächst eine höhere Proxy-Ebene erreicht werden muss und nicht zwischen <i>/ download</i> und <i>/ x / captcha / check</i> .  Zweitens wäre es schön, eine positive Antwort zum Kontext zu geben. </p><br><p>  Beginnen wir mit einem positiven Response-Handler: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check/ok { internal; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$http_x_context</span></span> = <span class="hljs-string"><span class="hljs-string">'download'</span></span> ) { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/store/file?filename=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_file_name</span></span></span><span class="hljs-string">"</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; }</code> </pre> <br><p>  Tatsächlich können wir abhängig vom Wert der Variablen <i>$ http_x_context</i> ( <i>X-Context-</i> Header) bestimmen, welche <i>Accel-Redirect</i> mit <i>/ x / captcha / check</i> antwortet.  Dies bedeutet, dass Sie diesen Mechanismus nicht nur zum Herunterladen der Datei verwenden können. </p><br><p>  Das Leeren des Caches ist ganz einfach: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/purge { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/x/captcha/check/ok"</span></span>; }</code> </pre> <br><p>  Im Allgemeinen ist das alles, am Ende haben wir die folgende Nginx-Konfiguration: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_path</span></span> /cache/nginx/captcha levels=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> keys_zone=captcha:<span class="hljs-number"><span class="hljs-number">10m</span></span> max_size=<span class="hljs-number"><span class="hljs-number">128m</span></span>; <span class="hljs-section"><span class="hljs-section">server</span></span> { ... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download { <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Context download; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-File-Name <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Key <span class="hljs-variable"><span class="hljs-variable">$arg_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Code <span class="hljs-variable"><span class="hljs-variable">$arg_code</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> X-Cache-Key <span class="hljs-variable"><span class="hljs-variable">$arg_cache_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/check; <span class="hljs-attribute"><span class="hljs-attribute">proxy_intercept_errors</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">error_page</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-number"><span class="hljs-number">404</span></span> = /download/fail; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /download/fail { internal; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL DOWNLOAD"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /store/file { internal; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> Content-Disposition <span class="hljs-string"><span class="hljs-string">"attachment; filename=\"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$arg_filename</span></span></span><span class="hljs-string">\""</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">alias</span></span> /spool/tmp/; <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$arg_filename</span></span> =<span class="hljs-number"><span class="hljs-number">404</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$captcha_salt</span></span> <span class="hljs-string"><span class="hljs-string">'salt'</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$request_id</span></span> <span class="hljs-regexp"><span class="hljs-regexp">~* "(\w</span></span>{4})$" ) { <span class="hljs-attribute"><span class="hljs-attribute">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/generate { <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache</span></span> captcha; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_key</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">:</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">365d</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_valid</span></span> any <span class="hljs-number"><span class="hljs-number">0s</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-string"><span class="hljs-string">"captcha.service.domain.my"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://captcha_upstream/?cache_key=<span class="hljs-variable"><span class="hljs-variable">$cache_key</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/salt { <span class="hljs-section"><span class="hljs-section">allow</span></span> {{ <span class="hljs-attribute"><span class="hljs-attribute">captcha</span></span> backend IPs }}; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-string">"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">secure_link_md5</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$captcha_salt</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_code</span></span></span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">secure_link</span></span> <span class="hljs-variable"><span class="hljs-variable">$http_x_key</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (<span class="hljs-variable"><span class="hljs-variable">$secure_link</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">403</span></span> <span class="hljs-string"><span class="hljs-string">"FAIL CHECK CODE"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">proxy_set_header</span></span> Host <span class="hljs-variable"><span class="hljs-variable">$host</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">proxy_pass</span></span> http://127.0.0.1/x/captcha/purge; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/check/ok { internal; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> ( <span class="hljs-variable"><span class="hljs-variable">$http_x_context</span></span> = <span class="hljs-string"><span class="hljs-string">'download'</span></span> ) { <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/store/file?filename=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_file_name</span></span></span><span class="hljs-string">"</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">return</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-string"><span class="hljs-string">"OK"</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /x/captcha/purge { <span class="hljs-attribute"><span class="hljs-attribute">allow</span></span> <span class="hljs-number"><span class="hljs-number">127.0.0.1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">deny</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">proxy_cache_purge</span></span> captcha <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$http_x_cache_key</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">add_header</span></span> X-Accel-Redirect <span class="hljs-string"><span class="hljs-string">"/x/captcha/check/ok"</span></span>; } }</code> </pre> <br><p>  Was Sie beachten sollten: <br></p><ul><li>  Accel-Redirect funktioniert nur, wenn der Antwortstatus 2XX ist.  Leider ist nirgendwo etwas darüber geschrieben worden, und Nginx-Anhänger sind anderer Meinung. </li><li>  Private <i>Standorte in der</i> Nähe <i>erlauben</i> entweder <i>127.0.0.1;</i>  <i>leugne alles;</i>  entweder <i>intern;</i>  Je nachdem, ob wir über <i>proxy_pass</i> oder über <i>Accel-Redirect</i> an diesen <i>Speicherort</i> gelangen. </li><li>  Alle mit dem Captcha verknüpften <i>Stellen</i> werden in <i>/ x / capcha / ... hervorgehoben,</i> damit ein Microservice erstellt werden kann. </li></ul><br><p>  Zur Verdeutlichung habe ich auch ein Diagramm der Arbeit gezeichnet: </p><br><img src="https://habrastorage.org/getpro/habr/post_images/245/8bc/6c8/2458bc6c8defdbbf6f6f0bcfccb0f05a.png" alt="Bild"><br><h2>  Zusammenfassung </h2><br><p>  Aus diesem Grund müssen wir vom Backend aus nur das Bild und den Code dafür direkt generieren.  Den Rest kann Nginx problemlos erledigen.  Natürlich handelt es sich hierbei um relativ einfache logische Operationen, dies wird jedoch die Arbeit erheblich beschleunigen und die Belastung des Backends verringern.  Tatsächlich verwendeten wir keine ungewöhnlichen Mechanismen, sondern nur: </p><br><ul><li>  proxy_cache; </li><li>  Accel-Redirect </li><li>  error_page; </li><li>  secure_link </li><li>  cache_purge; </li></ul><br><p>  Der Rest ist der korrekte Aufbau logischer Ketten. </p><br><p>  Wir haben auch das temporäre Backend-Repository für Codes und einmalige Links entfernt.  Sie machten jedoch ein obligatorisches Element des Nginx-Systems und erhöhten sein Funktionsgewicht. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de485804/">https://habr.com/ru/post/de485804/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de485790/index.html">Interviews: Erwartungen vs. Realität</a></li>
<li><a href="../de485792/index.html">Ivan Lilekvist und Kim Dotkom, ein großes Interview: Die Geschichte von Megaupload, Auslieferung an die Vereinigten Staaten, Freiheit, Bitcoin. Teil 2</a></li>
<li><a href="../de485794/index.html">Entwickeln Sie auf .NET Core? Gehen wir zu Ubuntu, ich habe alles vorbereitet</a></li>
<li><a href="../de485796/index.html">Löse das Unlösbare</a></li>
<li><a href="../de485800/index.html">Digitalisierung vs. Automatisierung</a></li>
<li><a href="../de485806/index.html">Koronaviren: von SARS bis 2019-nCoV</a></li>
<li><a href="../de485810/index.html">Elixir-Hooks zur Kompilierungszeit</a></li>
<li><a href="../de485812/index.html">7 Stufen der Evolutionstests in einem Unternehmen</a></li>
<li><a href="../de485820/index.html">Sehr angegriffene Person: Finden Sie heraus, wer das Hauptziel von Cyberkriminellen in Ihrem Unternehmen ist.</a></li>
<li><a href="../de485824/index.html">Wie man einen Bot macht, der ein Foto in einen Comic verwandelt. Teil drei. Kostenloses serverloses + GPU-Hosting-Modell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>