<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚û°Ô∏è üíÜ üç∏ Servicemitarbeiter im Slack Client: On Download-Beschleunigung und Offline-Modus üà∂ üï¢ ü•ê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist der Geschichte √ºber die Optimierung der neuen Version des Slack- Desktop-Clients gewid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Servicemitarbeiter im Slack Client: On Download-Beschleunigung und Offline-Modus</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/468409/">  Das Material, dessen √úbersetzung wir heute ver√∂ffentlichen, ist der Geschichte √ºber die Optimierung der neuen Version des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Slack-</a> Desktop-Clients gewidmet, deren zentrales Merkmal die Beschleunigung des Ladens war. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/yq/fs/2h/yqfs2hg85qatg9osvxq8onvkhue.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Hintergrund</font> </h2><br>  Zu Beginn der Arbeiten an der neuen Version des Slack-Desktop-Clients wurde ein Prototyp erstellt, der als ‚Äûschnelle Stiefel‚Äú bezeichnet wurde.  Das Ziel dieses Prototyps war, wie Sie sich vorstellen k√∂nnen, den Download so weit wie m√∂glich zu beschleunigen.  Mithilfe der HTML-Datei aus dem CDN-Cache, der im Voraus gespeicherten Redux-Speicherdaten und des Servicemitarbeiters konnten wir die Light-Version des Clients in weniger als einer Sekunde laden (zu diesem Zeitpunkt betrug die √ºbliche Downloadzeit f√ºr Benutzer mit 1-2 Arbeitsbereichen etwa 5 Sekunden )  Der Servicemitarbeiter war das Zentrum dieser Beschleunigung.  Dar√ºber hinaus ebnete er den Weg f√ºr M√∂glichkeiten, die Slack-Benutzer h√§ufig umsetzen sollten.  Wir sprechen √ºber den Offline-Modus des Clients.  Mit dem Prototyp konnten wir buchst√§blich mit einem Auge sehen, wozu der neu erstellte Client in der Lage sein kann.  Basierend auf den oben genannten Technologien haben wir begonnen, den Slack-Client zu verarbeiten, uns das Ergebnis grob vorzustellen und uns darauf zu konzentrieren, den Download zu beschleunigen und den Offline-Modus des Programms zu implementieren.  Lassen Sie uns dar√ºber sprechen, wie der Kern des aktualisierten Clients funktioniert. <br><br><h2>  <font color="#3AC1EF">Was ist ein Servicemitarbeiter?</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Service Worker</a> ist im Wesentlichen ein leistungsstarkes Proxy-Objekt f√ºr Netzwerkanforderungen, mit dem der Entwickler mithilfe einer kleinen Menge JavaScript-Code steuern kann, wie der Browser einzelne HTTP-Anforderungen verarbeitet.  Servicemitarbeiter unterst√ºtzen eine erweiterte und flexible Caching-API, die so konzipiert ist, dass Anforderungsobjekte als Schl√ºssel und Antwortobjekte als Werte verwendet werden.  Service Worker werden wie Web Worker in ihren eigenen Prozessen au√üerhalb des Hauptthreads zur Ausf√ºhrung von JavaScript-Code in einem beliebigen Browserfenster ausgef√ºhrt. <br><br>  Service Worker ist ein Anh√§nger des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anwendungscaches</a> , der jetzt veraltet ist.  Es handelte sich um eine Reihe von APIs, die von der <code>AppCache</code> Schnittstelle dargestellt wurden und zum Erstellen von Websites verwendet wurden, die Offline-Funktionen implementieren.  Bei der Arbeit mit <code>AppCache</code> wurde eine statische Manifestdatei verwendet, die die Dateien beschreibt, die der Entwickler f√ºr die Offline-Verwendung zwischenspeichern m√∂chte.  Im Gro√üen und Ganzen waren die <code>AppCache</code> Funktionen <code>AppCache</code> beschr√§nkt.  Dieser Mechanismus war einfach, aber nicht flexibel, was dem Entwickler keine besondere Kontrolle √ºber den Cache gab.  Bei W3C wurde dies bei der Entwicklung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Service Worker-Spezifikation</a> ber√ºcksichtigt.  Infolgedessen erm√∂glichen Servicemitarbeiter dem Entwickler, viele Details zu jeder von einer Webanwendung oder Website durchgef√ºhrten Netzwerkinteraktionssitzung zu verwalten. <br><br>  Als wir anfingen, mit dieser Technologie zu arbeiten, war Chrome der einzige Browser, der sie unterst√ºtzte, aber wir wussten, dass nicht viel Zeit blieb, um auf eine umfassende Unterst√ºtzung f√ºr Servicemitarbeiter zu warten.  Jetzt ist diese Technologie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºberall</a> und wird von allen g√§ngigen Browsern unterst√ºtzt. <br><br><h2>  <font color="#3AC1EF">Wie wir Servicemitarbeiter einsetzen</font> </h2><br>  Wenn ein Benutzer zum ersten Mal einen neuen Slack-Client startet, laden wir einen vollst√§ndigen Satz von Ressourcen (HTML, JavaScript, CSS, Schriftarten und Sounds) herunter und platzieren sie im Cache des Servicemitarbeiters.  Au√üerdem erstellen wir eine Kopie des Redux-Speichers im Speicher und schreiben diese Kopie in die IndexedDB-Datenbank.  Wenn das Programm das n√§chste Mal gestartet wird, pr√ºfen wir, ob entsprechende Caches vorhanden sind.  Wenn dies der Fall ist, verwenden wir sie beim Herunterladen der Anwendung.  Wenn der Benutzer mit dem Internet verbunden ist, laden wir nach dem Starten der Anwendung die neuesten Daten herunter.  Wenn nicht, bleibt der Client betriebsbereit. <br><br>  Um zwischen den beiden oben genannten Optionen zum Laden des Clients zu unterscheiden, haben wir ihnen die Namen gegeben: hei√üer (warmer) und kalter (kalter) Download.  Der Kaltstart eines Clients tritt am h√§ufigsten auf, wenn der Benutzer das Programm zum ersten Mal startet.  In dieser Situation sind keine zwischengespeicherten Ressourcen oder Redux-Daten gespeichert.  Mit einem Hotboot haben wir alles, was Sie brauchen, um den Slack-Client auf dem Computer des Benutzers auszuf√ºhren.  Bitte beachten Sie, dass die meisten bin√§ren Ressourcen (Bilder, PDFs, Videos usw.) √ºber den Browser-Cache verarbeitet werden (diese Ressourcen werden durch regul√§re Caching-Header gesteuert).  Ein Servicemitarbeiter sollte sie nicht auf besondere Weise verarbeiten, damit wir offline mit ihnen arbeiten k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e2/86c/d90/3e286cd909ec21f50aec8152ac59baf1.png"></div><br>  <i><font color="#999999">Die Wahl zwischen hei√üer und kalter Beladung</font></i> <br><br><h2>  <font color="#3AC1EF">Lebenszyklus von Servicemitarbeitern</font> </h2><br>  Servicemitarbeiter k√∂nnen drei Lebenszyklusereignisse verarbeiten.  Diese werden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">installiert</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">abgerufen</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktiviert</a> .  Im Folgenden werden wir dar√ºber sprechen, wie wir auf jedes dieser Ereignisse reagieren. Zun√§chst m√ºssen wir jedoch √ºber das Herunterladen und Registrieren des Servicemitarbeiters selbst sprechen.  Der Lebenszyklus h√§ngt davon ab, wie der Browser die Aktualisierungen der Service Worker-Dateien verarbeitet.  Folgendes k√∂nnen Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDN</a> dar√ºber lesen: ‚ÄûDie Installation ist abgeschlossen, wenn die heruntergeladene Datei als neu erkannt wird.  Dies kann entweder eine Datei sein, die sich von der vorhandenen unterscheidet (der Unterschied zwischen den Dateien wird durch einen Byte-Vergleich ermittelt), oder eine Service-Worker-Datei, die der Browser auf der verarbeiteten Seite zum ersten Mal gefunden hat. ‚Äú <br><br>  Jedes Mal, wenn wir die entsprechende JavaScript-, CSS- oder HTML-Datei aktualisieren, wird das benutzerdefinierte Webpack-Plugin durchlaufen, das ein Manifest mit einer Beschreibung der entsprechenden Dateien mit eindeutigen Hashes erstellt ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier ein</a> abgek√ºrztes Beispiel f√ºr eine Manifestdatei).  Dieses Manifest ist in den Service Worker-Code eingebettet, wodurch der Service Worker beim n√§chsten Start aktualisiert wird.  Dar√ºber hinaus erfolgt dies auch dann, wenn sich die Implementierung des Servicemitarbeiters nicht √§ndert. <br><br><h3>  <font color="#3AC1EF">‚ñçEreignisereignis</font> </h3><br>  Jedes Mal, wenn ein Servicemitarbeiter aktualisiert wird, wird ein <code>install</code> angezeigt.  Als Antwort darauf gehen wir die Dateien durch, deren Beschreibungen in dem im Service Worker integrierten Manifest enthalten sind, laden sie jeweils und platzieren sie im entsprechenden Cache-Block.  Die Dateispeicherung wird mithilfe der neuen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Cache-</a> API organisiert, die Teil der Service Worker-Spezifikation ist.  Diese API speichert <code>Response</code> Verwendung von <code>Request</code> als Schl√ºssel.  Als Ergebnis stellt sich heraus, dass die Speicherung erstaunlich einfach ist.  Es passt gut dazu, wie Service-Worker-Ereignisse Anforderungen empfangen und Antworten zur√ºckgeben. <br><br>  Schl√ºssel zum Zwischenspeichern von Bl√∂cken werden basierend auf der Bereitstellungszeit der L√∂sung zugewiesen.  Der Zeitstempel ist in den HTML-Code eingebettet. Daher kann er als Teil des Dateinamens in der Anforderung zum Herunterladen jeder Ressource gesendet werden.  Das separate Zwischenspeichern von Ressourcen von jeder Bereitstellung ist wichtig, um zu vermeiden, dass inkompatible Ressourcen gemeinsam genutzt werden.  Dank dessen k√∂nnen wir sicher sein, dass die urspr√ºnglich heruntergeladene HTML-Datei nur kompatible Ressourcen herunterl√§dt. Dies gilt sowohl f√ºr das Herunterladen √ºber das Netzwerk als auch f√ºr das Herunterladen aus dem Cache. <br><br><h3>  <font color="#3AC1EF">‚ñçEvent holen</font> </h3><br>  Nachdem der Servicemitarbeiter registriert wurde, beginnt er mit der Verarbeitung aller Netzwerkanforderungen, die zur selben Quelle geh√∂ren.  Ein Entwickler kann es nicht schaffen, dass einige Anforderungen von einem Servicemitarbeiter verarbeitet werden, andere nicht.  Der Entwickler hat jedoch die volle Kontrolle dar√ºber, was genau mit den vom Servicemitarbeiter eingegangenen Anforderungen zu tun ist. <br><br>  Bei der Bearbeitung einer Anfrage pr√ºfen wir diese zun√§chst.  Wenn das Angeforderte im Manifest vorhanden ist und sich im Cache befindet, geben wir die Antwort auf die Anforderung zur√ºck, indem wir die Daten aus dem Cache entnehmen.  Wenn der Cache nicht √ºber das verf√ºgt, was Sie ben√∂tigen, geben wir eine echte Netzwerkanforderung zur√ºck, die auf die reale Netzwerkressource zugreift, als w√§re der Servicemitarbeiter √ºberhaupt nicht an diesem Prozess beteiligt.  Hier ist eine vereinfachte Version unseres <code>fetch</code> : <br><br><pre> <code class="javascript hljs">self.addEventListener(<span class="hljs-string"><span class="hljs-string">'fetch'</span></span>, (e) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (assetManifest.includes(e.request.url) {    e.respondWith(      caches        .open(cacheKey)        .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cache</span></span></span><span class="hljs-function"> =&gt;</span></span> cache.match(e.request))        .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {          <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response;          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(e.request);        });    );  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    e.respondWith(fetch(e.request));  } });</code> </pre> <br>  In der Realit√§t enth√§lt ein solcher Code viel mehr Slack-spezifische Logik, aber der Kern unseres Handlers ist so einfach wie in diesem Beispiel. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/86d/f94/1cf86df942a3064ac14c75cc47220fc1.png"></div><br>  <i><font color="#999999">Bei der Analyse von Netzwerkinteraktionen werden die vom Service Worker zur√ºckgegebenen Antworten an der ServiceWorker-Markierung in der Spalte erkannt, die die Datenmenge angibt</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñçEvent aktivieren</font> </h3><br>  Das <code>activate</code> wird nach der erfolgreichen Installation eines neuen oder aktualisierten Servicemitarbeiters ausgel√∂st.  Wir verwenden es, um zwischengespeicherte Ressourcen zu analysieren und Cache-Bl√∂cke ung√ºltig zu machen, die √§lter als 7 Tage sind.  Dies ist eine bew√§hrte Methode, um das System in Ordnung zu halten. Au√üerdem k√∂nnen Sie sicherstellen, dass beim Laden des Clients keine zu alten Ressourcen verwendet werden. <br><br><h2>  <font color="#3AC1EF">Client-Code, der hinter der neuesten Version zur√ºckbleibt</font> </h2><br>  M√∂glicherweise haben Sie bemerkt, dass unsere Implementierung impliziert, dass jeder, der den Slack-Client nach dem ersten Start des Clients startet, nicht die neuesten, sondern zwischengespeicherten Ressourcen erh√§lt, die w√§hrend der vorherigen Registrierung des Servicemitarbeiters geladen wurden.  In der urspr√ºnglichen Client-Implementierung haben wir versucht, den Service Worker nach jedem Download zu aktualisieren.  Ein typischer Slack-Benutzer kann jedoch beispielsweise ein Programm nur einmal am Tag morgens herunterladen.  Dies kann dazu f√ºhren, dass er st√§ndig mit einem Kunden zusammenarbeitet, dessen Code f√ºr den ganzen Tag hinter der neuesten Version zur√ºckbleibt (wir ver√∂ffentlichen mehrmals t√§glich neue Versionen). <br><br>  Im Gegensatz zu einer typischen Website, die beim Besuch schnell verlassen wird, ist der Slack-Client auf dem Computer des Benutzers stundenlang ge√∂ffnet und befindet sich im ge√∂ffneten Zustand.  Infolgedessen hat unser Code eine ziemlich lange Lebensdauer, weshalb wir spezielle Ans√§tze verwenden m√ºssen, um seine Relevanz zu erhalten. <br><br>  Gleichzeitig bem√ºhen wir uns sicherzustellen, dass Benutzer mit den neuesten Versionen des Codes arbeiten, damit sie die neuesten Funktionen, Fehlerbehebungen und Leistungsverbesserungen erhalten.  Kurz nachdem wir einen neuen Client ver√∂ffentlicht haben, haben wir einen Mechanismus implementiert, mit dem wir die L√ºcke zwischen dem, mit dem Benutzer arbeiten, und dem, was wir ver√∂ffentlicht haben, schlie√üen k√∂nnen.  Wenn nach dem letzten Update eine neue Version des Systems bereitgestellt wurde, laden wir neue Ressourcen, die beim n√§chsten Start des Clients verwendet werden.  Wenn nichts Neues gefunden werden kann, wird nichts geladen.  Nachdem diese √Ñnderung am Client vorgenommen wurde, wurde die durchschnittliche Lebensdauer der Ressourcen, mit denen der Client geladen wurde, halbiert. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc5/6bd/544/bc56bd544f49378516f608c8e4e321f9.png"></div><br>  <i><font color="#999999">Neue Versionen des Codes werden regelm√§√üig heruntergeladen, beim Herunterladen des Programms wird jedoch nur die neueste Version verwendet</font></i> <br><br><h2>  <font color="#3AC1EF">New Feature Flags Sync</font> </h2><br>  Mit Hilfe von Flags neuer Features (Feature Flags) markieren wir in der Codebasis die Arbeiten, an denen noch nicht abgeschlossen wurde.  Dies erm√∂glicht es uns, neue Funktionen vor ihrer Ver√∂ffentlichung in den Code aufzunehmen.  Dieser Ansatz verringert das Risiko von Produktionsfehlern, da neue Funktionen zusammen mit dem Rest der Anwendung frei getestet werden k√∂nnen, lange bevor die Arbeiten an ihnen abgeschlossen sind. <br><br>  Neue Funktionen in Slack werden normalerweise freigegeben, wenn sie √Ñnderungen an den entsprechenden APIs vornehmen.  Bevor wir Servicemitarbeiter einsetzten, hatten wir die Garantie, dass neue Funktionen und √Ñnderungen in der API immer synchronisiert werden.  Nachdem wir jedoch begonnen hatten, den Cache zu verwenden, der m√∂glicherweise nicht die neueste Version des Codes enth√§lt, stellte sich heraus, dass sich der Client m√∂glicherweise in einer Situation befindet, in der der Code nicht mit den Backend-Funktionen synchronisiert ist.  Um dieses Problem zu l√∂sen, werden nicht nur Ressourcen, sondern auch einige API-Antworten zwischengespeichert. <br><br>  Die Tatsache, dass Servicemitarbeiter absolut alle Netzwerkanforderungen verarbeiten, hat die L√∂sung vereinfacht.  Bei jedem Update des Service Workers f√ºhren wir unter anderem API-Anforderungen aus und speichern Antworten im selben Cache-Block wie die entsprechenden Ressourcen.  Dies verbindet F√§higkeiten und experimentelle Funktionen mit den richtigen Ressourcen - m√∂glicherweise veraltet, aber garantiert konsistent miteinander. <br><br>  Dies ist in der Tat nur die Spitze des Eisbergs der M√∂glichkeiten, die dem Entwickler dank Servicemitarbeitern zur Verf√ºgung stehen.  Ein Problem, das mit dem <code>AppCache</code> Mechanismus nicht gel√∂st werden konnte oder bei dem sowohl Client- als auch Servermechanismen gel√∂st werden m√ºssten, wird einfach und nat√ºrlich mit Service Workern und der Cache-API gel√∂st. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Der Servicemitarbeiter beschleunigte das Laden des Slack-Clients, indem er die lokale Speicherung von Ressourcen organisierte, die beim n√§chsten Start des Clients einsatzbereit sind.  Das Netzwerk - die Hauptursache f√ºr Verz√∂gerungen und Unklarheiten, auf die unsere Benutzer sto√üen k√∂nnten - hat praktisch keine Auswirkungen mehr auf die Situation.  Wir haben es sozusagen aus der Gleichung entfernt.  Und wenn Sie das Netzwerk aus der Gleichung entfernen k√∂nnen, stellt sich heraus, dass Sie Offline-Funktionen im Projekt implementieren k√∂nnen.  Unsere Unterst√ºtzung f√ºr den Offline-Modus ist derzeit sehr einfach.  Der Benutzer kann den Client herunterladen und Nachrichten aus heruntergeladenen Konversationen lesen.  Gleichzeitig bereitet sich das System auf Synchronisationsmarkierungen bei gelesenen Nachrichten vor.  Jetzt haben wir jedoch eine Grundlage f√ºr die k√ºnftige Implementierung fortschrittlicherer Mechanismen. <br><br>  Nach vielen Monaten der Entwicklung, des Experimentierens und der Optimierung haben wir viel dar√ºber gelernt, wie Servicemitarbeiter in der Praxis arbeiten.  Dar√ºber hinaus stellte sich heraus, dass diese Technologie f√ºr Gro√üprojekte gut geeignet ist.  In weniger als einem Monat nach der Ver√∂ffentlichung eines Kunden mit einem Servicemitarbeiter bearbeiten wir t√§glich erfolgreich Millionen von Anfragen von Millionen installierter Servicemitarbeiter.  Dies f√ºhrte zu einer Verk√ºrzung der Ladezeit neuer Kunden um etwa 50% im Vergleich zu alten Kunden und zu der Tatsache, dass das Hei√üladen etwa 25% schneller ist als das Kaltladen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e8/d46/330/9e8d463303d4002954ada304466550fd.png"></div><br>  <i><font color="#999999">Von links nach rechts: Laden eines alten Clients, Kaltladen eines neuen Clients, Hei√üladen eines neuen Clients (je niedriger der Indikator, desto besser)</font></i> <br><br>  <b>Liebe Leser!</b>  Verwenden Sie in Ihren Projekten Servicemitarbeiter? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468409/">https://habr.com/ru/post/de468409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468399/index.html">C / C ++. Verwendung eingebetteter Anwendungsressourcen bei der Arbeit in GCC unter Linux</a></li>
<li><a href="../de468401/index.html">Sichere M√∂glichkeit zum Austausch von JWT in ASP.NET Core + SPA</a></li>
<li><a href="../de468403/index.html">Integrierte Laufzeitsteuerung f√ºr Softwareanwendungen</a></li>
<li><a href="../de468405/index.html">Zwei Browser betreten irgendwie die Bildlaufleiste ...</a></li>
<li><a href="../de468407/index.html">5G - eine Technologie, die das Web wahrscheinlich verlangsamen wird</a></li>
<li><a href="../de468411/index.html">Eine Geschichte √ºber das L√∂sen des Leistungsproblems von Moment.j.</a></li>
<li><a href="../de468413/index.html">Beschleunigung instagram.com. Teil 2</a></li>
<li><a href="../de468415/index.html">Warum nicht 1C?</a></li>
<li><a href="../de468417/index.html">3CX v16 Update 3 Beta ver√∂ffentlicht - Videoanrufe auf Android und iOS, TLS-Verbindung von SIP-Amtsleitungen</a></li>
<li><a href="../de468419/index.html">Google Analytics und GDPR: Ben√∂tige ich die Zustimmung der Nutzer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>