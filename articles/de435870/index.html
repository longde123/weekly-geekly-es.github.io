<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü¶ã üîé ü§¥ Kybernetisches Orchester. Docker Container Orchestration mit .NET Core-Anwendungen in der Cloud üë®üèø‚Äçüè≠ ‚õ©Ô∏è üë©üèº‚Äç‚öñÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Um den Lastausgleich, die Skalierbarkeit und die Fehlertoleranz zu gew√§hrleisten, k√∂nnen zus√§tzliche Tools verwendet werden - Orchestratoren. Unter ih...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kybernetisches Orchester. Docker Container Orchestration mit .NET Core-Anwendungen in der Cloud</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/435870/"><p>  Um den Lastausgleich, die Skalierbarkeit und die Fehlertoleranz zu gew√§hrleisten, k√∂nnen zus√§tzliche Tools verwendet werden - Orchestratoren.  Unter ihnen ist der Kubernetes-Dienst mittlerweile sehr beliebt.  Der einfachste Weg, es in der Praxis zu versuchen, besteht darin, es in der Cloud bereitzustellen, was wir heute tun werden. </p><br><p><img src="https://habrastorage.org/webt/rx/3u/wn/rx3uwnjkkqp-6azxt-1cso7gbkc.jpeg"><a name="habracut"></a></p><br><p>  <em>Hinweis: Wir setzen die Reihe der Ver√∂ffentlichungen von Vollversionen von Artikeln aus dem Hacker-Magazin fort.</em>  <em>Rechtschreibung und Zeichensetzung des Autors gespeichert.</em> </p><br><h2>  Erweitern Sie AKS </h2><br><p>  Wir gehen zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Azure-Portal</a> , klicken auf "Ressource erstellen" und suchen einen Dienst namens Kubernetes Service. </p><br><p>  W√§hlen Sie den Namen und das Pr√§fix DNS nach Ihrem Geschmack.  Der Name beeinflusst, wie Sie auf Ihren Cluster zugreifen, das Pr√§fix wirkt sich jedoch auf die FQDN-Adresse aus. </p><br><p><img src="https://habrastorage.org/webt/fl/yt/vb/flytvbkzq8gmeefi7dqyhpkhqlm.png"></p><br><p>  Die billigste virtuelle Maschine kostet derzeit etwas mehr als 30 US-Dollar pro Monat. </p><br><p>  Der zweite Schritt besteht darin, einen Service-Principal zu erstellen.  Der Dienstprinzipal ist eine Art Dienstkonto, unter dem bestimmte Aufgaben ausgef√ºhrt werden k√∂nnen.  Der Vorteil ist, dass die Rechte eines solchen Kontos eingeschr√§nkt werden k√∂nnen.  Dar√ºber hinaus k√∂nnen Sie eine beliebige Anzahl solcher Konten erstellen (w√§hrend die Anzahl der regul√§ren Konten durch das Abonnement begrenzt ist).  Sie finden die erstellten Dienstprinzipalkonten in Active Directory unter App-Registrierungen. </p><br><img src="https://habrastorage.org/webt/9z/de/ml/9zdemlhwxmhnbcf0zg7stsmn1lc.png"><br><p>  RBAC (rollenbasierte Zugriffskontrolle) ist die F√§higkeit, den Zugriff auf bestimmte Ressourcen (oder Ressourcengruppen) einzuschr√§nken oder bereitzustellen.  Das hei√üt, Sie k√∂nnen unterscheiden, welche Benutzer Ihres Abonnements Zugriffsrechte haben und welche nicht. </p><br><img src="https://habrastorage.org/webt/9j/np/bw/9jnpbwgfkbqaydmumcpnlfroonk.png"><br><p>  Im Moment dauert der Vorgang ungef√§hr 20 Minuten, aber alles kann von der Konfiguration abh√§ngen. </p><br><p>  Finden Sie offizielle Anleitungen, indem Sie den Links folgen <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen Sie √ºber das Portal einen AKS-Cluster</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen eines AKS-Clusters mithilfe der CLI</a> </p><br><p>  Zum Arbeiten ben√∂tigen wir die Azure-Befehlszeile - CLI (Command Line Interface).  Es kann sowohl unter Windows als auch unter MacOS oder Linux installiert werden.  Pers√∂nlich bevorzuge ich die Azure Cloud Shell.  Dies ist die Befehlszeile, die von der in den Browser geladenen Azure-Portalseite ausgef√ºhrt wird.  Zum Arbeiten ist der erstellte Blob-Speicher erforderlich.  Die Kosten betragen einige Cent pro Monat und deshalb mache ich mir lieber keine Gedanken √ºber die Installation von CLI in meinem Auto. </p><br><p>  Kubernetes unterst√ºtzt verschiedene Containertechnologien, aber schauen wir uns die beliebteste an - Docker.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit docker.hub</a> k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> ein privates Docker-Image kostenlos speichern.  Wenn Sie mehr brauchen, k√∂nnen Sie sie f√ºr Geld platzieren.  F√ºr Geld kann jedoch ein privates Docker-Image in der Azure Container-Registrierung abgelegt werden.  Jetzt beginnen die Preise bei 5 USD pro Monat (f√ºr Basis-SKU). </p><br><p>  Ich habe einen ACR-Dienst unter dem Namen myservice erstellt.  Wenn Sie sich auch f√ºr die Verwendung von ACR entscheiden, m√ºssen Sie beim Erstellen eines Dienstes dessen Schl√ºssel abrufen. </p><br><img src="https://habrastorage.org/webt/nd/pi/_o/ndpi_oxqlsx4kk8q9vmtepkhiwu.png"><br><p>  Dann k√∂nnen Sie sich anmelden, indem Sie den folgenden Befehl ausf√ºhren: </p><br><pre><code class="plaintext hljs">docker login myservice.azurecr.io</code> </pre> <br><p>  Geben Sie den Benutzernamen (myservice) und das Passwort aus dem Portal ein (PJSeyO9 = lCMRDI7dGkz68wjhFGRGxSY3). </p><br><p>  Wenn Sie nun mit dem Projekt in das Verzeichnis gehen, k√∂nnen Sie ein Bild erstellen, w√§hrend Sie es mit dem gew√ºnschten Tag markieren.  Und danach senden Sie es an den Cloud-Service: </p><br><pre> <code class="plaintext hljs">docker build -t myservice.azurecr.io/myservice . docker push myservice.azurecr.io/myservice</code> </pre> <br><h2>  Geheimnisse, Geheimnisse ... Wir bieten Zugriff auf das Bild und speichern die Einstellungen. </h2><br><p>  Wenn Sie mit bereitgestelltem AKS arbeiten, m√ºssen Sie seine Credits erhalten.  Andernfalls werden kubectl-Befehle nicht ausgef√ºhrt.  Um auf AKS zuzugreifen, wird der folgende Befehl ausgef√ºhrt: </p><br><pre> <code class="plaintext hljs">az aks get-credentials --resource-group KubernetesGroup --name verycoolcluster</code> </pre> <br><p>  Um auf das Docker-Image im Docker-Repository in einem privaten Container zugreifen zu k√∂nnen, m√ºssen Sie ein Geheimnis erstellen.  Wenn Sie ein √∂ffentliches Image haben, k√∂nnen Sie diesen Schritt √ºberspringen. </p><br><p>  Um eine geheime Datei zu erstellen, m√ºssen Sie einen Befehl der folgenden Form ausf√ºhren: </p><br><pre> <code class="plaintext hljs">kubectl create secret docker-registry regcred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</code> </pre> <br><p>  Befindet sich Ihr Image im Docker-Repository, lautet der Wert von &lt;Ihr-Registrierungsserver&gt; <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://index.docker.io/v1/</a> </p><br><p>  F√ºr die Azure-Containerregistrierung lautet der vollqualifizierte Dom√§nenname &lt;Registrierungsname&gt; .azurecr.io </p><br><p>  Das hei√üt, um in meinem Fall ein Geheimnis f√ºr den Container zu schaffen, habe ich Folgendes getan: </p><br><pre> <code class="plaintext hljs">kubectl create secret docker-registry regcred --docker-server="myservice.azurecr.io" --docker-username="myservice" --docker-password="PJSeyO9=lCMRDI7dGkz68wjhFGRGxSY3" --docker-email="asommer@yandex.ru"</code> </pre> <br><p>  Sie k√∂nnen jetzt den Inhalt der erstellten geheimen Datei mit dem folgenden Befehl anzeigen: </p><br><pre> <code class="plaintext hljs">kubectl get secret regcred --output=yaml</code> </pre> <br><h1>  INFO </h1><br><p>  Wenn Sie AKS verwenden, k√∂nnen Sie keine geheime Datei erstellen, sondern dem AKS-Dienst auf andere Weise Zugriff auf den ACR-Dienst gew√§hren - indem Sie ein spezielles Skript ausf√ºhren.  Sie k√∂nnen es von der folgenden Seite nehmen: </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Authentifizieren Sie sich mit Azure Container Registry vom Azure Kubernetes Service</a> </p><br><pre> <code class="plaintext hljs">#!/bin/bash AKS_RESOURCE_GROUP=KubernetesGroup AKS_CLUSTER_NAME=verycoolcluster ACR_RESOURCE_GROUP=MyACRGroup ACR_NAME=myservice # Get the id of the service principal configured for AKS CLIENT_ID=$(az aks show --resource-group $AKS_RESOURCE_GROUP --name $AKS_CLUSTER_NAME --query "servicePrincipalProfile.clientId" --output tsv) # Get the ACR registry resource id ACR_ID=$(az acr show --name $ACR_NAME --resource-group $ACR_RESOURCE_GROUP --query "id" --output tsv) # Create role assignment az role assignment create --assignee $CLIENT_ID --role Reader --scope $ACR_ID</code> </pre> <br><p>  Sie k√∂nnen einfach die Werte der Variablen AKS <em>* und ACR</em> * √§ndern, dann das Skript kopieren und in die Azure CLI oder Cloud Shell einf√ºgen. </p><br><p>  Kubernetes enth√§lt einen sicheren Speicher f√ºr Anmeldeinformationen.  Das hei√üt, Sie k√∂nnen eine Datei mit den Einstellungen erstellen, und der Zugriff von au√üen auf diese Einstellungen ist schwierig.  Diese Datei enth√§lt normalerweise Datenbankverbindungszeichenfolgen und eine Art von Credits.  Wenn Sie solche Informationen nicht in der Anwendung haben (stimmt das?), K√∂nnen Sie diesen Schritt √ºberspringen. </p><br><p>  Um eine Einstellungsdatei √ºber die Befehlszeile zu erstellen, m√ºssen wir zuerst den Befehl vi ber√ºcksichtigen. </p><br><pre> <code class="plaintext hljs">vi &lt; &gt;</code> </pre> <br><p>  erstellt eine Datei, wenn sie fehlt oder eine vorhandene √∂ffnet </p><br><p>  Um die eingegebenen √Ñnderungen zu speichern, dr√ºcken Sie ESC und dann ZZ </p><br><p>  Um einfach zu beenden, ohne ESC zu speichern und danach: q! </p><br><p>  Eine sehr kurze Beschreibung, aber es sollte reichen.  Ich kann hinzuf√ºgen, dass der Einf√ºgen-Schl√ºssel sehr n√ºtzlich sein kann. </p><br><p>  Erstellen Sie daher √ºber Azure Cloud Shell eine Datei mit einem beliebigen Namen (z. B. appsettings.json) und dem gew√ºnschten Inhalt.  Lassen Sie uns Folgendes zugeben: </p><br><pre> <code class="plaintext hljs">{ "ConnectionString": "some secret string goes there" }</code> </pre> <br><p>  Und nachdem Sie den Befehl ausgef√ºhrt haben: </p><br><pre> <code class="plaintext hljs">kubectl create secret generic secret-appsettings --from-file=/home/youraccount/appsettings.json</code> </pre> <br><p>  Dieser Befehl erstellt ein Geheimnis mit Einstellungen, die als geheime Apps bezeichnet werden <br>  Mit dem Befehl pwd k√∂nnen Sie herausfinden, durch welchen Pfad / home / youraccount ersetzt werden soll </p><br><h2>  Erstellen Sie eine Bereitstellung </h2><br><p>  Bereitstellungen gelten f√ºr zustandslose Dienste.  Sie beschreiben, wie Pods und ReplicaSets erstellt und wie sie aktualisiert werden.  Pod ist eine Gruppe von Containern (oder ein einzelner Container), die in derselben Umgebung arbeiten.  Der Zweck von ReplicaSet besteht darin, zu steuern, dass die angegebene Anzahl von Pods gestartet wird und st√§ndig funktioniert. <br>  Basierend auf der zuvor erstellten Datei erstelle ich eine deploy.yaml-Datei, die 3 Sub erstellt.  Die Datei enth√§lt den folgenden Code (ich erinnere Sie daran, dass Leerzeichen in yaml sehr wichtig sind): </p><br><pre> <code class="plaintext hljs">apiVersion: apps/v1beta1 kind: Deployment metadata: name: mydeployment spec: replicas: 3 minReadySeconds: 10 strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 maxSurge: 1 template: metadata: labels: app: myapp spec: containers: - name: app image: myservice.azurecr.io/myservice:latest ports: - containerPort: 80 name: http protocol: TCP imagePullPolicy: Always env: - name: "ASPNETCORE_ENVIRONMENT" value: "Production" volumeMounts: - name: secrets mountPath: /app/secrets readOnly: true imagePullSecrets: - name: regcred volumes: - name: secrets secret: secretName: secret-appsettings</code> </pre> <br><p>  Betrachten Sie den Code.  Der Anfang beschreibt die Anzahl der Replikate und die Aktualisierungsstrategie.  Anschlie√üend erh√§lt die Bereitstellung einen Namen (myapp) und ein Verweis auf das Container-Image wird angezeigt.  Ports sind registriert.  80 ist der Standardport f√ºr http.  Als N√§chstes werden die ASP.NET Core-Umgebungseinstellungen aufgef√ºhrt.  Dann wurden die Credits des privaten Docker-Images und die geheimen Anwendungseinstellungen, die wir k√ºrzlich erstellt haben, bereitgestellt. </p><br><pre> <code class="plaintext hljs"> strategy: type: RollingUpdate rollingUpdate: maxUnavailable: 1 maxSurge: 1</code> </pre> <br><p>  Dieses Teil ist f√ºr den Upgrade-Prozess verantwortlich.  maxSurge - Die Anzahl der Herde, die beim Aktualisieren √ºber den vorhandenen Herden erstellt wurden (in Einheiten oder Prozent).  maxUnavailable - Die maximale Anzahl von Herden, die w√§hrend des Aktualisierungsvorgangs m√∂glicherweise nicht mehr verf√ºgbar sind. <br>  Die Bereitstellung kann mit dem folgenden Befehl erstellt werden: </p><br><pre> <code class="plaintext hljs">kubectl apply -f deploy.yaml</code> </pre> <br><h2>  Treffen Sie Ingress </h2><br><p>  Um den Zugriff auf Clusterdienste bereitzustellen und den Lastenausgleich zu organisieren, wird ein Dienst namens Ingress verwendet.  Eine ziemlich beliebte L√∂sung ist Ingress basierend auf Nginx.  Der einfachste Weg, es zu installieren, ist die Verwendung des Kubernetes-Paketmanagers namens helm.  Der Vorteil von Azure Cloud Shell besteht darin, dass der Helm bereits darin installiert ist.  Was bleibt zu tun, um nginx-ingress zu installieren?  Geben Sie ein: </p><br><pre> <code class="plaintext hljs">helm init</code> </pre> <br><p>  Warten Sie etwas und f√ºhren Sie Folgendes aus: </p><br><pre> <code class="plaintext hljs">helm install stable/nginx-ingress --namespace kube-system --set rbac.create=false</code> </pre> <br><h2>  Erstellen von SSL-Zertifikaten mit LetsEncrypt </h2><br><p>  Da das SSL-Zertifikat an einen Dom√§nennamen gebunden ist, legen wir unseren DNS-Ressourcennamen fest. </p><br><p>  F√ºhren Sie den folgenden Befehl aus und √ºbernehmen Sie die externe IP </p><br><pre> <code class="plaintext hljs">kubectl get service -l app=nginx-ingress --namespace kube-system</code> </pre> <br><p>  Ersetzen Sie IP und den Namen, den wir f√ºr die Subdomain im folgenden Skript erfunden haben </p><br><pre> <code class="plaintext hljs">#!/bin/bash # Public IP address of your ingress controller IP="168.63.19.2" # Name to associate with public IP address DNSNAME="myservice-ingress" # Get the resource-id of the public ip PUBLICIPID=$(az network public-ip list --query "[?ipAddress!=null]|[?contains(ipAddress, '$IP')].[id]" --output tsv) # Update public ip address with DNS name az network public-ip update --ids $PUBLICIPID --dns-name $DNSNAME</code> </pre> <br><p>  Wir kopieren dieses Skript einfach, f√ºgen es in die Befehlszeile ein und f√ºhren es auf diese Weise aus.  Als Namen f√ºr die Subdomain habe ich einen sehr "urspr√ºnglichen" Namen festgelegt - myservice-ingress </p><br><p>  Installieren Sie den Zertifikatmanager auf die gleiche Weise, indem Sie das folgende Skript kopieren und in die Befehlszeile einf√ºgen.  Auch hier muss nichts Besonderes ge√§ndert werden. </p><br><pre> <code class="plaintext hljs">helm install \ --name cert-manager \ --namespace kube-system \ stable/cert-manager \ --set ingressShim.defaultIssuerName=letsencrypt-prod \ --set ingressShim.defaultIssuerKind=ClusterIssuer \ --set rbac.create=false \ --set serviceAccount.create=false</code> </pre> <br><h1>  INFO </h1><br><p>  Wenn wir einen Cluster mit RBAC h√§tten, w√§re das Skript anders. </p><br><pre> <code class="plaintext hljs">helm install stable/cert-manager --set ingressShim.defaultIssuerName=letsencrypt-staging --set ingressShim.defaultIssuerKind=ClusterIssuer</code> </pre> <br><p>  Wenn die Zertifikatdatei verf√ºgbar ist, k√∂nnen Sie sie folgenderma√üen hinzuf√ºgen: </p><br><pre> <code class="plaintext hljs">kubectl create secret tls tls-secret --cert CERT.crt --key KEY-FOR-CERT.key</code> </pre> <br><p>  Da wir jedoch kein unterschriebenes CA-Zertifikat haben, m√ºssen wir ein wenig mit einem Tamburin tanzen.  Wir werden eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zertifizierungsstelle</a> mit einem kostenlosen Dienst namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LetsEncrypt erstellen</a> .  LetsEncrypt ist eine Zertifizierungsstelle, die kostenlos Zertifikate ausstellt.  Eine solche altruistische Organisation, deren Ziel es ist, das Internet zu sichern. </p><br><p>  Erstellen Sie also die Datei cluster-issuer.yaml. Sie beschreibt die Organisation, die das Zertifikat ausgestellt hat. </p><br><pre> <code class="plaintext hljs">apiVersion: certmanager.k8s.io/v1alpha1 kind: ClusterIssuer metadata: name: letsencrypt-prod spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: youeemail@yourdomain.ru privateKeySecretRef: name: letsencrypt-prod http01: {}</code> </pre> <br><p>  Sie m√ºssen nur die E-Mail durch Ihre Adresse ersetzen und k√∂nnen Folgendes tun: </p><br><pre> <code class="plaintext hljs">kubectl apply -f cluster-issuer.yaml</code> </pre> <br><p>  Anschlie√üend erstellen wir die Zertifikatsdatei certificate.yaml, in der der Name des erstellten ClusterIssuer und die Dom√§ne angegeben sind, f√ºr die das Zertifikat bestimmt ist - myservice-ingress.westeurope.cloudapp.azure.com </p><br><pre> <code class="plaintext hljs">apiVersion: certmanager.k8s.io/v1alpha1 kind: Certificate metadata: name: tls-prod-secret spec: secretName: tls-prod-secret dnsNames: - myservice-ingress.westeurope.cloudapp.azure.com acme: config: - http01: ingressClass: nginx domains: - myservice-ingress.westeurope.cloudapp.azure.com issuerRef: name: letsencrypt-prod kind: ClusterIssuer</code> </pre> <br><p>  Wir f√ºhren aus: </p><br><pre> <code class="plaintext hljs">kubectl apply -f certificate.yaml</code> </pre> <br><h2>  Serviceerstellung und Ingress </h2><br><p>  Kubernetes kann vier verschiedene Arten von Diensten erstellen. <br>  Der Standarddienst ist ClusterIP.  Der Zugriff auf diesen Dienst ist nur vom Cluster √ºber die interne IP m√∂glich. </p><br><p>  NodePort erstellt automatisch den ClusterIP-Dienst.  Der Zugriff auf NodePort ist extern auf folgendem Weg m√∂glich: <br></p><p>  Der LoadBalancer Load Balancer bietet Zugriff von au√üen auf den Dienst und erstellt automatisch NodePort- und ClusterIP-Dienste. </p><br><p>  ExternalName ordnet den Dienst einem externen Namen zu. </p><br><p>  Die Grundversorgung reicht uns: </p><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: myservice spec: type: ClusterIP ports: - port: 80 name: http targetPort: http selector: app: myapp</code> </pre> <br><p>  Mit dem Wert des Selektors geben wir den Namen unserer Bereitstellung an. <br>  Es bleibt ein Service zu erstellen </p><br><pre> <code class="plaintext hljs">kubectl apply -f service.yaml</code> </pre> <br><p>  Und als letzten Schritt erstellen wir einen Eingang, mit dem ich Sie in diesem Artikel bereits etwas h√∂her vorgestellt habe.  In yaml geben wir den Namen des Cluster-Ausstellers und das Zertifikat an.  Wir haben sie fr√ºher erstellt. </p><br><pre> <code class="plaintext hljs">apiVersion: extensions/v1beta1 kind: Ingress metadata: name: myingress annotations: kubernetes.io/ingress.class: nginx certmanager.k8s.io/cluster-issuer: letsencrypt-prod nginx.ingress.kubernetes.io/rewrite-target: / spec: tls: - hosts: - myservice-ingress.westeurope.cloudapp.azure.com secretName: tls-prod-secret rules: - host: myservice-ingress.westeurope.cloudapp.azure.com http: paths: - path: / backend: serviceName: myservice servicePort: 80</code> </pre> <br><p>  Einige Zeit nach dem Erstellen des Eingangs mit demselben Befehl kubectl apply sollte unser Microservice unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https: // myservice-ingress.westeurope.cloudapp.azure.com</a> verf√ºgbar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">sein</a> .  Durch Klicken auf das Schloss in der Adressleiste des Browsers neben https k√∂nnen Sie √ºberpr√ºfen, ob das Zertifikat g√ºltig und von CA ausgestellt ist. </p><br><img src="https://habrastorage.org/webt/kj/e2/gz/kje2gzpczlirmrm5fpmnjigkcxc.png"><br><br>  Wir erinnern Sie daran, dass dies die Vollversion eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikels aus dem Hacker-Magazin ist</a> .  Sein Autor ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Alexey Sommer</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435870/">https://habr.com/ru/post/de435870/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435858/index.html">Programmierbare Hardware-TOTP-Tasten mit der M√∂glichkeit, die Zeit zu synchronisieren</a></li>
<li><a href="../de435862/index.html">Unterhaltungselektronik Hall of Fame: Die Geschichten der besten Ger√§te der letzten 50 Jahre, Teil 4</a></li>
<li><a href="../de435864/index.html">Mapping-Anfragen f√ºr Netty</a></li>
<li><a href="../de435866/index.html">Release IT: Eine neue Plattform f√ºr die Einf√ºhrung von Produkten und Dienstleistungen im Rahmen des SXSW 2019-Festivals</a></li>
<li><a href="../de435868/index.html">Slush 2018. Preview Day</a></li>
<li><a href="../de435872/index.html">Zick-Programmiersprache</a></li>
<li><a href="../de435876/index.html">Detaillierte Firefox-Browsereinstellungen</a></li>
<li><a href="../de435878/index.html">Amateur in OpenSource - Lektionen in 3 Jahren gelernt</a></li>
<li><a href="../de435880/index.html">√Ñndern des Schemas von PostgreSQL-Tabellen ohne lange Sperren. Yandex Vortrag</a></li>
<li><a href="../de435882/index.html">Xiaomi Mi Box S Bewertung und ein kleiner Vergleich mit Mi Box 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>