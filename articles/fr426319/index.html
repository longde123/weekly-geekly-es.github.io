<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💲 🛬 🔆 Serveur de test pour l'équipe de développement 🚓 🏥 🍒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Dans cet article, je souhaite partager l'expérience du déploiement d'un serveur de test pour l'équipe de développement. Brièvement l'es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Serveur de test pour l'équipe de développement</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/426319/">  Bonjour, Habr!  Dans cet article, je souhaite partager l'expérience du déploiement d'un serveur de test pour l'équipe de développement.  Brièvement l'essence du problème - il y a une équipe de développement et plusieurs projets en php.  Alors que nous étions peu nombreux et que le projet en était essentiellement un, nous avons utilisé 1 serveur de test et pour montrer la tâche au client, le développeur a «réparti» le serveur pendant un certain temps.  S'il n'y avait pas de «fenêtres» à temps, alors nous devions attendre.  Au fil du temps, l'équipe et la complexité des tâches ont augmenté, respectivement, le temps de vérification et l'activité du serveur de test ont augmenté, ce qui a eu une incidence négative sur le délai d'exécution et le bonus.  Par conséquent, j'ai dû chercher une solution et c'est sous la coupe. <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  Quel était: <br><br><ol><li>  Un serveur de test </li><li>  Gitlab et redmine sur un autre serveur </li><li>  Désir de régler un problème </li></ol><br>  Tous les serveurs sont dans notre réseau local, le serveur de test est inaccessible de l'extérieur. <br><br>  Ce qui était requis: <br><br><ol><li>  Possibilité de tester plusieurs projets / branches en même temps </li><li>  Le développeur peut aller sur le serveur, le configurer et ne rien casser aux autres </li><li>  Tout doit être aussi pratique que possible et effectué sur 1 bouton, de préférence à partir de gitlab (CI / CD). </li></ol><br><h3>  Options de décision </h3><br><h4>  1. Un serveur, plusieurs hôtes </h4><br>  L'option la plus simple.  Nous utilisons le même serveur de test, seul le développeur doit créer un hôte pour chaque branche / projet et l'ajouter à la configuration nginx / apache2. <br><br>  Avantages: <br><br><ol><li>  Rapidement et tout le monde comprend </li><li>  Peut automatiser </li></ol><br>  Inconvénients: <br><br><ol><li>  La clause 2 des exigences n'est pas satisfaite - le développeur peut commencer à mettre à jour la base de données et, dans certaines circonstances, tout mettre (Salut Andrey!) </li><li>  Automatisation assez complexe avec un tas de fichiers de configuration </li></ol><br><h4>  2. À chaque développeur sur le serveur! </h4><br>  Attribuer à chaque serveur et le développeur est responsable de son économie. <br><br>  Avantages: <br><br><ol><li>  Le développeur peut personnaliser entièrement le serveur pour votre projet </li></ol><br>  Inconvénients: <br><br><ol><li>  La clause 2 des exigences n'est pas remplie </li><li>  Cher et les ressources peuvent rester inactives pendant que le développement est en cours, pas de test </li><li>  L'automatisation est encore plus compliquée qu'au point 1 en raison de serveurs différents </li></ol><br><h4>  3. Conteneurisation - docker, kubernetes </h4><br>  Cette technologie pénètre de plus en plus nos vies.  À la maison, j'utilise depuis longtemps Docker pour mes projets. <br><blockquote>  Docker - logiciel pour automatiser le déploiement et la gestion des applications dans un environnement de virtualisation au niveau du système d'exploitation.  Vous permet de "compresser" l'application avec tous ses environnements et dépendances dans un conteneur qui peut être porté sur n'importe quel système Linux avec prise en charge de cgroups dans le noyau, et fournit également un environnement de gestion de conteneur. </blockquote>  Avantages: <br><br><ol><li>  Un serveur est utilisé </li><li>  Toutes les exigences sont remplies. </li></ol><br>  Inconvénients: <br><br><ol><li>  Les images et les conteneurs prennent parfois beaucoup de place, il faut nettoyer les couronnes déjà dépassées pour libérer de l'espace. </li></ol><br><h3>  Implémentation de Docker </h3><br>  Lors de l'utilisation de gitlab, AutoDevOps, les paramètres de kubernetes ont très souvent attiré mon attention.  De plus, les gars barbus sur diverses rencontres disent à quel point ils travaillent avec kubernetes.  Par conséquent, il a été décidé d'essayer de déployer le cluster dans ses installations, le serveur a été demandé (et vous ne pouvez pas toucher le test, les gens y testent) et cela a commencé! <br><br>  Depuis que j'ai de l'expérience avec kubernetes 0, tout a été fait selon le manuel avec une tentative de comprendre comment fonctionnent tous ces clusters.  Après un certain temps, j'ai réussi à augmenter le cluster, mais il y a eu ensuite des problèmes avec les certificats, les clés et en effet avec la difficulté de déploiement.  J'avais besoin d'une solution plus simple pour enseigner à mes collègues comment travailler avec cela (par exemple, je ne veux pas passer les mêmes vacances assis sur Skype et aider à la configuration).  Par conséquent, kubernetes a été laissé seul.  Docker lui-même est resté et il était nécessaire de trouver une solution pour le routage des conteneurs.  Puisqu'ils pouvaient être récupérés sur différents ports, le même nginx pouvait être utilisé pour la redirection interne.  C'est ce qu'on appelle un serveur proxy inverse. <br><blockquote>  Un serveur proxy inverse est un type de serveur proxy qui relaie les demandes des clients d'un réseau externe vers un ou plusieurs serveurs logiquement situés sur le réseau interne.  Dans le même temps, il considère le client comme si les ressources demandées se trouvaient directement sur le serveur proxy. </blockquote><h4>  Proxy inverse </h4><br>  Afin de ne pas réinventer la roue, j'ai commencé à chercher des solutions toutes faites.  Et il a été trouvé - c'est du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traefik</a> . <br><br>  Træfik est un proxy inverse HTTP moderne et un équilibreur de charge qui simplifie le déploiement des microservices.  Træfik s'intègre aux composants d'infrastructure existants (Docker, mode Swarm, Kubernetes, Marathon, Consul, Etcd, Rancher, Amazon ECS, ...) et est configuré automatiquement et dynamiquement.  Pour travailler avec docker, il vous suffit de spécifier son socket et c'est tout, puis Tr fik lui-même trouve tous les conteneurs et les achemine vers eux (pour plus de détails, voir «Emballage d'applications dans docker»). <br><br><div class="spoiler">  <b class="spoiler_title">Configuration du conteneur Træfik</b> <div class="spoiler_text">  Je le lance via docker-compose.yml <br><br><pre><code class="hljs delphi">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: traefik: image: traefik:latest # The official Traefik docker image command: --api --docker # Enables the web UI <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tells Træfik <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> docker ports: - <span class="hljs-number"><span class="hljs-number">443</span></span>:<span class="hljs-number"><span class="hljs-number">443</span></span> - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> # The HTTP port - <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> # The Web UI (enabled by --api) volumes: - /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock # So that Traefik can listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the Docker events - /opt/traefik/traefik.toml:/traefik.toml - /opt/traefik/certs/:/certs/ networks: - proxy container_name: traefik restart: always networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: true</code> </pre> <br></div></div><br>  Ici, nous informons le proxy que nous devons écouter les ports 80,443 et 8080 (la face Web du proxy), monter le socket docker, le fichier de configuration et le dossier de certificat.  Pour faciliter la dénomination des sites de test, nous avons décidé de créer une zone de domaine local * .test.  Lors de l'accès à un site sur celui-ci, l'utilisateur accède à notre serveur de test.  Par conséquent, les certificats du dossier traefik sont auto-signés, mais il prend donc en charge Let's Encrypt. <br><br>  Génération de certificats <br><br><pre> <code class="bash hljs">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout domain.key -out domain.crt</code> </pre> <br>  Avant de commencer, vous devez créer un réseau proxy dans le docker (vous pouvez le nommer vous-même). <br><br><pre> <code class="bash hljs">docker network create proxy</code> </pre> <br>  Ce sera le réseau pour connecter traefik avec des conteneurs de sites php.  Par conséquent, nous le spécifions dans le paramètre réseaux du service et dans les réseaux de l'ensemble du fichier en spécifiant dans le paramètre external: true. <br><br><div class="spoiler">  <b class="spoiler_title">Fichier Traefik.toml</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> logLevel = "DEBUG" defaultEntryPoints = ["https","http"] #  insecureSkipVerify = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> #   [entryPoints] [entryPoints.http] address = ":80" [entryPoints.https] address = ":443" [entryPoints.https.tls] [docker] endpoint = "unix:///var/run/docker.sock" <span class="hljs-keyword"><span class="hljs-keyword">domain</span></span> = "docker.localhost" watch = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> exposedbydefault = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br></div></div><br>  Tout est assez simple ici - nous spécifions les points d'entrée du trafic http et https, n'oubliez pas de mettre insecureSkipVerify = true si les certificats sont locaux.  Dans la section entryPoints.https.tls, vous ne pouvez pas spécifier de certificats, alors traefik substituera son certificat. <br><br>  Vous pouvez démarrer le service <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  Si vous allez sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site.test</a> , vous obtiendrez une erreur 404, car ce domaine n'est lié à aucun conteneur. <br><br><h4>  Nous emballons les applications dans Docker </h4><br>  Vous devez maintenant configurer le conteneur avec l'application, à savoir: <br><br>  1. spécifier un réseau proxy dans les réseaux <br>  2. ajouter des étiquettes avec la configuration de traefik <br><br>  Voici la configuration de l'une des applications <br><br><div class="spoiler">  <b class="spoiler_title">applications docker-compose.yml</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: app: build: <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/docker/php #   restart: always working_dir: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> volumes: - ./:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html #    - /home/develop/site-files/f:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span>/f #       links: - mailcatcher - memcached - mysql labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">443</span></span> - traefik.protocol=https networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mailcatcher: image: schickling/mailcatcher:latest restart: always memcached: image: memcached restart: always mysql: image: mysql:<span class="hljs-number"><span class="hljs-number">5.7</span></span> restart: always command: --max_allowed_packet=<span class="hljs-number"><span class="hljs-number">902505856</span></span> --sql-mode=<span class="hljs-string"><span class="hljs-string">""</span></span> environment: MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> MYSQL_DATABASE: site volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/cache/mysql-db:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/mysql #      phpmyadmin: image: phpmyadmin/phpmyadmin restart: always links: - mysql environment: MYSQL_USERNAME: root MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> PMA_ARBITRARY: <span class="hljs-number"><span class="hljs-number">1</span></span> PMA_HOST: mysql_1 labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:pma.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">80</span></span> - traefik.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.protocol=http networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br></div></div><br>  Dans le service d'application, dans la section réseau, vous devez spécifier le proxy et le défaut, cela signifie qu'il sera disponible sur deux réseaux, comme le montre la configuration, je ne transfère pas les ports à l'extérieur, tout se passe sur le réseau. <br><br>  Ensuite, configurez les étiquettes <br><br><pre> <code class="hljs 1c"> - traefik.enabled=true <span class="hljs-meta"><span class="hljs-meta"># traefik </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN #  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  traefik     - traefik.docker.network=proxy # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  - traefik.port=443 #, </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">    ssl   80   http - traefik.protocol=https #  #  phpmyadmin   http </span></span></code> </pre><br>  Dans la section des réseaux généraux, spécifiez external: true <br><br>  La constante TEST_DOMAIN doit être remplacée par un domaine, par exemple, site.test <br><br>  Lancez l'application <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  Maintenant, si vous accédez aux domaines site.test, crm.site.test, bonus.site.test, vous pouvez voir le site de travail.  Et sur le domaine pma.site.test, il y aura phpmyadmin pour un travail pratique avec la base de données. <br><br><h4>  Configurer GitLab </h4><br>  Nous créons un gestionnaire de tâches, pour cela nous exécutons <br><br><pre> <code class="bash hljs">gitlab-runner register</code> </pre> <br>  Nous spécifions l'url de gitlab, le jeton et à travers lesquels la tâche sera exécutée (exécuteurs).  Puisque mon test et gitlab sont sur des serveurs différents, je sélectionne ssh executor.  Vous devrez spécifier l'adresse du serveur et le login / mot de passe pour la connexion via ssh. <br><br>  Runner peut être attaché à un ou plusieurs projets.  Puisque ma logique de travail est la même partout, un runner partagé a été créé (commun à tous les projets). <br>  Et la touche finale est de créer un fichier de configuration CI <br><br><div class="spoiler">  <b class="spoiler_title">.gitlab-ci.yml</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk">stages: - build - clear #  develop build_develop: stage: build #   build tags: #     - ssh-develop environment: # ,       -   name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME #  url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test <span class="hljs-symbol"><span class="hljs-symbol">#url</span></span>     on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #     - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - sed -i -e <span class="hljs-comment"><span class="hljs-comment">"s/TEST_DOMAIN/site$CI_PIPELINE_ID.test/g"</span></span> docker-compose.yml #   - docker-compose down #   - docker-compose up -d --build #  - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist \<span class="hljs-comment"><span class="hljs-comment">""</span></span> #   - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> #     #  production build_prod: stage: build tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - docker-compose down - docker-compose up -d --build - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist --no-dev\<span class="hljs-comment"><span class="hljs-comment">""</span></span> - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> clear: stage: clear tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME action: stop script: - cd ../ &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; docker-compose down &amp;&amp; cd ../ &amp;&amp; echo password | sudo -<span class="hljs-type"><span class="hljs-type">S</span></span> rm -rf <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #       when: manual</code> </pre><br></div></div><br>  Dans cette configuration, 2 étapes sont décrites - construire et effacer.  La phase de construction a 2 options - build_develop et build_prod <br><br><img src="https://habrastorage.org/webt/yz/ut/dy/yzutdyyknwjgwbcg4-kj2ssv-f8.png"><br><br>  Gitlab construit un organigramme de processus compréhensible.  Dans mon exemple, tous les processus démarrent manuellement (quand: paramètre manuel).  Cela est fait pour que le développeur, après avoir déployé le site de test, puisse insérer ses modifications dans le conteneur sans reconstruire le conteneur entier.  Une autre raison est le nom de domaine - site $ CI_PIPELINE_ID.test, où CI_PIPELINE_ID est le numéro du processus qui a démarré l'assemblage.  Autrement dit, ils ont soumis le site avec le domaine site123.test pour vérification, et afin d'apporter des modifications à chaud, les modifications sont immédiatement versées dans le conteneur par le développeur. <br><br>  Une petite fonctionnalité de ssh executor.  Une fois connecté au serveur, un dossier du formulaire est créé. <br><br><pre> <code class="bash hljs">/home//builds/_runner/0/_/_</code> </pre> <br>  Par conséquent, une ligne a été ajoutée <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../ &amp;&amp; cp -r <span class="hljs-variable"><span class="hljs-variable">$CI_PROJECT_NAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span></code> </pre> <br>  Dans celui-ci, nous montons dans le dossier ci-dessus et copions le projet dans le dossier avec le numéro de processus.  Vous pouvez donc déployer plusieurs branches d'un même projet.  Mais dans les paramètres du gestionnaire, vous devez vérifier Verrouiller sur les projets en cours, afin que le gestionnaire n'essaye pas de développer plusieurs branches en même temps. <br><br>  L'étape d'effacement arrête les conteneurs et supprime le dossier, vous pouvez avoir besoin des privilèges root, nous utilisons donc le mot de passe echo |  sudo -S rm où mot de passe est votre mot de passe. <br><br><h4>  Collecte des ordures </h4><br>  De temps en temps, vous devez supprimer les conteneurs inutilisés afin de ne pas prendre de place, pour cela un script avec un tel contenu se bloque dans la couronne <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #   : docker ps --filter status=dead --filter status=exited -aq | xargs -r docker rm -v #   : yes | docker container prune #    : yes | docker image prune #    : yes | docker volume prune</span></span></code> </pre> <br>  effectué une fois par jour. <br><br><h3>  Conclusion </h3><br>  Cette solution nous a permis d'optimiser considérablement les tests et la sortie de nouvelles fonctionnalités.  Prêt à répondre aux questions, la critique constructive est acceptée. <br><br><h3>  Bonus </h3><br>  Afin de ne pas collecter à chaque fois des images du Dockerfile, vous pouvez les stocker dans le registre Docker local. <br><br><div class="spoiler">  <b class="spoiler_title">Fichier docker-compose.yml</b> <div class="spoiler_text"><pre> <code class="hljs powershell">registry: restart: always image: registry:<span class="hljs-number"><span class="hljs-number">2</span></span> ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">5000</span></span> volumes: - /opt/docker<span class="hljs-literal"><span class="hljs-literal">-registry</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>:/var/lib/registry <span class="hljs-comment"><span class="hljs-comment">#    </span></span></code> </pre><br></div></div><br>  Cette option n'utilise pas d'authentification, ce n'est pas un moyen sûr (!!!), mais il convient au stockage d'images non critiques. <br><br>  Vous pouvez configurer gitlab pour afficher <br><br><pre> <code class="bash hljs"> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_enabled'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_host'</span></span>] = <span class="hljs-string"><span class="hljs-string">"registry.test"</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_port'</span></span>] = <span class="hljs-string"><span class="hljs-string">"5000"</span></span></code> </pre><br>  Après cela, une liste d'images apparaît dans gitlab <br><br><img src="https://habrastorage.org/webt/lu/hn/8i/luhn8ilow44doqm5btrtafgv-hq.png"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr426319/">https://habr.com/ru/post/fr426319/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr426305/index.html">Travaillez avec les statuts des personnages. Expériences d'unité</a></li>
<li><a href="../fr426311/index.html">Conférence BLACK HAT USA. Botnet à partir d'un million de navigateurs. 2e partie</a></li>
<li><a href="../fr426313/index.html">Nouveau Microsoft Learn</a></li>
<li><a href="../fr426315/index.html">Comment se faire des amis python avec Internet Invisible? Les bases du développement d'applications I2P en Python et asyncio</a></li>
<li><a href="../fr426317/index.html">1155 vs 2011. Certaines personnes âgées se battent</a></li>
<li><a href="../fr426323/index.html">Une tentative de fabriquer un boîtier de robot avec un budget limité. Tapis de verre et époxy</a></li>
<li><a href="../fr426325/index.html">Cours MIT "Sécurité des systèmes informatiques". Conférence 12: Sécurité du réseau, partie 1</a></li>
<li><a href="../fr426327/index.html">Nouveautés de la mise à jour d'octobre 2018 de Windows 10</a></li>
<li><a href="../fr426331/index.html">Vulnérabilité dans PlayStation 4 - le jeu de caractères dans le message pour l'utilisateur transforme à distance la console en presque une "brique"</a></li>
<li><a href="../fr426333/index.html">Microsoft a publié le code MS-DOS 1.25 et 2.0 sous la licence MIT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>