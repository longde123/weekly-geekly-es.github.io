<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸš° ğŸŒ³ âš±ï¸ Pengembangan AI menggunakan contoh game Dicey Dungeons ğŸ¤• ğŸ¦… ğŸ‘ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama sekitar satu bulan, saya menyelesaikan salah satu masalah teknis paling sulit dari game baru saya, Dicey Dungeons - sebuah AI yang ditingkatkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengembangan AI menggunakan contoh game Dicey Dungeons</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432062/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/295/2a6/391/2952a639197eaa3a64690bd53e3fd0bd.jpg"></div><br>  Selama sekitar satu bulan, saya menyelesaikan salah satu masalah teknis paling sulit dari game baru saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dicey Dungeons</a> - sebuah AI yang ditingkatkan untuk rilis final game.  Itu adalah karya yang agak menarik, dan kebanyakan baru bagi saya, jadi saya memutuskan untuk menulis sedikit tentang itu. <br><br>  Untuk mulai dengan, saya akan menjelaskan: Saya bukan ahli dalam teori komputer, tetapi hanya salah satu dari mereka yang telah mempelajari pemrograman cukup untuk membuat video game, setelah itu saya lulus dari pelatihan, hanya meraih apa yang saya butuhkan.  Biasanya saya bisa menyelesaikan masalah saya sendiri, tetapi seorang programmer nyata kemungkinan besar tidak akan menyetujui keputusan saya. <br><br>  Saya mencoba menulis artikel pada tingkat abstraksi yang cukup tinggi sehingga ide dasarnya jelas bahkan untuk non-programmer.  Tetapi saya bukan ahli dalam hal-hal seperti itu, jadi penjelasan saya tentang teori itu mungkin salah.  Menulis kepada saya tentang ini di komentar ke aslinya, saya dengan senang hati akan melakukan perubahan! <br><br>  Baiklah, mari kita mulai dengan menjelaskan tugas! <br><a name="habracut"></a><br><h2>  Tantangan </h2><br>  Jika Anda belum pernah bermain Dicey Dungeons, saya akan berbicara singkat tentang permainan: ini adalah RPG dengan deckbuilding, di mana setiap musuh memiliki satu set peta senjata yang melakukan berbagai tindakan.  Selain itu, mereka melempar dadu!  Kemudian mereka memasukkan dadu ke dalam persenjataan untuk menghasilkan kerusakan, atau menciptakan berbagai efek status, atau menyembuhkan, atau mempertahankan diri dari kerusakan, dan sejenisnya.  Berikut adalah contoh sederhana tentang bagaimana katak kecil menggunakan pedang besar dan perisai kecil: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/db8/48a/908db848a06270e8398e67313f9e16c7.gif"></div><br>  Contoh yang lebih kompleks: Jack dari semua perdagangan ini memiliki kunci pas, yang memungkinkan Anda untuk menyatukan dua dadu (yaitu, 3 + 2 akan memberikan 5, dan 4 + 5 akan memberikan 6 dan 3).  Dia juga memiliki palu (Palu), yang memberikan efek "kejutan" pada pemain, jika Anda menerapkan enam padanya, dan seorang penembak kacang (Pea Shooter), yang tidak sedikit merusak, tetapi ia memiliki "hitungan mundur", kemudian ada itu berlaku untuk beberapa gerakan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/691/1d0/391/6911d0391f12dc6af58dd978907a6df3.gif"></div><br>  Komplikasi penting lainnya: permainan memiliki efek status yang mengubah kemampuan lawan.  Yang paling penting dari ini adalah Shock, yang secara acak menonaktifkan senjata;  guncangan dapat dihilangkan dengan menggunakan kubus tambahan di atasnya, dan "Bakar", yang membakar kubus.  Sementara kubus terbakar, mereka dapat digunakan, tetapi setiap penggunaan akan menelan biaya 2 poin kesehatan.  Inilah yang dilakukan oleh tukang pintar ketika saya menyetrum dan membakar semua senjata dan kubusnya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f92/36c/aae/f9236caaee860e0c026e31bd4390d6e3.gif"></div><br>  Tentu saja, ada lebih banyak dalam permainan, tetapi untuk mendapatkan ide umum, ini sudah cukup. <br><br>  Jadi, tugas kita: bagaimana membuat AI memilih tindakan terbaik untuk pergerakannya?  Bagaimana dia bisa mengetahui kubus mana yang akan dibakar, kubus mana yang digunakan untuk meredakan kejutan, dan mana yang harus disimpan untuk senjata penting? <br><br><h2>  Seperti yang dia lakukan sebelumnya </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfb/bac/9ef/dfbbac9efb2cad316eb7dd82aab379c5.png"></div><br>  Untuk waktu yang lama, AI di Dicey Dungeons hanya memiliki satu aturan: dia melihat semua senjata dari kiri ke kanan, menentukan kubus terbaik yang bisa digunakan padanya, dan kemudian menggunakannya.  Ini bekerja dengan baik, tetapi ada pengecualian.  Jadi saya menambahkan aturan baru. <br><br>  Misalnya, saya berurusan dengan guncangan dengan melihat semua senjata yang tidak terkena goncangan, dan memilih dadu mana yang akan saya gunakan saat goncangan dilepas, dan kemudian menandai dadu ini sebagai "dicadangkan" untuk masa depan.  Saya bekerja dengan membakar batu seperti ini: Saya memeriksa apakah saya memiliki kesehatan yang cukup untuk memadamkannya, dan secara acak memilih apakah akan melakukan ini. <br><br>  Saya menambahkan aturan demi aturan untuk semua yang dapat saya bayangkan, dan sebagai hasilnya saya mendapatkan AI yang sepertinya berfungsi!  Bahkan, sungguh menakjubkan betapa baiknya jalinan aturan yang berbeda ini menunjukkan dirinya sendiri - AI di Dicey Dungeons mungkin tidak selalu membuat keputusan yang tepat, tetapi selalu setidaknya dapat diterima.  Setidaknya untuk game masih dalam pengembangan. <br><br>  Namun seiring berjalannya waktu, sistem untuk terus-menerus menambahkan aturan baru mulai retak pada lapisannya.  Orang-orang telah menemukan eksploitasi yang membuat AI berperilaku bodoh.  Misalnya, dengan pendekatan yang tepat, Anda bisa mengecoh salah satu bos sehingga dia tidak akan pernah menyerang pemain.  Semakin banyak aturan yang saya tambahkan untuk memperbaiki situasi, semakin banyak hal aneh mulai terjadi - beberapa aturan bertentangan dengan yang lain, kasus batas mulai muncul. <br><br>  Tentu saja, salah satu solusinya adalah menambahkan aturan baru, mempertimbangkan setiap tugas satu per satu, dan membuat konstruksi baru jika untuk memprosesnya.  Tetapi saya berpikir bahwa dengan cara ini saya hanya menyingkirkan solusi yang sebenarnya untuk masalah tersebut.  Keterbatasan sistem adalah bahwa ia hanya mengkhawatirkan satu pertanyaan: "Apa langkah saya <b>selanjutnya</b> ?"  Dia tidak pernah melihat ke depan dan tidak mencoba menyarankan apa yang <i>bisa</i> terjadi dari kombinasi cerdas tertentu. <br><br>  Jadi saya memutuskan untuk memulai lagi. <br><br><h2>  Solusi klasik </h2><br>  Cobalah mencari informasi tentang AI untuk game, dan kemungkinan besar hal pertama yang Anda temui adalah solusi klasik - membuat algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">minimax</a> .  Berikut adalah video tentang bagaimana ia digunakan dalam mengembangkan AI untuk catur: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/DZfv0YgLJ2Q" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Implementasi minimax adalah sebagai berikut: <br><br>  Pertama, kami membuat versi abstrak permainan kami yang paling sederhana, di mana ada semua informasi yang diperlukan untuk titik waktu tertentu dalam permainan.  Kami akan menyebutnya <b>papan</b> .  Dalam hal catur, ini adalah posisi saat ini dari semua bagian.  Dalam kasus Dicey Dungeons, ini adalah daftar efek dadu, senjata, dan status. <br><br>  Lalu kami membuat <i>fungsi nilai</i> yang mengukur seberapa baik permainan ini dimainkan untuk konfigurasi game tertentu, yaitu, untuk <i>papan</i> tertentu.  Misalnya, dalam catur, papan tempat potongan berada di posisi semula diberi nilai 0 poin.  Papan tempat Anda memakan pion lawan memiliki nilai 1 poin, dan papan tempat Anda kehilangan pion Anda sendiri memiliki nilai -1 poin.  Dan papan yang kita periksa lawan akan dievaluasi pada jumlah poin yang tak terbatas, atau sesuatu seperti itu! <br><br>  Kemudian, dari papan abstrak ini, kami mensimulasikan semua gerakan yang mungkin bisa kami lakukan, yang memberi kami papan abstrak baru.  Kemudian kami mensimulasikan penyelesaian semua kemungkinan langkah di papan <i>ini</i> , dan seterusnya, sebanyak langkah yang Anda inginkan.  Berikut ini adalah ilustrasi yang sangat baik tentang solusi serupa dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">freecodecamp.org</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/905/fa7/323905fa7062bd302e0b97afd1b81d40.png"></div><br>  Kami membuat grafik dari semua gerakan yang mungkin dilakukan oleh kedua pemain, dan menerapkan fungsi nilai untuk mengevaluasi bagaimana permainan berjalan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf9/487/181/bf948718169b06d15fdfbf816839d6a4.jpg"></div><br>  Dan dalam hal ini, Dicey Dungeons berbeda dari minimax: minimax berasal dari teori matematika permainan, ia dirancang untuk menemukan serangkaian gerakan terbaik di dunia di mana lawan berusaha untuk memaksimalkan skornya.  Algoritma disebut demikian karena meminimalkan kerugian pemain ketika lawan bermain untuk memaksimalkan kemenangannya. <br><br>  Tapi apa yang terjadi di Dicey Dungeons?  Sebenarnya, saya tidak peduli apa yang lawan saya lakukan.  Agar permainan menjadi menarik, cukup bagi kecerdasan buatan untuk membuat langkah logis - untuk menentukan cara terbaik untuk menerapkan dadu pada senjata, sehingga pertempuran itu adil.  Dengan kata lain, hanya "maks" yang penting bagi saya, tanpa "mini". <br><br>  Yaitu, bagi AI Dicey Dungeons untuk membuat langkah yang baik, cukup bagi saya untuk membuat grafik gerakan yang mungkin dan menemukan papan yang memiliki skor tertinggi, dan kemudian membuat gerakan yang mengarah ke titik ini. <br><br><h2>  Langkah mudah musuh </h2><br>  Baiklah, mari kita beralih ke contoh!  Mari kita lihat katak itu lagi.  Bagaimana dia bisa <b>memutuskan</b> apa yang harus dilakukan selanjutnya?  Bagaimana dia <i>tahu</i> bahwa tindakan yang dipilih adalah yang terbaik? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/db8/48a/908db848a06270e8398e67313f9e16c7.gif"></div><br>  Bahkan, dia hanya punya dua pilihan.  Tempatkan 1 di pedang lebar, dan 3 di perisai, atau lakukan yang sebaliknya.  Dia jelas memutuskan bahwa lebih baik menempatkan 3 daripada 1. Tapi mengapa?  Karena dia mempelajari semua hasil yang mungkin: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/429/44c/85b/42944c85becf5fc79d0868de96b2dbd6.png"></div><br>  Jika Anda menempatkan 1 pada pedang, maka kita akan mendapatkan 438 poin.  Jika Anda menempatkan 3 di atasnya, kami mendapatkan 558 poin.  Hebat!  Jadi, saya mendapatkan lebih banyak poin dengan menempatkan pada pedang 3, masalahnya selesai. <br><br>  Dari mana kacamata ini berasal?  Sistem penilaian di Dicey Dungeons saat ini mempertimbangkan aspek-aspek berikut: <br><br><ul><li>  <strong>Kerusakan: Faktor</strong> paling penting adalah 100 poin untuk setiap titik kerusakan yang diberikan. </li><li>  <strong>Racun:</strong> Efek status penting yang AI anggap hampir sama pentingnya dengan kerusakan - 90 untuk setiap racun. </li><li>  <strong>Membuat efek status lainnya:</strong> misalnya, guncangan, terbakar, melemah, dll.  Masing-masing harganya 50 poin. </li><li>  <strong>Efek status bonus:</strong> menambah pemain sendiri efek status positif, seperti pertahanan dan sejenisnya, masing-masing biaya 40 poin. </li><li>  <strong>Penggunaan senjata:</strong> menggunakan semua jenis senjata berharga 10 poin, karena jika tidak ada yang berhasil, AI harus mencoba menggunakan semuanya. </li><li>  <strong>Pengurangan hitung mundur:</strong> untuk mengaktifkan beberapa jenis senjata (misalnya, untuk Pea Shooter), jumlah total pada dadu cukup.  Oleh karena itu, AI menerima 10 poin untuk setiap titik hitung yang dikurangi. </li><li>  <strong>Dots on Dice:</strong> AI mendapat 5 poin untuk setiap poin yang tidak digunakan pada dadu, yaitu 1 biaya 5 poin, dan 6 biaya 30 poin.  Ini dilakukan agar AI memilih untuk tidak menggunakan kubus yang tidak perlu Anda gunakan, sehingga gerakannya menjadi sangat mirip dengan yang dilakukan manusia. </li><li>  <strong>Durasi:</strong> AI kehilangan 1 poin per giliran, sehingga gerakan panjang memiliki nilai yang sedikit lebih rendah daripada yang pendek.  Hal ini dilakukan agar dengan adanya dua gerakan yang memiliki nilai yang sama, AI memilih yang paling pendek. </li><li>  <strong>Perawatan:</strong> biaya hanya 1 poin untuk satu titik kesehatan yang dipulihkan, karena walaupun saya ingin AI mempertimbangkan hal ini penting, saya tidak benar-benar memantau kesehatan saya.  Selalu ada hal yang harus dilakukan dan lebih penting! </li><li>  <strong>Poin bonus:</strong> mereka dapat ditambahkan ke setiap gerakan untuk memaksa AI melakukan sesuatu yang dia tidak akan pernah lakukan sebaliknya.  Digunakan dengan sangat moderat. </li></ul><br>  Dan akhirnya, ada dua kasus khusus - jika target yang diserang kehabisan kesehatan, maka harganya sejuta poin.  Jika kesehatan berakhir dengan AI, maka harganya minus satu juta poin.  Ini berarti bahwa AI tidak akan pernah secara tidak sengaja membunuh dirinya sendiri (misalnya, membayar mati dengan kesehatan yang sangat rendah), atau tidak pernah melewatkan langkah di mana ia dapat membunuh pemain. <br><br>  Angka-angka ini tidak ideal - misalnya, masalah terbuka saat ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">640</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">642</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">649</a> , tetapi ini tidak terlalu penting.  Bahkan kira-kira angka yang akurat cukup untuk merangsang AI untuk melakukan lebih atau kurang dengan benar. <br><br><h2>  Gerakan musuh yang lebih sulit </h2><br>  Kasing katak sangat sederhana sehingga bahkan kode mengerikan saya dapat mengetahui semua opsi hanya dalam 0,017 detik.  Tetapi kemudian situasinya menjadi lebih rumit.  Mari kita lihat lagi contoh Jack semua perdagangan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f92/36c/aae/f9236caaee860e0c026e31bd4390d6e3.gif"></div><br>  Pohon keputusannya â€œsedikitâ€ lebih rumit: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f7/f79/49a/8f7f7949aed6051ea06e4139bc76fd06.gif"></div><br>  Sayangnya, bahkan dalam kasus yang relatif sederhana, ledakan kompleksitas terjadi dengan cukup cepat.  Dalam hal ini, dalam grafik kami, kami mendapatkan 2.670 node yang perlu diperiksa, dan ini membutuhkan waktu lebih lama daripada dalam kasus katak - mungkin satu atau dua detik. <br><br>  Ini sebagian besar disebabkan oleh kompleksitas kombinatorial - misalnya, tidak masalah yang mana dari dua yang kami gunakan untuk meredakan kejutan pada awalnya, algoritma menganggap ini sebagai dua solusi terpisah, dan membuat pohon lengkap solusi percabangan untuk masing-masing.  Akibatnya, kami mendapatkan cabang yang duplikasinya sama sekali tidak perlu.  Ada juga masalah kombinatorial serupa ketika memilih blok untuk penebusan, untuk menghilangkan kejutan dari senjata, dan prosedur untuk penggunaannya. <br><br>  Tetapi bahkan jika kita menemukan dan mengoptimalkan cabang yang tidak perlu seperti itu (yang saya lakukan sampai batas tertentu), akan selalu ada titik di mana kompleksitas dari semua permutasi yang memungkinkan solusi mengarah ke pohon keputusan besar, lambat, evaluasi yang akan memakan waktu tak terbatas.  Jadi, ini adalah masalah serius pertama dari pendekatan ini.  Ini satu lagi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d5/0f0/29b/9d50f029bd3cededbc248022f19a83a6.png"></div><br>  <i>Kunci utama.</i>  <i>Membagi kubus menjadi dua.</i> <br><br>  Jenis persenjataan penting ini (dan yang serupa) menyebabkan masalah AI karena hasil penggunaannya tidak <i>pasti</i> .  Jika saya menempatkan enam di atasnya, saya bisa mendapatkan lima dan satu, atau empat dan dua, atau mungkin dua kali lipat.  Saya tidak akan tahu ini sampai saya tahu, jadi sangat sulit untuk membuat rencana yang akan mempertimbangkan ini. <br><br>  Untungnya, Dicey Dungeons memiliki solusi hebat untuk kedua masalah ini! <br><br><h2>  Solusi modern </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Metode</a> Monte Carlo Tree Search (MCTS) adalah algoritma pengambilan keputusan probabilistik.  Di bawah ini adalah video yang agak aneh, yang, bagaimanapun, dengan sangat baik menjelaskan prinsip pengambilan keputusan berdasarkan metode Monte Carlo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BfS2H1y6tzQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Bahkan, alih-alih menambahkan setiap gerakan yang mungkin ke grafik, MCTS memeriksa urutan gerakan acak, dan kemudian melacak langkah-langkah yang terbukti lebih baik.  Berkat formula yang disebut Batas Keyakinan Tinggi, ia secara ajaib dapat menentukan cabang-cabang pohon keputusan mana yang "paling menjanjikan": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f38/1aa/c26/f381aac265ea58ab792166af30d64dca.png"></div><br>  Ngomong-ngomong, saya mengambil formula ini dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel yang sangat berguna tentang mencari pohon menggunakan metode Monte Carlo</a> .  Jangan tanya saya bagaimana cara kerjanya! <br><br>  Hal yang luar biasa tentang MCTS adalah bahwa untuk menemukan solusi terbaik, kami biasanya tidak perlu melalui pencarian yang bodoh tentang semuanya, dan kami dapat menggunakan sistem simulasi papan / pemindahan abstrak yang sama seperti pada minimax.  Artinya, kami agak menggunakan kedua algoritma.  Ini persis skema yang saya gunakan di Dicey Dungeons.  Pertama, dia mencoba menyelesaikan penyebaran lengkap pohon keputusan, yang biasanya tidak memakan banyak waktu dan mengarah pada hasil terbaik.  Tetapi jika pohon itu tampak terlalu besar, maka kita kembali menggunakan MCTS. <br><br>  MCTS memiliki dua fitur yang sangat keren yang sempurna untuk Dicey Dungeons: <br><br>  Pertama, metode ini bekerja secara ideal dengan ketidakpastian.  Karena ini dilakukan berulang-ulang, mengumpulkan data dari setiap proses, saya hanya membiarkannya mensimulasikan gerakan yang tidak terdefinisi, misalnya, menggunakan kunci utama, dengan cara alami, dan setelah banyak berjalan metode ini menciptakan rentang poin yang cukup benar yang diperoleh sebagai hasil dari langkah ini. <br><br>  Kedua, dia bisa memberi saya solusi parsial.  Bahkan, ketika bekerja dengan MCTS, Anda dapat melakukan simulasi sebanyak yang Anda suka.  Secara teoritis, jika dilakukan tanpa henti, itu akan menyatu dengan hasil yang sama persis dengan minimax.  Namun, yang lebih penting bagi saya adalah saya dapat menggunakan MCTS untuk mendapatkan solusi yang baik dalam waktu berpikir yang terbatas.  Semakin banyak pencarian yang kami lakukan, semakin baik "solusi" akan ditemukan, tetapi dalam kasus Dicey Dungeons seringkali hanya beberapa ratus pencarian yang cukup, yang mengambil sebagian kecil dari satu detik. <br><br><h2>  Topik terkait yang menarik </h2><br>  Jadi, beginilah cara musuh di Dicey Dungeons memutuskan cara membunuhmu!  Saya ingin menambahkan sistem ini ke versi selanjutnya dari game v0.15! <br><br>  Dari mana grafik yang saya tunjukkan berasal, termasuk di twitter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/969/95d/85c/96995d85c59364cde7cd4df0609da6c4.png"></div><br>  Saya membuatnya dengan menulis eksportir untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GraphML</a> , format file grafik sumber terbuka yang dapat dibaca oleh banyak alat yang berbeda.  (Saya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YEd</a> luar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">biasa</a> , yang sangat saya rekomendasikan.) <br><br>  Bagian dari solusi untuk masalah ini adalah untuk memungkinkan AI untuk mensimulasikan gerakan, yang dengan sendirinya merupakan teka-teki yang menarik.  Akibatnya, saya menerapkan sistem scripting tindakan.  Sekarang lawan menggunakan berbagai jenis senjata.  mereka mengeksekusi skrip kecil ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/d3e/f6b/1c5d3ef6bdbfe755699cd588c89dc54f.png"></div><br>  Script-script kecil ini dijalankan oleh parser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hscript</a> dan penerjemah ekspresi berdasarkan haxe.  Bagian ini sulit untuk diimplementasikan, tetapi upaya itu terbayar: itu membuat game super nyaman untuk membuat mod.  Saya berharap bahwa setelah rilis game, orang dapat menggunakan sistem ini untuk mengembangkan senjata mereka sendiri, yaitu, mereka dapat menambah game hampir semua yang mereka bisa bayangkan.  Selain itu, karena AI cukup pintar untuk mengevaluasi setiap tindakan yang ditransfer ke sana, musuh akan dapat mengetahui cara menggunakan senjata yang dimodifikasi yang akan dibuat oleh pemain! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432062/">https://habr.com/ru/post/id432062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432052/index.html">â€œAnda adalah pengembang yang keren, pergi dan minta lebih banyak uangâ€ - kami akan memberi tahu manajer cara kerja dunia</a></li>
<li><a href="../id432054/index.html">Apa yang membuat BeOS dan HaikuOS unik</a></li>
<li><a href="../id432056/index.html">Verifikasi foto eceran dengan visi Komputer</a></li>
<li><a href="../id432058/index.html">Apa yang Baru di AppCode 2018.3</a></li>
<li><a href="../id432060/index.html">Cara terbaik untuk menghafal kata-kata bahasa Inggris</a></li>
<li><a href="../id432064/index.html">Cara melarikan diri dari "hares". Instruksi UV</a></li>
<li><a href="../id432068/index.html">Cara memfasilitasi studi Bahasa Inggris: 5 layanan bermanfaat</a></li>
<li><a href="../id432070/index.html">Secara singkat tentang saluran redux-saga</a></li>
<li><a href="../id432072/index.html">Tiga jenis kebocoran memori</a></li>
<li><a href="../id432074/index.html">Bagaimana pemain merobek kain realitas Spelunky dengan senapan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>