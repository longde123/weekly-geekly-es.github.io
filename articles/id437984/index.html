<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸŒˆ ğŸ‘ğŸ¾ ğŸ‘› Threading di Node.js: module worker_threads ğŸ˜µ ğŸ‘• ğŸ¤²ğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada 18 Januari, platform Node.js versi 11.7.0 diumumkan . Di antara perubahan-perubahan penting dalam versi ini, orang dapat mencatat kesimpulan dari...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Threading di Node.js: module worker_threads</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/437984/">  Pada 18 Januari, platform Node.js versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">11.7.0 diumumkan</a> .  Di antara perubahan-perubahan penting dalam versi ini, orang dapat mencatat kesimpulan dari kategori module_ laboratorial modul eksperimental, yang muncul di Node.js <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">10.5.0</a> .  Sekarang bendera - pekerja eksperimental tidak diperlukan untuk menggunakannya.  Modul ini, sejak awal, tetap cukup stabil, dan karenanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keputusan</a> dibuat, tercermin dalam Node.js 11.7.0. <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/jp/qj/fk/jpqjfkjewyfpm1cbr5yxaubxt-w.png"></a> <br>  Penulis materi, terjemahan yang kami terbitkan, menawarkan untuk membahas kemampuan modul worker_threads, khususnya, ia ingin berbicara tentang mengapa modul ini diperlukan, dan bagaimana multithreading diimplementasikan dalam JavaScript dan Node.js karena alasan historis.  Di sini kita akan berbicara tentang masalah apa yang terkait dengan penulisan aplikasi JS multi-utas, tentang cara yang ada untuk menyelesaikannya, dan tentang masa depan pemrosesan data paralel menggunakan apa yang disebut "utas pekerja", yang kadang-kadang disebut "utas pekerja" atau hanya "pekerja." <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Hidup di dunia single-threaded</font> </h2><br>  JavaScript dipahami sebagai bahasa pemrograman single-threaded yang berjalan di browser.  "Single-threaded" berarti bahwa dalam proses yang sama (di browser modern kita berbicara tentang tab browser yang terpisah), hanya satu set instruksi yang dapat dieksekusi pada suatu waktu. <br><br>  Ini menyederhanakan pengembangan aplikasi, memfasilitasi pekerjaan programmer.  Awalnya, JavaScript adalah bahasa yang hanya cocok untuk menambahkan beberapa fitur interaktif ke halaman web, misalnya, seperti validasi formulir.  Di antara tugas-tugas yang dirancang untuk JS, tidak ada hal rumit yang membutuhkan multithreading. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ryan Dahl</a> , pencipta Node.js, melihat peluang menarik dalam pembatasan bahasa ini.  Dia ingin mengimplementasikan platform server berdasarkan pada subsistem I / O asinkron.  Ini berarti bahwa programmer tidak perlu bekerja dengan utas, yang sangat menyederhanakan pengembangan untuk platform yang sama.  Ketika mengembangkan program yang dirancang untuk eksekusi kode paralel, masalah mungkin timbul yang sangat sulit untuk dipecahkan.  Katakanlah, jika beberapa utas mencoba mengakses area memori yang sama, ini dapat mengarah pada apa yang disebut "proses perlombaan" yang mengganggu program.  Kesalahan seperti itu sulit untuk direproduksi dan diperbaiki. <br><br><h2>  <font color="#3AC1EF">Apakah platform Node.js beralur tunggal?</font> </h2><br>  Apakah aplikasi Node.js beralur tunggal?  Ya, memang demikian adanya.  Sebenarnya, Node.js memungkinkan Anda untuk melakukan tindakan tertentu secara paralel, tetapi untuk ini, programmer tidak perlu membuat utas atau menyinkronkannya.  Platform Node.js dan sistem operasi melakukan operasi input / output paralel dengan caranya sendiri, dan ketika saatnya tiba untuk pemrosesan data menggunakan kode JavaScript kami, ia bekerja dalam mode single-threaded. <br><br>  Dengan kata lain, semuanya kecuali kode JS kami bekerja secara paralel.  Dalam blok kode JavaScript yang sinkron, perintah selalu dijalankan satu per satu, sesuai urutan yang disajikan dalam kode sumber: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> flag = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  flag = <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-comment"><span class="hljs-comment">//    -  (     flag)...  //      ,     flag   true.  // -       ,  //      . }</span></span></code> </pre> <br>  Semua ini luar biasa - jika semua kode kita sibuk melakukan I / O asinkron.  Program ini terdiri dari blok kecil kode sinkron yang dengan cepat beroperasi pada data, misalnya, dikirim ke file dan stream.  Kode fragmen program sangat cepat sehingga tidak memblokir eksekusi kode fragmen lainnya.  Jauh lebih banyak waktu daripada eksekusi kode yang dibutuhkan untuk menunggu hasil dari I / O yang tidak sinkron.  Pertimbangkan sebuah contoh kecil: <br><br><pre> <code class="javascript hljs">db.findOne(<span class="hljs-string"><span class="hljs-string">'SELECT ... LIMIT 1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, result</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) }) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Running query'</span></span>) setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hey there'</span></span>) }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre> <br>  Ada kemungkinan bahwa kueri ke database yang ditampilkan di sini akan memakan waktu sekitar satu menit, tetapi pesan <code>Running query</code> akan dikirim ke konsol segera setelah permintaan ini dimulai.  Dalam hal ini, pesan <code>Hey there</code> akan ditampilkan satu detik setelah permintaan dieksekusi, terlepas dari apakah eksekusi telah selesai atau belum.  Aplikasi Node.js kami hanya memanggil fungsi yang menginisiasi permintaan, sementara eksekusi kode lainnya tidak diblokir.  Setelah permintaan selesai, aplikasi akan diinformasikan tentang hal ini menggunakan fungsi panggilan balik, dan kemudian akan menerima tanggapan terhadap permintaan ini. <br><br><h2>  <font color="#3AC1EF">Tugas intensif CPU</font> </h2><br>  Apa yang terjadi jika kita, melalui JavaScript, perlu melakukan komputasi berat?  Misalnya - untuk memproses set besar data yang disimpan dalam memori?  Hal ini dapat mengarah pada fakta bahwa program akan berisi sebuah fragmen kode sinkron, pelaksanaannya membutuhkan banyak waktu dan memblokir eksekusi kode lainnya.  Bayangkan perhitungan ini membutuhkan waktu 10 detik.  Jika kita berbicara tentang server web yang memproses permintaan tertentu, ini berarti bahwa itu tidak akan dapat memproses permintaan lain selama setidaknya 10 detik.  Ini masalah besar.  Bahkan, perhitungan yang lebih dari 100 milidetik sudah dapat menyebabkan masalah ini. <br><br>  JavaScript dan platform Node.js pada awalnya tidak dirancang untuk menyelesaikan tugas yang menggunakan sumber daya prosesor secara intensif.  Dalam kasus JS yang berjalan di browser, melakukan tugas-tugas seperti itu berarti "rem" pada antarmuka pengguna.  Di Node.js, ini dapat membatasi kemampuan untuk meminta platform untuk melakukan tugas I / O asinkron baru dan kemampuan untuk merespons peristiwa yang terkait dengan penyelesaiannya. <br><br>  Mari kita kembali ke contoh sebelumnya.  Bayangkan bahwa sebagai respons terhadap permintaan ke database, beberapa ribu catatan terenkripsi masuk, yang, dalam kode JS sinkron, harus didekripsi: <br><br><pre> <code class="javascript hljs">db.findAll(<span class="hljs-string"><span class="hljs-string">'SELECT ...'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, results</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) <span class="hljs-comment"><span class="hljs-comment">//      ,    . for (const encrypted of results) {   const plainText = decrypt(encrypted)   console.log(plainText) } })</span></span></code> </pre> <br>  Hasilnya, setelah menerimanya, ada dalam fungsi panggilan balik.  Setelah itu, hingga akhir pemrosesan, tidak ada kode JS lain yang dapat dieksekusi.  Biasanya, seperti yang telah disebutkan, beban pada sistem yang dibuat oleh kode tersebut minimal, dengan cepat melakukan tugas yang diberikan kepadanya.  Namun dalam kasus ini, program menerima hasil kueri, yang memiliki jumlah yang cukup besar, dan kami masih perlu memprosesnya.  Sesuatu seperti ini bisa memakan waktu beberapa detik.  Jika kita berbicara tentang server tempat banyak pengguna bekerja, ini berarti mereka dapat terus bekerja hanya setelah selesainya operasi yang intensif sumber daya. <br><br><h2>  <font color="#3AC1EF">Mengapa JavaScript tidak pernah memiliki utas?</font> </h2><br>  Mengingat hal di atas, mungkin untuk menyelesaikan masalah komputasi berat di Node.js Anda perlu menambahkan modul baru yang akan memungkinkan Anda membuat utas dan mengelolanya.  Bagaimana Anda bisa melakukannya tanpa hal seperti itu?  Sangat menyedihkan bahwa mereka yang menggunakan platform server yang matang, seperti Node.js, tidak memiliki sarana untuk menyelesaikan masalah yang terkait dengan pemrosesan sejumlah besar data dengan indah. <br><br>  Semua ini benar, tetapi jika Anda menambahkan kemampuan untuk bekerja dengan stream dalam JavaScript, ini akan menyebabkan perubahan pada sifat dari bahasa ini.  Di JS, Anda tidak bisa hanya menambahkan kemampuan untuk bekerja dengan utas, katakanlah, dalam bentuk beberapa kelas atau fungsi baru.  Untuk melakukan ini, Anda perlu mengubah bahasa itu sendiri.  Dalam bahasa yang mendukung multithreading, konsep sinkronisasi banyak digunakan.  Sebagai contoh, di Jawa, bahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">beberapa tipe numerik</a> tidak bersifat atom.  Ini berarti bahwa jika mekanisme sinkronisasi tidak digunakan untuk bekerja dengannya dari utas berbeda, semua ini dapat menghasilkan, misalnya, setelah beberapa utas secara bersamaan mencoba mengubah nilai variabel yang sama, beberapa byte dari variabel tersebut akan disetel ke satu mengalir, dan beberapa lainnya.  Akibatnya, variabel tersebut akan berisi sesuatu yang tidak sesuai dengan operasi normal program. <br><br><h2>  <font color="#3AC1EF">Solusi primitif untuk masalah: iterasi dari loop acara</font> </h2><br>  Node.js tidak akan menjalankan blok kode berikutnya dalam antrian acara hingga blok sebelumnya selesai.  Ini berarti bahwa untuk menyelesaikan masalah kami, kami dapat memecahnya menjadi bagian-bagian yang diwakili oleh fragmen kode sinkron, dan kemudian menggunakan konstruksi dari bentuk <code>setImmediate(callback)</code> untuk merencanakan eksekusi fragmen ini.  Kode yang ditentukan oleh fungsi <code>callback</code> dalam konstruksi ini akan dieksekusi setelah tugas iterasi saat ini (centang) dari loop acara selesai.  Setelah itu, desain yang sama digunakan untuk mengantri kumpulan perhitungan berikutnya.  Ini memungkinkan untuk tidak memblokir siklus peristiwa dan, pada saat yang sama, memecahkan masalah volumetrik. <br><br>  Bayangkan bahwa kita memiliki array besar yang perlu diproses, sementara memproses setiap elemen dari array tersebut membutuhkan perhitungan yang kompleks: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [<span class="hljs-comment"><span class="hljs-comment">/*large array*/</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> arr) { <span class="hljs-comment"><span class="hljs-comment">//         } // ,   ,      .</span></span></code> </pre> <br>  Seperti yang telah disebutkan, jika kita memutuskan untuk memproses seluruh array dalam satu panggilan, akan terlalu banyak waktu dan mencegah eksekusi kode aplikasi lain.  Oleh karena itu, kami akan membagi tugas besar ini menjadi beberapa bagian dan menggunakan <code>setImmediate(callback)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> crypto = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'crypto'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">200</span></span>).fill(<span class="hljs-string"><span class="hljs-string">'something'</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processChunk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (arr.length === <span class="hljs-number"><span class="hljs-number">0</span></span>) {   <span class="hljs-comment"><span class="hljs-comment">// ,      } else {   console.log('processing chunk');   //  10         const subarr = arr.splice(0, 10)   for (const item of subarr) {     //           doHeavyStuff(item)   }   //       setImmediate(processChunk) } } processChunk() function doHeavyStuff(item) { crypto.createHmac('sha256', 'secret').update(new Array(10000).fill(item).join('.')).digest('hex') } //       , ,   , //       . let interval = setInterval(() =&gt; { console.log('tick!') if (arr.length === 0) clearInterval(interval) }, 0)</span></span></code> </pre> <br>  Sekarang, dalam sekali jalan, kami memproses sepuluh elemen array, setelah itu, menggunakan <code>setImmediate()</code> , kami merencanakan kumpulan perhitungan berikutnya.  Dan ini berarti bahwa jika Anda perlu mengeksekusi beberapa kode lagi dalam program, itu dapat dieksekusi antara operasi pada pemrosesan fragmen array.  Untuk ini, di sini, di akhir contoh, ada kode yang menggunakan <code>setInterval()</code> . <br><br>  Seperti yang Anda lihat, kode seperti itu terlihat jauh lebih rumit daripada versi aslinya.  Dan seringkali algoritme dapat menjadi jauh lebih kompleks daripada kita, yang berarti bahwa, ketika diimplementasikan, tidak akan mudah untuk memecah perhitungan menjadi beberapa bagian dan memahami di mana, untuk mencapai keseimbangan yang tepat, Anda perlu mengatur <code>setImmediate()</code> , merencanakan bagian perhitungan berikutnya.  Selain itu, kode sekarang ternyata tidak sinkron, dan jika proyek kami bergantung pada pustaka pihak ketiga, maka kami mungkin tidak dapat memecah proses penyelesaian tugas yang sulit menjadi beberapa bagian. <br><br><h2>  <font color="#3AC1EF">Proses latar belakang</font> </h2><br>  Mungkin pendekatan di atas dengan <code>setImmediate()</code> akan berfungsi dengan baik untuk kasus-kasus sederhana, tetapi jauh dari ideal.  Selain itu, utas tidak digunakan di sini (untuk alasan yang jelas) dan kami juga tidak bermaksud mengubah bahasa untuk ini.  Apakah mungkin untuk melakukan pemrosesan data paralel tanpa menggunakan utas?  Ya, itu mungkin, dan untuk ini kita perlu semacam mekanisme untuk pemrosesan data latar belakang.  Ini adalah tentang memulai tugas tertentu, meneruskan data ke sana, dan agar tugas ini, tanpa mengganggu kode utama, menggunakan semua yang diperlukan, menghabiskan waktu sebanyak yang diperlukan untuk bekerja, dan kemudian mengembalikan hasilnya ke kode utama.  Kami memerlukan sesuatu yang mirip dengan cuplikan kode berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  script.js   ,    . const service = createService('script.js') //          service.compute(data, function(err, result) { //      })</span></span></code> </pre> <br>  Kenyataannya adalah bahwa di Node.js Anda dapat menggunakan proses latar belakang.  Intinya adalah bahwa dimungkinkan untuk membuat percabangan proses dan mengimplementasikan skema kerja yang dijelaskan di atas menggunakan mekanisme pengiriman pesan antara proses anak dan orang tua.  Proses utama dapat berinteraksi dengan proses keturunan, mengirimkan peristiwa ke sana dan menerima mereka darinya.  Memori bersama tidak digunakan dengan pendekatan ini.  Semua data yang dipertukarkan oleh proses adalah "kloning", yaitu, ketika perubahan dibuat untuk contoh data ini dengan satu proses, perubahan ini tidak terlihat oleh proses lain.  Ini mirip dengan permintaan HTTP - ketika klien mengirimkannya ke server, server hanya menerima salinannya.  Jika proses tidak menggunakan memori bersama, ini berarti bahwa dengan operasi simultan mereka tidak mungkin untuk membuat "negara ras", dan bahwa kita tidak perlu membebani diri kita sendiri dengan bekerja dengan utas.  Sepertinya masalah kita telah teratasi. <br><br>  Benar, pada kenyataannya tidak demikian.  Ya - di depan kami adalah salah satu solusi untuk tugas melakukan perhitungan intensif, tetapi sekali lagi, itu tidak sempurna.  Membuat garpu proses adalah operasi yang intensif sumber daya.  Butuh waktu untuk menyelesaikannya.  Bahkan, kita berbicara tentang membuat mesin virtual baru dari awal dan tentang meningkatkan jumlah memori yang dikonsumsi oleh program, yang disebabkan oleh fakta bahwa proses tidak menggunakan memori bersama.  Mengingat hal di atas, adalah tepat untuk bertanya apakah mungkin, setelah menyelesaikan tugas, untuk menggunakan kembali proses garpu.  Anda dapat memberikan jawaban positif untuk pertanyaan ini, tetapi di sini Anda harus ingat bahwa sudah direncanakan untuk mentransfer percabangan proses ke berbagai tugas intensif sumber daya yang akan dilakukan di dalamnya secara serempak.  Dua masalah bisa dilihat di sini: <br><br><ul><li>  Meskipun dengan pendekatan ini proses utama tidak diblokir, proses keturunan mampu melakukan tugas yang ditransfer ke sana hanya secara berurutan.  Jika kita memiliki dua tugas, yang salah satunya membutuhkan waktu 10 detik, dan yang kedua membutuhkan waktu 1 detik, dan kita akan menyelesaikannya dalam urutan ini, maka kita tidak mungkin menyukai kebutuhan untuk menunggu yang pertama diselesaikan sebelum yang kedua.  Karena kami membuat garpu proses, kami ingin menggunakan kemampuan sistem operasi untuk merencanakan tugas dan menggunakan sumber daya komputasi dari semua inti prosesor kami.  Kami membutuhkan sesuatu yang menyerupai bekerja di komputer untuk orang yang mendengarkan musik dan melakukan perjalanan melalui halaman web.  Untuk melakukan ini, Anda dapat membuat dua proses percabangan dan mengatur pelaksanaan tugas-tugas paralel dengan bantuan mereka. </li><li>  Selain itu, jika salah satu tugas mengarah ke akhir proses dengan kesalahan, semua tugas yang dikirim ke proses tersebut akan diproses. </li></ul><br>  Untuk menyelesaikan masalah ini, kita memerlukan beberapa proses percabangan, bukan satu, tetapi kita harus membatasi jumlahnya, karena masing-masing membutuhkan sumber daya sistem dan perlu waktu untuk membuatnya masing-masing.  Sebagai hasilnya, mengikuti pola sistem yang mendukung koneksi basis data, kita memerlukan sesuatu seperti kumpulan proses yang siap digunakan.  Sistem manajemen kumpulan proses, setelah menerima tugas baru, akan menggunakan proses bebas untuk mengeksekusinya, dan ketika proses tertentu mengatasi tugas tersebut, ia akan dapat menetapkan yang baru untuknya.  Ada perasaan bahwa skema kerja semacam itu tidak mudah untuk diimplementasikan, dan, pada kenyataannya, memang demikian.  Kami akan menggunakan paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pekerja-pertanian</a> untuk mengimplementasikan skema ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   const workerFarm = require('worker-farm') const service = workerFarm(require.resolve('./script')) service('hello', function (err, output) { console.log(output) }) // script.js //      - module.exports = (input, callback) =&gt; { callback(null, input + ' ' + world) }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Modul Worker_threads</font> </h2><br>  Jadi, apakah masalah kita terselesaikan?  Ya, kami dapat mengatakan bahwa itu terpecahkan, tetapi dengan pendekatan ini, diperlukan lebih banyak memori daripada yang diperlukan jika kami memiliki solusi multithreaded yang kami miliki.  Thread mengkonsumsi sumber daya yang jauh lebih sedikit dibandingkan dengan garpu proses.  Itulah mengapa modul <code>worker_threads</code> muncul di <code>worker_threads</code> <br><br>  Utas pekerja dijalankan dalam konteks yang terisolasi.  Mereka bertukar informasi dengan proses utama menggunakan pesan.  Ini menyelamatkan kita dari masalah â€œkondisi balapanâ€ yang harus dihadapi oleh lingkungan multi-utas.  Pada saat yang sama, aliran pekerja ada dalam proses yang sama dengan program utama, yaitu, dengan pendekatan ini, dibandingkan dengan penggunaan proses garpu, memori yang digunakan lebih sedikit. <br><br>  Selain itu, bekerja dengan pekerja, Anda dapat menggunakan memori bersama.  Jadi, khusus untuk tujuan ini, objek dari tipe <code>SharedArrayBuffer</code> .  Mereka harus digunakan hanya dalam kasus-kasus ketika program perlu melakukan pemrosesan kompleks sejumlah besar data.  Mereka memungkinkan Anda untuk menyimpan sumber daya yang diperlukan untuk membuat serial dan deserialisasi data saat mengatur pertukaran data antara pekerja dan program utama melalui pesan. <br><br><h2>  <font color="#3AC1EF">Arus Pekerja Pekerja</font> </h2><br>  Jika Anda menggunakan platform Node.js sebelum versi 11.7.0, untuk mengaktifkan pekerjaan dengan modul <code>worker_threads</code> , Anda perlu menggunakan <code>--experimental-worker</code> ketika memulai <code>--experimental-worker</code> <br><br>  Selain itu, perlu diingat bahwa menciptakan pekerja (seperti membuat utas dalam bahasa apa pun), meskipun membutuhkan jauh lebih sedikit sumber daya daripada membuat garpu proses, juga menciptakan beban tertentu pada sistem.  Mungkin dalam kasus Anda, bahkan beban ini mungkin terlalu banyak.  Dalam kasus seperti itu, dokumentasi merekomendasikan membuat kumpulan pekerja.  Jika Anda memerlukan ini, maka tentu saja Anda dapat membuat implementasi Anda sendiri dari mekanisme semacam itu, tetapi mungkin Anda harus mencari sesuatu yang cocok di registri NPM. <br><br>  Pertimbangkan contoh bekerja dengan utas pekerja.  Kami akan memiliki file utama, <code>index.js</code> , di mana kami akan membuat utas pekerja dan memberikannya beberapa data untuk diproses.  API yang sesuai adalah berbasis peristiwa, tapi saya akan menggunakan janji di sini yang menyelesaikan ketika pesan pertama dari pekerja tiba: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// index.js //    Node.js   11.7.0,  //      node --experimental-worker index.js const { Worker } = require('worker_threads') function runService(workerData) { return new Promise((resolve, reject) =&gt; {   const worker = new Worker('./service.js', { workerData });   worker.on('message', resolve);   worker.on('error', reject);   worker.on('exit', (code) =&gt; {     if (code !== 0)       reject(new Error(`Worker stopped with exit code ${code}`));   }) }) } async function run() { const result = await runService('world') console.log(result); } run().catch(err =&gt; console.error(err))</span></span></code> </pre> <br>  Seperti yang Anda lihat, menggunakan mekanisme alur kerja cukup sederhana.  Yaitu, saat membuat pekerja, Anda harus meneruskan jalur ke file dengan kode pekerja dan data ke desainer <code>Worker</code> .  Ingat bahwa data ini dikloning, tidak disimpan dalam memori bersama.  Setelah memulai pekerja, kami mengharapkan pesan darinya, mendengarkan acara <code>message</code> . <br><br>  Di atas, saat membuat objek bertipe <code>Worker</code> , kami meneruskan konstruktor nama file dengan kode pekerja - <code>service.js</code> .  Ini kode untuk file ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { workerData, parentPort } = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'worker_threads'</span></span>) <span class="hljs-comment"><span class="hljs-comment">// , ,    , //    . parentPort.postMessage({ hello: workerData })</span></span></code> </pre> <br>  Ada dua hal yang menarik bagi kita dalam kode pekerja.  Pertama, kita membutuhkan data yang dikirimkan oleh aplikasi utama.  Dalam kasus kami, mereka diwakili oleh variabel data <code>workerData</code> .  Kedua, kita memerlukan mekanisme untuk mengirimkan informasi ke aplikasi utama.  Mekanisme ini diwakili oleh objek <code>parentPort</code> , yang memiliki metode <code>postMessage()</code> , yang digunakan untuk meneruskan hasil pemrosesan data ke aplikasi utama.  Begitulah cara kerjanya. <br><br>  Ini adalah contoh yang sangat sederhana, tetapi dengan menggunakan mekanisme yang sama Anda dapat membangun struktur yang jauh lebih kompleks.  Misalnya, dari aliran pekerja, Anda dapat mengirim banyak pesan ke arus utama yang membawa informasi tentang status pemrosesan data jika aplikasi kami membutuhkan mekanisme yang sama.  Bahkan dari pekerja, hasil pemrosesan data dapat dikembalikan sebagian.  Misalnya, sesuatu seperti ini dapat berguna dalam situasi ketika seorang pekerja sedang sibuk, misalnya, memproses ribuan gambar, dan Anda, tanpa menunggu semuanya diproses, ingin memberi tahu aplikasi utama yang masing-masing telah selesai diproses. <br><br>  Detail tentang modul <code>worker_threads</code> dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h2>  <font color="#3AC1EF">Pekerja web</font> </h2><br>  Anda mungkin pernah mendengar tentang pekerja web.  Mereka dimaksudkan untuk digunakan dalam lingkungan klien, teknologi ini telah ada sejak lama dan menikmati <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dukungan yang baik untuk</a> browser modern.  API untuk bekerja dengan pekerja web berbeda dari apa yang diberikan modul Node.js pada <code>worker_threads</code> , ini semua tentang perbedaan lingkungan tempat mereka bekerja.  Namun, teknologi ini dapat menyelesaikan masalah serupa.  Misalnya, pekerja web dapat digunakan dalam aplikasi klien untuk melakukan enkripsi dan dekripsi data, kompresi dan dekompresi mereka.  Dengan bantuan mereka, Anda dapat memproses gambar, menerapkan sistem visi komputer (misalnya, kita berbicara tentang pengenalan wajah) dan menyelesaikan masalah serupa lainnya di browser. <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  <code>worker_threads</code> â€”     Node.js.    ,    ,   .       , ,       ,         Â« Â».   ,      ? ,    <code>worker_threads</code>      ,        Node.js      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">worker-farm</a> ,    <code>worker_threads</code>  ,   Node.js        . <br><br>  <b>Pembaca yang budiman!</b>        Node.js-? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437984/">https://habr.com/ru/post/id437984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437974/index.html">Bagaimana cara memenangkan WorldSkills digital? Pada contoh praktis</a></li>
<li><a href="../id437976/index.html">"Vkontakte" diizinkan untuk menyembunyikan catatan individual dari polisi</a></li>
<li><a href="../id437978/index.html">Selamat datang di SuperJob SphinxSearch-meetup</a></li>
<li><a href="../id437980/index.html">Buka webinar â€œMetode Pengujian Berpasangan dalam Pengujian Kotak Hitamâ€</a></li>
<li><a href="../id437982/index.html">Serangan enkripsi baru Shade menargetkan pengguna bisnis Rusia</a></li>
<li><a href="../id437986/index.html">Mengapa TypeScript adalah jantung dari setiap aplikasi web PayPal baru?</a></li>
<li><a href="../id437988/index.html">React Tutorial, Bagian 12: Workshop, Aplikasi TODO Tahap 3</a></li>
<li><a href="../id437990/index.html">Bereaksi Tutorial Bagian 13: Komponen Berbasis Kelas</a></li>
<li><a href="../id437992/index.html">Layanan microser. Versi dalam Integrasi dan Penerapan Sistem Berkelanjutan Studi Kasus CI / CD Menggunakan TFS</a></li>
<li><a href="../id437994/index.html">Pemerah susu otomatis dan rumah kaca otomatis: cara kerja pertanian teknologi tinggi kecil</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>