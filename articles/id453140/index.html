<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛺️ 👨🏿‍💻 🌦️ Siapa yang mencuri waktu CPU virtual? 🔛 👩🏼‍🤝‍👨🏻 📒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai! Dalam artikel ini, saya ingin menjelaskan, dalam istilah awam, bagaimana mencuri muncul di VMs dan memberi tahu Anda tentang beberapa artefak yan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Siapa yang mencuri waktu CPU virtual?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/453140/"><img src="https://habrastorage.org/getpro/habr/post_images/9d4/ede/bb8/9d4edebb8a0253cb1b973bd5df46a9a9.jpg"><br><br>  Hai!  Dalam artikel ini, saya ingin menjelaskan, dalam istilah awam, bagaimana <i>mencuri</i> muncul di VMs dan memberi tahu Anda tentang beberapa artefak yang kurang jelas yang kami temukan selama penelitian tentang topik yang saya terlibat sebagai CTO dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mail. com</a> Platform <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solusi Cloud</a> .  Platform ini menjalankan KVM. <br><a name="habracut"></a><br>  Waktu mencuri CPU adalah waktu selama VM tidak menerima sumber daya yang diperlukan untuk beroperasi.  Waktu ini hanya dapat dihitung dalam OS tamu di lingkungan virtualisasi.  Sangat tidak jelas di mana sumber daya yang dialokasikan hilang, seperti dalam situasi kehidupan nyata.  Namun, kami memutuskan untuk mencari tahu, dan kami bahkan melakukan serangkaian tes untuk melakukannya.  Itu bukan untuk mengatakan bahwa kami tahu segalanya tentang <i>mencuri,</i> tetapi ada beberapa hal menarik yang ingin kami bagikan dengan Anda. <br><br><h2>  1. Apa itu <i>mencuri</i> ? </h2><br>  <i>Steal</i> adalah metrik yang menunjukkan kurangnya waktu CPU untuk proses VM.  Seperti yang dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">patch kernel KVM</a> , <i>mencuri</i> adalah waktu yang dihabiskan hypervisor untuk menjalankan proses lain dalam OS host, sementara proses VM dalam antrian run.  Dengan kata lain, <i>mencuri</i> dihitung sebagai perbedaan antara saat ketika suatu proses siap untuk dijalankan dan saat ketika waktu CPU dialokasikan untuk proses tersebut. <br><br>  Kernel VM mendapatkan metrik <i>mencuri</i> dari hypervisor.  Hypervisor tidak menentukan proses yang sedang berjalan.  Itu hanya mengatakan: "Aku sibuk, dan tidak bisa mengalokasikan waktu untukmu."  Dalam KVM, <i>mencuri mencuri</i> didukung dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tambalan</a> .  Ada dua poin utama mengenai ini: <br><br><ul><li>  Seorang VM belajar tentang <i>mencuri</i> dari hypervisor.  Ini berarti bahwa dalam hal kerugian, <i>mencuri</i> adalah pengukuran tidak langsung yang dapat terdistorsi dalam beberapa cara. <br></li><li>  Hypervisor tidak membagikan informasi VM tentang apa yang ditempati.  Poin yang paling penting adalah tidak mengalokasikan waktu untuk itu.  VM itu sendiri, oleh karena itu, tidak dapat mendeteksi distorsi dalam metrik <i>mencuri</i> <i>,</i> yang dapat diperkirakan oleh sifat dari proses yang bersaing. <br></li></ul><br><h2>  2. Apa yang mempengaruhi <i>mencuri</i> ? </h2><br><h4>  2.1.  Menghitung <i>mencuri</i> </h4><br>  Pada dasarnya, <i>mencuri</i> dihitung dengan cara yang kurang lebih sama dengan waktu pemanfaatan CPU.  Tidak ada banyak informasi mengenai bagaimana pemanfaatan dihitung.  Itu mungkin karena sebagian besar profesional berpikir itu sudah jelas.  Namun, ada beberapa jebakan.  Prosesnya dijelaskan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebuah artikel oleh Brendann Gregg</a> .  Dia membahas sejumlah nuansa tentang bagaimana menghitung pemanfaatan dan skenario di mana perhitungan akan salah: <br><br><ul><li>  CPU kepanasan dan pelambatan. <br></li><li>  Menghidupkan / mematikan Turbo Boost, menghasilkan perubahan dalam laju jam CPU. </li><li> Perubahan irisan waktu yang terjadi ketika teknologi hemat daya CPU, misalnya SpeedStep, digunakan. <br></li><li>  Masalah yang terkait dengan menghitung rata-rata: mengukur pemanfaatan selama satu menit pada daya 80% dapat menyembunyikan dorongan 100% jangka pendek. <br></li><li>  Spinlock yang menghasilkan skenario di mana prosesor digunakan, tetapi proses pengguna tidak mengalami kemajuan.  Akibatnya, utilisasi CPU yang dihitung akan menjadi 100%, tetapi prosesnya tidak akan menghabiskan waktu CPU. <br></li></ul><br>  Saya belum menemukan artikel yang menggambarkan perhitungan <i>mencuri seperti itu</i> (jika Anda tahu ada, silakan bagikan di bagian komentar).  Seperti yang Anda lihat dari kode sumber, mekanisme perhitungannya sama dengan pemanfaatan.  Satu-satunya perbedaan adalah bahwa penghitung lain ditambahkan secara khusus untuk proses KVM (proses VM), yang menghitung berapa lama proses KVM telah menunggu waktu CPU.  Penghitung mengambil data pada CPU dari spesifikasinya dan memeriksa apakah semua kutu sedang digunakan oleh proses VM.  Jika semua kutu sedang digunakan, maka CPU hanya sibuk dengan proses VM.  Kalau tidak, kita tahu bahwa CPU melakukan sesuatu yang lain dan <i>mencuri</i> muncul. <br><br>  Proses dimana <i>mencuri</i> dihitung tunduk pada masalah yang sama seperti perhitungan reguler pemanfaatan.  Masalah-masalah ini tidak begitu umum, tetapi mereka bisa tampak agak membingungkan. <br><br><h4>  2.2.  Jenis virtualisasi KVM </h4><br>  Secara umum, ada tiga jenis virtualisasi, dan semuanya didukung oleh KVM.  Mekanisme <i>pencuri</i> mungkin tergantung pada jenis virtualisasi. <br><br>  Terjemahan  Dalam hal ini, OS VM akan bekerja dengan perangkat hypervisor fisik dengan cara berikut: <br><br><ol><li>  OS tamu mengirim perintah ke perangkat tamunya. <br></li><li>  Driver perangkat tamu menerima perintah, membuat permintaan perangkat BIOS, dan mengirimkan perintah ke hypervisor. <br></li><li>  Proses hypervisor menerjemahkan perintah menjadi perintah perangkat fisik, membuatnya lebih aman, antara lain. <br></li><li>  Driver perangkat fisik menerima perintah yang dimodifikasi dan meneruskannya ke perangkat fisik itu sendiri. <br></li><li>  Hasil eksekusi dari perintah kembali mengikuti jalur yang sama. <br></li></ol><br>  Keuntungan dari terjemahan adalah ia memungkinkan kita untuk meniru perangkat apa pun dan tidak memerlukan persiapan khusus dari kernel OS.  Tetapi ini datang dengan mengorbankan kinerja. <br><br>  Virtualisasi perangkat keras.  Dalam hal ini, perangkat menerima perintah dari OS pada tingkat perangkat keras.  Ini adalah metode terbaik tercepat dan keseluruhan.  Sayangnya, tidak semua perangkat fisik, hypervisor, dan OS tamu mendukungnya.  Untuk saat ini, perangkat utama yang mendukung virtualisasi perangkat keras adalah CPU. <br><br>  Paravirtualization.  Opsi paling umum untuk virtualisasi perangkat pada KVM dan tipe virtualisasi yang paling luas untuk OS tamu.  Fitur utamanya adalah bekerja dengan beberapa subsistem hypervisor (mis. Jaringan atau drive stack) dan mengalokasikan halaman memori menggunakan API hypervisor tanpa menerjemahkan perintah level rendah.  Kerugian dari metode virtualisasi ini adalah kebutuhan untuk memodifikasi kernel OS tamu untuk memungkinkan interaksi dengan hypervisor menggunakan API yang sama.  Solusi paling umum untuk masalah ini adalah menginstal driver khusus ke dalam OS tamu.  Dalam KVM, API ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API virtio</a> . <br><br>  Ketika paravirtualization digunakan, jalur ke perangkat fisik jauh lebih pendek daripada dalam kasus ketika terjemahan digunakan, karena perintah dikirim langsung dari VM ke proses hypervisor di host.  Ini mempercepat eksekusi semua instruksi dalam VM.  Dalam KVM, API virtio bertanggung jawab untuk ini.  Ini hanya berfungsi untuk beberapa perangkat seperti adapter jaringan dan drive.  Inilah sebabnya mengapa driver virtio diinstal ke VM. <br><br>  Sisi lain dari akselerasi tersebut adalah tidak semua proses yang dijalankan dalam VM tetap berada dalam VM.  Ini menghasilkan sejumlah efek, yang dapat menyebabkan <i>mencuri</i> .  Jika Anda ingin mempelajari lebih lanjut, mulailah dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API untuk virtual I / O: virtio</a> . <br><br><h4>  2.3.  Penjadwalan yang adil </h4><br>  VM pada hypervisor, pada kenyataannya, adalah proses reguler, yang tunduk pada hukum penjadwalan (distribusi sumber daya antara proses) di kernel Linux.  Mari kita lihat lebih dekat. <br><br>  Linux menggunakan apa yang disebut CFS, Completely Fair Scheduler, yang menjadi default dengan kernel 2.6.23.  Untuk memahami algoritma ini, baca Arsitektur Kernel Linux atau kode sumbernya.  Inti dari CFS terletak pada distribusi waktu CPU antar proses, tergantung pada waktu menjalankannya.  Semakin banyak waktu CPU yang dibutuhkan suatu proses, semakin sedikit waktu CPU yang didapat.  Ini menjamin eksekusi "adil" dari semua proses dan membantu untuk menghindari satu proses mengambil semua prosesor, sepanjang waktu dan memungkinkan proses lain untuk berjalan juga. <br><br>  Terkadang paradigma ini menghasilkan artefak yang menarik.  Pengguna Linux yang sudah lama berdiri pasti akan ingat bagaimana editor teks biasa pada desktop akan membeku ketika menjalankan aplikasi intensif sumber daya seperti kompiler.  Ini terjadi karena tugas sumber daya ringan, seperti aplikasi desktop, bersaing dengan tugas yang menggunakan banyak sumber daya, seperti kompiler.  CFS menganggap ini tidak adil, sehingga menghentikan editor teks dari waktu ke waktu dan memungkinkan CPU memproses tugas-tugas kompiler.  Ini diperbaiki menggunakan mekanisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sched_autogroup</a> ;  Namun, ada banyak keanehan lain dari distribusi waktu CPU.  Artikel ini sebenarnya bukan tentang seberapa buruk CFS.  Ini lebih merupakan upaya untuk menarik perhatian pada kenyataan bahwa distribusi waktu CPU yang "adil" bukanlah tugas yang paling sepele. <br><br>  Aspek penting lain dari penjadwal adalah preemption.  Ini diperlukan untuk membersihkan CPU dari segala proses yang terlalu dipaksakan dan memungkinkan orang lain untuk bekerja juga.  Ini disebut <i>pengalihan konteks</i> .  Seluruh konteks tugas dipertahankan: status tumpukan, register, dan sebagainya, setelah itu proses dibiarkan menunggu dan digantikan oleh proses lain.  Ini adalah operasi yang mahal untuk sebuah OS.  Ini jarang digunakan, tetapi sebenarnya tidak buruk sama sekali.  Pergantian konteks yang sering mungkin menjadi indikator masalah OS tetapi biasanya terjadi terus menerus dan bukan merupakan tanda masalah apa pun secara khusus. <br><br>  Wacana panjang ini diperlukan untuk menjelaskan satu fakta: dalam penjadwal Linux yang adil, semakin banyak sumber daya CPU yang digunakan proses, semakin cepat akan dihentikan untuk memungkinkan proses lain bekerja.  Apakah ini benar atau tidak adalah pertanyaan yang kompleks, dan solusinya berbeda tergantung pada bebannya.  Sampai saat ini, Windows scheduler memprioritaskan aplikasi desktop, yang mengakibatkan proses latar belakang lebih lambat.  Di Sun Solaris ada lima kelas penjadwal yang berbeda.  Ketika virtualisasi diperkenalkan, mereka menambahkan satu lagi, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Penjadwal berbagi yang adil</a> , karena yang lain tidak berjalan dengan baik dengan virtualisasi Solaris Zones.  Untuk menggali lebih dalam tentang ini, saya sarankan memulai dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Solaris Internal: Solaris 10 dan OpenSolaris Kernel Architecture</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Kernel Linux</a> . <br><br><h4>  2.4.  Bagaimana kita bisa memonitor <i>mencuri</i> ? </h4><br>  Sama seperti metrik CPU lainnya, mudah untuk <i>mencuri</i> di dalam VM.  Anda dapat menggunakan alat pengukuran metrik CPU apa pun.  Yang utama adalah VM harus ada di Linux.  Untuk beberapa alasan, Windows tidak memberikan informasi seperti itu kepada pengguna.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/9f8/5b1/fff9f85b10523ddaecfc176f1fa18f33.png"><br>  <i>Output atas: spesifikasi beban CPU dengan mencuri di kolom kanan</i> <br><br>  Banyak hal menjadi rumit ketika mencoba untuk mendapatkan informasi ini dari hypervisor.  Anda dapat mencoba meramalkan <i>mencuri</i> pada mesin host, menggunakan Load Average (LA), misalnya.  Ini adalah nilai rata-rata jumlah proses dalam antrian run.  Metode perhitungan untuk parameter ini bukan yang sederhana, tetapi secara umum, jika LA yang telah distandarisasi berdasarkan jumlah utas CPU lebih besar dari 1, itu berarti server Linux kelebihan beban. <br><br>  Jadi, tunggu apa lagi semua proses ini?  Jelas, CPU.  Namun, jawaban ini tidak terlalu akurat, karena kadang-kadang CPU gratis dan LA terlalu tinggi.  Ingatlah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bahwa NFS jatuh dan LA naik pada saat yang sama</a> .  Situasi serupa mungkin terjadi dengan drive dan perangkat input / output lainnya.  Bahkan, proses mungkin menunggu akhir kunci: fisik (terkait dengan perangkat input / output) atau logis (objek mutex, misalnya).  Hal yang sama berlaku untuk kunci tingkat perangkat keras (misalnya, respons disk) atau kunci tingkat logika (disebut "penguncian primitif", yang mencakup sejumlah entitas, mutex adaptif dan putaran, semaphore, variabel kondisi, kunci rw, kunci ipc ...). <br><br>  Fitur lain dari LA adalah bahwa itu dihitung sebagai nilai rata-rata dalam OS.  Misalnya, jika 100 proses bersaing untuk satu file, LA adalah 50. Jumlah besar ini membuatnya tampak seperti ini buruk untuk OS.  Namun, untuk kode yang ditulis dengan buruk ini bisa menjadi normal.  Hanya kode spesifik yang akan menjadi buruk, dan sisa OS mungkin baik-baik saja. <br><br>  Karena rata-rata ini (kurang dari satu menit), menentukan apa pun yang menggunakan LA bukanlah ide terbaik, karena dapat menghasilkan hasil yang sangat ambigu dalam beberapa kasus.  Jika Anda mencoba mencari tahu lebih lanjut tentang ini, Anda akan menemukan bahwa Wikipedia dan sumber daya lain yang tersedia hanya menggambarkan kasus yang paling sederhana, dan prosesnya tidak dijelaskan secara rinci.  Jika Anda tertarik dengan ini, sekali lagi, kunjungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Brendann Gregg</a> dan ikuti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tautannya</a> . <br><br><h2>  3. Efek khusus </h2><br>  Sekarang mari kita ke kasus utama <i>pencurian</i> yang kita temui.  Izinkan saya menjelaskan bagaimana hasilnya dari hal di atas dan bagaimana mereka berkorelasi dengan metrik hypervisor. <br><br>  Pemanfaatan berlebih.  Kasus paling sederhana dan paling umum: hypervisor sedang digunakan secara berlebihan.  Memang, dengan banyak VM berjalan dan memakan banyak sumber daya CPU, persaingan tinggi, dan pemanfaatan menurut LA lebih besar dari 1 (standar menurut utas CPU).  Semuanya tertinggal dalam semua VM.  <i>Mencuri yang</i> dikirim dari hypervisor juga tumbuh.  Anda harus mendistribusikan ulang muatan atau mematikan sesuatu.  Secara keseluruhan, ini semua logis dan langsung. <br><br>  Paravirtualization vs instance tunggal.  Hanya ada satu VM di hypervisor.  VM mengkonsumsi sebagian kecil dari itu, tetapi memberikan beban input / output yang tinggi, misalnya, untuk drive.  Tanpa diduga, <i>mencuri</i> kecil kurang dari 10% muncul (karena beberapa tes yang kami lakukan menunjukkan). <br><br>  Ini adalah kasus yang aneh.  Di sini, <i>mencuri</i> muncul karena kunci pada tingkat perangkat paravirtualized.  Di dalam VM, breakpoint dibuat.  Ini diproses oleh pengemudi dan pergi ke hypervisor.  Karena pemrosesan breakpoint pada hypervisor, VM melihat ini sebagai permintaan yang dikirim.  Sudah siap untuk menjalankan dan menunggu CPU, tetapi tidak menerima waktu CPU.  VM berpikir bahwa waktunya telah dicuri. <br><br>  Ini terjadi ketika buffer dikirim.  Ia pergi ke ruang kernel hypervisor dan kami menunggu untuk itu.  Dari sudut pandang VM, itu harus segera kembali.  Karena itu, menurut algoritma perhitungan <i>mencuri</i> kami, kali ini dianggap dicuri.  Sangat mungkin bahwa mekanisme lain mungkin terlibat dalam hal ini (misalnya pemrosesan <i>panggilan sistem</i> lain), tetapi mekanisme tersebut tidak boleh berbeda secara signifikan. <br><br>  Penjadwal vs VM yang sangat dimuat.  Ketika satu VM menderita <i>mencuri</i> lebih dari yang lain, ini terhubung langsung dengan penjadwal.  Semakin besar beban yang dilakukan suatu proses pada CPU, semakin cepat penjadwal akan membuangnya, sehingga memungkinkan proses lain bekerja.  Jika VM mengonsumsi sedikit, itu akan mengalami hampir tidak <i>mencuri.</i>  Prosesnya baru saja duduk dan menunggu, dan perlu diberi lebih banyak waktu.  Jika VM memberikan beban maksimum pada semua core, prosesnya dibuang lebih sering dan VM diberikan lebih sedikit waktu. <br><br>  Lebih buruk lagi ketika proses dalam VM mencoba untuk mendapatkan lebih banyak CPU, karena mereka tidak dapat memproses data.  Maka OS pada hypervisor akan memberikan lebih sedikit waktu CPU karena optimasi yang adil.  Ini memproses bola salju, dan <i>mencuri</i> lonjakan setinggi langit, sementara VM lain mungkin bahkan tidak menyadarinya.  Semakin banyak core, semakin buruk bagi VM yang malang.  Singkatnya, banyak VM yang dimuat dengan banyak core paling menderita. <br><br>  Rendah LA tetapi <i>mencuri</i> ada.  Jika LA sekitar 0,7 (artinya hypervisor tampaknya kurang beban), tetapi ada <i>mencuri</i> di beberapa VM: <br><br><ul><li>  Contoh paravirtualization yang disebutkan di atas berlaku.  VM mungkin menerima metrik yang mengindikasikan <i>mencuri</i> , sedangkan hypervisor tidak memiliki masalah.  Menurut hasil pengujian kami, <i>mencuri</i> seperti itu cenderung tidak melebihi 10% dan tidak memiliki dampak yang signifikan pada kinerja aplikasi dalam VM. <br></li><li>  Parameter LA telah dihitung secara tidak benar.  Lebih tepatnya, itu telah dihitung dengan benar pada saat tertentu, tetapi ketika rata-rata, itu lebih rendah dari yang seharusnya selama satu menit.  Misalnya, jika satu VM (sepertiga dari hypervisor) mengkonsumsi semua CPU selama 30 detik, maka LA selama satu menit akan menjadi 0,15.  Empat VM seperti itu, yang bekerja pada saat yang sama, akan menghasilkan nilai 0,6.  Berdasarkan LA, Anda tidak akan dapat menyimpulkan bahwa selama 30 detik untuk masing-masing, <i>mencuri</i> hampir 25%. <br></li><li>  Sekali lagi, ini terjadi karena penjadwal, yang memutuskan bahwa seseorang "terlalu banyak makan" dan membuat mereka menunggu.  Sementara itu, ia akan mengubah konteks, memproses breakpoint, dan menangani masalah sistem penting lainnya.  Akibatnya, beberapa VM tidak mengalami masalah, dan yang lain menderita kerugian kinerja yang signifikan. <br></li></ul><br><h2>  4. Distorsi lainnya </h2><br>  Ada sejuta alasan yang mungkin untuk distorsi alokasi waktu CPU yang adil pada VM.  Sebagai contoh, hyperthreading dan NUMA menambah kompleksitas pada perhitungan.  Mereka mempersulit pemilihan inti yang digunakan untuk menjalankan suatu proses karena penjadwal menggunakan koefisien;  artinya bobot, yang menyulitkan perhitungan bahkan lebih dari ini ketika mengganti konteks. <br><br>  Ada distorsi yang muncul dari teknologi seperti Turbo Boost atau kebalikannya, mode hemat daya, yang mungkin secara artifisial meningkatkan atau mengurangi kecepatan inti CPU dan bahkan irisan waktu.  Menghidupkan Turbo Boost pada penurunan produktivitas satu utas CPU karena peningkatan kinerja di utas lainnya.  Pada saat itu, informasi mengenai kecepatan clock CPU saat ini tidak dikirim ke VM, yang berpikir bahwa seseorang mencuri waktunya (mis. Ia meminta 2 GHz dan mendapat separuh lebih banyak). <br><br>  Faktanya, ada banyak alasan untuk distorsi.  Anda dapat menemukan sesuatu yang lain sepenuhnya dalam sistem apa pun.  Saya sarankan mulai dengan buku-buku yang ditautkan di atas dan mendapatkan statistik dari hypervisor menggunakan alat-alat seperti perf, sysdig, systemtap, dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">puluhan lainnya</a> . <br><br><h2>  5. Kesimpulan </h2><br><ol><li>  Beberapa <i>mencuri</i> mungkin muncul karena paravirtualization dan ini dapat dianggap normal.  Sumber daring mengatakan bahwa nilai ini bisa 5-10%.  Itu tergantung pada aplikasi dalam VM, dan beban yang diletakkan VM pada perangkat fisiknya.  Penting untuk memperhatikan bagaimana perasaan aplikasi di dalam VM. <br></li><li>  Korelasi antara beban pada hypervisor dan <i>mencuri di</i> dalam VM tidak selalu pasti.  Kedua perhitungan <i>mencuri</i> bisa salah dalam beberapa kasus dan dengan beban yang berbeda. <br></li><li>  Penjadwal tidak menyukai proses yang meminta banyak sumber daya.  Ia mencoba memberi lebih sedikit kepada mereka yang meminta lebih.  Contoh besar berarti. <br></li><li>  Sedikit <i>mencuri</i> bisa menjadi normal tanpa paravirtualization juga (dengan mempertimbangkan beban dalam VM, kekhasan beban tetangga, distribusi beban antara benang, dan faktor lainnya). <br></li><li>  Jika Anda ingin menghitung <i>mencuri</i> dalam sistem tertentu, teliti berbagai kemungkinan, kumpulkan metrik, analisis secara menyeluruh, dan pikirkan cara mendistribusikan beban secara adil.  Apapun, mungkin ada penyimpangan, yang harus diverifikasi menggunakan tes atau melihatnya di debugger kernel. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453140/">https://habr.com/ru/post/id453140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453126/index.html">Penampilan UIA tidak sesederhana itu</a></li>
<li><a href="../id453128/index.html">Intisari telekomunikasi: 15 materi ahli tentang IPv6, IS, standar dan undang-undang di bidang TI</a></li>
<li><a href="../id453130/index.html">Kode korektif sistematis. Kode Grup Linier</a></li>
<li><a href="../id453136/index.html">Menulis API - mematahkan XML (dua)</a></li>
<li><a href="../id453138/index.html">Seni dan sains: proyek VITAE - banyak sidik jari di bunga bulan</a></li>
<li><a href="../id453146/index.html">Cara memanfaatkan konferensi secara maksimal</a></li>
<li><a href="../id453148/index.html">AirBnb mengabaikan akunnya</a></li>
<li><a href="../id453154/index.html">Sejarah Internet: Meningkatkan Interaktivitas</a></li>
<li><a href="../id453156/index.html">General Motors akan memberi jiwa bagi semua mobil barunya (digital shell)</a></li>
<li><a href="../id453158/index.html">Saya tidak tahu cara kerja prosesor, jadi saya menulis simulator perangkat lunak</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>