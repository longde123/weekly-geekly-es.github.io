<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤳🏾 🧦 🦍 Apa yang kita lakukan salah dengan Spring ↩️ 🕵🏿 📸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel ini saya ingin berbagi pengamatan tentang beberapa antipatterns yang ditemukan dalam kode aplikasi yang berjalan di Spring. Semuanya deng...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang kita lakukan salah dengan Spring</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472994/"><p> Pada artikel ini saya ingin berbagi pengamatan tentang beberapa antipatterns yang ditemukan dalam kode aplikasi yang berjalan di Spring.  Semuanya dengan satu atau lain cara muncul di kode hidup: entah saya menemukan mereka di kelas yang ada, atau saya tertangkap saat membaca karya rekan kerja. </p><br><p>  Saya harap Anda akan tertarik, dan jika setelah membaca Anda mengakui "dosa" Anda dan memulai jalan koreksi, saya akan sangat senang.  Saya juga mendesak Anda untuk membagikan contoh Anda sendiri di komentar, kami akan menambahkan yang paling aneh dan tidak biasa ke posting. </p><a name="habracut"></a><br><h4 id="autowired">  Autowired </h4><br><p> <code>@Autowired</code> hebat dan mengerikan adalah seluruh era di Musim Semi.  Anda masih tidak dapat melakukannya tanpa itu ketika menulis tes, tetapi dalam kode utama itu (PMSM) jelas berlebihan.  Dalam beberapa proyek terakhir saya, dia sama sekali tidak.  Untuk waktu yang lama kami menulis seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ServiceDependency; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> AnotherServiceDependency; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Alasan mengapa injeksi ketergantungan melalui ladang dan setter dikritik telah dijelaskan secara rinci, khususnya di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Alternatif adalah implementasi melalui konstruktor.  Mengikuti tautan, sebuah contoh dijelaskan: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyA dependencyA; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyB dependencyB; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyC dependencyC; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DependencyA dependencyA, DependencyB dependencyB, DependencyC dependencyC)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyA = dependencyA; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyB = dependencyB; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyC = dependencyC; }</code> </pre> <br><p>  Kelihatannya kurang lebih layak, tetapi bayangkan kita memiliki 10 dependensi (ya, ya, saya tahu bahwa dalam hal ini mereka perlu dikelompokkan ke dalam kelas yang terpisah, tetapi sekarang ini bukan tentang itu).  Gambar tidak lagi begitu menarik: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyA dependencyA; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyB dependencyB; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyC dependencyC; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyD dependencyD; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyE dependencyE; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyF dependencyF; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyG dependencyG; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyH dependencyH; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyI dependencyI; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DependencyJ dependencyJ; <span class="hljs-meta"><span class="hljs-meta">@Autowired</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DI</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* ... */</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyA = dependencyA; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyB = dependencyB; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyC = dependencyC; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyD = dependencyD; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyE = dependencyE; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyF = dependencyF; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyG = dependencyG; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyH = dependencyH; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyI = dependencyI; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dependencyJ = dependencyJ; }</code> </pre> <br><p>  Kode itu terus terang, itu terlihat mengerikan. </p><br><p>  Dan di sini, banyak yang lupa itu di sini juga <del>  pemain biola </del>  <code>@Autowired</code> tidak diperlukan!  Jika sebuah kelas hanya memiliki satu konstruktor, maka Spring (&gt; = 4) akan memahami bahwa dependensi perlu diimplementasikan melalui konstruktor ini.  Jadi kita bisa membuangnya, menggantinya dengan Lombok <code>@AllArgsContructor</code> .  Atau bahkan lebih baik - pada <code>@RequiredArgsContructor</code> , tanpa lupa menyatakan semua bidang yang diperlukan <code>final</code> dan menerima inisialisasi objek yang aman dalam lingkungan multi-berulir (asalkan semua dependensi juga diinisialisasi dengan aman): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DI</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyA dependencyA; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyB dependencyB; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyC dependencyC; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyD dependencyD; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyE dependencyE; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyF dependencyF; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyG dependencyG; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyH dependencyH; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyI dependencyI; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> DependencyJ dependencyJ; }</code> </pre> <br><h4 id="staticheskie-metody-v-utilitnyh-klassah-i-enum-funkcii">  Metode statis di kelas utilitas dan fungsi enum </h4><br><p>  Bloody E sering memiliki tugas untuk mengkonversi objek data dari satu lapisan aplikasi ke objek serupa dari lapisan lain.  Untuk ini, kelas utilitas dengan metode statis seperti ini masih digunakan (ingat, pada tahun 2019): </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@UtilityClass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Utils</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> UserDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entityToDto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEntity user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> <br><p>  Pengguna yang lebih maju yang membaca buku pintar menyadari sifat magis enumerasi: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Function implements Function&lt;UserEntity, UserDto&gt; { INST; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> UserDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEntity user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> <br><p>  Benar, dalam hal ini, panggilan masih terjadi ke satu objek, dan bukan ke komponen yang dikendalikan oleh Spring. <br>  Bahkan cowok yang lebih mahir (dan perempuan) tahu tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MapStruct</a> , yang memungkinkan Anda untuk mendeskripsikan semuanya dalam satu antarmuka: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Mapper</span></span>(componentModel = <span class="hljs-string"><span class="hljs-string">"spring"</span></span>, unmappedTargetPolicy = ReportingPolicy.ERROR) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CriminalRecommendationMapper</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">UserDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEntity user)</span></span></span></span>; }</code> </pre> <br><p>  Sekarang kita mendapatkan komponen pegas.  Sepertinya kemenangan.  Tetapi iblis ada dalam perinciannya, dan kebetulan kemenangan menjadi luar biasa.  Pertama, nama bidang harus sama (jika wasir mulai), yang tidak selalu nyaman, dan kedua, jika ada transformasi bidang kompleks dari objek yang diproses, kesulitan tambahan muncul.  Nah, mapstruct itu sendiri perlu ditambahkan tergantung. </p><br><p>  Dan sedikit orang yang mengingat cara kuno, tetapi tetap sederhana dan bekerja untuk mendapatkan konverter pegas: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.springframework.core.convert.converter.Converter; <span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserEntityToDto</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Converter</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserDto</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> UserDto </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">convert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UserEntity user)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> <br><p>  Keuntungannya di sini adalah di kelas lain, saya hanya perlu menulis </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DI</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Converter&lt;UserEntity, UserDto&gt; userEnityToDto; }</code> </pre> <br><p>  dan Spring akan menyelesaikan semuanya sendiri! </p><br><h4 id="nenuzhnyy-qualifier">  Kualifikasi Limbah </h4><br><p>  Kasus hidup: aplikasi bekerja dengan dua basis data.  Dengan demikian, ada dua sumber data ( <code>java.sql.DataSource</code> ), dua manajer transaksi, dua kelompok repositori, dll.  Semua ini mudah dijelaskan dalam dua pengaturan terpisah.  Ini untuk Postgre: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PsqlDatasourceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@Primary</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties</span></span>(prefix = <span class="hljs-string"><span class="hljs-string">"spring.datasource.psql"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">psqlDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder.create().build(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SpringLiquibase </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primaryLiquibase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ProfileChecker checker, @Qualifier(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"psqlDataSource"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> DataSource dataSource ) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isTest = checker.isTest(); SpringLiquibase liquibase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpringLiquibase(); liquibase.setDataSource(dataSource); liquibase.setChangeLog(<span class="hljs-string"><span class="hljs-string">"classpath:liquibase/schema-postgre.xml"</span></span>); liquibase.setShouldRun(isTest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> liquibase; } }</code> </pre> <br><p>  Dan ini untuk DB2: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Db2DatasourceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties</span></span>(prefix = <span class="hljs-string"><span class="hljs-string">"spring.datasource.db2"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">db2DataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder.create().build(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SpringLiquibase </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">liquibase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ProfileChecker checker, @Qualifier(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"db2DataSource"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> DataSource dataSource ) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isTest = checker.isTest(); SpringLiquibase liquibase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpringLiquibase(); liquibase.setDataSource(dataSource); liquibase.setChangeLog(<span class="hljs-string"><span class="hljs-string">"classpath:liquibase/schema-db2.xml"</span></span>); liquibase.setShouldRun(isTest); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> liquibase; } }</code> </pre> <br><p>  Karena saya memiliki dua database, untuk pengujian saya ingin menggulung dua DDL / DML terpisah.  Karena kedua konfigurasi dimuat pada saat yang sama ketika aplikasi habis, jika saya <code>@Qualifier</code> , maka Spring akan kehilangan tujuan penargetannya dan, paling-paling, akan gagal.  Ternyata <code>@Qualifier</code> rumit dan rentan terhadap goresan, dan tanpa mereka tidak akan berhasil.  Untuk memecahkan kebuntuan, Anda perlu menyadari bahwa ketergantungan dapat diperoleh tidak hanya sebagai argumen, tetapi juga sebagai nilai balik, dengan menulis ulang kode seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PsqlDatasourceConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-meta"><span class="hljs-meta">@Primary</span></span> <span class="hljs-meta"><span class="hljs-meta">@ConfigurationProperties</span></span>(prefix = <span class="hljs-string"><span class="hljs-string">"spring.datasource.psql"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> DataSource </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">psqlDataSource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DataSourceBuilder.create().build(); } <span class="hljs-meta"><span class="hljs-meta">@Bean</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SpringLiquibase </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">primaryLiquibase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProfileChecker checker)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isTest = checker.isTest(); SpringLiquibase liquibase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SpringLiquibase(); liquibase.setDataSource(psqlDataSource()); <span class="hljs-comment"><span class="hljs-comment">// &lt;----- liquibase.setChangeLog("classpath:liquibase/schema-postgre.xml"); liquibase.setShouldRun(isTest); return liquibase; } } //... @Configuration public class Db2DatasourceConfig { @Bean @ConfigurationProperties(prefix = "spring.datasource.db2") public DataSource db2DataSource() { return DataSourceBuilder.create().build(); } @Bean public SpringLiquibase liquibase(ProfileChecker checker) { boolean isTest = checker.isTest(); SpringLiquibase liquibase = new SpringLiquibase(); liquibase.setDataSource(db2DataSource()); // &lt;----- liquibase.setChangeLog("classpath:liquibase/schema-db2.xml"); liquibase.setShouldRun(isTest); return liquibase; } }</span></span></code> </pre> <br><h4 id="javaxinjectprovider">  javax.inject.Provider </h4><br><p>  Bagaimana cara mendapatkan kacang dengan lingkup prototipe?  Saya sering menemukan ini </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@Scope</span></span>(SCOPE_PROTOTYPE) <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectBuilder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProjectFileConverter converter; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ProjectRepository projectRepository; <span class="hljs-comment"><span class="hljs-comment">//... } @Component @RequiredArgsConstructor public class PrototypeUtilizer { private final Provider&lt;ProjectBuilder&gt; projectBuilderProvider; void method() { ProjectBuilder freshBuilder = projectBuilderProvider.get(); } }</span></span></code> </pre> <br><p>  Tampaknya semuanya baik-baik saja, kodenya berfungsi.  Namun, dalam tong madu ini ada lalat di salep.  Kita perlu menyeret satu lagi <code>javax.inject:javax.inject:1</code> dependensi, yang ditambahkan ke Maven Central tepat 10 tahun yang lalu dan tidak pernah diperbarui sejak saat itu. </p><br><p>  Tetapi Spring telah lama dapat melakukan hal yang sama tanpa kecanduan pihak ketiga!  Cukup ganti <code>javax.inject.Provider::get</code> dengan <code>org.springframework.beans.factory.ObjectFactory::getObject</code> dan semuanya bekerja dengan cara yang sama. </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@RequiredArgsConstructor</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrototypeUtilizer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ObjectFactory&lt;ProjectBuilder&gt; projectBuilderFactory; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ProjectBuilder freshBuilder = projectBuilderFactory.getObject(); } }</code> </pre> <br><p>  Sekarang kita dapat, dengan hati nurani yang jelas, memotong <code>javax.inject</code> dari daftar dependensi. </p><br><h4 id="ispolzovanie-strok-vmesto-klassov-v-nastroykah">  Menggunakan string sebagai ganti kelas dalam pengaturan </h4><br><p>  Contoh umum menghubungkan repositori Data Spring ke proyek: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(<span class="hljs-string"><span class="hljs-string">"com.smth.repository"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Di sini kami secara eksplisit meresepkan paket yang akan dilihat oleh Spring.  Jika kami mengizinkan sedikit penamaan tambahan, maka aplikasi akan macet saat startup.  Saya ingin mendeteksi kesalahan bodoh seperti itu pada tahap awal, dalam batas - tepat saat mengedit kode.  Kerangka kerja menuju kita, sehingga kode di atas dapat ditulis ulang: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(basePackageClasses = AuditRepository.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JpaConfig</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br><p>  Di sini <code>AuditRepository</code> adalah salah satu repositori paket yang akan kita lihat.  Karena kita menunjukkan kelas, kita perlu menghubungkan kelas ini ke konfigurasi kita, dan sekarang kesalahan ketik akan dideteksi secara langsung di editor atau, paling buruk, ketika membangun proyek. </p><br><p>  Pendekatan ini dapat diterapkan dalam banyak kasus serupa, misalnya: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ComponentScan</span></span>(basePackages = <span class="hljs-string"><span class="hljs-string">"com.smth"</span></span>)</code> </pre> <br><p>  berubah menjadi </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.smth.Smth; <span class="hljs-meta"><span class="hljs-meta">@ComponentScan</span></span>(basePackageClasses = Smth.class)</code> </pre> <br><p>  Jika kita perlu menambahkan beberapa kelas ke kamus dari bentuk <code>Map&lt;String, Object&gt;</code> , maka ini bisa dilakukan seperti ini: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalContainerEntityManagerFactoryBean bean)</span></span></span><span class="hljs-function"> </span></span>{ String property = <span class="hljs-string"><span class="hljs-string">"hibernate.session_factory.session_scoped_interceptor"</span></span>; bean.getJpaPropertyMap().put(property, <span class="hljs-string"><span class="hljs-string">"com.smth.interceptor.AuditInterceptor"</span></span>); }</code> </pre> <br><p>  tetapi lebih baik menggunakan tipe eksplisit: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.smth.interceptor.AuditInterceptor; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LocalContainerEntityManagerFactoryBean bean)</span></span></span><span class="hljs-function"> </span></span>{ String property = <span class="hljs-string"><span class="hljs-string">"hibernate.session_factory.session_scoped_interceptor"</span></span>; bean.getJpaPropertyMap().put(property, AuditInterceptor.class); }</code> </pre> <br><p>  Dan ketika ada sesuatu seperti </p><br><pre> <code class="java hljs">LocalContainerEntityManagerFactoryBean bean = builder .dataSource(dataSource) .packages( <span class="hljs-comment"><span class="hljs-comment">//...     ) .persistenceUnit("psql") .build();</span></span></code> </pre> <br><p>  Perlu dicatat bahwa metode <code>packages()</code> kelebihan beban dan menggunakan kelas: <br><img src="https://habrastorage.org/webt/zt/tq/-8/zttq-8strhme7sjmgxc7ybnr6bu.png"></p><br><h4 id="ne-kladite-vse-biny-v-odin-paket">  Jangan memasukkan semua kacang dalam satu paket </h4><br><p>  Saya pikir dalam banyak proyek di Spring / Spring Booth Anda melihat struktur yang sama: </p><br><pre> <code class="plaintext hljs">root-package | \ repository/ entity/ service/ Application.java</code> </pre> <br><p>  Di sini <code>Application.java</code> adalah kelas root dari aplikasi: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SpringBootApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(basePackageClasses = SomeRepository.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ SpringApplication.run(Application.class, args); } }</code> </pre> <br><p>  Ini adalah kode microservice klasik: komponen disusun dalam folder sesuai dengan tujuannya, kelas dengan pengaturannya adalah di root.  Meskipun proyek ini kecil, maka semuanya baik-baik saja.  Seiring pertumbuhan proyek, paket lemak muncul dengan puluhan repositori / layanan.  Dan jika proyek tetap monolit, maka Gd bersama mereka.  Tetapi jika tugas muncul untuk membagi aplikasi yang berantakan menjadi beberapa bagian, maka pertanyaan dimulai.  Setelah mengalami rasa sakit ini sekali, saya memutuskan untuk mengambil pendekatan yang berbeda, yaitu mengelompokkan kelas berdasarkan domain mereka.  Hasilnya adalah sesuatu seperti </p><br><pre> <code class="plaintext hljs">root-package/ | \ user/ | \ repository/ domain/ service/ controller/ UserConfig.java billing/ | \ repository/ domain/ service/ BillingConfig.java //... Application.java</code> </pre> <br><p>  Di sini, paket <code>user</code> termasuk sub-paket dengan kelas-kelas yang bertanggung jawab atas logika pengguna: </p><br><pre> <code class="plaintext hljs">user/ | \ repository/ UserRepository.java domain/ UserEntity.java service/ UserService.java controller/ UserController.java UserConfig.java</code> </pre> <br><p>  Sekarang di <code>UserConfig</code> Anda dapat menjelaskan semua pengaturan yang terkait dengan fungsi ini: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Configuration</span></span> <span class="hljs-meta"><span class="hljs-meta">@ComponentScan</span></span>(basePackageClasses = UserServiceImpl.class) <span class="hljs-meta"><span class="hljs-meta">@EnableJpaRepositories</span></span>(basePackageClasses = UserRepository.class) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserConfig</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre> <br><p>  Keuntungan dari pendekatan ini adalah, jika perlu, modul dapat lebih mudah dialokasikan untuk layanan / aplikasi terpisah.  Ini juga berguna jika Anda bermaksud memodulasi proyek Anda dengan menambahkan <code>module-info.java</code> , menyembunyikan kelas utilitas dari dunia luar. </p><br><p>  Itu saja, saya harap, pekerjaan saya bermanfaat bagi Anda.  Jelaskan antipatterns Anda dalam komentar, kami akan mengatasinya bersama-sama :) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id472994/">https://habr.com/ru/post/id472994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id472978/index.html">Arduino menulis kursus untuk putranya sendiri</a></li>
<li><a href="../id472980/index.html">Celana pendek Belokamentseva</a></li>
<li><a href="../id472982/index.html">"Dengarkan untuk menemukan gangguan": rekaman audio dari mesin industri yang gagal diterbitkan</a></li>
<li><a href="../id472984/index.html">Troli truk ROS. Bagian 7. Lokalisasi robot: gmapping, AMCL, titik referensi pada peta kamar</a></li>
<li><a href="../id472988/index.html">Kami menganalisis nada suara dari teks menggunakan Fast.ai</a></li>
<li><a href="../id472996/index.html">Pentagon mengembangkan teknologi kontrol drone dengan pikiran tentara</a></li>
<li><a href="../id473000/index.html">Panduan matematika singkat untuk orang asing</a></li>
<li><a href="../id473002/index.html">Penjelasan paradoks Fermi dalam kerangka sosiologi ruang Liu Qixin</a></li>
<li><a href="../id473008/index.html">Hukum Pengembalian yang Dipercepat (Bagian 2)</a></li>
<li><a href="../id473012/index.html">Hasil Konferensi Mitra Advantech di Moskow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>