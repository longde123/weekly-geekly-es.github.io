<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌟 🐵 🛌🏿 Comment Namecoin Blockchain Research a prédit les cyber-attaques RTM 🧑🏽‍🤝‍🧑🏽 🧒🏽 🗿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La blockchain Namecoin a été créée comme une alternative aux registraires DNS traditionnels, protégée de la censure et de la saisie forcée de domaine....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment Namecoin Blockchain Research a prédit les cyber-attaques RTM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/460857/"><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br>  La blockchain Namecoin a été créée comme une alternative aux registraires DNS traditionnels, protégée de la censure et de la saisie forcée de domaine.  Au cours des dernières années, des opérateurs de botnet tels que Dimnie, Shifu, RTM et Gandcrab ont commencé à l'utiliser pour gérer les adresses des serveurs C&amp;C. <br><br>  D'une part, la décentralisation et la stabilité de la blockchain empêchent les chercheurs et les prestataires de supprimer de tels domaines ou d'en prendre le contrôle.  D'autre part, l'infrastructure basée sur la blockchain a une caractéristique architecturale: tous les changements dans le réseau sont accessibles au public et peuvent être utilisés pour étudier et suivre les actions des attaquants. <br><br>  Cet article présente l'approche utilisée pour cartographier les botnets en Namecoin et les suivre pour extraire de nouveaux IOC.  En utilisant l'approche décrite, des listes d'actifs (voir l'annexe) utilisées par les botnets mentionnés ci-dessus ont été compilées. <br><a name="habracut"></a><br><h2>  Digression lyrique </h2><br>  Les inventions qui modifient Internet résolvent souvent non seulement et pas tant un problème technique que social.  Ce sont précisément ces technologies et services qui permettent à la communauté de regarder de côté certains axiomes qui semblaient inébranlables, de les repenser, de recréer à partir de zéro, en ne laissant qu'une idée et en abandonnant la charge des conventions et des limitations héritées accumulées au fil des ans.  Blockchain et Bitcoin, Tor, Wikipedia - derrière le succès de chacun d'eux est un petit groupe de passionnés aux yeux brûlants, croyant sincèrement qu'ils font une société meilleure. <br><br>  Hélas, d'autres viennent souvent après eux - étrangers aux idéaux étranges des pionniers de l'Internet, mais beaucoup plus pratiques.  Ils trouvent <i>une</i> application <i>alternative</i> à la technologie, à laquelle les créateurs n'ont pas pensé (ou n'ont pas voulu penser).  Étant à la frontière (et le plus souvent, pour cacher, franchement à l'étranger) du admissible, cette application alternative, souvent non sans l'aide des médias, pour la majorité se transforme en un <i>défaut implicite</i> , voire le <i>seul</i> . <br><br>  L'équivalence de la technologie en tant qu'idée et la méthode la plus discutée de son utilisation peuvent conduire au rejet par la société de la technologie elle-même.  Du fait de la criminalisation de son utilisation, un service immature peut être réduit au niveau d'une culture marginale ou complètement détruit.  C'est donc arrivé il y a longtemps avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Napster</a> , il n'y a pas si longtemps - avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">BitTorrent</a> et Tor, en ce moment, cela se produit avec Bitcoin. <br><br>  Ce n'est pas passé le héros de ce travail - Namecoin.  Namecoin est une chaîne de blocs conçue pour stocker des paires clé-valeur arbitraires, dont la plus célèbre est un système d'enregistrement de nom DNS décentralisé et résistant à la censure - Dot-Bit. <br><br>  Notre intérêt pour Namecoin a grandi après que le groupe de gestion du botnet RTM a commencé à utiliser Dot-Bit pour gérer ses serveurs C&amp;C.  À un moment donné, nous nous sommes demandé - est-il possible de détecter de nouveaux serveurs C &amp; C immédiatement après leur enregistrement dans Dot-Bit?  Et s'il n'y a pas eu de problèmes avec les mises à jour de domaines bien connus, le développement d'une approche qui permet de détecter des preuves solides de la connexion de nouveaux domaines avec une personne d'intérêt s'est soudain avéré être une tâche de recherche passionnante, dont le résultat a été ce travail. <br><br>  En général, la recherche Namecoin et la collecte d'indicateurs de compromis en Dot-Bit ont été effectuées plus tôt.  Le travail le plus détaillé peut être considéré comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un article de Kevin Perlow</a> .  Il a été le premier à attirer l'attention sur la possibilité fondamentale d'extraire des données de Namecoin et a décrit plusieurs techniques heuristiques qui permettent à un expert de trouver des domaines de caractéristiques similaires aux serveurs C&amp;C bien connus d'un groupe particulier. <br><br>  L'approche présentée dans cette étude présente plusieurs différences significatives par rapport à la technique experte d'indexation et de pivotement décrite par Kevin.  Les règles heuristiques que nous avons développées pour déterminer les propriétaires de domaine dérivent des principes de la blockchain et de la formation de transactions en son sein et, en plus de la description générale, sont présentées sous la forme de formulations logiques strictes.  Avec une description formelle de l'algorithme de contournement, cela vous permet d'automatiser la recherche d'IOC, ce qui augmente considérablement l'efficacité de l'enquête.  De plus, l'algorithme développé permet non seulement de trouver d'autres noms qui étaient autrefois utilisés par le groupe d'étude, mais vous permet également de suivre la création de nouveaux domaines contrôlés par la même personne. <br><br>  Tout le travail est divisé en trois chapitres.  Le premier chapitre décrit les bases du Bitcoin, dont le code a été utilisé comme plate-forme pour créer Namecoin.  De nombreuses entités, relations et leurs implémentations définies dans Bitcoin ont été héritées par Namecoin.  Leur compréhension est cruciale pour une discussion plus approfondie. <br><br>  Le deuxième chapitre est consacré directement à Namecoin et à son application principale - Dot-Bit. <br><br>  Le troisième chapitre décrit l'approche proposée pour extraire des données de Namecoin, et donne également une description formelle de l'algorithme de contournement de la blockchain et des règles heuristiques utilisées pour établir des relations entre les domaines. <br><br>  Les annexes contiennent des IOC collectés à l'aide de la méthode décrite pour certains réseaux de zombies, ainsi qu'une liste de références et de référentiels qui aideront les chercheurs qui souhaitent continuer à travailler sur ce sujet. <br><br><h2>  Bitcoin 201 </h2><br>  La plupart des informations de cette section sont collectées à partir des documents de la série d'articles de Sergey <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">Pavlov_dog</a> Potekhin « <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bitcoin en bref</a> ».  Pour les lecteurs russophones, cette source est, à notre avis, la plus complète et la plus approfondie accessible au public, mais elle est étonnamment facile à lire.  Chercheurs intéressés par le dispositif interne de Bitcoin, nous vous invitons à ne pas vous limiter aux extraits donnés dans cette section, mais à vous familiariser avec le texte intégral des articles, disponible via le lien dans l'application.  Le reste des informations présentées ci-dessous sera suffisant pour comprendre la description de l'algorithme et des règles heuristiques pour trouver la relation entre les adresses en Namecoin, donnée dans le dernier chapitre. <br><br>  Bien qu'il soit habituel de commencer l'histoire de la blockchain avec des blocs et de la cryptographie qui les relie, nous commencerons par les transactions. <br><br><h3>  Transaction </h3><br>  Comme vous le savez, l'analogue le plus proche de Bitcoin est un livre de comptes dans lequel toutes les transactions avec des pièces sont enregistrées.  Mais, étrangement, dans Bitcoin, il n'y a pas de tableau général du formulaire <code>&lt;, &gt;</code> , tout comme il n'y a pas de comptable en chef qui éditerait ce tableau. <br><br>  Au lieu de cela, la blockchain très notoire est utilisée, c'est-à-dire que toutes les transactions sont généralement stockées.  Pour simplifier, nous pouvons supposer que ce sont des messages de la forme: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span><span class="hljs-tag">&gt;</span></span> sent <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">amount</span></span></span><span class="hljs-tag">&gt;</span></span> BTC to <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">address</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Donc, si vous parcourez toute la blockchain, vous pouvez calculer combien de pièces «appartiennent» à une adresse particulière. <br><br><h4>  Entrées et sorties </h4><br>  Une transaction réelle sur un réseau Bitcoin est un peu plus compliquée que celle décrite ci-dessus.  Il s'agit d'une structure dont les principaux composants sont les entrées et les sorties. <br><br>  Les entrées sont des transactions auxquelles vous vous référez.  Imaginez que trois transactions ont été envoyées à votre adresse X une fois: <br><br><pre> <code class="json hljs">TXN_ID: <span class="hljs-number"><span class="hljs-number">123456</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">40</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">645379</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">10</span></span> BTC TXN_ID: <span class="hljs-number"><span class="hljs-number">888888</span></span>, VALUE: <span class="hljs-number"><span class="hljs-number">100</span></span> BTC</code> </pre> <br>  Si vous devez dépenser, par exemple, <code>45 BTC</code> , vous pouvez vous référer à la transaction <code>888888</code> ou à deux transactions à la fois: <code>123456</code> et <code>645379</code> . <br><br>  Sorties - littéralement "sorties".  Nous pouvons supposer que ce sont des «adresses» auxquelles des pièces seront «envoyées» à la suite de la transaction.  Il peut également y avoir plusieurs sorties, chacune ayant son propre montant. <br><br>  Dans l'image ci-dessous, une nouvelle transaction <code>C</code> , qui fait référence à deux sorties - <code>A</code> et <code>B</code>  En conséquence, la transaction a <code>0.008 BTC</code> à l'entrée, qui sont ensuite divisés en deux sorties - <code>0.001 BTC</code> envoyé à la première adresse et <code>0.006 BTC</code> à la seconde. <br><br><img src="https://habrastorage.org/webt/hc/jj/-v/hcjj-vgrvls-t0qv4alrdutq1mm.png" alt="image"><br><br>  La possibilité de spécifier plusieurs sorties à la fois est une caractéristique très importante, car <b>la sortie de transaction ne peut être utilisée comme entrée qu'une seule fois et uniquement dans son intégralité</b> .  Si vous avez une transaction entrante à <code>10 BTC</code> et que vous devez en dépenser 8, vous créez simplement une transaction avec une entrée et deux sorties: <code>8 BTC</code> pour le vendeur et <code>2 BTC</code> pour votre adresse.  Si vous créez une transaction dans laquelle la somme des sorties est inférieure à la somme des entrées (comme dans l'image), la différence est envoyée à l'adresse du mineur qui a écrit votre transaction dans le bloc. <br><br><h2>  Frais </h2><br>  C'est cette différence entre la somme des entrées et la somme des sorties qui est appelée « <code>transaction fee</code> », <code>transaction fee</code> .  C'est la deuxième source de revenus la plus importante pour les mineurs, et le temps qu'il faut pour que la transaction soit incluse dans la blockchain en dépend.  Cela est dû au fait que chaque mineur dispose d'un certain pool de transactions non vérifiées qui prétendent être dans le bloc, et, en règle générale, le mineur les trie simplement par ordre décroissant, maximisant ainsi leur profit.  Par conséquent, plus la commission est élevée, plus vous serez dans la file d'attente et plus votre paiement ira vite. <br><br>  La vue générale de la transaction est décrite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spécification officielle du protocole</a> , ici un des cas particuliers les plus courants est donné. <br><br><img src="https://habrastorage.org/webt/sy/s-/g1/sys-g1dafvutkmxwetsud1urhng.png"><br><br>  <code>previous output hash</code> - identifiant (hachage) de la transaction à laquelle nous faisons référence.  <code>previous output index</code> - puisque nous devons nous référer non pas à la transaction elle-même, mais à l'une de ses sorties, alors dans ce paramètre, nous indiquons quelle sortie particulière nous intéresse.  La numérotation commence à zéro.  <code>value</code> - la quantité de Satoshi ( <code>1/100000000</code> BTC) envoyée à la sortie.  Il est enregistré sous une forme peu endienne, c'est-à-dire <code>62 64 01 00 00 00 00 00</code> - c'est <code>0x016462</code> ou <code>0.00091234 BTC</code> . <br><br>  Les paramètres de <code>block lock time</code> et de <code>sequence</code> sont rarement utilisés dans la pratique.  Nous ne sommes pas intéressés par eux, nous allons donc omettre la description de leur objectif. <br><br>  Mais sur les paramètres avec le mot <code>script</code> dans le titre, nous nous attardons plus en détail. <br><br><h4>  Script </h4><br>  Le réseau Bitcoin dispose d'un mécanisme basé sur des algorithmes cryptographiques avec une clé publique qui vous permet de créer un système dans lequel seul le propriétaire de la clé peut utiliser les pièces associées à l'adresse obtenue à partir de cette clé.  Nous allons voir comment cela est mis en œuvre sous le capot. <br><br>  Pour commencer, à l'intérieur de Bitcoin, il existe un langage de programmation empilé simple appelé <code>Script</code> .  Voici le programme de script le plus simple: <br><br><pre> <code class="xml hljs">2 3 OP_ADD 5 OP_EQUAL</code> </pre> <br>  Chaque instruction est appelée <code>opcode</code> , il y en a environ 80. L'image ci-dessous montre le processus d'exécution du programme ci-dessus. <br><br><img src="https://habrastorage.org/webt/du/p0/a9/dup0a971icbk3mhhz1k7vfsipg0.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/6k/pexz6k4icaot60gal2hc7y_iijk.png"><br><br><img src="https://habrastorage.org/webt/ie/nr/sg/ienrsgzd8tb5ncdwaxvvpzzdfku.png"><br><br><img src="https://habrastorage.org/webt/n8/zy/ve/n8zyvevbelp1wm7za8aksy-kcpi.png"><br><br><img src="https://habrastorage.org/webt/gx/aw/v_/gxawv_arrvb86zydou0zm22qhi0.png"><br><br>  Dans Bitcoin <code>Script</code> est utilisé pour définir une condition dans laquelle il sera possible de dépenser la sortie et de pouvoir confirmer que la condition est remplie.  La condition ( <code>locking script</code> ) est stockée dans la transaction dans le champ <code>scriptPubKey</code> pour chaque sortie.  La confirmation que la condition est remplie ( <code>unlocking script</code> ) est écrite dans le champ <code>scriptSig</code> pour chaque entrée. <br><br>  Pour vérifier le droit d'utiliser la sortie, vous devez connecter le <code>unlocking script</code> + le <code>locking script</code> et exécuter le programme résultant dans son ensemble.  Si après exécution, <code>TRUE</code> reste au sommet de la pile, alors la transaction est valide. <br><br><a name="P2PKH"></a><br><h4>  Payer au hachage de clé publique (P2PKH) </h4><br>  Le script <code>P2PKH</code> utilisé dans la plupart des transactions, vous devez donc comprendre comment il fonctionne.  Voici sa vue générale: <br><br><img src="https://habrastorage.org/webt/yc/l5/bz/ycl5bz9rlakm74fw8zztbhesnbm.png"><br><br>  Ce script est connu depuis l'avènement du Bitcoin, et il effectue la tâche mentionnée au début du chapitre - s'assurer que seul le propriétaire de la clé peut utiliser les pièces associées à l'adresse obtenue à partir de cette clé. <br><br>  L'idée est la suivante: laissez votre ami <code>B</code> posséder une paire de clés - <code>P</code> (privé) et <code>K</code> (public).  À l'aide de la fonction de hachage, il obtient l'adresse <code>A</code> de la clé publique et vous indique l'adresse.  Ensuite, vous envoyez, par exemple, <code>1 BTC</code> à l'adresse <code>A</code> et écrivez ce qui suit dans le champ du <code>locking script</code> : <br><br><blockquote>  Seule une personne possédant la clé privée de l'adresse <code>A</code> peut dépenser cette transaction.  Pour preuve, écrivez dans le <code>unlocking script</code> , d'une part, la clé publique <code>K</code> , et d'autre part, la signature de la transaction avec la clé privée <code>P</code> <br></blockquote><br>  Lorsque <code>B</code> décide d'utiliser votre transaction comme entrée, il crée, par exemple, <code>0.5 BTC</code> , et dans le champ de <code>unlocking script</code> , <code>unlocking script</code> met la signature de sa transaction avec la clé privée <code>P</code> - <code>sig</code> et la clé publique K- <code>PubK</code> . <br><br>  Voici le processus d'exécution du programme combiné: <br><br><img src="https://habrastorage.org/webt/et/zx/tw/etzxtwxr3qihzwza6e43rrymdcs.png"><br><br><img src="https://habrastorage.org/webt/yj/bs/1n/yjbs1nuol2e6ut1rp_p9iifi9z4.png"><br><br><img src="https://habrastorage.org/webt/ia/eo/kb/iaeokbdrdznakoutfhiuu2m53xu.png"><br><br><img src="https://habrastorage.org/webt/ix/zh/v2/ixzhv2l0_qhjxgn55tjung8tyng.png"><br><br><img src="https://habrastorage.org/webt/3f/ah/zf/3fahzfikukod-rbz-29tufqlry8.png"><br><br><img src="https://habrastorage.org/webt/71/gf/2h/71gf2hcsfwo7eqtvmmmmdebz0pw.png"><br><br><img src="https://habrastorage.org/webt/yk/f_/b7/ykf_b7fyo6hplbhax7wolaukqrk.png"><br><br><h2>  Blocs et blockchain </h2><br>  Si la blockchain entière est un livre, les blocs individuels peuvent être représentés comme des pages sur lesquelles les transactions sont enregistrées.  Chaque bloc "se réfère" au précédent, et ainsi de suite jusqu'au tout premier bloc ( <code>genesis block</code> ).  C'est ce qui crée une telle fonctionnalité de la blockchain que l'immuabilité.  Vous ne pouvez pas prendre et modifier le bloc <code>#123</code> pour que personne ne le remarque: la blockchain est conçue de manière à entraîner un changement dans le bloc <code>#124</code> , puis <code>#125</code> et ainsi de suite, tout en haut. <br><br>  La structure du bloc ressemble à ceci: <br><br><img src="https://habrastorage.org/webt/bs/kp/3d/bskp3dzxovwwy4zx-s-pxzromgu.png"><br><br>  Les six premiers paramètres (tous sauf <code>txn_count</code> et <code>txns</code> ) forment l'en-tête du bloc.  Le hachage d'en-tête est appelé hachage de bloc;  Les transactions elles-mêmes ne participent pas directement au hachage.  <code>merkle_root</code> est responsable de leur immuabilité - s'il est simplifié, il s'agit d'un hachage de toutes les transactions dans le bloc.  Vous pouvez en savoir plus sur l'algorithme de construction de l'arbre Merkle ici sur ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lien</a> . <br><br>  Le nonce et les bits sont directement liés au processus d'apparition des blocs - minage. <br><br><h3>  Exploitation minière </h3><br>  Le minage est un processus critique pour Bitcoin, consistant à créer de nouveaux blocs et à poursuivre deux objectifs à la fois.  Le premier est la production de masse monétaire.  Chaque fois qu'un mineur crée un nouveau bloc, il est récompensé pour cela avec le Nième nombre de pièces qu'il dépense ensuite quelque part, lançant ainsi de nouveaux fonds dans le réseau. <br><br>  Le deuxième objectif, beaucoup plus important, est de contrôler le respect des règles du réseau.  Ce sont les mineurs qui vérifient les scripts et les entrées de transaction avant de les inclure dans le bloc. <br><br>  Ceux qui souhaitent en savoir plus sur les fondements financiers du Bitcoin peuvent conseiller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cet article</a> .  Je n'accorderai pas beaucoup d'attention au premier aspect de l'exploitation minière et je me concentrerai sur le second - vérifier les transactions et les lancer sur le réseau. <br><br><h3>  Preuve de travail </h3><br>  Laissez-vous être mineur.  Vous avez 10 transactions que vous souhaitez inclure dans le bloc.  Vous vérifiez la validité de ces transactions, en forme un bloc, spécifiez 0 dans le champ <code>nonce</code> et considérez le hachage de bloc.  Puis changez <code>nonce</code> en 1, comptez à nouveau le hachage. <br><br>  Votre tâche consiste à trouver un <code>nonce</code> tel que le hachage de bloc (nombre 256 bits) soit inférieur à un nombre prédéterminé <code>N</code>  La recherche d'un tel hachage n'est possible que par le <code>nonce</code> force brute.  Par conséquent, plus vous voulez trouver rapidement du nonce, plus vous aurez besoin de puissance. <br><br>  Le nombre <code>N</code> est exactement ce paramètre (il est aussi appelé <code>target</code> ), que le réseau ajuste en fonction de la puissance totale des mineurs.  Si demain des blocs commencent à sortir, relativement parlant, toutes les trois minutes, alors <code>N</code> sera réduit, plus de temps sera nécessaire pour rechercher le nonce et <code>block time</code> augmentera à nouveau à 10 minutes.  Et vice versa. <br><br>  Voilà à quoi ressemble l'algorithme de preuve de travail sous-jacent à Bitcoin et à de nombreuses autres chaînes de blocs.  D'une simplicité apparente, il présente un certain nombre de caractéristiques importantes: <br><br><ul><li>  La création d'un nouveau bloc est une tâche difficile sur le plan des calculs.  Dans le même temps, la vérification de l'exactitude du bloc est une opération simple et presque instantanée. </li><li>  L'ensemble du réseau prend 10 minutes pour calculer un nouveau bloc (en moyenne).  L'heure spécifique est différente pour chaque blockchain, mais l'essentiel est que la durée moyenne est prédéfinie.  De plus, cette durée ne dépend pas du nombre de participants au réseau.  Même si un jour il y aura cent fois plus de mineurs, l'algorithme changera ses paramètres pour qu'il devienne plus difficile de trouver le <code>block time</code> et <code>block time</code> retombe au voisinage de l'heure spécifiée. <br><br>  Comme décrit ci-dessus, le processus d'exploration se résume à trouver un hachage de bloc inférieur à un nombre appelé <code>target</code> .  Dans la structure de blocs, ce nombre est écrit dans le champ des bits.  Par exemple, pour le bloc <code>#277316 target</code> était <code>1903a30c</code> . </li></ul><br>  Comme décrit ci-dessus, le processus d'exploration se résume à trouver un hachage de bloc inférieur à un nombre appelé <code>target</code> .  Dans la structure de blocs, ce nombre est écrit dans le champ des <code>bits</code> .  Par exemple, pour le bloc <code>#277316</code> <code>target</code> était <code>1903a30c</code> . <br><br><pre> <code class="json hljs">$ bitcoin-cli getblock <span class="hljs-number"><span class="hljs-number">0000000000000001</span></span>b<span class="hljs-number"><span class="hljs-number">6</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span>a<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-number"><span class="hljs-number">3</span></span>b<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">5</span></span>e<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">6</span></span>db<span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>c<span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-number"><span class="hljs-number">8</span></span>b<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">7</span></span>ef<span class="hljs-number"><span class="hljs-number">2</span></span>d<span class="hljs-number"><span class="hljs-number">9</span></span><span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-number"><span class="hljs-number">4</span></span>a<span class="hljs-number"><span class="hljs-number">9</span></span>b<span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-number"><span class="hljs-number">1</span></span>b<span class="hljs-number"><span class="hljs-number">2</span></span>cc<span class="hljs-number"><span class="hljs-number">7</span></span>bdc<span class="hljs-number"><span class="hljs-number">4</span></span> { <span class="hljs-attr"><span class="hljs-attr">"hash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"confirmations"</span></span> : <span class="hljs-number"><span class="hljs-number">35561</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span> : <span class="hljs-number"><span class="hljs-number">218629</span></span>, <span class="hljs-attr"><span class="hljs-attr">"height"</span></span> : <span class="hljs-number"><span class="hljs-number">277316</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span> : <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"merkleroot"</span></span> : <span class="hljs-string"><span class="hljs-string">"c91c008c26e50763e9f548bb8b2fc323735f73577effbc55502c51eb4cc7cf2e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tx"</span></span> : [<span class="hljs-string"><span class="hljs-string">"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f"</span></span>, ...], <span class="hljs-attr"><span class="hljs-attr">"time"</span></span> : <span class="hljs-number"><span class="hljs-number">1388185914</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nonce"</span></span> : <span class="hljs-number"><span class="hljs-number">924591752</span></span>, <span class="hljs-attr"><span class="hljs-attr">"bits"</span></span> : <span class="hljs-string"><span class="hljs-string">"1903a30c"</span></span>, // &lt;--   <span class="hljs-attr"><span class="hljs-attr">"difficulty"</span></span> : <span class="hljs-number"><span class="hljs-number">1180923195.25802612</span></span>, <span class="hljs-attr"><span class="hljs-attr">"chainwork"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000000000000000000000000000000000934695e92aaf53afa1a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"previousblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"0000000000000002a7bbd25a417c0374cc55261021e8a9ca74442b01284f0569"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"nextblockhash"</span></span> : <span class="hljs-string"><span class="hljs-string">"000000000000000010236c269dd6ed714dd5db39d36b33959079d78dfd431ba7"</span></span> }</code> </pre> <br>  En <code>bits</code> en fait, deux nombres sont écrits à la fois: le premier octet <code>0x19</code> est l'exposant, les trois autres octets <code>0x03a30c</code> sont la mantisse.  Pour obtenir la <code>target</code> partir de <code>bits</code> , vous devez utiliser la formule suivante: <br><br><pre> <code class="python hljs">target = mantissa * <span class="hljs-number"><span class="hljs-number">2</span></span>^(<span class="hljs-number"><span class="hljs-number">8</span></span> * (exponent - <span class="hljs-number"><span class="hljs-number">3</span></span>))</code> </pre> <br>  Mais ce sont des <code>bits</code> , en règle générale, qui sont indiqués dans tous les registres de blocs en ligne, tels que, par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://namecha.in/</a> - Registre de blocs Namecoin. <br><br>  Et oui, assez de théorie.  Tout ce dont nous avons parlé ci-dessus lorsqu'il est appliqué à Bitcoin s'applique également à Namecoin - à l'exception des petites différences, dont nous parlerons dans la section suivante. <br><br><h2>  Namecoin </h2><br>  <i>Namecoin</i> est une blockchain basée sur les algorithmes et le code source de Bitcoin, dont l'idée principale est d'utiliser un schéma de registre de transactions distribué pour gérer un système de nom de domaine, un analogue du DNS traditionnel. <br><br>  Namecoin copie les principales approches Bitcoin (Proof-of-Work, intervalle de génération de blocs de 10 minutes) et les formats de données, à l'exception de petits ajouts, dont nous parlerons plus tard. <br><br>  Les domaines Namecoin ont le suffixe .bit.  Cette zone n'a pas été allouée par l'IANA et n'a pas été affectée à la liste des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">domaines à usage spécial</a> .  Les serveurs DNS normaux répondent généralement à ces demandes NXDOMAIN.  Mais il existe des passerelles de DNS à Namecoin (par exemple, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">OpenNIC</a> ), des proxys publics avec prise en charge de Namecoin, des plug- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ins de</a> navigateur et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un projet open source</a> qui vous permet de démarrer votre propre serveur DNS avec prise en charge de Namecoin. <br><br>  Pour gérer un domaine avec le nom, disons <code>facebook.bit</code> , il suffit d'enregistrer la clé <code>d/facebook</code> préfixe <code>d/facebook</code> est utilisé dans Namecoin pour les domaines) et de déterminer sa valeur.  Le format JSON est utilisé pour définir les valeurs.  Une entrée qui définit la résolution de domaine sur l'adresse IP <code>1.2.3.4</code> ressemble à ceci: <br><br><pre> <code class="json hljs">{<span class="hljs-attr"><span class="hljs-attr">"ip"</span></span>: [<span class="hljs-string"><span class="hljs-string">"1.2.3.4"</span></span>]}</code> </pre> <br>  Namecoin attribue les noms sur la base du <i>premier arrivé, premier servi</i> .  Même pour Mark Zuckerberg lui-même, il sera cryptographiquement impossible de prendre le domaine <code>facebook.bit</code> au propriétaire. <br><br>  En fait, rien ne limite l'utilisation de Namecoin à la seule gestion des ensembles de noms DNS - adresse IP.  Namecoin peut être utilisé (et utilisé) comme table distribuée pour mapper des clés arbitraires à des valeurs.  Mais nous nous concentrerons précisément sur le scénario de son utilisation dans lequel il représente un DNS alternatif sur blockchain. <br><br><h2>  Gestion de domaine </h2><br>  Namecoin utilise une transaction pour stocker un enregistrement de domaine.  A savoir, le champ <code>scriptPubKey</code> contenant le programme est la condition pour utiliser la sortie de transaction, à laquelle nous avons consacré tant de temps dans le chapitre précédent.  Pour gérer les enregistrements, Namecoin a introduit trois nouveaux opérateurs (plus précisément, les opérateurs existants redéfinis): <br><br><ul><li>  NAME_NEW </li><li>  NAME_FIRSTUPDATE </li><li>  NAME_UPDATE </li></ul><br>  Leur signification ressort clairement des noms, mais nous analyserons néanmoins le but et le format d'utilisation de chacun d'eux. <br><br>  Vous pouvez remarquer que l'opérateur de suppression ou d'invalidation de domaine est manquant.  Pour nettoyer le registre des noms inutilisés, un mécanisme est intégré au réseau qui libère automatiquement un nom qui n'a pas été mis à jour depuis 36 000 blocs (~ 250 jours). <br><br><h3>  NAME_NEW </h3><br>  La première étape consiste à annoncer l'intention d'enregistrer un nouveau nom sur le réseau.  Pour ce faire, créez simplement une pièce spéciale (sortie) pesant au moins <code>0.01 NMC</code> , dont le <code>output script</code> ressemblera à ceci: <br><br><pre> <code class="xml hljs">OP_NAMENEW <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">20</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">byte</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">hash</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Pour le démontrer, je vais utiliser les transactions que Stephen Morse a faites pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">illustrer son article</a> . <br><br>  Donc, si nous voulons annoncer l'enregistrement du nom <code>d/stephenmorse</code> , alors nous devons faire ce qui suit: <br><br><img src="https://habrastorage.org/webt/q9/br/b8/q9brb8jrft9fyzc1vc2ph0ssade.png"><br><br>  En regardant la transaction qui en résulte, vous pouvez remarquer deux faits intéressants.  Premièrement, malgré le fait que le <code>output script</code> écrit en notation Namecoin, il est toujours valable du point de vue du Bitcoin d'origine.  Les créateurs de Namecoin ont si bien choisi les codes pour leurs opérations qu'en Bitcoin ils correspondent à des opérations qui sont essentiellement équivalentes à l'écriture dans la pile constante.  <code>NAME_NEW (0x51)</code> correspond à <code>OP_1</code> , qui pousse <code>OP_1</code> pile 1. Une histoire similaire avec <code>NAME_FIRSTUPDATE</code> ( <code>0x52</code> ou <code>OP_2</code> , met 2) et avec <code>NAME_UPDATE</code> ( <code>0x53</code> ou <code>OP_3</code> , met 3).  Ainsi, les deux premières étapes du script ne mettent que deux valeurs sur la pile.  Et la prochaine opération <code>OP_2DROP</code> supprime de la pile, de sorte que le <code>P2PKH</code> supplémentaire fonctionne «à partir de zéro».  Par conséquent, toutes ces astuces de script que nous avons couvertes dans le chapitre sur Bitcoin sont également applicables à Namecoin, malgré la redéfinition de certaines opérations. <br><br>  Deuxièmement, les clés qui ouvrent une pièce spéciale et la changent sont différentes.  Bien que rien ne vous empêche techniquement d'utiliser la même clé à plusieurs reprises, il est courant de générer une nouvelle clé pour chaque reçu.  Ceci est fait pour rendre difficile l'identification des corrélations entre les transactions et augmenter le niveau d'anonymat dans le réseau. <br><br>  À première vue, il semble étrange que, contrairement au bon sens, il soit impossible de prendre et d'enregistrer immédiatement un nom et une adresse IP pour celui-ci.  Ceci est fait pour que personne ne puisse intercepter le nom dès qu'il voit que vous voulez l'enregistrer (puis vous le revendre). <br><br>  Par exemple, les mineurs, en analysant les transactions non confirmées (qui ne sont encore incluses dans aucun des blocs) du réseau, pourraient créer leur propre transaction pour l'enregistrement du même domaine et l'inclure (et non la vôtre) dans leur bloc.  Pour implémenter cette attaque, il n'est même pas nécessaire de miner votre bloc.  Il suffira de mettre votre transaction sur le réseau moyennant des frais importants.  Par conséquent, deux opérations distinctes <code>NAME_NEW</code> et <code>NAME_FIRSTUPDATE</code> , et la seconde ne peut être effectuée que par celui qui a effectué la première, et uniquement après que <code>NAME_NEW</code> est entré dans un bloc. <br><br>  En fait, cette restriction est encore un peu plus stricte: <code>NAME_FIRSTUPDATE</code> est possible au plus tôt 12 blocs après <code>NAME_NEW</code> (soit environ 2 heures).  Pour comprendre pourquoi les blocs de cette restriction ne sont pas 1, pas 2, pas 3, mais spécifiquement 12, nous devrons prendre un peu de recul par rapport à l'histoire principale et comprendre ce que sont la <code>fork</code> et l' <code>51% attack</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Fourchette</b> <div class="spoiler_text">  Imaginez que les mineurs recherchent le bloc <code>#123456</code> .  Et à peu près au même moment, il a été retrouvé de façon indépendante par deux mineurs, dont l'un vit en Australie et l'autre aux États-Unis.  Chacun d'eux commence à disperser sa version du bloc sur le réseau, et en conséquence, il s'avère que la moitié du monde a une blockchain et l'autre en a une autre. <br><br><img src="https://habrastorage.org/webt/ov/a1/yq/ova1yqiulayufd1o7z6vbmwpb0e.png"><br><br>  Est-ce possible?  Oui c'est possible.  De plus, cela arrive assez souvent.  Dans ce cas, chaque nœud continue d'adhérer à sa propre version de la blockchain jusqu'à ce que quelqu'un trouve le bloc suivant.  Supposons que le nouveau bloc continue la branche verte, comme dans l'image ci-dessous.  Dans ce cas, les nœuds qui adhèrent à la version rouge synchronisent automatiquement le vert, car la règle fonctionne en Bitcoin (et, par conséquent, en Namecoin): la version la plus longue de la blockchain est vraie.  La version rouge de la blockchain sera tout simplement oubliée, ainsi que des récompenses pour ceux qui la trouveront. <br><br><img src="https://habrastorage.org/webt/br/le/xq/brlexqeynpgyq5qjq6u0knjla5q.png"><br><br>  Bien sûr, théoriquement, dans la deuxième étape, la situation peut se répéter et en même temps avec du violet, ils en trouveront une autre qui continuera la version rouge de la blockchain.  Et le troisième, et ainsi de suite.  Mais la probabilité que même la première fourchette soit plutôt faible, la seconde est encore moins et ainsi de suite.  La fourche la plus longue de l'histoire du Bitcoin n'était que de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">quatre blocs</a> .  Donc, à un moment donné, l'une des succursales va quand même prendre de l'avance et tout le réseau va y aller. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">51% attaque</b> <div class="spoiler_text">  Le fait que la chaîne la plus longue de la blockchain soit dominante est basé sur une attaque portant le nom de 51%. <br><br>  Imaginez que vous êtes un escroc et achetez des marchandises à <code>1000 BTC</code> dans un magasin.  Vous êtes d'accord avec le vendeur et lui envoyez l'argent.  Le vendeur vérifie la blockchain, voit qu'une telle transaction a vraiment été, a passé tous les contrôles et est même entré dans un bloc, par exemple <code>#123</code> .  Après cela, le vendeur va à la poste et vous envoie la marchandise. <br><br>  À ce moment, vous allumez votre ferme de minage et commencez le minage à partir du bloc <code>#122</code> .  Si vous avez suffisamment de puissance, vous pouvez dépasser le reste du réseau et compter le plus rapide pour bloquer le <code>#124</code> , après quoi le monde entier passera à votre version de la blockchain.  Dans le même temps, vous n'incluerez votre transaction pour <code>1000 BTC</code> dans aucun des blocs, ce qui signifie qu'elle sera à jamais oubliée, comme si elle ne l'avait jamais été.          . <br><br>         ,          .      .   11   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a>  , ,     6  ,      0,1%    ,    10% .        ,         . ,  Namecoin      ,     20%  . <br><br>       . ,        .    ,  <code>NAME_NEW</code> ,  12 ,       <code>NAME_FIRSTUPDATE</code> . <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_FIRSTUPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le but de l'opération </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est de publier le nom que j'ai annoncé </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et de lui spécifier une valeur. </font><font style="vertical-align: inherit;">Pour ce faire, je dois lancer une transaction sur le réseau, dont l'entrée est la pièce très spéciale que j'ai générée à la sortie </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Afin de confirmer le droit de l'utiliser, je présente dans le script d'entrée ma clé publique et la signature de la transaction </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectuée par la clé de paire privée, exactement selon le schéma que nous avons examiné dans le chapitre sur </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'un des résultats de la transaction sera une nouvelle pesée spéciale des pièces, comme la précédente, rien de moins </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Son script de sortie devrait être comme ceci:</font></font><br><br><pre> <code class="xml hljs">OP_NAME_FIRSTUPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Salt</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_2DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br> <code>Salt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Est le nombre très aléatoire </font></font><code>0xd5eeb22ee8117f57</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que nous avons créé lors de la première étape de préparation du script </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- il est </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en hexadécimal </font></font><code>0x642f7374657068656e6d6f727365</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le champ </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">doit contenir un tableau associatif représentant les règles selon lesquelles le nom sera résolu. Une liste complète des clés et règles possibles pour les remplir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . En première approximation, il s'agit d'un analogue du fichier de zone; le lien ci-dessus montre le mappage des entités Namecoin avec des entités DNS familières. Les plus populaires d'entre eux sont ip, un exemple avec lequel était plus élevé, et ns, que nous utilisons maintenant. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour indiquer ce que sera le serveur NS pour le domaine, nous </font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mettrons une valeur dans Value </font></font><code>{“ns”:[“1.2.3.4”]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais, bien sûr, en hexadécimal - </font></font><code>0x7b226e73223a5b22312e322e332e34225d7d</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme la dernière fois, fermez la pièce avec </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans son exemple, Stephen a délibérément créé une pièce à l'étape NAME_NEW avec un poids pas exactement </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais avec une marge, de sorte qu'à l'étape suivante, cette marge serait suffisante pour la commission au mineur. </font><font style="vertical-align: inherit;">Dans le cas général, la transaction aura une entrée de plus pour assurer la commission - et une sortie de plus pour la livraison. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous collectons tout dans une transaction et le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetons dans le réseau</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/nn/rt/cd/nnrtcdedqwwblvhs_wsdawyivpg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lorsque la transaction tombe dans le bloc, les hôtes mettront à jour dans leurs tables la valeur de la clé </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">activée </font></font><code>{“ns”:[“1.2.3.4”]}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tous les navigateurs prenant en charge Namecoin résoudront désormais le domaine </font></font><code>stephenmorse.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et ses sous-domaines en adresses IP via le serveur DNS situé à l'adresse </font></font><code>1.2.3.4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAME_UPDATE </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le «tableau» avec les clés et leur signification, que j'ai mentionné à la fin de la dernière section, est en fait appelé </font></font><code>UTXO set (unspent transaction output)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Puisqu'il est essentiel que le réseau empêche les dépenses répétées de fonds, avant d'ajouter une transaction au bloc, le mineur vérifie si les entrées précédemment spécifiées dans la transaction ont été utilisées. Pour accélérer cette opération, toutes les sorties inutilisées sont stockées dans une structure de données distincte. Cette structure n'existe pas au niveau du réseau, mais est calculée et stockée localement par chaque nœud. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Après avoir terminé la transaction </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la sortie de ma pièce avec un poids </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, à laquelle la valeur de la clé est attachée </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, a frappé la table</font></font><code>UTXO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si cette sortie n'est pas dépensée pour 36 000 blocs (soit plus de 8 mois avec 10 minutes par bloc en moyenne), alors elle sera considérée comme invalide et le nom correspondant comme gratuit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette période de 36 000 blocs (ainsi que la valeur minimale d'une pièce spéciale en </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) est clairement définie au début du réseau et reste inchangée. Pour prolonger l'enregistrement du nom, ainsi que pour toute modification de l'enregistrement ou le transférer à un autre propriétaire, une transaction est utilisée </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les règles pour la formation d'une telle transaction ne diffèrent pratiquement pas de celles décrites ci-dessus. L'entrée pour la transaction doit être la sortie de la pièce obtenue dans la transaction</font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Un apport supplémentaire est nécessaire pour assurer la commission. </font><font style="vertical-align: inherit;">Des deux sorties de la transaction, l'une est une nouvelle pièce avec une valeur mise à jour pour le nom, et la seconde est conçue pour transférer la modification de la commission. </font><font style="vertical-align: inherit;">Le format de script de sortie pour la pièce est:</font></font><br><br><pre> <code class="xml hljs">OP_NAME_UPDATE <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Value</span></span></span><span class="hljs-tag">&gt;</span></span> OP_2DROP OP_DROP <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">lock</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme dans le cas précédent, </font></font><code>Name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">il s'agit de </font><font style="vertical-align: inherit;">- </font></font><code>d/stephenmorse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- JSON avec une valeur, tous deux en hexadécimal. </font><font style="vertical-align: inherit;">Fermez la sortie à l'aide de P2PKH et lancez la transaction </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le réseau</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/webt/ny/2t/vq/ny2tvqbgf2fhkaiebkx2b9_fdkc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En général, c'est presque tout ce que je voulais dire sur la gestion des noms dans Namecoin. </font><font style="vertical-align: inherit;">Il ne reste plus qu'à dire quelques mots sur les coûts de possession d'un domaine.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Coût </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calculons combien le contenu du nom </font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(le nom de la zone DNS .bit, fonctionnant sur la base de Namecoin) coûte en crypto-monnaie et, en traduisant les nombres en monnaie fiduciaire, est comparable au coût d'un domaine DNS "normal". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, comme on peut le voir dans la section précédente, pour une transaction, les </font></font><code>NAME_NEW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coûts du propriétaire du domaine seront </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de créer une pièce à laquelle la zone sera attachée, plus la commission du mineur. Pour une transaction, une </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nouvelle pièce est créée au détriment de l'ancienne, et en plus le propriétaire ne paie que la commission. Après environ 8 mois, le propriétaire devra terminer la transaction </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour conserver le nom enregistré. Et c'est là que les coûts requis pour la première année se terminent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La plupart des articles sur Namecoin (y compris l' </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">article</font></a><font style="vertical-align: inherit;"> précédemment cité </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par Stephen Morse</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sont basées sur des données des premières années d'existence du réseau et affirment que la commission du mineur est de 0,005 NMC. Mais depuis lors, la valeur médiane de la commission a progressivement diminué et au début de 2019 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est d'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> environ 0,0003 NMC. Le taux de change du NMC par rapport au dollar américain, au contraire, ayant subi plusieurs hausses, est revenu au niveau de 2015 et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'élève à</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> environ 0,7 $ pour 1 NMC. Il est facile de calculer que le domaine dans la zone .bit la première année coûtera au propriétaire 0,0109 NMC ou 0,00763 $. Peut-être qu'il sera plus facile pour quelqu'un de se rappeler un analogue approximatif de ce montant en monnaie russe - 50 kopecks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, c'est la limite inférieure qui correspond au scénario d'achat d'un nom pour une utilisation future ou un cybersquattage. Et la limite supérieure? Étant donné que l'entrée de chaque transaction mettant à jour la zone doit être une pièce d'un des blocs précédents, le maximum théorique de la fréquence de mise à jour du nom est égal à la fréquence de l'apparition de nouveaux blocs. Rappelant que la valeur moyenne de cette valeur a été fixée au début du réseau et est d'environ 10 minutes, on peut estimer que la limite supérieure du coût de maintenance d'un domaine sera de 15,7744 NMC ou un peu plus de 11 $.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, même un scénario aussi fantastique d'utiliser un nom en Namecoin à un coût équivaut approximativement à la première année de possession d'un domaine régulier dans la zone .com la plus populaire. Si nous comparons un scénario plus réaliste avec une mise à jour en moyenne une fois par jour, le nom dans la zone .bit coûtera environ 8 cents par an, ce qui est beaucoup moins cher que les offres les plus avantageuses du DNS traditionnel, qui ne tombent pas en dessous de 1 $. Dans le scénario d'utilisation à court terme du domaine (de plusieurs heures à un mois), la différence en faveur de Namecoin sera déjà de deux ordres de grandeur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compte tenu de l'attractivité financière du service, ainsi que de l'anonymat du propriétaire du domaine, y compris de l'absence d'une «piste monétaire» traditionnelle pour le DNS ordinaire, il devient clair pourquoi Namecoin est devenu un réseau populaire pour les propriétaires de services avec un risque accru de déconnexion ou de blocage, en particulier les réseaux de zombies. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Botnets à Namecoin </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En effet, le fait que les opérateurs de botnet aient commencé à utiliser l'anonymat </font></font><code>Dot-Bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour protéger leurs serveurs C&amp;C n'est pas surprenant. Une autre chose est plus intéressante - combien de temps les botnets en .bit restent actifs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les domaines C&amp;C enregistrés dans des zones DNS «ordinaires» sont tôt ou tard retirés au propriétaire, ce qui oblige l'opérateur à payer pour enregistrer un nouveau nom et lancer un nouvel assemblage de bot sur le réseau, avec un nouveau serveur de gestion. L'impossibilité fondamentale de supprimer un domaine dans la zone .bit a augmenté la durée de vie du botnet de plusieurs ordres de grandeur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prenons par exemple le </font></font><code>pationare.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">domaine enregistré en décembre 2016. Il a été utilisé pour contrôler un botnet </font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(distribution d'un cheval de Troie bancaire construit sur la base du fameux ZeuS). Campagne de distribution</font></font><code>Chthronic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a été associé à l'utilisation du pack d'exploit RIG et a été décrit en détail par divers chercheurs (par exemple </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malware-traffic-analysis.net</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) fin 2016 et premier semestre 2017. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On pourrait supposer que ce botnet a été détruit depuis longtemps. Mais pas plus de deux ans après le lancement, le domaine C&amp;C du botnet et son réseau sont toujours actifs. Comme le montre la capture d'écran ci-dessous, la dernière mise à jour a été effectuée en décembre 2018.</font></font><br><br><img src="https://habrastorage.org/webt/9k/o9/5w/9ko95wbszt4g7fqntkxm0cnh34u.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ça a l'air tentant, non? Étant donné que le nom DNS du serveur de gestion reste intact, il n'est pas nécessaire de mettre à jour fréquemment le code bot et de redémarrer la campagne de distribution. Il ne reste que le coût de la modification de l'hébergement après avoir bloqué l'adresse IP, mais ces coûts peuvent également être réduits en utilisant des serveurs Web piratés comme proxy, dont les coques coûtent moins d'un dollar.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'un autre côté, toutes les transactions dans la blockchain sont accessibles au public pour tout participant. </font><font style="vertical-align: inherit;">Comme nous l'avons expliqué en détail dans les chapitres précédents, les pièces en Namecoin ne disparaissent pas sans laisser de trace, ce qui signifie que nous pouvons suivre leur redistribution entre les adresses. </font><font style="vertical-align: inherit;">Et connaissant les règles et les restrictions, en tenant compte des transactions qui sont formées dans Namecoin, nous pouvons trouver des modèles significatifs dans lesquels la gestion uniforme de certaines adresses impliquées dans la transaction sera évidente. </font><font style="vertical-align: inherit;">Dans ce cas, les domaines payés avec des pièces de ces adresses auront un propriétaire commun - le groupe que nous gérons, qui contrôle le botnet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous développerons cette idée plus loin.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Système général de collecte du CIO </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Décrivons le schéma de recherche général en utilisant l'exemple d'un vrai botnet du groupe RTM. Nous allons construire sur cet </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">échantillon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui a été identifié comme </font></font><code>Win32/Spy.RTM.N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/9r/rx/tq/9rrxtqepv4ods_wcbibv-2hk9uk.png"><br><br><img src="https://habrastorage.org/webt/ps/by/dk/psbydk2cmnsifuf5cf8njpmnnvm.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir sur la capture d'écran ci-dessus, après avoir démarré, il essaie d'obtenir l'adresse IP pour le nom </font></font><code>stat-counter-4.bit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous obtenons des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">informations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur l'historique des transactions pour ce nom en Namecoin. </font></font><br><br><img src="https://habrastorage.org/webt/ok/jj/aj/okjjajszmlcuj_8enwzkosbze6k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'identifiant de la transaction qui a créé ce domaine, nous l'obtenons en cliquant sur le lien vers l'opération NAME_NEW. L'adresse d'entrée de cette transaction, à l'aide de laquelle le domaine a été créé, est évidemment gérée par le groupe qui nous intéresse. Il sera la première série de données: </font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><img src="https://habrastorage.org/webt/-k/si/6n/-ksi6n9mz69t-tscu-cpyilewpa.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur la base de l'ensemble de données initial, nous contournons de manière itérative la blockchain, en nous déplaçant dans le sens de sa croissance (mouvement ascendant ou amont). Au début de chaque étape, nous obtenons une transaction dont une certaine pièce à l'entrée appartient à la personne qui nous intéresse. Dans un premier temps, nous vérifions la transaction à partir de l'ensemble de données initial, le propriétaire des pièces à l'entrée dont nous connaissons a priori.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La transaction est vérifiée pour la conformité aux règles heuristiques (nous les formulerons ci-dessous), qui garantissent qu'une certaine pièce (ou pièces) à la sortie de la transaction appartient à la même personne que la pièce d'entrée connue. Si la transaction en question satisfait une ou plusieurs heuristiques, alors ces pièces de guidage indiqueront la direction du mouvement ultérieur. La transaction qui dépense la pièce de guidage sera la prochaine étape de l'itération. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À chaque étape de l'itération, nous reconstituons la liste des domaines qui ont participé aux transactions et la liste des adresses IP auxquelles ces domaines ont été résolus. Ce sont des identificateurs historiques de compromis (IOC), qui peuvent être utilisés pour les criminalistes, ainsi que pour identifier les tactiques et les méthodes de regroupement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le mouvement s'arrête si la transaction en question ne satisfait à aucune des heuristiques. Cela signifie que nous ne pouvons pas dire avec certitude que l'un des résultats de la transaction en question est contrôlé par la personne qui nous intéresse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une autre situation qui arrête le mouvement est le manque de transactions à partir de l'adresse de sortie. Nous enregistrerons ces adresses dans une liste séparée de pièces non dépensées (UTXO). Ils représentent la plus grande valeur de toute l'étude. Étant donné que nous sommes convaincus que ces adresses sont gérées par la personne qui nous intéresse, toute transaction future utilisant ces adresses générera un nouveau CIO inconnu auparavant - le nom de domaine ou l'adresse IP - qui n'a pas encore été utilisé par le groupement. Mais avec une forte probabilité, ce sera bientôt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour contourner la blockchain, il est pratique de l'exporter vers la base de données. Pour cela, vous pouvez utiliser, par exemple, l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilitaire rusty-blockparser</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> modifié </font><font style="vertical-align: inherit;">, dans lequel nous avons amélioré la prise en charge de Namecoin en ajoutant la reconnaissance des opérations </font></font><code>NAME_*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les structures de données </font></font><code>Auxiliary Proof-of-Work</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et en élargissant le format d'exportation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pseudo-code Python pour le mouvement ascendant est présenté ci-dessous. Ci-après, il est supposé que les données de transaction de la blockchain sont stockées dans MongoDB.</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">upstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heuristic_result = upstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_outs: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_out <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_outs: known_addresses.add(guiding_out.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"in.id"</span></span>: guiding_out.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: upstream_movement(tx) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: utxo.add(guiding_out)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième partie du contournement de la blockchain est le mouvement contre la croissance de la blockchain (mouvement vers le bas ou mouvement en aval). En général, l'algorithme de mouvement vers le bas n'est pas différent de l'algorithme vers le haut. Un mouvement commence par une transaction de l'ensemble de données d'origine. A chaque étape, la transaction est vérifiée pour la conformité aux règles heuristiques (en général, différentes des règles de mouvement ascendant). La seule différence est que la pièce, dont l'appartenance est connue a priori, est à la sortie de la transaction, et l'heuristique garantit que la même personne a une ou plusieurs pièces à l'entrée.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un mouvement à la baisse s'arrête également si la transaction en cours ne satisfait à aucune des heuristiques. </font><font style="vertical-align: inherit;">Contrairement au mouvement vers le haut, nous ne pouvons pas rencontrer de pièces non dépensées parmi les guides, et cette option pour quitter la récursivité dans le mouvement vers le bas ne fonctionnera pas. </font><font style="vertical-align: inherit;">Mais, comme pour le mouvement ascendant, nous reconstituons à la fois la liste des noms et la liste des adresses IP. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le pseudo-code Python pour le mouvement vers le bas ressemblerait à ceci:</font></font><br><br><pre> <code class="python hljs">start = <span class="hljs-string"><span class="hljs-string">"37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16"</span></span> tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"id"</span></span>: start}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downstream_movement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> names <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> IPs <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> utxo <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> known_addresses heristic_result = downstream_heuristic_test(tx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> heuristic_result <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> heuristic_result.guiding_ins: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.has_name_op(): names.add(tx.name_op.name) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ip_address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.name_op.get_ip(): IPs.add(ip_address) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> guiding_in <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> heuristic_result.guiding_ins: known_addresses.add(guiding_in.address) tx = namecoin.transactions.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: guiding_in.id}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx: downstream_movement(tx)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Considérons maintenant les règles heuristiques que nous utiliserons lors du déplacement le long de la blockchain. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Règles heuristiques </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Changement commun </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Revoyons la transaction, dont une capture d'écran est donnée ci-dessus. Une adresse </font></font><code>N3KPt8py24EAsAiKquyFgoKGyTYeR5Tmry</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contenant de l'argent pour créer un nouveau nom </font><font style="vertical-align: inherit;">est envoyée à l'entrée de transaction </font><font style="vertical-align: inherit;">. Il y </font><font style="vertical-align: inherit;">aura deux adresses </font><font style="vertical-align: inherit;">pour les transactions </font></font><code>NAME_FIRSTUPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>NAME_UPDATE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'entrée - une pièce spéciale avec une zone de la transaction précédente par domaine et des fonds supplémentaires pour couvrir la commission. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Je noterai immédiatement que dans le cadre des transactions, nous parlerons à la fois des pièces et des adresses. Malgré le fait que dans certains travaux, ces concepts sont considérés comme presque équivalents, il est important pour nous d'indiquer clairement la différence entre ces termes, car au cours de l'étude, nous tirerons des conclusions sur les pièces et les adresses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dire «pièce», nous entendrons un solde positif formé comme la sortie d'une transaction. Cette pièce est identifiée par le numéro de transaction qui l'a générée et l'indice de sortie. Par exemple, une pièce à l'entrée de la transaction considérée ci-dessus a un identifiant </font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a:1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car elle a été formée en sortie (avec l'index 1) de la transaction </font></font><code>5778be8e1901e9931e9b41a128a0b7f963e6e1ae72e461df2cba26e6279d433a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une pièce spéciale, comme précédemment, nous appellerons une pièce d'une valeur nominale de b </font></font><code>0.01 NMC</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>locking script</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui contient l'opération avec un nom de domaine. Nous avons examiné en détail le mécanisme de formation de ces pièces dans la section Gestion de domaine. Une pièce ordinaire, nous l'appellerons une pièce de monnaie arbitraire, à laquelle l'opération avec le domaine n'est pas liée.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La principale propriété des pièces est leur immuabilité. Toute pièce ne peut être dépensée qu'une seule fois et uniquement dans son intégralité. Ainsi, tout est mentionné sur le réseau Namecoin au maximum deux fois: une fois à la création, et une deuxième fois aux dépenses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dire «adresse», nous entendrons un identifiant qui identifie de manière unique une paire de clés qui peut ouvrir un script de verrouillage dans un format </font></font><code>P2PKH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui ferme une pièce située à l'entrée ou à la sortie d'une transaction. Étant donné que seule la clé correspondant à l'adresse peut dépenser une pièce, l'analogie la plus proche du monde physique avec l'adresse est le portefeuille dans lequel les pièces sont stockées (et à partir desquelles elles sont dépensées).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Malgré le fait qu'à Namecoin, une adresse n'est souvent utilisée que deux fois, il n'est pas nécessaire de recevoir et de consommer une seule pièce. Les faits de la réutilisation des adresses nous aideront un peu à l'avenir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons parlé plus en détail des entrées, sorties et adresses dans le chapitre de Bitcoin 201. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ainsi, deux pièces sont formées à la sortie de la transaction. La </font></font><code>N2hgZoWaTKoJ7FPmLuytTow3XrCCfEj2ca</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">même pièce spéciale, pesant 0,01 NMC, à laquelle le domaine est lié, est allée à l' </font><font style="vertical-align: inherit;">adresse </font><font style="vertical-align: inherit;">. Une </font></font><code>NKMMLwyMw4nwGuke6vd3AuDBMP18FWRaF1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pièce ordinaire avec changement a été envoyée à la </font><font style="vertical-align: inherit;">deuxième adresse </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il s'agit du schéma de transaction le plus courant. Il y a encore des options quand il y a plus d'une pièce à l'entrée, mais leur propriété commune est que la pièce avec changement est toujours exactement la même.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez deviner qu'une telle transaction correspond à une simple mise à jour des informations de domaine. Le paiement de la mise à jour s'effectue à l'aide d'une (moins souvent plusieurs) pièces appartenant à une seule personne. En effet, comme une transaction n'a toujours qu'un seul auteur, elle doit gérer toutes les adresses d'entrée. Sans cela, il ne sera pas en mesure de créer un script de déverrouillage, qui est nécessaire pour utiliser les pièces de ce portefeuille. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eh bien, puisque tout le changement de cette opération est collecté dans une pièce, il est clair que cette pièce appartient à la même personne que les pièces à l'entrée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un schéma similaire pour Bitcoin est décrit dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce travail</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , où il est appelé </font></font><code>one-time change</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Il reflète la méthode par laquelle les applications Bitcoin natives effectuent les transactions - </font></font><code>bitcoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et</font></font><code>bitcoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Une fois (une fois), il est appelé en raison d'une autre caractéristique de ces applications. Par défaut, ils génèrent de nouvelles adresses pour les pièces en sortie de la transaction créée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namecoin, avec la base de code Bitcoin, a hérité de la majeure partie du code de ces applications, appelées </font></font><code>namecoind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>namecoin-qt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En ce qui concerne les pièces ordinaires, nous pouvons utiliser cette heuristique en toute sécurité sans aucun changement.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les statistiques de réutilisation des adresses pour le stockage des pièces spéciales montrent que cette règle est dans la plupart des cas également observée pour eux. La réutilisation de telles adresses est assez rare. Adresses utilisées plus d'une fois, environ 6% du total; plus de deux fois - environ 1%. Sur la base de l'objectif de Namecoin, il semble raisonnable de supposer que la plupart des transactions avec des pièces spéciales sur le réseau sont de simples opérations de création et de mise à jour, pendant lesquelles le propriétaire du domaine ne change pas. Par conséquent, nous pouvons affirmer qu'une telle opération correspond au retrait d'une pièce spéciale vers une nouvelle adresse, précédemment inutilisée. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Voyons maintenant un exemple de transaction avec une adresse réutilisée pour une pièce de sortie spéciale. Pour ce faire, effectuez une autre transaction du groupe RTM -</font></font><code>b3c7ce9ca3a689c6236b9d6df3c257c5fab6c3985187669ccf731ac42a127a11</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><img src="https://habrastorage.org/webt/em/d6/hx/emd6hxidz3xhgqny_f5e7ho5-04.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'adresse </font></font><code>NDpWDEx1mBkUYywqxDTAZZeGCfUV4GkVE8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à laquelle la pièce spéciale est allée était déjà utilisée dans les transactions précédentes. </font></font><br><br><img src="https://habrastorage.org/webt/ws/32/00/ws3200wv6hvjc1z63vt4p1hdivs.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme mentionné précédemment, les scripts par défaut dans les applications clientes natives pour Namecoin n'entraînent pas la réutilisation des adresses. Pour envoyer une pièce spéciale à une adresse existante, le propriétaire devra faire des efforts séparés et facultatifs, trouver et indiquer explicitement l'adresse de sortie au stade de la formation de la transaction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi cela pourrait-il être requis? La seule mention de la situation dans laquelle l'adresse de sortie est indiquée manuellement, je ne l'ai rencontrée que dans les </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instructions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de transfert du domaine à un autre propriétaire.</font></font><br><br><img src="https://habrastorage.org/webt/zv/8q/pe/zv8qpeblzvm4jogj-axkgmcgili.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La conjecture est confirmée en considérant le futur sort des adresses à la sortie de la transaction en question. Dans le diagramme ci-dessous, cette transaction est marquée par un jalon vert clair. On peut voir que la prochaine transaction </font></font><code>9e16f6be</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur le domaine stat-counter-4 a eu lieu en utilisant une adresse monétaire </font></font><code>NJ8xUePv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui n'a pas de connexion explicite avec l'adresse utilisée dans la transaction "parent". De toute évidence, le domaine a été transféré à la gestion d'une autre personne.</font></font><br><br><img src="https://habrastorage.org/webt/ue/ho/ea/uehoea2yau72ydjns-ujsixawkw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas général, il peut s'agir soit de la vente d'un domaine à un autre propriétaire qui n'est pas lié aux activités de la personne concernée, soit du transfert d'un domaine entre les comptes d'une personne. </font><font style="vertical-align: inherit;">La deuxième option est la simplicité et le faible coût d'enregistrement d'un nouveau domaine, ainsi que le manque d'intérêt visible des organisations et des propriétaires de marques pour l'enregistrement de domaines dans la zone .bit. </font><font style="vertical-align: inherit;">Nous n'avons pas pu trouver au moins une motivation peu justifiée pour l'achat d'un domaine, constatée dans une activité malveillante. </font><font style="vertical-align: inherit;">Par conséquent, nous pensons que malgré la possibilité de transférer le domaine à une autre personne, les transactions avec des adresses réutilisables pour le retrait d'une pièce spéciale représentent un réarrangement des actifs entre plusieurs comptes contrôlés par un groupe.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous formulons les arguments ci-dessus sous la forme d'une règle heuristique, que nous appellerons changement commun: </font></font><br><br><blockquote>         ,   ,       ,     . <br><br>          ,     ,    . <br><br>  ,    ,     . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le schéma d'utilisation de cette règle est illustré dans la figure. Flux gris - pièces ordinaires, vert - une pièce spéciale. Les guides seront toutes les pièces de la fin de la transaction en face de la pièce par laquelle nous sommes arrivés à cette transaction: toutes les sorties sont pour le mouvement vers le haut, et toutes les entrées sont pour le mouvement vers le bas. </font></font><br><br><img src="https://habrastorage.org/webt/1a/bh/fo/1abhfo8tmu_v8xwuw_uk7j0mla4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous notons plusieurs caractéristiques de cette heuristique. Premièrement, bidirectionnel: il fonctionne à la fois pour le mouvement vers le haut, lorsque nous connaissons le propriétaire de l'entrée, et pour le mouvement vers le bas, lorsque nous connaissons le propriétaire d'une des pièces à la sortie. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxièmement, la disponibilité facultative d'une pièce spéciale: malgré le fait qu'en son absence la transaction n'est pas liée à la mise à jour du domaine, le raisonnement logique donné ci-dessus concernant le propriétaire d'une pièce ordinaire reste valable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le pseudo-code pour tester une transaction pour la conformité avec la règle de changement commune ressemblerait à ceci: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_change</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = {<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: []} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(tx.outs.money) != <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} addr = tx.outs.money[<span class="hljs-number"><span class="hljs-number">0</span></span>].address first_tx = namecoin.tx.find_one({<span class="hljs-string"><span class="hljs-string">"out.id"</span></span>: addr}, sort=[(<span class="hljs-string"><span class="hljs-string">"block"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first_tx.id != tx.id: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>] = tx.outs.all result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>] = tx.ins.all <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dépenses communes </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'heuristique considérée ci-dessus a une autre propriété importante, en plus de la bidirectionnalité. Changement commun - heuristique "sans mémoire"; le résultat de la vérification est déterminé uniquement par les caractéristiques de la transaction en question et ne dépend pas des résultats d'autres heuristiques et des données accumulées. Une telle heuristique est indispensable dans les premières itérations d'un parcours, pour le remplissage initial d'un ensemble de données. En revanche, il est facile de remarquer les limites de son application. Par exemple, elle se concentrera sur une transaction contenant deux sorties de trésorerie ou plus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À titre d'exemple d'une telle transaction, considérez </font></font><code>db4ff4082f39d0a501508706e627f26aa92712d27b4f633ded59917d201cfae5</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Cette opération concerne les activités du groupe gérant le botnet Dimnie. </font></font><br><br><img src="https://habrastorage.org/webt/td/61/-c/td61-cbmmd7enx-0olfyjxrpcva.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous avons effectué cette transaction via l'adresse</font></font><code>My7Ap3nH5f4X6Us2KiUWisd77wRpMG1MDY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui a été utilisé dans la transaction CC précédente comme adresse de connexion. Malgré le fait que son attitude envers la personne étudiée ne fait aucun doute, nous ne pouvons pas en dire autant (ainsi que le contraire) à propos des autres sorties et entrées. Il peut s'agir d'une redistribution de pièces entre les adresses de groupe, auquel cas toutes les adresses sont contrôlées par la personne qui nous intéresse. Ou est-ce, peut-être, une recharge à partir des adresses de l'un des échanges vendant des jetons Namecoin. Ou un transfert d'un autre membre du réseau qui n'est pas lié aux activités de la personne étudiée. Il est impossible de tirer une conclusion définitive sur les seuls attributs de cette transaction. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Considérez l'adresse</font></font><code>N4XtLb7xpC4Zk72T8QcshKhTW17ZCyQ1j1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à l'entrée de cette transaction. </font><font style="vertical-align: inherit;">Cette adresse a déjà été utilisée précédemment («plus tôt» pour un mouvement à la baisse signifie «à l'avenir», «dans le sens de la croissance de la blockchain») à l'entrée d'une transaction CC </font></font><code>6bffc741eb66de074c09a380fb5e6bd13d4bd5205c36a76e3682674dba08461e</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui nous permet de considérer que cette adresse est gérée par la personne qui nous intéresse. </font><font style="vertical-align: inherit;">Et comme, comme cela a déjà été montré, les clés de toutes les pièces à l'entrée de la transaction sont contrôlées par une seule personne (ce qui ne peut pas être dit sur les sorties), nous avons des raisons de croire que toutes les autres entrées appartiennent également au groupe qui nous intéresse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La condition stricte des dépenses communes heuristiques semble très simple:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S'il est connu qu'au moins une des adresses à l'entrée de la transaction est contrôlée par une certaine personne, alors toutes les autres adresses aux entrées de cette transaction sont contrôlées par la même personne. </font><font style="vertical-align: inherit;">Les pièces à ces entrées appartiennent à la même personne.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme vous pouvez le voir, cette heuristique n'a de sens que pour le mouvement vers le bas. Lorsque nous nous dirigeons vers la croissance de la blockchain, nous arrivons à la transaction à l'étude via l'un des intrants. Dans ce cas, la condition de règle est satisfaite automatiquement, mais ne dit rien sur les sorties de la transaction et ne vous permet pas de continuer à vous déplacer vers l'amont. En d'autres termes, il s'agit d'une heuristique unidirectionnelle. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La deuxième caractéristique de cette heuristique, qui mérite d'être soulignée, est qu'ici, nous avons d'abord utilisé les données accumulées à la suite de la vérification des transactions précédentes - une liste d'adresses gérées par la personne faisant l'objet de l'enquête. Pour cette raison, cette heuristique secondaire ne peut pas être utilisée pour un mouvement indépendant, sans aucune heuristique primaire qui ne dépend pas des résultats accumulés (comme un changement commun).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Le pseudo-code pour tester la conformité d'une transaction avec la règle de dépenses communes ressemblerait à ceci: </font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">common_spending</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: tx.ins.all} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {}</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Adresse connue </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La dernière heuristique que nous considérerons dans le cadre de cette section est la plus simple de toutes. </font><font style="vertical-align: inherit;">Il s'agit d'une heuristique bidirectionnelle secondaire qui (puisqu'elle est bidirectionnelle) peut être utilisée à la fois pour un mouvement vers le haut et vers le bas. </font><font style="vertical-align: inherit;">La formulation stricte de l'adresse heuristique connue pour le mouvement ascendant ressemble à ceci:</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> S'il est connu que l'adresse à l'entrée (sortie) de la transaction est contrôlée par une certaine personne, alors les pièces reçues à cette adresse (dépensées à partir de cette adresse) appartiennent à la même personne. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien que l'heuristique ressemble à un truisme franc, cette règle permet de trouver des branches et des intersections dans les flux de pièces et ajoute la connectivité à l'arbre de transaction. De plus, il vous permet de ne pas arrêter le mouvement sur les transactions qui ne relèvent pas d'autres heuristiques. Un exemple est la transaction du </font></font><code>7a35b9cb0a16b3eba92781be014555eaa4255bd17655bb00f2b3f42c3950ac69</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">botnet Dimnie déjà mentionné. </font></font><br><br><img src="https://habrastorage.org/webt/06/eg/as/06egasevdvty7quvjjvr0jrp6gy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'ayant atteint dans un mouvement à la hausse, nous ne pourrons pas avancer avec l'aide d'un changement commun, car la sortie est plus d'une pièce ordinaire. En regardant une transaction, nous ne pouvons pas dire combien de pièces dans la sortie appartiennent à la même personne que la pièce dans l'entrée - les deux, une ou aucune. L'utilisation de l'heuristique d'adresse connue vous permet d'avancer du fait que l'adresse</font></font><code>MwMdTb8WQvoRW9jEW5dHn9SkkCJTRn31wQ</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a été impliqué dans la transaction CC </font></font><code>cf7ac8986f9855246c6cf26df9a24aa5645cb9258bf787e034a33e75101ae1fc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui a créé le domaine </font><font style="vertical-align: inherit;">rencontré plus tôt dans le mouvement en amont </font></font><code>d/sectools</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par souci d'exhaustivité, nous donnons le pseudocode de l'adresse heuristique connue:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">known_address</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx)</span></span></span><span class="hljs-function">:</span></span> result = { <span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>: [], <span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>: [] } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_outs(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> output.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_outs"</span></span>].append(output) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> input <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tx.get_ins(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input.address <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> known_addresses: result[<span class="hljs-string"><span class="hljs-string">"guiding_ins"</span></span>].append(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Donc, maintenant nous avons à la fois l'algorithme de contournement général et l'heuristique nécessaire pour se déplacer le long de la blockchain, afin que nous puissions les assembler pour obtenir un certain IOC de Namecoin. </font></font><br><br><h2>  C'est parti! </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous allons passer par les transactions RTM avec le mouvement à la hausse et à la baisse, en commençant par </font></font><code>37d40bc2f3ca7415908dc9e276593b50d3120158cd540cb088246f2e2cf88b16</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Au cours de l'avancée sur la blockchain, nous collecterons non seulement le CIO, mais aussi les transactions elles-mêmes qui satisfont l'heuristique. Les flux de pièces entre les transactions que nous visualisons à l'aide du graphique Sankey. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le diagramme complet est trop grand pour être affiché dans le format de ce document, donc je n'en donnerai ici qu'une partie qui est nécessaire pour la suite de l'histoire. </font></font><br><br><img src="https://habrastorage.org/webt/zj/jh/un/zjjhundsmnmtabrgw81hkty76nk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un flux de pièces ordinaires est surligné en gris. Les couleurs restantes correspondent aux flux de pièces spéciales. Une couleur distincte est sélectionnée pour chaque nom. Les jalons blancs correspondent aux transactions qui satisfont aux conditions heuristiques. Les jalons rouge vif sur la droite sont UTXO.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'élément de graphique sur lequel je voudrais attirer l'attention est mis en évidence par un jalon bleu. Il s'agit d'une entrée pendante - une pièce qui a surgi à l'entrée d'une transaction que l'algorithme a transmise sur le mouvement ascendant, mais la transaction qui a créé cette pièce ne l'a pas rencontré.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les entrées pendantes sont des signes que la structure à l'étude a des branches latérales qui ne sont pas connectées au tronc principal le long duquel l'algorithme se déplace. Dans le cas illustré, il s'agit d'un autre compte indépendant. Comme on peut le voir sur le diagramme, il commence à être utilisé pour payer les changements dans les domaines que nous connaissons déjà. De ce fait, nous pouvons conclure que ce compte est également contrôlé par la personne faisant l'objet de l'enquête. Pour obtenir le CIO associé aux opérations sur ce compte jusqu'à ce qu'il apparaisse sur le graphique, nous allons commencer un mouvement à la baisse distinct, en commençant dans une transaction avec une entrée pendante. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De même, dans un mouvement vers le bas, des sorties pendantes peuvent se produire. Pour chacun d'eux, nous lancerons un mouvement haussier distinct à partir de la transaction correspondante.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En plus des transactions du groupe qui contrôle le botnet RTM, nous avons également examiné les transactions des groupes qui contrôlent les botnets Shifu, Dimnie et GandCrab. En conséquence, 164 domaines enregistrés dans l'intérêt de ces groupes et 277 adresses IP associées à ces noms ont été trouvés. Au moment d'écrire ces lignes, sur les UTXO collectés appartenant à ces groupes, 39 pièces restaient en vigueur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les listes du CIO, ainsi que les adresses Namecoin sur lesquelles sont restées les pièces inutilisées des groupes, figurent à l'annexe A.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les tests en conditions réelles représentent un défi pour presque toutes les technologies. Au milieu des années 2000, Wikipédia était devenu une source d'information si populaire et fiable qu'en changeant le texte des articles, il était devenu possible de contrôler l'opinion publique, de se lancer, de gagner de l'argent. Cette période de l'histoire du service est célèbre pour ses énormes guerres de révision - l'utilisation agressive du mécanisme de correction des articles et l'annulation des modifications par plusieurs parties belligérantes afin de gagner le différend sur le contenu de l'article. Les pages de Wikipédia se sont transformées en une foire internationale de vanité, où tout le monde voulait littéralement dire le dernier mot.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D'une part, ils ont commencé à mener la guerre des amendements, en fixant des règles spéciales qui permettent, en cas de litige, d'exclure temporairement la possibilité de modifier l'article - jusqu'à ce que les débatteurs de la section "Discussion" trouvent un libellé de compromis. D'autre part, la guerre des révisions a contraint Wikipedia à lancer un mécanisme dynamique de gestion des ressources des administrateurs, ce qui leur a permis d'être rapidement impliqués dans la résolution des conflits dans les zones les plus chaudes. De plus, l'encyclopédie a profité de l'attention du public qui s'est attirée sur les articles individuels pour attirer davantage de participants à la rédaction de ces articles et obtenir la couverture la plus correcte et complète d'un sujet particulier.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namecoin, comme Wikipedia, peut-il grandir et faire face à son défi? </font><font style="vertical-align: inherit;">Attendez et voyez. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Des tableaux PS avec des indicateurs de compromis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sont disponibles sur GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Publié par</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alexey Goncharov, PT Expert Security Center</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460857/">https://habr.com/ru/post/fr460857/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460845/index.html">Fernando Corbato, le père de votre ordinateur (et mot de passe), est décédé à 93 ans</a></li>
<li><a href="../fr460847/index.html">12,3 millions de WebSockets simultanés</a></li>
<li><a href="../fr460849/index.html">Partie 4. Un modèle de graphe pour calculer les fonctions logiques pour les processus parallèles asynchrones</a></li>
<li><a href="../fr460851/index.html">SamsPcbGuide, Partie 10: Technologie - Soudage de composants sans plomb</a></li>
<li><a href="../fr460855/index.html">Comment utiliser PHP pour implémenter des microservices?</a></li>
<li><a href="../fr460859/index.html">Conférence IThink # 3 à Kharkov - basée sur la WWDC 2019</a></li>
<li><a href="../fr460861/index.html">Portée lexicale JavaScript et fermeture</a></li>
<li><a href="../fr460863/index.html">Détails du crash de Cloudflare 2 juillet 2019</a></li>
<li><a href="../fr460865/index.html">Les gens sur la lune. Les sources</a></li>
<li><a href="../fr460867/index.html">Sourcery pour convertir automatiquement en structures d'objets Realm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>