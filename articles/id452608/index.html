<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíà üßïüèæ üåÅ Bagian 1. QInst: lebih baik kehilangan satu hari, kemudian terbang dalam lima menit (alat tulis itu sepele) ü§πüèΩ üßõüèº üßõüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada bagian sebelumnya, saya secara kasar menjelaskan bagaimana Anda dapat memuat fungsi eBPF dari file ELF. Sekarang saatnya untuk beralih dari fanta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagian 1. QInst: lebih baik kehilangan satu hari, kemudian terbang dalam lima menit (alat tulis itu sepele)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452608/"><p>  Pada bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya,</a> saya secara kasar menjelaskan bagaimana Anda dapat memuat fungsi eBPF dari file ELF.  Sekarang saatnya untuk beralih dari fantasi ke kartun Soviet, dan mengikuti saran bijak, setelah menghabiskan sejumlah upaya sekali, membuat alat instrumentasi universal <del>  <em>(atau, singkatnya, UII !!!)</em> </del>  .  Dengan melakukan itu, saya akan mengambil keuntungan dari desain antipattern Golden Hammer dan membangun alat dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QEMU yang</a> relatif akrab.  Sebagai bonus untuk ini, kami mendapatkan instrumentasi lintas-arsitektur, serta instrumentasi di level seluruh komputer virtual.  Instrumentasi akan berupa "file asli kecil + file kecil .o dengan eBPF".  Dalam hal ini, fungsi eBPF akan diganti sebelum instruksi yang sesuai dari representasi internal QEMU sebelum optimasi dan pembuatan kode. </p><br><p>  Akibatnya, instrumentasi itu sendiri, yang <strong>ditambahkan selama pembuatan kode</strong> (yaitu, tidak menghitung beberapa kilobyte dari runtime sistem normal), terlihat seperti ini, dan ini <strong>bukan</strong> kode pseudo: </p><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Nah, saatnya untuk memuat peri kita ke dalam Matrix.  Nah, bagaimana cara mengunduh <del>  menampar </del>  semprotan. </p><a name="habracut"></a><br><p>  Seperti yang telah disebutkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel tentang QEMU.js</a> , salah satu mode operasi QEMU adalah pembuatan kode mesin host JIT dari tamu (berpotensi, untuk arsitektur yang sama sekali berbeda).  Jika terakhir kali saya mengimplementasikan backend pembuatan kode saya, maka kali ini saya akan memproses representasi internal dengan memotong tepat di depan pengoptimal.  Apakah ini keputusan yang sewenang-wenang?  Tidak.  Ada harapan bahwa pengoptimal akan memotong sudut berlebih, membuang variabel yang tidak perlu, dll.  Sejauh yang saya mengerti, dia, pada kenyataannya, melakukan hal-hal sederhana dan cepat dapat dilakukan: mendorong konstanta, membuang ekspresi seperti "x: = x + 0" dan menghapus kode yang tidak terjangkau.  Dan kita bisa mendapatkan jumlah yang layak. </p><br><h1 id="konfiguraciya-sborochnyh-skriptov">  Konfigurasi skrip perakitan </h1><br><p>  Pertama, mari kita tambahkan file sumber kami: <code>tcg/bpf-loader.c</code> dan <code>tcg/instrument.c</code> ke Makefiles.  Secara umum, ada keinginan untuk suatu hari nanti mendorong ini ke hulu, jadi Anda harus melakukannya pada akhirnya dengan bijak, tetapi untuk sekarang saya hanya akan tanpa syarat menambahkan file-file ini ke majelis.  Dan saya akan mengambil parameter dalam tradisi terbaik AFL - melalui variabel lingkungan.  Ngomong-ngomong, saya akan menguji ini lagi pada instrumentasi untuk AFL. </p><br><p>  Lihat saja penyebutan "tetangga" - file <code>grep -R</code> dengan <code>grep -R</code> dan kami tidak akan menemukan apa pun.  Karena itu perlu mencari <code>optimize.o</code> : </p><br><pre> <code class="diff hljs"><span class="hljs-comment"><span class="hljs-comment">--- a/Makefile.target +++ b/Makefile.target @@ -110,7 +110,7 @@ obj-y += trace/ obj-y += exec.o obj-y += accel/ obj-$(CONFIG_TCG) += tcg/tcg.o tcg/tcg-op.o tcg/tcg-op-vec.o tcg/tcg-op-gvec.o -obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o +obj-$(CONFIG_TCG) += tcg/tcg-common.o tcg/optimize.o tcg/instrument.o tcg/bpf-loader.o obj-$(CONFIG_TCG_INTERPRETER) += tcg/tci.o obj-$(CONFIG_TCG_INTERPRETER) += disas/tci.o obj-$(CONFIG_TCG) += fpu/softfloat.o</span></span></code> </pre> <br><h1 id="tak-vot-ty-kakoe-metaprogrammirovanie-na-c">  Jadi di sini Anda, metaprogramming di C ... </h1><br><p>  Pertama, mari kita tambahkan <code>bpf-loader.c</code> dari seri terakhir dengan kode yang menarik keluar titik masuk yang sesuai dengan operasi QEMU.  Dan file <code>tcg-opc.h</code> misterius akan membantu kita dengan ini.  Ini terlihat seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * DEF(name, oargs, iargs, cargs, flags) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* predefined ops */</span></span> DEF(discard, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, TCG_OPF_NOT_PRESENT) DEF(set_label, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END | TCG_OPF_NOT_PRESENT) <span class="hljs-comment"><span class="hljs-comment">/* variable number of parameters */</span></span> DEF(call, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, TCG_OPF_CALL_CLOBBER | TCG_OPF_NOT_PRESENT) DEF(br, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, TCG_OPF_BB_END) <span class="hljs-comment"><span class="hljs-comment">// ...</span></span></code> </pre> <br><p>  Omong kosong apa  Dan masalahnya adalah bahwa itu tidak terhubung di header sumber - Anda perlu mendefinisikan makro <code>DEF</code> , termasuk file ini, dan segera menghapus makro.  Lihat, dia bahkan tidak punya penjaga. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inst_function_names[] = { #define DEF(name, a, b, c, d) stringify(inst_qemu_##name), #include <span class="hljs-string"><span class="hljs-string">"tcg-opc.h"</span></span> #undef DEF <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> };</code> </pre> <br><p>  Sebagai hasilnya, kita mendapatkan array rapi dari nama fungsi target, diindeks oleh opcodes dan diakhiri dengan NULL, yang dapat kita jalankan untuk setiap karakter dalam file.  Saya mengerti bahwa ini tidak efektif.  Tapi itu sederhana, yang penting, mengingat sifat operasi ini satu kali.  Selanjutnya, kita lewati saja semua karakternya </p><br><pre> <code class="cpp hljs">ELF64_ST_BIND(sym-&gt;st_info) == STB_LOCAL || ELF64_ST_TYPE(sym-&gt;st_info) != STT_FUNC</code> </pre> <br><p>  Sisanya diperiksa berdasarkan daftar. </p><br><h1 id="privyazyvaemsya-k-potoku-vypolneniya">  Kami melekat pada aliran eksekusi </h1><br><p>  Sekarang Anda harus bangun di suatu tempat pada aliran mekanisme pembuatan kode, dan tunggu sampai instruksi yang diinginkan lewat.  Tetapi pertama-tama Anda perlu mendefinisikan fungsi <code>instrumentation_init</code> , <code>tcg_instrument</code> dan <code>instrumentation_shutdown</code> dalam file <code>tcg/tcg.h</code> dan menuliskan panggilan mereka: inisialisasi - setelah backend diinisialisasi, instrumentasi - tepat sebelum panggilan <code>tcg_optimize</code> .  Tampaknya <code>instrumentation_shutdown</code> dapat digantung di <code>instrumentation_init</code> di <code>atexit</code> dan tidak melonjak.  Saya pikir juga begitu, dan kemungkinan besar itu akan bekerja dalam mode emulasi sistem penuh, tetapi dalam mode emulasi usermode QEMU menerjemahkan panggilan sistem <code>exit_group</code> dan kadang-kadang <code>exit</code> ke panggilan fungsi <code>_exit</code> , yang mengabaikan semua penangan-atexit ini, oleh karena itu, kita akan mencarinya di <code>linux-user/syscall.c</code> dan <code>linux-user/syscall.c</code> panggilan ke kode kita di depannya. </p><br><h1 id="interpretiruem-baytkod">  Menafsirkan Bytecode </h1><br><p>  Jadi sudah waktunya untuk membaca apa yang dihasilkan kompiler untuk kita.  Ini mudah dilakukan menggunakan <code>llvm-objdump</code> dengan opsi <code>-x</code> , atau lebih baik, segera <code>-d -t -r</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Contoh keluaran</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./compile-bpf.sh test-bpf.o: file format ELF64-BPF Disassembly of section .text: 0000000000000000 inst_brcond_i64: 0: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000000: R_BPF_64_64 prev 2: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 3: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 4: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 5: af 13 00 00 00 00 00 00 r3 ^= r1 6: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 7: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 0000000000000038: R_BPF_64_64 __afl_area_ptr 9: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 10: 0f 34 00 00 00 00 00 00 r4 += r3 11: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 12: 07 03 00 00 01 00 00 00 r3 += 1 13: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 14: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 15: 95 00 00 00 00 00 00 00 exit 0000000000000080 inst_brcond_i32: 16: 18 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r2 = 0 ll 0000000000000080: R_BPF_64_64 prev 18: 79 23 00 00 00 00 00 00 r3 = *(u64 *)(r2 + 0) 19: 77 03 00 00 01 00 00 00 r3 &gt;&gt;= 1 20: 7b 32 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r3 21: af 13 00 00 00 00 00 00 r3 ^= r1 22: 57 03 00 00 ff ff 00 00 r3 &amp;= 65535 23: 18 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r4 = 0 ll 00000000000000b8: R_BPF_64_64 __afl_area_ptr 25: 79 44 00 00 00 00 00 00 r4 = *(u64 *)(r4 + 0) 26: 0f 34 00 00 00 00 00 00 r4 += r3 27: 71 43 00 00 00 00 00 00 r3 = *(u8 *)(r4 + 0) 28: 07 03 00 00 01 00 00 00 r3 += 1 29: 73 34 00 00 00 00 00 00 *(u8 *)(r4 + 0) = r3 30: 7b 12 00 00 00 00 00 00 *(u64 *)(r2 + 0) = r1 31: 95 00 00 00 00 00 00 00 exit SYMBOL TABLE: 0000000000000000 l df *ABS* 00000000 test-bpf.c 0000000000000000 ld .text 00000000 .text 0000000000000000 *UND* 00000000 __afl_area_ptr 0000000000000080 g F .text 00000080 inst_brcond_i32 0000000000000000 g F .text 00000080 inst_brcond_i64 0000000000000008 g O *COM* 00000008 prev</code> </pre> </div></div><br><p>  Jika Anda mencoba mencari deskripsi opcode eBPF, ternyata di tempat-tempat yang jelas (sumber dan halaman manual dari kernel Linux) ada deskripsi tentang bagaimana menggunakannya, cara mengkompilasi, dll.  Kemudian Anda menemukan <a href="">halaman</a> tim alat iovisor dengan referensi eBPF tidak resmi yang nyaman. </p><br><p>  Instruksi menempati satu kata 64-bit (sekitar dua) dan memiliki bentuk </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> opcode; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> dst:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> src:<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> offset; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> imm; };</code> </pre> <br><p>  Mereka yang menempati dua kata hanya terdiri dari instruksi pertama dengan semua logika dan "trailer" dengan 32 bit lebih dari nilai langsung dan sangat jelas terlihat pada pembongkaran objek. </p><br><p>  Opcode sendiri juga memiliki struktur reguler: tiga bit yang lebih rendah adalah kelas operasi: ALU 32-bit, 64-bit ALU, memuat / menyimpan, percabangan bersyarat.  Oleh karena itu, sangat mudah untuk menerapkannya pada makro dalam tradisi terbaik QEMU.  Saya tidak akan melakukan instruksi terperinci pada basis kode <del>  kita tidak sedang meninjau kode </del>  Saya lebih baik memberi tahu Anda tentang jebakan. </p><br><p>  Masalah pertama saya adalah saya membuat pengalokasi register eBPF yang malas dalam bentuk QEMU- <code>local_temp</code> , dan mulai tanpa berpikir mentransfer panggilan fungsi ini ke makro.  Ternyata seperti dalam meme terkenal: "Kami memasukkan abstraksi ke abstraksi sehingga Anda dapat menghasilkan instruksi saat Anda menghasilkan instruksi."  Pasca factum, saya sudah tidak mengerti dengan baik apa yang rusak saat itu, tetapi sesuatu yang aneh tampaknya terjadi dengan urutan instruksi yang dihasilkan.  Setelah itu, saya membuat analog dari fungsi <code>tcg_gen_...</code> untuk mendorong instruksi baru ke tengah daftar, mengambil operan sebagai argumen ke fungsi, dan urutan secara otomatis menjadi sebagaimana mestinya (karena argumen sepenuhnya dihitung tepat sekali sebelum panggilan). </p><br><p>  Masalah kedua adalah mencoba untuk mendorong konstanta TCG sebagai operan dari instruksi sewenang-wenang ketika melihat operan langsung di eBPF.  Meminta tcg-opc.h yang telah disebutkan, komposisi daftar argumen operasi benar-benar diperbaiki: <code>n</code> argumen input, <code>m</code> output dan <code>k</code> konstan.  Ngomong-ngomong, ketika debugging kode seperti itu, akan membantu untuk memberikan QEMU argumen baris perintah <code>-d op,op_opt</code> atau bahkan <code>-d op,op_opt,out_asm</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Kemungkinan Argumen</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ ./x86_64-linux-user/qemu-x86_64 -d help Log items (comma separated): out_asm show generated host assembly code for each compiled TB in_asm show target assembly code for each compiled TB op show micro ops for each compiled TB op_opt show micro ops after optimization op_ind show micro ops before indirect lowering int show interrupts/exceptions in short format exec show trace before each executed TB (lots of logs) cpu show CPU registers before entering a TB (lots of logs) fpu include FPU registers in the 'cpu' logging mmu log MMU-related activities pcall x86 only: show protected mode far calls/returns/exceptions cpu_reset show CPU state before CPU resets unimp log unimplemented functionality guest_errors log when the guest OS does something invalid (eg accessing a non-existent register) page dump pages at beginning of user mode emulation nochain do not chain compiled TBs so that "exec" and "cpu" show complete traces trace:PATTERN enable trace events Use "-d trace:help" to get a list of trace events.</code> </pre> </div></div><br><p>  Nah, jangan ulangi kesalahan saya: instruksi internal disassembler cukup maju, dan jika Anda melihat sesuatu seperti <code>add_i64 loc15,loc15,$554412123213</code> , maka hal ini setelah tanda dolar bukan pointer.  Lebih tepatnya, ini, tentu saja, adalah sebuah pointer, tetapi mungkin digantung dengan bendera dan dalam peran nilai literal operan, dan bukan pointer.  Semua ini berlaku, tentu saja, jika Anda tahu bahwa harus ada angka tertentu, seperti <code>$0</code> atau <code>$ff</code> , Anda tidak perlu takut sama sekali pada petunjuk.  :) Cara <code>movi</code> - Anda hanya perlu membuat fungsi yang mengembalikan <code>temp</code> baru, ke mana melalui <code>movi</code> menempatkan konstan yang diinginkan. </p><br><p>  Omong-omong, jika Anda berkomentar <code>#define USE_TCG_OPTIMIZATIONS</code> di <code>tcg/tcg.c</code> <code>#define USE_TCG_OPTIMIZATIONS</code> , maka, tiba-tiba, pengoptimalan akan mati dan akan lebih mudah untuk menganalisis transformasi kode. </p><br><p>  Untuk sim, saya akan mengirim pembaca yang tertarik memilih QEMU ke dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi</a> , bahkan yang resmi!  Selebihnya, saya akan mendemonstrasikan instrumentasi yang dijanjikan untuk AFL. </p><br><h1 id="te-zhe-i-krolik">  Sama dan kelinci </h1><br><p>  Untuk teks lengkap runtime, saya, sekali lagi, akan mengirim pembaca ke repositori, karena itu (teks) tidak memiliki nilai artistik dan secara jujur ‚Äã‚Äãdikeraskan dari <code>qemu_mode</code> dari pengiriman AFL, dan secara umum, adalah bagian reguler dari kode C. Tapi di sini adalah bagaimana instrumentasi itu sendiri terlihat : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdint.h&gt; extern uint8_t *__afl_area_ptr; extern uint64_t prev; void inst_qemu_brcond_i64(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; } void inst_qemu_brcond_i32(uint64_t tag, uint64_t x, uint64_t y, uint64_t z, uint64_t u) { __afl_area_ptr[((prev &gt;&gt; 1) ^ tag) &amp; 0xFFFF] += 1; prev = tag; }</span></span></span></span></code> </pre> <br><p>  Penting bahwa fungsi kait memiliki argumen sebanyak <code>iargs</code> untuk operasi QEMU yang sesuai.  Dua <code>extern</code> di header akan ditautkan ke runtime selama proses relokasi.  Pada prinsipnya, <code>prev</code> dapat didefinisikan di sini, tetapi kemudian harus didefinisikan sebagai <code>static</code> , jika tidak akan jatuh ke bagian UMUM yang tidak saya dukung.  Sebenarnya, kami, sebenarnya, hanya menulis ulang kode semu dari dokumentasi, tetapi ini bisa dibaca oleh mesin! </p><br><p>  Untuk memeriksa, buat file <code>bug.c</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; int main(int argc, char *argv[]) { char buf[16]; int res = read(0, buf, 4); if (buf[0] == 'T' &amp;&amp; buf[1] == 'E' &amp;&amp; buf[2] == 'S' &amp;&amp; buf[3] == 'T') abort(); return res * 0; }</span></span></span></span></code> </pre> <br><p>  Dan juga - file <code>forksrv</code> , yang nyaman untuk memberi makan AFL: </p><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash export NATIVE_INST=./instrumentation-examples/afl/afl-native.so export BPF_INST=./instrumentation-examples/afl/afl-bpf.co exec ./x86_64-linux-user/qemu-x86_64 ./instrumentation-examples/afl/bug</span></span></code> </pre> <br><p>  Dan jalankan fuzzing: </p><br><pre> <code class="bash hljs">AFL_SKIP_BIN_CHECK=1 afl-fuzz -i ../input -o ../output -m none -- ./forksrv</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">American Fuzzy Lop</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1234 T234 TE34 TES4 TEST &lt;-     crashes,    2200  </code> </pre> </div></div><br><p>  Sejauh ini, kecepatan tidak begitu panas, tetapi sebagai alasan saya akan mengatakan bahwa di sini (untuk saat ini) fitur penting dari <code>qemu_mode</code> asli tidak digunakan: mengirim alamat kode yang dapat dieksekusi ke server fork.  Tapi tidak ada AFL dalam basis kode QEMU sekarang, dan ada harapan bahwa instrumentasi umum ini suatu hari nanti akan dijejalkan ke hulu. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Proyek GitHub</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id452608/">https://habr.com/ru/post/id452608/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id452592/index.html">Bagian 0. Membutuhkan peri untuk bekerja di Matrix. Relokasi dimungkinkan</a></li>
<li><a href="../id452596/index.html">735.000 alamat IPv4 diambil dari scammer dan dikembalikan ke registri</a></li>
<li><a href="../id452598/index.html">Manajemen tim pemrogram: bagaimana dan bagaimana memotivasi mereka dengan benar? Bagian satu</a></li>
<li><a href="../id452602/index.html">Cisco Hyperflex untuk Sistem Manajemen Basis Data Beban Tinggi</a></li>
<li><a href="../id452606/index.html">UDB. Apa ini Bagian 8. Mengatasi UDB</a></li>
<li><a href="../id452610/index.html">Bantu dan minta dia. Artikel tentang keamanan informasi untuk pengguna biasa</a></li>
<li><a href="../id452612/index.html">Mempelajari pembelajaran mesin jaringan saraf dalam tensorflow.js: Trik</a></li>
<li><a href="../id452614/index.html">Cara memulai pemrograman di Adobe Illustrator. Bagian dua</a></li>
<li><a href="../id452618/index.html">Apa yang dikatakan di Google I / O 2019: Android 10, AR-aplikasi dan banyak lagi</a></li>
<li><a href="../id452620/index.html">Turunkan jenis Tindakan menggunakan Scriptot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>