<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛎ 🏇🏽 👨🏿‍🏭 Pengukuran Waktu dengan Akurasi Nanosecond 🕷️ 💪 💔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa bulan yang lalu suatu momen bersejarah datang untuk saya. Alat sistem operasi standar untuk mengukur waktu sudah tidak cukup bagi saya. Butuh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengukuran Waktu dengan Akurasi Nanosecond</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425237/"><img src="https://habrastorage.org/webt/zx/xf/se/zxxfse_sd5ma4wwfy0u6rilcai8.jpeg" alt="gambar"><br><br>  Beberapa bulan yang lalu suatu momen bersejarah datang untuk saya.  Alat sistem operasi standar untuk mengukur waktu sudah tidak cukup bagi saya.  Butuh waktu untuk mengukur dengan akurasi nanosecond dan dengan overhead nanosecond. <br><br>  Saya memutuskan untuk menulis perpustakaan yang akan menyelesaikan masalah ini.  Sekilas, sepertinya tidak ada yang istimewa untuk dilakukan.  Tetapi setelah diperiksa lebih dekat, seperti biasa, ternyata ada banyak masalah menarik yang harus ditangani.  Pada artikel ini, saya akan berbicara tentang masalah dan bagaimana mereka menyelesaikannya. <br><br>  Karena Anda dapat mengukur berbagai jenis waktu di komputer, saya akan segera mengklarifikasi bahwa di sini kita akan berbicara tentang "waktu oleh stopwatch".  Atau waktu jam dinding.  Ini waktu nyata, waktu berlalu, dll.  Yaitu, waktu "manusia" yang sederhana, yang kami deteksi pada awal tugas dan berhenti pada akhirnya. <br><a name="habracut"></a><br><h3>  Microsecond - hampir selamanya </h3><br>  Pengembang sistem berkinerja tinggi selama beberapa tahun terakhir telah terbiasa dengan skala waktu mikrodetik.  Dalam mikrodetik, Anda dapat membaca data dari drive NVMe.  Dalam mikrodetik, data dapat dikirim melalui jaringan.  Bukan untuk semua orang, tentu saja, tetapi untuk jaringan InifiniBand - dengan mudah. <br><br>  Pada saat yang sama, mikrodetik juga memiliki struktur.  Tumpukan I / O lengkap terdiri dari beberapa komponen perangkat lunak dan perangkat keras.  Keterlambatan yang diperkenalkan oleh beberapa dari mereka berada pada tingkat sub-mikrodetik. <br><br>  Untuk mengukur keterlambatan sebesar ini, akurasi mikrodetik tidak lagi memadai.  Namun, tidak hanya keakuratan itu penting, tetapi juga overhead untuk mengukur waktu.  Panggilan sistem Linux clock_gettime () mengembalikan waktu dengan ketepatan nanosecond.  Pada mesin yang tepat di ujung jari saya (Intel® Xeon® CPU E5-2630 v2 @ 2.60GHz), panggilan ini selesai sekitar 120 ns.  Sosok yang sangat bagus.  Selain itu, clock_gettime () berfungsi dengan sangat mudah ditebak.  Ini memungkinkan Anda untuk memperhitungkan overhead panggilannya dan benar-benar melakukan pengukuran dengan akurasi urutan puluhan nanodetik.  Namun, mari kita perhatikan hal ini.  Untuk mengukur interval waktu, Anda perlu membuat dua panggilan seperti itu: di awal dan di akhir.  Yaitu  menghabiskan 240 ns.  Jika interval waktu yang padat dari urutan 1-10 μs diukur, maka dalam beberapa kasus seperti itu proses pengukuran itu sendiri akan secara signifikan mengubah proses yang diamati. <br><br>  Saya memulai bagian ini dengan cara mempercepat tumpukan IO dalam beberapa tahun terakhir.  Ini baru, tetapi jauh dari satu-satunya alasan ingin mengukur waktu dengan cepat dan akurat.  Kebutuhan seperti itu selalu ada.  Sebagai contoh, selalu ada kode yang saya ingin percepat oleh setidaknya 1 jam siklus mikroprosesor.  Atau contoh lain, dari artikel asli tentang kerentanan Spectre sensasional: <br><br><img src="https://habrastorage.org/webt/db/5a/7o/db5a7oldvzrcqfi_ymamg4qzscu.jpeg" alt="gambar"><br><br>  Di sini, baris 72-74 mengukur waktu pelaksanaan operasi akses memori tunggal.  Benar, Spectre tidak tertarik pada nanodetik.  Waktu dapat diukur dalam "burung beo."  Kami akan kembali ke kakatua dan detik. <br><br><h3>  Penghitung waktu </h3><br>  Kunci pengukuran waktu yang cepat dan akurat adalah penghitung mikroprosesor khusus.  Nilai penghitung ini biasanya disimpan dalam register terpisah dan biasanya - tetapi tidak selalu - dapat diakses dari ruang pengguna.  Pada arsitektur yang berbeda, penghitung disebut berbeda: <br><br><ol><li>  penghitung cap waktu x86 </li><li>  register basis waktu di PowerPC </li><li>  penghitung waktu interval pada Itanium </li><li>  dll. </li></ol><br>  Di bawah ini saya akan selalu menggunakan nama "penghitung cap waktu" atau TSC, meskipun pada kenyataannya saya akan mengingat penghitung seperti itu, terlepas dari arsitekturnya. <br><br>  Membaca nilai TSC biasanya - tetapi sekali lagi tidak selalu - dimungkinkan dengan satu instruksi.  Berikut adalah contoh untuk x86.  Sebenarnya, ini bukan instruksi assembler murni, tetapi assembler inline GNU: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> eax, edx; __asm__ __volatile__( <span class="hljs-string"><span class="hljs-string">"rdtsc"</span></span> : <span class="hljs-string"><span class="hljs-string">"=a"</span></span> (eax), <span class="hljs-string"><span class="hljs-string">"=d"</span></span> (edx));</code> </pre> <br>  Instruksi rdtsc menempatkan dua bagian 32-bit dari register TSC di register eax dan edx.  Dari jumlah tersebut, Anda dapat "merekatkan" nilai 64-bit tunggal. <br><br>  Sekali lagi saya perhatikan: instruksi ini (dan sejenisnya) dalam banyak kasus dapat dipanggil langsung dari ruang pengguna.  Tidak ada panggilan sistem.  Overhead minimum. <br><br>  Apa yang sekarang perlu dilakukan untuk mengukur waktu? <br><br><ol><li>  Jalankan satu instruksi seperti itu di awal interval waktu yang menarik bagi kami.  Ingat nilai konter </li><li>  Jalankan satu instruksi seperti itu di akhir.  Kami percaya bahwa nilai penghitung dari instruksi pertama ke yang kedua akan meningkat.  Kalau tidak, mengapa itu dibutuhkan?  Ingat nilai kedua </li><li>  Kami mempertimbangkan perbedaan antara dua nilai yang disimpan.  Ini adalah waktu kita </li></ol><br>  Ini terlihat sederhana, tetapi ... <br><br>  Waktu yang diukur dengan prosedur yang dijelaskan dinyatakan dalam "kakatua".  Itu tidak dalam hitungan detik.  Tetapi terkadang burung beo adalah yang Anda butuhkan.  Ada situasi di mana bukan nilai absolut dari interval waktu yang penting, tetapi bagaimana interval berbeda berhubungan satu sama lain.  Contoh Spectre di atas menunjukkan dengan tepat situasi ini.  Durasi setiap akses memori individu tidak masalah.  Hanya penting bahwa panggilan ke beberapa alamat akan dieksekusi lebih cepat daripada yang lain (tergantung pada apakah data disimpan dalam cache atau memori utama). <br><br>  Tetapi bagaimana jika bukan beo yang dibutuhkan, tetapi detik / mikrodetik / nanodetik, dll.?  Dua kasus yang berbeda secara mendasar dapat dibedakan di sini: <br><br><ol><li>  Nanodetik diperlukan, tetapi kemudian.  Artinya, pertama-tama diperbolehkan melakukan semua pengukuran yang diperlukan pada burung beo dan menyimpannya di tempat lain untuk diproses lebih lanjut (misalnya, dalam memori).  Dan hanya setelah pengukuran selesai, perlahan-lahan mengkonversi burung nuri yang dikumpulkan menjadi detik </li><li>  Nanodetik diperlukan "dengan cepat."  Misalnya, proses pengukuran Anda memiliki semacam "konsumen" yang tidak Anda kendalikan dan yang mengharapkan waktu dalam format "manusia" </li></ol><br>  Kasus pertama sederhana, yang kedua - membutuhkan akal.  Konversi harus seefektif mungkin.  Jika itu menghabiskan banyak sumber daya, itu dapat sangat merusak proses pengukuran.  Kami akan berbicara tentang konversi yang efektif di bawah ini.  Di sini kita sejauh ini mengidentifikasi masalah ini dan beralih ke masalah lain. <br><br>  Penghitung waktu tidak semudah yang kita inginkan.  Pada beberapa arsitektur: <br><br><ol><li>  tidak dijamin bahwa TSC diperbarui pada frekuensi tinggi.  Jika TSC diperbarui, katakanlah, sekali setiap mikrodetik, maka itu tidak mungkin untuk memperbaiki nanodetik dengan itu. </li><li>  frekuensi TSC diperbarui dapat bervariasi dari waktu ke waktu </li><li>  pada berbagai CPU yang ada dalam sistem, TSC dapat diperbarui pada frekuensi yang berbeda </li><li>  mungkin ada pergeseran antara TSC yang berdetak pada CPU yang berbeda </li></ol><br>  Berikut adalah contoh yang menggambarkan masalah terakhir.  Misalkan kita memiliki sistem dengan dua CPU: CPU1 dan CPU2.  Misalkan TSC pada CPU pertama berada di belakang yang kedua dengan jumlah ticks, yang setara dengan 5 detik.  Misalkan lebih lanjut bahwa aliran diluncurkan dalam sistem yang mengukur waktu perhitungan, yang ia lakukan sendiri.  Untuk melakukan ini, aliran pertama membaca nilai TSC, kemudian melakukan perhitungan, dan kemudian membaca nilai TSC kedua.  Jika sepanjang hidupnya satu utas tetap hanya pada satu CPU - pada apa saja - maka tidak ada masalah.  Tetapi bagaimana jika utas dimulai pada CPU1, mengukur nilai TSC pertama di sana, dan kemudian di tengah perhitungan dipindahkan oleh sistem operasi ke CPU2, di mana ia membaca nilai TSC kedua?  Dalam hal ini, perhitungan akan tampak 5 detik lebih lama dari yang sebenarnya. <br><br>  Karena masalah yang tercantum di atas, TSC tidak dapat berfungsi sebagai sumber waktu yang andal pada beberapa sistem.  Namun, pada sistem lain "menderita" dari masalah yang sama, TSC masih dapat digunakan.  Ini dimungkinkan berkat fitur arsitektur khusus: <br><br><ol><li>  peralatan dapat menghasilkan interupsi khusus setiap kali frekuensi perubahan TSC diperbarui.  Pada saat yang sama, peralatan juga memberikan kesempatan untuk mengetahui frekuensi saat ini.  Sebagai alternatif, kecepatan refresh TSC dapat ditempatkan di bawah kendali sistem operasi (lihat “Power ISA Versi 2.06 Revisi B, Buku II, Bab 5”) </li><li>  bersama dengan nilai TSC, peralatan juga dapat memberikan ID CPU tempat nilai ini dibaca (lihat instruksi Intel RDTSCP, "Manual Pengembang Perangkat Lunak Arsitektur Intel 64 dan IA-32", Volume 2) </li><li>  pada beberapa sistem, Anda dapat secara programatik menyesuaikan nilai TSC untuk setiap CPU (lihat instruksi Intel WRMSR dan daftarkan IA32_TIME_STAMP_COUNTER, “Manual Pengembang Perangkat Lunak Arsitektur Perangkat Arsitektur Intel 64 dan IA-32”, Volume 3) </li></ol><br>  Secara umum, tema tentang bagaimana meter waktu diimplementasikan pada arsitektur yang berbeda sangat menarik dan luas.  Jika Anda punya waktu dan minat, saya sarankan menyelam.  Antara lain, Anda akan belajar, misalnya, bahwa beberapa sistem memungkinkan Anda untuk menentukan apakah TSC dapat berfungsi sebagai sumber waktu yang andal. <br><br>  Jadi, ada banyak implementasi arsitektur TSC, masing-masing dengan karakteristiknya sendiri.  Tetapi menarik bahwa tren umum telah ditetapkan di semua kebun binatang ini.  <b>Perangkat keras dan sistem operasi modern berusaha untuk memastikan bahwa</b> : <br><br><ol><li>  TSC berdetak pada frekuensi yang sama pada setiap CPU dalam sistem </li><li>  frekuensi ini tidak berubah dalam waktu </li><li>  tidak ada pergeseran antara TSC yang berdetak pada CPU yang berbeda </li></ol><br>  Ketika mendesain perpustakaan saya, saya memutuskan untuk melanjutkan dari premis ini, dan bukan dari tampilan implementasi perangkat keras. <br><br><h3>  Perpustakaan </h3><br>  Saya tidak mulai meletakkan pada chip perangkat keras dari sekelompok arsitektur yang berbeda.  Sebaliknya, saya memutuskan bahwa perpustakaan saya akan berorientasi pada tren.  Dia memiliki fokus empiris murni: <br><br><ol><li>  itu memungkinkan Anda untuk secara eksperimental memverifikasi keandalan TSC sebagai sumber waktu </li><li>  juga memungkinkan Anda untuk secara eksperimental menghitung parameter yang diperlukan untuk dengan cepat mengkonversi kutu ke nanodetik </li><li>  secara alami, perpustakaan menyediakan antarmuka yang nyaman untuk membaca TSC dan mengubah kutu menjadi nanodetik "on the fly" </li></ol><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode perpustakaan tersedia di sini.</a>  Ini akan dikompilasi dan dieksekusi hanya di Linux. <br><br>  Dalam kode tersebut, Anda dapat melihat detail implementasi semua metode, yang akan dibahas nanti. <br><br><h3>  Penilaian Keandalan TSC </h3><br>  Perpustakaan menyediakan antarmuka yang mengembalikan dua peringkat: <br><br><ol><li>  pergeseran maksimum antara penghitung milik CPU yang berbeda.  Hanya CPU yang tersedia untuk proses yang dipertimbangkan.  Misalnya, jika suatu proses memiliki tiga CPU yang tersedia, dan pada saat yang sama TSC pada CPU ini adalah 50, 150, 20, maka pergeseran maksimum akan menjadi 150-20 = 130.  Secara alami, perpustakaan tidak akan dapat memperoleh pergeseran maksimum yang nyata secara eksperimental, tetapi akan memberikan perkiraan yang sesuai dengan pergeseran ini.  Apa yang harus dilakukan selanjutnya dengan penilaian?  Bagaimana cara menggunakan  Ini sudah memecahkan kode klien.  Tetapi artinya kira-kira sebagai berikut.  Pergeseran maksimum adalah nilai maksimum dimana dimensi yang dibuat kode klien dapat terdistorsi.  Misalkan, dalam contoh kita dengan tiga CPU, kode klien mulai mengukur waktu pada CPU3 (di mana TSC adalah 20), dan berakhir pada CPU2 (di mana TSC adalah 150).  Ternyata 130 kutu tambahan akan menyusup ke interval yang diukur.  Dan tidak akan pernah lagi.  Perbedaan antara CPU1 dan CPU2 akan hanya 100 ticks.  Memiliki perkiraan 130 ticks (pada kenyataannya, itu akan jauh lebih konservatif), klien dapat memutuskan apakah nilai distorsi seperti itu cocok untuknya atau tidak </li><li>  Apakah nilai TSC diukur secara berurutan pada kenaikan CPU yang sama atau berbeda.  Inilah idenya.  Katakanlah kita memiliki beberapa CPU.  Misalkan jam mereka disinkronkan dan terus berdetak pada frekuensi yang sama.  Kemudian jika Anda pertama kali mengukur waktu pada satu CPU, dan kemudian mengukurnya lagi - sudah pada salah satu CPU yang tersedia - maka digit kedua harus lebih besar dari yang pertama. <br><br>  Saya akan menyebut estimasi ini di bawah estimasi monotonisitas TSC <br></li></ol><br>  Sekarang mari kita lihat bagaimana kita bisa mendapatkan estimasi pertama: <br><br><ol><li>  salah satu prosesor yang tersedia untuk proses tersebut dinyatakan "dasar" </li><li>  maka semua CPU lainnya diurutkan, dan untuk masing-masing shift dihitung: <code>TSC___CPU – TSC___CPU</code> .  Ini dilakukan sebagai berikut: <br><ul><li>  a) tiga nilai terukur diambil secara berurutan (satu demi satu!): <code>TSC_base_1, TSC_current, TSC_base_2</code> .  Di sini, saat ini menunjukkan bahwa nilai diukur pada CPU saat ini, dan berdasarkan pada basis </li><li>  b) shift <code>TSC___CPU – TSC___CPU</code> harus terletak pada interval <code>[TSC_current – TSC_base_2, TSC_current – TSC_base_1]</code> .  Ini berdasarkan asumsi bahwa TSC terus berdetak pada frekuensi yang sama pada kedua CPU. </li><li>  c) langkah a) -b) diulang beberapa kali.  Perpotongan semua interval yang diperoleh pada langkah b) dihitung.  Interval yang dihasilkan diambil sebagai estimasi shift <code>TSC___CPU – TSC___CPU</code> </li></ul><br></li><li>  setelah estimasi shift diperoleh untuk setiap CPU relatif terhadap basis, mudah untuk mendapatkan estimasi pergeseran maksimum antara semua CPU yang tersedia: <br><ul><li>  a) interval minimum dihitung, yang mencakup semua interval yang dihasilkan yang diperoleh pada langkah 2 </li><li>  b) lebar interval ini diambil sebagai estimasi pergeseran maksimum antara TSC yang berdetak pada CPU yang berbeda </li></ul><br></li></ol><br>  Untuk mengevaluasi monoton di perpustakaan, algoritma berikut ini diterapkan: <br><br><ol><li>  Katakanlah sebuah proses memiliki N CPU yang tersedia </li><li>  Mengukur TSC pada CPU1 </li><li>  Mengukur TSC pada CPU2 </li><li>  ... </li><li>  Mengukur TSC pada CPUN </li><li>  Ukur TSC lagi pada CPU1 </li><li>  Kami memverifikasi bahwa nilai yang diukur meningkat secara monoton dari yang pertama ke yang terakhir </li></ol><br>  Penting di sini bahwa nilai pertama dan terakhir diukur pada CPU yang sama.  Dan inilah alasannya.  Katakanlah kita memiliki 3 CPU.  Misalkan TSC pada CPU2 digeser oleh +100 ticks relatif terhadap TSC pada CPU1.  Anggap juga bahwa TSC pada CPU3 digeser oleh +100 ticks relatif terhadap TSC pada CPU2.  Pertimbangkan rangkaian acara berikut: <br><br><ul><li>  Baca TSC pada CPU1.  Biarkan nilai 10 diperoleh </li><li>  2 ticks berlalu </li><li>  Baca TSC pada CPU2.  Harus 112 </li><li>  2 ticks berlalu </li><li>  Baca TSC pada CPU3.  Harus 214 </li></ul><br>  Sejauh ini, jamnya terlihat disinkronkan.  Tapi mari kita ukur TSC pada CPU1 lagi: <br><br><ul><li>  2 ticks berlalu </li><li>  Baca TSC pada CPU1.  Harus 16 tahun </li></ul><br>  Ups!  Monoton rusak.  Ternyata mengukur nilai pertama dan terakhir pada CPU yang sama memungkinkan Anda mendeteksi lebih atau kurang pergeseran besar di antara jam.  Pertanyaan selanjutnya, tentu saja: "Seberapa besar pergeserannya?"  Jumlah pergeseran yang dapat dideteksi tergantung pada waktu yang berlalu antara pengukuran TSC berturut-turut.  Dalam contoh yang diberikan, ini hanya 2 ticks.  Pergeseran antara jam yang melebihi 2 kutu akan terdeteksi.  Secara umum, pergeseran yang kurang dari waktu yang berlalu antara pengukuran berturut-turut tidak akan terdeteksi.  Jadi, semakin padat pengukuran terletak pada waktunya, semakin baik.  Keakuratan kedua perkiraan tergantung pada ini.  Semakin padat pengukuran dilakukan: <br><br><ul><li>  semakin rendah estimasi pergeseran maksimum </li><li>  semakin percaya diri dalam penilaian monoton </li></ul><br>  Di bagian selanjutnya, kita akan berbicara tentang bagaimana melakukan pengukuran ketat.  Saya akan menambahkan di sini bahwa ketika menghitung perkiraan keandalan TSC, perpustakaan melakukan banyak pemeriksaan "kutu" yang lebih sederhana, misalnya: <br><br><ul><li>  verifikasi terbatas bahwa TSC pada CPU berbeda berdetak pada kecepatan yang sama </li><li>  memeriksa apakah penghitung benar-benar berubah dari waktu ke waktu, dan tidak hanya menunjukkan nilai yang sama </li></ul><br><h3>  Dua metode untuk mengumpulkan nilai penghitung </h3><br>  Di perpustakaan, saya menerapkan dua metode untuk mengumpulkan nilai TSC: <br><br><ol><li>  <b>Beralih di antara CPU</b> .  Dalam metode ini, semua data yang diperlukan untuk menilai keandalan TSC dikumpulkan oleh satu utas yang "melompat" dari satu CPU ke CPU lainnya.  Kedua algoritma yang dijelaskan pada bagian sebelumnya cocok untuk metode ini dan tidak cocok untuk yang lain. <br>  "Beralih di antara CPU" tidak memiliki penggunaan praktis.  Metode itu diterapkan hanya demi "bermain-main."  Masalah dengan metode ini adalah waktu yang dibutuhkan untuk "menyeret" aliran dari satu CPU ke CPU lainnya sangat besar.  Oleh karena itu, banyak waktu berlalu antara pengukuran TSC berturut-turut, dan akurasi estimasi sangat rendah.  Misalnya, perkiraan tipikal untuk pergeseran maksimum antara TSC diperoleh di wilayah 23.000 kutu. <br><br>  Namun, metode ini memiliki beberapa keunggulan: <br><ul><li>  itu mutlak deterministik.  Jika Anda perlu mengukur TSC secara berurutan pada CPU1, CPU2, CPU3, maka kami hanya mengambil dan melakukannya: beralih ke CPU1, baca TSC, beralih ke CPU2, baca TSC, dan akhirnya, beralih ke CPU3, baca TSC </li><li>  mungkin, jika jumlah CPU dalam sistem tumbuh sangat cepat, maka waktu peralihan di antara mereka harus tumbuh jauh lebih lambat.  Karena itu, secara teori, ternyata, sebuah sistem bisa ada - sistem yang sangat besar!  - di mana penggunaan metode ini akan dibenarkan.  Tapi tetap saja ini tidak mungkin </li></ul><br></li><li>  <b>Pengukuran dipesan menggunakan CAS</b> .  Dalam metode ini, data dikumpulkan secara paralel oleh banyak utas.  Setiap CPU yang tersedia memulai satu utas.  Pengukuran yang dilakukan oleh utas berbeda diatur dalam satu urutan menggunakan operasi “bandingkan-dan-tukar”.  Di bawah ini adalah bagian dari kode yang menunjukkan bagaimana hal ini dilakukan. <br>  Gagasan metode ini dipinjam dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fio</a> , alat yang populer untuk menghasilkan beban I / O. <br><br>  Estimasi keandalan yang diperoleh dengan kekuatan metode ini sudah terlihat cukup bagus.  Misalnya, perkiraan pergeseran maksimum sudah diperoleh pada level beberapa ratus kutu.  Pemeriksaan monoton memungkinkan Anda untuk menangkap jam tidak sinkron dalam ratusan kutu. <br><br>  Namun, algoritma yang diberikan pada bagian sebelumnya tidak cocok untuk metode ini.  Penting bagi mereka bahwa nilai-nilai TSC diukur dalam urutan yang telah ditentukan.  Metode "pengukuran yang dipesan oleh CAS" tidak memungkinkan hal ini.  Alih-alih, pertama urutan panjang pengukuran acak dikumpulkan, dan kemudian algoritma (sudah berbeda) mencoba mencari nilai yang dibaca pada CPU "cocok" dalam urutan ini. <br><br>  Saya tidak akan memberikan algoritme ini di sini, agar tidak menyalahgunakan perhatian Anda.  Anda dapat melihatnya dalam kode.  Ada banyak komentar.  Secara teori, algoritma ini sama.  Poin mendasar yang baru adalah verifikasi tentang bagaimana urutan TSC yang diketik secara acak adalah "kualitatif".  Dimungkinkan juga untuk menetapkan tingkat signifikansi statistik minimum yang dapat diterima untuk perkiraan keandalan TSC. <br><br>  Secara teoritis, pada sistem SANGAT besar, metode "CAS ordered" dapat memberikan hasil yang buruk.  Metode ini membutuhkan prosesor untuk bersaing mendapatkan akses ke lokasi memori umum.  Jika ada banyak prosesor, maka persaingan bisa berubah menjadi sangat intens.  Akibatnya, akan sulit untuk membuat urutan pengukuran dengan sifat statistik yang baik.  Namun, saat ini, situasi ini tampaknya tidak mungkin. <br></li></ol><br>  Saya berjanji beberapa kode.  Begini tampilannya membangun pengukuran dalam satu rantai menggunakan CAS. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arg-&gt;probes_count; i++ ) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> seq_num = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> tsc_val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { __atomic_load( seq_counter, &amp;seq_num, __ATOMIC_ACQUIRE); __sync_synchronize(); tsc_val = WTMLIB_GET_TSC(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( !__atomic_compare_exchange_n( seq_counter, &amp;seq_num, seq_num + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED)); arg-&gt;tsc_probes[i].seq_num = seq_num; arg-&gt;tsc_probes[i].tsc_val = tsc_val; }</code> </pre><br>  Kode ini dijalankan pada setiap CPU yang tersedia.  Semua utas memiliki akses ke variabel <code>seq_counter</code> .  Sebelum membaca TSC, stream membaca nilai variabel ini dan menyimpannya dalam variabel <code>seq_num</code> .  Kemudian membaca TSC.  Kemudian ia mencoba untuk meningkatkan seq_counter satu per satu, tetapi hanya jika nilai variabel tidak berubah sejak dibaca.  Jika operasi berhasil, maka ini berarti bahwa utas berhasil "mengintai" nomor urut yang disimpan dalam <code>seq_num</code> di belakang nilai TSC yang diukur.  Nomor seri berikutnya, yang akan dapat dipertaruhkan (mungkin sudah ada di utas lain) akan menjadi satu lagi.  Untuk nomor ini diambil dari variabel <code>seq_counter</code> , dan setiap panggilan yang berhasil dari <code>__atomic_compare_exchange_n()</code> meningkatkan variabel ini dengan satu. <br><br><div class="spoiler">  <b class="spoiler_title">__atomic dengan __sync ???</b> <div class="spoiler_text">  Demi <code>__atomic</code> , perlu dicatat bahwa menggunakan fungsi <code>__atomic</code> keluarga <code>__atomic</code> bersama dengan fungsi dari keluarga <code>__sync</code> usang terlihat jelek.  <code>__sync_synchronize()</code> digunakan dalam kode untuk menghindari penataan ulang operasi membaca TSC dengan operasi hulu.  Ini membutuhkan penghalang memori yang lengkap.  Keluarga <code>__atomic</code> secara formal tidak memiliki fungsi dengan properti yang sesuai.  Meskipun sebenarnya ada: <code>__atomic_signal_fence()</code> .  Fungsi ini mengatur perhitungan aliran dengan penangan sinyal yang mengeksekusi pada aliran yang sama.  Sebenarnya, ini adalah penghalang yang lengkap.  Namun, ini tidak dinyatakan secara eksplisit.  Dan saya lebih suka kode yang tidak memiliki semantik tersembunyi.  Karenanya <code>__sync_synchronize()</code> adalah penghalang memori stop-full. <br></div></div><br>  Poin lain yang layak disebutkan di sini adalah kepedulian bahwa semua aliran yang terlibat dalam pengukuran mulai kurang lebih secara bersamaan.  Kami tertarik pada fakta bahwa nilai-nilai TSC yang dibaca pada CPU yang berbeda sangat beragam.  Kami tidak puas dengan situasi ketika, misalnya, satu utas dimulai pertama, menyelesaikan pekerjaannya, dan baru kemudian semua lainnya mulai.  Urutan TSC yang dihasilkan akan memiliki sifat tidak berguna.  Tidak ada perkiraan yang bisa diambil darinya.  Awal yang simultan dari semua utas penting - dan untuk ini, langkah-langkah telah diambil di perpustakaan. <br><br><h3>  Ubah kutu menjadi nanodetik dengan cepat </h3><br>  Setelah memeriksa keandalan TSC, tujuan utama kedua perpustakaan adalah untuk mengubah kutu menjadi nanodetik dengan cepat.  Saya meminjam ide konversi ini dari fio yang telah disebutkan.  Namun, saya harus membuat beberapa perbaikan yang signifikan, karena seperti yang ditunjukkan oleh analisis saya, pada akhirnya prosedur konversi tidak berfungsi dengan cukup baik.  Di sana Anda mendapatkan akurasi rendah. <br><br>  Saya akan mulai dengan sebuah contoh. <br><br>  Idealnya, saya ingin mengonversi kutu menjadi nanodetik seperti ini: <br> <code>ns_time = tsc_ticks / tsc_per_ns</code> <br>  Kami ingin waktu yang dihabiskan untuk konversi menjadi minimal.  Oleh karena itu, kami bertujuan untuk menggunakan aritmatika integer eksklusif.  Mari kita lihat bagaimana ini bisa mengancam kita. <br><br>  Jika <code>tsc_per_ns = 3</code> , maka divisi integer sederhana, dari sudut pandang akurasi, berfungsi dengan baik: <code>ns_time = tsc_ticks / 3</code> . <br><br>  Tetapi bagaimana jika <code>tsc_per_ns = 3.333</code> ?       3,      .      : <br> <code>ns_time = (tsc_ticks * factor) / (3.333 * factor)</code> . <br><br>   <code>factor</code>  ,     .  -  .  ,    .   –    . ,  x86   10+ .   ,      . <br><br>      : <br> <code>ns_time = (tsc_ticks * factor / 3.333) / factor</code> . <br><br>   –  .    <code>(factor / 3.333)</code> .     – - .    ,   <code>factor</code>   .           –    . <br><br>     <code>factor</code> ?  , <code>factor</code>      .    ,  ,   ,      64- . ,     «» .  ,         . <br><br>  ,     <code>factor</code>    . ,          .   TSC    : <code>3.333 * 1000000000 * 60 * 60 * 24 * 365 = 105109488000000000</code> .    64-    : <code>18446744073709551615 / 105109488000000000 ~ 175.5</code> .  ,  <code>(factor / 3.333)</code>    ,   .  : <code>factor &lt;= 175.5 * 3.333 ~ 584.9</code> .    ,     ,  512. ,     : <br><br> <code>ns_time = (tsc_ticks * 512 / 3.333) / 512</code> <br> <br> : <br><br> <code>ns_time = tsc_ticks * 153 / 512</code> <br> <br> .   ,      .     <code>1000000000 * 60 * 60 * 24 * 365 = 31536000000000000</code> .    : <code>105109488000000000 * 153 / 512 = 31409671218750000</code> .      126328781250000 ,  <code>126328781250000 / 1000000000 / 60 / 60 ~ 35</code> . <br><br>   .    .          ?   .      .   : <br><br> <code>ns_time = tsc_ticks * 1258417 / 4194304</code> (1) <br><br>     119305   1  (  0.2 ).    .        ,  ,      .     ?       ? <br><br>     : <br><br> <code>tsc_ticks = (tsc_ticks_per_1_hour * number_of_hours) + tsc_ticks_remainder</code> <br> <br>    <code>tsc_ticks_per_1_hour</code> ,    <code>number_of_hours</code>  <code>tsc_ticks</code> . ,  ,      .           <code>tsc_ticks</code> ,     .   ,      <code>tsc_ticks_remainder</code> .   ,      ,   .  ,     ,     (1). <br><br> .     .      . <br><br>  ,        .           1 .      : <br><br> <code>tsc_ticks = modulus * number_of_moduli_periods + tsc_ticks_remainder</code> <br> <br>   ,     : <br><br> <code>ns_per_remainder = (tsc_ticks_remainder * factor / tsc_per_nsec) / factor</code> <br> <br>    ( ,  <code>tsc_ticks_remainder &lt; modulus</code> ): <br><br> <code>modulus * (factor / tsc_per_nsec) &lt;= UINT64_MAX <br> factor &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br> 2 ^ shift &lt;= (UINT64_MAX / modulus) * tsc_per_nsec <br></code> <br><br>  ,  ,          .        .  ,     ,  ,     . <br><br>  ,      <code>shift</code> ,  : <br><br> <code>factor = 2 ^ shift <br> mult = factor / tsc_per_nsec <br></code> <br><br>          : <br><br> <code>ns_per_remainder = (tsc_ticks_remainder * mult) &gt;&gt; shift <br></code> <br><br> ,    .  ,    –   <code>tsc_ticks_remainder</code>  <code>number_of_moduli_periods</code>  <code>tsc_ticks</code> .  ,     .  ,     .    <code>modulus</code>   : <br><br> <code>modulus = 2 ^ remainder_bit_length</code> <br> <br> : <br><br> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length <br> tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> <br> <br>  Bagus   ,    <code>tsc_ticks</code> <code>number_of_moduli_periods</code>  <code>tsc_ticks_remainder</code> .  ,   <code>tsc_ticks_remainder</code>  .  ,       ,   <code>modulus</code> .    : <br><br> <code>ns_per_moduli = ns_per_modulus * number_of_moduli_periods</code> <br> <br> <code>ns_per_modulus</code>   .     ,     .       ,   ,  <code>modulus</code> .  <code>modulus</code> , ,  ,  <code>modulus</code> . <br><br> <code>ns_per_modulus = (modulus * mult) &gt;&gt; shift</code> <br> <br> !     ,       « ».     : <br><br><ol><li>  <code>tsc_ticks</code> </li><li> <code>number_of_moduli_periods = tsc_ticks &gt;&gt; remainder_bit_length</code> </li> <li> <code>tsc_ticks_remainder = tsc_ticks &amp; (modulus - 1)</code> </li> <li> <code>ns = ns_per_modulus * number_of_moduli_periods + (tsc_ticks_remainder * mult) &gt;&gt; shift</code> </li> </ol><br>     <code>remainder_bit_length</code> , <code>modulus, ns_per_modulus</code> , <code>mult</code>  <code>shift</code>  . <br><br>       ,      .  ,   performance-    . <br><br>  Jadi disini. ,     :) <br><br> ,     <code>mult</code> ?    : <br><br> <code>mult = factor / tsc_per_nsec</code> <br> <br> :   <code>tsc_per_nsec</code> ? <br>      –    .       <code>tsc_per_nsec</code>  <code>(tsc_per_sec / 1000000000)</code> . ..: <br><br> <code>mult = factor * 1000000000 / tsc_per_sec</code> <br> <br>      : <br><br><ol><li>  <code>tsc_per_sec</code> ,   <code>tsc_per_msec</code> , ? </li><li>    <code>tsc_per_sec</code> ? </li></ol><br>   .  fio       .     .  ,     , <code>tsc_per_msec = 2599998</code> .     <code>tsc_per_sec = 2599998971</code> .       ,        : 0.999999626.      ,   ,         374 .  – <code>tsc_per_sec</code> . <br><br> …   <code>tsc_per_sec</code> ? <br><br>      : <br><br> <code>start_sytem_time = clock_gettime() <br> start_tsc = WTMLIB_GET_TSC() <br>  -  <br> end_system_time = clock_gettime() <br> end_tsc = WTMLIB_GET_TSC() <br></code> <br><br> «- » —   .    ,     . ,  .  ,     <code>end_system_time</code>  <code>start_system_time</code>   0,6 .  <code>tsc_per_sec = (end_tsc – start_tsc) / 0,6</code> . <br><br>       <code>tsc_per_sec</code> .     «»       -  <code>tsc_per_sec</code> ,   . <br><br>    ,  ,    <code>clock_gettime()</code>  <code>WTMLIB_GET_TSC()</code> . ,     <code>WTMLIB_GET_TSC()</code>     ,      <code>clock_gettime()</code> .          TSC.     <code>tsc_per_sec</code>     .      <code>tsc_per_sec</code>           .         . <br><br><h3>  Kesimpulan </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mungkin itu saja. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi topik pengukuran waktu yang efektif tidak terbatas pada hal ini. </font><font style="vertical-align: inherit;">Ada banyak nuansa. </font><font style="vertical-align: inherit;">Bagi mereka yang tertarik, saya mengusulkan untuk bekerja secara independen pada masalah-masalah berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menyimpan parameter konversi dalam cache atau - bahkan lebih baik - di register </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hingga batas apa yang dapat dikurangi </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(dengan demikian meningkatkan keakuratan konversi)?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti yang telah kita lihat, keakuratan konversi dipengaruhi tidak hanya </font></font><code>modulus</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi juga oleh ukuran interval waktu, yang berkorelasi dengan kutu ( </font></font><code>tsc_per_msec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>tsc_per_sec</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Bagaimana menyeimbangkan pengaruh kedua faktor tersebut?</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TSC di mesin virtual. </font><font style="vertical-align: inherit;">Bisakah saya menggunakannya?</font></font></li><li>        . , fio        timespec.    : <br><br> <code>tp-&gt;tv_sec = nsecs / 1000000000ULL;</code> <br> <br> ,   TSC          .         ,  ,      <br></li></ul><br>                .   ,        . <br><br> ,  fio,      ,        700-900  (     ).      -      .     fio.    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">    ,  </a> .   ,  . <br><br>     ! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id425237/">https://habr.com/ru/post/id425237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id425227/index.html">Para peneliti telah menemukan cara untuk mendeteksi dan memotong kunci Honeytoken di sejumlah layanan Amazon.</a></li>
<li><a href="../id425229/index.html">Bagaimana kami membantu CDN MegaFon.TV tidak mencapai Piala Dunia 2018</a></li>
<li><a href="../id425231/index.html">FAQ tentang pekerjaan pramugari</a></li>
<li><a href="../id425233/index.html">Python 3 di Facebook</a></li>
<li><a href="../id425235/index.html">Lebih banyak tentang grafik, atau cara mendeteksi ketergantungan antara aplikasi Anda</a></li>
<li><a href="../id425241/index.html">Pengembang 20 tahun kemudian: Dengan mudah Lebedev tentang ICRE, pendidikan, bukunya, dan pemrogramannya</a></li>
<li><a href="../id425243/index.html">Buku pegangan john willis</a></li>
<li><a href="../id425245/index.html">Pengumuman RamblerFront & # 6</a></li>
<li><a href="../id425247/index.html">Crowdsourcing dalam pengujian</a></li>
<li><a href="../id425249/index.html">Bagaimana berkenalan dengan LLP di ITMO University: kursus "Pemrograman Tingkat Rendah"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>