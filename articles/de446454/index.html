<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçüíª üë≤üèº ü§ôüèº Golang Webserver-Entwicklung - Von einfach zu komplex ‚ûñ ü•É ‚òÅÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor f√ºnf Jahren begann ich mit der Entwicklung von Gophish , was es erm√∂glichte, Golang zu lernen. Ich erkannte, dass Go eine m√§chtige Sprache ist, de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang Webserver-Entwicklung - Von einfach zu komplex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/446454/"><img src="https://habrastorage.org/getpro/habr/post_images/da7/244/1d8/da72441d8fc6c0c8b5a7e735b4d0b506.png"><br><br>  Vor f√ºnf Jahren begann ich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Gophish</a> , was es erm√∂glichte, Golang zu lernen.  Ich erkannte, dass Go eine m√§chtige Sprache ist, deren F√§higkeiten durch viele Bibliotheken erg√§nzt werden.  Go ist universell: Insbesondere mit seiner Hilfe ist es m√∂glich, Serveranwendungen ohne Probleme zu entwickeln. <br><br>  In diesem Artikel geht es um das Schreiben eines Servers in Go.  Beginnen wir mit einfachen Dingen wie ‚ÄûHallo Welt!‚Äú Und enden mit einer Anwendung mit den folgenden Funktionen: <br><br>  - Verwenden von Let's Encrypt f√ºr HTTPS. <br>  - Arbeiten Sie als API-Router. <br>  - Arbeiten Sie mit Middleware. <br>  - Verarbeitung statischer Dateien. <br>  - Richtiges Herunterfahren. <br><a name="habracut"></a><br><blockquote>  <b>Skillbox empfiehlt:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Python-Entwickler von Grund</a> <b>auf zum Anfassen</b> . <br><br>  <b>Wir erinnern Sie daran:</b> <i>F√ºr alle Leser von ‚ÄûHabr‚Äú - ein Rabatt von 10.000 Rubel bei der Anmeldung f√ºr einen Skillbox-Kurs mit dem Promo-Code ‚ÄûHabr‚Äú.</i> <br></blockquote><h3>  Hallo Welt! </h3><br>  Das Erstellen eines Webservers unter Go ist sehr schnell.  Hier ist ein Beispiel f√ºr die Verwendung eines Handlers, der das oben versprochene "Hallo Welt!" Zur√ºckgibt. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":80"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  Wenn Sie danach die Anwendung starten und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost-</a> Seite √∂ffnen, wird sofort der Text "Hallo Welt!" Angezeigt.  (Nat√ºrlich, wenn alles richtig funktioniert). <br><br>  Als n√§chstes werden wir den Handler wiederholt verwenden, aber zuerst wollen wir verstehen, wie alles funktioniert. <br><br><h4>  net / http </h4><br>  In diesem Beispiel wurde das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/"><code>net/http</code></a> , das das Hauptwerkzeug in Go f√ºr die Entwicklung von Servern und HTTP-Clients ist.  Um den Code zu verstehen, schauen wir uns die Bedeutung von drei wichtigen Elementen an: http.Handler, http.ServeMux und http.Server. <br><br><h4>  HTTP-Handler </h4><br>  Wenn wir eine Anfrage erhalten, analysiert der Handler diese und bildet eine Antwort.  Go-Handler werden wie folgt implementiert: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ServeHTTP(ResponseWriter, *Request) }</code> </pre> <br>  Das erste Beispiel verwendet die Hilfsfunktion http.HandleFunc.  Es umschlie√üt eine andere Funktion, die wiederum http.ResponseWriter und http.Request in ServeHTTP akzeptiert. <br><br>  Mit anderen Worten, Golang-Handler werden durch eine einzige Schnittstelle dargestellt, die dem Programmierer viele M√∂glichkeiten bietet.  So wird beispielsweise Middleware mithilfe eines Handlers implementiert, wobei ServeHTTP zuerst etwas ausf√ºhrt und dann die ServeHTTP-Methode eines anderen Handlers aufruft. <br><br>  Wie oben erw√§hnt, generieren Handler einfach Antworten auf Anforderungen.  Aber welcher bestimmte Handler sollte zu einem bestimmten Zeitpunkt verwendet werden? <br><br><h4>  Routing anfordern </h4><br>  Verwenden Sie den HTTP-Multiplexer, um die richtige Wahl zu treffen.  In einigen Bibliotheken wird es als Muxer oder Router bezeichnet, aber es ist alles das Gleiche.  Die Multiplexerfunktion besteht darin, den Anforderungspfad zu analysieren und den geeigneten Handler auszuw√§hlen. <br><br>  Wenn Sie Unterst√ºtzung f√ºr komplexes Routing ben√∂tigen, ist es besser, Bibliotheken von Drittanbietern zu verwenden.  Eine der fortschrittlichsten ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gorilla / Mux</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Chi / Chi</a> . Diese Bibliotheken erm√∂glichen die problemlose Implementierung der Zwischenverarbeitung.  Mit ihrer Hilfe k√∂nnen Sie das Wildcard-Routing konfigurieren und eine Reihe anderer Aufgaben ausf√ºhren.  Ihr Plus ist die Kompatibilit√§t mit Standard-HTTP-Handlern.  Infolgedessen k√∂nnen Sie einfachen Code mit der M√∂glichkeit seiner zuk√ºnftigen √Ñnderung schreiben. <br><br>  Das Arbeiten mit komplexen Frameworks in einer normalen Situation erfordert nicht ganz Standardl√∂sungen, was die Verwendung von Standardhandlern erheblich erschwert.  Um die √ºberwiegende Mehrheit der Anwendungen zu erstellen, reicht eine Kombination aus der Standardbibliothek und einem einfachen Router aus. <br><br><h4>  Anfrage bearbeiten </h4><br>  Dar√ºber hinaus ben√∂tigen wir eine Komponente, die eingehende Verbindungen ‚Äûabh√∂rt‚Äú und alle Anforderungen an den richtigen Handler umleitet.  Diese Aufgabe kann problemlos von http.Server ausgef√ºhrt werden. <br><br>  Das Folgende zeigt, dass der Server f√ºr alle Aufgaben verantwortlich ist, die sich auf die Verbindungsverarbeitung beziehen.  Dies funktioniert beispielsweise mit dem TLS-Protokoll.  Zum Implementieren des Aufrufs von http.ListenAndServer wird ein Standard-HTTP-Server verwendet. <br><br>  Schauen wir uns nun komplexere Beispiele an. <br><br><h3>  Hinzuf√ºgen von Let's Encrypt </h3><br>  Standardm√§√üig wird unsere Anwendung √ºber das HTTP-Protokoll ausgef√ºhrt. Es wird jedoch empfohlen, das HTTPS-Protokoll zu verwenden.  In Go ist dies problemlos m√∂glich.  Wenn Sie ein Zertifikat und einen privaten Schl√ºssel erhalten haben, registrieren Sie ListenAndServeTLS einfach mit den richtigen Zertifikat- und Schl√ºsseldateien. <br><br><pre> <code class="go hljs">http.ListenAndServeTLS(<span class="hljs-string"><span class="hljs-string">":443"</span></span>, <span class="hljs-string"><span class="hljs-string">"cert.pem"</span></span>, <span class="hljs-string"><span class="hljs-string">"key.pem"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Sie k√∂nnen es immer besser machen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Let's Encrypt</a> bietet kostenlose Zertifikate mit der M√∂glichkeit zur automatischen Verl√§ngerung.  Um den Dienst nutzen zu k√∂nnen, ben√∂tigen Sie das <code>autocert</code> Paket. <br><br>  Die einfachste M√∂glichkeit zur Konfiguration besteht darin, die Methode autocert.NewListener in Kombination mit http.Serve zu verwenden.  Mit dieser Methode k√∂nnen Sie TLS-Zertifikate empfangen und erneuern, w√§hrend der HTTP-Server Anforderungen verarbeitet: <br><br><pre> <code class="go hljs">http.Serve(autocert.NewListener(<span class="hljs-string"><span class="hljs-string">"example.com"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">example.com</a> im Browser √∂ffnen, erhalten wir die HTTPS-Antwort "Hallo Welt!". <br><br>  Wenn Sie eine gr√ºndlichere Konfiguration ben√∂tigen, sollten Sie den Manager autocert.Manager verwenden.  Dann erstellen wir unsere eigene http.Server-Instanz (bis jetzt haben wir sie standardm√§√üig verwendet) und f√ºgen den Manager dem TLSConfig-Server hinzu: <br><br><pre> <code class="go hljs">m := &amp;autocert.Manager{ Cache: autocert.DirCache(<span class="hljs-string"><span class="hljs-string">"golang-autocert"</span></span>), Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(<span class="hljs-string"><span class="hljs-string">"example.org"</span></span>, <span class="hljs-string"><span class="hljs-string">"www.example.org"</span></span>), } server := &amp;http.Server{ Addr: <span class="hljs-string"><span class="hljs-string">":443"</span></span>, TLSConfig: m.TLSConfig(), } server.ListenAndServeTLS(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre> <br>  Dies ist eine einfache M√∂glichkeit, die vollst√§ndige HTTPS-Unterst√ºtzung mit automatischer Zertifikatserneuerung zu implementieren. <br><br><h3>  Benutzerdefinierte Routen hinzuf√ºgen </h3><br>  Der in der Standardbibliothek enthaltene Standardrouter ist gut, aber sehr einfach.  Die meisten Anwendungen erfordern ein komplexeres Routing, einschlie√ülich verschachtelter Routen und Platzhalterrouten, oder das Verfahren zum Festlegen von Mustern und Pfadparametern. <br><br>  In diesem Fall sollten Sie die Pakete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Gorilla / Mux</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Go-Chi / Chi verwenden</a> .  Wir werden lernen, wie man mit letzterem arbeitet - ein Beispiel ist unten gezeigt. <br><br>  Gegeben ist die Datei api / v1 / api.go, die die Routen f√ºr unsere API enth√§lt: <br><br><pre> <code class="go hljs">/ HelloResponse is the JSON representation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a customized message <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HelloResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"message"`</span></span> } <span class="hljs-comment"><span class="hljs-comment">// HelloName returns a personalized JSON message func HelloName(w http.ResponseWriter, r *http.Request) { name := chi.URLParam(r, "name") response := HelloResponse{ Message: fmt.Sprintf("Hello %s!", name), } jsonResponse(w, response, http.StatusOK) } // NewRouter returns an HTTP handler that implements the routes for the API func NewRouter() http.Handler { r := chi.NewRouter() r.Get("/{name}", HelloName) return r }</span></span></code> </pre> <br>  Wir setzen das Pr√§fix api / vq f√ºr Routen in der Hauptdatei. <br><br>  Wir k√∂nnen dies dann auf unserem Hauptrouter unter dem Pr√§fix api / v1 / in unserer Hauptanwendung mounten: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// NewRouter returns a new HTTP handler that implements the main server routes func NewRouter() http.Handler { router := chi.NewRouter() router.Mount("/api/v1/", v1.NewRouter()) return router } http.Serve(autocert.NewListener("example.com"), NewRouter())</span></span></code> </pre> <br>  Die Einfachheit der Arbeit mit komplexen Routen in Go erm√∂glicht es, die Strukturierung durch die Bereitstellung gro√üer komplexer Anwendungen zu vereinfachen. <br><br><h3>  Arbeiten Sie mit Middleware </h3><br>  Bei der Zwischenverarbeitung wird ein HTTP-Handler mit einem anderen umbrochen, wodurch eine schnelle Authentifizierung, Komprimierung, Aufzeichnung und einige andere Funktionen m√∂glich sind. <br><br>  Betrachten Sie als Beispiel die Schnittstelle http.Handler, mit deren Hilfe wir einen Handler mit Authentifizierung der Benutzer des Dienstes schreiben. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequireAuthentication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isAuthenticated(r) { http.Redirect(w, r, <span class="hljs-string"><span class="hljs-string">"/login"</span></span>, http.StatusTemporaryRedirect) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Assuming authentication passed, run the original handler next.ServeHTTP(w, r) }) }</span></span></code> </pre> <br>  Es gibt Router von Drittanbietern, z. B. Chi, mit denen Sie die Funktionalit√§t der Zwischenverarbeitung erweitern k√∂nnen. <br><br><h3>  Arbeiten Sie mit statischen Dateien </h3><br>  Die Go-Standardbibliothek enth√§lt Funktionen zum Arbeiten mit statischen Inhalten, einschlie√ülich Bildern, sowie JavaScript- und CSS-Dateien.  Sie k√∂nnen √ºber die Funktion http.FileServer aufgerufen werden.  Es gibt einen Handler zur√ºck, der Dateien aus einem bestimmten Verzeichnis verteilt. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { router := chi.NewRouter() r.Get(<span class="hljs-string"><span class="hljs-string">"/{name}"</span></span>, HelloName) <span class="hljs-comment"><span class="hljs-comment">//     staticPath, _ := filepath.Abs("../../static/") fs := http.FileServer(http.Dir(staticPath)) router.Handle("/*", fs) return r</span></span></code> </pre> <br>  Beachten Sie, dass http.Dir den Inhalt des Verzeichnisses anzeigt, wenn es nicht √ºber die Hauptdatei index.html verf√ºgt.  In diesem Fall lohnt es sich, das nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>unindexed</code></a> Paket zu verwenden, um zu verhindern, dass das Verzeichnis kompromittiert wird. <br><br><h3>  Richtiges Herunterfahren </h3><br>  Go hat auch eine Funktion wie das korrekte Herunterfahren des HTTP-Servers.  Dies kann mit der Shutdown () -Methode erfolgen.  Der Server startet in Goroutine und dann wird der Kanal abgeh√∂rt, um ein Interrupt-Signal zu empfangen.  Sobald das Signal empfangen wird, wird der Server heruntergefahren, jedoch nicht sofort, sondern nach einigen Sekunden. <br><br><pre> <code class="go hljs">handler := server.NewRouter() srv := &amp;http.Server{ Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { srv.Serve(autocert.NewListener(domains...)) }() <span class="hljs-comment"><span class="hljs-comment">// Wait for an interrupt c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) &lt;-c // Attempt a graceful shutdown ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() srv.Shutdown(ctx)</span></span></code> </pre> <br><h3>  Abschlie√üend </h3><br>  Go ist eine leistungsstarke Sprache mit einer fast universellen Standardbibliothek.  Die Standardfunktionen sind sehr umfangreich und k√∂nnen mithilfe von Schnittstellen verst√§rkt werden. Auf diese Weise k√∂nnen Sie wirklich zuverl√§ssige HTTP-Server entwickeln. <br><blockquote>  <b>Skillbox empfiehlt:</b> <br><br><ul><li>  Zweij√§hriger Praktikumskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Ich bin ein PRO-Webentwickler</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> </li><li>  Online-Bildungskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Beruf Java-Entwickler"</a> . </li><li>  Praktischer Jahreskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"PHP-Entwickler von 0 bis PRO"</a> . <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446454/">https://habr.com/ru/post/de446454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446440/index.html">Das Buch Reagieren Sie schnell. Webanwendungen in React, JSX, Redux und GraphQL ¬ª</a></li>
<li><a href="../de446444/index.html">Von Skype zu WebRTC: Wie wir die Webvideokommunikation organisiert haben</a></li>
<li><a href="../de446446/index.html">Grundlagen der JavaScript-Engine: Allgemeine Formulare und Inline-Caching. Teil 1</a></li>
<li><a href="../de446448/index.html">5 Grundregeln f√ºr die Durchf√ºhrung von Probleminterviews zur Ermittlung der Verbraucherbed√ºrfnisse</a></li>
<li><a href="../de446452/index.html">Mondmission "Bereshit" - 4. April 2019, der √úbergang zur Mondumlaufbahn ist abgeschlossen, 7 Flugtage voraus, 6 Man√∂ver und 1 Landung</a></li>
<li><a href="../de446456/index.html">Importsubstitution in der Praxis. Teil 1. Optionen</a></li>
<li><a href="../de446458/index.html">Universal DRO basierend auf Arduino Nano - shDRO. Teil 2</a></li>
<li><a href="../de446460/index.html">Food Design Digest M√§rz 2019</a></li>
<li><a href="../de446462/index.html">Eintauchen in den Fahrer: das allgemeine Prinzip des R√ºckw√§rtsfahrens am Beispiel der Aufgabe NeoQUEST-2019</a></li>
<li><a href="../de446464/index.html">15 Papageien: W√§hlen Sie einen Hosting-Anbieter f√ºr VPS / VDS-Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>