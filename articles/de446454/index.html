<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍💻 👲🏼 🤙🏼 Golang Webserver-Entwicklung - Von einfach zu komplex ➖ 🥃 ☁️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vor fünf Jahren begann ich mit der Entwicklung von Gophish , was es ermöglichte, Golang zu lernen. Ich erkannte, dass Go eine mächtige Sprache ist, de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang Webserver-Entwicklung - Von einfach zu komplex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillbox/blog/446454/"><img src="https://habrastorage.org/getpro/habr/post_images/da7/244/1d8/da72441d8fc6c0c8b5a7e735b4d0b506.png"><br><br>  Vor fünf Jahren begann ich mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Gophish</a> , was es ermöglichte, Golang zu lernen.  Ich erkannte, dass Go eine mächtige Sprache ist, deren Fähigkeiten durch viele Bibliotheken ergänzt werden.  Go ist universell: Insbesondere mit seiner Hilfe ist es möglich, Serveranwendungen ohne Probleme zu entwickeln. <br><br>  In diesem Artikel geht es um das Schreiben eines Servers in Go.  Beginnen wir mit einfachen Dingen wie „Hallo Welt!“ Und enden mit einer Anwendung mit den folgenden Funktionen: <br><br>  - Verwenden von Let's Encrypt für HTTPS. <br>  - Arbeiten Sie als API-Router. <br>  - Arbeiten Sie mit Middleware. <br>  - Verarbeitung statischer Dateien. <br>  - Richtiges Herunterfahren. <br><a name="habracut"></a><br><blockquote>  <b>Skillbox empfiehlt:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der Python-Entwickler von Grund</a> <b>auf zum Anfassen</b> . <br><br>  <b>Wir erinnern Sie daran:</b> <i>Für alle Leser von „Habr“ - ein Rabatt von 10.000 Rubel bei der Anmeldung für einen Skillbox-Kurs mit dem Promo-Code „Habr“.</i> <br></blockquote><h3>  Hallo Welt! </h3><br>  Das Erstellen eines Webservers unter Go ist sehr schnell.  Hier ist ein Beispiel für die Verwendung eines Handlers, der das oben versprochene "Hallo Welt!" Zurückgibt. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { http.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { fmt.Fprintf(w, <span class="hljs-string"><span class="hljs-string">"Hello World!"</span></span>) }) http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":80"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) }</code> </pre> <br>  Wenn Sie danach die Anwendung starten und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost-</a> Seite öffnen, wird sofort der Text "Hallo Welt!" Angezeigt.  (Natürlich, wenn alles richtig funktioniert). <br><br>  Als nächstes werden wir den Handler wiederholt verwenden, aber zuerst wollen wir verstehen, wie alles funktioniert. <br><br><h4>  net / http </h4><br>  In diesem Beispiel wurde das Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://golang.org/pkg/net/"><code>net/http</code></a> , das das Hauptwerkzeug in Go für die Entwicklung von Servern und HTTP-Clients ist.  Um den Code zu verstehen, schauen wir uns die Bedeutung von drei wichtigen Elementen an: http.Handler, http.ServeMux und http.Server. <br><br><h4>  HTTP-Handler </h4><br>  Wenn wir eine Anfrage erhalten, analysiert der Handler diese und bildet eine Antwort.  Go-Handler werden wie folgt implementiert: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ServeHTTP(ResponseWriter, *Request) }</code> </pre> <br>  Das erste Beispiel verwendet die Hilfsfunktion http.HandleFunc.  Es umschließt eine andere Funktion, die wiederum http.ResponseWriter und http.Request in ServeHTTP akzeptiert. <br><br>  Mit anderen Worten, Golang-Handler werden durch eine einzige Schnittstelle dargestellt, die dem Programmierer viele Möglichkeiten bietet.  So wird beispielsweise Middleware mithilfe eines Handlers implementiert, wobei ServeHTTP zuerst etwas ausführt und dann die ServeHTTP-Methode eines anderen Handlers aufruft. <br><br>  Wie oben erwähnt, generieren Handler einfach Antworten auf Anforderungen.  Aber welcher bestimmte Handler sollte zu einem bestimmten Zeitpunkt verwendet werden? <br><br><h4>  Routing anfordern </h4><br>  Verwenden Sie den HTTP-Multiplexer, um die richtige Wahl zu treffen.  In einigen Bibliotheken wird es als Muxer oder Router bezeichnet, aber es ist alles das Gleiche.  Die Multiplexerfunktion besteht darin, den Anforderungspfad zu analysieren und den geeigneten Handler auszuwählen. <br><br>  Wenn Sie Unterstützung für komplexes Routing benötigen, ist es besser, Bibliotheken von Drittanbietern zu verwenden.  Eine der fortschrittlichsten ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gorilla / Mux</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Chi / Chi</a> . Diese Bibliotheken ermöglichen die problemlose Implementierung der Zwischenverarbeitung.  Mit ihrer Hilfe können Sie das Wildcard-Routing konfigurieren und eine Reihe anderer Aufgaben ausführen.  Ihr Plus ist die Kompatibilität mit Standard-HTTP-Handlern.  Infolgedessen können Sie einfachen Code mit der Möglichkeit seiner zukünftigen Änderung schreiben. <br><br>  Das Arbeiten mit komplexen Frameworks in einer normalen Situation erfordert nicht ganz Standardlösungen, was die Verwendung von Standardhandlern erheblich erschwert.  Um die überwiegende Mehrheit der Anwendungen zu erstellen, reicht eine Kombination aus der Standardbibliothek und einem einfachen Router aus. <br><br><h4>  Anfrage bearbeiten </h4><br>  Darüber hinaus benötigen wir eine Komponente, die eingehende Verbindungen „abhört“ und alle Anforderungen an den richtigen Handler umleitet.  Diese Aufgabe kann problemlos von http.Server ausgeführt werden. <br><br>  Das Folgende zeigt, dass der Server für alle Aufgaben verantwortlich ist, die sich auf die Verbindungsverarbeitung beziehen.  Dies funktioniert beispielsweise mit dem TLS-Protokoll.  Zum Implementieren des Aufrufs von http.ListenAndServer wird ein Standard-HTTP-Server verwendet. <br><br>  Schauen wir uns nun komplexere Beispiele an. <br><br><h3>  Hinzufügen von Let's Encrypt </h3><br>  Standardmäßig wird unsere Anwendung über das HTTP-Protokoll ausgeführt. Es wird jedoch empfohlen, das HTTPS-Protokoll zu verwenden.  In Go ist dies problemlos möglich.  Wenn Sie ein Zertifikat und einen privaten Schlüssel erhalten haben, registrieren Sie ListenAndServeTLS einfach mit den richtigen Zertifikat- und Schlüsseldateien. <br><br><pre> <code class="go hljs">http.ListenAndServeTLS(<span class="hljs-string"><span class="hljs-string">":443"</span></span>, <span class="hljs-string"><span class="hljs-string">"cert.pem"</span></span>, <span class="hljs-string"><span class="hljs-string">"key.pem"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Sie können es immer besser machen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Let's Encrypt</a> bietet kostenlose Zertifikate mit der Möglichkeit zur automatischen Verlängerung.  Um den Dienst nutzen zu können, benötigen Sie das <code>autocert</code> Paket. <br><br>  Die einfachste Möglichkeit zur Konfiguration besteht darin, die Methode autocert.NewListener in Kombination mit http.Serve zu verwenden.  Mit dieser Methode können Sie TLS-Zertifikate empfangen und erneuern, während der HTTP-Server Anforderungen verarbeitet: <br><br><pre> <code class="go hljs">http.Serve(autocert.NewListener(<span class="hljs-string"><span class="hljs-string">"example.com"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  Wenn wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">example.com</a> im Browser öffnen, erhalten wir die HTTPS-Antwort "Hallo Welt!". <br><br>  Wenn Sie eine gründlichere Konfiguration benötigen, sollten Sie den Manager autocert.Manager verwenden.  Dann erstellen wir unsere eigene http.Server-Instanz (bis jetzt haben wir sie standardmäßig verwendet) und fügen den Manager dem TLSConfig-Server hinzu: <br><br><pre> <code class="go hljs">m := &amp;autocert.Manager{ Cache: autocert.DirCache(<span class="hljs-string"><span class="hljs-string">"golang-autocert"</span></span>), Prompt: autocert.AcceptTOS, HostPolicy: autocert.HostWhitelist(<span class="hljs-string"><span class="hljs-string">"example.org"</span></span>, <span class="hljs-string"><span class="hljs-string">"www.example.org"</span></span>), } server := &amp;http.Server{ Addr: <span class="hljs-string"><span class="hljs-string">":443"</span></span>, TLSConfig: m.TLSConfig(), } server.ListenAndServeTLS(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre> <br>  Dies ist eine einfache Möglichkeit, die vollständige HTTPS-Unterstützung mit automatischer Zertifikatserneuerung zu implementieren. <br><br><h3>  Benutzerdefinierte Routen hinzufügen </h3><br>  Der in der Standardbibliothek enthaltene Standardrouter ist gut, aber sehr einfach.  Die meisten Anwendungen erfordern ein komplexeres Routing, einschließlich verschachtelter Routen und Platzhalterrouten, oder das Verfahren zum Festlegen von Mustern und Pfadparametern. <br><br>  In diesem Fall sollten Sie die Pakete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Gorilla / Mux</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow noopener noreferrer">Go-Chi / Chi verwenden</a> .  Wir werden lernen, wie man mit letzterem arbeitet - ein Beispiel ist unten gezeigt. <br><br>  Gegeben ist die Datei api / v1 / api.go, die die Routen für unsere API enthält: <br><br><pre> <code class="go hljs">/ HelloResponse is the JSON representation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a customized message <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> HelloResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"message"`</span></span> } <span class="hljs-comment"><span class="hljs-comment">// HelloName returns a personalized JSON message func HelloName(w http.ResponseWriter, r *http.Request) { name := chi.URLParam(r, "name") response := HelloResponse{ Message: fmt.Sprintf("Hello %s!", name), } jsonResponse(w, response, http.StatusOK) } // NewRouter returns an HTTP handler that implements the routes for the API func NewRouter() http.Handler { r := chi.NewRouter() r.Get("/{name}", HelloName) return r }</span></span></code> </pre> <br>  Wir setzen das Präfix api / vq für Routen in der Hauptdatei. <br><br>  Wir können dies dann auf unserem Hauptrouter unter dem Präfix api / v1 / in unserer Hauptanwendung mounten: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// NewRouter returns a new HTTP handler that implements the main server routes func NewRouter() http.Handler { router := chi.NewRouter() router.Mount("/api/v1/", v1.NewRouter()) return router } http.Serve(autocert.NewListener("example.com"), NewRouter())</span></span></code> </pre> <br>  Die Einfachheit der Arbeit mit komplexen Routen in Go ermöglicht es, die Strukturierung durch die Bereitstellung großer komplexer Anwendungen zu vereinfachen. <br><br><h3>  Arbeiten Sie mit Middleware </h3><br>  Bei der Zwischenverarbeitung wird ein HTTP-Handler mit einem anderen umbrochen, wodurch eine schnelle Authentifizierung, Komprimierung, Aufzeichnung und einige andere Funktionen möglich sind. <br><br>  Betrachten Sie als Beispiel die Schnittstelle http.Handler, mit deren Hilfe wir einen Handler mit Authentifizierung der Benutzer des Dienstes schreiben. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RequireAuthentication</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !isAuthenticated(r) { http.Redirect(w, r, <span class="hljs-string"><span class="hljs-string">"/login"</span></span>, http.StatusTemporaryRedirect) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Assuming authentication passed, run the original handler next.ServeHTTP(w, r) }) }</span></span></code> </pre> <br>  Es gibt Router von Drittanbietern, z. B. Chi, mit denen Sie die Funktionalität der Zwischenverarbeitung erweitern können. <br><br><h3>  Arbeiten Sie mit statischen Dateien </h3><br>  Die Go-Standardbibliothek enthält Funktionen zum Arbeiten mit statischen Inhalten, einschließlich Bildern, sowie JavaScript- und CSS-Dateien.  Sie können über die Funktion http.FileServer aufgerufen werden.  Es gibt einen Handler zurück, der Dateien aus einem bestimmten Verzeichnis verteilt. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewRouter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { router := chi.NewRouter() r.Get(<span class="hljs-string"><span class="hljs-string">"/{name}"</span></span>, HelloName) <span class="hljs-comment"><span class="hljs-comment">//     staticPath, _ := filepath.Abs("../../static/") fs := http.FileServer(http.Dir(staticPath)) router.Handle("/*", fs) return r</span></span></code> </pre> <br>  Beachten Sie, dass http.Dir den Inhalt des Verzeichnisses anzeigt, wenn es nicht über die Hauptdatei index.html verfügt.  In diesem Fall lohnt es sich, das nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>unindexed</code></a> Paket zu verwenden, um zu verhindern, dass das Verzeichnis kompromittiert wird. <br><br><h3>  Richtiges Herunterfahren </h3><br>  Go hat auch eine Funktion wie das korrekte Herunterfahren des HTTP-Servers.  Dies kann mit der Shutdown () -Methode erfolgen.  Der Server startet in Goroutine und dann wird der Kanal abgehört, um ein Interrupt-Signal zu empfangen.  Sobald das Signal empfangen wird, wird der Server heruntergefahren, jedoch nicht sofort, sondern nach einigen Sekunden. <br><br><pre> <code class="go hljs">handler := server.NewRouter() srv := &amp;http.Server{ Handler: handler, } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { srv.Serve(autocert.NewListener(domains...)) }() <span class="hljs-comment"><span class="hljs-comment">// Wait for an interrupt c := make(chan os.Signal, 1) signal.Notify(c, os.Interrupt) &lt;-c // Attempt a graceful shutdown ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) defer cancel() srv.Shutdown(ctx)</span></span></code> </pre> <br><h3>  Abschließend </h3><br>  Go ist eine leistungsstarke Sprache mit einer fast universellen Standardbibliothek.  Die Standardfunktionen sind sehr umfangreich und können mithilfe von Schnittstellen verstärkt werden. Auf diese Weise können Sie wirklich zuverlässige HTTP-Server entwickeln. <br><blockquote>  <b>Skillbox empfiehlt:</b> <br><br><ul><li>  Zweijähriger Praktikumskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Ich bin ein PRO-Webentwickler</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"</a> </li><li>  Online-Bildungskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Beruf Java-Entwickler"</a> . </li><li>  Praktischer Jahreskurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"PHP-Entwickler von 0 bis PRO"</a> . <br></li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de446454/">https://habr.com/ru/post/de446454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de446440/index.html">Das Buch Reagieren Sie schnell. Webanwendungen in React, JSX, Redux und GraphQL »</a></li>
<li><a href="../de446444/index.html">Von Skype zu WebRTC: Wie wir die Webvideokommunikation organisiert haben</a></li>
<li><a href="../de446446/index.html">Grundlagen der JavaScript-Engine: Allgemeine Formulare und Inline-Caching. Teil 1</a></li>
<li><a href="../de446448/index.html">5 Grundregeln für die Durchführung von Probleminterviews zur Ermittlung der Verbraucherbedürfnisse</a></li>
<li><a href="../de446452/index.html">Mondmission "Bereshit" - 4. April 2019, der Übergang zur Mondumlaufbahn ist abgeschlossen, 7 Flugtage voraus, 6 Manöver und 1 Landung</a></li>
<li><a href="../de446456/index.html">Importsubstitution in der Praxis. Teil 1. Optionen</a></li>
<li><a href="../de446458/index.html">Universal DRO basierend auf Arduino Nano - shDRO. Teil 2</a></li>
<li><a href="../de446460/index.html">Food Design Digest März 2019</a></li>
<li><a href="../de446462/index.html">Eintauchen in den Fahrer: das allgemeine Prinzip des Rückwärtsfahrens am Beispiel der Aufgabe NeoQUEST-2019</a></li>
<li><a href="../de446464/index.html">15 Papageien: Wählen Sie einen Hosting-Anbieter für VPS / VDS-Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>