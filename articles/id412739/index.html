<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏼 😽 🔽 Anjing gembala 👩🏽‍🍳 💄 🌿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sheepdog adalah sistem scalable yang menyediakan perangkat blok terdistribusi ke mesin virtual. Pengembangannya dimulai pada tahun 2009 oleh pengemban...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Anjing gembala</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/412739/"><p><img src="https://habrastorage.org/webt/ru/g3/9i/rug39i1kkn-c4ack--isbvvzjma.jpeg"></p><br><p> <strong>Sheepdog</strong> adalah sistem scalable yang menyediakan perangkat blok terdistribusi ke mesin virtual.  Pengembangannya dimulai pada tahun 2009 oleh pengembang dari perusahaan Jepang <em>Nippon Telegraph dan Telephone Corporation</em> .  <strong>Sheepdog</strong> adalah aplikasi open source di bawah lisensi GPL2.  Versi terbaru 0.9.3, dirilis pada November 2015, akan menjadi warisan versi 1.0, cocok untuk penggunaan komersial <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a></sup> <sup><a name="cite_ref-1"></a></sup>  .  <em>(sudah menjadi - perkiraan.)</em> </p><br><blockquote>  Untuk kepentingan, versi pertama (0.1.0) dirilis oleh pengembang pada Agustus 2010 - dan pada saat yang sama, dukungan anjing gembala segera dimasukkan dalam cabang pengembangan QEMU utama. <a name="habracut"></a><br>  Tes pertama pada anjing gembala I dilakukan pada November 2011 <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2</a></sup> <sup><a name="cite_ref-2"></a></sup>  dan hasilnya bagus untuk operasi I / O.  Namun, kemudian sistem <strong>Sheepdog masih</strong> memiliki masalah dengan pemulihan node yang jatuh.  Masalah ini mungkin diselesaikan segera, karena pengembangan aplikasi cukup hidup, tetapi pada saat itu saya menggunakan solusi yang berbeda. </blockquote><br><h1 id="vozmozhnosti">  Kemungkinan </h1><br><p>  Prinsip kerja <strong>Sheepdog</strong> dijelaskan dengan sangat baik dalam presentasi yang dipublikasikan, jadi saya akan membatasi diri hanya pada tinjauan singkat. </p><br><p>  <strong>Itu scalable</strong> <br>  Volume gugus dapat secara sewenang-wenang ditingkatkan baik pada level node, meningkatkan kapasitas dan ruang untuk data selama operasi, dan dengan meningkatkan jumlah node.  Semakin banyak node, semakin tinggi kinerja VDI I / O. </p><br><p>  <strong>Dia sederhana</strong> <br>  Tidak seperti sistem lain, seperti CEPH, <strong>Sheepdog</strong> tidak bekerja secara langsung dengan sistem file tetapi beroperasi dengan blok ukuran tetap, oleh karena itu ia tidak memerlukan daemon terpisah untuk melayani metadata.  Semua kontrol dilakukan menggunakan alat <strong>anjing</strong> tunggal yang secara langsung berkomunikasi dengan <strong>domba</strong> <br>  <em>(ceph juga menggunakan objek - sekitar per.)</em> </p><br><p>  <strong>Menghitung simpul yang jatuh</strong> <br>  Setiap VDI terdiri dari blok-blok (objek) yang direplikasi secara bersamaan ke beberapa node, oleh karena itu, jika salah satu dari mereka jatuh, data tetap tersedia, dan objek dari node yang jatuh mulai mereplikasi ke node lain. </p><br><p>  <strong>Mendukung memblokir snapshot perangkat</strong> <br>  <strong>Snapshot</strong> anjing gembala bekerja sama dengan Btrfs.  Blok VDI terlampir disimpan, dan data baru ditulis ke blok baru. </p><br><p>  Fungsi-fungsi berikut mungkin bermasalah dalam kondisi tertentu: </p><br><p>  <strong>Sheepdog tidak mendukung SPOF</strong> <br>  Jika VDI digunakan sebagai perangkat blok melalui QEMU, masalah dapat muncul jika terhubung secara bersamaan di beberapa tempat.  SPOF <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3</a></sup> bisa mencegah ini. <sup><a name="cite_ref-3"></a></sup>  Anjing gembala tidak punya.  Namun, di Sheepdog versi baru, VDI dapat diblokir agar tidak memungkinkan lebih dari satu koneksi. </p><br><p>  <strong>Siklus hidup objek data</strong> <br>  Objek VDI hanya dapat dihapus ketika semua klon dan foto yang terkait dengannya dihapus.  Ini persis sama dengan untuk Btrfs.  Oleh karena itu, menghapus foto yang tidak terpakai mungkin tidak cukup untuk memberikan ruang penyimpanan. </p><br><h1 id="demon-kommunikacii">  Daemon komunikasi </h1><br><p>  Anjing gembala sangat kecil dibandingkan dengan Ceph atau GlusterFS.  Ini karena dia tidak mencoba menyelesaikan semua masalah sendiri, tetapi menggunakan secara maksimal apa yang sudah berhasil. </p><br><p>  Pada gilirannya, ia menyediakan perangkat blok yang dapat digunakan sebagai disk fisik, serta serangan perangkat lunak, dll. </p><br><p>  Itu hanya peduli tentang distribusi objek data antara node yang menjalankannya. </p><br><p>  Namun, ia membutuhkan informasi yang disediakan oleh <strong>daemon komunikasi</strong> - komponen kunci yang tanpanya <strong>Sheepdog</strong> tidak akan berfungsi. </p><br><p>  <strong>Daemon komunikasi</strong> - tidak menyediakan kemampuan untuk bertukar data antar node.  Inilah yang dilakukan setan-setan <strong>domba</strong> .  Melalui itu, <strong>domba</strong> hanya mengetahui simpul mana yang saat ini hidup. </p><br><h2 id="corosync">  corosync </h2><br><p>  Pertama-tama, <strong>Sheepdog</strong> mengasumsikan bahwa node akan berkomunikasi satu sama lain melalui <strong>corosync</strong> .  Ini mendukung hingga 64 node, meskipun secara teoritis harus dapat melayani lebih banyak, penggunaannya optimal untuk cluster kecil hingga 16 node. </p><br><p>  Biasanya, <strong>corosync</strong> juga menggunakan Pacemaker, jadi tidak perlu menginstal apa pun. </p><br><h3 id="ustanovka-corosync-na-debian">  Instal corosync di Debian </h3><br><p>  Corosync ada di repositori distribusi, dan instalasinya sederhana: </p><br><pre><code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install corosync libcoro<span class="hljs-built_in"><span class="hljs-built_in">sync-common4</span></span></code> </pre> <br><h3 id="nastroyka-corosync">  Pengaturan corosync </h3><br><h2 id="zookeeper">  penjaga kebun binatang </h2><br><p>  Pengembang <strong>Sheepdog</strong> merekomendasikan penggunaan <strong>zookeeper</strong> untuk kluster yang lebih besar.  Menurut pengembang, penyimpanan uji <strong>Sheepdog</strong> dengan 1000 node dibangun dan diuji <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4</a></sup> <sup><a name="cite_ref-4"></a></sup>  . </p><br><h3 id="ustanovka-zookeeper-na-debian">  Instal zookeeper di Debian </h3><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> apt<span class="hljs-literal"><span class="hljs-literal">-get</span></span> install zookeeper zookeeperd</code> </pre> <br><p>  Meluncurkan daemon .. </p><br><pre> <code class="hljs pgsql">$ /usr/<span class="hljs-keyword"><span class="hljs-keyword">share</span></span>/zookeeper/bin/zkServer.sh <span class="hljs-keyword"><span class="hljs-keyword">start</span></span></code> </pre> <br><p>  Port default yang dijalankan zookeeper adalah 2181 </p><br><p>  Menjalankan anjing gembala dengan dukungan zookeeper: </p><br><pre> <code class="hljs powershell"><span class="hljs-variable"><span class="hljs-variable">$</span></span> sheep <span class="hljs-literal"><span class="hljs-literal">-c</span></span> zookeeper:IP1:PORT1,IP2:PORT2,IP3:PORT3 ...other...option...</code> </pre> <br><p>  Bonus <strong>zookeeper</strong> adalah bahwa dalam kasusnya, <strong>Sheepdog</strong> memiliki konfigurasi node yang lebih jelas dan lebih mudah, tetapi ada masalah bahwa paket instalasi Debian tidak termasuk dukungannya. </p><br><p>  Karenanya, untuk mendapatkan Sheepdog dengan dukungan zookeeper, Anda harus mengompilasinya dari kode sumber.  Meskipun saya tidak dapat mengesampingkan bahwa situasinya mungkin berbeda saat ini. <br>  <em>(Dukungan penjaga kebun binatang masih membutuhkan kompilasi dari sumber - sekitar.)</em> </p><br><h1 id="nastroyka-demona-sheep">  Menyiapkan daemon domba </h1><br><p>  Node menjadi bagian dari Anjing Gembala ketika manajer objek, daemon <strong>domba</strong> , dimulai.  Itu selalu berfungsi dalam dua salinan: </p><br><ol><li><p>  Contoh pertama proses dimulai sebagai gateway, yang menerima permintaan I / O dari klien (misalnya, dari driver perangkat blok QEMU), menghitung node target dan mengirimkan permintaan untuk diproses lebih lanjut di antara mereka.  Artinya, ia membangun banyak koneksi jaringan. </p><br></li><li>  Lain berfungsi sebagai manajer objek lokal ( <strong>Manajer Objek</strong> ) </li></ol><br><p>  Parameter konfigurasi daemon domba dapat diteruskan sebagai argumen baris perintah saat runtime.  Jika tidak ada, nilai default akan digunakan, dan Anda harus berhati-hati: </p><br><p>  <strong>Nomor port</strong> <br>  Kecuali ditentukan lain, daemon domba berjalan pada port 7000 </p><br><p>  <strong>Jalur brankas</strong> <br>  Kecuali ditentukan lain, direktori shep menggunakan direktori / var / lib / sheepdog, dan objek VDI disimpan dalam subdirektori <code>obj</code> . </p><br><blockquote>  Secara teoritis, tidak ada yang mencegah beberapa contoh <strong>domba</strong> bekerja pada satu simpul - syarat utamanya adalah setiap orang menggunakan nomor port dan penyimpanan mereka sendiri.  Masalah alamat IP dari simpul hampir terselesaikan.  Setiap instance daemon <strong>domba yang</strong> berjalan pada port yang berbeda akan secara otomatis terhubung ke cluster yang ada! <br><br>  Informasi penting adalah bahwa nomor port adalah bagian dari konfigurasi wadah VDI.  Anda perlu tahu apakah Anda ingin mengkonfigurasi ulang daemon <strong>domba</strong> untuk dijalankan di port lain dari cluster yang ada. <br><br>  Oleh karena itu, jika Anda menjalankan instance daemon <strong>domba</strong> dengan nomor port yang berbeda, tetapi dengan jalur yang sama ke toko objek, Anda dapat kehilangan informasi dalam wadah VDI yang ada. </blockquote><br><h1 id="demon-sheep-kak-shlyuz">  Iblis domba sebagai pintu gerbang </h1><br><p>  Pada mesin yang tidak memiliki ruang penyimpanan untuk objek VDI, daemon <strong>domba</strong> dapat dijalankan secara eksklusif dalam mode gateway, dengan flag <code>-G</code> . </p><br><p>  Dalam hal ini, ketika mendistribusikan objek VDI, penyimpanan lokal tidak akan digunakan sama sekali, dan data akan didistribusikan secara langsung ke node lain. </p><br><h1 id="demon-sheep-kak-menedzher-obektov">  Domba iblis sebagai manajer objek </h1><br><p>  Instance berjalan kedua, bertindak sebagai manajer objek lokal, menerima permintaan I / O dari instance yang dimulai sebagai gateway, dan melakukan operasi r / w di penyimpanan objek lokal ( <strong>Object storage</strong> ) </p><br><h2 id="hranilische-obektov">  Penyimpanan objek </h2><br><p>  Secara default, penyimpanan untuk objek VDI di <strong>Sheepdog</strong> adalah direktori <code>/var/lib/sheepdog/obj</code> , yang juga digunakan oleh daemon <strong>domba</strong> sebagai bagian dari struktur direktori internal - ini adalah jalur penyimpanan default. </p><br><p>  Jika Anda ingin objek VDI disimpan di tempat lain, Anda bisa melewati jalur tempat perangkat blok lain dipasang sebagai parameter saat startup. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sheep</span></span> ... /cesta_do_přípojného_bodu</code> </pre> <br><p>  Bahkan ada lebih banyak cara untuk disampaikan.  Versi baru <strong>Sheepdog</strong> mendukung apa yang disebut teknologi multi-perangkat, yang memungkinkan Anda untuk secara dinamis meningkatkan kapasitas memori, jika perlu, tanpa harus me-restart <strong>Sheepdog</strong> .  Meningkatkan kapasitas penyimpanan bekerja mirip dengan Btrfs. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">sheep</span></span> ... /cesta_do_A,/cesta_do_B,/cesta_do_C</code> </pre> <br><p>  <em>(direktori pertama yang ditentukan hanya akan digunakan untuk metadata - approx.per)</em> </p><br><p>  Penyimpanan tambahan juga dapat ditambahkan (atau dihapus) melalui <strong>dog node md</strong> </p><br><p>  ... </p><br><p>  Fungsi yang ditawarkan oleh multi-perangkat sangat berguna ketika sistem file penyimpanan tidak mendukung "desain" ini (tidak seperti Btrfs atau ZFS).  Secara umum, pilihan sistem file untuk menyimpan objek, properti, parameter, dan pengaturannya dapat secara signifikan mempengaruhi kinerja sistem file IO mesin virtual. </p><br><blockquote>  Teknologi multi-perangkat memerlukan atribut canggih di sisi file, yang bukan masalah bagi sistem file modern seperti btrfs <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5</a></sup> <sup><a name="cite_ref-5"></a></sup>  atau ext4.  Tetapi beberapa sistem file lama seperti reiserfs atau ext2 <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">6</a></sup> <sup><a name="cite_ref-6"></a></sup>  Jangan mendukung mereka. <br><br>  Jika Anda ingin menggunakan sistem file yang tidak mendukung atribut yang diperluas untuk menyimpan objek, kita perlu mengkompilasi <strong>Sheepdog</strong> tanpa dukungan multi-perangkat. </blockquote><br><h2 id="tip-hranilischa---plain-versus-tree">  Jenis Penyimpanan - polos versus pohon </h2><br><p>  Saat memformat sebuah cluster, di antara opsi lain, Anda dapat menentukan jenis penyimpanan (penyimpanan backend).  Anda dapat mengatur jenis ke <strong>dataran</strong> atau <strong>pohon</strong> .  Untuk tipe <strong>biasa</strong> , struktur direktori akan terlihat seperti ini: </p><br><pre> <code class="hljs ruby"><span class="hljs-params"><span class="hljs-params">| |</span></span>- obj <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt;id &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|-&lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>-&lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|-&lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>- ... <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt;id  &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> ... <span class="hljs-params"><span class="hljs-params">|- config [] |</span></span>- epoch <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span>- ... <span class="hljs-params"><span class="hljs-params">|- journal \- sheep.log []</span></span></code> </pre> <br><p>  Semua objek VDI dalam direktori <code>obj</code> akan dikirim ke subdirektori yang namanya didasarkan pada pengidentifikasi era saat ini.  Artinya, untuk setiap era, objek VDI yang sesuai akan disimpan secara terpisah.  Namun, selama satu era, sejumlah besar objek VDI dapat muncul di direktori, yang selanjutnya memperlambat akses ke file.  Oleh karena itu, Anda dapat memilih opsi kedua, yaitu <strong>pohon</strong> : </p><br><pre> <code class="hljs ruby"><span class="hljs-params"><span class="hljs-params">|- obj |</span></span> <span class="hljs-params"><span class="hljs-params">|- aa |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>-&lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|-&lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>-&lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|- ... |</span></span> <span class="hljs-params"><span class="hljs-params">|- ab |</span></span> <span class="hljs-params"><span class="hljs-params">| ... |</span></span> <span class="hljs-params"><span class="hljs-params">|- meta |</span></span> <span class="hljs-params"><span class="hljs-params">| |</span></span>- &lt; &gt; <span class="hljs-params"><span class="hljs-params">| |</span></span> <span class="hljs-params"><span class="hljs-params">|- ... |</span></span> <span class="hljs-params"><span class="hljs-params">|- 0a |</span></span> <span class="hljs-params"><span class="hljs-params">| ... |</span></span>- config [] <span class="hljs-params"><span class="hljs-params">|- epoch |</span></span> <span class="hljs-params"><span class="hljs-params">|- &lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">|- &lt; &gt; |</span></span> <span class="hljs-params"><span class="hljs-params">|- ... \- sheep.log []</span></span></code> </pre> <br><p>  Dalam jenis penyimpanan ini, daemon <strong>domba</strong> membuat satu set 256 subdirektori dengan nama <code>0a, ..., 99</code> di direktori <code>obj</code> , dan kemudian menghamburkan objek berdasarkan dua karakter terakhir dari <strong>id VDI</strong> , yang unik tidak hanya untuk setiap wadah VDI tetapi juga snapshots atau klon. </p><br><h2 id="imena-vdi-obektov">  Nama objek VDI </h2><br><p>  Ketika <strong>Sheepdog</strong> menyimpan data dalam wadah VDI, file akan mulai muncul di penyimpanan data <code>obj</code> , masing-masing akan memiliki nama sendiri yang terdiri dari beberapa elemen: </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^</code> </pre> <br><p>  Dua karakter pertama menunjukkan jenis objek.  Objek data dimulai dengan <code>00...</code> dan metadata (yang dapat disimpan di direktori lain) <code>80...</code> </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^^^^^</code> </pre> <br><p>  Lalu datanglah VDI.  Ini unik tidak hanya untuk setiap wadah, tetapi juga untuk snapshot atau klonnya. </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^ ^^</code> </pre> <br><p>  Dua digit terakhir dari pengidentifikasi VDI menunjukkan - dalam kasus <strong>jenis</strong> penyimpanan <strong>pohon</strong> - di mana subdirektori tempat objek berada. </p><br><pre> <code class="hljs go">../obj/<span class="hljs-number"><span class="hljs-number">8f</span></span>/<span class="hljs-number"><span class="hljs-number">00e8</span></span>b18f00000005 ^^^^^^^^</code> </pre> <br><p>  Dan pengidentifikasi wadah VDI dalam heksadesimal diikuti oleh nomor seri objek dalam wadah VDI </p><br><h2 id="epoha">  Era </h2><br><p>  Subdirektori <code>epoch</code> berisi daftar biner dari objek-objek yang dimiliki oleh era tersebut.  Jumlah zaman meningkat, setiap kali setiap cluster berubah - ketika sebuah node ditambahkan atau dihapus.  Setiap perubahan tersebut memulai proses <strong>pemulihan</strong> , di mana keadaan saat ini objek lokal akan diperiksa pada node, diikuti oleh peningkatan era. </p><br><h1 id="kak-optimalno-vybrat-hranilische-vdi-obektov">  Bagaimana memilih penyimpanan objek VDI yang optimal </h1><br><p>  Kapasitas penyimpanan yang tersedia dihitung berdasarkan ruang kosong pada node.  Ruang yang dipilih oleh <strong>domba</strong> selalu tergantung pada seberapa banyak ruang yang tersedia di perangkat blok tempat objek VDI disimpan. </p><br><p>  Ukuran wadah VDI hanyalah bentuk virtual yang sama sekali tidak terkait dengan berapa banyak ruang yang ditempati objek VDI.  Penting untuk mengetahui bagaimana Sheepdog memproses data dalam sebuah cluster: </p><br><blockquote>  Sheepdog selalu mencoba untuk menyimpan data secara merata di antara semua mesin pada zaman itu. </blockquote><p>  Ini berarti bahwa jika salah satu node jatuh, era berubah dan <strong>Sheepdog</strong> segera memulai proses pemulihan, itu akan membuat objek VDI yang hilang pada node yang tersisa untuk mengkompensasi kerugian. </p><br><p>  Situasi serupa akan muncul ketika menambahkan node baru.  <strong>Sheepdog</strong> akan mulai memindahkan objek VDI dari node baru ke repositori secara merata, sehingga persentase pengisian ruang data pada node akan seimbang mungkin.  Gunakan perintah berikut untuk mendapatkan gambaran umum global tentang berapa banyak ruang yang saat ini digunakan pada node Anda: </p><br><pre> <code class="hljs pgsql">nod1 ~ # collie node md <span class="hljs-keyword"><span class="hljs-keyword">info</span></span> -A Id Size Used Avail Use% <span class="hljs-type"><span class="hljs-type">Path</span></span> Node <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.1</span></span> TB <span class="hljs-number"><span class="hljs-number">391</span></span> GB <span class="hljs-number"><span class="hljs-number">720</span></span> GB <span class="hljs-number"><span class="hljs-number">35</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">702</span></span> GB <span class="hljs-number"><span class="hljs-number">394</span></span> GB <span class="hljs-number"><span class="hljs-number">307</span></span> GB <span class="hljs-number"><span class="hljs-number">56</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">794</span></span> GB <span class="hljs-number"><span class="hljs-number">430</span></span> GB <span class="hljs-number"><span class="hljs-number">364</span></span> GB <span class="hljs-number"><span class="hljs-number">54</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">3</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.6</span></span> TB <span class="hljs-number"><span class="hljs-number">376</span></span> GB <span class="hljs-number"><span class="hljs-number">1.2</span></span> TB <span class="hljs-number"><span class="hljs-number">22</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">4</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.2</span></span> TB <span class="hljs-number"><span class="hljs-number">401</span></span> GB <span class="hljs-number"><span class="hljs-number">838</span></span> GB <span class="hljs-number"><span class="hljs-number">32</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">5</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.5</span></span> TB <span class="hljs-number"><span class="hljs-number">370</span></span> GB <span class="hljs-number"><span class="hljs-number">1.1</span></span> TB <span class="hljs-number"><span class="hljs-number">24</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj Node <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1.6</span></span> TB <span class="hljs-number"><span class="hljs-number">388</span></span> GB <span class="hljs-number"><span class="hljs-number">1.2</span></span> TB <span class="hljs-number"><span class="hljs-number">23</span></span>% /<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/sheepdog-data/obj</code> </pre> <br><h2 id="proizvoditelnost-io">  Kinerja I / O </h2><br><p>  Penting untuk dikatakan di sini bahwa <strong>Sheepdog</strong> bekerja secara berbeda dari Ceph, dan memiliki prioritas yang berbeda. </p><br><p>  Untuk Ceph, "bobot" perangkat OSD sangat penting ketika menempatkan objek data, serta kinerja perangkat blok, konektivitas host, dan kecepatan respons.  <em>(sebenarnya tidak - kira-kira)</em> </p><br><p>  Apakah Sheepdog melakukan sesuatu seperti ini, saya tidak tahu.  Mungkin  Data untuknya lebih dulu.  Kinerja dalam hal operasi I / O adalah sekunder.  Tentu saja, dengan node yang lebih kuat, kinerja I / O-nya dapat meningkat, tetapi selalu tergantung pada struktur spesifik.  <em>(Namun, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes</a> menunjukkan kinerja anjing gembala yang lebih baik dibandingkan dengan ceph - approx.per)</em> </p><br><blockquote>  Saya menambahkan node baru ke Sheepdog dengan data yang disimpan pada disk SATA II 2TB yang berputar.  Kecepatan tulis maksimum untuk disk ini adalah sekitar 80M / s.  Bahkan, ini sangat bervariasi karena drive SATA tidak dapat membaca dan menulis pada saat yang sama. <br><br>  Awalnya, kecepatan tulis rata-rata pada VDI pada disk ini adalah sekitar 20 ~ 30M / s, karena selain data dari VDI, 392G data kontainer direplikasi sebagai bagian dari proses pemulihan.  Ini berlangsung selama 6,5 ​​jam.  Kecepatan tulis berkisar antara 40 ~ 55M / s. <br><br>  Jelas, dalam hal ini, kecepatan penulisan dibatasi oleh kinerja I / O dari perangkat blok lokal. </blockquote><p>  Untuk Sheepdog, aturan berikut ini berlaku: "Semakin banyak objek VDI yang ada pada node dengan koneksi cepat, semakin baik kinerja operasi I / O." </p><br><p>  Karena fakta bahwa memindahkan objek VDI di latar belakang berarti bahwa "kematian cepat sebuah node" akan memperlambat replikasi objek data yang memakan banyak ruang, ini akan memanifestasikan dirinya sebagai penurunan kinerja operasi I / O wadah VDI. </p><br><h2 id="zanimaemoe-prostranstvo">  Ruang yang ditempati </h2><br><p>  Saat menempatkan objek data, jumlah ruang kosong sangat penting untuk daemon <strong>domba</strong> .  Mekanismenya tampak sederhana.  Daemon <strong>domba</strong> , yang dengannya data dikomunikasikan dengan wadah VDI, dari waktu ke waktu menentukan pemanfaatan ruang yang bebas dan ditempati pada node, yang menyortirnya.  Kemudian data didistribusikan di antara node dengan tingkat pemanfaatan terendah. </p><br><p>  Jika ada jalur tulis yang paling cepat, operasi penulisan ke wadah VDI juga akan cepat.  Karena semakin cepat operasi I / O dari wadah VDI dilakukan, semakin cepat daemon <strong>domba</strong> dapat melanjutkan ke operasi berikutnya. </p><br><p>  Yang penting adalah bahwa dengan Sheepdog tidak akan ada situasi ketika salah satu node benar-benar penuh.  Jika tingkat pemanfaatan pada node menjadi jauh lebih buruk, maka daemon domba mulai memindahkan objek datanya ke lokasi lain. </p><br><p>  Sheepdog bekerja seperti halnya Btrfs - hanya menggunakan ruang yang benar-benar ditempati.  Dengan demikian, Anda dapat membuat wadah VDI virtual dengan kapasitas 1 TB, yang sebenarnya akan memakan ruang sebanyak data yang disimpan di dalamnya.  Dari sudut pandang ini, diinginkan untuk menggunakan format seperti disk virtual dan sistem file dalam wadah VDI sehingga dapat dibersihkan satu sama lain. </p><br><h1 id="zapusk-klastera">  Peluncuran cluster </h1><br><blockquote>  Sementara semua node dapat dihentikan pada saat yang sama, node tidak dapat dimulai sekaligus !!!  Node harus dihubungkan secara bertahap.  Dimulai dengan node yang pertama kali ditentukan dalam daftar node. <br>  <em>(Ini adalah pernyataan yang sangat aneh - kira-kira)</em> </blockquote><br><h1 id="vdi">  Vdi </h1><br><p>  Ini adalah singkatan umum dalam <strong>Sheepdog</strong> untuk disk virtual, bukan format spesifiknya <sup><a name="cite_ref-7"></a></sup>  .  Secara umum, ini adalah kotak virtual dengan kompartemen ukuran tetap di mana <strong>Sheepdog</strong> kemudian menempatkan data yang ditransmisikan klien. </p><br><h1 id="sozdanie-vdi">  Membuat VDI </h1><br><p>  Sebelum kita membuat atau mengimpor VDI pertama, kita perlu memformat cluster.  Saat memformat sebuah cluster, parameter ditetapkan yang kemudian akan digunakan secara default saat membuat setiap VDI berikutnya. </p><br><p>  Contoh yang menunjukkan pembuatan VDI baru bernama Disk1 dan ukuran 1 GB </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi create disk1 1G root</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@nod</span></span></span><span class="hljs-comment">1 :~# collie vdi list Name Id Size Used Shared Creation time VDI id Copies Tag Block Size Shift disk1 0 1.0 GB 0.0 MB 0.0 MB 2015-12-04 14:07 e8b18f 2 22</span></span></code> </pre> <br><p>  <strong>Id</strong> <br>  Pengidentifikasi VDI </p><br><p>  <strong>Ukuran</strong> <br>  Ukuran VDI yang belum tentu akan segera dialokasikan sebelumnya. <br>  Jika VDI ini dalam format inkremental (qcow2 dan sejenisnya) yang dibuat menggunakan <code>qemu-img convert</code> , itu tidak akan cocok dengan ukuran disk virtual, tetapi akan terus tumbuh. </p><br><p>  <strong>Digunakan</strong> <br>  Informasi tentang berapa banyak ruang yang ditempati objek data VDI. <br>  VDI, yang tidak memerlukan alokasi objek data selama pembuatan, akan menempati apa-apa, karena objek data belum dibuat untuk itu. </p><br><p>  <strong>Dibagikan</strong> <br>  Volume objek data yang dibagikan oleh VDI lain </p><br><p>  <strong>Waktu pembuatan</strong> <br>  Waktu pembuatan VDI </p><br><p>  <strong>Ukuran blok</strong> <br>  Ukuran objek VDI.  Perhatian!  Ini tidak ditentukan dalam MB, tetapi sebagai kekuatan dua byte.  Dalam versi yang lebih lama, hanya 4 MB objek ukuran tetap yang digunakan.  Saat ini, VDI mungkin memiliki objek yang lebih besar.  Ukuran optimal untuk objek VDI dari mesin virtual biasa terlihat seperti 64MB (26).  Ukuran standar 22 (4 MB) juga minimal.  Kurang tidak bisa dipasang.  Semakin kecil ukuran objek, semakin besar jumlah file yang harus diproses <strong>Sheepdog saat</strong> bekerja dengan VDI, dan bekerja dengan file bukanlah masalah yang murah dari sudut pandang IO.  Sejumlah besar file, terutama dengan pengontrol SATA lambat, dapat menyebabkan penurunan tajam dalam kecepatan baca dan tulis.  Ukuran maksimum objek yang dapat digunakan adalah 31 (2 GB).  Ini dapat bermanfaat jika VDI secara konsisten menyimpan sejumlah besar data statis, seperti cadangan. </p><br><p>  <strong>Vdi id</strong> <br>  Pengidentifikasi VDI. </p><br><h2 id="chto-soderzhit-vdi">  Apa isi VDI? </h2><br><p>  Konten VDI adalah data.  Ini adalah perangkat blok terdistribusi, jadi <strong>Sheepdog</strong> tidak menyelesaikan data atau sampah ini.  Dari sudut pandang ini, VDI terlihat seperti volume logis LVM.  VDI pra-populasi sesuai dengan partisi LV klasik dengan rentang khusus, sedangkan VDI menyerupai partisi LV tipis yang dibuat dalam kumpulan (lihat LVM (thin_provisioning)), tetapi dengan perbedaan bahwa data yang diperluas (objek) tidak disimpan secara lokal memblokir perangkat, dan tersebar di antara node. </p><br><blockquote>  Format VDI berfungsi dalam analogi ini sebagai sistem file.  Beberapa menempati luasan yang dilindungi (objek) secara berurutan, yang lain memetakannya sebagai inode mereka, dan kemudian mengirim data secara langsung kepada mereka.  Kombinasi yang salah dari sistem file penyimpanan node, format VDI, dan sistem file internal dapat menyebabkan penurunan kinerja I / O yang signifikan. </blockquote><br><h2 id="kak-poluchit-informaciyu-o-vdi">  Cara mendapatkan informasi tentang VDI </h2><br><p>  Untuk mempelajari lebih lanjut tentang format VDI, Anda dapat menggunakan <strong>info qemu-img</strong> : </p><br><pre> <code class="hljs mel">root@nod1 :~# qemu-img info sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:disk1 <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:test2 <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>: qcow2 virtual <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">12</span></span>G (<span class="hljs-number"><span class="hljs-number">12884901888</span></span> bytes) disk <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">4.0</span></span>G cluster_size: <span class="hljs-number"><span class="hljs-number">65536</span></span> Format specific information: compat: <span class="hljs-number"><span class="hljs-number">1.1</span></span> lazy refcounts: false refcount bits: <span class="hljs-number"><span class="hljs-number">16</span></span> corrupt: false</code> </pre> <br><p>  Dari output perintah, Anda dapat mengetahui bahwa disk1 memiliki ukuran nominal 12G.  Saat ini hanya membutuhkan 4G.  Karena ini dalam format qcow2, jelas bahwa itu dibuat sebagai tambahan. </p><br><pre> <code class="hljs mel">root@nod1 :~# collie vdi list Name Id Size Used Shared Creation time VDI id Copies Tag Block Size Shift disk2 <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">4.0</span></span> GB <span class="hljs-number"><span class="hljs-number">4.0</span></span> GB <span class="hljs-number"><span class="hljs-number">0.0</span></span> MB <span class="hljs-number"><span class="hljs-number">2015</span></span><span class="hljs-number"><span class="hljs-number">-12</span></span><span class="hljs-number"><span class="hljs-number">-04</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>:<span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">825</span></span>dc1 <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span> root@nod1 :~# qemu-img info sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:disk2 <span class="hljs-keyword"><span class="hljs-keyword">image</span></span>: sheepdog:localhost:<span class="hljs-number"><span class="hljs-number">8000</span></span>:disk2 <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">format</span></span>: raw virtual <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">4.0</span></span>G (<span class="hljs-number"><span class="hljs-number">4294967296</span></span> bytes) disk <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>: <span class="hljs-number"><span class="hljs-number">4.0</span></span>G root@nod1 :~# find /datastore/obj/ | grep <span class="hljs-number"><span class="hljs-number">825</span></span>dc1 /datastore/obj/meta/<span class="hljs-number"><span class="hljs-number">80825</span></span>dc100000000 /datastore/obj/c1/<span class="hljs-number"><span class="hljs-number">00825</span></span>dc100000000 /datastore/obj/c1/<span class="hljs-number"><span class="hljs-number">00825</span></span>dc100000001</code> </pre> <br><p>  Dalam hal ini, Disk2 dibuat sebagai VDI 4 GB yang dialokasikan sebelumnya dalam format mentah dengan ukuran blok 2 GB, yang sebenarnya hanya membutuhkan dua 2 GB </p><br><h2 id="eksport-vdi-v-fayl">  Ekspor VDI ke file </h2><br><p>  Konten VDI dapat diekspor dari <strong>Sheepdog dalam</strong> beberapa cara.  Mungkin yang tercepat menggunakan <strong>membaca anjing</strong> .  Perintah ini agak membingungkan, tetapi hanya berarti: "Muat konten VDI dan kirimkan ke STDOUT ..", yang dapat diarahkan ke file: </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi read disk1 &gt; /backups/soubor.raw</span></span></code> </pre> <br><p>  Jika VDI memiliki 10G tetapi hanya 2G yang digunakan, itu akan membuat file dengan kapasitas penuh 10 GB. </p><br><p>  <strong>Dalam perintah ini, konten VDI tidak berubah</strong> , jadi jika konten VDI, misalnya, disk virtual dalam format qcow2 terkompresi, dapat digunakan secara langsung </p><br><pre> <code class="hljs mel">.. -drive <span class="hljs-keyword"><span class="hljs-keyword">file</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">file</span></span>:/disk1_exportovany_z_vdi,..,<span class="hljs-keyword"><span class="hljs-keyword">format</span></span>=qcow2 ..</code> </pre> <br><p>  Cara lain untuk mendapatkan konten VDI ke dalam file adalah dengan menggunakan <strong>qemu-img convert</strong> .  Ini tidak begitu cepat, tetapi memungkinkan Anda untuk mengubah VDI ke format lain menggunakan opsi berbeda dari format disk virtual yang sesuai. </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># qemu-img convert -f qcow2 -O file -o preallocation=full,nocow=on sheepdog:localhost:8000:disk1 /disk1_exportovany_z_vdi</span></span></code> </pre> <br><h2 id="inkrementnoe-rezervnoe-kopirovanie">  Cadangan tambahan </h2><br><p>  Buat cadangan tambahan </p><br><p>  Delta antara foto pertama dan kedua .. </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi backup test -F snap1 -s snap2 /backups/soubor_diff</span></span></code> </pre> <br><p>  Pulihkan VDI dari cadangan inkremental </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi restore test -s snap1 /tmp/backup restoring /tmp/backup... done</span></span></code> </pre> <br><p>  Saat mengimpor cadangan tambahan, VDI tentu saja harus memiliki snapshot dari mana cadangan dibuat. </p><br><p>  Verifikasi dengan membaca konten asli dari tes gambar ... </p><br><pre> <code class="hljs ruby"> root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi read test 0 512 -s 3</span></span></code> </pre> <br><h1 id="import-vdi-iz-fayla">  Impor VDI dari file </h1><br><p>  Mengimpor disk virtual yang ada sebagai file FS lokal dapat dilakukan dengan cara yang sama dengan ekspor.  Tetapi dengan perbedaan yang <strong>digunakan penulisan anjing</strong> ("Membaca data dari STDIN dan menulis ke file VDI ..") </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi write disk1 &lt; /backups/soubor.raw</span></span></code> </pre> <br><p></p><br><blockquote><ul><li>  Konten hanya dapat diimpor ke VDI yang ada. </li><li>  VDI yang diimpor selalu membutuhkan lebih banyak ruang daripada file asli, karena blok data tempat VDI dipulihkan berisi data pada area yang ditandai. </li></ul><br></blockquote><p>  Jika VDI belum ada dan kami tidak tahu berapa banyak ruang yang dibutuhkan untuk disk virtual, kami dapat menggunakan <strong>qemu-img convert</strong> </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># qemu-img convert -f file -O qcow2 -o redundancy=2:1 ./disk_ukladany_do_vdi sheepdog:localhost:8000:disk</span></span></code> </pre> <br><blockquote>  Meskipun format VDI seperti qcow2, qed dan lainnya dapat digunakan dalam VDI.  Untuk efisiensi I / O, lebih baik melakukan pra-alokasi blok data. <br>     ,        <strong>Sheepdog</strong>     VDI. </blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.sheepdog-project.org/doc/vdi_read_and_write.html</a> </p><br><h1 id="proverka-vdi">  VDI </h1><br><p>    VDI ,      . </p><br><pre> <code class="hljs ruby">root@nod1 <span class="hljs-symbol"><span class="hljs-symbol">:~</span></span><span class="hljs-comment"><span class="hljs-comment"># collie vdi check disk1</span></span></code> </pre> <br><blockquote>    VDI,     .    Sheepdog    ,      .     ,            . </blockquote><p> :   'dog node kill'     ,         ethernet ,   sheep    .          (,    Ethernet),         sheep .               . </p><br><h2 id="io-proizvoditelnost-vdi"> IO  VDI </h2><br><p>  VDI    .          .       ,   IO   VDI. </p><br><p>   <strong>Sheepdog</strong>    SYNC,    .   -,     VFS,   ,       ,       . </p><br><p>       VDI  <strong>Sheepdog</strong>    ,            .              .  <strong>Sheepdog</strong>        VDI-. </p><br><h2 id="ispolzovanie-vfs-kesha-nody">  VFS-  </h2><br><p>      IO  VDI      <strong>sheep</strong>   <strong>-n</strong> .    SYNC         ,   ,        VFS .     ,   VFS  ,   ,      ! </p><br><p>         .            ,          — , ,    . </p><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">sheep</span></span> -n ...</code> </pre> <br><blockquote>   <strong>Sheepdog</strong>      .      <strong>-D</strong> </blockquote><br><h1 id="obektnyy-kesh">   </h1><br><p>     -   .   <strong>sheep</strong>           -   IO —  SSD .  ,   VDI,       SYNC   .             . </p><br><p>       ,   VDI     ,         VDI   . ,     ,     ,      VDI. </p><br><pre> <code class="hljs dos">sheep -w size=<span class="hljs-number"><span class="hljs-number">20000</span></span>,directio,<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span>=/<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> ...</code> </pre> <br><p> <strong>size</strong> <br>   </p><br><p> <strong>directio</strong> <br>     <strong>sheep</strong>      ,      .      SSD. </p><br><p> <strong>dir</strong> </p><br><pre> <code class="hljs erlang">     ,     .</code> </pre> <br><p>       ( )   <strong>dog</strong> . </p><br><blockquote>        VDI          <strong>dog vd cashe flush</strong> ,     VDI! </blockquote><br><h2 id="zhurnal">  </h2><br><p>   —  .           VDI,     VFS   ,           (/store_dir/journal/[epoch]/[vdi_object_id]),     ,    . </p><br><p>   IO   ,        (cik, cak),   (sequence). </p><br><p>  , <strong>Sheepdog</strong>        VDI ,           ,  SSD-.     ,       VDI    ,           ,                VDI. </p><br><p>        <strong>sheep</strong>      —         </p><br><pre> <code class="hljs matlab">$ sheep -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> <span class="hljs-built_in"><span class="hljs-built_in">size</span></span>=<span class="hljs-number"><span class="hljs-number">256</span></span>M ...</code> </pre> <br><p>       ,  VDI      ,    .        -,   —   —         -: </p><br><pre> <code class="hljs matlab">$ sheep -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> dir=/dir,<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>=<span class="hljs-number"><span class="hljs-number">256</span></span>M ...</code> </pre> <br><p>  dir =      ,          .       ,     SW RAID     SSD. </p><br><p> <strong>:</strong>    <strong>sheep</strong>     ,    .     ,      skip,   . </p><br><pre> <code class="hljs matlab">$ sheep -<span class="hljs-built_in"><span class="hljs-built_in">j</span></span> dir=/dir,<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>=<span class="hljs-number"><span class="hljs-number">256</span></span>M,skip ...</code> </pre> <br><hr><br><ol><li> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> <a name="cite_note-1"></a> .       2015 . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://events.linuxfoundation.jp/sites/events/files/slides/COJ2015_Sheepdog_20150604.pdf</a></sup> </li><li> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> <a name="cite_note-2"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.abclinuxu.cz/blog/kenyho_stesky/2011/11/sheepdog-hrajeme-si-v-hampejzu</a></sup> </li><li> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> <a name="cite_note-3"></a> SPOF ( <strong>S</strong> ingle <strong>p</strong> oint <strong>o</strong> f <strong>f</strong> ailure) ,             .  SPOF   VDI   iSCSI  <strong>tgtd</strong></sup> </li><li> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> <a name="cite_note-4"></a></sup>  <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1</a></sup> </li><li><p> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> <a name="cite_note-5"></a> Btrfs —    COW,       ,        .   ,      -,      .      ,     ,              .      ,         ,   .  ,     :</sup> </p><br><p> <sup>autodefrag —     ,          .</sup> </p><br><p> <sup>      </sup> </p><br><p> <sup>nocow —           (),      —           GlusterFS</sup> </p><br><p> <sup> Btrfs   ,     ,     FS,       <strong>Sheepdog</strong> .</sup> </p><br><ul><li> <sup>    ,   ,    ,      </sup> </li><li> <sup>  multipath,                         .</sup> </li></ul><br><p> <sup>,  ,        ,        Sheepdog.</sup> </p><br></li><li><p> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> <a name="cite_note-6"></a> <strong>Ext2</strong> .     -  FS  Btrfs,    ext2,     inode.    ext3  ext4     .   inode , Sheepdog          . ,      -,   .           ,   <strong>Sheepdog</strong>      ,         <strong>dog vdi check</strong> . ,  ext2  ,            —    -     <strong>dog vdi md</strong> ,       VDI     .</sup> </p><br></li><li> <sup><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">↑</a> <a name="cite_note-7"></a>    ,   , <strong>vdi</strong>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">QEMU_Block_Disk</a></sup> </li></ol><br><h1 id="ssylki">  Referensi </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/collie/sheepdog/wiki</a> — ,        <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.osrg.net/sheepdog/</a> —    Nippon Telegraph and Telephone Corporation <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.sheepdog-project.org/doc/index.html</a> —   Sheepdog   0.8.0;  — Valerio Pachera <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">http://www.admin-magazine.com/Archive/2014/23/Distributed-storage-with-Sheepdog</a> —  Udo Seidela   <strong>Sheepdog</strong> ,   23-   Admin   2014  </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412739/">https://habr.com/ru/post/id412739/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412725/index.html">Cara membuat infrastruktur TI Anda membosankan</a></li>
<li><a href="../id412727/index.html">Bagaimana memilih alat untuk membuat prototipe pada tahun 2018?</a></li>
<li><a href="../id412729/index.html">GDPR. Apakah perlu untuk melakukannya di Rusia?</a></li>
<li><a href="../id412735/index.html">Tinggalkan kontes ATM Alone pada PHDays 8</a></li>
<li><a href="../id412737/index.html">Perlindungan data pribadi 3 miliar orang - persamaan dan perbedaan dalam undang-undang di negara-negara BRICS</a></li>
<li><a href="../id412741/index.html">Bagaimana berhenti takut bahwa kecerdasan buatan akan meninggalkan Anda tanpa kerja</a></li>
<li><a href="../id412743/index.html">Profesi: Detektif Cyber</a></li>
<li><a href="../id412747/index.html">MIS. Penyimpanan data medis</a></li>
<li><a href="../id412749/index.html">Elektronik sebagai Seni: Arus Listrik</a></li>
<li><a href="../id412751/index.html">Kebotakan: Teori dan praktik pengobatan, bagian 1 "Dihydrotestosterone saya, musuh saya"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>