<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§© üë®üèΩ üôè Una breve descripci√≥n general de la arquitectura del compilador üçµ ‚òëÔ∏è üëé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La mayor√≠a de los compiladores tienen la siguiente arquitectura: 



 En este art√≠culo, voy a diseccionar esta arquitectura en detalle, elemento por e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una breve descripci√≥n general de la arquitectura del compilador</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/451894/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/ej/-i/slej-ivpokabgczeqdbgiafc0rw.jpeg"></div><br>  La mayor√≠a de los compiladores tienen la siguiente arquitectura: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73e/ff7/c46/73eff7c467213f5de1b9134666f9e569.png"><br><br>  En este art√≠culo, voy a diseccionar esta arquitectura en detalle, elemento por elemento. <br>  Podemos decir que este art√≠culo es una adici√≥n a la gran cantidad de recursos existentes sobre el tema de los compiladores.  Es una fuente aut√≥noma que le permitir√° comprender los conceptos b√°sicos de dise√±o e implementaci√≥n de lenguajes de programaci√≥n. <br><br>  El p√∫blico objetivo del art√≠culo son las personas cuya idea del trabajo de los compiladores es extremadamente limitada (el m√°ximo es que est√°n involucrados en la compilaci√≥n).  Sin embargo, espero que el lector entienda las estructuras de datos y los algoritmos. <br><br>  El art√≠culo no est√° dedicado en modo alguno a los compiladores de producci√≥n modernos con millones de l√≠neas de c√≥digo; no, este es un curso corto de "compiladores para tontos" que ayuda a comprender qu√© es un compilador. <br><a name="habracut"></a><br><h2>  Introduccion </h2><br>  Actualmente estoy trabajando en el lenguaje del sistema <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Krug</a> inspirado en Rust and Go.  En el art√≠culo me referir√© a Krug como un ejemplo para ilustrar mis pensamientos.  Krug est√° en desarrollo, pero ya est√° disponible en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/krug-lang</a> en los repositorios <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">caasper</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">krug</a> .  El lenguaje no es del todo t√≠pico en comparaci√≥n con la arquitectura habitual de los compiladores, lo que en parte me inspir√≥ a escribir un art√≠culo, pero m√°s sobre eso m√°s adelante. <br><br>  ¬°Me apresuro a informarles que no soy especialista en compiladores!  No tengo un doctorado y no recib√≠ ning√∫n entrenamiento formal: estudi√© todo lo descrito en el art√≠culo por mi cuenta en mi tiempo libre.  Tambi√©n debo decir que no estoy describiendo el enfoque real y √∫nico para crear un compilador, sino que presento los m√©todos b√°sicos adecuados para crear un peque√±o compilador de "juguetes". <br><br><h2>  Frontend </h2><br>  Volvamos al diagrama de arriba: las flechas a la izquierda dirigidas al campo frontend son lenguajes conocidos y amados como C. El frontend se parece a esto: an√°lisis l√©xico -&gt; analizador sint√°ctico. <br><br><h2>  An√°lisis l√©xico </h2><br>  Cuando comenc√© a estudiar compiladores y dise√±o de lenguaje, me dijeron que el an√°lisis l√©xico es lo mismo que la tokenizaci√≥n.  Usaremos esta descripci√≥n.  El analizador toma datos de entrada en forma de cadenas o una secuencia de caracteres y reconoce patrones en ellos, que corta en tokens. <br><br>  En el caso de un compilador, recibe un programa escrito como entrada.  Se lee en una cadena desde un archivo, y el analizador tokeniza su c√≥digo fuente. <br><br><pre><code class="plaintext hljs">enum TokenType { Identifier, Number, }; struct Token { std::string Lexeme; TokenType type; // ... // It's also handy to store things in here // like the position of the token (start to end row:col) };</code> </pre> <br>  En este fragmento, escrito en un lenguaje en forma de C, puede ver la estructura que contiene el lexema mencionado anteriormente, as√≠ como TokenType, que sirve para reconocer este token. <br><br>  Nota: el art√≠culo no es una instrucci√≥n para crear un lenguaje con ejemplos, pero para una mejor comprensi√≥n, insertar√© fragmentos de c√≥digo de vez en cuando. <br><br>  Los analizadores suelen ser los componentes m√°s simples del compilador.  Toda la interfaz, de hecho, es bastante simple en comparaci√≥n con el resto de las piezas del rompecabezas.  Aunque depende mucho de tu trabajo. <br><br>  Tome la siguiente pieza de c√≥digo C: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello world!\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Despu√©s de leerlo de un archivo a una l√≠nea y realizar un escaneo lineal, es posible que pueda cortar tokens.  Identificamos tokens de forma natural, ya que int es una "palabra" y 0 en la declaraci√≥n de retorno es un "n√∫mero".  El analizador l√©xico realiza el mismo procedimiento que nosotros: luego examinaremos este proceso con m√°s detalle.  Por ejemplo, analice los n√∫meros: <br><br><pre> <code class="plaintext hljs">0xdeadbeef ‚Äî HexNumber ( ) 1231234234 ‚Äî WholeNumber ( ) 3.1412 ‚Äî FloatingNumber (   ) 55.5555 ‚Äî FloatingNumber (   ) 0b0001 ‚Äî BinaryNumber ( )</code> </pre> <br>  Definir palabras puede ser dif√≠cil.  La mayor√≠a de los idiomas definen una palabra como una secuencia de letras y n√∫meros, y un identificador generalmente debe comenzar con una letra o un gui√≥n bajo.  Por ejemplo: <br><br><pre> <code class="plaintext hljs">123foobar := 3 person-age := 5 fmt.Println(123foobar)</code> </pre> <br>  En Go, este c√≥digo no se considerar√° correcto y se analizar√° en los siguientes tokens: <br><br><pre> <code class="plaintext hljs">Number(123), Identifier(foobar), Symbol(:=), Number(3) ...</code> </pre> <br>  La mayor√≠a de los identificadores encontrados se ven as√≠: <br><br><pre> <code class="plaintext hljs">foo_bar __uint8_t fooBar123</code> </pre> <br>  Los analizadores tendr√°n que resolver otros problemas, por ejemplo, con espacios, comentarios multil√≠nea y de una sola l√≠nea, identificadores, n√∫meros, sistemas num√©ricos y formato de n√∫meros (por ejemplo, 1_000_000) y codificaciones (por ejemplo, soporte para UTF8 en lugar de ASCII). <br><br>  Y si crees que puedes recurrir a expresiones regulares, mejor no vale la pena.  Es mucho m√°s f√°cil escribir un analizador desde cero, pero recomiendo leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">este art√≠culo</a> de nuestro rey y dios Rob Pike.  Las razones por las cuales Regex no es adecuado para nosotros se describen en muchos otros art√≠culos, por lo que omitir√© este punto.  Adem√°s, escribir un analizador es mucho m√°s interesante que atormentarse con largas expresiones detalladas cargadas en regex101.com a las 5:24 a.m.  En mi primer idioma, utilic√© la funci√≥n <code>split(str)</code> para la tokenizaci√≥n, y no fui muy lejos. <br><br><h2>  Analizando </h2><br>  El an√°lisis es algo m√°s complicado que el an√°lisis l√©xico.  Hay muchos analizadores y generadores de analizadores: aqu√≠ el juego comienza a lo grande. <br><br>  Los analizadores en los compiladores usualmente toman la entrada en forma de tokens y construyen un √°rbol espec√≠fico: un √°rbol de sintaxis abstracta o un √°rbol de an√°lisis.  Por su naturaleza, son similares, pero tienen algunas diferencias. <br><br>  Estas etapas se pueden representar como funciones: <br><br><pre> <code class="plaintext hljs">fn lex(string input) []Token {...} fn parse(tokens []Token) AST {...} let input = "int main() { return 0; }"; let tokens = lex(input); let parse_tree = parse(tokens); // ....</code> </pre> <br>  Por lo general, los compiladores se compilan a partir de muchos componentes peque√±os que toman entradas, las cambian o las convierten a diferentes salidas.  Esta es una de las razones por las cuales los lenguajes funcionales son adecuados para crear compiladores.  Otras razones son excelentes evaluaciones comparativas y bibliotecas est√°ndar bastante extensas.  Dato curioso: la primera implementaci√≥n del compilador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust</a> fue en Ocaml. <br><br>  Le aconsejo que mantenga estos componentes lo m√°s simples y aut√≥nomos posible: la modularidad facilitar√° enormemente el proceso.  En mi opini√≥n, lo mismo se puede decir sobre muchos otros aspectos del desarrollo de software. <br><br><h2>  Arboles </h2><br><h4>  √Årbol de an√°lisis </h4><br>  ¬øQu√© demonios es esto?  Tambi√©n conocido como √°rbol de an√°lisis, este √°rbol grueso sirve para visualizar el programa fuente.  Contienen toda la informaci√≥n (o la mayor parte) sobre el programa de entrada, generalmente la misma que se describe en la gram√°tica de su idioma.  Cada nodo del √°rbol ser√° final o no final, por ejemplo, NumberConstant o StringConstant. <br><br><h4>  √Årbol de sintaxis abstracta </h4><br>  Como su nombre lo indica, el ASD es un <i>√°rbol de</i> sintaxis <i>abstracta</i> .  El √°rbol de an√°lisis contiene mucha informaci√≥n (a menudo redundante) sobre su programa y, en el caso de un ASD, no es obligatorio.  ASD no necesita informaci√≥n in√∫til sobre la estructura y la gram√°tica, lo que no afecta la sem√°ntica del programa. <br><br>  Supongamos que su √°rbol tiene una expresi√≥n como ((5 + 5) -3) +2.  En el √°rbol de an√°lisis, lo almacenar√≠a por completo, junto con los corchetes, los operadores y los valores 5, 5, 3 y 2. Pero simplemente puede asociarse con el ASD: solo necesitamos conocer los valores, los operadores y su orden. <br><br>  La imagen a continuaci√≥n muestra el √°rbol para la expresi√≥n a + b / c. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98c/61a/cb3/98c61acb355e7887b53b5c37de0aa34f.png" width="400"></div><br>  ASD se puede representar de la siguiente manera: <br><br><pre> <code class="plaintext hljs">interface Expression { ... }; struct UnaryExpression { Expression value; char op; }; struct BinaryExpression { Expression lhand, rhand; string op; // string because the op could be more than 1 char. }; interface Node { ... }; // or for something like a variable struct Variable : Node { Token identifier; Expression value; };</code> </pre> <br>  Esta vista es bastante limitada, pero espero que pueda ver c√≥mo se estructurar√°n sus nodos.  Para analizar, puede recurrir al siguiente procedimiento: <br><br><pre> <code class="plaintext hljs">Node parseNode() { Token current = consume(); switch (current.lexeme) { case "var": return parseVariableNode(); // ... } panic("unrecognized input!"); } Node n = parseNode(); if (n != null) { // append to some list of top level nodes? // or append to a block of nodes! }</code> </pre> <br>  Espero que comprenda la esencia de c√≥mo proceder√° el an√°lisis paso a paso de los nodos restantes, comenzando con construcciones de lenguaje de alto nivel.  C√≥mo se implementa exactamente un analizador sint√°ctico con un descenso recursivo, debe estudiar usted mismo. <br><br><h2>  Gram√°tica </h2><br>  Analizar un ADS de un conjunto de tokens puede ser dif√≠cil.  Por lo general, debe comenzar por la gram√°tica de su idioma.  En esencia, la gram√°tica determina la estructura de su idioma.  Hay varios idiomas para definir idiomas que pueden describirse (o analizarse) por s√≠ mismos. <br><br>  Un ejemplo de un idioma para determinar idiomas es una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">forma extendida de Backus-Naur</a> (RBNF).  Es una variaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">BNF</a> con menos par√©ntesis angulares.  Aqu√≠ hay un ejemplo de RBNF de un art√≠culo de Wikipedia: <br><br><pre> <code class="plaintext hljs">digit excluding zero = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ; digit = "0" | digit excluding zero ;</code> </pre> <br>  Las reglas de producci√≥n est√°n definidas: indican qu√© plantilla de terminal es "no terminal".  Los terminales son parte del alfabeto, por ejemplo, el token if o 0 y 1 en el ejemplo anterior son terminales.  Los no terminales son su opuesto, est√°n en el lado izquierdo de las reglas de producci√≥n, y pueden considerarse como variables o "punteros con nombre" para grupos de terminales y no terminales. <br><br>  Muchos idiomas tienen especificaciones que contienen gram√°tica.  Por ejemplo, para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Go</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">D.</a> <br><br><h2>  Analizadores recursivos de descenso </h2><br>  El descenso recursivo es el m√°s f√°cil de muchos enfoques de an√°lisis. <br><br>  Analizadores de descenso recursivo: descendente, basado en procedimientos recursivos.  Es mucho m√°s f√°cil escribir un analizador sint√°ctico, porque su gram√°tica no ha <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">dejado recursividad</a> .  En la mayor√≠a de los lenguajes de "juguetes", esta t√©cnica es suficiente para analizar.  GCC usa un analizador descendente escrito a mano, aunque antes se usaba YACC. <br><br>  Sin embargo, analizar estos idiomas puede causar problemas.  En particular, C, donde <br><br><pre> <code class="cpp hljs">foo * bar</code> </pre> <br>  puede ser interpretado como <br><br><pre> <code class="plaintext hljs">int foo = 3; int bar = 4; foo * bar; // unused expression</code> </pre> <br>  o como <br><br><pre> <code class="plaintext hljs">typedef struct { int b; } foo; foo* bar; bar.b = 3;</code> </pre> <br>  La implementaci√≥n de Clang tambi√©n usa un analizador de descenso recursivo: <br><br>  <i>Como se trata de un c√≥digo C ++ normal, un descenso recursivo facilita que los principiantes lo entiendan.</i>  <i>Admite reglas personalizadas y otras cosas extra√±as que requiere C / C ++ y le ayuda a diagnosticar y corregir errores f√°cilmente.</i> <br><br>  Tambi√©n vale la pena prestar atenci√≥n a otros enfoques: <br><br><ul><li>  LL descendente, descenso recursivo </li><li>  LR ascendente, cambio, descenso ascendente </li></ul><br><h2>  Generadores de analizadores </h2><br>  Otra buena manera.  Por supuesto, tambi√©n hay desventajas, pero esto se puede decir sobre cualquier otra opci√≥n que los programadores hagan al crear software. <br><br>  Los generadores de analizadores funcionan muy r√°pido.  Usarlos es m√°s f√°cil que escribir su propio analizador y obtener un resultado de calidad, aunque no son muy f√°ciles de usar y no siempre muestran mensajes de error.  Adem√°s, tendr√° que aprender a usar el generador de analizadores y, cuando promocione el compilador, probablemente tenga que desenrollar el generador de analizadores. <br><br>  Un ejemplo de un generador de analizador es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ANTLR</a> , hay muchos otros. <br><br>  Creo que esta herramienta es adecuada para aquellos que no quieren pasar tiempo escribiendo una interfaz y que preferir√≠an escribir en el medio y el backend del compilador / int√©rprete y analizar cualquier cosa. <br><br><h2>  Aplicaci√≥n de an√°lisis </h2><br>  Si a√∫n no te entiendes a ti mismo.  Incluso la interfaz del compilador (lex / parse) se puede usar para resolver otros problemas: <br><br><ul><li>  resaltado de sintaxis </li><li>  An√°lisis HTML / CSS para motor de renderizado </li><li>  transpilers: TypeScript, CoffeeScript </li><li>  enlazadores </li><li>  REGEX </li><li>  an√°lisis de datos de interfaz </li><li>  An√°lisis de URL </li><li>  herramientas de formateo como <i>gofmt</i> </li><li>  An√°lisis de SQL y m√°s. </li></ul><br><h2>  Mediados </h2><br>  An√°lisis sem√°ntico!  El an√°lisis de la sem√°ntica del lenguaje es una de las tareas m√°s dif√≠ciles al crear un compilador. <br><br>  Debe asegurarse de que todos los programas de entrada funcionen correctamente.  En mi lenguaje Krug, los aspectos relacionados con el an√°lisis sem√°ntico a√∫n no se han incluido, y sin √©l, el programador siempre tendr√° que escribir el c√≥digo correcto.  En realidad, esto es imposible, y siempre escribimos, compilamos, a veces corremos, corregimos errores.  Esta espiral es interminable. <br><br>  Adem√°s, la compilaci√≥n de programas es imposible sin el an√°lisis de la correcci√≥n de la sem√°ntica en la etapa apropiada de compilaci√≥n. <br><br>  Una vez me encontr√© con un gr√°fico sobre el porcentaje de front-end, midland y backend.  Entonces parec√≠a <br><br><pre> <code class="plaintext hljs">F: 20% M: 20%: B: 60%</code> </pre> <br>  Hoy es algo como <br><br><pre> <code class="plaintext hljs">F: 5% M: 60% B: 35%</code> </pre> <br>  El frontend se ocupa principalmente del generador, y en los lenguajes sin contexto que no tienen la dualidad de la gram√°tica, se pueden completar con bastante rapidez; un descenso recursivo ayudar√° aqu√≠. <br><br>  Con la tecnolog√≠a LLVM, la mayor parte del trabajo de optimizaci√≥n se puede cargar en el marco, que presenta una serie de optimizaciones listas para usar. <br><br>  El siguiente paso es el an√°lisis sem√°ntico, una parte esencial de la fase de compilaci√≥n. <br><br>  Por ejemplo, en Rust, con su modelo de administraci√≥n de memoria, el compilador act√∫a como una m√°quina grande y poderosa que realiza varios tipos de an√°lisis est√°ticos en formas introductorias.  Parte de esta tarea es convertir los datos de entrada en una forma m√°s conveniente para el an√°lisis. <br><br>  Por esta raz√≥n, el an√°lisis sem√°ntico juega un papel importante en la arquitectura del compilador, y el agotador trabajo preparatorio como optimizar el ensamblaje generado o leer los datos de entrada en el ASD se realiza por usted. <br><br><h2>  Pasos Sem√°nticos </h2><br>  En el curso del an√°lisis sem√°ntico, la mayor√≠a de los compiladores realizan una gran cantidad de "pases sem√°nticos" en el SDA u otra forma abstracta de expresi√≥n de c√≥digo.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Este art√≠culo</a> proporciona detalles sobre la mayor√≠a de los pases realizados en el compilador .NET C #. <br><br>  No considerar√© cada pasaje, especialmente porque var√≠an seg√∫n el idioma, pero a continuaci√≥n se describen varios pasos en Krug. <br><br><h2>  Anuncio de nivel superior </h2><br>  El compilador revisar√° todos los anuncios de "nivel superior" en los m√≥dulos y estar√° al tanto de su existencia.  No profundizar√° en los bloques, simplemente declarar√° qu√© estructuras, funciones, etc.  est√°n disponibles en uno u otro m√≥dulo. <br><br><h2>  Resoluci√≥n de nombre / s√≠mbolo </h2><br>  El compilador revisa todos los bloques de c√≥digo en funciones, etc.  y los resuelve, es decir, encuentra caracteres que requieren permiso.  Este es un paso com√∫n, y es a partir de aqu√≠ que el error <i>XYZ de tal s√≠mbolo no</i> suele aparecer al compilar el c√≥digo Go. <br><br>  Realizar este pase puede ser muy dif√≠cil, especialmente si hay dependencias circulares en su diagrama de dependencia.  Algunos idiomas no los permiten, por ejemplo, Go arrojar√° un error si uno de sus paquetes forma un bucle, como mi lenguaje Krug.  Las dependencias c√≠clicas pueden considerarse un efecto secundario de una arquitectura pobre. <br><br>  Los bucles se pueden determinar modificando DFS en el diagrama de dependencia, o usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el algoritmo de Tarjan</a> (como lo hizo Krug) para definir (m√∫ltiples) bucles. <br><br><h2>  Inferencia de tipo </h2><br>  El compilador revisa todas las variables y muestra sus tipos.  La inferencia de tipos en Krug es muy d√©bil; simplemente genera variables basadas en sus valores.  De ninguna manera es un sistema extra√±o, como los que puedes encontrar en lenguajes funcionales como Haskell. <br><br>  Los tipos pueden derivarse mediante el proceso de "unificaci√≥n" o "unificaci√≥n de tipos".  Para sistemas de tipo m√°s simple, se puede utilizar una implementaci√≥n muy simple. <br><br>  Los tipos se implementan en Krug as√≠: <br><br><pre> <code class="plaintext hljs">interface Type {}; struct IntegerType : Type { int width; bool signed; }; struct FloatingType : Type { int width; }; struct ArrayType : Type { Type base_type; uint64 length; };</code> </pre> <br>  Tambi√©n puede tener una inferencia de tipo simple, en la que asigna un tipo a nodos de expresi√≥n, por ejemplo, <code>IntegerConstantNode</code> puede ser de tipo IntegerType (64).  Y luego puede obtener la funci√≥n <code>unify(t1, t2)</code> , que seleccionar√° el tipo m√°s amplio que puede usarse para deducir el tipo de expresiones m√°s complejas, por ejemplo, las binarias.  Entonces se trata de asignar una variable a la izquierda a los valores de los tipos dados a la derecha. <br><br>  Una vez escrib√≠ un simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">tipo de reparto</a> en Go, que se convirti√≥ en un prototipo de implementaci√≥n para Krug. <br><br><h2>  Pase de mutabilidad </h2><br>  Krug (como Rust) es, por defecto, un lenguaje inmutable, es decir, las variables permanecen sin cambios a menos que se especifique lo contrario: <br><br><pre> <code class="plaintext hljs">let x = 3; x = 4; // BAD! mut y = 5; y = 6; // OK!</code> </pre> <br>  El compilador revisa todos los bloques y funciones y comprueba que sus "variables son correctas", es decir, no cambiamos lo que no sigue, y que todas las variables pasadas a ciertas funciones son constantes o modificables cuando sea necesario. <br><br>  Esto se hace con la ayuda de informaci√≥n simb√≥lica que se ha recopilado en pases anteriores.  Una tabla de s√≠mbolos basada en los resultados del paso sem√°ntico contiene nombres de tokens y signos de variabilidad variable.  Puede contener otros datos, por ejemplo, en C ++ una tabla puede almacenar informaci√≥n sobre si un s√≠mbolo es externo o est√°tico. <br><br><h2>  Tablas de personajes </h2><br>  Una tabla de caracteres, o "pu√±alada", es una tabla para encontrar los caracteres que se utilizan en su programa.  Se crea una tabla para cada √°mbito, y todos contienen informaci√≥n sobre los caracteres presentes en un √°mbito particular. <br><br>  Esta informaci√≥n incluye propiedades tales como el nombre del s√≠mbolo, el tipo, el signo de mutabilidad, la presencia de comunicaci√≥n externa, la ubicaci√≥n en la memoria est√°tica, etc. <br><br><h3>  Alcance </h3><br>  Este es un concepto importante en los lenguajes de programaci√≥n.  Por supuesto, su idioma no tiene que hacer posible crear √°mbitos anidados, ¬°todo se puede colocar en un espacio de nombres com√∫n! <br><br>  Aunque representar el alcance es una tarea interesante para la arquitectura del compilador, en la mayor√≠a de los lenguajes tipo C, el alcance se comporta (o es) como una estructura de datos de pila. <br><br>  Por lo general, creamos y destruimos √°mbitos, y generalmente se usan para administrar nombres, es decir, nos permiten ocultar (sombrear) variables: <br><br><pre> <code class="plaintext hljs">{ // push scope let x = 3; { // push scope let x = 4; // OK! } // pop scope } // pop scope</code> </pre> <br>  Se puede representar de manera diferente: <br><br><pre> <code class="plaintext hljs">struct Scope { Scope* outer; SymbolTable symbols; }</code> </pre> <br>  Un tema peque√±o, pero recomiendo leer sobre la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">pila de espaguetis</a> .  Esta es una estructura de datos que se utiliza para almacenar √°reas de visibilidad en los nodos ASD de bloques opuestos. <br><br><h2>  Sistemas de tipo </h2><br>  Muchas de las siguientes secciones se pueden desarrollar en art√≠culos separados, pero me parece que este t√≠tulo merece m√°s.  Hoy en d√≠a hay mucha informaci√≥n disponible sobre los sistemas de tipos, as√≠ como sobre las variedades de los sistemas mismos, alrededor de los cuales se rompen muchas copias.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">profundizar√©</a> en este tema, solo dejar√© un enlace al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">excelente art√≠culo de Steve Klabnik</a> . <br><br>  Un sistema de tipos es lo que se proporciona y define sem√°nticamente en el compilador utilizando representaciones del compilador y an√°lisis de estas representaciones. <br><br><h2>  Posesi√≥n </h2><br>  Este concepto se usa en la programaci√≥n cada vez m√°s.  Los principios de la sem√°ntica de propiedad y movimiento est√°n integrados en el lenguaje <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rust</a> , y espero que aparezcan en otros idiomas.  Rust realiza muchos tipos diferentes de an√°lisis est√°tico, que verifica si la entrada satisface un conjunto de reglas con respecto a la memoria: qui√©n posee qu√© memoria, cu√°ndo se destruye la memoria y cu√°ntas referencias (o pr√©stamos) existen a estos valores o memoria. <br><br>  La belleza de Rust radica en el hecho de que todo esto se hace durante la compilaci√≥n, dentro del compilador, para que el programador no tenga que lidiar con la recolecci√≥n de basura o el conteo de enlaces.  Todas estas sem√°nticas est√°n relacionadas con el sistema de tipos y se pueden proporcionar incluso antes de que el programa se presente como un archivo binario completo. <br><br>  No puedo decir c√≥mo funciona todo bajo el cap√≥, pero todo esto es el resultado de un an√°lisis est√°tico y una investigaci√≥n maravillosa por parte del equipo de Mozilla y los participantes del proyecto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Cyclone</a> . <br><br><h2>  Gr√°ficos de control de flujo </h2><br>  Para representar los flujos del programa, utilizamos gr√°ficos de flujo de control (CFG), que contienen todas las rutas que puede seguir la ejecuci√≥n del programa.  Esto se utiliza en el an√°lisis sem√°ntico para excluir secciones inactivas de c√≥digo, es decir, bloques, funciones e incluso m√≥dulos que nunca se lograr√°n durante la ejecuci√≥n del programa.  Los gr√°ficos tambi√©n se pueden usar para identificar ciclos que no se pueden interrumpir.  O para buscar un c√≥digo inaccesible, por ejemplo, cuando llamas a un "p√°nico" (llamar a un p√°nico), o regresas en un bucle, y el c√≥digo fuera del bucle no se ejecuta.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El an√°lisis del flujo de datos</a> juega un papel importante durante la fase sem√°ntica del compilador, por lo que le recomiendo leer sobre los tipos de an√°lisis que puede realizar, c√≥mo funcionan y qu√© pueden hacer las optimizaciones. <br><br><h2>  Backend </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/330/914/1b9/3309141b9d53be1d9e5c8f77fb46d982.jpg"><br>  <i>La parte final de nuestro esquema de arquitectura.</i> <br><br>  Hemos realizado la mayor parte del trabajo de generar binarios ejecutables.  Esto se puede hacer de varias maneras, que discutiremos a continuaci√≥n. <br><br>        - ,   . ,     ,    ¬´¬ª. <br><br><h2>     </h2><br>   ,           . ,    ,      .   ,   ,         ,    .        ,      . <br><br>   ,           .  ,   ++ ‚Äî Cfront ‚Äî     C. <br><br>    JavaScript.     TypeScript    ,     ,   ,              ,         . <br><br>    ¬´¬ª ,     ,             ,       ,    ¬´  ¬ª  .        ‚Äî   ,        ,     . <br><br><h2> LLVM </h2><br>          LLVM: Rust, Swift, C/C++ (clang), D, Haskell. <br><br>    ¬´ ¬ª,             ,      .     , LLVM      .   ,       .  ,   ,     , , 1, 4, 8  16-.       ,  ,   -    . <br><br><h2>  - </h2><br>      ‚Äî     , ‚Äî     ,      . <br><br> Go ‚Äî    ,      LLVM (    ). Go     ,    Windows, Linux  MacOS. ,    Krug    -. <br><br>        .  ,     LLVM,     ,   ,        LLVM      ,     . <br><br>   ,        ,       ,        LLVM,      IR,    ,  , ,    (    ). <br><br>     .      ,         ,   ,       .       IR (    )  ¬´¬ª       fprintf   .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8cc</a> . <br><br><h2>   </h2><br>             .   ‚Äî Java:  , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JVM</a>        , , Kotlin. <br><br>     ,   Java   .         ,           .            ,       . <br>   , JVM   JIT       ,     JIT-,     . <br><br><h2>  </h2><br>     ,      !      ,     ,   .   -          ,   ,   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Godbolt</a> ‚Äî  ,  ,             .       , ,     . <br><br>      ,         ,       (strip the debug symbols),  ,   GCC.     ,  -  . <br><br>            .       .    ,         .        production-. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>        rwmj ,    8  ,   80%     .        1971-!    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>  ,  Rust. <br><br><h2> IR </h2><br>   (intermediate representation, IR)  ,  .      ,        ,     . <br><br>   IR     .      ,  ,    ,    . <br><br>    IR,  ¬´¬ª,       IR   . , SSA ‚Äî Static Single Assignment,   ,        . <br><br>  Go     IR   SSA. IR  LLVM   SSA,    . <br><br>  SSA   ,  ,   (constant propagation),     ( )  . <br><br><h2>   </h2><br>      ,  .  ,    ,   ,      ,    .         (  16  32),     ,      (spill to the stack). <br><br>   ‚Äî             (   ).     ,     ,          . <br><br>     : <br><br><ul><li>   (graph colouring) ‚Äî   (NP- ).      ,     (liveness ranges) . <br></li><li>   ‚Äî       . <br></li></ul><br><h2>     </h2><br>     . ,       .   ,       ,         . <br><br><h2>   ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Name Mangling</a> ) </h2><br>    -,            ,        .         ,   . <br><br><pre> <code class="plaintext hljs">fn main() int { let x = 0; { let x = 0; { let x = 0; } } return 0; }</code> </pre> <br> ,    (  -    :) )      ,      .        ,        . <br><br><h2>   </h2><br>   LLDB     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DWARF</a> .     LLVM   ,   DWARF         GNU-. ,     ,     ,   . <br><br><h2>    (Foreign Function Interface, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FFI</a> ) </h2><br>   libc   ,        ,      .       ,        ? <br><br><h2>  </h2><br>   ‚Äî  .     ,      (  .s/.asm)?       ? ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jai</a>        .   ,     . <br><br><h2>    (CaaS) </h2><br>         API-.  ,       Krug-,         .  ,     ,      . <br><br> ,     , ,      .         ,     API-. <br><br>   production-   CaaS.    Microsofts Roslyn,       ,     .    , , ,      ,     API-,     , ,  Rust  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RLS</a> . <br><br>    Krug ‚Äî        ‚Äî   Caasper  CaaS-. <br><br> Caasper      (,  ,  ),      , krug,    .   ,        ,      (bootstrap)   ,     . <br><br>   Krug   JavaScript,       Go*,  , ,   Krug. JavaScript     ,         yarn/npm. <br><br> <i>*      Go   ()  ,    JS.</i> <br><br>    Caasper  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> Github   Krug,    D    LLVM.       YouTube- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a> . <br><br>   Krug ()  <a href=""></a> . <br><br><h2>  Enlaces utiles </h2><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Jack Crenshaw</a> ‚Äî        . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Crafting Interpreters</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">  LLVM ( Go)</a> ‚Äî ! <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PL/0</a> <br></li><li> The Dragon Book ‚Äî  ,    . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">8cc</a> <br></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/451894/">https://habr.com/ru/post/451894/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451878/index.html">Transmisi√≥n en vivo de video est√©reo a gafas VR (Oculus Go)</a></li>
<li><a href="../451880/index.html">DevPRO'19: vista desde el stand de Wrike</a></li>
<li><a href="../451884/index.html">Siete a√±os de trabajo como desarrollador: ¬øqu√© lecciones he aprendido?</a></li>
<li><a href="../451886/index.html">Usar matem√°ticas discretas en las pruebas</a></li>
<li><a href="../451890/index.html">Delegaci√≥n de una zona de subred inversa de menos de / 24 en BIND. Como funciona</a></li>
<li><a href="../451896/index.html">Un eyeDisk "irrompible" est√° protegido por un esc√°ner de iris, pero transmite una contrase√±a en texto claro</a></li>
<li><a href="../451898/index.html">Innovaci√≥n en ruso</a></li>
<li><a href="../451900/index.html">Primera contribuci√≥n a la API del navegador de Facebook</a></li>
<li><a href="../451902/index.html">Microsoft Azure Developer Camp Rusia</a></li>
<li><a href="../451904/index.html">A veces m√°s es menos. Cuando una disminuci√≥n en la carga conduce a un aumento en el retraso</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>