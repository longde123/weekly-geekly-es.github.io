<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐎 👲 👆🏽 Nombre de communautés «Quoi?» O?? Quand? »(ChGK) ou combien de poignées de main avant un ami? 👩🏿‍💼 👘 🧛</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 


 Les vacances du Nouvel An sont le moment idéal pour  prendre une pause de l'informatique  Utilisez des compétences professionnelles...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nombre de communautés «Quoi?» O?? Quand? »(ChGK) ou combien de poignées de main avant un ami?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483356/"><img src="https://habrastorage.org/webt/sx/cv/ze/sxcvzemh1zfstlb99nne9_2hoxm.png"><br><p>  Bonjour, Habr! </p><br><p>  Les vacances du Nouvel An sont le moment idéal pour <del>  prendre une pause de l'informatique </del>  Utilisez des compétences professionnelles dans votre passe-temps préféré.  En fouillant sur le <a href="https://rating.chgk.info/" rel="nofollow">site de la cote sportive ChGK</a> , j'ai trouvé une excellente API qui vous permet d'obtenir des données sur tous les jeux de tous les tournois.  J'ai donc eu l'idée de construire un graphique de la communauté d'experts et de tester la théorie des six poignées de main sur une communauté géographiquement dispersée et strictement hors ligne.  Sous katom des images de graphiques et de statistiques inutiles. </p><a name="habracut"></a><br><p>  Pour commencer, un bref programme éducatif, qu'est-ce que le sport ChGK. </p><br><div class="spoiler">  <b class="spoiler_title">Qu'est-ce que le sport ChGK</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/w8/fb/yk/w8fbykni1pnbv0jgab0-9sbo4j4.jpeg" alt="Tournoi sportif ChGK"></p><br><p>  Je suis sûr qu'avec la version télévisée de "Quoi?  O??  Quand? »Le lecteur connaît bien le haut et les lettres des téléspectateurs.  Sports ChGK est une extension du format de télévision qui permet à plusieurs équipes de jouer simultanément. </p><br><p>  Dans le café, la maison des jeunes, la salle de réunion de l'université, plusieurs équipes de jusqu'à six personnes se rassemblent.  L'animateur lit les questions, une minute est accordée à la réflexion.  À la fin de la minute, l'équipe enregistre la réponse au formulaire de jeu et se lève.  Des personnes spécialement formées appelées hirondelles ramassent du papier.  Habituellement, 36 questions sont lues par partie, divisées en trois tours.  Qui a répondu le plus, c'est bien fait. </p><br><p>  Il y a beaucoup de tournois en ChGK, il y a même des championnats d'Europe et du monde, j'envoie les curieux à une <a href="http://lurkmore.to/%25D0%25A1%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25A7%25D0%2593%25D0%259A" rel="nofollow">source d'informations réputée</a> .  Et des exemples de questions peuvent être trouvés <a href="https://db.chgk.info/" rel="nofollow">ici</a> . </p></div></div><br><h2 id="poluchenie-dannyh">  Récupération de données </h2><br><p>  Nous supposons que les joueurs se connaissent bien s'ils ont joué au moins une fois sur une table de jeu.  Grâce à la <a href="https://rating.chgk.info/api-doc" rel="nofollow">bonne API, le</a> téléchargement de données sur tous les tournois et toutes les équipes n'est pas un problème. </p><br><p>  Sous les spoilers, même la Beautiful Soup n'est pas utilisée, seulement les demandes.  Un cahier jupyter avec tout le code source sera à la fin de l'article. </p><br><div class="spoiler">  <b class="spoiler_title">Télécharger les données de tous les tournois</b> <div class="spoiler_text"><pre><code class="python hljs">url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments.json/?page={}'</span></span> df = pd.DataFrame(columns=[<span class="hljs-string"><span class="hljs-string">'name'</span></span>, <span class="hljs-string"><span class="hljs-string">'start'</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>): data = requests.get(url.format(i)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data[<span class="hljs-string"><span class="hljs-string">"items"</span></span>]: df.loc[item[<span class="hljs-string"><span class="hljs-string">"idtournament"</span></span>]] = (item[<span class="hljs-string"><span class="hljs-string">"name"</span></span>], item[<span class="hljs-string"><span class="hljs-string">"date_start"</span></span>]) df.to_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>)</code> </pre> </div></div><br><p>  Il reste à télécharger les listes de jeu de tous les tournois et à se souvenir de toutes les connaissances.  Au départ, j'avais prévu de stocker les faits d'un jeu en commun dans un DataFrame, mais la vitesse d'ajout de nouveaux enregistrements était déprimante.  Par conséquent, nous allons définir à partir de tuples (id1, id2), où id1, id2 sont les identifiants des joueurs qui se connaissent.  En même temps, débarrassez-vous des doublons. </p><br><div class="spoiler">  <b class="spoiler_title">Téléchargement de compositions et rencontres</b> <div class="spoiler_text"><pre> <code class="python hljs">df = pd.read_csv(<span class="hljs-string"><span class="hljs-string">'tournaments.csv'</span></span>).set_index(<span class="hljs-string"><span class="hljs-string">'Unnamed: 0'</span></span>) url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/tournaments/{}/recaps.json'</span></span> links = set() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> df.index: teams = requests.get(url.format(id)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> team <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> teams: t = team[<span class="hljs-string"><span class="hljs-string">"recaps"</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(t)): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(i + <span class="hljs-number"><span class="hljs-number">1</span></span>, len(t)): first = int(t[i][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) second = int(t[j][<span class="hljs-string"><span class="hljs-string">"idplayer"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> first &lt; second: links.add((first, second)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: links.add((second, first)) <span class="hljs-comment"><span class="hljs-comment">#    sleep(1) clear_output(wait=True) display('Current tournament: ' + str(df.index.get_loc(id) + 1) + '/' + str(len(df))) display('Links total: ' + str(len(links)))</span></span></code> </pre> </div></div><br><h2 id="poluchenie-grafa-i-issledovanie-komponent-svyaznosti">  Obtenir un graphique et explorer les composants connectés </h2><br><p>  La préparation des données est donc terminée, il est temps de construire un graphique!  Pour ce faire, nous utiliserons la bibliothèque <a href="https://networkx.github.io/" rel="nofollow">networkx</a> , dont les capacités sont tout à fait suffisantes pour notre cluster. </p><br><pre> <code class="python hljs">players = itertools.chain(*links) G = nx.Graph() G.add_nodes_from(players) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> links: G.add_edge(*t) print(nx.info(G))</code> </pre> <br><p>  Maintenant, il y a environ deux cent mille personnes dans la communauté ChGK, et en moyenne, un expert sur une carrière a joué avec 12 personnes: </p><br><pre> <code class="plaintext hljs">Number of nodes: 198145 Number of edges: 1206076 Average degree: 12.1737</code> </pre> <br><p>  Il est temps de découvrir le nombre de composants connectés dans le graphique de datation.  Networkx a une excellente fonction appelée connected_components qui fait exactement ce dont vous avez besoin: </p><br><pre> <code class="python hljs">clusters_l = [len(c) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)] print(clusters_l[:<span class="hljs-number"><span class="hljs-number">20</span></span>])</code> </pre> <br><p>  Près des trois quarts des joueurs sont dans un composant connecté, les autres sont divisés en très petits sous-graphiques.  Il y en a plus de huit mille. </p><br><pre> <code class="plaintext hljs">[145922, 153, 124, 74, 72, 56, 50, 47, 42, 40, 39, 39, 38, 38, 37, 36, 36, 36, 36, 35]</code> </pre> <br><p>  Même à l'échelle logarithmique, la dominance de la composante principale semble impressionnante.  Sur l'axe X - le numéro du composant du plus grand au moins, sur l'axe Y - sa taille (l'axe logarithmique). </p><br><img src="https://habrastorage.org/webt/c9/pa/ol/c9paolwikv7_cjugzxctqtpffwy.png"><br><p>  Qu'est-ce qui a causé une telle répartition inégale des personnes dans les composants connectés?  À mon avis, le point est le suivant: </p><br><ul><li>  un petit groupe de personnes vient pour la première fois au jeu et forme ainsi un petit groupe pour 4-6 personnes; </li><li>  si la ville a déjà une grande communauté, un tel cluster fusionnera très rapidement avec le principal - une seule personne doit jouer pour une équipe du cluster principal; </li><li>  si dans la ville de ChGK vient d'apparaître, le cluster vivra plus longtemps, car  jouer pour une équipe du cluster principal est plus difficile. </li></ul><br><p>  Le processus ressemble à la formation de gouttes de pluie dans les nuages: une grosse goutte attire les petites et se développe rapidement. </p><br><p>  Avant de traiter du composant principal, regardons les composants en première ou neuvième place (je considère que le composant principal est nul).  Nous testons l'hypothèse que les habitants de ces composantes sont de la même ville.  Le connaisseur n'a aucun attachement à la ville (ce qui est logique dans notre monde moderne).  Cependant, vous pouvez regarder le port d'attache de l'équipe pour laquelle il a joué pour la dernière fois </p><br><div class="spoiler">  <b class="spoiler_title">Code statistique de la ville</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>): _g = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[i]) s = pd.Series() p_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/players/{}/tournaments.json'</span></span> t_url = <span class="hljs-string"><span class="hljs-string">'https://rating.chgk.info/api/teams/{}.json'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> player <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> _g: data = requests.get(p_url.format(player)).json() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: team_id = data[item][<span class="hljs-string"><span class="hljs-string">"tournaments"</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"idteam"</span></span>] data = requests.get(t_url.format(team_id)).json() town = data[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-string"><span class="hljs-string">"town"</span></span>] s.at[len(s)] = town print(<span class="hljs-string"><span class="hljs-string">' #{}'</span></span>.format(i)) print(s.value_counts())</code> </pre> </div></div><br><p>  Plaque de résumé: </p><br><div class="scrollable-table"><table><thead><tr><th>  Numéro de composant de connectivité </th><th>  La taille </th><th>  Les villes </th></tr></thead><tbody><tr><td>  1 </td><td>  153 </td><td>  Kerch </td></tr><tr><td>  2 </td><td>  124 </td><td>  110 - Ust-Ilimsk, 12 - Vladivostok, 2 - Irkoutsk </td></tr><tr><td>  3 </td><td>  74 </td><td>  Tambov - 72, <strong>Luxembourg - 2</strong> </td></tr><tr><td>  4 </td><td>  72 </td><td>  La forêt </td></tr><tr><td>  5 </td><td>  56 </td><td>  Yeisk </td></tr><tr><td>  6 </td><td>  50 </td><td>  Bichkek </td></tr><tr><td>  7 </td><td>  47 </td><td>  <strong>Gorno-Altaysk</strong> </td></tr><tr><td>  8 </td><td>  42 </td><td>  Jytomyr - 37, Glazov - 5 </td></tr><tr><td>  9 </td><td>  40 </td><td>  <strong>Gorno-Altaysk - 31, Moscou - 9</strong> </td></tr></tbody></table></div><br><p>  Oui, les petites grappes proviennent presque entièrement d'une seule ville.  Veuillez prêter attention à la composante de soixante-douze résidents de Tambov, qui est associée au Luxembourg.  Aux septième et neuvième places se trouvent des composants de Gorno-Altaysk, qui pour une raison quelconque ne sont pas interconnectés.  J'imagine facilement la lutte de deux clans ChGK-ash, comme Montecca et Capulet, qui se battent pour le contrôle de la ville. <br>  Je suppose que dans un avenir proche, ces composants fusionneront dans le principal <del>  mais continuera à se battre </del>  . </p><br><h2 id="osnovnaya-komponenta-svyaznosti">  Le principal composant de la connectivité </h2><br><p>  Nous sommes donc arrivés au composant principal.  Nous obtiendrons le sous-graphique souhaité et regarderons ses statistiques: </p><br><pre> <code class="python hljs">subgraph_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]) subgraph = G.subgraph(subgraph_v) print(nx.info(subgraph))</code> </pre> <br><p>  Le nombre moyen de connexions s'est avéré être plus. </p><br><pre> <code class="plaintext hljs">Number of nodes: 145922 Number of edges: 1070504 Average degree: 14.6723</code> </pre> <br><p>  Et quel est le nombre maximum de connexions par joueur? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(G.degree, key=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: x[<span class="hljs-number"><span class="hljs-number">1</span></span>], reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[:<span class="hljs-number"><span class="hljs-number">10</span></span>]: print(<span class="hljs-string"><span class="hljs-string">' {}   {} '</span></span>.format(t[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre> <br><pre> <code class="plaintext hljs"> 42511   818   15051   798   29800   678   23020   666   16581   662   5328   657   29887   651   15811   645   30352   605   1055   602 </code> </pre> <br><p>  Franchement, je suis un peu choqué par les chiffres.  Si vous jouez avec une nouvelle équipe à chaque fois, vous aurez besoin de 818/5 ≈ 164 matchs pour atteindre la première place.  Incroyable. <br>  Nous nous souviendrons des deux premiers experts de cette notation et utiliserons davantage leurs compétences en communication. <br>  Estimons le nombre de connaissances les plus proches d'un expert moyen: </p><br><div class="spoiler">  <b class="spoiler_title">Obtention de données et traçage</b> <div class="spoiler_text"><pre> <code class="python hljs">_count = <span class="hljs-number"><span class="hljs-number">50</span></span> values = nx.degree_histogram(subgraph) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),values[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(0,_count, 5)) plt.ylabel(' ', fontsize=18) plt.title(' ', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><img src="https://habrastorage.org/webt/rt/cl/eh/rtclehktplh8tx_5mms3ny6gcom.png"><br><p>  Sur l'axe X - le nombre de connaissances les plus proches, sur l'axe Y - le nombre d'experts qui ont le nombre correspondant de connaissances.  Par exemple, environ 40 000 experts ont chacun cinq connaissances. <br>  Notez que la mode a 5 connaissances (c'est drôle que jusqu'à six personnes puissent être à table).  Dans le même temps, la moyenne arithmétique du nombre de connaissances est de 14,67 et la médiane est de 7. Le fait est que les messieurs de la notation ci-dessus surestiment largement la moyenne.  Si une centaine de personnes ne jouent pas en ChGK, et qu'une a 800 connaissances, alors en moyenne elles jouent en ChGK. </p><br><h2 id="rasstoyaniya-do-igrokov">  Distances par rapport aux joueurs </h2><br><p>  Parce que  compter le diamètre d'un tel graphique est un <a href="https://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC%25D1%258B_%25D0%25BD%25D0%25B0_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D1%258F%25D1%2585" rel="nofollow">peu difficile</a> , faisons-le plus facilement: prenez une liste de plusieurs joueurs et trouvez le maximum des distances les plus courtes entre eux et d'autres experts.  En tant que ces joueurs, j'ai pris plusieurs experts bien connus, moi-même, un joueur au hasard et deux experts avec le plus grand nombre de connaissances (voir note ci-dessus).  Voici ce qui s'est passé: </p><br><pre> <code class="python hljs">famous_players = {<span class="hljs-number"><span class="hljs-number">9808</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">5195</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">25882</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">29333</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118622</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">42511</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">15051</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-number"><span class="hljs-number">118621</span></span>: <span class="hljs-string"><span class="hljs-string">' '</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], nx.eccentricity(subgraph, v=key)))</code> </pre><br><pre> <code class="plaintext hljs"> : 12 -        : 12 -        : 12 -        : 12 -        : 13 -        : 12 -        : 13 -        : 13 -      </code> </pre><br><p>  Il s'avère qu'une formulation forte de la théorie des six poignées de main (deux personnes quelconques sont séparées par pas plus de cinq niveaux d'amis communs) est incorrecte.  Le diamètre du graphique est très probablement 13-14. <br>  Qu'en est-il d'une formulation plus faible (deux personnes <strong>en moyenne sont</strong> séparées par pas plus de cinq niveaux d'amis communs)? </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> famous_players: paths = nx.shortest_path_length(subgraph, source=key).values() print(<span class="hljs-string"><span class="hljs-string">'{}: {} -      '</span></span> .format(famous_players[key], sum(paths) / len(paths)))</code> </pre><br><pre> <code class="plaintext hljs"> : 3.941461876893135 -        : 3.7971107852140182 -        : 3.89353216101753 -        : 3.8634887131481204 -        : 4.1443373857266215 -        : 3.575478680390894 -        : 3.608674497334192 -        : 4.564102739819904 -      </code> </pre><br><p>  Si nous desserrons le libellé, alors la théorie est remplie - en moyenne entre experts sur 4-5 niveaux de connaissances.  Nous traçons le nombre de personnes qui connaissent le connaisseur aléatoire A. Druzem directement, à travers un, deux, etc.  connaisseurs. </p><br><div class="spoiler">  <b class="spoiler_title">Obtention de données et traçage</b> <div class="spoiler_text"><pre> <code class="python hljs">paths = nx.shortest_path_length(subgraph, source=<span class="hljs-number"><span class="hljs-number">9808</span></span>) neighbours = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> paths: neighbours[paths[k]] += <span class="hljs-number"><span class="hljs-number">1</span></span> _count = <span class="hljs-number"><span class="hljs-number">15</span></span> plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">80</span></span>) plt.plot(range(_count),neighbours[:_count],<span class="hljs-string"><span class="hljs-string">'ro-'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># in-degree plt.xlabel(' ', fontsize=18) plt.xticks(range(_count)) plt.ylabel(' ', fontsize=18) plt.title('  .', fontsize=22) plt.show()</span></span></code> </pre> </div></div><br><p>  Sur l'axe X, le degré de connaissance avec A. Druzem (directement, à travers un, deux, etc.), sur l'axe Y, le nombre d'experts qui connaissent A. Druzem de cette manière. </p><br><img src="https://habrastorage.org/webt/fj/tt/sk/fjttskyhdbiw2qrmdux5ug1mnn8.png"><br><h2 id="socialnye-grafy">  Graphiques sociaux </h2><br><p>  Parce que  construire un graphique pour près de 200 000 personnes n'est pas une bonne idée, nous allons vous faciliter la tâche: nous allons construire le composant de connectivité Kerch et un graphique des personnes associées à l'auteur. </p><br><h3 id="kerchenskaya-komponenta">  Composant Kerch </h3><br><pre> <code class="python hljs">little_v = list(sorted(nx.connected_components(G), key=len, reverse=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)[<span class="hljs-number"><span class="hljs-number">1</span></span>]) little = G.subgraph(little_v) plt.figure(figsize=(<span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>), dpi=<span class="hljs-number"><span class="hljs-number">200</span></span>) pos = nx.kamada_kawai_layout(little) nx.draw(little, pos=pos, node_size=<span class="hljs-number"><span class="hljs-number">100</span></span>, edge_color=<span class="hljs-string"><span class="hljs-string">'gray'</span></span>, node_color=[val <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (node, val) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> little.degree()], cmap=plt.cm.jet) plt.show()</code> </pre> <br><img src="https://habrastorage.org/webt/_p/tu/k6/_ptuk61dseuqzz0mviea_1jw4iy.png"><br><p>  Vous pouvez voir la séparation des composants en équipes.  De plus, les équipes sont interconnectées avec l'aide, en règle générale, d'un ou deux connaisseurs sociables.  Au centre se trouve un noyau d'experts assez restreint qui a joué avec un grand nombre d'autres joueurs. </p><br><h3 id="graf-odnogo-cheloveka">  Nombre d'une personne </h3><br><p>  Nous trouverons les connaissances les plus proches d'une personne et verrons comment elles sont liées.  Pour simplifier le graphique, nous n'ajouterons pas la personne elle-même (elle est déjà connectée avec tout le monde) </p><br><pre> <code class="python hljs">id = <span class="hljs-number"><span class="hljs-number">118622</span></span> ego_graph = [n <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> G.neighbors(id)] <span class="hljs-comment"><span class="hljs-comment">#ego_graph.append(id) ego_graph = G.subgraph(ego_graph) plt.figure(figsize=(24, 16), dpi=200) pos = nx.kamada_kawai_layout(ego_graph) nx.draw(ego_graph, pos=pos, node_size=100, edge_color='gray', node_color=[val for (node, val) in ego_graph.degree()], cmap=plt.cm.jet) plt.show()</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/ag/pq/xx/agpqxx0wdbosfslvdrrl0hu_x8u.png"><br><p>  Le graphique est beaucoup plus dense, un noyau de 10 à 15 personnes qui se connaissent se distingue.  La taille de clic maximale est de 13. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><ul><li>  Il est beaucoup plus difficile d'apprendre à connaître une personne dans le sport ChGK que sur un réseau social, vous devez vous déconnecter et jouer à au moins un tournoi.  Dans le même temps, les experts sont dispersés à travers le monde.  Cependant, la distance <strong>moyenne</strong> entre experts est en effet inférieure à cinq. </li><li>  Le site de notation utilise <a href="https://rating.chgk.info/players.php%3Fshow_bacon_stats" rel="nofollow">le numéro Snyatkovsky</a> , qui est un analogue <a href="https://ru.wikipedia.org/wiki/%25D0%25A7%25D0%25B8%25D1%2581%25D0%25BB%25D0%25BE_%25D0%25AD%25D1%2580%25D0%25B4%25D1%2591%25D1%2588%25D0%25B0" rel="nofollow">du numéro Erdös</a> dans le monde de ChGK.  M. Snyatkovsky lui-même prend la troisième place dans notre classement des connaisseurs les plus sociables. </li><li>  Code d'un article dans mon <a href="https://github.com/atepaevm/ChGK" rel="nofollow">github</a> . </li><li>  Pour ses précieux commentaires, l'auteur remercie le White Noise et Who Framed Roger Federer, Mikhail Akulov, Vera Terentyeva et <a href="https://habr.com/ru/users/firemoon/" class="user_link">Firemoon</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483356/">https://habr.com/ru/post/fr483356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483346/index.html">Comment la blockchain changera-t-elle la comptabilité?</a></li>
<li><a href="../fr483348/index.html">Comment calculer la "similitude" des numéros dans les passeports. Et trouver la même chose même avec des fautes de frappe</a></li>
<li><a href="../fr483350/index.html">Nouveautés de notre documentation .NET (décembre 2019)</a></li>
<li><a href="../fr483352/index.html">Python dans Visual Studio Code - version de janvier 2020</a></li>
<li><a href="../fr483354/index.html">Malédiction du deuxième mois</a></li>
<li><a href="../fr483360/index.html">Commande d'entraînement électrique. Expérience amateur</a></li>
<li><a href="../fr483364/index.html">Vous pouvez écrire du code au travail pour économiser votre temps libre.</a></li>
<li><a href="../fr483366/index.html">Histoire d'Internet: Réseautage</a></li>
<li><a href="../fr483368/index.html">Création du packer de fichiers ELF x86_64 pour Linux</a></li>
<li><a href="../fr483372/index.html">Comment former un réseau neuronal DeepPavlov sur un ordinateur portable à l'aide d'un GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>