<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥙 🔇 🥙 Mengganti Equals dan GetHashCode. Tetapi apakah itu perlu? 🤷🏼 🔝 🧤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda terbiasa dengan C #, kemungkinan besar Anda tahu bahwa Anda harus selalu mengesampingkan Equals , serta GetHashCode , untuk menghindari GetH...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengganti Equals dan GetHashCode. Tetapi apakah itu perlu?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/418515/"> Jika Anda terbiasa dengan C #, kemungkinan besar Anda tahu bahwa Anda harus selalu mengesampingkan <code>Equals</code> , serta <code>GetHashCode</code> , untuk menghindari <code>GetHashCode</code> kinerja.  Tetapi apa yang akan terjadi jika ini tidak dilakukan?  Hari ini, kami membandingkan kinerja dengan dua opsi penyetelan dan mempertimbangkan alat untuk membantu menghindari kesalahan. <br><br><img src="https://habrastorage.org/webt/w9/iq/7g/w9iq7gen1fjdvh3j6jcxai470ec.jpeg"><a name="habracut"></a><br><br><h2>  Seberapa serius masalah ini? </h2><br>  Tidak setiap masalah kinerja potensial mempengaruhi runtime aplikasi.  Metode <code>Enum.HasFlag</code> tidak terlalu efisien (*), tetapi jika Anda tidak menggunakannya pada sepotong kode sumber daya intensif, maka tidak akan ada masalah serius dalam proyek.  Ini juga merupakan kasus dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salinan yang diproteksi yang</a> dibuat oleh tipe struct yang tidak bisa dibaca dalam konteks readonly.  Masalahnya ada, tetapi tidak mungkin terlihat dalam aplikasi biasa. <br><br>  <i>(*) Tetap di NET Inti 2.1, dan, seperti yang saya sebutkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam publikasi sebelumnya</a> , dan sekarang dapat diatasi dengan menggunakan HasFlag mereka sendiri disesuaikan untuk versi.</i> <br><br>  Tetapi masalah yang akan kita bicarakan hari ini adalah spesial.  Jika metode <code>Equals</code> dan <code>GetHashCode</code> tidak dibuat dalam struktur, maka versi standar mereka dari <code>System.ValueType</code> .  Dan mereka dapat secara signifikan mengurangi kinerja aplikasi akhir. <br><br><h2>  Mengapa versi standar lambat? </h2><br>  Para penulis CLR melakukan yang terbaik untuk membuat versi standar Equals dan GetHashCode seefisien mungkin untuk tipe nilai.  Tetapi ada beberapa alasan mengapa metode ini hilang dalam keefektifan versi pengguna, ditulis untuk jenis tertentu secara manual (atau dihasilkan oleh kompiler). <br><br>  1. Distribusi konversi kemasan.  CLR dirancang sedemikian rupa sehingga setiap panggilan ke elemen yang didefinisikan dalam tipe <code>System.ValueType</code> atau <code>System.Enum</code> memicu transformasi pembungkus (**). <br><br>  <i>(**) Jika metode ini tidak mendukung kompilasi JIT.</i>  <i>Misalnya, dalam Core CLR 2.1, kompiler JIT mengenali metode <code>Enum.HasFlag</code> dan menghasilkan kode yang sesuai yang tidak mulai membungkus.</i> <br><br>  2. Potensi konflik dalam versi standar dari metode <code>GetHashCode</code> .  Saat menerapkan fungsi hash, kita menghadapi dilema: untuk membuat distribusi fungsi hash baik atau cepat.  Dalam beberapa kasus, Anda bisa melakukan keduanya, tetapi dalam tipe <code>ValueType.GetHashCode</code> , ini biasanya sulit. <br><br>  Fungsi hash tradisional tipe struct "menggabungkan" kode hash dari semua bidang.  Tetapi satu-satunya cara untuk mendapatkan kode hash bidang dalam metode <code>ValueType</code> adalah dengan menggunakan refleksi.  Itu sebabnya penulis CLR memutuskan untuk mengorbankan kecepatan demi distribusi, dan versi standar <code>GetHashCode</code> hanya mengembalikan kode hash dari bidang non-nol pertama dan <a href="">"merusaknya" dengan pengenal tipe</a> (***) (untuk lebih jelasnya lihat <code>RegularGetValueTypeHashCode</code> di coreclr repo on github). <br><br>  <i>(***) Dilihat dari komentar dalam repositori CoreCLR, situasinya mungkin berubah di masa depan.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">""</span></span>, position: <span class="hljs-number"><span class="hljs-number">1</span></span>).GetHashCode(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hash3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Location(path: <span class="hljs-string"><span class="hljs-string">"1"</span></span>, position: <span class="hljs-number"><span class="hljs-number">42</span></span>).GetHashCode(); <span class="hljs-comment"><span class="hljs-comment">// hash1 and hash2 are the same and hash1 is different from hash3</span></span></code> </pre> <br>  Ini adalah algoritma yang masuk akal sampai terjadi kesalahan.  Tetapi jika Anda kurang beruntung dan nilai bidang pertama dari tipe struct Anda adalah sama di sebagian besar kasus, maka fungsi hash akan selalu menghasilkan hasil yang sama.  Seperti yang mungkin sudah Anda duga, jika Anda menyimpan instance ini dalam hash set atau hash table, maka kinerja akan anjlok. <br><br>  3. Kecepatan implementasi berdasarkan refleksi rendah.  Sangat rendah  Refleksi adalah alat yang ampuh jika digunakan dengan benar.  Tetapi konsekuensinya akan mengerikan jika Anda menjalankannya pada sepotong kode sumber daya-intensif. <br><br>  Mari kita lihat bagaimana fungsi hash yang gagal, yang mungkin hasil dari (2) dan implementasi berbasis refleksi, mempengaruhi kinerja: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location1 { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Position { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Location1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position</span></span></span><span class="hljs-function">)</span></span> =&gt; (Path, Position) = (path, position); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Location2 { <span class="hljs-comment"><span class="hljs-comment">// The order matters! // The default GetHashCode version will get a hashcode of the first field public int Position { get; } public string Path { get; } public Location2(string path, int position) =&gt; (Path, Position) = (path, position); } public readonly struct Location3 : IEquatable&lt;Location3&gt; { public string Path { get; } public int Position { get; } public Location3(string path, int position) =&gt; (Path, Position) = (path, position); public override int GetHashCode() =&gt; (Path, Position).GetHashCode(); public override bool Equals(object other) =&gt; other is Location3 l &amp;&amp; Equals(l); public bool Equals(Location3 other) =&gt; Path == other.Path &amp;&amp; Position == other.Position; } private HashSet&lt;Location1&gt; _locations1; private HashSet&lt;Location2&gt; _locations2; private HashSet&lt;Location3&gt; _locations3; [Params(1, 10, 1000)] public int NumberOfElements { get; set; } [GlobalSetup] public void Init() { _locations1 = new HashSet&lt;Location1&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location1("", n))); _locations2 = new HashSet&lt;Location2&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location2("", n))); _locations3 = new HashSet&lt;Location3&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location3("", n))); _locations4 = new HashSet&lt;Location4&gt;(Enumerable.Range(1, NumberOfElements).Select(n =&gt; new Location4("", n))); } [Benchmark] public bool Path_Position_DefaultEquality() { var first = new Location1("", 0); return _locations1.Contains(first); } [Benchmark] public bool Position_Path_DefaultEquality() { var first = new Location2("", 0); return _locations2.Contains(first); } [Benchmark] public bool Path_Position_OverridenEquality() { var first = new Location3("", 0); return _locations3.Contains(first); }</span></span></code> </pre> <br><br><pre> <code class="cs hljs"> Method | NumOfElements | Mean | Gen <span class="hljs-number"><span class="hljs-number">0</span></span> | Allocated | -------------------------------- |------ |--------------:|--------:|----------:| Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">885.63</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0286</span></span> | <span class="hljs-number"><span class="hljs-number">92</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">127.80</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1</span></span> | <span class="hljs-number"><span class="hljs-number">47.99</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">214.02</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.2441</span></span> | <span class="hljs-number"><span class="hljs-number">776</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">130.04</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">10</span></span> | <span class="hljs-number"><span class="hljs-number">47.67</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B | Path_Position_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">589</span></span>,<span class="hljs-number"><span class="hljs-number">014.52</span></span> ns | <span class="hljs-number"><span class="hljs-number">23.4375</span></span> | <span class="hljs-number"><span class="hljs-number">76025</span></span> B | Position_Path_DefaultEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">133.74</span></span> ns | <span class="hljs-number"><span class="hljs-number">0.0050</span></span> | <span class="hljs-number"><span class="hljs-number">16</span></span> B | Path_Position_OverridenEquality | <span class="hljs-number"><span class="hljs-number">1000</span></span> | <span class="hljs-number"><span class="hljs-number">48.51</span></span> ns | - | <span class="hljs-number"><span class="hljs-number">0</span></span> B |</code> </pre> <br>  Jika nilai bidang pertama selalu sama, maka secara default fungsi hash mengembalikan nilai yang sama untuk semua elemen dan set hash secara efektif dikonversi ke daftar tertaut dengan operasi penyisipan dan pencarian O (N) dan pencarian.  Jumlah operasi untuk mengisi koleksi menjadi O (N ^ 2) (di mana N adalah jumlah sisipan dengan kompleksitas O (N) untuk setiap sisipan).  Ini berarti bahwa menyisipkan ke dalam kumpulan 1000 elemen akan menghasilkan hampir 500.000 panggilan ke <code>ValueType.Equals</code> .  Berikut adalah konsekuensi dari metode yang menggunakan refleksi! <br><br>  Seperti yang ditunjukkan dalam tes, kinerja akan dapat diterima jika Anda beruntung dan elemen pertama dari struktur ini unik (dalam kasus <code>Position_Path_DefaultEquality</code> ).  Tetapi jika tidak demikian, maka produktivitas akan sangat rendah. <br><br><h2>  Masalah nyata </h2><br>  Saya pikir sekarang Anda bisa menebak masalah apa yang baru-baru ini saya temui.  Beberapa minggu yang lalu saya menerima pesan kesalahan: runtime aplikasi yang saya kerjakan meningkat dari 10 menjadi 60 detik.  Untungnya, laporan itu sangat rinci dan berisi acara Tracing untuk Windows, sehingga area masalah ditemukan dengan cepat - <code>ValueType.Equals</code> dimuat 50 detik. <br><br>  Setelah melihat sekilas kode tersebut, menjadi jelas apa masalahnya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HashSet&lt;(ErrorLocation, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)&gt; _locationsWithHitCount; <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> ErrorLocation { <span class="hljs-comment"><span class="hljs-comment">// Empty almost all the time public string OptionalDescription { get; } public string Path { get; } public int Position { get; } }</span></span></code> </pre> <br>  Saya menggunakan tuple yang berisi tipe struct kustom dengan versi standar <code>Equals</code> .  Dan sayangnya, ia memiliki bidang pertama opsional, yang hampir selalu menyamai <code>String.equals</code> .  Produktivitas tetap tinggi sampai jumlah elemen dalam set meningkat secara signifikan.  Dalam hitungan menit, koleksi dengan puluhan ribu elemen telah diinisialisasi. <br><br><h2>  Apakah implementasi <code>ValueType.Equals/GetHashCode</code> default selalu berjalan lambat? </h2><br>  <code>ValueType.Equals</code> dan <code>ValueType.GetHashCode</code> memiliki metode optimasi khusus.  Jika jenisnya tidak memiliki "pointer" dan itu dikemas dengan benar (saya akan menunjukkan contoh dalam satu menit), maka versi dioptimalkan digunakan: iterasi <code>GetHashCode</code> dilakukan pada blok contoh, XOR dari 4 byte digunakan, metode <code>memcmp</code> membandingkan dua contoh menggunakan <code>memcmp</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// Optimized ValueType.GetHashCode implementation static INT32 FastGetValueTypeHashCodeHelper(MethodTable *mt, void *pObjRef) { INT32 hashCode = 0; INT32 *pObj = (INT32*)pObjRef; // this is a struct with no refs and no "strange" offsets, just go through the obj and xor the bits INT32 size = mt-&gt;GetNumInstanceFieldBytes(); for (INT32 i = 0; i &lt; (INT32)(size / sizeof(INT32)); i++) hashCode ^= *pObj++; return hashCode; } // Optimized ValueType.Equals implementation FCIMPL2(FC_BOOL_RET, ValueTypeHelper::FastEqualsCheck, Object* obj1, Object* obj2) { TypeHandle pTh = obj1-&gt;GetTypeHandle(); FC_RETURN_BOOL(memcmp(obj1-&gt;GetData(), obj2-&gt;GetData(), pTh.GetSize()) == 0); }</span></span></code> </pre> <br>  Pemeriksaan itu sendiri dilakukan di <code>ValueTypeHelper::CanCompareBits</code> , itu disebut baik dari iterasi <code>ValueType.Equals</code> dan dari iterasi <code>ValueType.GetHashCode</code> . <br><br>  Tetapi optimisasi adalah hal yang sangat berbahaya. <br><br>  Pertama, sulit dipahami ketika dihidupkan;  bahkan perubahan kecil pada kode dapat menghidupkan dan mematikannya: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Case1 { <span class="hljs-comment"><span class="hljs-comment">// Optimization is "on", because the struct is properly "packed" public int X { get; } public byte Y { get; } } public struct Case2 { // Optimization is "off", because struct has a padding between byte and int public byte Y { get; } public int X { get; } }</span></span></code> </pre> <br>  Untuk informasi lebih lanjut tentang struktur memori, lihat blog saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Elemen Internal Objek yang Dikelola, Bagian 4. Struktur Lapangan"</a> . <br><br>  Kedua, membandingkan memori tidak selalu memberi Anda hasil yang benar.  Ini adalah contoh sederhana: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> MyDouble { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyDouble</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> =&gt; Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d1 = <span class="hljs-number"><span class="hljs-number">-0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> d2 = +<span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// True bool b1 = d1.Equals(d2); // False! bool b2 = new MyDouble(d1).Equals(new MyDouble(d2));</span></span></code> </pre> <br>  <code>-0,0</code> dan <code>+0,0</code> sama, tetapi memiliki representasi biner yang berbeda.  Ini berarti bahwa <code>Double.Equals</code> benar dan <code>MyDouble.Equals</code> salah.  Dalam kebanyakan kasus, perbedaannya tidak signifikan, tetapi bayangkan berapa jam yang Anda habiskan untuk memperbaiki masalah yang disebabkan oleh perbedaan ini. <br><br><h2>  Bagaimana cara menghindari masalah serupa? </h2><br>  Bisakah Anda bertanya kepada saya bagaimana hal di atas dapat terjadi dalam situasi nyata?  Salah satu cara yang jelas untuk memulai metode <code>Equals</code> dan <code>GetHashCode</code> di jenis struct - menggunakan FxCop aturan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CA1815</a> .  Tetapi ada satu masalah: ini adalah pendekatan yang terlalu ketat. <br><br>  Aplikasi yang kinerjanya sangat penting dapat memiliki ratusan tipe struct yang belum tentu digunakan dalam kumpulan hash atau kamus.  Oleh karena itu, pengembang aplikasi dapat menonaktifkan aturan, yang akan menimbulkan konsekuensi yang tidak menyenangkan jika tipe struct menggunakan fungsi yang dimodifikasi. <br><br>  Pendekatan yang lebih tepat adalah untuk memperingatkan pengembang jika struct tipe "tidak pantas" dengan nilai elemen default yang sama (didefinisikan dalam aplikasi atau perpustakaan pihak ketiga) disimpan dalam hash set.  Tentu saja saya berbicara tentang <a href="">ErrorProne.NET</a> dan aturan yang saya tambahkan di sana segera setelah saya mengalami masalah ini: <br><br><img src="https://habrastorage.org/webt/fx/dp/2u/fxdp2u0isbov-7e2vh0stw70x2m.png"><br><br>  Versi ErrorProne.NET tidak sempurna dan akan "menyalahkan" kode yang benar jika penyelesai kesetaraan khusus digunakan dalam konstruktor: <br><br><img src="https://habrastorage.org/webt/9b/16/0p/9b160peycjwrjmiblktkuroajk0.png"><br><br>  Tapi saya masih berpikir itu layak peringatan jika struct dengan elemen yang sama secara default tidak digunakan ketika sedang diproduksi.  Misalnya, ketika saya memeriksa aturan saya, saya menyadari bahwa struktur <code>System.Collections.Generic.KeyValuePair &lt;TKey, TValue&gt;</code> yang didefinisikan dalam mscorlib tidak menimpa <code>Equals</code> dan <code>GetHashCode</code> .  Tidak mungkin ada orang yang akan mendefinisikan variabel seperti <code>HashSet &lt;KeyValuePair&lt;string, int&gt;&gt;</code> hari ini, tapi saya percaya bahkan BCL dapat melanggar aturan.  Karena itu, ada baiknya menemukan ini sebelum terlambat. <br><br><h2>  Kesimpulan </h2><br><ul><li>  Menerapkan kesetaraan default untuk tipe struct dapat memiliki konsekuensi serius untuk aplikasi Anda.  Ini masalah nyata, bukan teoretis. </li><li>  Elemen kesetaraan default untuk tipe nilai didasarkan pada refleksi. </li><li>  Distribusi yang dilakukan oleh <code>GetHashCode</code> versi standar akan sangat buruk jika bidang pertama dari banyak instance memiliki nilai yang sama. </li><li>  Ada versi yang dioptimalkan untuk metode <code>Equals</code> dan <code>GetHashCode</code> standar, tetapi Anda tidak harus bergantung pada mereka, karena bahkan perubahan kode kecil dapat mematikannya. </li><li>  Gunakan aturan FxCop untuk memastikan bahwa setiap tipe struct mengabaikan elemen kesetaraan.  Namun, lebih baik untuk mencegah masalah dengan penganalisis jika struktur "tidak tepat" disimpan dalam set hash atau dalam tabel hash. </li></ul><br><h2>  Sumber Daya Tambahan </h2><br><ul><li>  <a href="">ErrorProne.NET di github</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ErrorProne.NET Structs di toko</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418515/">https://habr.com/ru/post/id418515/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418503/index.html">Setelah 2020, Inggris akan memperoleh pelabuhan antariksa pertama - di Skotlandia</a></li>
<li><a href="../id418505/index.html">Tinjauan Umum dan Perbandingan Platform Perangkat Lunak Quantum Gerbang-Level</a></li>
<li><a href="../id418507/index.html">Apa yang diberikan kosmonautika kepada kita?</a></li>
<li><a href="../id418509/index.html">Rekognisi Amazon mengakui 28 anggota kongres AS sebagai penjahat</a></li>
<li><a href="../id418513/index.html">Cara menulis hanya kode yang baik</a></li>
<li><a href="../id418517/index.html">Cakupan Kode: Cara Meningkatkan Kualitas Pengujian</a></li>
<li><a href="../id418519/index.html">Apa yang dapat ditemukan dalam kode orang lain? Pilihan bahan yang berguna untuk .NET</a></li>
<li><a href="../id418521/index.html">Tabir kerahasiaan atas peluncuran dari Alaska</a></li>
<li><a href="../id418523/index.html">Mengapa pengecer "menguping" pada karyawan mereka dan mengapa mereka masih menggunakan teknologi audio</a></li>
<li><a href="../id418525/index.html">Opera go public</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>