<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘ ğŸ¤ ğŸ’§ Mengelola Asynchrony dalam PHP: From Promises to Coroutines ğŸ…¿ï¸ ğŸ¤²ğŸ¾ ğŸ‘©ğŸ½â€ğŸ¤â€ğŸ‘©ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa itu asinkron? Singkatnya, asinkron berarti melakukan beberapa tugas selama periode waktu tertentu. PHP berjalan dalam satu utas, yang berarti hany...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mengelola Asynchrony dalam PHP: From Promises to Coroutines</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skyeng/blog/453296/"><p><img src="https://habrastorage.org/webt/ud/ah/t9/udaht9uat9o8n1cj2y_uwpzhbqw.jpeg"></p><br><p>  Apa itu asinkron?  Singkatnya, asinkron berarti melakukan beberapa tugas selama periode waktu tertentu.  PHP berjalan dalam satu utas, yang berarti hanya satu bagian dari kode PHP yang dapat dieksekusi pada waktu tertentu.  Ini mungkin tampak seperti batasan, tetapi sebenarnya memberi kita lebih banyak kebebasan.  Akibatnya, kami tidak harus menghadapi semua kompleksitas yang terkait dengan pemrograman multithreaded.  Namun di sisi lain, ada satu set masalah.  Kita harus berurusan dengan asinkron.  Kita perlu entah bagaimana mengaturnya dan mengoordinasinya. </p><br><p>  <em>Memperkenalkan terjemahan sebuah artikel dari blog pengembang backend Skyeng, Sergey Zhuk.</em> </p><a name="habracut"></a><br><p>  Misalnya, ketika kami menjalankan dua permintaan HTTP paralel, kami mengatakan bahwa mereka "berjalan secara paralel."  Ini biasanya mudah dan sederhana untuk dilakukan, tetapi masalah muncul ketika kita perlu merampingkan respons dari permintaan ini, misalnya, ketika satu permintaan membutuhkan data yang diterima dari permintaan lain.  Dengan demikian, dalam manajemen asinkron itulah kesulitan terbesar terletak.  Ada beberapa cara berbeda untuk menyelesaikan masalah ini. </p><br><blockquote>  Saat ini tidak ada dukungan bawaan untuk abstraksi tingkat tinggi untuk mengelola asinkron di PHP, dan kami harus menggunakan perpustakaan pihak ketiga seperti ReactPHP dan Amp.  Dalam contoh di artikel ini, saya menggunakan ReactPHP. </blockquote><br><h3>  Janji </h3><br><p>  Untuk lebih memahami gagasan tentang janji, sebuah contoh kehidupan nyata akan berguna.  Bayangkan Anda berada di McDonald's dan ingin melakukan pemesanan.  Anda membayar uang untuk itu dan dengan demikian memulai transaksi.  Menanggapi transaksi ini, Anda berharap mendapatkan hamburger dan kentang goreng.  Namun kasir tidak segera mengembalikan makanan.  Sebagai gantinya, Anda menerima cek dengan nomor pesanan.  Anggap cek ini sebagai janji untuk pesanan di masa mendatang.  Sekarang Anda dapat mengambil cek ini dan mulai memikirkan makan siang lezat Anda.  Hamburger yang diharapkan dan kentang goreng belum siap, jadi Anda berdiri dan menunggu sampai pesanan Anda selesai.  Segera setelah nomornya muncul di layar, Anda akan menukar cek untuk pesanan Anda.  Inilah janjinya: </p><br><blockquote>  <i>Pengganti nilai masa depan.</i> </blockquote><p>  Sebuah janji adalah representasi untuk makna masa depan, pembungkus mandiri waktu yang kita bungkus makna.  Kami tidak peduli apakah nilainya sudah ada di sini atau belum.  Kami terus memikirkannya dengan cara yang sama.  Bayangkan bahwa kita memiliki tiga permintaan HTTP asinkron yang dijalankan "secara paralel", sehingga permintaan itu akan diselesaikan pada satu titik waktu.  Tetapi kami ingin mengoordinasikan dan mengatur jawaban mereka.  Misalnya, kami ingin mencetak jawaban ini segera setelah diterima, tetapi dengan sedikit batasan: jangan cetak jawaban kedua sampai jawaban pertama diterima.  Maksud saya di sini adalah jika <b>$ janji1</b> terpenuhi, maka kita mencetaknya.  Tetapi jika <b>$ janji2</b> dipenuhi terlebih dahulu, kami tidak mencetaknya, karena <b>$ janji1</b> masih dalam proses.  Bayangkan kita mencoba mengadaptasi tiga permintaan kompetitif sedemikian rupa sehingga bagi pengguna akhir mereka terlihat seperti satu permintaan cepat. </p><br><p>  Jadi, bagaimana kita bisa menyelesaikan masalah ini dengan janji?  Pertama-tama, kita membutuhkan fungsi yang mengembalikan janji.  Kita bisa mengumpulkan tiga janji seperti itu dan kemudian menyatukannya.  Berikut ini beberapa kode palsu untuk ini: </p><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fakeResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url, callable $callback)</span></span></span><span class="hljs-function"> </span></span>{ $callback(<span class="hljs-string"><span class="hljs-string">"response for $url"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeRequest</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string $url)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(callable $resolve)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($url)</span></span></span><span class="hljs-function"> </span></span>{ fakeResponse($url, $resolve); }); }</code> </pre> <br><p>  Di sini saya memiliki dua fungsi: <br>  <b>fakeResponse (string $ url, callable $ callback)</b> berisi respons yang tersandikan dan memungkinkan panggilan balik yang ditentukan dengan jawaban ini; <br>  <b>makeRequest (string $ url)</b> mengembalikan janji yang menggunakan <b>fakeResponse ()</b> untuk menunjukkan bahwa permintaan telah selesai. </p><br><p>  Dari kode klien, kami cukup memanggil <b>fungsi makeRequest ()</b> dan mendapatkan janji: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url1'</span></span>); $promise2 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url2'</span></span>); $promise3 = makeRequest(<span class="hljs-string"><span class="hljs-string">'url3'</span></span>);</code> </pre> <br><p>  Itu sederhana, tetapi sekarang kita perlu mengurutkan jawaban ini entah bagaimana.  Sekali lagi, kami ingin tanggapan dari janji kedua akan dicetak hanya setelah penyelesaian yang pertama.  Untuk mengatasi masalah ini, Anda dapat membangun rantai janji: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Dalam kode di atas, kita mulai dengan <b>$ janji1</b> .  Setelah selesai, kami mencetak nilainya.  Kami tidak peduli berapa lama: kurang dari satu detik atau satu jam.  Segera setelah janji itu selesai, kami akan mencetak nilainya.  Dan kemudian kita menunggu <b>$ janji2</b> .  Dan di sini kita dapat memiliki dua skenario: </p><br><p>  <b>$ janji2</b> sudah selesai, dan kami segera mencetak nilainya; <br>  <b>$ janji2</b> masih terpenuhi, dan kami sedang menunggu. </p><br><p>  Berkat rantai janji-janji, kita tidak perlu lagi khawatir apakah janji telah dipenuhi atau tidak.  Promis tidak tergantung pada waktu, dan karenanya menyembunyikan statusnya dari kami (dalam proses, sudah selesai atau dibatalkan). </p><br><p>  Ini adalah bagaimana Anda dapat mengontrol asinkron dengan janji.  Dan itu tampak hebat, rantai janji jauh lebih cantik dan lebih bisa dipahami daripada banyak panggilan balik bersarang. </p><br><h3>  Generator </h3><br><p>  Di PHP, generator adalah dukungan bahasa bawaan untuk fungsi yang dapat dijeda dan kemudian dilanjutkan.  Ketika eksekusi kode di dalam generator berhenti, itu tampak seperti program kecil yang diblokir.  Tetapi di luar program ini, di luar generator, semua yang lain terus bekerja.  Ini semua keajaiban dan kekuatan generator. </p><br><p>  Kami benar-benar dapat menghentikan generator secara lokal untuk menunggu janji untuk menyelesaikan.  Ide dasarnya adalah menggunakan janji dan generator bersama.  Mereka mengambil alih kendali asynchrony, dan kami hanya memanggil hasil ketika kami perlu menangguhkan generator.  Berikut adalah program yang sama, tetapi sekarang kami menghubungkan generator dan janji: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { $promise1 = makeRequest('url1'); $promise2 = makeRequest('url2'); $promise3 = makeRequest('url3'); var_dump(yield $promise1); var_dump(yield $promise2); var_dump(yield $promise3); });</span></span></code> </pre> <br><blockquote>  <i>Untuk kode ini, saya menggunakan library <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">recoilphp / recoil</a> , yang memungkinkan Anda memanggil <b>ReactKernel :: start ()</b> .</i>  <i>Recoil memungkinkan untuk menggunakan generator PHP untuk menjalankan janji asinkron ReactPHP.</i> </blockquote><p>  Di sini, kami masih melakukan tiga kueri secara paralel, tetapi sekarang kami menyortir respons menggunakan kata kunci <b>hasil</b> .  Dan lagi, kami menampilkan hasilnya di akhir setiap janji, tetapi hanya setelah yang sebelumnya. </p><br><h3>  Coroutine </h3><br><p>  Coroutine adalah cara membagi operasi atau proses menjadi potongan-potongan, dengan beberapa eksekusi di dalam setiap potongan tersebut.  Akibatnya, ternyata alih-alih melakukan seluruh operasi pada satu waktu (yang dapat menyebabkan pembekuan aplikasi yang nyata), itu akan dilakukan secara bertahap sampai semua jumlah pekerjaan yang diperlukan telah selesai. </p><br><p>  Sekarang kita memiliki generator interruptible dan terbarukan, kita dapat menggunakannya untuk menulis kode asinkron dengan janji-janji dalam bentuk sinkron yang lebih akrab.  Menggunakan generator dan janji-janji PHP, Anda dapat sepenuhnya menyingkirkan panggilan balik.  Idenya adalah bahwa ketika kita memberikan janji (menggunakan panggilan yield), coroutine berlangganan.  Corutin berhenti dan menunggu sampai janji selesai (selesai atau dibatalkan).  Begitu janji itu selesai, coroutine akan terus memenuhi.  Setelah berhasil diselesaikan, janji coroutine mengirimkan nilai yang diterima kembali ke konteks generator menggunakan panggilan <b>Generator :: send ($ value)</b> .  Jika janji gagal, maka Corutin melempar pengecualian melalui generator menggunakan panggilan <b>Generator :: throw ()</b> .  Dengan tidak adanya panggilan balik, kita dapat menulis kode asinkron yang terlihat hampir seperti yang biasa sinkron. </p><br><p>  <b>Eksekusi berurutan</b> </p><br><p>  Saat menggunakan coroutine, urutan eksekusi dalam kode asinkron sekarang penting.  Kode dieksekusi tepat ke tempat di mana kata kunci hasil dipanggil dan kemudian dijeda sampai janji selesai.  Pertimbangkan kode berikut: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... ReactKernel::start(function () { echo 'Response 1: ', yield makeRequest('url1'), PHP_EOL; echo 'Response 2: ', yield makeRequest('url2'), PHP_EOL; echo 'Response 3: ', yield makeRequest('url3'), PHP_EOL; });</span></span></code> </pre> <br><p>  <b>Promise1:</b> akan ditampilkan di <b>sini</b> , kemudian eksekusi berhenti dan menunggu.  Segera setelah janji dari <b>makeRequest ('url1')</b> selesai, kami mencetak hasilnya dan beralih ke baris kode berikutnya. </p><br><p>  <b>Menangani kesalahan</b> </p><br><p>  Standar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Janji / A +</a> Janji menyatakan bahwa masing-masing Janji berisi metode <b>maka () dan menangkap ()</b> .  Antarmuka ini memungkinkan Anda membangun rantai dari janji dan secara opsional menangkap kesalahan.  Pertimbangkan kode berikut: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> operation()-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> anotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> yetAnotherOperation($result); })-&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $result; });</code> </pre> <br><p>  Di sini kita memiliki rantai janji yang meneruskan hasil dari setiap janji sebelumnya ke janji berikutnya.  Tetapi tidak ada blok <b>catch ()</b> di rantai ini, tidak ada penanganan kesalahan di sini.  Ketika janji dalam rantai gagal, eksekusi kode bergerak ke penangan kesalahan terdekat di rantai.  Dalam kasus kami, ini berarti bahwa janji yang beredar akan diabaikan, dan kesalahan yang terjadi akan hilang selamanya.  Dengan coroutine, penanganan kesalahan muncul kedepan.  Jika operasi asinkron gagal, pengecualian akan dilemparkan: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Recoil</span></span>\<span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">ReactKernel</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">React</span></span>\<span class="hljs-title"><span class="hljs-title">Promise</span></span>\<span class="hljs-title"><span class="hljs-title">RejectedPromise</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ... function failedOperation() { return new RejectedPromise(new RuntimeException('Something went wrong')); } ReactKernel::start(function () { try { yield failedOperation(); } catch (Throwable $error) { echo $error-&gt;getMessage() . PHP_EOL; } });</span></span></code> </pre> <br><h3>  Membuat Kode Asinkron Dapat Dibaca </h3><br><p>  Generator memiliki efek samping yang sangat penting yang dapat kita gunakan untuk mengontrol asinkron dan yang memecahkan masalah keterbacaan kode asinkron.  Sulit bagi kita untuk memahami bagaimana kode asinkron akan dieksekusi karena fakta bahwa utas eksekusi terus-menerus berpindah di antara berbagai bagian program.  Namun, otak kita pada dasarnya bekerja secara sinkron dan single-threaded.  Sebagai contoh, kami merencanakan hari kami dengan sangat konsisten: melakukan satu, lalu yang lain, dan seterusnya.  Tetapi kode asinkron tidak berfungsi sebagaimana otak kita terbiasa berpikir.  Bahkan rantai janji yang sederhana mungkin tidak terlihat terlalu mudah dibaca: </p><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $promise1 -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise2; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($promise3)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $promise3; }) -&gt;then(<span class="hljs-string"><span class="hljs-string">'var_dump'</span></span>) -&gt;then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">'Complete'</span></span>; });</code> </pre> <br><p>  Kita harus membongkar secara mental untuk memahami apa yang terjadi di sana.  Jadi kita perlu pola yang berbeda untuk mengontrol asinkron.  Singkatnya, generator menyediakan cara untuk menulis kode asinkron sehingga terlihat seperti sinkron. </p><br><p>  Janji dan generator menggabungkan yang terbaik dari kedua dunia: kita mendapatkan kode asinkron dengan kinerja hebat, tetapi pada saat yang sama itu tampak seperti sinkron, linier, dan berurutan.  Coroutine memungkinkan Anda untuk menyembunyikan asinkron, yang sudah menjadi detail implementasi.  Dan kode kita pada saat yang sama terlihat seperti otak kita terbiasa berpikir - secara linear dan berurutan. </p><br><p>  Jika kita berbicara tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ReactPHP</a> , maka kita dapat menggunakan pustaka RecoilPHP untuk menulis janji dalam bentuk coroutine.  Dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Amp,</a> coroutine tersedia langsung di luar kotak. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id453296/">https://habr.com/ru/post/id453296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id453280/index.html">Utang teknis</a></li>
<li><a href="../id453286/index.html">Kesalahan paling mahal dalam hidup saya: detail tentang serangan pada port kartu SIM</a></li>
<li><a href="../id453290/index.html">Intisari Ilmu Data (Mei 2019)</a></li>
<li><a href="../id453292/index.html">"Sebuah buku kecil tentang lubang hitam"</a></li>
<li><a href="../id453294/index.html">Bereaksi Pemuatan malas</a></li>
<li><a href="../id453298/index.html">Musim panas: waktu upgrade ... diri Anda sendiri</a></li>
<li><a href="../id453300/index.html">Game 3D Shaders untuk Pemula</a></li>
<li><a href="../id453302/index.html">Jam pertama kehidupan bersama Yandex.Module</a></li>
<li><a href="../id453304/index.html">Manfaat Utama dari Zextras PowerStore</a></li>
<li><a href="../id453306/index.html">Kubernetes akan mengambil alih dunia. Kapan dan bagaimana?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>