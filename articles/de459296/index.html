<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÜ ü§ûüèΩ ‚úñÔ∏è JavaScript Preis 2019 üöΩ üëåüèª üëö</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten Jahren hat sich der sogenannte ‚Äû JavaScript-Preis ‚Äú aufgrund der erh√∂hten Analysegeschwindigkeit und der Browser-Kompilierung von Skrip...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript Preis 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/459296/">  In den letzten Jahren hat sich der sogenannte ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Preis</a> ‚Äú aufgrund der erh√∂hten Analysegeschwindigkeit und der Browser-Kompilierung von Skripten erheblich positiv ver√§ndert.  Jetzt, im Jahr 2019, sind die Hauptkomponenten der Auslastung der von JavaScript erstellten Systeme die Ladezeit der Skripte und ihre Ausf√ºhrungszeit. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/7x/g6/g_/7xg6g_poas_6_4qwu5u4clgjxrs.jpeg"></a> <br><br>  Die Interaktion des Benutzers mit der Site kann vor√ºbergehend unterbrochen werden, wenn der Browser gerade JavaScript-Code ausf√ºhrt.  Infolgedessen k√∂nnen wir sagen, dass die Optimierung von Engp√§ssen beim Laden und Ausf√ºhren von Skripten einen starken positiven Einfluss auf die Leistung der Website haben kann. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Allgemeine praktische Richtlinien f√ºr die Website-Optimierung</font> </h2><br>  Was bedeutet das oben Genannte f√ºr Webentwickler?  Der Punkt hier ist, dass die Kosten f√ºr Ressourcen zum Parsen (Parsen, Parsen) und Kompilieren von Skripten nicht so hoch sind wie zuvor.  Daher sollten Entwickler bei der Analyse und Optimierung von JavaScript-Bundles die folgenden drei Empfehlungen ber√ºcksichtigen: <br><br><ol><li>  Versuchen Sie, die zum Herunterladen von Skripten erforderliche Zeit zu verk√ºrzen. <br><br><ul><li>  Versuchen Sie, Ihre JS-Bundles klein zu halten.  Dies ist besonders wichtig f√ºr Websites, die f√ºr mobile Ger√§te entwickelt wurden.  Die Verwendung kleiner Bundles verbessert die Ladezeit des Codes, verringert die Speichernutzung und verringert die Belastung des Prozessors. </li><li>  Versuchen Sie zu verhindern, dass der gesamte Projektcode als ein einziges gro√ües Paket dargestellt wird.  Wenn die B√ºndelgr√∂√üe ungef√§hr 50-100 Kb √ºberschreitet, teilen Sie sie in separate Fragmente kleiner Gr√∂√üe.  Dank HTTP / 2-Multiplexing k√∂nnen mehrere Serveranforderungen und mehrere Antworten gleichzeitig verarbeitet werden.  Dies reduziert die Belastung des Systems, die mit der Notwendigkeit verbunden ist, zus√§tzliche Anforderungen zum Laden von Daten zu erf√ºllen. </li><li>  Wenn Sie an einem mobilen Projekt arbeiten, versuchen Sie, den Code so klein wie m√∂glich zu halten.  Diese Empfehlung ist mit niedrigen Datenraten √ºber Mobilfunknetze verbunden.  Streben Sie au√üerdem nach einer sparsamen Nutzung des Speichers. </li></ul></li><li>  Versuchen Sie, die zum Ausf√ºhren von Skripten erforderliche Zeit zu verk√ºrzen. <br><br><ul><li> Vermeiden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">langwierige Aufgaben</a> , die den Hauptthread √ºber einen l√§ngeren Zeitraum laden k√∂nnen, und erh√∂hen Sie die Zeit, die erforderlich ist, damit sich die Seiten in einem Zustand befinden, in dem Benutzer mit ihnen interagieren k√∂nnen.  In der aktuellen Umgebung tragen Skripte, die nach dem Laden ausgef√ºhrt werden, wesentlich zum "Preis von JavaScript" bei. </li></ul></li><li>  Betten Sie keine gro√üen Codefragmente in Seiten ein. <br><br><ul><li>  Die folgende Regel sollte hier eingehalten werden: Wenn die Skriptgr√∂√üe 1 KB √ºberschreitet, versuchen Sie, sie nicht in den Seitencode einzubetten.  Einer der Gr√ºnde f√ºr diese Empfehlung ist die Tatsache, dass 1 KB die Grenze ist, nach der das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwischenspeichern</a> von externem Skriptcode in Chrome funktioniert.  Beachten Sie au√üerdem, dass das Parsen und Kompilieren eingebetteter Skripte weiterhin im Hauptthread ausgef√ºhrt wird. </li></ul></li></ol><br><h2>  <font color="#3AC1EF">Warum ist es so wichtig, Skripte zu laden und auszuf√ºhren?</font> </h2><br>  Warum ist es wichtig, die Lade- und Ausf√ºhrungszeit von Skripten unter modernen Bedingungen zu optimieren?  Die Ladezeiten von Skripten sind in Situationen √§u√üerst wichtig, in denen auf Websites √ºber langsame Netzwerke zugegriffen wird.  Trotz der Tatsache, dass sich 4G-Netze (und sogar 5G) immer mehr verbreiten, zeigt die Eigenschaft <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">NetworkInformation.effectiveType</a> in vielen F√§llen bei Verwendung mobiler Internetverbindungen Indikatoren an, die sich auf der Ebene von 3G-Netzen oder sogar auf niedrigeren Ebenen befinden. <br><br>  Die zur Ausf√ºhrung des JS-Codes erforderliche Zeit ist f√ºr mobile Ger√§te mit langsamen Prozessoren wichtig.  Aufgrund der Tatsache, dass mobile Ger√§te unterschiedliche CPUs und GPUs verwenden, und aufgrund der Tatsache, dass bei √úberhitzung von Ger√§ten zum Schutz der Leistung die Leistung ihrer Komponenten abnimmt, k√∂nnen Sie eine gravierende L√ºcke zwischen der Leistung teurer und billiger Telefone und Tablets feststellen.  Dies wirkt sich stark auf die Leistung von JavaScript-Code aus, da die F√§higkeit, solchen Code von einem Ger√§t auszuf√ºhren, durch die Prozessorf√§higkeiten dieses Ger√§ts eingeschr√§nkt ist. <br><br>  Wenn wir die Gesamtzeit analysieren, die zum Laden und Vorbereiten der Seite f√ºr die Arbeit in einem Browser wie Chrome aufgewendet wurde, k√∂nnen etwa 30% dieser Zeit f√ºr die Ausf√ºhrung von JS-Code aufgewendet werden.  Im Folgenden finden Sie eine Analyse des Ladens einer sehr typischen Webseite (reddit.com) auf einem Hochleistungs-Desktop-Computer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/8f6/af0/31d8f6af06d7158ecc9bd17710d216bb.png"></div><br>  <i><font color="#999999">Beim Laden der Seite werden etwa 10 bis 30% der Zeit f√ºr die Codeausf√ºhrung mit V8 aufgewendet</font></i> <br><br>  Wenn wir √ºber mobile Ger√§te sprechen, dauert es auf einem durchschnittlichen Telefon (Moto G4) 3-4 Mal l√§nger, reddit.com auf einem JS-Code auszuf√ºhren als auf einem High-Level-Ger√§t (Pixel 3).  Auf einem schwachen Ger√§t (Alcatel 1X kostet weniger als 100 US-Dollar) erfordert die L√∂sung des gleichen Problems mindestens sechsmal mehr Zeit als bei Pixel 3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/71a/4f0/3a9/71a4f03a9f7d673740c6917f30cee360.png"></div><br>  <i><font color="#999999">Die Zeit, die zum Verarbeiten von JS-Code auf Mobilger√§ten verschiedener Klassen ben√∂tigt wird</font></i> <br><br>  Bitte beachten Sie, dass die mobilen und Desktop-Versionen von reddit.com unterschiedlich sind.  Daher k√∂nnen Sie die Ergebnisse von Mobilger√§ten und beispielsweise MacBook Pro nicht vergleichen. <br><br>  Wenn Sie versuchen, die Ausf√ºhrungszeit von JavaScript-Code zu optimieren, achten Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">langwierige Aufgaben</a> , die den UI-Stream f√ºr lange Zeit erfassen k√∂nnen.  Diese Aufgaben k√∂nnen die Ausf√ºhrung anderer, √§u√üerst wichtiger Aufgaben behindern, selbst wenn das Erscheinungsbild der Seite vollst√§ndig arbeitsbereit erscheint.  Langzeitaufgaben sollten in kleinere Aufgaben unterteilt werden.  Indem Sie den Code in Teile aufteilen und die Ladereihenfolge dieser Teile steuern, k√∂nnen Sie erreichen, dass Seiten schneller in einen interaktiven Zustand versetzt werden.  Dies f√ºhrt hoffentlich dazu, dass Benutzer weniger Schwierigkeiten bei der Interaktion mit Seiten haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/002/eef/32b/002eef32b869be9ae677bc41b41c86c2.png"></div><br>  <i><font color="#999999">Lang laufende Aufgaben erfassen den Hauptthread.</font></i>  <i><font color="#999999">Sie sollten in St√ºcke zerbrochen werden</font></i> <br><br><h2>  <font color="#3AC1EF">Wie beschleunigen V8-Verbesserungen das Parsen und Kompilieren von Skripten?</font> </h2><br>  Die Geschwindigkeit beim Parsen des JS-Quellcodes in V8 hat sich seit Chrome 60 um das Zweifache erh√∂ht.  Gleichzeitig tragen Parsen und Kompilieren jetzt weniger zum "JavaScript-Preis" bei.  Dies ist anderen Optimierungsbem√ºhungen von Chrome zu verdanken, die zur Parallelisierung dieser Aufgaben gef√ºhrt haben. <br><br>  In V8 wird der Aufwand f√ºr das Parsen und Kompilieren von Code im Hauptthread um durchschnittlich 40% reduziert.  F√ºr Facebook betrug die Verbesserung dieses Indikators beispielsweise 46%, f√ºr Pinterest 62%.  Das h√∂chste Ergebnis, 81%, wurde f√ºr YouTube erzielt.  Solche Ergebnisse sind m√∂glich, weil Parsing und Kompilierung in einen separaten Stream verschoben werden.  Dies gilt zus√§tzlich zu den bestehenden Verbesserungen hinsichtlich der Streaming-L√∂sung derselben Aufgaben au√üerhalb des Hauptstroms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a7/41e/24c/4a741e24c05a9149d98ee568be74b564.png"></div><br>  <i><font color="#999999">JS-Analysezeit in verschiedenen Versionen von Chrome</font></i> <br><br>  Sie k√∂nnen auch visualisieren, wie sich die in verschiedenen Chrome-Versionen vorgenommenen V8-Optimierungen auf die f√ºr die Verarbeitung des Codes erforderliche Prozessorzeit auswirken.  In der gleichen Zeit, in der Chrome 61 den Facebook JS-Code analysieren musste, kann Chrome 75 jetzt den Facebook JS-Code und zus√§tzlich den Twitter-Code sechsmal analysieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6b/000/0e0/c6b0000e0b2bb98087ff12f8a9eb0d97.png"></div><br>  <i><font color="#999999">In der Zeit, die Chrome 61 f√ºr die Verarbeitung von Facebook JS-Code ben√∂tigte, kann Chrome 75 sowohl Facebook-Code als auch die sechsfache Menge an Twitter-Code verarbeiten.</font></i> <br><br>  Lassen Sie uns dar√ºber sprechen, wie solche Verbesserungen erzielt wurden.  Kurz gesagt, die Skriptressourcen k√∂nnen im Streaming-Modus des Workflows analysiert und kompiliert werden.  Dies bedeutet Folgendes: <br><br><ul><li>  V8 kann JS-Code analysieren und kompilieren, ohne den Hauptthread zu blockieren. </li><li> Die Stream-Verarbeitung des Skripts beginnt, wenn der universelle HTML-Parser auf das <code>&lt;script&gt;</code> st√∂√üt.  Ein HTML-Parser verarbeitet Skripte, die das Parsen von Seiten blockieren.  Er trifft auf asynchrone Skripte und arbeitet weiter. </li><li>  In den meisten realen Szenarien, die durch bestimmte Netzwerkverbindungsgeschwindigkeiten gekennzeichnet sind, analysiert der V8 den Code schneller, als er laden kann.  Infolgedessen f√ºhrt V8 die Aufgaben des Parsens und Kompilierens des Codes einige Millisekunden nach dem Laden der letzten Bytes des Skripts aus. </li></ul><br>  Wenn Sie dar√ºber etwas ausf√ºhrlicher sprechen, lautet der Punkt hier wie folgt.  In viel √§lteren Versionen von Chrome musste das Skript vollst√§ndig heruntergeladen werden, bevor es analysiert werden konnte.  Dieser Ansatz ist einfach und verst√§ndlich, aber wenn er verwendet wird, werden Prozessorressourcen irrational verwendet.  Chrome zwischen den Versionen 41 und 68 beginnt unmittelbar nach dem Laden des Skripts im asynchronen Modus mit dem Parsen und f√ºhrt diese Aufgabe in einem separaten Thread aus. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/574/43a/4fd/57443a4fd274a348de26652d006941c3.png"></div><br>  <i><font color="#999999">Skripte werden fragmentarisch an den Browser gesendet.</font></i>  <i><font color="#999999">V8 beginnt mit der Streaming-Datenverarbeitung, nachdem mindestens 30 KB Code vorhanden sind.</font></i> <br><br>  In Chrome 71 sind wir zu einem aufgabenbasierten System √ºbergegangen.  Hier kann der Scheduler gleichzeitig mehrere asynchrone / verz√∂gerte Skriptverarbeitungssitzungen starten.  Aufgrund dieser √Ñnderung hat sich die durch das Parsen des Hauptthreads erzeugte Last um etwa 20% verringert.  Dies f√ºhrte zu einer Verbesserung der TTI / FID-Werte an realen Standorten um etwa 2%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3f/161/863/a3f16186348f3773a04f7caccc185592.png"></div><br>  <i><font color="#999999">Chrome 71 verwendet ein aufgabenbasiertes Codeverarbeitungssystem.</font></i>  <i><font color="#999999">Mit diesem Ansatz kann der Scheduler mehrere asynchrone / ausstehende Skripts gleichzeitig verarbeiten.</font></i> <br><br>  In Chrome 72 haben wir die Streaming-Verarbeitung zur prim√§ren Methode zum Parsen von Skripten gemacht.  Jetzt werden sogar regul√§re synchrone Skripte auf diese Weise behandelt (obwohl dies nicht f√ºr integrierte Skripte gilt).  Au√üerdem haben wir das Abbrechen von aufgabenbasierten Analysevorg√§ngen eingestellt, wenn der Hauptthread analysierten Code ben√∂tigte.  Dies geschieht aufgrund der Tatsache, dass dies dazu f√ºhrt, dass ein Teil der bereits geleisteten Arbeit erneut ausgef√ºhrt werden muss. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die vorherige Version von Chrome</a> unterst√ºtzte das Streaming-Parsing und die Stream-Kompilierung von Code.  Dann sollte das aus dem Netzwerk heruntergeladene Skript zuerst in den Hauptstrom gelangen und dann zum Verarbeitungssystem f√ºr Streaming-Skripte umgeleitet werden. <br><br>  Dies f√ºhrte h√§ufig dazu, dass der Stream-Parser auf Daten wartete, die bereits aus dem Netzwerk heruntergeladen, aber noch nicht vom Haupt-Stream zur Stream-Verarbeitung umgeleitet wurden.  Dies geschah aufgrund der Tatsache, dass der Hauptthread m√∂glicherweise mit einigen anderen Aufgaben besch√§ftigt war (z. B. Parsen von HTML, Erstellen eines Seitenlayouts oder Ausf√ºhren von JS-Code). <br><br>  Jetzt experimentieren wir damit, wie Sie beim Vorladen von Seiten mit dem Parsen von Code beginnen.  Bisher wurde die Implementierung eines solchen Mechanismus durch die Notwendigkeit behindert, die Ressourcen des Hauptthreads zum √úbertragen von Aufgaben an den Streaming-Parser zu verwenden.  Details zum Parsen von JS-Code, der "sofort" ausgef√ºhrt wird, finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">Wie haben sich die Verbesserungen auf das ausgewirkt, was in den Tools des Entwicklers zu sehen ist?</font> </h2><br>  Zus√§tzlich zu dem oben Gesagten kann festgestellt werden, dass es zuvor ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Problem</a> in den Entwicklertools gab.  Es bestand darin, dass Informationen √ºber die Aufgabe des Parsens so angezeigt wurden, als w√ºrden sie den Hauptthread vollst√§ndig blockieren.  Der Parser f√ºhrte jedoch nur Operationen aus, die den Hauptthread blockierten, wenn neue Daten ben√∂tigt wurden.  Da wir von dem Schema der Verwendung eines einzelnen Streams f√ºr die Streaming-Datenverarbeitung zu dem Schema √ºbergegangen sind, in dem Streaming-Verarbeitungsaufgaben angewendet werden, ist dies ziemlich offensichtlich geworden.  Folgendes k√∂nnen Sie in Chrome 69 sehen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87c/b4c/ab0/87cb4cab05a3c00e7b21dfc25524a9c8.png"></div><br>  <i><font color="#999999">Das Problem liegt in den Entwicklertools, aufgrund derer Informationen zu Parsing-Skripten angezeigt wurden, als w√ºrden sie den Hauptthread vollst√§ndig blockieren</font></i> <br><br>  Hier sehen Sie, dass die Aufgabe "Parse Script" 1,08 Sekunden dauert.  Das Parsen von JavaScript ist jedoch nicht so langsam!  Meistens wird nichts N√ºtzliches ausgef√ºhrt, au√üer auf Daten vom Hauptthread zu warten. <br>  In Chrome 76 sehen Sie bereits ein v√∂llig anderes Bild. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/874/e37/ef8874e37664a31f03c822c71feb0fa8.png"></div><br>  <i><font color="#999999">In Chrome 76 ist das Parsen in viele kleine Aufgaben unterteilt</font></i> <br><br>  Im Allgemeinen kann festgestellt werden, dass die Registerkarte Leistung der Entwicklertools gro√üartig ist, um das Gesamtbild der Vorg√§nge auf der Seite anzuzeigen.  Um detailliertere Informationen zu den Funktionen von V8 zu erhalten, z. B. Analysezeit und Kompilierungszeit, k√∂nnen Sie Chrome Tracing mit RCS-Unterst√ºtzung (Runtime Call Stats) verwenden.  In den empfangenen RCS-Daten finden Sie die Indikatoren Parse-Background und Compile-Background.  Sie k√∂nnen angeben, wie lange es gedauert hat, den JS-Code au√üerhalb des Hauptthreads zu analysieren und zu kompilieren.  Die Metriken "Analysieren" und "Kompilieren" geben an, wie viel Zeit f√ºr verwandte Aktivit√§ten im Hauptthread aufgewendet wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3a4/200/d26/3a4200d269fe47bedac1d84c27722a2b.png"></div><br>  <i><font color="#999999">Analyse von RCS-Daten mit Google Tracing</font></i> <br><br><h2>  <font color="#3AC1EF">Wie haben sich die √Ñnderungen auf die Arbeit mit realen Websites ausgewirkt?</font> </h2><br>  Schauen wir uns einige Beispiele an, wie die Verarbeitung von Streaming-Skripten das Surfen auf realen Websites beeinflusst hat. <br><br><h3>  <font color="#3AC1EF">¬ªReddit</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/4ba/270/d774ba2709a772bbcfb26294b67ab385.png"></div><br>  <i><font color="#999999">Zeigen Sie reddit.com auf einem MacBook Pro an.</font></i>  <i><font color="#999999">Zeit zum Parsen und Kompilieren von JS-Code, der im Haupt- und im Arbeitsthread verbracht wird</font></i> <br><br>  Auf der reddit.com-Website gibt es mehrere JS-Bundles, von denen jedes eine Gr√∂√üe von mehr als 100 KB hat.  Sie sind in externe Funktionen eingebunden, was zur Ausf√ºhrung gro√üer Mengen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"fauler" Kompilierungen</a> im Hauptthread f√ºhrt.  Entscheidend im obigen Diagramm ist die Zeit, die erforderlich ist, um die Skripte im Hauptthread zu verarbeiten.  Dies liegt an der Tatsache, dass eine gro√üe Belastung des Hauptthreads die Zeit verl√§ngern kann, die die Seite ben√∂tigt, um in den interaktiven Modus zu wechseln.  Bei der Verarbeitung des reddit.com-Sitecodes wird die meiste Zeit im Hauptthread verbracht, und die Ressourcen des Arbeits- / Hintergrundthreads werden auf ein Minimum reduziert. <br><br>  Sie k√∂nnen diese Site optimieren, indem Sie einige gro√üe Bundles in Teile (jeweils ca. 50 KB) aufteilen und den Code nicht in eine Funktion einschlie√üen.  Dies w√ºrde die parallele Verarbeitung von Skripten maximieren.  Infolgedessen konnten Bundles im Streaming-Modus gleichzeitig analysiert und kompiliert werden.  Dies w√ºrde die Belastung des Hauptthreads beim Vorbereiten der Seite f√ºr die Arbeit verringern. <br><br><h3>  <font color="#3AC1EF">‚ñçFacebook</font> </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/d83/a53/bc2d83a53f5b73658168e3dba70c9a85.png"></div><br>  <i><font color="#999999">Zeigen Sie facebook.com auf Ihrem MacBook Pro an.</font></i>  <i><font color="#999999">Zeit zum Parsen und Kompilieren von JS-Code, der im Haupt- und im Arbeitsthread verbracht wird</font></i> <br><br>  Wir k√∂nnen auch eine Site wie facebook.com in Betracht ziehen, die etwa 6 MB komprimierten JS-Code verwendet.  Dieser Code wird mit ungef√§hr 292 Anforderungen geladen.  Einige von ihnen sind asynchron, andere zielen auf das Vorladen von Daten ab, andere haben eine niedrige Priorit√§t.  Die meisten Facebook-Skripte sind klein und eng fokussiert.  Dies kann sich durch Hintergrund- / Workflows positiv auf die parallele Datenverarbeitung auswirken.  Tatsache ist, dass viele kleine Skripte gleichzeitig durch Streaming-Skriptverarbeitung analysiert und kompiliert werden k√∂nnen. <br><br>  Bitte beachten Sie, dass sich Ihre Website wahrscheinlich von der Facebook-Website unterscheidet.  Sie haben wahrscheinlich keine Anwendungen, die lange Zeit ge√∂ffnet bleiben (z. B. eine Facebook-Website oder die Google Mail-Oberfl√§che), und wenn Sie mit ihnen arbeiten, kann das Herunterladen derart schwerwiegender Skriptmengen mit einem Desktop-Browser gerechtfertigt sein.  Trotzdem k√∂nnen wir eine allgemeine Empfehlung abgeben, die f√ºr alle Projekte fair ist.  Es liegt in der Tatsache, dass es sich lohnt, den Anwendungscode in bescheidene Bundles zu zerlegen, und dass Sie diese Bundles nur herunterladen m√ºssen, wenn sie ben√∂tigt werden. <br><br>  Obwohl die meisten Arbeiten zum Parsen und Kompilieren von JS-Code mithilfe von Streaming-Tools in einem Hintergrundthread ausgef√ºhrt werden k√∂nnen, erfordern einige Vorg√§nge immer noch einen Hauptthread.  Wenn der Haupt-Thread mit etwas besch√§ftigt ist, kann die Seite nicht auf Benutzerinteraktionen reagieren.  Daher wird empfohlen, die Auswirkungen des Ladens und Ausf√ºhrens von JS-Code auf UX-Sites zu ber√ºcksichtigen. <br><br>  Beachten Sie, dass nicht alle JavaScript-Engines und -Browser jetzt Skripte streamen und deren Laden optimieren.  Trotzdem hoffen wir, dass die oben beschriebenen allgemeinen Optimierungsprinzipien die Benutzererfahrung bei der Arbeit mit Websites verbessern k√∂nnen, die in einem der vorhandenen Browser angezeigt werden. <br><br><h2>  <font color="#3AC1EF">JSON-Analysepreis</font> </h2><br>  Das Parsen von JSON-Code kann viel effizienter sein als das Parsen von JavaScript-Code.  Die Sache ist, JSON-Grammatik ist viel einfacher als JavaScript-Grammatik.  Dieses Wissen kann angewendet werden, um die Vorbereitungsgeschwindigkeit f√ºr die Arbeit von Webanwendungen zu verbessern, die gro√üe Konfigurationsobjekte (wie Redux-Repositorys) verwenden, deren Struktur JSON-Code √§hnelt.  Als Ergebnis stellt sich heraus, dass Sie die Daten nicht als im Code eingebettete Objektliterale darstellen, sondern als Zeichenfolgen von JSON-Objekten darstellen und diese Objekte zur Laufzeit analysieren k√∂nnen. <br><br>  Der erste Ansatz mit JS-Objekten sieht folgenderma√üen aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-number"><span class="hljs-number">1337</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Der zweite Ansatz, bei dem JSON-Zeichenfolgen verwendet werden, umfasst die Verwendung solcher Konstrukte: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(<span class="hljs-string"><span class="hljs-string">'{"foo":42,"bar":1337}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// </span></span></code> </pre> <br>  Da Sie die JSON-Zeichenfolgenverarbeitung nur einmal ausf√ºhren m√ºssen, ist der Ansatz, der <code>JSON.parse</code> verwendet, viel schneller als die Verwendung von JavaScript-Objektliteralen.  Besonders - beim "kalten" Laden von Seiten.  Es wird empfohlen, JSON-Zeichenfolgen zu verwenden, um Objekte darzustellen, die bei 10 KB beginnen.  Wie bei jedem Leistungstipp sollte dieser Tipp jedoch nicht gedankenlos befolgt werden.  Bevor diese Technik zur Darstellung von Daten in der Produktion angewendet wird, m√ºssen Messungen durchgef√ºhrt und die tats√§chlichen Auswirkungen auf das Projekt bewertet werden. <br><br>  Die Verwendung von Objektliteralen als Speicher f√ºr gro√üe Datenmengen stellt eine weitere Bedrohung dar.  Der Punkt ist, dass das Risiko besteht, dass solche Literale zweimal verarbeitet werden k√∂nnen: <br><br><ol><li>  Der erste Verarbeitungsdurchlauf wird mit vorl√§ufiger Analyse des Literal durchgef√ºhrt. </li><li>  Der zweite Ansatz wird w√§hrend des "faulen" Parsens des Literals durchgef√ºhrt. </li></ol><br>  Sie k√∂nnen den ersten Durchgang der Verarbeitung von Objektliteralen nicht loswerden.  Gl√ºcklicherweise kann der zweite Durchgang vermieden werden, indem Objektliterale auf der obersten Ebene oder in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PIFE platziert werden</a> . <br><br><h2>  <font color="#3AC1EF">Was ist mit dem Parsen und Kompilieren von Code bei wiederholten Besuchen von Websites?</font> </h2><br>  Dank der V8-Funktionen zum Zwischenspeichern von Code und Bytecode ist es m√∂glich, die Site-Leistung f√ºr diese F√§lle zu optimieren, wenn Benutzer sie mehrmals besuchen.  Wenn ein Skript zum ersten Mal vom Server angefordert wird, l√§dt Chrome es herunter und √ºbergibt V8 zur Kompilierung.  Der Browser speichert au√üerdem die Datei dieses Skripts im Festplatten-Cache.  Wenn die zweite Anforderung zum Herunterladen derselben JS-Datei ausgef√ºhrt wird, nimmt Chrome sie aus dem Browser-Cache und √ºbergibt V8 erneut zum Kompilieren.  Diesmal wird der kompilierte Code jedoch serialisiert und als Metadaten an die zwischengespeicherte Skriptdatei angeh√§ngt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b78/216/702/b7821670255f45c9ec4a08217b495153.png"></div><br>  <i><font color="#999999">Code-Caching-System in V8</font></i> <br><br>  Wenn das Skript zum dritten Mal angefordert wird, nimmt Chrome sowohl die Datei als auch ihre Metadaten aus dem Cache und √ºbertr√§gt dann beide V8.  V8 deserialisiert die Metadaten und √ºberspringt daher m√∂glicherweise den Kompilierungsschritt.  Das Zwischenspeichern von Code wird ausgel√∂st, wenn Besuche auf der Site innerhalb von 72 Stunden durchgef√ºhrt werden.  Chrome verwendet auch die Strategie des gierigen Code-Caching, wenn ein Servicemitarbeiter zum Zwischenspeichern von Skripten verwendet wird.  Details zum Code-Caching finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Im Jahr 2019 sind das Laden und Ausf√ºhren von Skripten die wichtigsten Leistungsengp√§sse f√ºr Webseiten.  Um die Situation zu verbessern, bem√ºhen Sie sich, synchrone (integrierte) Skripte kleiner Gr√∂√üe zu verwenden, die f√ºr die Organisation der Benutzerinteraktion mit dem Teil der Seite erforderlich sind, der f√ºr ihn unmittelbar nach dem Laden sichtbar ist.  Es wird empfohlen, Skripte, die zur Wartung anderer Teile der Seiten verwendet werden, im verz√∂gerten Modus zu laden.  Brechen Sie gro√üe B√ºndel in kleine St√ºcke.  Dies erleichtert die Implementierung einer Strategie f√ºr die Arbeit mit Code, in deren Anwendung der Code nur geladen wird, wenn er ben√∂tigt wird und nur dort, wo er ben√∂tigt wird.  Dadurch werden die Funktionen von V8 maximiert, die auf die parallele Verarbeitung des Codes abzielen. <br><br>  Wenn Sie mobile Projekte entwickeln, sollten Sie sicherstellen, dass diese so wenig JS-Code wie m√∂glich verwenden.  Diese Empfehlung beruht auf der Tatsache, dass mobile Ger√§te normalerweise in relativ langsamen Netzwerken arbeiten.  Solche Ger√§te k√∂nnen au√üerdem hinsichtlich des verf√ºgbaren RAM und der verf√ºgbaren Prozessorressourcen begrenzt sein.  Versuchen Sie, ein Gleichgewicht zwischen der Zeit zu finden, die f√ºr die Vorbereitung der vom Netzwerk heruntergeladenen Skripte und die Verwendung des Caches erforderlich ist.  Dadurch wird der Umfang des Parsens und Kompilierens von Code au√üerhalb des Hauptthreads maximiert. <br><br>  <b>Liebe Leser!</b>  Optimieren Sie Ihre Webprojekte unter Ber√ºcksichtigung der Besonderheiten der JS-Code-Verarbeitung durch moderne Browser? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/rw/6v/yn/rw6vyn2bxx4usoqc39holmj2z8m.jpeg"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459296/">https://habr.com/ru/post/de459296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459284/index.html">Kurze Einf√ºhrung in die Priorisierung von Produktstrategien und Funktionen</a></li>
<li><a href="../de459286/index.html">Halbmetall-Wolfram-Tellurid - das Schweizer Messer des Tages der Nanotechnologie</a></li>
<li><a href="../de459288/index.html">Native Implementierung der ECS-Bibliothek</a></li>
<li><a href="../de459292/index.html">Testautomatisierung f√ºr mobile Anwendungen: Toolvergleich</a></li>
<li><a href="../de459294/index.html">Was ist wichtiger: eine Programmiersprache kennen oder ein Gesch√§ftsproblem l√∂sen k√∂nnen?</a></li>
<li><a href="../de459298/index.html">Winkel: Status im Jahr 2019</a></li>
<li><a href="../de459300/index.html">Quasar 1.0: Ein neues n√ºtzliches Tool f√ºr Vue-Entwickler und nicht nur f√ºr sie</a></li>
<li><a href="../de459302/index.html">Wiederholen fehlgeschlagener HTTP-Anforderungen in Angular</a></li>
<li><a href="../de459304/index.html">Angular Pitfall Bypass und Zeitersparnis</a></li>
<li><a href="../de459306/index.html">Server-Rendering in einer Umgebung ohne Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>