<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßóüèæ ü§õüèº üë©‚Äçüë©‚Äçüëß‚Äçüëß Gu√≠a de Node.js, Parte 8: Protocolos HTTP y WebSocket üî¶ ü•ì üôÜüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Node.js es una plataforma de servidor. La tarea principal del servidor es procesar las solicitudes de los clientes, en particular de los navegadores, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a de Node.js, Parte 8: Protocolos HTTP y WebSocket</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424557/">  Node.js es una plataforma de servidor.  La tarea principal del servidor es procesar las solicitudes de los clientes, en particular de los navegadores, de la manera m√°s r√°pida y eficiente posible.  La octava parte de la traducci√≥n del tutorial Node.js que publicamos hoy trata sobre HTTP y WebSocket. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Le aconsejamos que lea] Otras partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n general y primeros pasos</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript, V8, algunos trucos de desarrollo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hosting, REPL, trabajar con la consola, m√≥dulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos npm, package.json y package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">npm y npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bucle de eventos, pila de llamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programaci√≥n asincr√≥nica</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, Parte 8: Protocolos HTTP y WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, parte 9: trabajar con el sistema de archivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, Parte 10: M√≥dulos est√°ndar, flujos, bases de datos, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDF completo de la gu√≠a Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">¬øQu√© sucede al hacer solicitudes HTTP?</font> </h2><br>  Hablemos sobre c√≥mo los navegadores realizan solicitudes a los servidores utilizando el protocolo HTTP / 1.1. <br><br>  Si alguna vez tuvo una entrevista en el campo de TI, es posible que se le pregunte qu√© sucede cuando escribe algo en la barra de direcciones de su navegador y presiona Enter.  Quiz√°s esta sea una de las preguntas m√°s populares que se produce en tales entrevistas.  Cualquiera que haga tales preguntas quiere saber si puede explicar algunos conceptos bastante simples y averiguar si comprende los principios de Internet. <br><br>  Esta pregunta toca muchas tecnolog√≠as, para comprender los principios generales de lo que significa comprender c√≥mo se construye uno de los sistemas m√°s complejos jam√°s creados por la humanidad, que cubre todo el mundo. <br><br><h3>  <font color="#3AC1EF">‚ñç protocolo HTTP</font> </h3><br>  Los navegadores modernos pueden distinguir las URL reales ingresadas en su barra de direcciones de las consultas de b√∫squeda, para cuyo procesamiento generalmente se usa el motor de b√∫squeda predeterminado.  Hablaremos de las URL.  Si ingresa la direcci√≥n de un sitio web, como <code>flaviocopes.com</code> , en la l√≠nea del navegador, el navegador convierte esta direcci√≥n en el formulario <code>http://flaviocopes.com</code> , en el supuesto de que el protocolo HTTP se utilizar√° para intercambiar datos con el recurso especificado.  Tenga en cuenta que en Windows, de lo que vamos a hablar aqu√≠ puede parecer un poco diferente que en macOS y Linux. <br><br><h3>  <font color="#3AC1EF">‚ñç Fase de b√∫squeda de DNS</font> </h3><br>  Entonces, el navegador, comenzando a trabajar en la descarga de datos de la direcci√≥n solicitada por los usuarios, realiza la operaci√≥n de b√∫squeda de DNS (b√∫squeda de DNS) para averiguar la direcci√≥n IP del servidor correspondiente.  Los nombres simb√≥licos de los recursos ingresados ‚Äã‚Äãen la barra de direcciones son convenientes para las personas, pero el dispositivo de Internet implica la posibilidad de intercambiar datos entre computadoras usando direcciones IP, que son conjuntos de n√∫meros como 222.324.3.1 (para IPv4). <br><br>  Primero, al descubrir la direcci√≥n IP del servidor, el navegador busca en el cach√© de DNS local para ver si se ha realizado un procedimiento similar recientemente.  En el navegador Chrome, por ejemplo, hay una manera conveniente de mirar el cach√© DNS ingresando la siguiente direcci√≥n en la barra de direcciones: <code>chrome://net-internals/#dns</code> . <br><br>  Si no se puede encontrar nada en la memoria cach√©, el navegador utiliza la llamada del sistema POSIX <code>gethostbyname</code> para averiguar la direcci√≥n IP del servidor. <br><br><h3>  <font color="#3AC1EF">‚ñç funci√≥n gethostbyname</font> </h3><br>  La funci√≥n <code>gethostbyname</code> primero verifica el <code>hosts</code> , que, en macOS o Linux, se puede encontrar en <code>/etc/hosts</code> para averiguar si se puede encontrar informaci√≥n local al encontrar la direcci√≥n del servidor. <br><br>  Si local significa resolver la solicitud para averiguar la direcci√≥n IP del servidor falla, el sistema realiza una solicitud al servidor DNS.  Las direcciones de dichos servidores se almacenan en la configuraci√≥n del sistema. <br><br>  Aqu√≠ hay un par de servidores DNS populares: <br><br><ul><li>  8.8.8.8: servidor DNS de Google. </li><li>  1.1.1.1: servidor DNS CloudFlare. </li></ul><br>  La mayor√≠a de las personas usan los servidores DNS proporcionados por sus proveedores.  El navegador realiza consultas DNS utilizando el protocolo UDP. <br><br>  TCP y UDP son dos protocolos b√°sicos utilizados en redes de computadoras.  Est√°n ubicados en el mismo nivel conceptual, pero TCP es un protocolo orientado a la conexi√≥n, y para el intercambio de mensajes UDP, cuyo procesamiento crea una peque√±a carga adicional en el sistema, no se requiere un procedimiento de establecimiento de conexi√≥n.  No hablaremos exactamente sobre c√≥mo se intercambian los datos a trav√©s de UDP. <br><br>  La direcci√≥n IP correspondiente al nombre de dominio que nos interesa puede estar en la cach√© del servidor DNS.  Si este no es el caso, se pondr√° en contacto con el servidor DNS ra√≠z.  El sistema de servidor DNS ra√≠z consta de 13 servidores, de los cuales depende el funcionamiento de todo Internet. <br><br>  Cabe se√±alar que el servidor DNS ra√≠z no conoce la correspondencia entre todos los nombres de dominio y direcciones IP existentes en el mundo.  Pero servidores similares conocen las direcciones de los servidores DNS de nivel superior para dominios como .com, .it, .pizza, etc. <br><br>  Al recibir la solicitud, el servidor DNS ra√≠z la redirige al servidor DNS del dominio de nivel superior, al llamado servidor TLD (desde el dominio de nivel superior). <br><br>  Supongamos que el navegador est√° buscando la direcci√≥n IP para el servidor <code>flaviocopes.com</code> .  En cuanto al servidor DNS ra√≠z, el navegador recibir√° de √©l la direcci√≥n del servidor TLD para la zona .com.  Ahora esta direcci√≥n se almacenar√° en la memoria cach√©, como resultado, si necesita averiguar la direcci√≥n IP de otra URL de la zona .com, no tendr√° que volver a ponerse en contacto con el servidor DNS ra√≠z. <br><br>  Los servidores de TLD tienen direcciones IP de servidores de nombres (Name Server, NS), con la ayuda de los cuales puede encontrar la direcci√≥n IP en la URL que tenemos.  ¬øDe d√≥nde obtiene el servidor NS esta informaci√≥n?  El hecho es que si compra un dominio, el registrador de dominio env√≠a datos al respecto a los servidores de nombres.  Se realiza un procedimiento similar, por ejemplo, al cambiar el alojamiento. <br><br>  Los servidores en cuesti√≥n generalmente son propiedad de proveedores de hosting.  Como regla general, para protegerse contra fallas, se crean varios de estos servidores.  Por ejemplo, pueden tener estas direcciones: <br><br><ul><li>  ns1.dreamhost.com </li><li>  ns2.dreamhost.com </li><li>  ns3.dreamhost.com </li></ul><br>  Para averiguar la direcci√≥n IP por URL, al final, recurren a dichos servidores.  Almacenan los datos reales sobre las direcciones IP. <br><br>  Ahora, despu√©s de que pudimos encontrar la direcci√≥n IP detr√°s de la URL ingresada en la barra de direcciones del navegador, pasamos al siguiente paso de nuestro trabajo. <br><br><h3>  <font color="#3AC1EF">‚ñç Establecer una conexi√≥n TCP</font> </h3><br>  Tras conocer la direcci√≥n IP del servidor, el cliente puede iniciar una conexi√≥n TCP con √©l.  En el proceso de establecer una conexi√≥n TCP, el cliente y el servidor se transmiten entre s√≠ algunos datos de servicio, despu√©s de lo cual pueden intercambiar informaci√≥n.  Esto significa que una vez establecida la conexi√≥n, el cliente podr√° enviar una solicitud al servidor. <br><br><h3>  <font color="#3AC1EF">‚ñç Solicitud de env√≠o</font> </h3><br>  Una solicitud es un fragmento de texto estructurado de acuerdo con las reglas del protocolo utilizado.  Consta de tres partes: <br><br><ul><li>  Cadena de consulta </li><li>  Solicitar encabezado. </li><li>  Solicitar cuerpo. </li></ul><br><h4>  Cadena de consulta </h4><br>  La cadena de consulta es una cadena de texto √∫nica que contiene la siguiente informaci√≥n: <br><br><ul><li>  M√©todo HTTP </li><li>  Direcci√≥n de recursos </li><li>  Versi√≥n de protocolo </li></ul><br>  Puede verse, por ejemplo, as√≠: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> / HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span></code> </pre> <br><h4>  Encabezado de solicitud </h4><br>  El encabezado de la solicitud est√° representado por un conjunto de <code>: </code> .  Hay 2 campos de encabezado obligatorios, uno de los cuales es <code>Host</code> y el segundo es <code>Connection</code> .  Los campos restantes son opcionales. <br><br>  El t√≠tulo puede verse as√≠: <br><br><pre> <code class="hljs pgsql">Host: flaviocopes.com <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">close</span></span></code> </pre> <br>  El campo <code>Host</code> indica el nombre de dominio que le interesa al navegador.  El campo <code>Connection</code> , configurado para <code>close</code> , significa que la conexi√≥n entre el cliente y el servidor no necesita mantenerse abierta. <br><br>  Otros encabezados de solicitud de uso com√∫n incluyen los siguientes: <br><br><ul><li> <code>Origin</code> </li> <li> <code>Accept</code> </li> <li> <code>Accept-Encoding</code> </li> <li> <code>Cookie</code> </li> <li> <code>Cache-Control</code> </li> <li> <code>Dnt</code> </li> </ul><br>  De hecho, hay muchos m√°s. <br><br>  El encabezado de la solicitud termina con una cadena vac√≠a. <br><br><h4>  Cuerpo de solicitud </h4><br>  El cuerpo de la solicitud es opcional; no se utiliza en solicitudes GET.  El cuerpo de la solicitud se utiliza en solicitudes POST, as√≠ como en otras solicitudes.  Puede contener, por ejemplo, datos en formato JSON. <br><br>  Como ahora estamos hablando de una solicitud GET, el cuerpo de la solicitud estar√° vac√≠o, no trabajaremos con ella. <br><br><h3>  <font color="#3AC1EF">‚ñç respuesta</font> </h3><br>  Despu√©s de que el servidor recibe la solicitud enviada por el cliente, la procesa y env√≠a una respuesta al cliente. <br><br>  La respuesta comienza con un c√≥digo de estado y un mensaje correspondiente.  Si la solicitud es exitosa, el comienzo de la respuesta se ver√° as√≠: <br><br><pre> <code class="hljs">200 OK</code> </pre> <br>  Si algo sali√≥ mal, puede haber otros c√≥digos.  Por ejemplo, lo siguiente: <br><br><ul><li> <code>404 Not Found</code> </li> <li> <code>403 Forbidden</code> </li> <li> <code>301 Moved Permanently</code> </li> <li> <code>500 Internal Server Error</code> </li> <li> <code>304 Not Modified</code> </li> <li> <code>401 Unauthorized</code> </li> </ul><br>  Adem√°s, la respuesta contiene una lista de encabezados HTTP y el cuerpo de la respuesta (que, dado que la solicitud es ejecutada por el navegador, ser√° un c√≥digo HTML). <br><br><h4>  An√°lisis HTML </h4><br>  Despu√©s de que el navegador recibe la respuesta del servidor, cuyo cuerpo contiene c√≥digo HTML, comienza a analizarlo, repitiendo el proceso anterior para cada recurso que se necesita para formar la p√°gina.  Dichos recursos incluyen, por ejemplo, los siguientes: <br><br><ul><li>  Archivos CSS </li><li>  Im√°genes </li><li>  Icono de p√°gina web (favicon). </li><li>  Archivos JavaScript </li></ul><br>  La forma exacta en que el navegador muestra la p√°gina no se aplica a nuestra conversaci√≥n.  Lo principal que nos interesa aqu√≠ es que el proceso anterior de solicitud y recepci√≥n de datos se utiliza no solo para el c√≥digo HTML, sino tambi√©n para cualquier otro objeto transferido desde el servidor al navegador utilizando el protocolo HTTP. <br><br><h2>  <font color="#3AC1EF">Acerca de crear un servidor simple usando Node.js</font> </h2><br>  Ahora, despu√©s de examinar el proceso de interacci√≥n entre el navegador y el servidor, puede echar un vistazo a la secci√≥n de la aplicaci√≥n First Node.js de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">primera parte de</a> esta serie de materiales, en la que describimos el c√≥digo para un servidor simple. <br><br><h2>  <font color="#3AC1EF">Hacer solicitudes HTTP con Node.js</font> </h2><br>  Para realizar solicitudes HTTP usando Node.js, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://nodejs.org/api/">se usa el m√≥dulo</a> apropiado.  Los siguientes ejemplos usan el m√≥dulo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=https://nodejs.org/api/">https</a> .  El hecho es que, en las condiciones modernas, siempre que sea posible, es necesario utilizar el protocolo HTTPS. <br><br><h3>  <font color="#3AC1EF">‚ñç Ejecutando solicitudes GET</font> </h3><br>  Aqu√≠ hay un ejemplo de ejecuci√≥n de una solicitud GET usando Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">Execution Ejecuci√≥n de solicitud POST</font> </h3><br>  Aqu√≠ se explica c√≥mo realizar una solicitud POST desde Node.js: <br><br><pre> <code class="hljs coffeescript">const https = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'https'</span></span>) const data = JSON.stringify({ todo: <span class="hljs-string"><span class="hljs-string">'Buy the milk'</span></span> }) const options = { hostname: <span class="hljs-string"><span class="hljs-string">'flaviocopes.com'</span></span>, port: <span class="hljs-number"><span class="hljs-number">443</span></span>, path: <span class="hljs-string"><span class="hljs-string">'/todos'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'POST'</span></span>, headers: {   <span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>,   <span class="hljs-string"><span class="hljs-string">'Content-Length'</span></span>: data.length } } const req = https.request(options, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">statusCode: ${res.statusCode}</span></span>`) res.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'data'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   process.stdout.write(d) }) }) req.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'error'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) }) req.write(data) req.end()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçPUT y BORRAR consultas</font> </h3><br>  La ejecuci√≥n de tales solicitudes tiene el mismo aspecto que la ejecuci√≥n de solicitudes POST.  La principal diferencia, adem√°s del contenido sem√°ntico de tales operaciones, es el valor de la propiedad del <code>method</code> del objeto de <code>options</code> . <br><br><h3>  <font color="#3AC1EF">‚ñç Realizar solicitudes HTTP en Node.js utilizando la biblioteca Axios</font> </h3><br>  Axios es una biblioteca JavaScript muy popular que funciona tanto en el navegador (esto incluye todos los navegadores modernos e IE, comenzando con IE8), como en el entorno Node.js, que puede usarse para realizar solicitudes HTTP. <br><br>  Esta biblioteca se basa en promesas, tiene algunas ventajas sobre los mecanismos est√°ndar, en particular, sobre API Fetch.  Entre sus ventajas est√°n las siguientes: <br><br><ul><li>  Soporte para navegadores antiguos (necesita un polyfill para usar Fetch). </li><li>  Posibilidad de interrumpir solicitudes. </li><li>  Soporte para establecer tiempos de espera para solicitudes. </li><li>  Protecci√≥n incorporada contra ataques CSRF. </li><li>  Soporte para cargar datos con el suministro de informaci√≥n sobre el progreso de este proceso. </li><li>  Soporte para conversi√≥n de datos JSON. </li><li>  Empleos en Node.js </li></ul><br><h4>  Instalaci√≥n </h4><br>  Puede usar npm para instalar Axios: <br><br><pre> <code class="hljs sql">npm <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> axios</code> </pre> <br>  El mismo efecto se puede lograr con hilo: <br><br><pre> <code class="hljs cs">yarn <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> axios</code> </pre> <br>  Puede conectar la biblioteca a la p√°gina usando <code>unpkg.com</code> : <br><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/axios/dist/axios.min.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h4>  API Axios </h4><br>  Puede realizar una solicitud HTTP utilizando el objeto <code>axios</code> : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">axios</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>, method: <span class="hljs-string"><span class="hljs-string">'get'</span></span>, data: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br>  Pero generalmente es m√°s conveniente usar m√©todos especiales: <br><br><ul><li> <code>axios.get()</code> </li> <li> <code>axios.post()</code> </li> </ul><br>  Esto es similar a c√≥mo jQuery usa <code>$.get()</code> y <code>$.post()</code> lugar de <code>$.ajax()</code> <code>$.post()</code> . <br><br>  Axios ofrece m√©todos separados para ejecutar otros tipos de solicitudes HTTP, que no son tan populares como GET y POST, pero que a√∫n se utilizan: <br><br><ul><li> <code>axios.delete()</code> </li> <li> <code>axios.put()</code> </li> <li> <code>axios.patch()</code> </li> <li> <code>axios.options()</code> </li> </ul><br>  La biblioteca tiene un m√©todo para ejecutar una solicitud dise√±ada para recibir solo encabezados HTTP, sin el cuerpo de respuesta: <br><br><ul><li> <code>axios.head()</code> </li> </ul><br><h4>  OBTENER solicitudes </h4><br>  Axios es conveniente de usar usando la sintaxis moderna async / await.  El siguiente ejemplo de c√≥digo, dise√±ado para Node.js, usa la biblioteca para cargar una lista de razas de perros desde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la API de perros</a> .  Aqu√≠ se aplica el m√©todo <code>axios.get()</code> y se cuentan las rocas: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getBreeds() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (breeds.data.message) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(breeds.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>) } } countBreeds()</code> </pre> <br>  Lo mismo se puede reescribir sin usar async / await, aplicando promesas: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> axios = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'axios'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getBreeds = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> axios.get(<span class="hljs-string"><span class="hljs-string">'https://dog.ceo/api/breeds/list/all'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(error) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> countBreeds = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> breeds = getBreeds()   .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.data.message) {       <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(         <span class="hljs-string"><span class="hljs-string">`Got </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">Object</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.entries(response.data.message).length}</span></span></span><span class="hljs-string"> breeds`</span></span>       )     }   })   .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(error)   }) } countBreeds()</code> </pre> <br><h4>  Usar par√°metros en solicitudes GET </h4><br>  Una solicitud GET puede contener par√°metros que se ven as√≠ en una URL: <br><br><pre> <code class="hljs objectivec">https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar</span></span></code> </pre> <br>  Al usar Axios, se puede hacer una consulta de este tipo de la siguiente manera: <br><br><pre> <code class="hljs swift">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>('https:<span class="hljs-comment"><span class="hljs-comment">//site.com/?foo=bar')</span></span></code> </pre> <br>  Se puede lograr el mismo efecto configurando la propiedad <code>params</code> en un objeto con par√°metros: <br><br><pre> <code class="hljs cs">axios.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>: {   foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> } })</code> </pre> <br><h4>  Solicitudes POST </h4><br>  La ejecuci√≥n de solicitudes POST es muy similar a la ejecuci√≥n de solicitudes GET, pero aqu√≠, en lugar del m√©todo <code>axios.post()</code> , se utiliza el m√©todo <code>axios.post()</code> : <br><br><pre> <code class="hljs scala">axios.post(<span class="hljs-symbol"><span class="hljs-symbol">'https</span></span>:<span class="hljs-comment"><span class="hljs-comment">//site.com/')</span></span></code> </pre> <br>  Como segundo argumento, el m√©todo <code>post</code> acepta un objeto con par√°metros de solicitud: <br><br><pre> <code class="hljs cs">axios.post(<span class="hljs-string"><span class="hljs-string">'https://site.com/'</span></span>, { foo: <span class="hljs-string"><span class="hljs-string">'bar'</span></span> })</code> </pre> <br><h2>  <font color="#3AC1EF">Uso del protocolo WebSocket en Node.js</font> </h2><br>  WebSocket es una alternativa a HTTP, se puede usar para organizar el intercambio de datos en aplicaciones web.  Este protocolo le permite crear canales de comunicaci√≥n bidireccionales de larga duraci√≥n entre el cliente y el servidor.  Una vez establecida la conexi√≥n, el canal de comunicaci√≥n permanece abierto, lo que pone la aplicaci√≥n a disposici√≥n de una conexi√≥n muy r√°pida, caracterizada por bajas latencias y una peque√±a carga adicional en el sistema. <br><br>  El protocolo WebSocket es compatible con todos los navegadores modernos. <br><br><h3>  <font color="#3AC1EF">‚ñç Diferencias HTTP</font> </h3><br>  HTTP y WebSocket son protocolos muy diferentes que utilizan diferentes enfoques para intercambiar datos.  HTTP se basa en el modelo de "solicitud-respuesta": el servidor env√≠a algunos datos al cliente despu√©s de que se solicite.  En el caso de WebSocket, todo est√° organizado de manera diferente.  A saber: <br><br><ul><li>  El servidor puede enviar mensajes al cliente por iniciativa propia, sin esperar una solicitud del cliente. </li><li>  El cliente y el servidor pueden intercambiar datos al mismo tiempo. </li><li>  Al transmitir un mensaje, se utiliza una cantidad extremadamente peque√±a de datos de servicio.  Esto, en particular, conduce a una baja latencia en la transmisi√≥n de datos. </li></ul><br>  El protocolo WebSocket es muy adecuado para las comunicaciones en tiempo real a trav√©s de canales que permanecen abiertos durante mucho tiempo.  HTTP, a su vez, es excelente para organizar sesiones de comunicaci√≥n ocasionales iniciadas por el cliente.  Al mismo tiempo, debe tenerse en cuenta que, desde el punto de vista de la programaci√≥n, es mucho m√°s f√°cil implementar el intercambio de datos utilizando el protocolo HTTP que utilizando el protocolo WebSocket. <br><br><h3>  <font color="#3AC1EF">‚ñç Versi√≥n protegida del protocolo WebSocket</font> </h3><br>  Existe una versi√≥n insegura del protocolo WebSocket (esquema <code>ws://</code> URI), que se asemeja, en t√©rminos de seguridad, al protocolo <code>http://</code> .  Se debe evitar el uso de <code>ws://</code> , prefiriendo una versi√≥n segura del protocolo - <code>wss://</code> . <br><br><h3>  <font color="#3AC1EF">‚ñçCreando una conexi√≥n WebSocket</font> </h3><br>  Para crear una conexi√≥n WebSocket, debe usar el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">constructor</a> apropiado: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> url = <span class="hljs-string"><span class="hljs-string">'wss://myserver.com/something'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(url)</code> </pre> <br>  Despu√©s de establecer una conexi√≥n exitosa, se genera el evento <code>open</code> .  Puede organizar este evento asignando una funci√≥n de devoluci√≥n de llamada a la propiedad <code>onopen</code> del objeto de <code>connection</code> : <br><br><pre> <code class="hljs javascript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Para manejar errores, se usa el controlador de eventos <code>onerror</code> : <br><br><pre> <code class="hljs javascript">connection.onerror = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`WebSocket error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${error}</span></span></span><span class="hljs-string">`</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçEnv√≠o de datos al servidor</font> </h3><br>  Despu√©s de abrir una conexi√≥n WebSocket al servidor, puede enviarle datos.  Esto se puede hacer, por ejemplo, en la devoluci√≥n de <code>onopen</code> abierta: <br><br><pre> <code class="hljs coffeescript">connection.onopen = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { connection.send(<span class="hljs-string"><span class="hljs-string">'hey'</span></span>) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Obtenci√≥n de datos del servidor</font> </h3><br>  Para recibir los datos enviados mediante el protocolo WebSocket desde el servidor, puede asignar la devoluci√≥n de <code>onmessage</code> onmessage, que se llamar√° cuando se reciba el evento del <code>message</code> : <br><br><pre> <code class="hljs javascript">connection.onmessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e.data) }</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Implementaci√≥n del servidor WebSocket en el entorno Node.js</font> </h3><br>  Para implementar un servidor WebSocket en el entorno Node.js, puede usar la popular biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ws</a> .  Lo usaremos para el desarrollo del servidor, pero es adecuado para crear clientes, as√≠ como para organizar la interacci√≥n entre dos servidores. <br><br>  Instale esta biblioteca inicializando primero el proyecto: <br><br><pre> <code class="hljs swift">yarn <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> yarn add ws</code> </pre> <br>  El c√≥digo para el servidor WebSocket que necesitamos escribir es bastante compacto: <br><br><pre> <code class="hljs javascript">constWebSocket = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'ws'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> wss = newWebSocket.Server({ <span class="hljs-attr"><span class="hljs-attr">port</span></span>: <span class="hljs-number"><span class="hljs-number">8080</span></span> }) wss.on(<span class="hljs-string"><span class="hljs-string">'connection'</span></span>, ws =&gt; { ws.on(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, message =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Received message =&gt; </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${message}</span></span></span><span class="hljs-string">`</span></span>) }) ws.send(<span class="hljs-string"><span class="hljs-string">'ho!'</span></span>) })</code> </pre> <br>  Aqu√≠ creamos un nuevo servidor que escucha en el puerto est√°ndar 8080 el protocolo WebSocket y describe una devoluci√≥n de llamada que, cuando se establece la conexi√≥n, env√≠a un mensaje <code>ho!</code> al cliente <code>ho!</code>  e imprime en la consola un mensaje recibido del cliente. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu√≠ hay un</a> ejemplo funcional de un servidor WebSocket, y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> hay un cliente que puede interactuar con √©l. <br><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre los mecanismos de red compatibles con la plataforma Node.js, trazando paralelos con mecanismos similares utilizados en los navegadores.  Nuestro pr√≥ximo tema ser√° trabajar con archivos. <br><br>  <b>Estimados lectores!</b>  ¬øUtiliza el protocolo WebSocket en sus aplicaciones web, cuyo lado del servidor se cre√≥ con Node.js? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424557/">https://habr.com/ru/post/es424557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424541/index.html">Historia del fiasco de UGJ 2018: c√≥mo hacer un juego que a nadie le guste (¬°no lo hagas!)</a></li>
<li><a href="../es424543/index.html">Java 11 / JDK 11: Disponibilidad general</a></li>
<li><a href="../es424551/index.html">Warm and tube: cinco balalaikas sobre tecnolog√≠a de audio magn√©tico</a></li>
<li><a href="../es424553/index.html">Gu√≠a de Node.js, Parte 6: Bucle de eventos, Pila de llamadas, Temporizadores</a></li>
<li><a href="../es424555/index.html">Manual de Node.js, Parte 7: Programaci√≥n asincr√≥nica</a></li>
<li><a href="../es424559/index.html">Big Data resistencia 1 o el esquivo Joe. Anonimato de Internet, anti-detecci√≥n, anti-seguimiento para anti-usted y anti-nosotros.</a></li>
<li><a href="../es424563/index.html">Beeline env√≠a detalles de conversaciones a extra√±os</a></li>
<li><a href="../es424565/index.html">Descripci√≥n general: escaneo 3D de locales inmobiliarios</a></li>
<li><a href="../es424567/index.html">La experiencia de bloquear la publicidad en l√≠nea en la red local de la compa√±√≠a.</a></li>
<li><a href="../es424569/index.html">Contrataci√≥n de programadores. Consejos de programador</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>