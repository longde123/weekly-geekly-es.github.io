<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏼 🌗 😊 Julia: Typen, Multimethoden und Arithmetik über Polynome 🚇 👨🏿‍🍳 🏕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dieser Veröffentlichung konzentrieren wir uns meiner Meinung nach auf das Hauptmerkmal der Julia-Sprache - die Darstellung von Funktionen in Form v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia: Typen, Multimethoden und Arithmetik über Polynome</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450628/">  In dieser Veröffentlichung konzentrieren wir uns meiner Meinung nach auf das Hauptmerkmal der Julia-Sprache - die Darstellung von Funktionen in Form von Methoden mit Mehrfachversand.  Auf diese Weise können Sie die Leistung von Berechnungen steigern, ohne die Lesbarkeit des Codes zu beeinträchtigen und einerseits die Abstraktheit zu beeinträchtigen, und andererseits können Sie mit mathematischen Konzepten in einer bekannteren Notation arbeiten.  Als Beispiel wird die Frage der Einheitlichkeit (unter dem Gesichtspunkt linearer Operationen) bei der Darstellung der Koeffizientenliste mit Polynomen und bei Interpolationspolynomen betrachtet. <br><a name="habracut"></a><br><h2>  Grundlegende Syntax </h2><br>  Eine kurze Einführung für Unbekannte.  Julia ist eine skriptähnliche Sprache mit REPL (Read-Evaluate-Print-Schleife, d. H. Eine interaktive Shell).  Auf den ersten Blick sieht es zum Beispiel Python oder MATLAB ziemlich ähnlich. <br><h4>  Arithmetische Operationen </h4><br>  Die Arithmetik ist ungefähr gleich wie überall: +, -, *, /, ^ für die Potenzierung usw. <br>  Vergleich:&gt;, &lt;,&gt; =, &lt;=, ==,! = Etc. <br>  Zuordnung: =. <br>  Features: Division durch <code>/</code> immer eine Bruchzahl zurück;  Wenn Sie den ganzzahligen Teil der Division zweier Ganzzahlen benötigen, müssen Sie die Operation <code>div(m, n)</code> oder das Infix-Äquivalent <code>m ÷ n</code> . <br><h4>  Typen </h4><br>  Numerische Typen: <br><ul><li>  Ganzzahlen ( <code>Int</code> ) - <code>2</code> , <code>3</code> , <code>-42</code> </li><li>  Ganzzahlen ohne <code>UInt</code> ( <code>UInt</code> ) - <code>0x12345</code> </li><li>  Gleitkomma ( <code>Float32</code> , <code>Float64</code> ) - <code>1.0</code> , <code>3.1415</code> , <code>-Inf</code> , <code>NaN</code> </li><li>  Rational ( <code>Rational</code> ) - <code>3//3</code> , <code>7//2</code> </li><li>  Real ( <code>Real</code> ) - alles oben Genannte </li><li>  Komplex ( <code>Complex</code> ) - <code>3+4*im</code> , <code>2//3+2//3*im</code> , <code>3.0+0.0*im</code> ( <code>im</code> ist eine imaginäre Einheit, nur eine Zahl mit einem explizit geschriebenen Imaginärteil wird als komplex angesehen) </li><li>  <code>Number</code> - alle oben genannten </li></ul><br><br>  Zeichenfolgen und Zeichen: <br><ul><li>  <code>'a'</code> - Zeichen ( <code>Char</code> ) </li><li>  <code>"a"</code> ist ein String ( <code>String</code> ) </li></ul><br><br>  NB: Zeichenfolgen sind, wie jetzt in vielen Sprachen, unveränderlich. <br>  NB: Zeichenfolgen (sowie Variablennamen) unterstützen Unicode, einschließlich Emoji. <br><br>  Arrays: <br><ul><li>  <code>x = [1, 2, 3]</code> - Angabe eines Arrays durch direkte Aufzählung von Elementen </li><li>  spezielle Konstruktoren: <code>zeros(length)</code> für ein Array von Nullen, <code>ones(length)</code> für ein Array von Einsen, <code>rand(length)</code> für ein Array von Zufallszahlen usw. </li><li>  Unterstützung für mehrdimensionale Arrays </li><li>  Unterstützung für lineare Algebraoperationen (Hinzufügen von Arrays, Skalarmultiplikation, Matrixvektormultiplikation und vieles mehr) in der Standardbibliothek </li></ul><br><br>  NB: Alle Sammlungen werden ab einer indiziert. <br>  NB: weil  Die Sprache ist für Rechenaufgaben gedacht. Arrays sind einer der wichtigsten Typen. Sie müssen mehr als einmal zu den Prinzipien ihrer Arbeit zurückkehren. <br><br>  Tupel (geordneter Satz von Elementen, unveränderlich): <br><ul><li>  <code>(2, 5.3, "k")</code> ist ein reguläres Tupel </li><li>  <code>(a = 3, b = 4)</code> - benanntes Tupel </li></ul><br><br>  NB: Auf die Felder eines benannten Tupels kann sowohl nach Namen durch einen Punkt als auch nach Index über [] zugegriffen werden. <br><pre> <code class="julia hljs">julia&gt; x = (a = <span class="hljs-number"><span class="hljs-number">5</span></span>, b = <span class="hljs-number"><span class="hljs-number">12</span></span>) (a = <span class="hljs-number"><span class="hljs-number">5</span></span>, b = <span class="hljs-number"><span class="hljs-number">12</span></span>) julia&gt; x[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">5</span></span> julia&gt; sqrt(xa^<span class="hljs-number"><span class="hljs-number">2</span></span> + x[<span class="hljs-number"><span class="hljs-number">2</span></span>]^<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">13.0</span></span></code> </pre><br><br>  Wörterbücher: <br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Char</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">2</span></span> entries: <span class="hljs-string"><span class="hljs-string">'a'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">12</span></span> julia&gt; x[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> julia&gt; x <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Char</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">3</span></span> entries: <span class="hljs-string"><span class="hljs-string">'a'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">12</span></span></code> </pre><br><br><h4>  Grundlegende Kontrollsprachenkonstrukte </h4><br>  1. Variablen werden bei der Zuweisung automatisch erstellt.  Typ ist optional. <br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-number"><span class="hljs-number">7</span></span>; x + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> julia&gt; x = <span class="hljs-number"><span class="hljs-number">42.0</span></span>; x * <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">168.0</span></span></code> </pre><br>  2. Der bedingte Sprungblock beginnt mit dem Ausdruck <code>if &lt;condition&gt;</code> und endet mit dem Worte <code>end</code> .  Sie können auch ein <code>else</code> Licht oder <code>elseif</code> Lichter haben: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt; y println(<span class="hljs-string"><span class="hljs-string">"X is more than Y"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> x == y println(<span class="hljs-string"><span class="hljs-string">"X and Y are equal"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">"X is less than Y"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  3. Es gibt zwei Schleifenkonstrukte: <code>while</code> und <code>for</code> .  Das zweite funktioniert wie in Python, d.h.  Iteriert über die Sammlung.  Eine häufige Verwendung ist das Durchlaufen eines Wertebereichs, dessen Syntax <code>start[:increment]:end</code> lautet.  Im Gegensatz zu Python <i>umfasst</i> ein Bereich sowohl Start- als auch Endwerte, d. H.  Der leere Bereich ist nicht <code>1:1</code> (dies ist ein Bereich von 1), sondern <code>1:0</code> .  Das Ende des Schleifenkörpers ist mit dem Worte <code>end</code> markiert. <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>; print(i, <span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#   1  3   1 ( ) 1 2 3 julia&gt; for i in 1:2:3; print(i, " "); end #   1  3   2 1 3</span></span></code> </pre><br>  4. Funktionen werden durch die Schlüsselwortfunktion definiert, die Definition der Funktion endet ebenfalls mit dem Worte <code>end</code> .  Argumente mit Standardwerten und benannten Argumenten werden unterstützt. <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> square(x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> cube(x) x * square(x) <span class="hljs-comment"><span class="hljs-comment">#       ; return   end function root(x, degree = 2) #  degree     return x^(1.0/degree) end function greeting(name; times = 42, greet = "hello") #       println(times, " times ", greet, " to ", name) end julia&gt; greeting("John") 42 times hello to John julia&gt; greeting("Mike", greet = "wassup", times = 100500) #           100500 times wassup to Mike</span></span></code> </pre><br><br>  Im Allgemeinen ist dies alles Python ziemlich ähnlich, mit Ausnahme geringfügiger Unterschiede in der Syntax und der Tatsache, dass die Codeblöcke nicht mit Leerzeichen, sondern mit Schlüsselwörtern belegt sind.  In einfachen Fällen übersetzen Python-Programme sogar fast eins zu eins in Julia. <br>  Es gibt jedoch einen signifikanten Unterschied in der Tatsache, dass Sie in Julia explizit Typen für Variablen angeben können, wodurch Sie Programme kompilieren und schnellen Code erhalten können. <br>  Der zweite wesentliche Unterschied besteht darin, dass Python ein „klassisches“ OOP-Modell mit Klassen und Methoden implementiert, während Julia ein Multi-Dispatch-Modell implementiert. <br><br><h4>  Geben Sie Anmerkungen und Mehrfachversand ein </h4><br>  Mal sehen, was eine eingebaute Funktion ist: <br><pre> <code class="julia hljs">julia&gt; sqrt sqrt (generic <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> with <span class="hljs-number"><span class="hljs-number">19</span></span> methods)</code> </pre><br>  Wie REPL zeigt, ist <code>sqrt</code> eine generische Funktion mit 19 Methoden.  Welche Art von verallgemeinerter Funktion und welche Art von Methoden? <br><br>  Dies bedeutet, dass es <i>mehrere</i> <code>sqrt</code> Funktionen gibt, die für verschiedene Arten von Argumenten gelten und dementsprechend die Quadratwurzel mit verschiedenen Algorithmen berechnen.  Sie können sehen, welche Optionen verfügbar sind, indem Sie eingeben <br><pre> <code class="julia hljs">julia&gt; methods(sqrt)</code> </pre><br>  Es ist ersichtlich, dass die Funktion sowohl für verschiedene Arten von Zahlen als auch für Matrizen definiert ist. <br><br>  Im Gegensatz zum „klassischen“ OOP, bei dem die konkrete Implementierung der Methode nur von der aufrufenden Klasse bestimmt wird (Dispatching durch das erste Argument), wird bei Julia die Auswahl einer Funktion durch die Typen (und die Anzahl) <i>aller</i> ihrer Argumente bestimmt. <br>  Wenn Sie eine Funktion mit bestimmten Argumenten aus all ihren Methoden aufrufen, wird eine ausgewählt, die den spezifischen Satz von Typen, mit denen die Funktion aufgerufen wird, am genauesten beschreibt und der verwendet wird. <br><br>  Eine Besonderheit besteht darin, dass ein Ansatz angewendet wird, der von den Autoren der Sprache als "nur vorzeitig" zusammengestellt wird.  Das heißt,  Funktionen werden beim ersten Aufruf für die angegebenen Datentypen kompiliert, wonach die folgenden Aufrufe viel schneller ausgeführt werden.  Der Unterschied zwischen dem ersten und den nachfolgenden Anrufen kann sehr bedeutend sein: <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-meta"><span class="hljs-meta">@time</span></span> sqrt(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  @time -      0.006811 seconds (3.15 k allocations: 168.516 KiB) #   ,        2.8284271247461903 julia&gt; @time sqrt(15) 0.000002 seconds (5 allocations: 176 bytes) # 5   -     @time 3.872983346207417</span></span></code> </pre><br>  Im schlechten Fall ist jeder Funktionsaufruf eine Überprüfung des Typs der empfangenen Argumente und eine Suche nach der gewünschten Methode in der Liste.  Wenn Sie dem Compiler jedoch Hinweise geben, können Sie die Überprüfungen eliminieren, was zu schnellerem Code führt. <br><br>  Betrachten Sie beispielsweise die Berechnung der Summe <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mo>&amp;#x2212;</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>k</mi></msup></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.728ex" height="3.262ex" viewBox="0 -987.6 8063.4 1404.6" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-4E" x="1242" y="488"></use><g transform="translate(878,-327)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-31" x="1300" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-73" x="3793" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-71" x="4263" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-72" x="4723" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-74" x="5175" y="0"></use><g transform="translate(5536,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2212" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-31" x="1168" y="0"></use><g transform="translate(1668,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="550" y="583"></use></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mtext>&nbsp;</mtext><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ sum_ {k = 1} ^ N \ sqrt {(- 1) ^ k} </script></p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> mysqrt(num) <span class="hljs-comment"><span class="hljs-comment">#    -     #   -           if num &gt;= 0 return sqrt(num) else return sqrt(complex(num)) end end function S(n) #    sum = 0 sgn = -1 for k = 1:n sum += mysqrt(sgn) sgn = -sgn end return sum end function S_typed(n::Integer) # ..     ,      #     sum::Complex = 0.0 sgn::Int = -1 for k = 1:n sum += mysqrt(sgn) sgn = -sgn end return sum end</span></span></code> </pre><br>  Der Benchmark zeigt, dass die Funktion <code>S_typed()</code> Gegensatz zu <code>S()</code> nicht nur schneller ausgeführt wird, sondern auch nicht für jeden Aufruf eine Speicherzuweisung erfordert.  Das Problem hierbei ist, dass der Typ des von <code>mysqrt()</code> zurückgegebenen <code>mysqrt()</code> nicht definiert ist, genau wie der Typ der rechten Seite des Ausdrucks <br><pre> <code class="julia hljs">sum = sum + mysqrt(sgn)</code> </pre><br>  Infolgedessen kann der Compiler nicht einmal herausfinden, welche <code>sum</code> bei jeder Iteration sein wird.  Boxen (Typ Label Hooking) ist also eine Variable und Speicher wird zugewiesen. <br>  Für die Funktion <code>S_typed()</code> weiß der Compiler im Voraus, dass <code>sum</code> ein komplexer Wert ist, sodass der Code optimierter ist (insbesondere kann der Aufruf von <code>mysqrt()</code> effektiv inline erfolgen und den Rückgabewert immer an <code>Complex</code> ). <br><br>  Noch wichtiger ist, dass <code>S_typed()</code> Compiler für <code>S_typed()</code> weiß, dass der Rückgabewert vom Typ <code>Complex</code> , aber für <code>S()</code> Typ des Ausgabewerts nicht erneut definiert, wodurch alle Funktionen verlangsamt werden, bei denen <code>S()</code> aufgerufen wird. <br>  Mit dem Makro <code>@code_warntype</code> können Sie überprüfen, ob der Compiler über die vom Ausdruck zurückgegebenen Typen <code>@code_warntype</code> : <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_warntype</span></span> S(<span class="hljs-number"><span class="hljs-number">3</span></span>) Body::<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span> <span class="hljs-comment"><span class="hljs-comment">#     ,      ... julia&gt; @code_warntype S_typed(3) Body::Complex{Float64} #      ...</span></span></code> </pre><br>  Wenn eine Funktion irgendwo in der Schleife aufgerufen wird, für die <code>@code_warntype</code> den Rückgabetyp nicht ausgeben kann oder für die irgendwo im Body der Empfang eines Werts vom Typ <code>Any</code> <code>@code_warntype</code> , führt die Optimierung dieser Aufrufe höchstwahrscheinlich zu einer spürbaren Leistungssteigerung. <br><br><h4>  Verbindungstypen </h4><br>  Ein Programmierer kann zusammengesetzte Datentypen für seine Anforderungen mithilfe des <code>struct</code> : <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> GenericStruct <span class="hljs-comment"><span class="hljs-comment">#   struct    name b::Int c::Char v::Vector end #       #       ,        julia&gt; s = GenericStruct("Name", 1, 'z', [3., 0]) GenericStruct("Name", 1, 'z', [3.0, 0.0]) julia&gt; s.name, sb, sc, sv ("Name", 1, 'z', [3.0, 0.0])</span></span></code> </pre><br>  Strukturen in Julia sind unveränderlich, d. H. Durch Erstellen einer Instanz der Struktur ist es nicht mehr möglich, die Feldwerte zu ändern (genauer gesagt, Sie können die Adresse von Feldern im Speicher nicht ändern - Elemente von veränderlichen Feldern, wie z. B. <code>sv</code> im obigen Beispiel, können geändert werden).  Mutable Strukturen werden durch das mutable Strukturkonstrukt erstellt, dessen Syntax dieselbe ist wie für reguläre Strukturen. <br><br>  Die Vererbung von Strukturen im „klassischen“ Sinne wird nicht unterstützt, es besteht jedoch die Möglichkeit, Verhalten zu „erben“, indem zusammengesetzte Typen zu Supertypen oder, wie sie in Julia genannt werden, abstrakten Typen kombiniert werden.  Typbeziehungen werden ausgedrückt als <code>A&lt;:B</code> (A ist ein Subtyp von B) und <code>A&gt;:B</code> (A ist ein Subtyp von B).  Es sieht ungefähr so ​​aus: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> NDimPoint <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#   -     # ,    -     N  struct PointScalar&lt;:NDimPoint x1::Real end struct Point2D&lt;:NDimPoint x1::Real x2::Real end struct Point3D&lt;:NDimPoint x1::Real x2::Real x3::Real end #     ;   Markdown """ mag(p::NDimPoint) Calculate the magnitude of the radius vector of an N-dimensional point `p` """ function mag(p::NDimPoint) sqrmag = 0.0 # ..   ,       #     T   fieldnames(T) for name in fieldnames(typeof(p)) sqrmag += getfield(p, name)^2 end return sqrt(sqrmag) end """ add(p1::T, p2::T) where T&lt;:NDimPoint Calculate the sum of the radius vectors of two N-dimensional points `p1` and `p2` """ function add(p1::T, p2::T) where T&lt;:NDimPoint #  -  , ..       #     list comprehension sumvector = [Float64(getfield(p1, name) + getfield(p1, name)) for name in fieldnames(T)] #     ,    #  ...      , .. # f([1, 2, 3]...) -   ,  f(1, 2, 3) return T(sumvector...) end</span></span></code> </pre><br><h4>  Fallstudie: Polynome </h4><br>  Ein Typensystem, das mit Mehrfachversand gekoppelt ist, ist praktisch, um mathematische Konzepte auszudrücken.  Schauen wir uns ein Beispiel einer einfachen Bibliothek für die Arbeit mit Polynomen an. <br>  Wir führen zwei Arten von Polynomen ein: "kanonisch", definiert durch Koeffizienten bei Potenzen, und "Interpolation", definiert durch eine Menge von Paaren (x, f (x)).  Der Einfachheit halber werden nur gültige Argumente berücksichtigt. <br><br>  Zum Speichern eines Polynoms in einer üblichen Notation ist eine Struktur mit einem Array oder einem Tupel von Koeffizienten als Feld geeignet.  Um völlig unveränderlich zu sein, soll es eine Wagenkolonne geben.  Daher ist der Code zum Definieren des abstrakten Typs, der Struktur des Polynoms und zum Berechnen des Werts des Polynoms an einem bestimmten Punkt recht einfach: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> AbstractPolynomial <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" Polynomial &lt;: AbstractPolynomial Polynomials written in the canonical form """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-comment"><span class="hljs-comment"># NTuple{N, Type} -    N    end """ evpoly(p::Polynomial, z::Real) Evaluate polynomial `p` at `z` using the Horner's rule """ function evpoly(p::Polynomial, z::Real) ans = p.coeff[end] for idx = p.degree:-1:1 ans = p.coeff[idx] + z * ans end return ans end</span></span></code> </pre><br><br>  Interpolationspolynome benötigen eine andere Darstellungsstruktur und Berechnungsmethode.  Insbesondere wenn der Satz von Interpolationspunkten im Voraus bekannt ist und geplant ist, dasselbe Polynom an verschiedenen Punkten zu berechnen, ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newtonsche Interpolationsformel</a> zweckmäßig: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>c</mi><mi>k</mi></msub><msub><mi>n</mi><mi>k</mi></msub><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></mrow><mo>,</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="24.578ex" height="3.021ex" viewBox="0 -883.9 10582.2 1300.8" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-50" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="751" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="1141" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="1713" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="2380" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-73" x="3687" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-75" x="4156" y="0"></use><g transform="translate(4729,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-4E" x="1242" y="488"></use><g transform="translate(878,-327)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-30" x="1300" y="0"></use></g></g><g transform="translate(6980,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="613" y="-213"></use><g transform="translate(902,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="849" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="1971" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="2361" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="2933" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2C" x="10303" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></msubsup><mrow class="MJX-TeXAtom-ORD"><msub><mi>c</mi><mi>k</mi></msub><msub><mi>n</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>,</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> P (x) = \ sum_ {k = 0} ^ N {c_k n_k (x)}, </script></p><br>  wobei <i>n <sub>k</sub></i> ( <i>x</i> ) Grundpolynome sind, <i>n <sub>0</sub></i> ( <i>x</i> ) und für <i>k</i> &gt; 0 <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msub><mi>n</mi><mi>k</mi></msub><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>&amp;#x2212;</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></mrow><mo>,</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="25.81ex" height="3.262ex" viewBox="0 -987.6 11112.7 1404.6" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="849" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="1069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="1458" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="2031" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="2698" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-70" x="4004" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-72" x="4508" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6F" x="4959" y="0"></use><g transform="translate(5445,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-64" x="0" y="0"></use><g transform="translate(524,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-30" x="1124" y="0"></use></g></g><g transform="translate(7342,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2212" x="1184" y="0"></use><g transform="translate(2184,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-69" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="3101" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2C" x="10834" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>n</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mo>,</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> n_k (x) = \ prod_ {i = 0} ^ {k-1} {(x-x_i)}, </script></p><br>  wobei <i>x <sub>i</sub></i> die Interpolationsknoten sind. <br><br>  Aus den obigen Formeln ist ersichtlich, dass die Speicherung zweckmäßigerweise in Form eines Satzes von Interpolationsknoten <i>x <sub>i</sub></i> und Koeffizienten <i>c <sub>i organisiert</sub></i> ist und die Berechnung auf ähnliche Weise wie das Horner-Schema durchgeführt werden kann. <br><pre> <code class="julia hljs"><span class="hljs-string"><span class="hljs-string">""" InterpPolynomial &lt;: AbstractPolynomial Interpolation polynomials in Newton's form """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> InterpPolynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> xval::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" evpoly(p::Polynomial, z::Real) Evaluate polynomial `p` at `z` using the Horner's rule """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> evpoly(p::InterpPolynomial, z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) ans = p.coeff[p.degree+<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx = p.degree:-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> ans = ans * (z - p.xval[idx]) + p.coeff[idx] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Die Funktion zur Berechnung des Wertes des Polynoms heißt in beiden Fällen gleich - <code>evpoly()</code> - akzeptiert jedoch unterschiedliche Arten von Argumenten. <br><br>  Zusätzlich zur Berechnungsfunktion wäre es schön, eine Funktion zu schreiben, die aus bekannten Daten ein Polynom erstellt. <br><br>  In Julia gibt es dafür zwei Techniken: externe Konstruktoren und interne Konstruktoren.  Ein externer Konstruktor ist einfach eine Funktion, die ein Objekt des entsprechenden Typs zurückgibt.  Ein interner Konstruktor ist eine Funktion, die in die Strukturbeschreibung eingeführt wird und den Standardkonstruktor ersetzt.  Es ist ratsam, den internen Konstruktor zu verwenden, um Interpolationspolynome zu konstruieren, da <br><ul><li>  Es ist bequemer, ein Polynom nicht durch die Interpolationsknoten und -koeffizienten zu erhalten, sondern durch die Knoten und Werte der interpolierten Funktion </li><li>  Interpolationsknoten müssen unterschiedlich sein </li><li>  Die Anzahl der Knoten und Koeffizienten muss übereinstimmen </li></ul><br>  Durch das Schreiben eines internen Konstruktors, in dem diese Regeln garantiert eingehalten werden, wird sichergestellt, dass alle erstellten Variablen vom Typ <code>InterpPolynomial</code> zumindest von der Funktion <code>evpoly()</code> korrekt verarbeitet werden können. <br><br>  Wir schreiben einen Konstruktor gewöhnlicher Polynome, der ein eindimensionales Array oder ein Tupel von Koeffizienten als Eingabe verwendet.  Der Konstruktor des Interpolationspolynoms empfängt die Interpolationsknoten und die darin enthaltenen gewünschten Werte und berechnet die Koeffizienten nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methode der geteilten Differenzen</a> . <br><pre> <code class="julia hljs"><span class="hljs-string"><span class="hljs-string">""" Polynomial &lt;: AbstractPolynomial Polynomials written in the canonical form --- Polynomial(v::T) where T&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}) Construct a `Polynomial` from the list of the coefficients. The coefficients are assumed to go from power 0 in the ascending order. If an empty collection is provided, the constructor returns a zero polynomial. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) <span class="hljs-comment"><span class="hljs-comment">#     /     P(x) ≡ 0 coeff = isempty(v) ? (0.0,) : tuple([Float64(x) for x in v]...) #   -   new #  -    return new(length(coeff)-1, coeff) end end """ InterpPolynomial &lt;: AbstractPolynomial Interpolation polynomials in Newton's form --- InterpPolynomial(xsample::Vector{&lt;:Real}, fsample::Vector{&lt;:Real}) Construct an `InterpPolynomial` from a vector of points `xsample` and corresponding function values `fsample`. All values in `xsample` must be distinct. """ struct InterpPolynomial&lt;:AbstractPolynomial degree::Int xval::NTuple{N, Float64} where N coeff::NTuple{N, Float64} where N function InterpPolynomial(xsample::X, fsample::F) where {X&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}, F&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}} #   ,    ,   f  ,   if !allunique(xsample) throw(DomainError("Cannot interpolate with duplicate X points")) end N = length(xsample) if length(fsample) != N throw(DomainError("Lengths of X and F are not the same")) end coeff = [Float64(f) for f in fsample] #     (Stoer, Bulirsch, Introduction to Numerical Analysis, . 2.1.3) for i = 2:N for j = 1:(i-1) coeff[i] = (coeff[j] - coeff[i]) / (xsample[j] - xsample[i]) end end new(N-1, tuple([Float64(x) for x in xsample]...), tuple(coeff...)) end end</span></span></code> </pre><br>  Neben der eigentlichen Erzeugung von Polynomen wäre es schön, mit ihnen arithmetische Operationen durchführen zu können. <br><br>  Da arithmetische Operatoren in Julia gewöhnliche Funktionen sind, zu denen eine Infixnotation als syntaktischer Zucker hinzugefügt wird (die Ausdrücke <code>a + b</code> und <code>+(a, b)</code> sind beide gültig und absolut identisch), erfolgt ihre Überladung auf die gleiche Weise wie beim Schreiben zusätzliche Methoden zu ihren Funktionen. <br><br>  Der einzige subtile Punkt ist, dass der Benutzercode vom Hauptmodul (Namespace) gestartet wird und sich die Funktionen der Standardbibliothek im Basismodul befinden. Wenn Sie also überladen, müssen Sie entweder das <code>Base</code> importieren oder den vollständigen Namen der Funktion schreiben. <br><br>  Also fügen wir die Addition eines Polynoms mit einer Zahl hinzu: <br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># -   Base.+  , #    Base.:+,   " :+   Base" function Base.:+(p::Polynomial, x::Real) Polynomial(tuple(p.coeff[1] + x, p.coeff[2:end]...)) end function Base.:+(p::InterpPolynomial, x::Real) # ..           - #          . #       - #        fval::Vector{Float64} = [evpoly(p, xval) + x for xval in p.xval] InterpPolynomial(p.xval, fval) end #       function Base.:+(x::Real, p::AbstractPolynomial) return p + x end</span></span></code> </pre><br>  Um zwei gewöhnliche Polynome hinzuzufügen, reicht es aus, die Koeffizienten zu addieren. Wenn Sie das Interpolationspolynom zum anderen hinzufügen, können Sie die Summenwerte an mehreren Punkten finden und daraus eine neue Interpolation erstellen. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.:+(p1::Polynomial, p2::Polynomial) <span class="hljs-comment"><span class="hljs-comment">#    ,      deg = max(p1.degree, p2.degree) coeff = zeros(deg+1) coeff[1:p1.degree+1] .+= p1.coeff coeff[1:p2.degree+1] .+= p2.coeff Polynomial(coeff) end function Base.:+(p1::InterpPolynomial, p2::InterpPolynomial) xmax = max(p1.xval..., p2.xval...) xmin = min(p1.xval..., p2.xval...) deg = max(p1.degree, p2.degree) #         #       xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * π / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * π / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::InterpPolynomial, p2::Polynomial) xmax = max(p1.xval...) xmin = min(p1.xval...) deg = max(p1.degree, p2.degree) xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * π / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * π / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::Polynomial, p2::InterpPolynomial) p2 + p1 end</span></span></code> </pre><br>  Auf die gleiche Weise können Sie andere arithmetische Operationen für Polynome hinzufügen, was zu deren Darstellung im Code in einer natürlichen mathematischen Notation führt. <br><br>  Das ist alles für jetzt.  Ich werde versuchen, weiter über die Implementierung anderer numerischer Methoden zu schreiben. <br><br>  Zur Herstellung wurden folgende Materialien verwendet: <br><ol><li>  Julia Sprachdokumentation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.julialang.org</a> </li><li>  Julia Sprachdiskussionsplattform: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diskurs.julialang.org</a> </li><li>  J. Stoer, W. Bulirsch.  Einführung in die numerische Analyse </li><li>  Julia Hub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/en/hub/julia</a> </li><li>  Denken Sie an Julia: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benlauwens.github.io/ThinkJulia.jl/latest/book.html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450628/">https://habr.com/ru/post/de450628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450614/index.html">April 2019 Joomla Digest</a></li>
<li><a href="../de450618/index.html">Warum sind Programmierer laut Statistiken von Yandex und StackOverfow C # die billigsten?</a></li>
<li><a href="../de450620/index.html">Rätsel eines Neutrinos aus Supernova 1987A</a></li>
<li><a href="../de450624/index.html">Gruß von Hayabusa-2</a></li>
<li><a href="../de450626/index.html">Designmuster korrigieren - Singleton in PHP</a></li>
<li><a href="../de450630/index.html">Frontend Weekly Digest (29. April - 5. Mai 2019)</a></li>
<li><a href="../de450632/index.html">Cram Basic in 768 Bytes</a></li>
<li><a href="../de450634/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 363 (29. April - 5. Mai 2019)</a></li>
<li><a href="../de450636/index.html">Magento 2. Monolog oder wie man Protokolle schreibt</a></li>
<li><a href="../de450640/index.html">Wie man versteht, dass man wirklich mit dem Rauchen aufhört</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>