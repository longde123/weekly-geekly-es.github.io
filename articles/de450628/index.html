<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèº üåó üòä Julia: Typen, Multimethoden und Arithmetik √ºber Polynome üöá üë®üèø‚Äçüç≥ üèïÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In dieser Ver√∂ffentlichung konzentrieren wir uns meiner Meinung nach auf das Hauptmerkmal der Julia-Sprache - die Darstellung von Funktionen in Form v...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Julia: Typen, Multimethoden und Arithmetik √ºber Polynome</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450628/">  In dieser Ver√∂ffentlichung konzentrieren wir uns meiner Meinung nach auf das Hauptmerkmal der Julia-Sprache - die Darstellung von Funktionen in Form von Methoden mit Mehrfachversand.  Auf diese Weise k√∂nnen Sie die Leistung von Berechnungen steigern, ohne die Lesbarkeit des Codes zu beeintr√§chtigen und einerseits die Abstraktheit zu beeintr√§chtigen, und andererseits k√∂nnen Sie mit mathematischen Konzepten in einer bekannteren Notation arbeiten.  Als Beispiel wird die Frage der Einheitlichkeit (unter dem Gesichtspunkt linearer Operationen) bei der Darstellung der Koeffizientenliste mit Polynomen und bei Interpolationspolynomen betrachtet. <br><a name="habracut"></a><br><h2>  Grundlegende Syntax </h2><br>  Eine kurze Einf√ºhrung f√ºr Unbekannte.  Julia ist eine skript√§hnliche Sprache mit REPL (Read-Evaluate-Print-Schleife, d. H. Eine interaktive Shell).  Auf den ersten Blick sieht es zum Beispiel Python oder MATLAB ziemlich √§hnlich. <br><h4>  Arithmetische Operationen </h4><br>  Die Arithmetik ist ungef√§hr gleich wie √ºberall: +, -, *, /, ^ f√ºr die Potenzierung usw. <br>  Vergleich:&gt;, &lt;,&gt; =, &lt;=, ==,! = Etc. <br>  Zuordnung: =. <br>  Features: Division durch <code>/</code> immer eine Bruchzahl zur√ºck;  Wenn Sie den ganzzahligen Teil der Division zweier Ganzzahlen ben√∂tigen, m√ºssen Sie die Operation <code>div(m, n)</code> oder das Infix-√Ñquivalent <code>m √∑ n</code> . <br><h4>  Typen </h4><br>  Numerische Typen: <br><ul><li>  Ganzzahlen ( <code>Int</code> ) - <code>2</code> , <code>3</code> , <code>-42</code> </li><li>  Ganzzahlen ohne <code>UInt</code> ( <code>UInt</code> ) - <code>0x12345</code> </li><li>  Gleitkomma ( <code>Float32</code> , <code>Float64</code> ) - <code>1.0</code> , <code>3.1415</code> , <code>-Inf</code> , <code>NaN</code> </li><li>  Rational ( <code>Rational</code> ) - <code>3//3</code> , <code>7//2</code> </li><li>  Real ( <code>Real</code> ) - alles oben Genannte </li><li>  Komplex ( <code>Complex</code> ) - <code>3+4*im</code> , <code>2//3+2//3*im</code> , <code>3.0+0.0*im</code> ( <code>im</code> ist eine imagin√§re Einheit, nur eine Zahl mit einem explizit geschriebenen Imagin√§rteil wird als komplex angesehen) </li><li>  <code>Number</code> - alle oben genannten </li></ul><br><br>  Zeichenfolgen und Zeichen: <br><ul><li>  <code>'a'</code> - Zeichen ( <code>Char</code> ) </li><li>  <code>"a"</code> ist ein String ( <code>String</code> ) </li></ul><br><br>  NB: Zeichenfolgen sind, wie jetzt in vielen Sprachen, unver√§nderlich. <br>  NB: Zeichenfolgen (sowie Variablennamen) unterst√ºtzen Unicode, einschlie√ülich Emoji. <br><br>  Arrays: <br><ul><li>  <code>x = [1, 2, 3]</code> - Angabe eines Arrays durch direkte Aufz√§hlung von Elementen </li><li>  spezielle Konstruktoren: <code>zeros(length)</code> f√ºr ein Array von Nullen, <code>ones(length)</code> f√ºr ein Array von Einsen, <code>rand(length)</code> f√ºr ein Array von Zufallszahlen usw. </li><li>  Unterst√ºtzung f√ºr mehrdimensionale Arrays </li><li>  Unterst√ºtzung f√ºr lineare Algebraoperationen (Hinzuf√ºgen von Arrays, Skalarmultiplikation, Matrixvektormultiplikation und vieles mehr) in der Standardbibliothek </li></ul><br><br>  NB: Alle Sammlungen werden ab einer indiziert. <br>  NB: weil  Die Sprache ist f√ºr Rechenaufgaben gedacht. Arrays sind einer der wichtigsten Typen. Sie m√ºssen mehr als einmal zu den Prinzipien ihrer Arbeit zur√ºckkehren. <br><br>  Tupel (geordneter Satz von Elementen, unver√§nderlich): <br><ul><li>  <code>(2, 5.3, "k")</code> ist ein regul√§res Tupel </li><li>  <code>(a = 3, b = 4)</code> - benanntes Tupel </li></ul><br><br>  NB: Auf die Felder eines benannten Tupels kann sowohl nach Namen durch einen Punkt als auch nach Index √ºber [] zugegriffen werden. <br><pre> <code class="julia hljs">julia&gt; x = (a = <span class="hljs-number"><span class="hljs-number">5</span></span>, b = <span class="hljs-number"><span class="hljs-number">12</span></span>) (a = <span class="hljs-number"><span class="hljs-number">5</span></span>, b = <span class="hljs-number"><span class="hljs-number">12</span></span>) julia&gt; x[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">5</span></span> julia&gt; sqrt(xa^<span class="hljs-number"><span class="hljs-number">2</span></span> + x[<span class="hljs-number"><span class="hljs-number">2</span></span>]^<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">13.0</span></span></code> </pre><br><br>  W√∂rterb√ºcher: <br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>(<span class="hljs-string"><span class="hljs-string">'a'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Char</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">2</span></span> entries: <span class="hljs-string"><span class="hljs-string">'a'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">12</span></span> julia&gt; x[<span class="hljs-string"><span class="hljs-string">'c'</span></span>] = <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span> julia&gt; x <span class="hljs-built_in"><span class="hljs-built_in">Dict</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Char</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Int64</span></span>} with <span class="hljs-number"><span class="hljs-number">3</span></span> entries: <span class="hljs-string"><span class="hljs-string">'a'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-string"><span class="hljs-string">'b'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">12</span></span></code> </pre><br><br><h4>  Grundlegende Kontrollsprachenkonstrukte </h4><br>  1. Variablen werden bei der Zuweisung automatisch erstellt.  Typ ist optional. <br><pre> <code class="julia hljs">julia&gt; x = <span class="hljs-number"><span class="hljs-number">7</span></span>; x + <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> julia&gt; x = <span class="hljs-number"><span class="hljs-number">42.0</span></span>; x * <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">168.0</span></span></code> </pre><br>  2. Der bedingte Sprungblock beginnt mit dem Ausdruck <code>if &lt;condition&gt;</code> und endet mit dem Worte <code>end</code> .  Sie k√∂nnen auch ein <code>else</code> Licht oder <code>elseif</code> Lichter haben: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &gt; y println(<span class="hljs-string"><span class="hljs-string">"X is more than Y"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> x == y println(<span class="hljs-string"><span class="hljs-string">"X and Y are equal"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> println(<span class="hljs-string"><span class="hljs-string">"X is less than Y"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  3. Es gibt zwei Schleifenkonstrukte: <code>while</code> und <code>for</code> .  Das zweite funktioniert wie in Python, d.h.  Iteriert √ºber die Sammlung.  Eine h√§ufige Verwendung ist das Durchlaufen eines Wertebereichs, dessen Syntax <code>start[:increment]:end</code> lautet.  Im Gegensatz zu Python <i>umfasst</i> ein Bereich sowohl Start- als auch Endwerte, d. H.  Der leere Bereich ist nicht <code>1:1</code> (dies ist ein Bereich von 1), sondern <code>1:0</code> .  Das Ende des Schleifenk√∂rpers ist mit dem Worte <code>end</code> markiert. <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>; print(i, <span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#   1  3   1 ( ) 1 2 3 julia&gt; for i in 1:2:3; print(i, " "); end #   1  3   2 1 3</span></span></code> </pre><br>  4. Funktionen werden durch die Schl√ºsselwortfunktion definiert, die Definition der Funktion endet ebenfalls mit dem Worte <code>end</code> .  Argumente mit Standardwerten und benannten Argumenten werden unterst√ºtzt. <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> square(x) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> cube(x) x * square(x) <span class="hljs-comment"><span class="hljs-comment">#       ; return   end function root(x, degree = 2) #  degree     return x^(1.0/degree) end function greeting(name; times = 42, greet = "hello") #       println(times, " times ", greet, " to ", name) end julia&gt; greeting("John") 42 times hello to John julia&gt; greeting("Mike", greet = "wassup", times = 100500) #           100500 times wassup to Mike</span></span></code> </pre><br><br>  Im Allgemeinen ist dies alles Python ziemlich √§hnlich, mit Ausnahme geringf√ºgiger Unterschiede in der Syntax und der Tatsache, dass die Codebl√∂cke nicht mit Leerzeichen, sondern mit Schl√ºsselw√∂rtern belegt sind.  In einfachen F√§llen √ºbersetzen Python-Programme sogar fast eins zu eins in Julia. <br>  Es gibt jedoch einen signifikanten Unterschied in der Tatsache, dass Sie in Julia explizit Typen f√ºr Variablen angeben k√∂nnen, wodurch Sie Programme kompilieren und schnellen Code erhalten k√∂nnen. <br>  Der zweite wesentliche Unterschied besteht darin, dass Python ein ‚Äûklassisches‚Äú OOP-Modell mit Klassen und Methoden implementiert, w√§hrend Julia ein Multi-Dispatch-Modell implementiert. <br><br><h4>  Geben Sie Anmerkungen und Mehrfachversand ein </h4><br>  Mal sehen, was eine eingebaute Funktion ist: <br><pre> <code class="julia hljs">julia&gt; sqrt sqrt (generic <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> with <span class="hljs-number"><span class="hljs-number">19</span></span> methods)</code> </pre><br>  Wie REPL zeigt, ist <code>sqrt</code> eine generische Funktion mit 19 Methoden.  Welche Art von verallgemeinerter Funktion und welche Art von Methoden? <br><br>  Dies bedeutet, dass es <i>mehrere</i> <code>sqrt</code> Funktionen gibt, die f√ºr verschiedene Arten von Argumenten gelten und dementsprechend die Quadratwurzel mit verschiedenen Algorithmen berechnen.  Sie k√∂nnen sehen, welche Optionen verf√ºgbar sind, indem Sie eingeben <br><pre> <code class="julia hljs">julia&gt; methods(sqrt)</code> </pre><br>  Es ist ersichtlich, dass die Funktion sowohl f√ºr verschiedene Arten von Zahlen als auch f√ºr Matrizen definiert ist. <br><br>  Im Gegensatz zum ‚Äûklassischen‚Äú OOP, bei dem die konkrete Implementierung der Methode nur von der aufrufenden Klasse bestimmt wird (Dispatching durch das erste Argument), wird bei Julia die Auswahl einer Funktion durch die Typen (und die Anzahl) <i>aller</i> ihrer Argumente bestimmt. <br>  Wenn Sie eine Funktion mit bestimmten Argumenten aus all ihren Methoden aufrufen, wird eine ausgew√§hlt, die den spezifischen Satz von Typen, mit denen die Funktion aufgerufen wird, am genauesten beschreibt und der verwendet wird. <br><br>  Eine Besonderheit besteht darin, dass ein Ansatz angewendet wird, der von den Autoren der Sprache als "nur vorzeitig" zusammengestellt wird.  Das hei√üt,  Funktionen werden beim ersten Aufruf f√ºr die angegebenen Datentypen kompiliert, wonach die folgenden Aufrufe viel schneller ausgef√ºhrt werden.  Der Unterschied zwischen dem ersten und den nachfolgenden Anrufen kann sehr bedeutend sein: <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-meta"><span class="hljs-meta">@time</span></span> sqrt(<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  @time -      0.006811 seconds (3.15 k allocations: 168.516 KiB) #   ,        2.8284271247461903 julia&gt; @time sqrt(15) 0.000002 seconds (5 allocations: 176 bytes) # 5   -     @time 3.872983346207417</span></span></code> </pre><br>  Im schlechten Fall ist jeder Funktionsaufruf eine √úberpr√ºfung des Typs der empfangenen Argumente und eine Suche nach der gew√ºnschten Methode in der Liste.  Wenn Sie dem Compiler jedoch Hinweise geben, k√∂nnen Sie die √úberpr√ºfungen eliminieren, was zu schnellerem Code f√ºhrt. <br><br>  Betrachten Sie beispielsweise die Berechnung der Summe <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mo>&amp;#x2212;</mo><mn>1</mn><msup><mo stretchy=&quot;false&quot;>)</mo><mi>k</mi></msup></mrow></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.728ex" height="3.262ex" viewBox="0 -987.6 8063.4 1404.6" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-4E" x="1242" y="488"></use><g transform="translate(878,-327)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-31" x="1300" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-73" x="3793" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-71" x="4263" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-72" x="4723" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-74" x="5175" y="0"></use><g transform="translate(5536,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2212" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-31" x="1168" y="0"></use><g transform="translate(1668,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="550" y="583"></use></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mtext>&nbsp;</mtext><mi>s</mi><mi>q</mi><mi>r</mi><mi>t</mi><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mo>‚àí</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>k</mi></msup></mrow></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> \ sum_ {k = 1} ^ N \ sqrt {(- 1) ^ k} </script></p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> mysqrt(num) <span class="hljs-comment"><span class="hljs-comment">#    -     #   -           if num &gt;= 0 return sqrt(num) else return sqrt(complex(num)) end end function S(n) #    sum = 0 sgn = -1 for k = 1:n sum += mysqrt(sgn) sgn = -sgn end return sum end function S_typed(n::Integer) # ..     ,      #     sum::Complex = 0.0 sgn::Int = -1 for k = 1:n sum += mysqrt(sgn) sgn = -sgn end return sum end</span></span></code> </pre><br>  Der Benchmark zeigt, dass die Funktion <code>S_typed()</code> Gegensatz zu <code>S()</code> nicht nur schneller ausgef√ºhrt wird, sondern auch nicht f√ºr jeden Aufruf eine Speicherzuweisung erfordert.  Das Problem hierbei ist, dass der Typ des von <code>mysqrt()</code> zur√ºckgegebenen <code>mysqrt()</code> nicht definiert ist, genau wie der Typ der rechten Seite des Ausdrucks <br><pre> <code class="julia hljs">sum = sum + mysqrt(sgn)</code> </pre><br>  Infolgedessen kann der Compiler nicht einmal herausfinden, welche <code>sum</code> bei jeder Iteration sein wird.  Boxen (Typ Label Hooking) ist also eine Variable und Speicher wird zugewiesen. <br>  F√ºr die Funktion <code>S_typed()</code> wei√ü der Compiler im Voraus, dass <code>sum</code> ein komplexer Wert ist, sodass der Code optimierter ist (insbesondere kann der Aufruf von <code>mysqrt()</code> effektiv inline erfolgen und den R√ºckgabewert immer an <code>Complex</code> ). <br><br>  Noch wichtiger ist, dass <code>S_typed()</code> Compiler f√ºr <code>S_typed()</code> wei√ü, dass der R√ºckgabewert vom Typ <code>Complex</code> , aber f√ºr <code>S()</code> Typ des Ausgabewerts nicht erneut definiert, wodurch alle Funktionen verlangsamt werden, bei denen <code>S()</code> aufgerufen wird. <br>  Mit dem Makro <code>@code_warntype</code> k√∂nnen Sie √ºberpr√ºfen, ob der Compiler √ºber die vom Ausdruck zur√ºckgegebenen Typen <code>@code_warntype</code> : <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-meta"><span class="hljs-meta">@code_warntype</span></span> S(<span class="hljs-number"><span class="hljs-number">3</span></span>) Body::<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span> <span class="hljs-comment"><span class="hljs-comment">#     ,      ... julia&gt; @code_warntype S_typed(3) Body::Complex{Float64} #      ...</span></span></code> </pre><br>  Wenn eine Funktion irgendwo in der Schleife aufgerufen wird, f√ºr die <code>@code_warntype</code> den R√ºckgabetyp nicht ausgeben kann oder f√ºr die irgendwo im Body der Empfang eines Werts vom Typ <code>Any</code> <code>@code_warntype</code> , f√ºhrt die Optimierung dieser Aufrufe h√∂chstwahrscheinlich zu einer sp√ºrbaren Leistungssteigerung. <br><br><h4>  Verbindungstypen </h4><br>  Ein Programmierer kann zusammengesetzte Datentypen f√ºr seine Anforderungen mithilfe des <code>struct</code> : <br><pre> <code class="julia hljs">julia&gt; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> GenericStruct <span class="hljs-comment"><span class="hljs-comment">#   struct    name b::Int c::Char v::Vector end #       #       ,        julia&gt; s = GenericStruct("Name", 1, 'z', [3., 0]) GenericStruct("Name", 1, 'z', [3.0, 0.0]) julia&gt; s.name, sb, sc, sv ("Name", 1, 'z', [3.0, 0.0])</span></span></code> </pre><br>  Strukturen in Julia sind unver√§nderlich, d. H. Durch Erstellen einer Instanz der Struktur ist es nicht mehr m√∂glich, die Feldwerte zu √§ndern (genauer gesagt, Sie k√∂nnen die Adresse von Feldern im Speicher nicht √§ndern - Elemente von ver√§nderlichen Feldern, wie z. B. <code>sv</code> im obigen Beispiel, k√∂nnen ge√§ndert werden).  Mutable Strukturen werden durch das mutable Strukturkonstrukt erstellt, dessen Syntax dieselbe ist wie f√ºr regul√§re Strukturen. <br><br>  Die Vererbung von Strukturen im ‚Äûklassischen‚Äú Sinne wird nicht unterst√ºtzt, es besteht jedoch die M√∂glichkeit, Verhalten zu ‚Äûerben‚Äú, indem zusammengesetzte Typen zu Supertypen oder, wie sie in Julia genannt werden, abstrakten Typen kombiniert werden.  Typbeziehungen werden ausgedr√ºckt als <code>A&lt;:B</code> (A ist ein Subtyp von B) und <code>A&gt;:B</code> (A ist ein Subtyp von B).  Es sieht ungef√§hr so ‚Äã‚Äãaus: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> NDimPoint <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#   -     # ,    -     N  struct PointScalar&lt;:NDimPoint x1::Real end struct Point2D&lt;:NDimPoint x1::Real x2::Real end struct Point3D&lt;:NDimPoint x1::Real x2::Real x3::Real end #     ;   Markdown """ mag(p::NDimPoint) Calculate the magnitude of the radius vector of an N-dimensional point `p` """ function mag(p::NDimPoint) sqrmag = 0.0 # ..   ,       #     T   fieldnames(T) for name in fieldnames(typeof(p)) sqrmag += getfield(p, name)^2 end return sqrt(sqrmag) end """ add(p1::T, p2::T) where T&lt;:NDimPoint Calculate the sum of the radius vectors of two N-dimensional points `p1` and `p2` """ function add(p1::T, p2::T) where T&lt;:NDimPoint #  -  , ..       #     list comprehension sumvector = [Float64(getfield(p1, name) + getfield(p1, name)) for name in fieldnames(T)] #     ,    #  ...      , .. # f([1, 2, 3]...) -   ,  f(1, 2, 3) return T(sumvector...) end</span></span></code> </pre><br><h4>  Fallstudie: Polynome </h4><br>  Ein Typensystem, das mit Mehrfachversand gekoppelt ist, ist praktisch, um mathematische Konzepte auszudr√ºcken.  Schauen wir uns ein Beispiel einer einfachen Bibliothek f√ºr die Arbeit mit Polynomen an. <br>  Wir f√ºhren zwei Arten von Polynomen ein: "kanonisch", definiert durch Koeffizienten bei Potenzen, und "Interpolation", definiert durch eine Menge von Paaren (x, f (x)).  Der Einfachheit halber werden nur g√ºltige Argumente ber√ºcksichtigt. <br><br>  Zum Speichern eines Polynoms in einer √ºblichen Notation ist eine Struktur mit einem Array oder einem Tupel von Koeffizienten als Feld geeignet.  Um v√∂llig unver√§nderlich zu sein, soll es eine Wagenkolonne geben.  Daher ist der Code zum Definieren des abstrakten Typs, der Struktur des Polynoms und zum Berechnen des Werts des Polynoms an einem bestimmten Punkt recht einfach: <br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> AbstractPolynomial <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" Polynomial &lt;: AbstractPolynomial Polynomials written in the canonical form """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-comment"><span class="hljs-comment"># NTuple{N, Type} -    N    end """ evpoly(p::Polynomial, z::Real) Evaluate polynomial `p` at `z` using the Horner's rule """ function evpoly(p::Polynomial, z::Real) ans = p.coeff[end] for idx = p.degree:-1:1 ans = p.coeff[idx] + z * ans end return ans end</span></span></code> </pre><br><br>  Interpolationspolynome ben√∂tigen eine andere Darstellungsstruktur und Berechnungsmethode.  Insbesondere wenn der Satz von Interpolationspunkten im Voraus bekannt ist und geplant ist, dasselbe Polynom an verschiedenen Punkten zu berechnen, ist die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Newtonsche Interpolationsformel</a> zweckm√§√üig: <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>c</mi><mi>k</mi></msub><msub><mi>n</mi><mi>k</mi></msub><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></mrow><mo>,</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="24.578ex" height="3.021ex" viewBox="0 -883.9 10582.2 1300.8" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-50" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="751" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="1141" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="1713" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="2380" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-73" x="3687" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-75" x="4156" y="0"></use><g transform="translate(4729,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-4E" x="1242" y="488"></use><g transform="translate(878,-327)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-30" x="1300" y="0"></use></g></g><g transform="translate(6980,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-63" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="613" y="-213"></use><g transform="translate(902,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="849" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="1971" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="2361" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="2933" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2C" x="10303" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mi>N</mi></msubsup><mrow class="MJX-TeXAtom-ORD"><msub><mi>c</mi><mi>k</mi></msub><msub><mi>n</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mo>,</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> P (x) = \ sum_ {k = 0} ^ N {c_k n_k (x)}, </script></p><br>  wobei <i>n <sub>k</sub></i> ( <i>x</i> ) Grundpolynome sind, <i>n <sub>0</sub></i> ( <i>x</i> ) und f√ºr <i>k</i> &gt; 0 <br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><msub><mi>n</mi><mi>k</mi></msub><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo><mo>=</mo><mtext>&amp;#xA0;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo>&amp;#x2212;</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy=&quot;false&quot;>)</mo></mrow><mo>,</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="25.81ex" height="3.262ex" viewBox="0 -987.6 11112.7 1404.6" role="img" focusable="false" style="vertical-align: -0.969ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="849" y="-213"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="1069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="1458" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="2031" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="2698" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-70" x="4004" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-72" x="4508" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6F" x="4959" y="0"></use><g transform="translate(5445,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-64" x="0" y="0"></use><g transform="translate(524,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(520,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-3D" x="345" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-30" x="1124" y="0"></use></g></g><g transform="translate(7342,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2212" x="1184" y="0"></use><g transform="translate(2184,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMATHI-69" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-29" x="3101" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=https://habr.com/ru/post/450628/&amp;usg=ALkJrhgAxyXSubmJDNxU4jp7l7U2N9az4w#MJMAIN-2C" x="10834" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><msub><mi>n</mi><mi>k</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>&nbsp;</mtext><mi>p</mi><mi>r</mi><mi>o</mi><msubsup><mi>d</mi><mrow class="MJX-TeXAtom-ORD"><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>‚àí</mo><mn>1</mn></mrow></msubsup><mrow class="MJX-TeXAtom-ORD"><mo stretchy="false">(</mo><mi>x</mi><mo>‚àí</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><mo>,</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-3"> n_k (x) = \ prod_ {i = 0} ^ {k-1} {(x-x_i)}, </script></p><br>  wobei <i>x <sub>i</sub></i> die Interpolationsknoten sind. <br><br>  Aus den obigen Formeln ist ersichtlich, dass die Speicherung zweckm√§√üigerweise in Form eines Satzes von Interpolationsknoten <i>x <sub>i</sub></i> und Koeffizienten <i>c <sub>i organisiert</sub></i> ist und die Berechnung auf √§hnliche Weise wie das Horner-Schema durchgef√ºhrt werden kann. <br><pre> <code class="julia hljs"><span class="hljs-string"><span class="hljs-string">""" InterpPolynomial &lt;: AbstractPolynomial Interpolation polynomials in Newton's form """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> InterpPolynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> xval::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-string"><span class="hljs-string">""" evpoly(p::Polynomial, z::Real) Evaluate polynomial `p` at `z` using the Horner's rule """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> evpoly(p::InterpPolynomial, z::<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>) ans = p.coeff[p.degree+<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> idx = p.degree:-<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span> ans = ans * (z - p.xval[idx]) + p.coeff[idx] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ans <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Die Funktion zur Berechnung des Wertes des Polynoms hei√üt in beiden F√§llen gleich - <code>evpoly()</code> - akzeptiert jedoch unterschiedliche Arten von Argumenten. <br><br>  Zus√§tzlich zur Berechnungsfunktion w√§re es sch√∂n, eine Funktion zu schreiben, die aus bekannten Daten ein Polynom erstellt. <br><br>  In Julia gibt es daf√ºr zwei Techniken: externe Konstruktoren und interne Konstruktoren.  Ein externer Konstruktor ist einfach eine Funktion, die ein Objekt des entsprechenden Typs zur√ºckgibt.  Ein interner Konstruktor ist eine Funktion, die in die Strukturbeschreibung eingef√ºhrt wird und den Standardkonstruktor ersetzt.  Es ist ratsam, den internen Konstruktor zu verwenden, um Interpolationspolynome zu konstruieren, da <br><ul><li>  Es ist bequemer, ein Polynom nicht durch die Interpolationsknoten und -koeffizienten zu erhalten, sondern durch die Knoten und Werte der interpolierten Funktion </li><li>  Interpolationsknoten m√ºssen unterschiedlich sein </li><li>  Die Anzahl der Knoten und Koeffizienten muss √ºbereinstimmen </li></ul><br>  Durch das Schreiben eines internen Konstruktors, in dem diese Regeln garantiert eingehalten werden, wird sichergestellt, dass alle erstellten Variablen vom Typ <code>InterpPolynomial</code> zumindest von der Funktion <code>evpoly()</code> korrekt verarbeitet werden k√∂nnen. <br><br>  Wir schreiben einen Konstruktor gew√∂hnlicher Polynome, der ein eindimensionales Array oder ein Tupel von Koeffizienten als Eingabe verwendet.  Der Konstruktor des Interpolationspolynoms empf√§ngt die Interpolationsknoten und die darin enthaltenen gew√ºnschten Werte und berechnet die Koeffizienten nach der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Methode der geteilten Differenzen</a> . <br><pre> <code class="julia hljs"><span class="hljs-string"><span class="hljs-string">""" Polynomial &lt;: AbstractPolynomial Polynomials written in the canonical form --- Polynomial(v::T) where T&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}) Construct a `Polynomial` from the list of the coefficients. The coefficients are assumed to go from power 0 in the ascending order. If an empty collection is provided, the constructor returns a zero polynomial. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Polynomial&lt;:AbstractPolynomial degree::<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> coeff::<span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{N, <span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> N <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Polynomial(v::T <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Union</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Vector</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">NTuple</span></span>{&lt;:<span class="hljs-built_in"><span class="hljs-built_in">Any</span></span>, &lt;:<span class="hljs-built_in"><span class="hljs-built_in">Real</span></span>}}) <span class="hljs-comment"><span class="hljs-comment">#     /     P(x) ‚â° 0 coeff = isempty(v) ? (0.0,) : tuple([Float64(x) for x in v]...) #   -   new #  -    return new(length(coeff)-1, coeff) end end """ InterpPolynomial &lt;: AbstractPolynomial Interpolation polynomials in Newton's form --- InterpPolynomial(xsample::Vector{&lt;:Real}, fsample::Vector{&lt;:Real}) Construct an `InterpPolynomial` from a vector of points `xsample` and corresponding function values `fsample`. All values in `xsample` must be distinct. """ struct InterpPolynomial&lt;:AbstractPolynomial degree::Int xval::NTuple{N, Float64} where N coeff::NTuple{N, Float64} where N function InterpPolynomial(xsample::X, fsample::F) where {X&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}, F&lt;:Union{Vector{&lt;:Real}, NTuple{&lt;:Any, &lt;:Real}}} #   ,    ,   f  ,   if !allunique(xsample) throw(DomainError("Cannot interpolate with duplicate X points")) end N = length(xsample) if length(fsample) != N throw(DomainError("Lengths of X and F are not the same")) end coeff = [Float64(f) for f in fsample] #     (Stoer, Bulirsch, Introduction to Numerical Analysis, . 2.1.3) for i = 2:N for j = 1:(i-1) coeff[i] = (coeff[j] - coeff[i]) / (xsample[j] - xsample[i]) end end new(N-1, tuple([Float64(x) for x in xsample]...), tuple(coeff...)) end end</span></span></code> </pre><br>  Neben der eigentlichen Erzeugung von Polynomen w√§re es sch√∂n, mit ihnen arithmetische Operationen durchf√ºhren zu k√∂nnen. <br><br>  Da arithmetische Operatoren in Julia gew√∂hnliche Funktionen sind, zu denen eine Infixnotation als syntaktischer Zucker hinzugef√ºgt wird (die Ausdr√ºcke <code>a + b</code> und <code>+(a, b)</code> sind beide g√ºltig und absolut identisch), erfolgt ihre √úberladung auf die gleiche Weise wie beim Schreiben zus√§tzliche Methoden zu ihren Funktionen. <br><br>  Der einzige subtile Punkt ist, dass der Benutzercode vom Hauptmodul (Namespace) gestartet wird und sich die Funktionen der Standardbibliothek im Basismodul befinden. Wenn Sie also √ºberladen, m√ºssen Sie entweder das <code>Base</code> importieren oder den vollst√§ndigen Namen der Funktion schreiben. <br><br>  Also f√ºgen wir die Addition eines Polynoms mit einer Zahl hinzu: <br><pre> <code class="julia hljs"><span class="hljs-comment"><span class="hljs-comment"># -   Base.+  , #    Base.:+,   " :+   Base" function Base.:+(p::Polynomial, x::Real) Polynomial(tuple(p.coeff[1] + x, p.coeff[2:end]...)) end function Base.:+(p::InterpPolynomial, x::Real) # ..           - #          . #       - #        fval::Vector{Float64} = [evpoly(p, xval) + x for xval in p.xval] InterpPolynomial(p.xval, fval) end #       function Base.:+(x::Real, p::AbstractPolynomial) return p + x end</span></span></code> </pre><br>  Um zwei gew√∂hnliche Polynome hinzuzuf√ºgen, reicht es aus, die Koeffizienten zu addieren. Wenn Sie das Interpolationspolynom zum anderen hinzuf√ºgen, k√∂nnen Sie die Summenwerte an mehreren Punkten finden und daraus eine neue Interpolation erstellen. <br><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Base.:+(p1::Polynomial, p2::Polynomial) <span class="hljs-comment"><span class="hljs-comment">#    ,      deg = max(p1.degree, p2.degree) coeff = zeros(deg+1) coeff[1:p1.degree+1] .+= p1.coeff coeff[1:p2.degree+1] .+= p2.coeff Polynomial(coeff) end function Base.:+(p1::InterpPolynomial, p2::InterpPolynomial) xmax = max(p1.xval..., p2.xval...) xmin = min(p1.xval..., p2.xval...) deg = max(p1.degree, p2.degree) #         #       xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * œÄ / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * œÄ / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::InterpPolynomial, p2::Polynomial) xmax = max(p1.xval...) xmin = min(p1.xval...) deg = max(p1.degree, p2.degree) xmid = 0.5 * xmax + 0.5 * xmin dx = 0.5 * (xmax - xmin) / cos(0.5 * œÄ / (deg + 1)) chebgrid = [xmid + dx * cos((k - 0.5) * œÄ / (deg + 1)) for k = 1:deg+1] fsample = [evpoly(p1, x) + evpoly(p2, x) for x in chebgrid] InterpPolynomial(chebgrid, fsample) end function Base.:+(p1::Polynomial, p2::InterpPolynomial) p2 + p1 end</span></span></code> </pre><br>  Auf die gleiche Weise k√∂nnen Sie andere arithmetische Operationen f√ºr Polynome hinzuf√ºgen, was zu deren Darstellung im Code in einer nat√ºrlichen mathematischen Notation f√ºhrt. <br><br>  Das ist alles f√ºr jetzt.  Ich werde versuchen, weiter √ºber die Implementierung anderer numerischer Methoden zu schreiben. <br><br>  Zur Herstellung wurden folgende Materialien verwendet: <br><ol><li>  Julia Sprachdokumentation: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">docs.julialang.org</a> </li><li>  Julia Sprachdiskussionsplattform: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diskurs.julialang.org</a> </li><li>  J. Stoer, W. Bulirsch.  Einf√ºhrung in die numerische Analyse </li><li>  Julia Hub: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/en/hub/julia</a> </li><li>  Denken Sie an Julia: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">benlauwens.github.io/ThinkJulia.jl/latest/book.html</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de450628/">https://habr.com/ru/post/de450628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de450614/index.html">April 2019 Joomla Digest</a></li>
<li><a href="../de450618/index.html">Warum sind Programmierer laut Statistiken von Yandex und StackOverfow C # die billigsten?</a></li>
<li><a href="../de450620/index.html">R√§tsel eines Neutrinos aus Supernova 1987A</a></li>
<li><a href="../de450624/index.html">Gru√ü von Hayabusa-2</a></li>
<li><a href="../de450626/index.html">Designmuster korrigieren - Singleton in PHP</a></li>
<li><a href="../de450630/index.html">Frontend Weekly Digest (29. April - 5. Mai 2019)</a></li>
<li><a href="../de450632/index.html">Cram Basic in 768 Bytes</a></li>
<li><a href="../de450634/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 363 (29. April - 5. Mai 2019)</a></li>
<li><a href="../de450636/index.html">Magento 2. Monolog oder wie man Protokolle schreibt</a></li>
<li><a href="../de450640/index.html">Wie man versteht, dass man wirklich mit dem Rauchen aufh√∂rt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>