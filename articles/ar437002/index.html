<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍️ ⁉️ 🛑 صالح ASP.NET الأساسية 🛀🏾 🏴󠁧󠁢󠁷󠁬󠁳󠁿 👨🏾‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="خاصة لمحبي الكتب من سلسلة "C ++ في غضون 24 ساعة" ، قررت أن أكتب مقالًا حول ASP.NET Core. 


 إذا لم تكن قد طورت مسبقًا من أجل .NET أو لبعض الأنظمة الأ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>صالح ASP.NET الأساسية</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437002/" style=";text-align:right;direction:rtl"><p style=";text-align:right;direction:rtl"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u="><img src="https://habrastorage.org/webt/sy/y_/ph/syy_ph0f1cwt9upm9frbr6z5ggi.jpeg" alt="صالح ASP.NET الأساسية"></a> </p><br><p style=";text-align:right;direction:rtl">  خاصة لمحبي الكتب من سلسلة "C ++ في غضون 24 ساعة" ، قررت أن أكتب مقالًا حول ASP.NET Core. </p><br><p style=";text-align:right;direction:rtl">  إذا لم تكن قد طورت مسبقًا من أجل .NET أو لبعض الأنظمة الأساسية المشابهة ، فلا معنى لذلك أن تخفض من قواك.  ولكن إذا كنت مهتمًا بمعرفة ما هو IoC و DI و DIP و Interseptors و Middleware و Filters (أي كل شيء يختلف عن Core من .NET الكلاسيكية) ، فأنت بحاجة بالتأكيد إلى النقر فوق "قراءة المزيد" ، أثناء تطوير من دون فهم كل هذا ، من الواضح أنه غير صحيح. </p><a name="habracut"></a><br><h2 id="ioc-di-dip" style=";text-align:right;direction:rtl">  IOC ، DI ، DIP </h2><br><p style=";text-align:right;direction:rtl">  إذا بدأ المسرح مع شماعات ، ثم يبدأ ASP.NET Core مع Dependency Injection.  من أجل التعامل مع DI ، تحتاج إلى فهم ما هو IoC. </p><br><p style=";text-align:right;direction:rtl">  عند الحديث عن IoC ، غالبًا ما يتذكر المرء مبدأ هوليوود وهو "لا تتصل بنا ، وسنتصل بك".  مما يعني "لا حاجة للاتصال بنا ، وسوف نتصل بك أنفسنا". </p><br><p style=";text-align:right;direction:rtl"> توفر المصادر المختلفة أنماطًا مختلفة يمكن تطبيق IoC عليها.  وعلى الأرجح أنهم جميعا على حق ويكملون بعضهم البعض.  فيما يلي بعض هذه الأنماط: المصنع ، محدد موقع الخدمة ، طريقة القالب ، المراقب ، الإستراتيجية. </p><br><p style=";text-align:right;direction:rtl">  دعنا ننظر إلى IoC باستخدام تطبيق وحدة تحكم بسيط كمثال. </p><br><p style=";text-align:right;direction:rtl">  افترض أن لدينا فئتين بسيطتين تقومان بتطبيق واجهة مع طريقة واحدة: </p><br><pre style=";text-align:right;direction:rtl"><code class="plaintext hljs">class ConsoleLayer : ILayer { public void Write(string text) { Console.WriteLine(text); } } class DebugLayer : ILayer { public void Write(string text) { Debug.WriteLine(text); } } interface ILayer { void Write(string text); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  كلاهما يعتمد على التجريد (في هذه الحالة ، تعمل الواجهة كعملية تجريدية). </p><br><p style=";text-align:right;direction:rtl">  ودعنا نقول أن لدينا كائن مستوى أعلى باستخدام هذه الفئات: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> class Logging : ILayer { private ILayer _instance; public Logging(int i) { if (i == 1) { _instance = new ConsoleLayer(); } else { _instance = new DebugLayer(); } } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  وفقًا لمعلمة المنشئ ، تتم تهيئة متغير _instance بواسطة فئة معينة.  حسنًا ، علاوة على ذلك ، عند الاتصال بالكتابة ، سيتم إكمال الإخراج إلى وحدة التحكم أو Debug.  يبدو أن كل شيء جيد جدًا وحتى ، كما يبدو ، يتوافق مع الجزء الأول من مبدأ انعكاس التبعية </p><br><blockquote style=";text-align:right;direction:rtl">  الكائنات ذات المستوى الأعلى مستقلة عن الكائنات ذات المستوى الأدنى.  كل من هؤلاء وتلك تعتمد على التجريد. </blockquote><p style=";text-align:right;direction:rtl">  في حالتنا ، يعمل ILayer بمثابة تجريد. </p><br><p style=";text-align:right;direction:rtl">  ولكن يجب أن يكون لدينا أيضًا كائن بمستوى أعلى.  واحد يستخدم فئة التسجيل </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(1); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  من خلال تهيئة التسجيل بـ 1 ، ندخل في فئة التسجيل مثيلًا للفئة التي تُخرج البيانات إلى وحدة التحكم.  إذا تم تهيئة التسجيل باستخدام أي رقم آخر ، فسوف يقوم log.Write بإخراج البيانات إلى تصحيح الأخطاء.  كل شيء ، على ما يبدو ، يعمل ، لكنه يعمل بشكل سيء.  يعتمد كائننا ذي المستوى الأعلى على تفاصيل رمز الكائن ذي المستوى الأدنى - فئة التسجيل.  إذا قمنا بتغيير شيء ما في هذه الفئة ، فسنحتاج إلى تغيير رمز الفئة الرئيسية.  لمنع حدوث ذلك ، سنقوم بانعكاس التحكم - انعكاس التحكم.  لنجعل الفئة الرئيسية تتحكم في ما يحدث في فئة التسجيل.  ستتلقى فئة التسجيل ، كمعلمة مُنشئ ، مثيل لفئة تنفذ واجهة ILayer </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> class Logging { private ILayer _instance; public Logging(ILayer instance) { _instance = instance; } public void Write(string text) { _instance.Write(text); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  والآن ، سيبدو صفنا الرئيسي كما يلي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> static void Main(string[] args) { var log = new Logging(new DebugLayer()); log.Write("Hello!"); Console.Read(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  في الواقع ، نحن تزيين كائن تسجيل لدينا مع الكائن الضروري بالنسبة لنا. </p><br><p style=";text-align:right;direction:rtl">  يتوافق الآن طلبنا مع الجزء الثاني من مبدأ انعكاس التبعية: </p><br><blockquote style=";text-align:right;direction:rtl">  التجريدات مستقلة عن التفاصيل.  التفاصيل تعتمد على التجريد.  أي  لا نعرف تفاصيل ما يحدث في فئة التسجيل ، فنحن نمرر الفصل الذي ينفذ التجريد الضروري. </blockquote><p style=";text-align:right;direction:rtl">  هناك مثل هذا المصطلح اقتران ضيق - اتصال ضيق.  كلما كان الاتصال بين المكونات في التطبيق أضعف ، كان ذلك أفضل.  أود أن أشير إلى أن هذا المثال للتطبيق البسيط لا يصل إلى المستوى المثالي قليلاً.  لماذا؟  نعم ، لأنه في أعلى مستوى في Main ، نستخدم مرتين إنشاء مثيلات فئة باستخدام new.  وهناك عبارة ذاكري "New is a clue" - مما يعني أنه كلما قل استخدامك الجديد ، قلت اتصالات المكونات في التطبيق بشكل أفضل.  من الناحية المثالية ، يجب ألا نستخدم DebugLayer الجديد ، ولكن يجب أن نحصل على DebugLayer بطريقة أخرى.  أي واحد؟  على سبيل المثال ، من حاوية IoC أو باستخدام انعكاس من معلمة تم تمريرها إلى Main. </p><br><p style=";text-align:right;direction:rtl">  لقد اكتشفنا الآن ما هو انعكاس التحكم (IoC) وما هو انعكاس التبعية (DIP).  يبقى أن نفهم ما هو Dependency Injection (DI).  IoC هو نموذج التصميم.  Dependency Injection هو النمط.  هذا ما لدينا الآن في مُنشئ فئة التسجيل.  نحصل على مثيل تبعية محددة.  تعتمد فئة التسجيل على مثيل لفئة تقوم بتنفيذ ILayer.  ويتم حقن هذه الحالة من خلال المنشئ. </p><br><h2 id="ioc-container" style=";text-align:right;direction:rtl">  حاوية IoC </h2><br><p style=";text-align:right;direction:rtl">  حاوية IoC هي كائن يحتوي على العديد من التبعيات المحددة (التبعية).  يمكن أن يُطلق على التبعية خدمة - كقاعدة عامة ، إنها فئة ذات وظيفة معينة.  إذا لزم الأمر ، يمكن الحصول على اعتماد النوع المطلوب من الحاوية.  حقن التبعية في حاوية هو حقن.  استخراج - حل.  فيما يلي مثال على أبسط حاوية IoC مكتوبة ذاتيًا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public static class IoCContainer { private static readonly Dictionary&lt;Type, Type&gt; _registeredObjects = new Dictionary&lt;Type, Type&gt;(); public static dynamic Resolve&lt;TKey&gt;() { return Activator.CreateInstance(_registeredObjects[typeof(TKey)]); } public static void Register&lt;TKey, TConcrete&gt;() where TConcrete : TKey { _registeredObjects[typeof(TKey)] = typeof(TConcrete); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  فقط عشرة أسطر من التعليمات البرمجية ، لكن يمكنك استخدامها بالفعل (ليس للإنتاج ، بالطبع ، ولكن للأغراض التعليمية). </p><br><p style=";text-align:right;direction:rtl">  يمكنك تسجيل التبعية (على سبيل المثال ، ConsoleLayer أو DebugLayer التي استخدمناها في المثال السابق) مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> IoCContainer.Register&lt;ILayer, ConsoleLayer&gt;();</code> </pre> <br><p style=";text-align:right;direction:rtl">  واستخرجها من الحاوية في المكان المناسب للبرنامج مثل هذا: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> ILayer layer = IoCContainer.Resolve&lt;ILayer&gt;(); layer.Write("Hello from IoC!");</code> </pre> <br><p style=";text-align:right;direction:rtl">  في الحاويات الحقيقية ، يتم أيضًا تطبيق Dispos () ، مما يسمح لك بتدمير الموارد التي أصبحت غير ضرورية. </p><br><p style=";text-align:right;direction:rtl">  بالمناسبة ، اسم حاوية IoC لا ينقل المعنى بالضبط ، لأن مصطلح IoC أوسع بكثير في التطبيق.  لذلك ، تم استخدام مصطلح حاوية DI مؤخرًا في كثير من الأحيان (بما أن حقن التبعية لا يزال مطبقًا). </p><br><h2 id="service-lifetimes--various-extension-methods-in-composition-root" style=";text-align:right;direction:rtl">  عمر الخدمة + طرق تمديد مختلفة في Root Composition </h2><br><p style=";text-align:right;direction:rtl">  تحتوي تطبيقات ASP.NET Core على ملف Startup.cs ، وهو نقطة الانطلاق للتطبيق لتكوين DI.  يقوم بتكوين DI في أسلوب ConfigureServices. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public void ConfigureServices(IServiceCollection services) { services.AddScoped&lt;ISomeRepository, SomeRepository&gt;(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  سيضيف هذا الرمز فئة SomeRepository إلى حاوية DI ، والتي تنفذ واجهة ISomeRepository.  حقيقة إضافة الخدمة إلى الحاوية باستخدام AddScoped تعني أنه سيتم إنشاء مثيل للفئة في كل مرة يتم فيها طلب صفحة. <br>  يمكنك إضافة خدمة إلى حاوية دون تحديد واجهة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddScoped&lt;SomeRepository&gt;();</code> </pre> <br><p style=";text-align:right;direction:rtl">  لكن هذه الطريقة غير موصى بها ، حيث يفقد التطبيق مرونته وتظهر الاتصالات الوثيقة.  يوصى دائمًا بتحديد واجهة ، لأنه في هذه الحالة ، في أي وقت ، يمكنك استبدال تطبيق واجهة أخرى.  وإذا كانت التطبيقات تدعم مبدأ استبدال Liskov ، فعن طريق تغيير اسم فئة التنفيذ بـ "نقرة من المعصم" ، ستقوم بتغيير وظيفة التطبيق بأكمله. </p><br><p style=";text-align:right;direction:rtl">  هناك خياران إضافيان لإضافة خدمة - AddSingleton و AddTransient. <br>  عند استخدام AddSingleton ، يتم إنشاء الخدمة مرة واحدة ، وعند استخدام التطبيق ، تنتقل المكالمة إلى نفس المثيل.  استخدم هذه الطريقة بعناية خاصة ، حيث يمكن حدوث تسرب للذاكرة ومشاكل تعدد مؤشرات الترابط. </p><br><p style=";text-align:right;direction:rtl">  AddSingleton لديه ميزة صغيرة.  يمكن تهيئته إما عند أول وصول إليه </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService, YourService&gt;();</code> </pre> <br><p style=";text-align:right;direction:rtl">  إما على الفور عند إضافتها إلى المنشئ </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddSingleton&lt;IYourService&gt;(new YourService(param));</code> </pre> <br><p style=";text-align:right;direction:rtl">  في الطريقة الثانية ، يمكنك حتى إضافة معلمة إلى المنشئ. <br>  إذا كنت ترغب في إضافة معلمة إلى مُنشئ الخدمة المضافة ليس فقط باستخدام AddSingleton ، ولكن أيضًا باستخدام AddTransient / AddScoped ، يمكنك استخدام تعبير lambda: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddTransient&lt;IYourService&gt;(o =&gt; new YourService(param));</code> </pre> <br><p style=";text-align:right;direction:rtl">  وأخيرًا ، عند استخدام AddTransient ، يتم إنشاء خدمة في كل مرة تدخل فيها.  كبيرة للخدمات خفيفة الوزن التي لا تستهلك الذاكرة والموارد. </p><br><p style=";text-align:right;direction:rtl">  إذا كان مع كل من AddSingleton و AddScoped يجب أن يكون كل شيء أكثر أو أقل وضوحًا ، فإن AddTransient يحتاج إلى توضيح.  تقدم الوثائق الرسمية مثالًا يتم فيه إضافة خدمة معينة إلى حاوية DI كمعلمة لمنشئ خدمة أخرى وبشكل منفصل بشكل مستقل.  وفي حالة إضافته بشكل منفصل باستخدام AddTransient ، فإنه ينشئ مثيله مرتين.  سأقدم مثالًا بسيطًا للغاية.  في الحياة الحقيقية ، لا ينصح للاستخدام ، لأنه  فئات للبساطة لا ترث واجهات.  دعنا نقول لدينا فئة بسيطة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; private set; } public Operation() { OperationId = Guid.NewGuid(); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  وهناك فئة ثانية تحتوي على الخدمة الأولى كخدمة تابعة وتتلقى هذه التبعية كمعلمة مُنشئ: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public class OperationService { public Operation Operation { get; } public OperationService (Operation operation) { Operation = operation; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن نحقن خدمتين: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;(); services.AddScoped&lt;OperationService&gt;();</code> </pre> <br><p style=";text-align:right;direction:rtl">  وفي بعض وحدات التحكم في العمل ، أضف إيصال تبعياتنا واعرض القيم في نافذة التصحيح. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public IActionResult Index([FromServices] Operation operation, [FromServices] OperationService operationService) { Debug.WriteLine(operation.OperationId); Debug.WriteLine(operationService.Operation.OperationId); return View(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  لذلك ، نتيجة لذلك ، نحصل على قيمتين مختلفتين لـ Guid.  ولكن إذا استبدلنا AddTransient بـ AddScoped ، فنتيجة لذلك نحصل على قيمتين متطابقتين. </p><br><p style=";text-align:right;direction:rtl">  تحتوي حاوية IoC للتطبيق ASP.NET Core على بعض الخدمات بشكل افتراضي.  على سبيل المثال ، IConfiguration هي خدمة يمكنك من خلالها الحصول على إعدادات التطبيق من ملفات appsettings.json و appsettings.Development.json.  IHostingEnvironment و ILoggerFactory التي يمكنك من خلالها الحصول على التكوين الحالي وفئة المساعد التي تتيح التسجيل. </p><br><p style=";text-align:right;direction:rtl">  يتم استرداد الفئات من الحاوية باستخدام البناء النموذجي التالي (المثال الأكثر شيوعًا): </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> private readonly IConfiguration _configuration; public SomePageController(IConfiguration configuration) { _configuration = configuration; } public async Task&lt;IActionResult&gt; Index() { string connectionString = _configuration["connectionString"]; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يتم إنشاء متغير بمعدلات وصول خاصة للقراءة فقط في نطاق وحدة التحكم.  يتم الحصول على التبعية من الحاوية في مُنشئ الفئة وتعيين متغير خاص.  علاوة على ذلك يمكن استخدام هذا المتغير في أي أساليب أو تحكم العمل. <br>  في بعض الأحيان لا ترغب في إنشاء متغير من أجل استخدامه في إجراء واحد فقط.  ثم يمكنك استخدام السمة [FromServices].  مثال: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public IActionResult About([FromServices] IDateTime dateTime) { ViewData["Message"] = «  " + dateTime.Now; return View(); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  يبدو غريباً ، ولكن حتى لا يتم استدعاء طريقة الفئة الثابتة DateTime.Now () في الكود ، يتم ذلك أحيانًا حتى يتم الحصول على قيمة الوقت من الخدمة كمعلمة.  وبالتالي ، يصبح من الممكن تمرير أي وقت كمعلمة ، مما يعني أنه من الأسهل لكتابة الاختبارات ، وكقاعدة عامة ، يصبح من السهل إجراء تغييرات على التطبيق. <br>  هذا لا يعني أن ساكنة هو الشر.  طرق ثابتة هي أسرع.  وعلى الأرجح يمكن استخدام ساكنة في مكان ما في حاوية IoC نفسها.  ولكن إذا حفظنا طلبنا من كل شيء ثابت وجديد ، فسنحصل على المزيد من المرونة. </p><br><h2 id="storonnie-di-konteynery" style=";text-align:right;direction:rtl">  حاويات DI الطرف الثالث </h2><br><p style=";text-align:right;direction:rtl">  ما نظرنا إليه وما تقوم به حاوية ASP.NET Core DI بشكل افتراضي هو حقن المنشئ.  لا تزال هناك فرصة لحقن التبعية في الخاصية باستخدام حقن الخاصية ما يسمى ، ولكن هذه الميزة غير متوفرة في الحاوية المضمنة في ASP.NET Core.  على سبيل المثال ، قد يكون لدينا فئة تقوم بتطبيقها كتبعية ، وهذه الفئة لها نوع من الملكية العامة.  الآن تخيل أننا أثناء أو بعد حقن التبعية ، نحتاج إلى تعيين قيمة الخاصية.  دعنا نعود إلى مثال مشابه للمثال الذي درسناه مؤخرًا. <br>  إذا كان لدينا مثل هذه الفئة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public class Operation { public Guid OperationId { get; set; } public Operation() {} }</code> </pre> <br><p style=";text-align:right;direction:rtl">  والتي يمكننا أن نقدم إدمان ، </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddTransient&lt;Operation&gt;();</code> </pre> <br><p style=";text-align:right;direction:rtl">  ثم باستخدام الحاوية القياسية ، لا يمكننا ضبط قيمة العقار. <br>  إذا كنت تريد استخدام هذه الفرصة لتعيين قيمة لخاصية OperationId ، فيمكنك استخدام نوع من حاوية DI لجهة خارجية تدعم خاصية الحقن.  بالمناسبة ، لا ينصح حقن الممتلكات بشكل خاص.  ومع ذلك ، لا يزال هناك أسلوب حقن وحقن طريقة Setter ، والتي قد تكون في متناول يديك والتي لا تدعمها الحاوية القياسية أيضًا. </p><br><p style=";text-align:right;direction:rtl">  قد تحتوي حاويات الجهات الخارجية على ميزات أخرى مفيدة للغاية.  على سبيل المثال ، باستخدام حاوية تابعة لجهة خارجية ، يمكنك فقط إضافة التبعية إلى وحدات التحكم التي تحتوي على كلمة معينة في الاسم.  وغالبا ما تستخدم حالة - حاويات DI ، الأمثل للأداء. <br>  فيما يلي قائمة ببعض حاويات DI التابعة لجهة خارجية والتي يدعمها ASP.NET Core: Autofac ، Castle Windsor ، LightInject ، DryIoC ، StructureMap ، Unity </p><br><p style=";text-align:right;direction:rtl">  على الرغم من استخدام حاوية DI قياسية ، لا يمكنك استخدام حقن الخاصية / الطريقة ، ولكن يمكنك تنفيذ خدمة تابعة كمعلمة مُنشئ عن طريق تطبيق نمط المصنع على النحو التالي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddTransient&lt;IDataService, DataService&gt;((dsvc) =&gt; { IOtherService svc = dsvc.GetService&lt;IOtherService&gt;(); return new DataService(svc); });</code> </pre> <br><p style=";text-align:right;direction:rtl">  في هذه الحالة ، سيعود GetService فارغًا إذا لم يتم العثور على الخدمة التابعة.  يوجد تباين في GetRequiredService يؤدي إلى استثناء إذا لم يتم العثور على الخدمة التابعة. <br>  تطبق عملية الحصول على خدمة تابعة باستخدام GetService بالفعل نمط محدد موقع الخدمة. </p><br><h2 id="autofac" style=";text-align:right;direction:rtl">  Autofac </h2><br><p style=";text-align:right;direction:rtl">  دعونا نلقي نظرة على Autofac مع مثال عملي.  بسهولة ، يمكن تسجيل الخدمات الواردة من الحاوية واستلامها ، سواء بالطريقة الافتراضية أو باستخدام Autofac. </p><br><p style=";text-align:right;direction:rtl">  تثبيت حزمة NuGet Autofac.Extensions.DependencyInjection. <br>  تغيير القيمة التي تم إرجاعها بواسطة الأسلوب ConfigureServices من باطلة إلى IServiceProvider.  وإضافة الممتلكات </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public IContainer ApplicationContainer { get; private set; }</code> </pre> <br><p style=";text-align:right;direction:rtl">  بعد ذلك ، سيكون من الممكن إضافة رمز مثل التالي إلى نهاية طريقة ConfigureServices لفئة بدء التشغيل (هذا مجرد خيار من خيارات تسجيل الخدمات): </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddTransient&lt;ISomeRepository, SomeRepository&gt;(); var builder = new ContainerBuilder(); builder.Populate(services); builder.RegisterType&lt;AnotherRepository&gt;().As&lt;IAnotherRepository&gt;(); this.ApplicationContainer = builder.Build(); return new AutofacServiceProvider(this.ApplicationContainer);</code> </pre> <br><p style=";text-align:right;direction:rtl">  هنا builder.Populate (الخدمات) ؛  يضيف خدمات من IServiceCollection إلى الحاوية.  إضافة إلى أنه من الممكن بالفعل تسجيل الخدمات مع builder.RegisterType.  اوه نعم  لقد نسيت تقريبا.  يجب عليك تغيير قيمة الإرجاع للأسلوب ConfigureServices من الفراغ إلى IServiceProvider. </p><br><h2 id="aop-s-pomoschyu-aspnet-core---autofac-interseptors" style=";text-align:right;direction:rtl">  AOP مع ASP.NET Core - Autofac Interseptors </h2><br><p style=";text-align:right;direction:rtl">  يتحدثون عن البرمجة الموجهة نحو الجوانب ، ويذكرون مصطلحًا آخر - المخاوف الشاملة.  القلق هو بعض المعلومات التي تؤثر على الكود.  في النسخة الروسية يستخدمون كلمة المسؤولية.  حسنًا ، المخاوف الشاملة هي مسؤوليات تؤثر على المسؤوليات الأخرى.  لكن من الناحية المثالية ، ينبغي ألا تؤثر على بعضها البعض ، أليس كذلك؟  عندما تؤثر على بعضها البعض ، يصبح من الصعب تغيير البرنامج.  سيكون أكثر ملاءمة عندما يكون لدينا جميع العمليات بشكل منفصل.  يمكن إجراء التسجيل والمعاملات والتخزين المؤقت وغير ذلك الكثير باستخدام AOP دون تغيير رمز الفئات والأساليب نفسها. </p><br><p style=";text-align:right;direction:rtl">  في عالم .NET ، يتم استخدام طريقة غالبًا عندما يتم تضمين كود AOP باستخدام معالج النشر في رمز تطبيق <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">مترجم</a> بالفعل ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">PostSharp</a> ) ، أو بدلاً من ذلك ، يمكنك استخدام interceptors - فهذه هي <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ar&amp;u=">روابط</a> الأحداث التي يمكن إضافتها إلى رمز التطبيق.  يستخدم هؤلاء المعترضون ، كقاعدة عامة ، الديكور الذي درسناه بالفعل لعملهم. </p><br><p style=";text-align:right;direction:rtl">  دعونا إنشاء اعتراضية الخاصة بك.  المثال الأبسط والأكثر نموذجية والذي يسهل إعادة إنتاجه هو التسجيل. <br>  بالإضافة إلى حزمة Autofac.Extensions.DependencyInjection ، سنقوم أيضًا بتثبيت حزمة Autofac.Extras.DynamicProxy <br>  مثبتة؟  أضف فئة سجل بسيطة سيتم استدعاؤها عند الوصول إلى خدمات معينة. </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public class Logger : IInterceptor { public void Intercept(IInvocation invocation) { Debug.WriteLine($"Calling {invocation.Method.Name} from Proxy"); invocation.Proceed(); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">  أضف إلى تسجيلنا Autofac تسجيل المعترض: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> builder.Register(i =&gt; new Logger()); builder.RegisterType&lt;SomeRepository &gt;() .As&lt;ISomeRepository &gt;() .EnableInterfaceInterceptors() .InterceptedBy(typeof(Logger));</code> </pre> <br><p style=";text-align:right;direction:rtl">  والآن ، مع كل مكالمة إلى الفصل ، سيتم استدعاء طريقة اعتراض فئة المسجل. <br>  وبالتالي ، يمكننا تبسيط حياتنا وعدم كتابة إدخال سجل في بداية كل طريقة.  سيكون لدينا تلقائيا.  وإذا رغبت في ذلك ، سيكون من السهل علينا تغييره أو تعطيله للتطبيق بأكمله. </p><br><p style=";text-align:right;direction:rtl">  يمكننا أيضًا إزالة .InterceptedBy (typeof (Logger)) ؛  وقم بإضافة اعتراض الاتصال فقط لخدمات تطبيقات محددة باستخدام السمة [Intercept (typeof (Logger))] - يجب عليك تحديد ذلك قبل رأس الفصل. </p><br><h2 id="middleware" style=";text-align:right;direction:rtl">  الوسيطة </h2><br><p style=";text-align:right;direction:rtl">  يحتوي ASP.NET على سلسلة معينة من مكالمات التعليمات البرمجية التي تحدث عند كل طلب.  حتى قبل تحميل UI / MVC ، يتم تنفيذ بعض الإجراءات. </p><br><p style=";text-align:right;direction:rtl">  هذا ، على سبيل المثال ، إذا أضفنا في بداية طريقة تكوين فئة Startup.cs الكود </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { Debug.WriteLine(context.Request.Path); await next.Invoke(); });</code> </pre> <br><p style=";text-align:right;direction:rtl">  ثم يمكننا أن نرى في وحدة التحكم تصحيح الملفات ما طلبات طلباتنا.  في الواقع ، نحصل على قدرات AOP "خارج الصندوق" <br>  مثال عديم الفائدة ، ولكنه واضح وغني بالمعلومات حول استخدام البرامج الوسيطة ، سأريك الآن: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public void Configure(IApplicationBuilder app) { app.Use(async (context, next) =&gt; { await context.Response.WriteAsync("Hello!" + Environment.NewLine); await next.Invoke(); }); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello again."); }); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  مع كل طلب ، تبدأ سلسلة من المكالمات.  من كل app.Use ، بعد الاتصال next.invoke () ، يتم الانتقال إلى المكالمة التالية.  وكل شيء ينتهي بعد أعمال التطبيق. <br>  يمكنك تنفيذ بعض التعليمات البرمجية فقط عند الوصول إلى مسار معين. <br>  يمكنك القيام بذلك باستخدام app.Map: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> private static void Goodbye(IApplicationBuilder app) { app.Run(async context =&gt; { await context.Response.WriteAsync("Goodbye!"); }); } public void Configure(IApplicationBuilder app) { app.Map("/goodbye", Goodbye); app.Run(async context =&gt; { await context.Response.WriteAsync("Hello!"); }); }</code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن ، إذا انتقلت إلى صفحة الموقع ، يمكنك رؤية النص "Hello!" ، وإذا أضفت / وداعًا إلى شريط العناوين ، فسترى وداعًا. </p><br><p style=";text-align:right;direction:rtl">  بالإضافة إلى "الاستخدام" و "الخريطة" ، يمكنك استخدام "UseWhen" أو "MapWhen" لإضافة رمز إلى سلسلة البرامج الوسيطة فقط في ظل ظروف معينة محددة. </p><br><p style=";text-align:right;direction:rtl">  حتى الآن لا تزال هناك أمثلة عديمة الفائدة ، أليس كذلك؟  هنا مثال طبيعي: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> app.Use(async (context, next) =&gt; { context.Response.Headers.Add("X-Frame-Options", "DENY"); context.Response.Headers.Add("X-Content-Type-Options", "nosniff"); context.Response.Headers.Add("X-Xss-Protection", "1"); await next(); });</code> </pre> <br><p style=";text-align:right;direction:rtl">  نضيف هنا رؤوس لكل طلب للمساعدة في حماية الصفحة من هجمات القراصنة. </p><br><p style=";text-align:right;direction:rtl">  أو هنا مثال على الترجمة: </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> var supportedCultures = new[] { new CultureInfo("ru"), new CultureInfo("fr") }; app.UseRequestLocalization(new RequestLocalizationOptions { DefaultRequestCulture = new RequestCulture("ru"), SupportedCultures = supportedCultures, SupportedUICultures = supportedCultures });</code> </pre> <br><p style=";text-align:right;direction:rtl">  الآن إذا أضفت المعلمة؟ Culture = fr إلى عنوان الصفحة ، فيمكنك تبديل لغة التطبيق إلى الفرنسية (إذا تمت إضافة الترجمة إلى التطبيق الخاص بك ، فسيعمل كل شيء) </p><br><h2 id="filters" style=";text-align:right;direction:rtl">  مرشحات </h2><br><p style=";text-align:right;direction:rtl">  إذا كانت سلسلة البرامج الوسيطة تشير إلى العمليات قبل MVC ، فستعمل المرشحات مع MVC. <br>  يوضح المخطط التخطيطي التالي كيفية عمل المرشحات. </p><br><p style=";text-align:right;direction:rtl"><img src="https://habrastorage.org/webt/jz/n1/hv/jzn1hvufowfcck24q1-nnl-xbx8.png" alt="مرشحات"></p><br><p style=";text-align:right;direction:rtl">  أولاً ، تعمل عوامل تصفية التراخيص.  أي  يمكنك إنشاء نوع من الفلاتر أو عدة فلاتر وإدخال فيها نوعًا من كود التفويض الذي سينجح بناءً على الطلبات. </p><br><p style=";text-align:right;direction:rtl">  ثم تفي مرشحات الموارد.  باستخدام عوامل التصفية هذه ، يمكنك ، على سبيل المثال ، إرجاع بعض المعلومات من ذاكرة التخزين المؤقت. </p><br><p style=";text-align:right;direction:rtl">  ثم يحدث ربط البيانات ويتم تنفيذ عوامل تصفية الإجراء.  من خلال مساعدتهم ، يمكنك معالجة المعاملات التي تم تمريرها إلى Action والنتيجة التي تم إرجاعها. </p><br><p style=";text-align:right;direction:rtl">  مرشحات الاستثناء لأن تلميحات الاسم تتيح لك إضافة نوع من معالجة الأخطاء العامة للتطبيق.  يجب أن تكون مريحة جدًا للتعامل مع الأخطاء في كل مكان.  وهناك نوع من AOP-shny زائد. </p><br><p style=";text-align:right;direction:rtl">  تتيح لك عوامل تصفية النتيجة تنفيذ بعض الإجراءات قبل تنفيذ وحدة التحكم في الإجراء أو بعده.  تشبه عوامل تصفية الإجراء تمامًا ، لكن يتم تنفيذها فقط في حالة عدم وجود أخطاء.  مناسبة للمنطق مرتبطة عرض. </p><br><p style=";text-align:right;direction:rtl">       .            : </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public class YourCustomFilter : Attribute, IAuthorizationFilter { public async void OnAuthorization(AuthorizationFilterContext context) { // -    ,     ,    context.Result = new ContentResult() { Content = "        " }; } }</code> </pre> <br><p style=";text-align:right;direction:rtl">     DI  (   Startup.cs) </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> services.AddScoped&lt;YourCustomFilter&gt;();</code> </pre> <br><p style=";text-align:right;direction:rtl">      -    Action    </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> [ServiceFilter(typeof(YourCustomFilter))]</code> </pre> <br><p style=";text-align:right;direction:rtl">   –    middleware    - action   .              Configure </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> public class MyMiddlewareFilter { public void Configure(IApplicationBuilder applicationBuilder) { applicationBuilder.Use(async (context, next) =&gt; { Debug.WriteLine("  middleware!"); await next.Invoke(); }); } }</code> </pre> <br><p style=";text-align:right;direction:rtl">      Action-     </p><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> [MiddlewareFilter(typeof(MyMiddlewareFilter))]</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/BRKPP1NYCu4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar437002/">https://habr.com/ru/post/ar437002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar436992/index.html">التجربة والخطأ أثناء اختيار وكيل HTTP العكسي</a></li>
<li><a href="../ar436994/index.html">Liquibase و Maven</a></li>
<li><a href="../ar436996/index.html">دورة بيثون التخصص النهائي من مجموعة Mail.ru</a></li>
<li><a href="../ar436998/index.html">حماية الرقائق من الهندسة العكسية والدخول غير المصرح به</a></li>
<li><a href="../ar437000/index.html">كيفية تعليم الناس على استخدام بوابة</a></li>
<li><a href="../ar437004/index.html">هل يحلم مبرمجو YML باختبار ansible؟</a></li>
<li><a href="../ar437006/index.html">Wanhao الناسخ 10 3D استعراض الطابعة</a></li>
<li><a href="../ar437008/index.html">البرمجة اللغوية العصبية. الأساسيات. التقنيات. تطوير الذات. الجزء 1</a></li>
<li><a href="../ar437010/index.html">أصداء الماضي: تجربة يونغ في أساس طريقة التحليل الطيفي للأشعة السينية الجديدة</a></li>
<li><a href="../ar437014/index.html">مهمة N الهيئات أو كيفية تفجير مجرة ​​دون مغادرة المطبخ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>