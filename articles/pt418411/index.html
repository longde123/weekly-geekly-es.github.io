<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗 🐪 👨🏾‍🎤 Atirador de rede do navegador no Node.js 🎳 👩‍🎨 💕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O desenvolvimento de jogos multiplayer é complicado por vários motivos: a hospedagem pode ser cara, a estrutura não é óbvia e a implementação é difíci...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Atirador de rede do navegador no Node.js</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418411/"> O desenvolvimento de jogos multiplayer é complicado por vários motivos: a hospedagem pode ser cara, a estrutura não é óbvia e a implementação é difícil.  Neste tutorial, tentarei ajudá-lo a superar a última barreira. <br><br>  Este artigo é destinado a desenvolvedores que podem criar jogos e conhecem o JavaScript, mas nunca criaram jogos on-line para vários jogadores.  Depois de concluir este tutorial, você dominará a implementação dos componentes básicos de rede no seu jogo e poderá desenvolvê-lo em algo mais!  Aqui está o que vamos criar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e9a/220/340/e9a22034098ab10a84721a48615a1476.png"></div><br>  Você pode jogar o jogo terminado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> !  Quando você pressiona as teclas W ou "para cima", a nave se aproxima do cursor; quando você clica no mouse, ele dispara.  <em>(Se ninguém estiver online, verifique o funcionamento do multiplayer, abra duas janelas do navegador em um computador ou uma delas no telefone).</em>  Se você deseja executar o jogo localmente, o código fonte completo está disponível no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">GitHub</a> . <br><a name="habracut"></a><br>  Ao criar o jogo, usei os recursos gráficos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">do Pirate Pack</a> da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">Kenney</a> e da estrutura do jogo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">Phaser</a> .  Neste tutorial, você recebe a função de programador de rede.  O ponto de partida será uma versão totalmente funcional do jogo para usuário único, e nossa tarefa será escrever um servidor no Node.js usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Socket.io</a> para a parte da rede.  Para não sobrecarregar o tutorial, vou me concentrar nas partes relacionadas ao multiplayer e pular conceitos relacionados ao Phaser e Node.js. <br><br>  Você não precisa configurar nada localmente, porque criaremos este jogo completamente no navegador no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Glitch.com</a> !  O Glitch é uma ferramenta incrível para criar aplicativos da Web, incluindo back-ends, bancos de dados e muito mais.  É ótimo para criação de protótipos, treinamento e colaboração, e ficarei muito feliz em apresentar seus recursos neste tutorial. <br><br>  Vamos começar. <br><br><h2>  1. Preparação </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">Publiquei</a> o rascunho do projeto no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">Glitch.com</a> . <br><br>  Dicas de interface: Você pode iniciar a visualização do aplicativo clicando no botão <strong>Mostrar</strong> (canto superior esquerdo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac2/8b6/4dd/ac28b64dd9c37370872ad6a913b10078.png"></div><br>  A barra lateral vertical à esquerda contém todos os arquivos do aplicativo.  Para editar este aplicativo, você deve criar seu "remix".  Portanto, criaremos uma cópia dele em nossa conta (ou "fork" no jargão git).  Clique no botão <strong>Remixar este</strong> botão. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f71/88f/6e4/f7188f6e4b66e9b9801d04c7891d42dd.png"></div><br>  Neste ponto, você está editando o aplicativo em uma conta anônima.  Para salvar seu trabalho, você pode fazer login (canto superior direito). <br><br>  Agora, antes de prosseguir, é importante que você se familiarize com o jogo no qual adicionaremos o modo multiplayer.  Dê uma olhada no <strong>index.html</strong> .  Ele tem três funções importantes que você precisa conhecer: <code>preload</code> (linha 99), <code>create</code> (linha 115) e <code>GameLoop</code> (linha 142), bem como o objeto do jogador (linha 35). <br><br>  Se você prefere aprender praticando, entenda o trabalho do jogo concluindo as seguintes tarefas: <br><br><ul><li>  Aumente o tamanho do mundo <em>(linha 29)</em> - <em>observe que existe um tamanho de mundo separado para o mundo do jogo e um tamanho de janela para a própria tela da página</em> . </li><li>  Torne possível avançar com a ajuda do “espaço” <em>(linha 53).</em> </li><li>  Mude o tipo de navio do jogador <em>(linha 129).</em> </li><li>  Diminua o movimento das conchas <em>(linha 155).</em> </li></ul><br><h3>  Instale o Socket.io </h3><br>  O Socket.io é uma biblioteca para gerenciar comunicações em tempo real dentro de um navegador usando o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">WebSockets</a> (em vez de usar protocolos como o UDP, que são usados ​​para criar jogos multiplayer clássicos).  Além disso, a biblioteca possui maneiras redundantes de garantir a operação, mesmo quando o WebSockets não é suportado.  Ou seja, ela lida com protocolos de mensagens e permite o uso de um sistema conveniente de mensagens com base em eventos. <br><br>  A primeira coisa que precisamos fazer é instalar o módulo Socket.io.  No Glitch, isso pode ser feito acessando o arquivo <strong>package.json</strong> e, em seguida, inserindo o módulo necessário nas dependências ou clicando em <strong>Adicionar pacote</strong> e inserindo “socket.io”. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/41f/005/d9441f0059e23044aa69f6f8750c81bb.png"></div><br>  Agora é a hora certa para lidar com os logs do servidor.  Clique no botão <strong>Logs</strong> à esquerda para abrir o log do servidor.  Você deve ver que ele instala o Socket.io com todas as suas dependências.  É aqui que você precisa procurar todos os erros e a saída do código do servidor. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7db/6e1/58c/7db6e158c6e48d0d91f70344eaf51af7.png"></div><br>  Agora vamos para o <strong>server.js</strong> .  É aqui que nosso código do servidor está localizado.  Até o momento, há apenas algum código básico para servir nosso HTML.  Adicione uma linha na parte superior do arquivo para habilitar o Socket.io: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> io = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'socket.io'</span></span>)(http); <span class="hljs-comment"><span class="hljs-comment">//     http</span></span></code> </pre> <br>  Agora também precisamos habilitar o Socket.io no cliente, então vamos voltar ao <strong>index.html</strong> e adicionar as seguintes linhas dentro da tag <code>&lt;head&gt;</code> : <br><br><pre> <code class="javascript hljs">&lt;!--    Socket.io --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"/socket.io/socket.io.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  <em>Nota: O Socket.io processa automaticamente o carregamento da biblioteca do cliente nesse caminho, portanto, esta linha funciona mesmo se não houver diretório /socket.io/ em suas pastas.</em> <br><br>  Agora o Socket.io está incluído no projeto e está pronto para começar! <br><br><h2>  2. Reconhecimento e desova de jogadores </h2><br>  Nosso primeiro passo real será aceitar conexões no servidor e criar novos players no cliente. <br><br><h3>  Aceitando conexões do servidor </h3><br>  Adicione este código à parte inferior do <strong>server.js</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); })</span></span></code> </pre> <br>  Por isso, pedimos ao Socket.io para ouvir todos os eventos de <code>connection</code> que ocorrem automaticamente quando um cliente se conecta.  A biblioteca cria um novo objeto de <code>socket</code> para cada cliente, em que <code>socket.id</code> é o identificador exclusivo desse cliente. <br><br>  Para verificar se isso funciona, retorne ao cliente ( <strong>index.html</strong> ) e adicione esta linha em algum lugar da função de <strong>criação</strong> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = io(); <span class="hljs-comment"><span class="hljs-comment">//    'connection'  </span></span></code> </pre> <br>  Se você iniciar o jogo e observar o log do servidor (clique no botão <strong>Logs</strong> ), verá que o servidor registrou esse evento de conexão! <br><br>  Agora, ao conectar um novo jogador, esperamos que ele nos forneça informações sobre seu estado.  No nosso caso, precisamos saber pelo menos <strong>x</strong> , <strong>y</strong> e <strong>ângulo</strong> para criá-lo corretamente no ponto certo. <br><br>  O evento de <code>connection</code> foi um evento embutido acionado pelo Socket.io.  Podemos ouvir qualquer evento definido independentemente.  Vou nomear meu evento como <code>new-player</code> e espero que o cliente o envie assim que ele se conectar com informações sobre sua posição.  Ficará assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); }) })</span></span></code> </pre> <br>  Se você executar esse código, até ver qualquer coisa no log do servidor, porque ainda não dissemos ao cliente para gerar esse evento para <code>new-player</code> .  Mas vamos fingir por um momento que já fizemos isso e continuar trabalhando no servidor.  O que deve acontecer depois de obter a localização de um novo jogador que entra? <br><br>  Podemos enviar uma mensagem a todos os <em>outros</em> jogadores conectados, para que eles saibam que um novo jogador apareceu.  O Socket.io possui uma função conveniente para isso: <br><br><pre> <code class="javascript hljs">socket.broadcast.emit(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,state_data);</code> </pre> <br>  Quando <code>socket.emit</code> chamado <code>socket.emit</code> mensagem é simplesmente passada para esse único cliente.  Quando <code>socket.broadcast.emit</code> é chamado <code>socket.broadcast.emit</code> ele é enviado a todos os clientes conectados ao servidor, exceto em cujo soquete essa função foi chamada. <br><br>  A função <code>io.emit</code> envia uma mensagem para cada cliente conectado ao servidor sem exceções.  Em nosso esquema, não precisamos disso, porque se recebermos uma mensagem do servidor nos pedindo para criar nossa própria nave, receberemos uma duplicata do sprite, porque já criamos nossa própria nave quando o jogo começou.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aqui está uma dica útil</a> sobre os vários tipos de recursos de mensagens que usaremos neste tutorial. <br><br>  O código do servidor agora deve ficar assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); socket.broadcast.emit('create-player',state_data); }) })</span></span></code> </pre> <br>  Ou seja, toda vez que um jogador se conectar, esperamos que ele nos envie uma mensagem com informações sobre sua localização, e enviamos esses dados a todos os outros jogadores para que eles possam criar seu sprite. <br><br><h3>  Criação de cliente </h3><br>  Agora, para concluir esse ciclo, precisamos executar duas ações no cliente: <br><br><ol><li>  Gere uma mensagem com os dados da nossa localização após a conexão. </li><li>  Ouça os eventos <code>create-player</code> e crie um player neste momento. </li></ol><br>  Para executar a primeira ação após a criação de um player na função de <strong>criação</strong> (aproximadamente na linha 135), podemos gerar uma mensagem contendo os dados de localização que precisamos enviar: <br><br><pre> <code class="javascript hljs">socket.emit(<span class="hljs-string"><span class="hljs-string">'new-player'</span></span>,{<span class="hljs-attr"><span class="hljs-attr">x</span></span>:player.sprite.x,<span class="hljs-attr"><span class="hljs-attr">y</span></span>:player.sprite.y,<span class="hljs-attr"><span class="hljs-attr">angle</span></span>:player.sprite.rotation})</code> </pre> <br>  Não precisamos nos preocupar em serializar os dados que estão sendo enviados.  Você pode transferi-los para qualquer tipo de objeto, e o Socket.io o processará para nós. <br><br>  Antes de prosseguir, <em>teste o código</em> .  Deveríamos ver uma mensagem semelhante nos logs do servidor: <br><br><pre> <code class="javascript hljs">New player has state: { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">728.8180247836519</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">261.9979387913289</span></span>, <span class="hljs-attr"><span class="hljs-attr">angle</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre> <br>  Agora sabemos que nosso servidor recebe uma notificação sobre a conexão de um novo player e lê corretamente os dados sobre sua localização! <br><br>  Em seguida, queremos ouvir as solicitações para criar um novo player.  Podemos colocar esse código imediatamente após a geração da mensagem, deve ficar assim: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'create-player'</span></span>,<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// CreateShip -      ,     CreateShip(1,state.x,state.y,state.angle) })</span></span></code> </pre> <br>  Agora <em>teste o código</em> .  Abra duas janelas com o jogo e verifique se ele funciona. <br><br>  Você deve ver que, após a abertura de dois clientes, o primeiro cliente possui duas naves criadas e o segundo possui apenas uma. <br><br><blockquote>  Tarefa: você pode descobrir por que isso aconteceu?  Ou como você pode consertar isso?  Passo a passo, siga a lógica do cliente / servidor que escrevemos e tente depurá-la. </blockquote><br>  Espero que você tenha tentado descobrir por conta própria!  O seguinte acontece: quando o primeiro jogador se conecta, o servidor envia um evento de <code>create-player</code> para todos os outros jogadores, mas ainda não há jogadores que possam recebê-lo.  Depois de conectar o segundo jogador, o servidor envia suas mensagens novamente e o primeiro jogador o recebe e cria o sprite corretamente, enquanto o segundo jogador perdeu a mensagem do primeiro jogador. <br><br>  Ou seja, o problema é que o segundo jogador se conecta ao jogo mais tarde e ele precisa saber o estado do jogo.  Devemos informar a todos os novos jogadores que já existem (assim como outros eventos que ocorreram no mundo) para que eles possam se orientar.  Antes de resolvermos esse problema, tenho um breve aviso. <br><br><h3>  Aviso de Sincronização de Status do Jogo </h3><br>  Existem duas abordagens para implementar a sincronização de todos os players.  O primeiro é enviar uma quantidade mínima de informações sobre as alterações que ocorreram na rede.  Ou seja, toda vez que um novo jogador estiver conectado, enviaremos a todos os outros jogadores apenas informações sobre esse novo jogador (e enviaremos uma lista de todos os outros jogadores do mundo para esse novo jogador) e, após desconectar, informaremos todos os jogadores que esse jogador em particular foi desconectado. <br><br>  A segunda abordagem é transmitir todo o estado do jogo.  Nesse caso, sempre que você se conecta ou desconecta, enviamos a todos uma lista completa de todos os jogadores. <br><br>  A primeira abordagem é melhor, pois minimiza a quantidade de informações transmitidas pela rede, mas pode ser muito difícil de implementar e tem a probabilidade de os jogadores ficarem fora de sincronia.  O segundo garante que os jogadores estejam sempre sincronizados, mas cada mensagem terá que enviar mais dados. <br><br>  No nosso caso, em vez de tentar enviar mensagens quando um jogador está conectado para criá-lo e quando desconectado para excluí-lo, bem como quando se move para atualizar sua posição, podemos combinar tudo isso em um evento de <code>update</code> comum.  Esse evento de atualização sempre envia as posições de cada jogador para todos os clientes.  É isso que o servidor deve fazer.  A tarefa do cliente é manter a conformidade do mundo com o estado recebido. <br><br>  Para implementar esse esquema, farei o seguinte: <br><br><ol><li>  Manterei um dicionário de jogadores, cuja chave será o ID deles e o valor serão os dados de sua localização. </li><li>  Adicione um player a este dicionário quando estiver conectado e envie um evento de atualização. </li><li>  Remova o player deste dicionário quando estiver desligado e envie um evento de atualização. </li></ol><br>  Você pode tentar implementar esse sistema você mesmo, porque essas etapas são bastante simples ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">minha dica de recurso</a> pode ser útil aqui).  Aqui está a aparência da implementação completa: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  Socket.io    // 1 -      / var players = {}; io.on('connection', function(socket){ console.log("New client has connected with id:",socket.id); socket.on('new-player',function(state_data){ //   new-player    console.log("New player has state:",state_data); // 2 -      players[socket.id] = state_data; //    io.emit('update-players',players); }) socket.on('disconnect',function(){ // 3-       delete players[socket.id]; //    }) })</span></span></code> </pre> <br>  O lado do cliente é um pouco mais complicado.  Por um lado, agora devemos nos preocupar apenas com o evento <code>update-players</code> , mas, por outro lado, devemos considerar criar novas naves se o servidor enviar mais naves do que sabemos, ou excluir se houver muitas delas. <br><br>  É assim que eu manejo esse evento no cliente: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     // : -         other_players = {} socket.on('update-players',function(players_data){ var players_found = {}; //        for(var id in players_data){ //      if(other_players[id] == undefined &amp;&amp; id != socket.id){ // ,      var data = players_data[id]; var p = CreateShip(1,data.x,data.y,data.angle); other_players[id] = p; console.log("Created new player at (" + data.x + ", " + data.y + ")"); } players_found[id] = true; //     if(id != socket.id){ other_players[id].x = players_data[id].x; //  ,    ,      other_players[id].y = players_data[id].y; other_players[id].rotation = players_data[id].angle; } } //       for(var id in other_players){ if(!players_found[id]){ other_players[id].destroy(); delete other_players[id]; } } })</span></span></code> </pre> <br>  No lado do cliente, eu armazeno os navios no dicionário <code>other_players</code> , que acabei de definir na parte superior do script (não é mostrado aqui).  Como o servidor envia dados do jogador para todos os jogadores, devo adicionar uma verificação para que o cliente não crie um sprite extra para si.  (Se você tiver problemas com a estruturação, aqui está o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external">código completo</a> que deve estar em index.html no momento). <br><br>  Agora <em>teste o código</em> .  Você deve poder criar vários clientes e ver o número correto de navios criados nas posições corretas! <br><br><h2>  3. Sincronização das posições dos navios </h2><br>  Aqui começa uma parte muito interessante.  Queremos sincronizar as posições dos navios em todos os clientes.  Isso revelará a simplicidade da estrutura que criamos no momento.  Já temos um evento de atualização que pode sincronizar os locais de todos os navios.  Basta que façamos o seguinte: <br><br><ol><li>  Forçar o cliente a gerar uma mensagem cada vez que ele se move para uma nova posição. </li><li>  Ensine o servidor a ouvir essa mensagem de movimentação e atualize o elemento de dados do player no dicionário do <code>players</code> . </li><li>  Gere um evento de atualização para todos os clientes. </li></ol><br>  E isso deve ser o suficiente!  Agora é sua vez de tentar implementar isso sozinho. <br><br>  Se você está completamente confuso e precisa de uma dica, observe o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">projeto finalizado</a> . <br><br><h3>  Nota sobre como minimizar os dados transmitidos pela rede </h3><br>  A maneira mais direta de implementá-lo é atualizar as posições de todos os jogadores cada vez que um evento de movimento é recebido de <em>qualquer</em> jogador.  É ótimo que os jogadores sempre obtenham as informações mais recentes imediatamente após elas aparecerem, mas o número de mensagens transmitidas pela rede pode aumentar facilmente para centenas por quadro.  Imagine que você tem 10 jogadores, cada um dos quais envia uma mensagem de movimento em cada quadro.  O servidor deve encaminhá-los de volta para todos os 10 jogadores.  Já são 100 mensagens por quadro! <br><br>  Seria melhor fazer isso: espere até o servidor receber todas as mensagens de todos os jogadores e envie a todos os jogadores uma grande atualização contendo todas as informações.  Assim, reduziremos o número de mensagens transmitidas para o número de usuários presentes no jogo (em vez do quadrado desse número).  O problema aqui é que todos os usuários terão o mesmo atraso do player com a conexão mais lenta. <br><br>  Outra solução é enviar as atualizações do servidor a uma frequência constante, independentemente do número de mensagens recebidas do player.  Um padrão comum é atualizar o servidor aproximadamente 30 vezes por segundo. <br><br>  No entanto, ao escolher a estrutura do seu servidor, você deve avaliar o número de mensagens transmitidas em cada quadro nos estágios iniciais do desenvolvimento do jogo. <br><br><h2>  4. Sincronização de shell </h2><br>  Estamos quase terminando!  A última parte séria é a sincronização em uma rede de conchas.  Podemos implementá-lo da mesma maneira que os players sincronizados: <br><br><ul><li>  Cada cliente envia as posições de todas as suas conchas em cada quadro. </li><li>  O servidor os redireciona para cada jogador. </li></ul><br>  Mas há um problema. <br><br><h3>  Proteção contra trapaça </h3><br>  Se você redirecionar tudo o que o cliente transmite como as verdadeiras posições dos projéteis, o jogador pode trapacear facilmente, modificando seu cliente e transmitindo dados falsos para você, por exemplo, projéteis se teletransportando para as posições dos navios.  Você pode verificar isso facilmente fazendo o download da página da web, alterando o código para JavaScript e abrindo-o novamente.  E isso é um problema não apenas para jogos de navegador.  No caso geral, nunca podemos confiar nos dados provenientes do usuário. <br><br>  Para lidar parcialmente com esse problema, tentaremos usar outro esquema: <br><br><ul><li>  O cliente gera uma mensagem sobre o shell de tiro com sua posição e direção. </li><li>  O servidor simula o movimento das conchas. </li><li>  O servidor atualiza os dados de cada cliente, passando a posição de todos os shells. </li><li>  Os clientes processam conchas nas posições recebidas do servidor. </li></ul><br>  Assim, o cliente é responsável pela posição do projétil, mas não por sua velocidade e nem por seu movimento adicional.  O cliente pode alterar a posição dos shells por si mesmo, mas isso não altera o que os outros clientes veem. <br><br>  Para implementar esse esquema, adicionaremos a geração de mensagens quando acionadas.  Não vou mais criar o próprio sprite, porque sua existência e localização serão inteiramente determinadas pelo servidor.  Agora, nosso novo tiro de projétil em <strong>index.html</strong> ficará assim: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   if(game.input.activePointer.leftButton.isDown &amp;&amp; !this.shot){ var speed_x = Math.cos(this.sprite.rotation + Math.PI/2) * 20; var speed_y = Math.sin(this.sprite.rotation + Math.PI/2) * 20; /*    ,       ,       var bullet = {}; bullet.speed_x = speed_x; bullet.speed_y = speed_y; bullet.sprite = game.add.sprite(this.sprite.x + bullet.speed_x,this.sprite.y + bullet.speed_y,'bullet'); bullet_array.push(bullet); */ this.shot = true; //  ,     socket.emit('shoot-bullet',{x:this.sprite.x,y:this.sprite.y,angle:this.sprite.rotation,speed_x:speed_x,speed_y:speed_y}) }</span></span></code> </pre> <br>  Agora também podemos comentar todo o fragmento de código atualizando os shells no cliente: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*     ,         //   for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.sprite.x += bullet.speed_x; bullet.sprite.y += bullet.speed_y; //  ,       if(bullet.sprite.x &lt; -10 || bullet.sprite.x &gt; WORLD_SIZE.w || bullet.sprite.y &lt; -10 || bullet.sprite.y &gt; WORLD_SIZE.h){ bullet.sprite.destroy(); bullet_array.splice(i,1); i--; } } */</span></span></code> </pre> <br>  Finalmente, precisamos que o cliente escute as atualizações do shell.  Decidi implementar isso da mesma maneira que com os jogadores, ou seja, o servidor simplesmente envia uma matriz de todas as posições de shell em um evento chamado <code>bullets-update</code> , e o cliente cria ou destrói shells para manter a sincronização.  Aqui está o que parece: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     socket.on('bullets-update',function(server_bullet_array){ //     ,   for(var i=0;i&lt;server_bullet_array.length;i++){ if(bullet_array[i] == undefined){ bullet_array[i] = game.add.sprite(server_bullet_array[i].x,server_bullet_array[i].y,'bullet'); } else { //      ! bullet_array[i].x = server_bullet_array[i].x; bullet_array[i].y = server_bullet_array[i].y; } } //    ,   for(var i=server_bullet_array.length;i&lt;bullet_array.length;i++){ bullet_array[i].destroy(); bullet_array.splice(i,1); i--; } })</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E é tudo o que deve estar no cliente. </font><font style="vertical-align: inherit;">Suponho que você já saiba onde incorporar esses fragmentos de código e como agrupá-los, mas se tiver algum problema, poderá sempre olhar o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado final</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora no server.js, precisamos rastrear e simular shells. </font><font style="vertical-align: inherit;">Primeiro, criaremos uma matriz para rastrear conchas, semelhante a uma matriz para jogadores:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bullet_array = []; <span class="hljs-comment"><span class="hljs-comment">//        </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, ouvimos o evento de tiro com projétil: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   shoot-bullet        socket.on('shoot-bullet',function(data){ if(players[socket.id] == undefined) return; var new_bullet = data; data.owner_id = socket.id; //    id  bullet_array.push(new_bullet); });</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Agora simulamos cascas 60 vezes por segundo: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   60       function ServerGameLoop(){ for(var i=0;i&lt;bullet_array.length;i++){ var bullet = bullet_array[i]; bullet.x += bullet.speed_x; bullet.y += bullet.speed_y; // ,       if(bullet.x &lt; -10 || bullet.x &gt; 1000 || bullet.y &lt; -10 || bullet.y &gt; 1000){ bullet_array.splice(i,1); i--; } } } setInterval(ServerGameLoop, 16);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E o último passo é enviar o evento update em algum lugar dentro desta função (mas definitivamente fora do loop for): </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    ,    io.emit("bullets-update",bullet_array);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agora podemos finalmente testar o jogo! </font><font style="vertical-align: inherit;">Se tudo der certo, você deverá ver que os shells estão corretamente sincronizados em todos os clientes. </font><font style="vertical-align: inherit;">O fato de termos implementado isso no servidor nos forçou a trabalhar mais, mas nos deu muito mais controle. </font><font style="vertical-align: inherit;">Por exemplo, quando recebemos um evento de disparo de projétil, podemos verificar se a velocidade do projétil está dentro de um determinado intervalo e, se não for assim, saberemos que esse jogador está trapaceando.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Colisão com conchas </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esta é a última mecânica básica que implementamos. </font><font style="vertical-align: inherit;">Espero que você já esteja acostumado com o procedimento para planejar sua implementação, primeiro concluindo completamente a implementação do cliente e depois migrando para o servidor (ou vice-versa). </font><font style="vertical-align: inherit;">Esse método é muito menos suscetível a erros do que saltar quando implementado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A verificação de colisão é uma mecânica crucial do jogo, por isso queremos que ela seja protegida contra trapaças. </font><font style="vertical-align: inherit;">Nós o implementamos no servidor da mesma maneira que fizemos com os shells. </font><font style="vertical-align: inherit;">Precisamos do seguinte:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verifique se o projétil está perto o suficiente de qualquer jogador no servidor. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gere um evento para todos os clientes quando um projétil atingir um jogador. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ensine o cliente a ouvir o evento atingido e fazer o navio piscar quando atingido. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode tentar implementar esta parte você mesmo. </font><font style="vertical-align: inherit;">Para fazer o navio do jogador piscar ao ser atingido, basta definir seu canal alfa como 0:</font></font><br><br><pre> <code class="javascript hljs">player.sprite.alpha = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E ele retornará sem problemas à total opacidade (isso é feito na atualização do player). </font><font style="vertical-align: inherit;">Para outros jogadores, a ação será semelhante, mas você precisará retornar seu canal alfa para um na função de atualização com algo semelhante:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> other_players){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(other_players[id].alpha &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>){ other_players[id].alpha += (<span class="hljs-number"><span class="hljs-number">1</span></span> - other_players[id].alpha) * <span class="hljs-number"><span class="hljs-number">0.16</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { other_players[id].alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A única parte difícil pode ser verificar se o jogador não bate em suas próprias conchas (caso contrário, ele sofrerá dano toda vez que atirar). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observe que, nesse esquema, mesmo que o cliente tente trapacear e se recuse a aceitar a mensagem de acerto enviada a ele pelo servidor, isso mudará apenas o que vê em sua própria tela. </font><font style="vertical-align: inherit;">Todos os outros jogadores ainda verão que atingem o jogador.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Suavização de movimento </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você concluiu todas as etapas até este ponto, posso parabenizá-lo. </font><font style="vertical-align: inherit;">Você acabou de criar um jogo multiplayer funcional! </font><font style="vertical-align: inherit;">Envie o link para um amigo e veja como a magia do multiplayer online pode reunir jogadores! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O jogo é totalmente funcional, mas nosso trabalho não termina aí. </font><font style="vertical-align: inherit;">Existem alguns problemas que podem afetar negativamente a jogabilidade, e devemos lidar com eles:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se nem todo mundo tem uma conexão rápida, o movimento dos outros jogadores parece muito contorcido. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os projéteis parecem lentos, porque não são disparados imediatamente. </font><font style="vertical-align: inherit;">Antes de aparecer na tela do cliente, eles estão aguardando uma mensagem de retorno do servidor.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Podemos resolver o primeiro problema interpolando nossos dados de posição do navio no cliente. Portanto, se não recebermos atualizações com rapidez suficiente, podemos mover o navio sem problemas para o local onde deveria estar, e não apenas teleportá-lo para lá. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os reservatórios requerem uma solução mais complexa. Queremos que o servidor processe shells para proteger contra trapaças, mas também precisamos de uma reação instantânea: um tiro e um projétil voador. A melhor solução é uma abordagem híbrida. O servidor e o cliente podem simular shells, e o servidor ainda enviará atualizações para as posições dos shells. Se eles estiverem fora de sincronia, assumimos que o servidor está correto e redefinimos a posição do projétil no cliente. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não implementaremos esse sistema shell neste tutorial, mas é bom saber que esse método existe.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A simples interpolação das posições dos navios é muito simples. </font><font style="vertical-align: inherit;">Em vez de definir uma posição diretamente no evento de atualização, onde primeiro recebemos novos dados de posição, simplesmente salvamos a posição de destino:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     if(id != socket.id){ other_players[id].target_x = players_data[id].x; //  ,    ,     other_players[id].target_y = players_data[id].y; other_players[id].target_rotation = players_data[id].angle; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em seguida, na função de atualização (também no lado do cliente), contornamos todos os outros jogadores e os empurramos para o objetivo: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     ,      for(var id in other_players){ var p = other_players[id]; if(p.target_x != undefined){ px += (p.target_x - px) * 0.16; py += (p.target_y - py) * 0.16; //  ,    /  var angle = p.target_rotation; var dir = (angle - p.rotation) / (Math.PI * 2); dir -= Math.round(dir); dir = dir * Math.PI * 2; p.rotation += dir * 0.16; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Assim, o servidor nos envia atualizações 30 vezes por segundo, mas ainda podemos jogar a 60 qps e o jogo ainda parece tranquilo! </font></font><br><br><h2>  Conclusão </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examinamos muitos problemas. Vamos listá-los: aprendemos como transferir mensagens entre o cliente e o servidor, como sincronizar o estado do jogo, transmitindo-o do servidor para todos os jogadores. Essa é a maneira mais fácil de implementar um jogo online para vários jogadores. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também aprendemos a proteger o jogo da trapaça, simulando suas partes importantes no servidor e informando os clientes sobre os resultados. Quanto menos você confiar no cliente, mais seguro será o jogo.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, aprendemos a superar atrasos usando a interpolação do cliente. A compensação por atrasos é um tópico sério e é muito importante (alguns jogos com um atraso suficientemente grande tornam-se simplesmente impossíveis de jogar). Interpolar enquanto aguarda a próxima atualização do servidor é apenas uma maneira de reduzir o problema. Outro é prever os próximos quadros com antecedência e corrigi-los ao receber dados reais do servidor, mas, é claro, essa abordagem pode ser muito difícil.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma maneira completamente diferente de reduzir o impacto dos atrasos é fazer com que o design do sistema contorne esse problema. </font><font style="vertical-align: inherit;">A vantagem do giro lento do navio é que ele é uma mecânica única de movimento e que é uma maneira de impedir mudanças bruscas de movimento. </font><font style="vertical-align: inherit;">Portanto, mesmo com uma conexão lenta, eles ainda não destruirão a jogabilidade. </font><font style="vertical-align: inherit;">É muito importante considerar o atraso ao desenvolver os elementos básicos do jogo. </font><font style="vertical-align: inherit;">Às vezes, as melhores decisões não são de todo truques técnicos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você pode usar outra função útil do Glitch, que consiste na capacidade de baixar ou exportar seu próprio projeto através das Opções avançadas no canto superior esquerdo:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c62/d6b/dba/c62d6bdba51311a7a0d8976c37dbe6fb.png"></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418411/">https://habr.com/ru/post/pt418411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418399/index.html">Na onda da Selectel FM</a></li>
<li><a href="../pt418401/index.html">Como eu não me tornei você: um post de amor para administradores de sistemas</a></li>
<li><a href="../pt418403/index.html">Exemplo de programação do acelerador FPGA</a></li>
<li><a href="../pt418405/index.html">O princípio da pirâmide invertida na análise. Criamos um painel compreensível</a></li>
<li><a href="../pt418407/index.html">A mineração em nuvem Hashflare foi fechada. O dinheiro não volta</a></li>
<li><a href="../pt418415/index.html">O Telegram lançou seu próprio serviço de passaporte para verificação e autorização de usuários</a></li>
<li><a href="../pt418417/index.html">Apollo: 9 meses - voo normal</a></li>
<li><a href="../pt418419/index.html">Como a Dodo Pizza resolve problemas de negócios usando o Machine Learning</a></li>
<li><a href="../pt418423/index.html">Casa inteligente: uma nova dimensão de conforto e busca da excelência. Parte um</a></li>
<li><a href="../pt418427/index.html">Indexação para dispositivos móveis. Como e por que o gráfico de links mudará?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>