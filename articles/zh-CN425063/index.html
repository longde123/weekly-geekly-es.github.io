<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌷 🐷 👵🏿 以django为例，为PostgreSQL迁移数据库模式而无需停机 🕯️ 🈴 👧🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 


 哈Ha！ 


 我想分享为postgres和django编写迁移的经验。 这主要是关于postgres的，django是一个很好的补充，因为它具有开箱即用的模型更改自动迁移数据方案的功能，也就是说，它具有用于更改方案的相当完整的工作操作列表。 Django可以用任何喜欢的框架/库替换...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>以django为例，为PostgreSQL迁移数据库模式而无需停机</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/425063/"><h1 id="vvedenie"> 引言 </h1><br><p> 哈Ha！ </p><br><p> 我想分享为postgres和django编写迁移的经验。 这主要是关于postgres的，django是一个很好的补充，因为它具有开箱即用的模型更改自动迁移数据方案的功能，也就是说，它具有用于更改方案的相当完整的工作操作列表。  Django可以用任何喜欢的框架/库替换-方法很可能是相似的。 </p><br><p> 我不会描述我是如何做到这一点的，但是现在阅读文档时，我发现有必要在更早的时候加倍小心和意识地做到这一点，因此，我强烈建议这样做。 </p><br><p> 在继续之前，让我做以下假设。 </p><br><p> 您可以将使用大多数应用程序的数据库的逻辑分为三部分： </p><br><ol><li>迁移-更改数据库架构（表），假设我们始终在一个线程中运行它们。 </li><li> 业务逻辑-直接处理数据（在用户表中），持续且具有竞争力地处理相同的数据。 </li><li> 数据迁移-不更改数据模式，它们基本上像业务逻辑一样工作，默认情况下，当我们谈论业务逻辑时，我们也指数据迁移。 </li></ol><br><p> 停机是指当我们的业务逻辑的一部分在用户明显的时间内无法使用/掉落/加载的状态，假设这是几秒钟。 </p><br><p> 停机时间的缺乏可能是企业的关键条件，任何努力都必须遵守。 <a name="habracut"></a></p><br><h1 id="process-vykatki"> 推出过程 </h1><br><p> 推出时的主要要求： </p><br><ol><li> 我们有一个工作基地。 </li><li> 我们有几台业务逻辑在其中发展的机器。 </li><li> 具有业务逻辑的汽车隐藏在平衡器的后面。 </li><li> 我们的应用程序在滚动迁移之前，期间和之后都能很好地工作（旧代码可以在新旧数据库模式下正常工作）。 </li><li> 我们的应用程序在更新汽车上的代码之前，之中和之后都能很好地工作（旧代码和新代码在当前数据库方案下均能正常工作）。 </li></ol><br><p> 如果存在大量更改，并且推出不再满足这些条件，则将其划分为所需数量的满足这些条件的较小推出，否则我们将停机。 </p><br><p> 直接推出订单： </p><br><ol><li> 大量移民 </li><li> 从平衡器中删除一台机器，更新机器并重新启动，然后将机器退还给平衡器； </li><li> 重复上一步以更新所有汽车。 </li></ol><br><p> 当我们根据更改的方案自动创建迁移并验证是否存在所有向CI迁移时，反向推出顺序与删除表中的表和列有关。 </p><br><ol><li> 从平衡器中删除一台机器，更新机器并重新启动，然后将机器退还给平衡器； </li><li> 重复上一步以更新所有汽车； </li><li> 大量移民。 </li></ol><br><h1 id="teoriya"> 理论 </h1><br><p>  Postgres是一个出色的数据库，我们可以编写一个应用程序，以成千上万个流来写入和读取相同的数据，而且很有可能确保我们的数据将保持有效并且不会被破坏（通常是完整的ACID）。  Postgres实现了多种机制来实现这一目标；其中之一是阻塞。 </p><br><p>  Postgres有几种类型的锁，在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这里</a>可以找到更多详细信息，作为主题的一部分，我将仅涉及表和记录级别的锁。 </p><br><h2 id="blokirovki-na-urovne-tablicy"> 表级锁 </h2><br><p> 在表级别，postgres有<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">几种类型的锁</a> ，主要特征是它们有冲突，即不能同时执行两个有冲突锁的操作： </p><br><table><thead><tr><th></th><th><code>ACCESS SHARE</code> </th> <th> <code>ROW SHARE</code> </th> <th> <code>ROW EXCLUSIVE</code> </th> <th> <code>SHARE UPDATE EXCLUSIVE</code> </th> <th> <code>SHARE</code> </th> <th> <code>SHARE ROW EXCLUSIVE</code> </th> <th> <code>EXCLUSIVE</code> </th> <th> <code>ACCESS EXCLUSIVE</code> </th> </tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>ROW SHARE</code> </td> <td></td><td></td><td></td><td></td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td></td><td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td></td><td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>SHARE ROW EXCLUSIVE</code> </td> <td></td><td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>EXCLUSIVE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p> 例如，必须严格一对一地执行<code>ALTER TABLE tablename ADD COLUMN newcolumn integer</code>和<code>SELECT COUNT(*) FROM tablename</code> ，否则，我们将无法找出要返回<code>COUNT(*)</code> 。 </p><br><p> 在django迁移（下面的完整列表）中，有以下操作及其相应的锁： </p><br><table><thead><tr><th> 阻塞 </th><th> 运作 </th></tr></thead><tbody><tr><td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>CREATE SEQUENCE</code> ， <code>DROP SEQUENCE</code> ， <code>CREATE TABLE</code> ， <code>DROP TABLE</code> ， <code>ALTER TABLE</code> ， <code>DROP INDEX</code> </td></tr><tr><td> <code>SHARE</code> </td> <td> <code>CREATE INDEX</code> </td> </tr><tr><td> <code>SHARE UPDATE EXCLUSIVE</code> </td> <td>  <code>CREATE INDEX CONCURRENTLY</code> ，同时<code>DROP INDEX CONCURRENTLY</code> ， <code>ALTER TABLE VALIDATE CONSTRAINT</code> </td></tr></tbody></table><br><p> 在注释中，并非所有<code>ALTER TABLE</code>都具有<code>ACCESS EXCLUSIVE</code>锁定，Django迁移也没有<code>CREATE INDEX CONCURRENTLY</code>和<code>ALTER TABLE VALIDATE CONSTRAINT</code> ，但是稍后将需要它们来作为标准操作的更安全替代方法。 </p><br><p> 如果在一个线程中按顺序执行迁移，那么一切看起来都不错，因为迁移不会与另一迁移冲突，但是我们的业务逻辑仅在迁移和冲突期间起作用。 </p><br><table><thead><tr><th> 阻塞 </th><th> 运作 </th><th> 与锁冲突 </th><th> 与运营冲突 </th></tr></thead><tbody><tr><td> <code>ACCESS SHARE</code> </td> <td> <code>SELECT</code> </td> <td> <code>ACCESS EXCLUSIVE</code> </td> <td>  <code>ALTER TABLE</code> ， <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW SHARE</code> </td> <td> <code>SELECT FOR UPDATE</code> </td> <td>  <code>ACCESS EXCLUSIVE</code> </td><td>  <code>ALTER TABLE</code> ， <code>DROP INDEX</code> </td></tr><tr><td> <code>ROW EXCLUSIVE</code> </td> <td>  <code>INSERT</code> ， <code>UPDATE</code> ， <code>DELETE</code> </td><td>  <code>ACCESS EXCLUSIVE</code> ， <code>EXCLUSIVE</code> ， <code>SHARE ROW EXCLUSIVE</code> ， <code>SHARE</code> </td><td>  <code>ALTER TABLE</code> ， <code>DROP INDEX</code> ， <code>CREATE INDEX</code> </td></tr></tbody></table><br><p> 这里可以总结两点： </p><br><ol><li> 如果有更容易锁定的替代方法，则可以将其用作<code>CREATE INDEX</code>和<code>CREATE INDEX CONCURRENTLY</code> 。 </li><li> 大多数更改数据架构的迁移都与业务逻辑发生冲突，此外，它们与<code>ACCESS EXCLUSIVE</code>发生冲突，也就是说，我们甚至无法在保持此锁定的情况下进行<code>SELECT</code>并可能期望在此处停机，除非这种操作无法立即生效且停机时间为几秒钟。 </li></ol><br><p> 必须做出选择，或者我们始终避免<code>ACCESS EXCLUSIVE</code> ，也就是说，我们创建新的板并在那里可靠地复制数据，但是长时间复制大量数据，或者使<code>ACCESS EXCLUSIVE</code>尽可能快并针对停机提出其他警告-这是潜在的危险，但是速度很快。 </p><br><h2 id="blokirovki-na-urovne-zapisi"> 记录锁 </h2><br><p> 在记录级别，还存在锁<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS</a> ，它们也发生冲突，但它们只会影响我们的业务逻辑： </p><br><table><thead><tr><th></th><th> <code>FOR KEY SHARE</code> </th> <th> <code>FOR SHARE</code> </th> <th> <code>FOR NO KEY UPDATE</code> </th> <th> <code>FOR UPDATE</code> </th> </tr></thead><tbody><tr><td> <code>FOR KEY SHARE</code> </td> <td></td><td></td><td></td><td>  X </td></tr><tr><td> <code>FOR SHARE</code> </td> <td></td><td></td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR NO KEY UPDATE</code> </td> <td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td> <code>FOR UPDATE</code> </td> <td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table><br><p> 这是数据迁移的重点，也就是说，如果我们在整个板上进行<code>UPDATE</code>数据迁移，则其余更新数据的业务逻辑将等待锁释放并可能超过我们的停机时间阈值，因此最好进行部分更新以进行数据迁移。 还值得注意的是，当使用更复杂的sql查询进行数据迁移时，拆分成多个部分可以更快地进行，因为它可以使用更优化的计划和索引。 </p><br><h2 id="ocheryodnost-vypolneniya-operaciy"> 操作顺序 </h2><br><p> 另一个重要的知识是如何执行操作，何时以及如何进行和释放锁： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/889/8f9/adb/8898f9adbf4eab0350517d07177b7257.png" alt="图片"></p><br><p> 您可以在此处突出显示以下项目： </p><br><ol><li> 操作执行时间-对于迁移来说，这是持有锁的时间，如果长时间保持沉重的锁，我们将有一个停机时间，例如，可以使用<code>CREATE INDEX</code>或<code>ALTER TABLE ADD COLUMN SET DEFAULT</code> （在postgres 11中更好）。 </li><li> 冲突锁的等待时间-也就是说，迁移会一直等到所有冲突的请求都解决了，此时新的请求将等待我们的迁移，在这里缓慢的请求可能非常危险，无论是不是最佳的还是分析性的，因此在此期间不应存在缓慢的请求迁移。 </li><li> 每秒的请求数-如果长时间有很多请求在处理，那么免费连接可以迅速结束，而不是一个有问题的地方，整个数据库都可以进入停机状态（超级用户将只有一个连接限制），在这里您需要避免缓慢的请求，减少请求数量例如，在最小负载下开始迁移，使用其自己的数据库将关键组件分为不同的服务。 </li><li> 一个事务中有许多迁移操作-一个事务中的操作越多，重锁的持有时间就越长，因此最好分离重操作，而<code>ALTER TABLE VALIDATE CONSTRAINT</code>或具有重锁的一个事务中的数据迁移则更好。 </li></ol><br><h2 id="taymauty"> 超时时间 </h2><br><p>  <code>lock_timeout</code>具有诸如<code>lock_timeout</code>和<code>statement_timeout</code>设置，可以保护迁移的开始，既防止写得不好的迁移，也可以防止可能触发迁移的恶劣条件。 它们既可以全局安装，也可以当前连接安装。 </p><br><p> 在迁移之前等待缓慢的请求/事务之前，将<code>SET lock_timeout TO '2s'</code>可以避免停机： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT</a> 。 </p><br><p>  <code>SET statement_timeout TO '2s'</code>可以避免在使用重锁启动重迁移时避免停机： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT</a> 。 </p><br><h2 id="dedloki"> 死锁 </h2><br><p> 迁移中的死锁与停机时间无关，但是在编写迁移时并不令人满意，它在测试环境中可以正常工作，但在产品上滚动时却可以捕获死锁。 问题的主要根源可能是在一个事务和外键中进行大量操作，因为它在两个表中都创建了锁，所以最好将迁移操作分开，原子化越好。 </p><br><h2 id="hranenie-zapisey"> 记录存储 </h2><br><p>  Postgres <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以不同的方式存储不同类型的值</a> ：如果类型以不同的方式存储，则在它们之间进行转换将需要完全重写所有值，幸运的是，某些类型以相同的方式存储，并且在更改时不需要重写。 例如，无论大小如何，行都存储相同，减小/增大行的大小将不需要重写，但是减小行需要验证所有行均不超过较小的大小。 其他类型也可以以相似的方式存储并具有相似的特性。 </p><br><h2 id="multiversion-concurrency-control-mvcc"> 多版本并发控制（MVCC） </h2><br><p> 根据<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档</a> ，postgres一致性基于数据多版本，也就是说，每个事务和操作都可以看到自己的数据版本。 此功能完美地解决了竞争访问问题，并且在更改方案（例如添加和删除列）仅更改方案时，如果没有用于更改数据，索引或常量的附加操作，那么在较低级别的插入和更新操作将创建新的方案时，也会产生有趣的效果。具有所有必要值的记录，删除将标记相应的记录已删除。  VACUUM或AUTO VACUUM负责清洁剩余的碎屑。 </p><br><h1 id="primer-django">  Django范例 </h1><br><p> 现在，我们已经了解了停机时间可能取决于什么以及如何避免停机，但是在应用知识之前，您可以先看看django给出的内容（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/django/django/blob/2.1.2/django /db/backends/base/schema.py</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/django/django/blob/2.1.2/django/db/backends/postgresql/schema.py</a> ）： </p><br><table><thead><tr><th></th><th> 操作 </th></tr></thead><tbody><tr><td>  1个 </td><td> <code>CREATE SEQUENCE</code> </td> </tr><tr><td>  2 </td><td> <code>DROP SEQUENCE</code> </td> </tr><tr><td>  3 </td><td> <code>CREATE TABLE</code> </td> </tr><tr><td>  4 </td><td> <code>DROP TABLE</code> </td> </tr><tr><td>  5 </td><td> <code>ALTER TABLE RENAME TO</code> </td> </tr><tr><td>  6 </td><td> <code>ALTER TABLE SET TABLESPACE</code> </td> </tr><tr><td>  7 </td><td> <code>ALTER TABLE ADD COLUMN [SET DEFAULT] [SET NOT NULL] [PRIMARY KEY] [UNIQUE]</code> </td> </tr><tr><td>  8 </td><td> <code>ALTER TABLE ALTER COLUMN [TYPE] [SET NOT NULL|DROP NOT NULL] [SET DEFAULT|DROP DEFAULT]</code> </td> </tr><tr><td>  9 </td><td> <code>ALTER TABLE DROP COLUMN</code> </td> </tr><tr><td>  10 </td><td> <code>ALTER TABLE RENAME COLUMN</code> </td> </tr><tr><td>  11 </td><td> <code>ALTER TABLE ADD CONSTRAINT CHECK</code> </td> </tr><tr><td>  12 </td><td> <code>ALTER TABLE DROP CONSTRAINT CHECK</code> </td> </tr><tr><td>  13 </td><td> <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  14 </td><td> <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> </td> </tr><tr><td>  15 </td><td> <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  16 </td><td> <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> </td> </tr><tr><td>  17 </td><td> <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  18岁 </td><td> <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> </td> </tr><tr><td>  19 </td><td> <code>CREATE INDEX</code> </td> </tr><tr><td>  20 </td><td> <code>DROP INDEX</code> </td> </tr></tbody></table><br><p>  Django很好地满足了我的迁移需求，现在我们可以在不停机的情况下讨论安全和危险的迁移操作。 </p><br><p> 我们将使用<code>SHARE UPDATE EXCLUSIVE</code>锁定或<code>ACCESS EXCLUSIVE</code>来调用更安全的迁移，该迁移可立即生效。 <br> 我们将使用<code>SHARE</code>和<code>ACCESS EXCLUSIVE</code>锁来进行危险的迁移，这将花费大量时间。 </p><br><p> 我将通过大量示例预先留下有用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的文档链接</a> 。 </p><br><h2 id="sozdanie-i-udalenie-tablicy"> 创建和删除表 </h2><br><p>  <code>CREATE SEQUENCE</code> ， <code>DROP SEQUENCE</code> ， <code>CREATE TABLE</code> ， <code>DROP TABLE</code>称为安全的，因为业务逻辑要么不再与已迁移的表一起工作，否则使用FOREIGN KEY删除表的行为将在以后出现。 </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochih-tablicah"> 大量支持的工作表操作 </h2><br><p>  <code>ALTER TABLE RENAME TO</code>我很难称呼它为安全，因为在迁移前后很难编写适用于此类表的逻辑。 </p><br><p>  <code>ALTER TABLE SET TABLESPACE</code>不安全，因为它会物理移动板，并且在大体积上可能要花费很长时间。 </p><br><p> 另一方面，这些操作非常少见，作为替代，您可以提供创建新表并将数据复制到其中的功能。 </p><br><h2 id="sozdanie-i-udalenie-kolonki"> 创建和删除列 </h2><br><p>  <code>ALTER TABLE ADD COLUMN</code> ， <code>ALTER TABLE DROP COLUMN</code> －可以称为安全（创建时没有DEFAULT / NOT NULL / PRIMARY KEY / UNIQUE），因为业务逻辑不再适用于已迁移的列，使用FOREIGN KEY删除列的行为，其他常量和索引将在以后出现。 </p><br><p>  <code>ALTER TABLE ADD COLUMN SET DEFAULT</code> ， <code>ALTER TABLE ADD COLUMN SET NOT NULL</code> ， <code>ALTER TABLE ADD COLUMN PRIMARY KEY</code> ， <code>ALTER TABLE ADD COLUMN UNIQUE</code>不安全的操作，因为它们添加列并且在不释放锁的情况下使用默认值更新数据或创建构造作为替代，可为空的列，并作进一步的更改。 </p><br><p> 值得一提的是postgres 11中更快的<code>SET DEFAULT</code> ，它可以被认为是安全的，但是在django中并没有什么用，因为django仅使用<code>SET DEFAULT</code>来填充列，然后使<code>DROP DEFAULT</code> ，以及在迁移和更新机器之间的间隔在业务逻辑中，可以创建不存在默认值的记录，也就是说，同样地，执行数据迁移。 </p><br><h2 id="tyazhelo-podderzhivaemye-operacii-na-rabochey-tablice"> 工作表上大量支持的操作 </h2><br><p>  <code>ALTER TABLE RENAME COLUMN</code>我也不能称之为安全，因为在迁移前后很难编写与该列兼容的逻辑。 而是，该操作也不会很频繁，因为可以建议创建新列并将数据复制到该列。 </p><br><h2 id="izmenenie-kolonki"> 列变更 </h2><br><p>  <code>ALTER TABLE ALTER COLUMN TYPE</code> -操作既危险又安全。 如果postgres仅更改方案，并且数据已经以所需格式存储并且不需要其他类型检查，则是安全的，例如： </p><br><ul><li> 从<code>varchar(LESS)</code>到<code>varchar(MORE)</code>类型更改； </li><li> 将类型从<code>varchar(ANY)</code>更改为<code>text</code> ； </li><li> 类型从<code>numeric(LESS, SAME)</code>更改为<code>numeric(MORE, SAME)</code> 。 </li></ul><br><p>  <code>ALTER TABLE ALTER COLUMN SET NOT NULL</code>是危险的，因为它会传递内部数据并检查NULL，幸运的是，此结构可以用另一个<code>CHECK IS NOT NULL</code>代替。 值得注意的是，这种替换将导致不同的方案，但具有相同的属性。 </p><br><p>  <code>ALTER TABLE ALTER COLUMN DROP NOT NULL</code> ， <code>ALTER TABLE ALTER COLUMN SET DEFAULT</code> ， <code>ALTER TABLE ALTER COLUMN DROP DEFAULT</code>安全操作。 </p><br><h2 id="sozdanie-i-udalenie-indeksov-i-konstreyntov"> 创建和删除索引和常量 </h2><br><p>  <code>ALTER TABLE ADD CONSTRAINT CHECK</code>和<code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code>是不安全的操作，但是可以将它们声明为<code>NOT VALID</code> ，然后再声明<code>ALTER TABLE VALIDATE CONSTRAINT</code> 。 </p><br><p>  <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code>和<code>ALTER TABLE ADD CONSTRAINT UNIQUE</code>不安全的，因为它们在内部创建了唯一索引，但是您可以创建唯一索引为<code>CONCURRENTLY</code> ，然后使用现成索引通过<code>USING INDEX</code>创建相应的常量。 </p><br><p>  <code>CREATE INDEX</code>是不安全的操作，但是可以将<code>CONCURRENTLY</code>创建为索引。 </p><br><p>  <code>ALTER TABLE DROP CONSTRAINT CHECK</code> ， <code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code> ， <code>ALTER TABLE DROP CONSTRAINT PRIMARY KEY</code> ， <code>ALTER TABLE DROP CONSTRAINT UNIQUE</code> ， <code>DROP INDEX</code>安全操作。 </p><br><p> 值得注意的是， <code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code>和<code>ALTER TABLE DROP CONSTRAINT FOREIGN KEY</code>一次锁定两个表。 </p><br><h2 id="primenyaem-znaniya-v-django"> 在django中应用知识 </h2><br><p>  Django在迁移中具有执行任何SQL的操作： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//docs.djangoproject.com/en/2.1/ref/migration-operations/#django.db.migrations.operations.RunSQL</a> 。 通过它，您可以设置必要的超时并为迁移应用替代操作，指示<code>state_operations</code>我们正在替换的迁移。 </p><br><p> 尽管需要额外的编写，但是这对于其代码而言效果很好，但是您可以将繁琐的工作留在数据库后端，例如， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/tbicr/django-pg-zero-downtime-migrations/blob/master/django_zero_downtime_migrations_postgres_backend/schema .py</a>收集描述的做法，并用安全的对等替换不安全的操作，这将适用于第三方库。 </p><br><h1 id="naposledok"> 最后 </h1><br><p> 这些实践使我可以直接使用django创建的相同方案，只是替换了<code>CHECK IS NOT NULL</code>构造而不是<code>NOT NULL</code>和一些构造名称（例如，对于<code>ALTER TABLE ADD COLUMN UNIQUE</code>和其他方式）。 另一个权衡可能是替代迁移操作缺乏事务性，尤其是在出现<code>CREATE INDEX CONCURRENTLY</code>和<code>ALTER TABLE VALIDATE CONSTRAINT</code> 。 </p><br><p> 如果您没有超出postgres的范围，那么可以使用许多选项来更改数据方案，并且可以在特定条件下组合使用它们： </p><br><ul><li> 使用jsonb作为schamaless解决方案 </li><li> 停机的机会 </li><li> 无需停机即可进行迁移的要求 </li></ul><br><p> 无论如何，我希望该材料对增加正常运行时间或扩大意识很有用。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN425063/">https://habr.com/ru/post/zh-CN425063/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN425053/index.html">SSR：何时，为什么以及为什么。 以Vue为例</a></li>
<li><a href="../zh-CN425055/index.html">Oculus任务</a></li>
<li><a href="../zh-CN425057/index.html">来自GeekBrains和Alfa Bank的所有GeekUniversity课程的教育优惠贷款</a></li>
<li><a href="../zh-CN425059/index.html">Tinkoff.ru的Hackhackon No.1</a></li>
<li><a href="../zh-CN425061/index.html">CodeRainbow：交互式代码学习和文档</a></li>
<li><a href="../zh-CN425069/index.html">使用PromiseKit测试演示者</a></li>
<li><a href="../zh-CN425071/index.html">如何防止堆栈溢出（在Cortex M上）？</a></li>
<li><a href="../zh-CN425073/index.html">在OneDrive上轻松创建git存储库</a></li>
<li><a href="../zh-CN425075/index.html">机器视觉：在PHP中安装，配置和使用Google Cloud Vision</a></li>
<li><a href="../zh-CN425077/index.html">Kotlin深入了解-参见反编译的字节码</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>