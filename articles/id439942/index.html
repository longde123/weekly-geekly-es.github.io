<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏵️ 🚎 ☠️ Docker: apa yang perlu diketahui oleh setiap pengembang .Net 🀄️ 👉🏻 💪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di era DevOps yang menang, pengembang hanya perlu tahu tentang wadah Docker, mengapa mereka diperlukan dan bagaimana cara bekerja dengannya. Ini sanga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Docker: apa yang perlu diketahui oleh setiap pengembang .Net</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/psb/blog/439942/"> Di era DevOps yang menang, pengembang hanya perlu tahu tentang wadah Docker, mengapa mereka diperlukan dan bagaimana cara bekerja dengannya.  Ini sangat memudahkan pekerjaan.  Selain itu, bahkan mereka yang bekerja dengan .Net Core di lingkungan pengembangan Visual Studio 2017 dapat merasakan kekuatan penuh kontainerisasi. Pavel Skiba, kepala departemen pengembangan aplikasi server, di pertemuan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Panda-Meetup C # .Net</a> , berbicara tentang alat yang tersedia dan mengkonfigurasi Docker untuk VS. <br><br><img src="https://habrastorage.org/webt/-u/oc/-i/-uoc-itpzk__qajoj6vuduyvqsc.jpeg"><br><a name="habracut"></a><br>  Apa yang harus bisa dilakukan pengembang?  "Program," jawab Anda dan ... Tebak.  Tetapi jika sebelumnya daftar pengetahuan yang diperlukan berakhir pada ini, sekarang di zaman DevOps itu baru saja dimulai.  Ketika kita menulis kode, kita pasti perlu mengetahui struktur jaringan: apa yang berinteraksi dengan apa.  Dukungan diperlukan untuk beberapa bahasa pemrograman sekaligus, dan potongan kode yang berbeda dalam suatu proyek dapat ditulis pada apa saja. <br><br><img src="https://habrastorage.org/webt/kv/v8/e0/kvv8e0hdfubjxrh-ph7y8bqaxho.jpeg"><br><br>  Kita perlu tahu cara memutar kembali perangkat lunak jika kesalahan terdeteksi.  Kita perlu mengelola konfigurasi untuk lingkungan yang berbeda yang digunakan di perusahaan - ini setidaknya beberapa lingkungan pengembang, lingkungan pengujian dan pertempuran.  Oh ya, Anda masih perlu memahami skrip di berbagai server / sistem operasi, karena tidak semuanya dapat dilakukan menggunakan kode, terkadang Anda harus menulis skrip. <br><br>  Kita perlu mengetahui persyaratan keamanan, dan mereka menjadi lebih keras dan memakan banyak waktu dari pengembang.  Jangan lupa tentang dukungan dan pengembangan perangkat lunak terkait: Git, Jenkins dan sebagainya.  Akibatnya, pengembang mungkin tidak punya cukup waktu untuk pengembangan murni. <br><br>  Apa yang harus dilakukan  Ada jalan keluar, dan itu terletak di wadah Docker dan sistem manajemen mereka.  Setelah Anda menyebarkan semua raksasa yang rumit ini, dan Anda, seperti di masa lalu yang baik, hanya akan menulis kode lagi.  Segala sesuatu yang lain akan dikendalikan oleh orang lain atau sistem itu sendiri. <br><br><h3>  Kami memahami wadah </h3><br>  Apa itu wadah buruh pelabuhan?  Ini adalah struktur yang terdiri dari beberapa lapisan.  Lapisan atas adalah lapisan biner dari aplikasi Anda.  Lapisan kedua dan ketiga sekarang terintegrasi dalam. Net Core, wadah sudah SDK-shny.  Lapisan selanjutnya tergantung pada sistem operasi yang digunakan wadah tersebut.  Dan lapisan bawah adalah sistem operasi itu sendiri. <br><br><img src="https://habrastorage.org/webt/la/9r/rr/la9rrrk6nijaktzurbzvs6-7vem.jpeg"><br><br>  Di tingkat yang lebih rendah, Windows Nanoserver digunakan.  Ini adalah tekanan besar dari Windows Server, yang tidak dapat melakukan apa-apa selain mempertahankan program utilitas yang digunakan.  Tapi volumenya 12 kali lebih sedikit. <br><br>  Jika kita membandingkan server dan wadah fisik dan virtual, maka manfaat yang terakhir jelas. <br><br><img src="https://habrastorage.org/webt/rv/jf/bf/rvjfbftq2pa8vxkypp0cufyailq.jpeg"><br><br>  Ketika semuanya bekerja pada server fisik, kami dihadapkan dengan banyak masalah.  Tidak ada isolasi dalam kode perpustakaan, beberapa aplikasi dapat saling mengganggu.  Misalnya: satu aplikasi berfungsi di .Net 1.1, dan yang lain di .Net 2.0.  Paling sering, ini menyebabkan tragedi.  Setelah beberapa waktu, server virtual muncul, masalah isolasi diselesaikan, tidak ada perpustakaan bersama.  Benar, pada saat yang sama menjadi sangat mahal dalam hal sumber daya dan tenaga kerja: perlu untuk memantau sepanjang waktu berapa banyak mesin virtual berputar pada satu mesin virtual, pada Hyper-V dan pada sepotong besi. <br><br>  Kontainer dirancang untuk menjadi solusi yang murah dan nyaman, minimal bergantung pada OS.  Mari kita lihat perbedaannya.  Server virtual di dalam sistem berada kira-kira seperti ini. <br><br><img src="https://habrastorage.org/webt/7r/tx/hy/7rtxhyzwk89x504k4elpatklrue.jpeg"><br><br>  Lapisan bawah adalah server host.  Ini bisa berupa fisik atau virtual.  Lapisan berikutnya adalah OS apa saja dengan virtualisasi, di atas adalah hypervisor.  Di atas adalah server virtual yang dapat dibagi menjadi OS tamu dan aplikasi.  Yaitu, di bawah setiap server virtual, OS tamu digunakan di atas OS, dan ini adalah pemborosan sumber daya tambahan. <br><br>  Mari kita lihat bagaimana wadah Linux berada di sistem. <br><br><img src="https://habrastorage.org/webt/2i/fh/qm/2ifhqmfohluhldax3v5evaomvvo.jpeg"><br><br>  Seperti yang Anda lihat, binari dengan aplikasi langsung terletak di atas server host dan OS.  OS Guest tidak diperlukan, sumber daya dibebaskan, lisensi untuk OS tamu tidak diperlukan. <br><br>  Wadah Windows sedikit berbeda dari Linux. <br><br><img src="https://habrastorage.org/webt/br/p3/td/brp3tdb9vl_yau-iwsqj_c5yfmm.jpeg"><br><br>  Lapisan dasarnya sama: infrastruktur, host OS (tapi sekarang Windows).  Tetapi kemudian wadah dapat bekerja secara langsung dengan OS atau ditempatkan di atas hypervisor.  Dalam kasus pertama, ada isolasi proses dan ruang, tetapi mereka menggunakan inti yang sama dengan wadah lain, yang dari sudut pandang keamanan bukan es.  Jika Anda menggunakan kontainer melalui Hyper-V, maka semuanya akan diisolasi. <br><br><h3>  Mempelajari Docker untuk VS </h3><br>  Mari kita beralih ke Docker itu sendiri.  Misalkan Anda memiliki Visual Studio, dan Anda menginstal klien Docker untuk Windows untuk pertama kalinya.  Dalam hal ini, Docker akan menggunakan server iblis Docker, antarmuka di Istirahat untuk akses ke sana, dan klien itu sendiri - baris perintah Docker.  Ini akan memungkinkan kami untuk mengelola segala sesuatu yang terkait dengan wadah: jaringan, gambar, wadah, lapisan. <br><br><img src="https://habrastorage.org/webt/h3/ft/dz/h3ftdzxhy9d-y2cz43xjbllnfiq.jpeg"><br><br>  Slide menunjukkan perintah yang paling sederhana: tarik wadah Docker, luncurkan, kumpulkan, komit, kirim kembali. <br><br>  Docker sangat organik dipasangkan dengan Visual Studio.  Tangkapan layar memperlihatkan menu panel dari Visual Studio 2017. Dukungan penulisan Docker terintegrasi langsung ke Intellisense, Dockerfile didukung, dan semua artefak bekerja pada baris perintah. <br><br><img src="https://habrastorage.org/webt/o6/lo/xq/o6loxq2u8gcuxqmeeqc9rf5d7jw.jpeg"><br><br>  Menariknya, kita bisa men-debug kontainer Docker secara langsung dalam waktu nyata.  Dan jika kontainer Anda terhubung satu sama lain, maka mereka akan segera dibuang sekaligus, dan Anda tidak perlu menjalankan beberapa lingkungan. <br><br>  Bagaimana wadah dirakit?  Elemen utama di sini adalah dockerfile, yang berisi instruksi untuk membangun gambar.  Setiap dockerfile dibuat untuk setiap proyek.  Ini menunjukkan: dari mana kita mendapatkan gambar dasar, argumen apa yang kita lewati, apa nama direktori yang berfungsi dengan file, port. <br><br><img src="https://habrastorage.org/webt/cw/y4/s4/cwy4s4ukujlmx_ewfcr9rhq6wk4.jpeg"><br><br>  Argumen sumber ini memiliki dua parameter.  Parameter kedua adalah jalur di mana hasil perakitan akan ditempatkan di proyek, nilainya diatur secara default.  Menurut pendapat saya, ini bukan pilihan yang sangat baik.  Sering ada banyak sampah di folder ini, perlu dibersihkan secara berkala, dan ketika kita membersihkan folder ini, kita bisa menggosok rakitan.  Jadi, jika Anda mau, Anda bisa mengubahnya, itu diatur oleh parameter sistem Docker_build_source, yang juga bisa dipalu. <br><br>  Instruksi Entrypoint memungkinkan Anda untuk mengonfigurasi wadah sebagai yang dapat dieksekusi.  Baris ini diperlukan untuk .Net Core, sehingga setelah wadah mulai berhasil, ia mengirim pesan "Aplikasi Anda sedang berjalan" ke baris perintah. <br><br>  Sekarang tentang men-debug kontainer.  Semuanya di sini seperti .Net biasa, Anda akan sulit melihat perbedaannya.  Paling sering, saya menjalankan .Net Core sebagai self-host di bawah dotnet.exe.  Ini menggunakan debugger CLRDBG, cache paket NuGet dan kode sumber. <br><br>  ASP.Net 4.5+ diselenggarakan oleh IIS atau IIS Express, menggunakan Microsoft Visual Studio Debugger dan sumber root situs di IIS. <br><br><img src="https://habrastorage.org/webt/1h/xa/ad/1hxaadi82m4yntfg6nurythtlui.jpeg"><br><br>  Ada dua lingkungan untuk debugging: Debug dan Rilis.  Tag gambar debugging ditandai sebagai dev, dan rilis terbaru.  Saat debugging, argumen Sumber lebih baik diatur ke obj / Docker / kosong, agar tidak menjadi bingung, tetapi ketika Anda melepaskan obj / Docker / publikasikan.  Di sini Anda dapat menggunakan semua binari, tampilan, folder wwwroot yang sama dan semua dependensi yang ada. <br><br><h3>  Menguasai Docker Compose </h3><br>  Mari kita beralih ke bagian yang menyenangkan: alat orkestrasi penyusun Docker.  Mari kita lihat sebuah contoh: Anda memiliki semacam layanan bisnis yang memengaruhi 5-6 kontainer.  Dan Anda perlu memperbaiki bagaimana mereka harus dirakit, dalam urutan apa.  Di sinilah komposisi Docker sangat berguna, yang akan menyediakan semua perakitan, peluncuran dan penskalaan kontainer.  Dikelola secara sederhana, semuanya dikumpulkan oleh satu tim. <br><br><img src="https://habrastorage.org/webt/d4/df/aq/d4dfaqe-8qt-k9wxxfs6y8gigke.jpeg"><br><br>  Susunan docker menggunakan file YAML yang menyimpan konfigurasi tentang bagaimana kontainer harus dirakit.  Mereka menggambarkan pengaturan apa yang perlu Anda gunakan untuk gambar itu sendiri, rakitan, layanan, volume, jaringan, lingkungan.  Sintaksnya identik untuk publikasi dalam kelompok.  Yaitu, begitu mereka menulis file seperti itu, dan jika di masa depan akan diperlukan untuk menggunakan layanan bisnis dalam sebuah cluster, Anda tidak perlu menambahkan apa pun. <br><br>  Pertimbangkan struktur file YAML.  Gambar adalah gambar Docker.  Sebuah gambar adalah sebuah wadah tanpa lapisan aplikasi, itu tidak berubah. <br><br><img src="https://habrastorage.org/webt/no/y1/s7/noy1s7xjmk8uzkx9qw-7dgtubuc.jpeg"><br><br>  Build menunjukkan cara membangun, di mana membangun dan di mana akan digunakan. <br>  Depends_on - Ketergantungan pada layanan yang bergantung padanya. <br>  Lingkungan - di sini kita mengatur lingkungan. <br>  Ports - pemetaan port di mana port wadah Anda akan tersedia. <br><br>  Pertimbangkan sebuah contoh.  Kami hanya memiliki API tanpa layanan, pada dasarnya 3 wadah: ada SQL.data di Linux, ada aplikasi itu sendiri, itu tergantung pada webapi, dan webapi tergantung pada SQL.data. <br><br><img src="https://habrastorage.org/webt/dl/_b/wz/dl_bwzfrtxf-dpiumh0d6mcmork.jpeg"><br><br>  Tidak masalah bagaimana urutan komponen ditulis dalam file.  Jika semuanya dijelaskan dengan benar, Compose akan secara otomatis membangun informasi ini berdasarkan dependensi dalam proyek.  File ini cukup untuk mengumpulkan semua kontainer sekaligus, hasilnya akan menjadi rilis yang selesai. <br><br>  Ada semacam "wadah kontainer", buruh pelabuhan kontainer-compose.ci.build.yml kontainer khusus, di mana seluruh komposisi dirakit.  Anda dapat menjalankan wadah khusus ini dari baris perintah Visual Studio, dan itu akan dapat menyelesaikan perakitan di server build, misalnya, di Jenkins. <br><br><img src="https://habrastorage.org/webt/c-/n7/dt/c-n7dtz4rp_xdqlove2dxze5w7y.jpeg"><br><br>  Lihatlah di dalam file.  Contoh berisi direktori kerja dan dari mana asalnya.  Ia memulihkan proyek dari GIT, menerbitkan sendiri solusi ini, mengonfigurasi Rilis, dan mengunggah hasilnya.  Itulah seluruh tim yang harus dibangun, tidak ada lagi yang perlu ditulis.  Cukup mendaftar sekali, lalu mulai publikasi dengan satu tombol. <br><br>  Apa lagi yang perlu diperhatikan.  Susunan Docker untuk setiap lingkungan mengumpulkan gambar, untuk setiap konfigurasi file terpisah.  Untuk setiap konfigurasi di Visual Studio ada file dengan pengaturan yang Anda butuhkan untuk lingkungan. <br><br><img src="https://habrastorage.org/webt/hp/tl/mh/hptlmho5s80wvh-vqgpprnimnau.jpeg"><br><br>  Langsung dari VS, Anda dapat mulai men-debug seluruh komposisi dari jarak jauh. <br><br><h3>  Orkestra Kelompok </h3><br>  Akhirnya, kami menyentuh topik-topik seperti orkestra klaster.  Kita seharusnya tidak memikirkan bagaimana wadah terus ada, orang atau sistem mana yang dikelola.  Untuk ini, ada 4 sistem manajemen kontainer paling populer: Google Kubernetes, Mesos DC / OS, Docker Swarm, dan Azure Service Fabric.  Mereka memungkinkan Anda untuk mengelola pengelompokan dan komposisi wadah. <br><br><img src="https://habrastorage.org/webt/5h/xd/lq/5hxdlqbpiyr2e7lytjagsikndec.jpeg"><br><br>  Sistem-sistem ini mampu mengatasi lapisan besar layanan microser, memberikan mereka semua yang diperlukan.  Pengembang hanya perlu mengkonfigurasi lapisan ini sekali. <br><br>  Versi lengkap kinerja di Panda Meetup tersedia di bawah ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/GLMFaf39zxM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Bagi mereka yang ingin mempelajari topik ini lebih dalam, saya menyarankan Anda untuk mempelajari bahan-bahan berikut: <br><br>  Http://dot.net <br>  Http://docs.docker.com <br>  Http://hub.docker.com/microsoft <br>  Http://docs.microsoft.com <br>  Http://visualstudio.com <br><br>  Dan akhirnya, nasihat penting dari praktik: hal yang paling sulit adalah mengingat di mana letak itu. <br><br>  Dokumentasi ketika bekerja dengan wadah buruh pelabuhan akan jatuh di pundak Anda.  Tanpa dokumentasi, Anda akan lupa di mana wadah apa yang terhubung dengan apa dan apa yang berhasil.  Semakin banyak layanan, semakin besar total koneksi web. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id439942/">https://habr.com/ru/post/id439942/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id439932/index.html">Bagaimana kami membuka kantor pengembangan</a></li>
<li><a href="../id439934/index.html">Proses bisnis. Ekstrak model BPMN dari dokumen. Bagian 1</a></li>
<li><a href="../id439936/index.html">Teknologi 3D untuk pengecoran: cara membuat cetakan untuk casting dalam seminggu</a></li>
<li><a href="../id439938/index.html">Apa yang harus dipanggil: kebijakan privasi dan kebijakan privasi</a></li>
<li><a href="../id439940/index.html">Teamlead Conf Msk 2019: hasil kampanye aplikasi, laporan, pertimbangan</a></li>
<li><a href="../id439944/index.html">SAPUI5 untuk boneka bagian 5: Latihan selangkah demi selangkah yang lengkap</a></li>
<li><a href="../id439946/index.html">Mengapa kami memilih Elektron</a></li>
<li><a href="../id439948/index.html">Intel SVT-AV1: Open Source AV1 Encoder untuk Tugas Berat</a></li>
<li><a href="../id439950/index.html">3rd Turing Test: syarat untuk berpartisipasi dan hadiah untuk pemenang</a></li>
<li><a href="../id439952/index.html">Hosting Node.js https server dengan SSL yang diperbarui secara otomatis di cloud dan bagaimana saya mengatur siklus pengembangan (+ git, bereaksi)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>