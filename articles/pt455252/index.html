<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍💼 📪 👩🏾‍🎤 .NET: Ferramentas para trabalhar com multi-threading e assincronia - Parte 1 🤘🏻 🎅🏽 👩🏻‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originalmente, publiquei este artigo no blog CodingSight 
 A segunda parte do artigo está disponível aqui 

 A necessidade de fazer as coisas de manei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Ferramentas para trabalhar com multi-threading e assincronia - Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455252/">  <i>Originalmente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publiquei</a> este artigo no blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CodingSight</a></i> <br>  <i>A segunda parte do artigo está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a></i> <br><br>  A necessidade de fazer as coisas de maneira assíncrona - ou seja, dividir grandes tarefas entre várias unidades de trabalho - estava presente muito antes do surgimento dos computadores.  No entanto, quando eles apareceram, essa necessidade se tornou ainda mais óbvia.  Agora é 2019, e estou escrevendo este artigo em um laptop equipado com uma CPU Intel Core de 8 núcleos que, além disso, trabalha simultaneamente em centenas de processos, com o número de threads ainda maior.  Ao meu lado, está um smartphone um pouco desatualizado que comprei há alguns anos - e também possui um processador de 8 núcleos.  Os recursos especializados da web contêm uma grande variedade de artigos elogiando os principais smartphones deste ano, equipados com CPUs de 16 núcleos.  Por menos de US $ 20 por hora, o MS Azure pode fornecer acesso a uma máquina virtual de 128 núcleos com 2 TB de RAM.  Infelizmente, você não pode tirar o máximo proveito desse poder, a menos que saiba controlar a interação entre os threads. <br><a name="habracut"></a><br><h4>  Conteúdo </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terminologia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma metáfora</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferramentas .NET</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Iniciando um Thread</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualizando e depurando threads</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca paralela de tarefas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parando Encadeamentos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transformando uma API herdada em uma baseada em tarefas usando FromAsync</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transformando uma API herdada em uma baseada em tarefas usando TaskCompletionSource</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dicas e truques para fonte de tarefas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ValueTask: Por que e como</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TaskScheduler: Controlando estratégias de execução de tarefas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PLinq e a classe paralela</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sumário</a> </li></ul><br><a name="Terminology"></a><br><h3>  Terminologia </h3><br>  <b>Processo</b> - um objeto do SO que representa um espaço de endereço isolado contendo threads. <br><br>  <b>Thread</b> - um objeto do SO que representa a menor unidade de execução.  Os encadeamentos são partes constituintes dos processos, dividem a memória e outros recursos entre si no escopo de um processo. <br><br>  <b>Multitarefa</b> - um recurso do SO que representa a capacidade de executar vários processos simultaneamente. <br><br>  <b>Multi-core</b> - um recurso de CPU que representa a capacidade de usar vários núcleos para processamento de dados <br><br>  <b>Multiprocessamento</b> - o recurso de um computador que representa a capacidade de trabalhar fisicamente com várias CPUs. <br><br>  <b>Multiencadeamento</b> - o recurso de um processo que representa a capacidade de dividir e espalhar o processamento de dados entre vários encadeamentos. <br><br>  <b>Paralelismo</b> - execução física simultânea de várias ações em uma unidade de tempo <br><br>  <b>Assincronia</b> - executar uma operação sem esperar que ela seja totalmente processada, deixando o cálculo do resultado para mais tarde. <br><br><a name="Metaphor"></a><br><h3>  Uma metáfora </h3><br>  Nem todas as definições são eficazes e algumas delas requerem elaboração; portanto, deixe-me fornecer uma metáfora de cozimento para a terminologia que acabei de introduzir. <br><br>  Fazer café da manhã representa um <b>processo</b> nessa metáfora. <br><br>  Ao fazer o café da manhã, eu ( <b>CPU</b> ) vou para a cozinha ( <b>Computador</b> ).  Eu tenho duas mãos ( <b>Cores</b> ).  Na cozinha, há uma variedade de dispositivos ( <b>IO</b> ): fogão, chaleira, torradeira, geladeira.  Ligo o fogão, coloco uma frigideira e despejo um pouco de óleo vegetal.  Sem esperar que o óleo aqueça (de <b>forma assíncrona, Não obstrua as entradas / saídas</b> ), pego alguns ovos na geladeira, os quebro em uma tigela e os bato com uma mão ( <b>Linha 1</b> ).  Enquanto isso, o ponteiro dos segundos (Segmento # 2) mantém a tigela no lugar ( <b>Recurso Compartilhado</b> ).  Gostaria de ligar a chaleira, mas não tenho mãos livres suficientes no momento ( <b>Fome de Linha</b> ).  Enquanto batia os ovos, a frigideira ficou quente o suficiente (processamento de resultados), então despejei os ovos batidos nela.  Estendo a mão na chaleira, ligo a panela e olho para a água que está sendo fervida ( <b>Bloqueio-IO-Espere</b> ) - mas eu poderia ter usado esse tempo para lavar a tigela. <br><br>  Usei apenas duas mãos ao fazer a omelete (porque não tenho mais), mas foram executadas três operações simultâneas: bater os ovos, segurar a tigela, aquecer a frigideira.  A CPU é a parte mais rápida do computador e a E / S é a parte que requer a espera com mais frequência; portanto, é bastante eficaz carregar a CPU com algum trabalho enquanto aguarda os dados da E / S. <br><br>  Para estender a metáfora: <br><br><ul><li>  Se eu também estivesse tentando trocar de roupa enquanto preparava o café da manhã, teria sido <b>multitarefa</b> .  Os computadores são muito melhores nisso do que os humanos. </li><li>  Uma cozinha com vários cozinheiros - por exemplo, em um restaurante - é um computador com <b>vários núcleos</b> . </li><li>  Uma praça de alimentação de shopping com muitos restaurantes representaria um <b>data center</b> . </li></ul><br><br><a name="NetTools"></a><br><h3>  Ferramentas .NET </h3><br>  O .NET é realmente bom quando se trata de trabalhar com threads - assim como em muitas outras coisas.  A cada nova versão, ele fornece mais ferramentas para trabalhar com threads e novas camadas de abstração de threads do SO.  Ao trabalhar com abstrações, os desenvolvedores que trabalham com a estrutura estão usando uma abordagem que lhes permite reduzir uma ou mais camadas enquanto usam abstrações de alto nível.  Na maioria dos casos, não há necessidade real de fazer isso (e isso pode introduzir a possibilidade de dar um tiro no pé), mas às vezes essa é a única maneira de resolver um problema que não pode ser resolvido no nível de abstração atual. <br><br>  Quando eu disse as ferramentas anteriormente, quis dizer interfaces de programa (API) fornecidas pela estrutura ou pacotes de terceiros e soluções de software completas que simplificam o processo de pesquisa de problemas relacionados ao código multiencadeado. <br><br><a name="StartingAThread"></a><br><h4>  Iniciando um Thread </h4><br>  A classe Thread é a classe .NET mais básica para trabalhar com threads.  Seu construtor aceita um desses dois delegados: <br><br><ul><li>  ThreadStart - sem parâmetros </li><li>  ParametrizedThreadStart - um parâmetro do tipo de objeto. </li></ul><br><br>  O delegado será executado em um thread recém-criado depois de chamar o método Start.  Se o delegado ParametrizedThreadStart foi passado para o construtor, um objeto deve ser passado para o método Start.  Esse processo é necessário para passar qualquer informação local para o encadeamento.  Devo salientar que são necessários muitos recursos para criar um thread e o próprio thread é um objeto pesado - pelo menos porque requer interação com a API do SO e 1 MB de memória é alocado para a pilha. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  A classe ThreadPool representa o conceito de um pool.  No .NET, o pool de threads é uma obra de arte da engenharia e os desenvolvedores da Microsoft investiram muito esforço para fazê-lo funcionar de maneira ideal em todos os tipos de cenários. <br><br>  <b>O conceito geral:</b> <br>  <i>Quando iniciado, o aplicativo cria alguns threads em segundo plano, permitindo acessá-los quando necessário.</i>  <i>Se os threads forem usados ​​com frequência e em grandes números, o pool será expandido para satisfazer as necessidades do código de chamada.</i>  <i>Se o pool não tiver threads livres suficientes no momento certo, ele aguardará um dos threads ativos ficar desocupado ou criará um novo.</i>  <i>Com base nisso, o conjunto de encadeamentos é perfeito para ações curtas e não funciona muito bem para processos que funcionam como serviços por toda a duração da operação do aplicativo.</i> <br><br>  O método QueueUserWorkItem permite usar threads do pool.  Este método <i>utiliza o</i> delegado <i>WaitCallback</i> -type.  Sua assinatura coincide com a assinatura de ParametrizedThreadStart, e o parâmetro que é passado para ele tem a mesma função. <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  O método de pool de encadeamentos RegisterWaitForSingleObject menos conhecido é usado para organizar operações de E / S sem bloqueio.  O delegado que é passado para esse método será chamado quando o WaitHandle for liberado após ser passado para o método. <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br><br>  Há um cronômetro de encadeamento no .NET e ele difere dos timers WinForms / WPF, pois seu manipulador é chamado no encadeamento retirado do pool. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br><br>  Também há uma maneira bastante incomum de enviar o delegado para um thread do pool - o método BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br><br>  Eu também gostaria de dar uma olhada na função que muitos dos métodos que eu mencionei anteriormente se referem ao - CreateThread da API Win32 do Kernel32.dll.  Existe uma maneira de chamar essa função com a ajuda do mecanismo externo dos métodos.  Eu só vi isso sendo usado uma vez em um caso particularmente ruim de código legado - e ainda não entendo quais foram as razões de seu autor. <br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><br><a name="ViewingAndDebuggingThreads"></a><br><h4>  Visualizando e depurando threads </h4><br>  Todos os threads - criados por você, componentes de terceiros ou o pool .NET - podem ser exibidos na janela <b>Threads</b> do Visual Studio.  Essa janela exibirá apenas as informações sobre threads quando o aplicativo estiver sendo depurado no modo Break.  Aqui, você pode visualizar os nomes e prioridades de cada thread e focar o modo de depuração em threads específicos.  A propriedade Priority da classe Thread permite definir a prioridade do thread.  Essa prioridade será levada em consideração quando o SO e o CLR estiverem dividindo o tempo do processador entre os threads. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><a name="TaskParallelLibrary"></a><br><h4>  Biblioteca paralela de tarefas </h4><br>  A Biblioteca Paralela de Tarefas (TPL) apareceu pela primeira vez no .NET 4.0.  Atualmente, é a principal ferramenta para trabalhar com assincronia.  Qualquer código que utilize abordagens mais antigas será considerado código legado.  A unidade principal do TPL é a classe <b>Task</b> do espaço para nome System.Threading.Tasks.  As tarefas representam a abstração do encadeamento.  Com a versão mais recente do C #, adquirimos uma nova maneira elegante de trabalhar com o Tasks - os operadores assíncronos / aguardados.  Isso permite que o código assíncrono seja escrito como se fosse simples e síncrono, para que aqueles que não são bem versados ​​na teoria de threads agora possam escrever aplicativos que não terão dificuldades com operações longas.  O uso de assíncrono / espera é realmente um tópico para um artigo separado (ou mesmo alguns artigos), mas tentarei descrever o básico em algumas frases: <br><br><ul><li>  async é um modificador de um método que retorna uma tarefa ou anula </li><li>  waitit é um operador de uma tarefa de espera sem bloqueio. </li></ul><br><br>  Mais uma vez: o operador aguardar normalmente (há exceções) deixa o encadeamento atual e, quando a tarefa é executada e o encadeamento (na verdade, o contexto, mas voltaremos a ele mais tarde) estará livre como um Como resultado, ele continuará executando o método.  No .NET, esse mecanismo é implementado da mesma maneira que o retorno de rendimento - um método é transformado em uma classe de máquina de estados finitos que pode ser executada em partes separadas com base em seu estado.  Se isso parecer interessante, eu recomendaria escrever qualquer trecho de código simples baseado em assíncrono / aguardar, compilando-o e analisando sua compilação com a ajuda do JetBrains dotPeek com o código gerado pelo compilador ativado. <br><br>  Vejamos as opções que temos quando se trata de iniciar e usar uma tarefa.  No exemplo abaixo, criamos uma nova tarefa que na verdade não faz nada produtivo (Thread.Sleep (10000)).  No entanto, em casos reais, devemos substituí-lo por algum trabalho complexo que utiliza recursos da CPU. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br><br>  Uma tarefa é criada com as seguintes opções: <br><br><ul><li>  LongRunning - essa opção sugere o fato de que a tarefa não pode ser executada rapidamente.  Portanto, é possivelmente melhor criar um thread separado para esta tarefa, em vez de retirar um existente do pool para minimizar danos a outras tarefas. </li><li>  AttachedToParent - As tarefas podem ser organizadas hierarquicamente.  Se essa opção for usada, a tarefa estará aguardando a execução de suas tarefas filhas após a própria execução. </li><li>  PreferFairness - esta opção especifica que a tarefa deve ser melhor executada antes das tarefas que foram criadas posteriormente.  No entanto, é mais uma sugestão, portanto o resultado nem sempre é garantido. </li></ul><br><br>  O segundo parâmetro que foi passado para o método é CancellationToken.  Para que a operação seja cancelada corretamente depois de já ter sido iniciada, o código executável deve conter as verificações de estado de CancellationToken.  Se não houver essas verificações, o método Cancel chamado no objeto CancellationTokenSource só poderá parar a execução da tarefa antes que a tarefa seja realmente iniciada. <br><br>  Para o último parâmetro, enviamos um objeto do tipo TaskScheduler chamado scheduler.  Essa classe, juntamente com suas classes filho, é usada para controlar como as tarefas são distribuídas entre os threads.  Por padrão, uma tarefa será executada em um encadeamento selecionado aleatoriamente do pool <br><br>  O operador de espera é aplicado à tarefa criada.  Isso significa que o código escrito depois dele (se houver esse código) será executado no mesmo contexto (geralmente, isso significa 'no mesmo encadeamento') que o código escrito antes o aguardará. <br><br>  Esse método é identificado como vazio assíncrono, o que significa que o operador de espera pode ser usado nele, mas o código de chamada não poderá aguardar a execução.  Se tal possibilidade for necessária, o método deve retornar uma tarefa.  Os métodos rotulados como vazio assíncrono podem ser vistos com bastante frequência: geralmente são manipuladores de eventos ou outros métodos que operam sob o princípio de ignorar e esquecer.  Se for necessário aguardar a conclusão da execução e retornar o resultado, você deve usar a Tarefa. <br><br>  Para tarefas que retornam o método StartNew, podemos chamar ConfigureAwait com o parâmetro false - então, a execução após aguardar continuará em um contexto aleatório em vez de capturado.  Isso sempre deve ser feito se o código gravado após aguardar não exigir um contexto de execução específico.  Essa também é uma recomendação da MS quando se trata de escrever código fornecido como uma biblioteca. <br><br>  Vejamos como podemos esperar que uma tarefa seja concluída.  Abaixo, você pode ver um exemplo de código com comentários indicando quando a espera é implementada de maneira relativamente boa ou ruim. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  No primeiro exemplo, estamos aguardando a execução da tarefa sem bloquear o segmento de chamada, portanto, voltaremos a processar o resultado quando estiver pronto.  Antes que isso aconteça, o encadeamento de chamada é deixado sozinho. <br><br>  Na segunda tentativa, estamos bloqueando o encadeamento de chamada até que o resultado do método seja calculado.  Essa é uma abordagem ruim por dois motivos.  Antes de tudo, estamos desperdiçando um encadeamento - um recurso muito valioso - na simples espera.  Além disso, se o método que estamos chamando contiver um aguardar enquanto um retorno para o segmento de chamada depois de aguardar for planejado pelo contexto de sincronização, obteremos um impasse.  Isso acontece porque o encadeamento de chamada estará aguardando o resultado de um método assíncrono, e o próprio método assíncrono tentará infrutífera continuar sua execução no encadeamento de chamada. <br><br>  Outra desvantagem dessa abordagem é o aumento da complexidade do tratamento de erros.  Na verdade, os erros podem ser tratados com bastante facilidade no código assíncrono se for usado o assíncrono / espera - o processo nesse caso é idêntico ao do código síncrono.  No entanto, quando uma espera síncrona é aplicada a uma tarefa, a exceção inicial é agrupada em AggregateException.  Em outras palavras, para lidar com a exceção, precisaríamos explorar o tipo InnerException e escrever manualmente uma cadeia if em um bloco de captura ou, alternativamente, usar a captura quando a estrutura em vez da cadeia mais usual de blocos de captura. <br><br>  Os dois últimos exemplos também são rotulados como relativamente ruins pelos mesmos motivos e ambos contêm os mesmos problemas. <br><br>  Os métodos WhenAny e WhenAll são muito úteis quando se trata de aguardar um grupo de tarefas - eles agrupam essas tarefas em uma e serão executados quando uma tarefa do grupo for iniciada ou quando todas essas tarefas forem executadas com êxito. <br><br><a name="StoppingThreads"></a><br><h4>  Parando Encadeamentos </h4><br>  Por vários motivos, pode ser necessário interromper um encadeamento depois que ele foi iniciado.  Existem algumas maneiras de fazer isso.  A classe Thread possui dois métodos com nomes apropriados - <b>Interromper</b> e <b>Interromper</b> .  Eu desencorajaria fortemente o uso do primeiro, pois, depois de chamado, haveria uma <b>ThreadAbortedException</b> lançada a qualquer momento aleatório ao processar qualquer instrução escolhida arbitrariamente.  Você não espera que essa exceção seja encontrada quando uma variável inteira for incrementada, certo?  Bem, ao usar o método Abort, isso se torna uma possibilidade real.  No caso de você precisar negar a capacidade do CLR de criar essas exceções em uma parte específica do código, você pode <b>agrupá-</b> lo no <b>Thread.InstititititRegion</b> e <b>Thread.EndCriticalRegion</b> .  Qualquer código escrito no bloco final é envolvido nessas chamadas.  É por isso que você pode encontrar blocos com uma tentativa vazia e uma não vazia finalmente nas profundezas do código da estrutura.  A Microsoft não gosta deste método na medida em que não o inclui no núcleo do .NET. <br><br>  O método <b>Interromper</b> funciona de uma maneira muito mais previsível.  Ele pode interromper um thread com uma <b>ThreadInterruptedException</b> apenas quando o thread estiver no modo de espera.  Ele se move para esse estado quando suspenso enquanto aguarda WaitHandle, um bloqueio ou após o Thread.Sleep ser chamado. <br><br>  Ambas as formas têm uma desvantagem de imprevisibilidade.  Para escapar desse problema, devemos usar a estrutura <b>CancellationToken</b> e a classe <b>CancellationTokenSource</b> .  A ideia geral é a seguinte: uma instância da classe CancellationTokenSource é criada e somente aqueles que a possuem podem parar a operação chamando o método <b>Cancel</b> .  Somente CancellationToken é passado para a operação.  Os proprietários do CancelamentoToken não podem cancelar a operação eles mesmos - eles podem apenas verificar se a operação foi cancelada.  Isso pode ser alcançado usando a propriedade booleana <b>IsCancellationRequested</b> e o método <b>ThrowIfCancelRequested</b> .  O último gerará uma <b>TaskCancelledException</b> se o método Cancel tiver sido chamado na instância CancellationTokenSource que criou o CancellationToken.  Este é o método que eu recomendo usar.  Sua vantagem sobre os métodos descritos anteriormente reside no fato de fornecer controle total sobre os casos de exceção exata nos quais uma operação pode ser cancelada. <br><br>  A maneira mais brutal de interromper um thread seria chamar uma função da API do Win32 chamada TerminateThread.  Depois que essa função é chamada, o comportamento do CLR pode ser bastante imprevisível.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MSDN</a> , foi escrito o seguinte sobre esta função: <i>“TerminateThread é uma função perigosa que só deve ser usada nos casos mais extremos.</i>  <i>"</i> <br><br><a name="FromAsync"></a><br><h4>  Transformando uma API herdada em uma baseada em tarefas usando FromAsync </h4><br>  Se você teve a sorte de trabalhar em um projeto iniciado após a introdução das Tarefas (e quando não estiver mais provocando horror existencial na maioria dos desenvolvedores), não precisará lidar com APIs antigas - ambas de terceiros. aqueles e aqueles em que sua equipe trabalhou no passado.  Felizmente, a equipe de desenvolvimento do .NET Framework tornou mais fácil para nós - mas isso poderia ter sido um autocuidado, pelo que sabemos.  De qualquer forma, o .NET possui algumas ferramentas que ajudam a trazer o código escrito com as abordagens antigas para assincronia, para um formulário atualizado.  Um deles é o método TaskFactory chamado FromAsync.  No exemplo abaixo, estou agrupando os métodos assíncronos antigos da classe WebRequest em uma tarefa usando FromAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>É apenas um exemplo, e você provavelmente não fará algo desse tipo com os tipos internos.</i>  <i>No entanto, projetos antigos estão repletos de métodos BeginDoSomething que retornam os métodos IAsyncResult e EndDoSomething que os recebem.</i> <br><br><a name="TaskCompletionSource"></a><br><h4>  Transformando uma API herdada em uma baseada em tarefas usando TaskCompletionSource </h4><br>  Outra ferramenta que vale a pena explorar é a classe <b>TaskCompletionSource</b> .  Em sua funcionalidade, objetivo e princípio de operação, ele se parece com o método RegisterWaitForSingleObject da classe ThreadPool que eu mencionei anteriormente.  Essa classe nos permite envolver facilmente APIs assíncronas antigas em Tarefas. <br><br>  <i>Você pode dizer que eu já falei sobre o método FromAsync da classe TaskFactory, que serviu a esses propósitos.</i>  <i>Aqui, precisamos lembrar o histórico completo dos modelos assíncronos que a Microsoft forneceu nos últimos 15 anos: antes dos padrões assíncronos baseados em tarefas (TAP), havia padrões de programação assíncrona (APP).</i>  <i>Os aplicativos eram sobre <b>Begin</b> DoSomething retornando IAsyncResult e o método <b>End</b> DoSomething que o aceita - e o método FromAsync é perfeito para o legado desses anos.</i>  <i>No entanto, com o passar do tempo, isso foi substituído pelo EAP (Event Based Asynchronous Patterns), que especificava que um evento é chamado quando uma operação assíncrona é executada com êxito.</i> <br><br>  TaskCompletionSource são perfeitos para agrupar APIs herdadas criadas em torno do modelo de evento nas Tarefas.  É assim que funciona: os objetos dessa classe têm uma propriedade pública chamada Task, cujo estado pode ser controlado por vários métodos da classe TaskCompletionSource (SetResult, SetException etc.).  Nos locais em que o operador de espera foi aplicado a esta tarefa, ele será executado ou travado com uma exceção, dependendo do método aplicado ao TaskCompletionSource.  Para entender melhor, vejamos este exemplo de código.  Aqui, alguma API antiga da era EAP é agrupada em uma tarefa com a ajuda de TaskCompletionSource: quando um evento é acionado, a tarefa será alternada para o estado Concluído enquanto o método que aplicou o operador de espera a esta tarefa continuará sua execução. depois de receber um objeto de <b>resultado</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><a name="TaskCompletionSourceTips"></a><br><h4>  Dicas e truques para fonte de tarefas </h4><br>  TaskCompletionSource pode fazer mais do que apenas agrupar APIs obsoletas.  Essa classe abre uma possibilidade interessante de criar várias APIs baseadas em tarefas que não ocupam threads.  Um thread, como lembramos, é um recurso caro, limitado principalmente pela RAM.  Podemos facilmente atingir esse limite ao desenvolver um aplicativo Web robusto com lógica de negócios complexa.  Vejamos os recursos que mencionei em ação, implementando um truque conhecido como Long Polling. <br><br>  <b>Em resumo, é assim que o Long Polling funciona:</b> <br>  <i>Você precisa obter algumas informações de uma API sobre eventos que ocorrem do seu lado, mas a API, por algum motivo, pode retornar apenas um estado em vez de informar sobre o evento.</i>  <i>Um exemplo disso seria qualquer API criada sobre HTTP antes do WebSocket aparecer ou em circunstâncias nas quais essa tecnologia não pode ser usada.</i>  <i>O cliente pode perguntar ao servidor HTTP.</i>  <i>O servidor HTTP, por outro lado, não pode iniciar o contato com o cliente sozinho.</i>  <i>A solução mais simples seria solicitar ao servidor periodicamente usando um timer, mas isso criaria carga adicional para o servidor e um atraso geral que é aproximadamente igual a TimerInterval / 2. Para contornar isso, a Pesquisa Longa foi inventada.</i>  <i>Isso implica em atrasar a resposta do servidor até o tempo limite expirar ou ocorrer um evento.</i>  <i>Se um evento ocorrer, ele será tratado;</i>  <i>caso contrário - o pedido será enviado novamente.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  No entanto, a eficácia dessa solução diminuirá radicalmente se o número de clientes aguardando o evento aumentar - cada cliente em espera ocupa um encadeamento completo.  Além disso, temos um atraso adicional de 1ms para o acionamento do evento.  Frequentemente, não é realmente tão crucial, mas por que tornamos nosso software pior do que poderia ser?  Por outro lado, se removermos o Thread.Sleep (1), um dos núcleos da CPU será carregado por 100%, sem fazer nada em um ciclo inútil.  Com a ajuda do TaskCompletionSource, podemos transformar facilmente nosso código para resolver todos os problemas mencionados: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Lembre-se de que esse trecho de código é apenas um exemplo e de forma alguma pronto para produção.</i>  <i>Para usá-lo em casos reais, precisaríamos pelo menos adicionar uma maneira de lidar com situações nas quais uma mensagem é recebida quando nada estava esperando por ela: nesse caso, o método AcceptMessageAsync deve retornar uma tarefa já concluída.</i>  <i>Se esse for o caso mais comum, podemos considerar o uso da ValueTask.</i> <br><br>  Ao receber uma solicitação de mensagem, criamos um TaskCompletionSource, colocamos em um dicionário e aguardamos um dos seguintes eventos: o intervalo de tempo especificado é gasto ou a mensagem é recebida. <br><br><a name="ValueTask"></a><br><h4>  ValueTask: Por que e como </h4><br>  Os operadores async / waitit, assim como o operador de retorno de rendimento, geram uma máquina de estados finitos a partir de um método, o que significa criar um novo objeto - isso não importa muito na maioria das vezes, mas ainda pode criar problemas em alguns casos raros.  Um desses casos pode ocorrer com os métodos chamados com freqüência - estamos falando de dezenas e centenas de milhares de chamadas por segundo.  Se esse método é escrito de uma maneira que faz com que ele retorne o resultado, ignorando todos os métodos de espera na maioria dos casos, o .NET fornece uma ferramenta de otimização para isso - a estrutura ValueTask.  Para entender como funciona, vejamos um exemplo.  Suponha que exista um cache que acessamos regularmente.  Se houver algum valor, basta devolvê-lo;  se não houver valores - tentamos obtê-los de algumas E / S lentas.  Idealmente, o último deve ser feito de forma assíncrona, para que todo o método seja assíncrono.  Portanto, a maneira mais óbvia de implementar esse método será a seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br>  Com o desejo de otimizá-lo um pouco e uma preocupação com o que Roslyn gerará ao compilar esse código, poderíamos reescrever o método assim: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br>  No entanto, a melhor solução nesse caso seria otimizar o atalho - especificamente, obtendo valores de dicionário sem alocações desnecessárias e sem carga no GC.  Enquanto isso, nos casos pouco frequentes em que precisamos obter dados de E / S, as coisas permanecerão quase as mesmas: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br>  Vamos olhar mais de perto esse fragmento de código: se um valor estiver presente no cache, criaremos uma estrutura;  caso contrário, a tarefa real será agrupada em uma ValueTask.  O caminho pelo qual esse código é executado não é importante para o código de chamada: da perspectiva da sintaxe C #, uma ValueTask se comportará como uma Tarefa usual. <br><br><a name="TaskScheduler"></a><br><h4>  TaskScheduler: Controlando estratégias de execução de tarefas </h4><br>  A próxima API da qual gostaria de falar é a classe <b>TaskScheduler</b> e as derivadas dela.  Eu já mencionei que o TPL fornece a capacidade de controlar como exatamente as tarefas estão sendo distribuídas entre os threads.  Essas estratégias são definidas nas classes herdadas do TaskScheduler.  Quase qualquer estratégia que possamos precisar pode ser encontrada na biblioteca <b>ParallelExtensionsExtras</b> .  Esta biblioteca é desenvolvida pela Microsoft, mas não faz parte do .NET. Em vez disso, é distribuída como um pacote Nuget.  Vamos dar uma olhada em algumas das estratégias: <br><br><ul><li>  CurrentThreadTaskScheduler - executa tarefas no thread atual </li><li>  LimitedConcurrencyLevelTaskScheduler - limita o número de tarefas executadas simultaneamente usando o parâmetro N que ele aceita no construtor </li><li>  OrderedTaskScheduler - é definido como LimitedConcurrencyLevelTaskScheduler (1), para que as tarefas sejam executadas seqüencialmente. </li><li>  WorkStealingTaskScheduler - implementa a abordagem de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">roubo</a> de trabalho para execução de tarefas.  Essencialmente, ele pode ser visto como um ThreadPool separado.  Isso ajuda a questão de o ThreadPool ser uma classe estática no .NET - se for sobrecarregado ou usado incorretamente em uma parte do aplicativo, efeitos colaterais desagradáveis ​​podem ocorrer em um local diferente.  As causas reais desses defeitos podem ser difíceis de localizar, portanto, pode ser necessário usar WorkStealingTaskSchedulers separados nas partes do aplicativo em que o uso do ThreadPool pode ser agressivo e imprevisível. </li><li>  QueuedTaskScheduler - permite executar tarefas com base em uma fila priorizada </li><li>  ThreadPerTaskScheduler - cria um thread separado para cada tarefa executada nele.  Isso pode ser útil para tarefas cujo tempo de execução não pode ser estimado. </li></ul><br>  Há um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> muito bom sobre os TaskSchedulers no blog da Microsoft, portanto, fique à vontade para conferir. <br><br>  No Visual Studio, há uma janela Tarefas que pode ajudar na depuração de tudo relacionado a Tarefas.  Nesta janela, você pode ver o estado da tarefa e pular para a linha de código atualmente executada. <br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><a name="PLinq"></a><br><h4>  PLinq e a classe paralela </h4><br>  Além de Tarefas e tudo relacionado a elas, existem duas ferramentas adicionais no .NET que podemos achar interessantes - <b>PLinq</b> (Linq2Parallel) e a classe <b>Parallel</b> .  O primeiro promete execução paralela de todas as operações do Linq em todos os threads.  O número de threads pode ser configurado por um método de extensão WithDegreeOfParallelism.  Infelizmente, na maioria dos casos, o PLinq no modo padrão não terá informações suficientes sobre a fonte de dados para fornecer um aumento significativo na velocidade.  Por outro lado, o custo da tentativa é muito baixo: você só precisa chamar <b>AsParallel</b> antes da cadeia de métodos do Linq e executar testes de desempenho.  Além disso, você pode passar informações adicionais sobre a natureza da sua fonte de dados para o PLinq usando o mecanismo Partitions.  Você pode encontrar mais informações <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A classe estática Parallel fornece métodos para enumerar coleções em paralelo via Foreach, executando o ciclo For e executando vários delegados em paralelo a Invoke.  A execução do encadeamento atual será interrompida até que os resultados sejam calculados.  Você pode configurar o número de threads passando ParallelOptions como o último argumento.  TaskScheduler e CancellationToken também podem ser configurados com a ajuda de opções. <br><br><a name="Summary"></a><br><h3>  Sumário </h3><br>  Quando comecei a escrever este artigo com base na minha tese e no conhecimento que adquiri ao trabalhar depois, não achei que houvesse tanta informação.  Agora, com o editor de texto me dizendo reprovadoramente que escrevi quase 15 páginas, gostaria de tirar uma conclusão intermediária.  Veremos outras técnicas, APIs, ferramentas visuais e riscos ocultos no próximo artigo. <br><br>  <b>Conclusões:</b> <br><br><ul><li>  Para usar efetivamente os recursos dos PCs modernos, você precisa conhecer ferramentas para trabalhar com threads, assincronia e paralelismo. </li><li>  Existem muitas ferramentas como esta no .NET </li><li>  Nem todos eles foram criados ao mesmo tempo; portanto, é possível que você encontre frequentemente algum código legado - mas há maneiras de transformar APIs antigas com pouco esforço. </li><li>  No .NET, as classes Thread e ThreadPool são usadas para trabalhar com threads </li><li>  O método Thread.Abort e Thread.Interrupt, juntamente com a função de API do Win32 TerminateThread, são perigosos e não são recomendados para uso.  Em vez disso, é melhor usar CancellationTokens </li><li>  Threads são um recurso valioso e seu número é limitado.  Você deve evitar os casos em que os segmentos estão ocupados aguardando eventos.  A classe TaskCompletionSource pode ajudar a conseguir isso. </li><li>  As tarefas são a ferramenta mais poderosa e robusta que o .NET possui para trabalhar com paralelismo e assincronia. </li><li>  Os operadores C # assíncronos / esperados implementam o conceito de uma espera sem bloqueio </li><li>  Você pode controlar como as tarefas são distribuídas entre os threads com a ajuda de classes derivadas do TaskScheduler </li><li>  A estrutura ValueTask pode ser usada para otimizar atalhos e tráfego de memória </li><li>  As janelas Tarefas e Threads no Visual Studio fornecem muitas informações úteis para depurar código assíncrono ou multithread </li><li>  O PLinq é uma ferramenta incrível, mas pode não ter todas as informações necessárias sobre sua fonte de dados - que ainda podem ser corrigidas com o mecanismo de particionamento </li></ul><br>  <i>Para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">continuar</a> ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455252/">https://habr.com/ru/post/pt455252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455240/index.html">Usando a taxa de defeitos rejeitados para melhorar o relatório de erros</a></li>
<li><a href="../pt455244/index.html">História em quadrinhos "A soldagem é fácil" na versão atualizada (2019)</a></li>
<li><a href="../pt455246/index.html">As inscrições para o Customer Experience Day em São Petersburgo estão abertas em 20 de junho</a></li>
<li><a href="../pt455248/index.html">Principais erros de desenvolvimento ao trabalhar com o PostgreSQL</a></li>
<li><a href="../pt455250/index.html">Aquele que ressuscitou Duke Nukem: entrevista com Randy Pitchford, mágico da Gearbox</a></li>
<li><a href="../pt455256/index.html">Habr Weekly # 4 / Computex, como beta da Apple, Durov está morrendo de fome, gato BadComedian, por que a rede neural procurou atores pornográficos</a></li>
<li><a href="../pt455258/index.html">Começou a votação dos relatórios da seção Backend no aniversário do DevConfX, que será realizada de 21 a 22 de junho em Moscou</a></li>
<li><a href="../pt455260/index.html">Árvore Merkle: enferrujado e rápido</a></li>
<li><a href="../pt455264/index.html">Seja como Munch, ou algumas palavras sobre dever técnico</a></li>
<li><a href="../pt455268/index.html">Como tudo começou: displays flexíveis e dobráveis ​​- a história da aparência e saída de "pessoas"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>