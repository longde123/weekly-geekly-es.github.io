<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèø‚Äçüíº üì™ üë©üèæ‚Äçüé§ .NET: Ferramentas para trabalhar com multi-threading e assincronia - Parte 1 ü§òüèª üéÖüèΩ üë©üèª‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originalmente, publiquei este artigo no blog CodingSight 
 A segunda parte do artigo est√° dispon√≠vel aqui 

 A necessidade de fazer as coisas de manei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>.NET: Ferramentas para trabalhar com multi-threading e assincronia - Parte 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455252/">  <i>Originalmente, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publiquei</a> este artigo no blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CodingSight</a></i> <br>  <i>A segunda parte do artigo est√° dispon√≠vel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a></i> <br><br>  A necessidade de fazer as coisas de maneira ass√≠ncrona - ou seja, dividir grandes tarefas entre v√°rias unidades de trabalho - estava presente muito antes do surgimento dos computadores.  No entanto, quando eles apareceram, essa necessidade se tornou ainda mais √≥bvia.  Agora √© 2019, e estou escrevendo este artigo em um laptop equipado com uma CPU Intel Core de 8 n√∫cleos que, al√©m disso, trabalha simultaneamente em centenas de processos, com o n√∫mero de threads ainda maior.  Ao meu lado, est√° um smartphone um pouco desatualizado que comprei h√° alguns anos - e tamb√©m possui um processador de 8 n√∫cleos.  Os recursos especializados da web cont√™m uma grande variedade de artigos elogiando os principais smartphones deste ano, equipados com CPUs de 16 n√∫cleos.  Por menos de US $ 20 por hora, o MS Azure pode fornecer acesso a uma m√°quina virtual de 128 n√∫cleos com 2 TB de RAM.  Infelizmente, voc√™ n√£o pode tirar o m√°ximo proveito desse poder, a menos que saiba controlar a intera√ß√£o entre os threads. <br><a name="habracut"></a><br><h4>  Conte√∫do </h4><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terminologia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uma met√°fora</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ferramentas .NET</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Iniciando um Thread</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Visualizando e depurando threads</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Biblioteca paralela de tarefas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parando Encadeamentos</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transformando uma API herdada em uma baseada em tarefas usando FromAsync</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Transformando uma API herdada em uma baseada em tarefas usando TaskCompletionSource</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Dicas e truques para fonte de tarefas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ValueTask: Por que e como</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">TaskScheduler: Controlando estrat√©gias de execu√ß√£o de tarefas</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PLinq e a classe paralela</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sum√°rio</a> </li></ul><br><a name="Terminology"></a><br><h3>  Terminologia </h3><br>  <b>Processo</b> - um objeto do SO que representa um espa√ßo de endere√ßo isolado contendo threads. <br><br>  <b>Thread</b> - um objeto do SO que representa a menor unidade de execu√ß√£o.  Os encadeamentos s√£o partes constituintes dos processos, dividem a mem√≥ria e outros recursos entre si no escopo de um processo. <br><br>  <b>Multitarefa</b> - um recurso do SO que representa a capacidade de executar v√°rios processos simultaneamente. <br><br>  <b>Multi-core</b> - um recurso de CPU que representa a capacidade de usar v√°rios n√∫cleos para processamento de dados <br><br>  <b>Multiprocessamento</b> - o recurso de um computador que representa a capacidade de trabalhar fisicamente com v√°rias CPUs. <br><br>  <b>Multiencadeamento</b> - o recurso de um processo que representa a capacidade de dividir e espalhar o processamento de dados entre v√°rios encadeamentos. <br><br>  <b>Paralelismo</b> - execu√ß√£o f√≠sica simult√¢nea de v√°rias a√ß√µes em uma unidade de tempo <br><br>  <b>Assincronia</b> - executar uma opera√ß√£o sem esperar que ela seja totalmente processada, deixando o c√°lculo do resultado para mais tarde. <br><br><a name="Metaphor"></a><br><h3>  Uma met√°fora </h3><br>  Nem todas as defini√ß√µes s√£o eficazes e algumas delas requerem elabora√ß√£o; portanto, deixe-me fornecer uma met√°fora de cozimento para a terminologia que acabei de introduzir. <br><br>  Fazer caf√© da manh√£ representa um <b>processo</b> nessa met√°fora. <br><br>  Ao fazer o caf√© da manh√£, eu ( <b>CPU</b> ) vou para a cozinha ( <b>Computador</b> ).  Eu tenho duas m√£os ( <b>Cores</b> ).  Na cozinha, h√° uma variedade de dispositivos ( <b>IO</b> ): fog√£o, chaleira, torradeira, geladeira.  Ligo o fog√£o, coloco uma frigideira e despejo um pouco de √≥leo vegetal.  Sem esperar que o √≥leo aque√ßa (de <b>forma ass√≠ncrona, N√£o obstrua as entradas / sa√≠das</b> ), pego alguns ovos na geladeira, os quebro em uma tigela e os bato com uma m√£o ( <b>Linha 1</b> ).  Enquanto isso, o ponteiro dos segundos (Segmento # 2) mant√©m a tigela no lugar ( <b>Recurso Compartilhado</b> ).  Gostaria de ligar a chaleira, mas n√£o tenho m√£os livres suficientes no momento ( <b>Fome de Linha</b> ).  Enquanto batia os ovos, a frigideira ficou quente o suficiente (processamento de resultados), ent√£o despejei os ovos batidos nela.  Estendo a m√£o na chaleira, ligo a panela e olho para a √°gua que est√° sendo fervida ( <b>Bloqueio-IO-Espere</b> ) - mas eu poderia ter usado esse tempo para lavar a tigela. <br><br>  Usei apenas duas m√£os ao fazer a omelete (porque n√£o tenho mais), mas foram executadas tr√™s opera√ß√µes simult√¢neas: bater os ovos, segurar a tigela, aquecer a frigideira.  A CPU √© a parte mais r√°pida do computador e a E / S √© a parte que requer a espera com mais frequ√™ncia; portanto, √© bastante eficaz carregar a CPU com algum trabalho enquanto aguarda os dados da E / S. <br><br>  Para estender a met√°fora: <br><br><ul><li>  Se eu tamb√©m estivesse tentando trocar de roupa enquanto preparava o caf√© da manh√£, teria sido <b>multitarefa</b> .  Os computadores s√£o muito melhores nisso do que os humanos. </li><li>  Uma cozinha com v√°rios cozinheiros - por exemplo, em um restaurante - √© um computador com <b>v√°rios n√∫cleos</b> . </li><li>  Uma pra√ßa de alimenta√ß√£o de shopping com muitos restaurantes representaria um <b>data center</b> . </li></ul><br><br><a name="NetTools"></a><br><h3>  Ferramentas .NET </h3><br>  O .NET √© realmente bom quando se trata de trabalhar com threads - assim como em muitas outras coisas.  A cada nova vers√£o, ele fornece mais ferramentas para trabalhar com threads e novas camadas de abstra√ß√£o de threads do SO.  Ao trabalhar com abstra√ß√µes, os desenvolvedores que trabalham com a estrutura est√£o usando uma abordagem que lhes permite reduzir uma ou mais camadas enquanto usam abstra√ß√µes de alto n√≠vel.  Na maioria dos casos, n√£o h√° necessidade real de fazer isso (e isso pode introduzir a possibilidade de dar um tiro no p√©), mas √†s vezes essa √© a √∫nica maneira de resolver um problema que n√£o pode ser resolvido no n√≠vel de abstra√ß√£o atual. <br><br>  Quando eu disse as ferramentas anteriormente, quis dizer interfaces de programa (API) fornecidas pela estrutura ou pacotes de terceiros e solu√ß√µes de software completas que simplificam o processo de pesquisa de problemas relacionados ao c√≥digo multiencadeado. <br><br><a name="StartingAThread"></a><br><h4>  Iniciando um Thread </h4><br>  A classe Thread √© a classe .NET mais b√°sica para trabalhar com threads.  Seu construtor aceita um desses dois delegados: <br><br><ul><li>  ThreadStart - sem par√¢metros </li><li>  ParametrizedThreadStart - um par√¢metro do tipo de objeto. </li></ul><br><br>  O delegado ser√° executado em um thread rec√©m-criado depois de chamar o m√©todo Start.  Se o delegado ParametrizedThreadStart foi passado para o construtor, um objeto deve ser passado para o m√©todo Start.  Esse processo √© necess√°rio para passar qualquer informa√ß√£o local para o encadeamento.  Devo salientar que s√£o necess√°rios muitos recursos para criar um thread e o pr√≥prio thread √© um objeto pesado - pelo menos porque requer intera√ß√£o com a API do SO e 1 MB de mem√≥ria √© alocado para a pilha. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(...).Start(...);</code> </pre> <br>  A classe ThreadPool representa o conceito de um pool.  No .NET, o pool de threads √© uma obra de arte da engenharia e os desenvolvedores da Microsoft investiram muito esfor√ßo para faz√™-lo funcionar de maneira ideal em todos os tipos de cen√°rios. <br><br>  <b>O conceito geral:</b> <br>  <i>Quando iniciado, o aplicativo cria alguns threads em segundo plano, permitindo acess√°-los quando necess√°rio.</i>  <i>Se os threads forem usados ‚Äã‚Äãcom frequ√™ncia e em grandes n√∫meros, o pool ser√° expandido para satisfazer as necessidades do c√≥digo de chamada.</i>  <i>Se o pool n√£o tiver threads livres suficientes no momento certo, ele aguardar√° um dos threads ativos ficar desocupado ou criar√° um novo.</i>  <i>Com base nisso, o conjunto de encadeamentos √© perfeito para a√ß√µes curtas e n√£o funciona muito bem para processos que funcionam como servi√ßos por toda a dura√ß√£o da opera√ß√£o do aplicativo.</i> <br><br>  O m√©todo QueueUserWorkItem permite usar threads do pool.  Este m√©todo <i>utiliza o</i> delegado <i>WaitCallback</i> -type.  Sua assinatura coincide com a assinatura de ParametrizedThreadStart, e o par√¢metro que √© passado para ele tem a mesma fun√ß√£o. <br><br><pre> <code class="cs hljs">ThreadPool.QueueUserWorkItem(...);</code> </pre><br>  O m√©todo de pool de encadeamentos RegisterWaitForSingleObject menos conhecido √© usado para organizar opera√ß√µes de E / S sem bloqueio.  O delegado que √© passado para esse m√©todo ser√° chamado quando o WaitHandle for liberado ap√≥s ser passado para o m√©todo. <br><br><pre> <code class="cs hljs">ThreadPool.RegisterWaitForSingleObject(...)</code> </pre><br><br>  H√° um cron√¥metro de encadeamento no .NET e ele difere dos timers WinForms / WPF, pois seu manipulador √© chamado no encadeamento retirado do pool. <br><br><pre> <code class="cs hljs">System.Threading.Timer</code> </pre><br><br>  Tamb√©m h√° uma maneira bastante incomum de enviar o delegado para um thread do pool - o m√©todo BeginInvoke. <br><br><pre> <code class="cs hljs">DelegateInstance.BeginInvoke</code> </pre><br><br>  Eu tamb√©m gostaria de dar uma olhada na fun√ß√£o que muitos dos m√©todos que eu mencionei anteriormente se referem ao - CreateThread da API Win32 do Kernel32.dll.  Existe uma maneira de chamar essa fun√ß√£o com a ajuda do mecanismo externo dos m√©todos.  Eu s√≥ vi isso sendo usado uma vez em um caso particularmente ruim de c√≥digo legado - e ainda n√£o entendo quais foram as raz√µes de seu autor. <br><pre> <code class="cs hljs">Kernel32.dll CreateThread</code> </pre><br><br><a name="ViewingAndDebuggingThreads"></a><br><h4>  Visualizando e depurando threads </h4><br>  Todos os threads - criados por voc√™, componentes de terceiros ou o pool .NET - podem ser exibidos na janela <b>Threads</b> do Visual Studio.  Essa janela exibir√° apenas as informa√ß√µes sobre threads quando o aplicativo estiver sendo depurado no modo Break.  Aqui, voc√™ pode visualizar os nomes e prioridades de cada thread e focar o modo de depura√ß√£o em threads espec√≠ficos.  A propriedade Priority da classe Thread permite definir a prioridade do thread.  Essa prioridade ser√° levada em considera√ß√£o quando o SO e o CLR estiverem dividindo o tempo do processador entre os threads. <br><br><img src="https://habrastorage.org/webt/ow/kq/i5/owkqi5zdx2m8oe7iava3q1mikri.png"><br><br><a name="TaskParallelLibrary"></a><br><h4>  Biblioteca paralela de tarefas </h4><br>  A Biblioteca Paralela de Tarefas (TPL) apareceu pela primeira vez no .NET 4.0.  Atualmente, √© a principal ferramenta para trabalhar com assincronia.  Qualquer c√≥digo que utilize abordagens mais antigas ser√° considerado c√≥digo legado.  A unidade principal do TPL √© a classe <b>Task</b> do espa√ßo para nome System.Threading.Tasks.  As tarefas representam a abstra√ß√£o do encadeamento.  Com a vers√£o mais recente do C #, adquirimos uma nova maneira elegante de trabalhar com o Tasks - os operadores ass√≠ncronos / aguardados.  Isso permite que o c√≥digo ass√≠ncrono seja escrito como se fosse simples e s√≠ncrono, para que aqueles que n√£o s√£o bem versados ‚Äã‚Äãna teoria de threads agora possam escrever aplicativos que n√£o ter√£o dificuldades com opera√ß√µes longas.  O uso de ass√≠ncrono / espera √© realmente um t√≥pico para um artigo separado (ou mesmo alguns artigos), mas tentarei descrever o b√°sico em algumas frases: <br><br><ul><li>  async √© um modificador de um m√©todo que retorna uma tarefa ou anula </li><li>  waitit √© um operador de uma tarefa de espera sem bloqueio. </li></ul><br><br>  Mais uma vez: o operador aguardar normalmente (h√° exce√ß√µes) deixa o encadeamento atual e, quando a tarefa √© executada e o encadeamento (na verdade, o contexto, mas voltaremos a ele mais tarde) estar√° livre como um Como resultado, ele continuar√° executando o m√©todo.  No .NET, esse mecanismo √© implementado da mesma maneira que o retorno de rendimento - um m√©todo √© transformado em uma classe de m√°quina de estados finitos que pode ser executada em partes separadas com base em seu estado.  Se isso parecer interessante, eu recomendaria escrever qualquer trecho de c√≥digo simples baseado em ass√≠ncrono / aguardar, compilando-o e analisando sua compila√ß√£o com a ajuda do JetBrains dotPeek com o c√≥digo gerado pelo compilador ativado. <br><br>  Vejamos as op√ß√µes que temos quando se trata de iniciar e usar uma tarefa.  No exemplo abaixo, criamos uma nova tarefa que na verdade n√£o faz nada produtivo (Thread.Sleep (10000)).  No entanto, em casos reais, devemos substitu√≠-lo por algum trabalho complexo que utiliza recursos da CPU. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TCO = System.Threading.Tasks.TaskCreationOptions; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VoidAsyncMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cancellationSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CancellationTokenSource(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.StartNew( <span class="hljs-comment"><span class="hljs-comment">// Code of action will be executed on other context () =&gt; Thread.Sleep(10000), cancellationSource.Token, TCO.LongRunning | TCO.AttachedToParent | TCO.PreferFairness, scheduler ); // Code after await will be executed on captured context }</span></span></code> </pre><br><br>  Uma tarefa √© criada com as seguintes op√ß√µes: <br><br><ul><li>  LongRunning - essa op√ß√£o sugere o fato de que a tarefa n√£o pode ser executada rapidamente.  Portanto, √© possivelmente melhor criar um thread separado para esta tarefa, em vez de retirar um existente do pool para minimizar danos a outras tarefas. </li><li>  AttachedToParent - As tarefas podem ser organizadas hierarquicamente.  Se essa op√ß√£o for usada, a tarefa estar√° aguardando a execu√ß√£o de suas tarefas filhas ap√≥s a pr√≥pria execu√ß√£o. </li><li>  PreferFairness - esta op√ß√£o especifica que a tarefa deve ser melhor executada antes das tarefas que foram criadas posteriormente.  No entanto, √© mais uma sugest√£o, portanto o resultado nem sempre √© garantido. </li></ul><br><br>  O segundo par√¢metro que foi passado para o m√©todo √© CancellationToken.  Para que a opera√ß√£o seja cancelada corretamente depois de j√° ter sido iniciada, o c√≥digo execut√°vel deve conter as verifica√ß√µes de estado de CancellationToken.  Se n√£o houver essas verifica√ß√µes, o m√©todo Cancel chamado no objeto CancellationTokenSource s√≥ poder√° parar a execu√ß√£o da tarefa antes que a tarefa seja realmente iniciada. <br><br>  Para o √∫ltimo par√¢metro, enviamos um objeto do tipo TaskScheduler chamado scheduler.  Essa classe, juntamente com suas classes filho, √© usada para controlar como as tarefas s√£o distribu√≠das entre os threads.  Por padr√£o, uma tarefa ser√° executada em um encadeamento selecionado aleatoriamente do pool <br><br>  O operador de espera √© aplicado √† tarefa criada.  Isso significa que o c√≥digo escrito depois dele (se houver esse c√≥digo) ser√° executado no mesmo contexto (geralmente, isso significa 'no mesmo encadeamento') que o c√≥digo escrito antes o aguardar√°. <br><br>  Esse m√©todo √© identificado como vazio ass√≠ncrono, o que significa que o operador de espera pode ser usado nele, mas o c√≥digo de chamada n√£o poder√° aguardar a execu√ß√£o.  Se tal possibilidade for necess√°ria, o m√©todo deve retornar uma tarefa.  Os m√©todos rotulados como vazio ass√≠ncrono podem ser vistos com bastante frequ√™ncia: geralmente s√£o manipuladores de eventos ou outros m√©todos que operam sob o princ√≠pio de ignorar e esquecer.  Se for necess√°rio aguardar a conclus√£o da execu√ß√£o e retornar o resultado, voc√™ deve usar a Tarefa. <br><br>  Para tarefas que retornam o m√©todo StartNew, podemos chamar ConfigureAwait com o par√¢metro false - ent√£o, a execu√ß√£o ap√≥s aguardar continuar√° em um contexto aleat√≥rio em vez de capturado.  Isso sempre deve ser feito se o c√≥digo gravado ap√≥s aguardar n√£o exigir um contexto de execu√ß√£o espec√≠fico.  Essa tamb√©m √© uma recomenda√ß√£o da MS quando se trata de escrever c√≥digo fornecido como uma biblioteca. <br><br>  Vejamos como podemos esperar que uma tarefa seja conclu√≠da.  Abaixo, voc√™ pode ver um exemplo de c√≥digo com coment√°rios indicando quando a espera √© implementada de maneira relativamente boa ou ruim. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnotherMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> AsyncMethod(); <span class="hljs-comment"><span class="hljs-comment">// good result = AsyncMethod().Result; // bad AsyncMethod().Wait(); // bad IEnumerable&lt;Task&gt; tasks = new Task[] { AsyncMethod(), OtherAsyncMethod() }; await Task.WhenAll(tasks); // good await Task.WhenAny(tasks); // good Task.WaitAll(tasks.ToArray()); // bad }</span></span></code> </pre><br>  No primeiro exemplo, estamos aguardando a execu√ß√£o da tarefa sem bloquear o segmento de chamada, portanto, voltaremos a processar o resultado quando estiver pronto.  Antes que isso aconte√ßa, o encadeamento de chamada √© deixado sozinho. <br><br>  Na segunda tentativa, estamos bloqueando o encadeamento de chamada at√© que o resultado do m√©todo seja calculado.  Essa √© uma abordagem ruim por dois motivos.  Antes de tudo, estamos desperdi√ßando um encadeamento - um recurso muito valioso - na simples espera.  Al√©m disso, se o m√©todo que estamos chamando contiver um aguardar enquanto um retorno para o segmento de chamada depois de aguardar for planejado pelo contexto de sincroniza√ß√£o, obteremos um impasse.  Isso acontece porque o encadeamento de chamada estar√° aguardando o resultado de um m√©todo ass√≠ncrono, e o pr√≥prio m√©todo ass√≠ncrono tentar√° infrut√≠fera continuar sua execu√ß√£o no encadeamento de chamada. <br><br>  Outra desvantagem dessa abordagem √© o aumento da complexidade do tratamento de erros.  Na verdade, os erros podem ser tratados com bastante facilidade no c√≥digo ass√≠ncrono se for usado o ass√≠ncrono / espera - o processo nesse caso √© id√™ntico ao do c√≥digo s√≠ncrono.  No entanto, quando uma espera s√≠ncrona √© aplicada a uma tarefa, a exce√ß√£o inicial √© agrupada em AggregateException.  Em outras palavras, para lidar com a exce√ß√£o, precisar√≠amos explorar o tipo InnerException e escrever manualmente uma cadeia if em um bloco de captura ou, alternativamente, usar a captura quando a estrutura em vez da cadeia mais usual de blocos de captura. <br><br>  Os dois √∫ltimos exemplos tamb√©m s√£o rotulados como relativamente ruins pelos mesmos motivos e ambos cont√™m os mesmos problemas. <br><br>  Os m√©todos WhenAny e WhenAll s√£o muito √∫teis quando se trata de aguardar um grupo de tarefas - eles agrupam essas tarefas em uma e ser√£o executados quando uma tarefa do grupo for iniciada ou quando todas essas tarefas forem executadas com √™xito. <br><br><a name="StoppingThreads"></a><br><h4>  Parando Encadeamentos </h4><br>  Por v√°rios motivos, pode ser necess√°rio interromper um encadeamento depois que ele foi iniciado.  Existem algumas maneiras de fazer isso.  A classe Thread possui dois m√©todos com nomes apropriados - <b>Interromper</b> e <b>Interromper</b> .  Eu desencorajaria fortemente o uso do primeiro, pois, depois de chamado, haveria uma <b>ThreadAbortedException</b> lan√ßada a qualquer momento aleat√≥rio ao processar qualquer instru√ß√£o escolhida arbitrariamente.  Voc√™ n√£o espera que essa exce√ß√£o seja encontrada quando uma vari√°vel inteira for incrementada, certo?  Bem, ao usar o m√©todo Abort, isso se torna uma possibilidade real.  No caso de voc√™ precisar negar a capacidade do CLR de criar essas exce√ß√µes em uma parte espec√≠fica do c√≥digo, voc√™ pode <b>agrup√°-</b> lo no <b>Thread.InstititititRegion</b> e <b>Thread.EndCriticalRegion</b> .  Qualquer c√≥digo escrito no bloco final √© envolvido nessas chamadas.  √â por isso que voc√™ pode encontrar blocos com uma tentativa vazia e uma n√£o vazia finalmente nas profundezas do c√≥digo da estrutura.  A Microsoft n√£o gosta deste m√©todo na medida em que n√£o o inclui no n√∫cleo do .NET. <br><br>  O m√©todo <b>Interromper</b> funciona de uma maneira muito mais previs√≠vel.  Ele pode interromper um thread com uma <b>ThreadInterruptedException</b> apenas quando o thread estiver no modo de espera.  Ele se move para esse estado quando suspenso enquanto aguarda WaitHandle, um bloqueio ou ap√≥s o Thread.Sleep ser chamado. <br><br>  Ambas as formas t√™m uma desvantagem de imprevisibilidade.  Para escapar desse problema, devemos usar a estrutura <b>CancellationToken</b> e a classe <b>CancellationTokenSource</b> .  A ideia geral √© a seguinte: uma inst√¢ncia da classe CancellationTokenSource √© criada e somente aqueles que a possuem podem parar a opera√ß√£o chamando o m√©todo <b>Cancel</b> .  Somente CancellationToken √© passado para a opera√ß√£o.  Os propriet√°rios do CancelamentoToken n√£o podem cancelar a opera√ß√£o eles mesmos - eles podem apenas verificar se a opera√ß√£o foi cancelada.  Isso pode ser alcan√ßado usando a propriedade booleana <b>IsCancellationRequested</b> e o m√©todo <b>ThrowIfCancelRequested</b> .  O √∫ltimo gerar√° uma <b>TaskCancelledException</b> se o m√©todo Cancel tiver sido chamado na inst√¢ncia CancellationTokenSource que criou o CancellationToken.  Este √© o m√©todo que eu recomendo usar.  Sua vantagem sobre os m√©todos descritos anteriormente reside no fato de fornecer controle total sobre os casos de exce√ß√£o exata nos quais uma opera√ß√£o pode ser cancelada. <br><br>  A maneira mais brutal de interromper um thread seria chamar uma fun√ß√£o da API do Win32 chamada TerminateThread.  Depois que essa fun√ß√£o √© chamada, o comportamento do CLR pode ser bastante imprevis√≠vel.  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MSDN</a> , foi escrito o seguinte sobre esta fun√ß√£o: <i>‚ÄúTerminateThread √© uma fun√ß√£o perigosa que s√≥ deve ser usada nos casos mais extremos.</i>  <i>"</i> <br><br><a name="FromAsync"></a><br><h4>  Transformando uma API herdada em uma baseada em tarefas usando FromAsync </h4><br>  Se voc√™ teve a sorte de trabalhar em um projeto iniciado ap√≥s a introdu√ß√£o das Tarefas (e quando n√£o estiver mais provocando horror existencial na maioria dos desenvolvedores), n√£o precisar√° lidar com APIs antigas - ambas de terceiros. aqueles e aqueles em que sua equipe trabalhou no passado.  Felizmente, a equipe de desenvolvimento do .NET Framework tornou mais f√°cil para n√≥s - mas isso poderia ter sido um autocuidado, pelo que sabemos.  De qualquer forma, o .NET possui algumas ferramentas que ajudam a trazer o c√≥digo escrito com as abordagens antigas para assincronia, para um formul√°rio atualizado.  Um deles √© o m√©todo TaskFactory chamado FromAsync.  No exemplo abaixo, estou agrupando os m√©todos ass√≠ncronos antigos da classe WebRequest em uma tarefa usando FromAsync. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; WebRequest wr = WebRequest.CreateHttp(<span class="hljs-string"><span class="hljs-string">"http://github.com"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.Factory.FromAsync( wr.BeginGetResponse, we.EndGetResponse );</code> </pre><br>  <i>√â apenas um exemplo, e voc√™ provavelmente n√£o far√° algo desse tipo com os tipos internos.</i>  <i>No entanto, projetos antigos est√£o repletos de m√©todos BeginDoSomething que retornam os m√©todos IAsyncResult e EndDoSomething que os recebem.</i> <br><br><a name="TaskCompletionSource"></a><br><h4>  Transformando uma API herdada em uma baseada em tarefas usando TaskCompletionSource </h4><br>  Outra ferramenta que vale a pena explorar √© a classe <b>TaskCompletionSource</b> .  Em sua funcionalidade, objetivo e princ√≠pio de opera√ß√£o, ele se parece com o m√©todo RegisterWaitForSingleObject da classe ThreadPool que eu mencionei anteriormente.  Essa classe nos permite envolver facilmente APIs ass√≠ncronas antigas em Tarefas. <br><br>  <i>Voc√™ pode dizer que eu j√° falei sobre o m√©todo FromAsync da classe TaskFactory, que serviu a esses prop√≥sitos.</i>  <i>Aqui, precisamos lembrar o hist√≥rico completo dos modelos ass√≠ncronos que a Microsoft forneceu nos √∫ltimos 15 anos: antes dos padr√µes ass√≠ncronos baseados em tarefas (TAP), havia padr√µes de programa√ß√£o ass√≠ncrona (APP).</i>  <i>Os aplicativos eram sobre <b>Begin</b> DoSomething retornando IAsyncResult e o m√©todo <b>End</b> DoSomething que o aceita - e o m√©todo FromAsync √© perfeito para o legado desses anos.</i>  <i>No entanto, com o passar do tempo, isso foi substitu√≠do pelo EAP (Event Based Asynchronous Patterns), que especificava que um evento √© chamado quando uma opera√ß√£o ass√≠ncrona √© executada com √™xito.</i> <br><br>  TaskCompletionSource s√£o perfeitos para agrupar APIs herdadas criadas em torno do modelo de evento nas Tarefas.  √â assim que funciona: os objetos dessa classe t√™m uma propriedade p√∫blica chamada Task, cujo estado pode ser controlado por v√°rios m√©todos da classe TaskCompletionSource (SetResult, SetException etc.).  Nos locais em que o operador de espera foi aplicado a esta tarefa, ele ser√° executado ou travado com uma exce√ß√£o, dependendo do m√©todo aplicado ao TaskCompletionSource.  Para entender melhor, vejamos este exemplo de c√≥digo.  Aqui, alguma API antiga da era EAP √© agrupada em uma tarefa com a ajuda de TaskCompletionSource: quando um evento √© acionado, a tarefa ser√° alternada para o estado Conclu√≠do enquanto o m√©todo que aplicou o operador de espera a esta tarefa continuar√° sua execu√ß√£o. depois de receber um objeto de <b>resultado</b> . <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;Result&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> SomeApiInstance someApiObj</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Result&gt;(); someApiObj.Done += result =&gt; completionSource.SetResult(result); someApiObj.Do(); result completionSource.Task; }</code> </pre><br><a name="TaskCompletionSourceTips"></a><br><h4>  Dicas e truques para fonte de tarefas </h4><br>  TaskCompletionSource pode fazer mais do que apenas agrupar APIs obsoletas.  Essa classe abre uma possibilidade interessante de criar v√°rias APIs baseadas em tarefas que n√£o ocupam threads.  Um thread, como lembramos, √© um recurso caro, limitado principalmente pela RAM.  Podemos facilmente atingir esse limite ao desenvolver um aplicativo Web robusto com l√≥gica de neg√≥cios complexa.  Vejamos os recursos que mencionei em a√ß√£o, implementando um truque conhecido como Long Polling. <br><br>  <b>Em resumo, √© assim que o Long Polling funciona:</b> <br>  <i>Voc√™ precisa obter algumas informa√ß√µes de uma API sobre eventos que ocorrem do seu lado, mas a API, por algum motivo, pode retornar apenas um estado em vez de informar sobre o evento.</i>  <i>Um exemplo disso seria qualquer API criada sobre HTTP antes do WebSocket aparecer ou em circunst√¢ncias nas quais essa tecnologia n√£o pode ser usada.</i>  <i>O cliente pode perguntar ao servidor HTTP.</i>  <i>O servidor HTTP, por outro lado, n√£o pode iniciar o contato com o cliente sozinho.</i>  <i>A solu√ß√£o mais simples seria solicitar ao servidor periodicamente usando um timer, mas isso criaria carga adicional para o servidor e um atraso geral que √© aproximadamente igual a TimerInterval / 2. Para contornar isso, a Pesquisa Longa foi inventada.</i>  <i>Isso implica em atrasar a resposta do servidor at√© o tempo limite expirar ou ocorrer um evento.</i>  <i>Se um evento ocorrer, ele ser√° tratado;</i>  <i>caso contr√°rio - o pedido ser√° enviado novamente.</i> <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!eventOccures &amp;&amp; !timeoutExceeded) { CheckTimout(); CheckEvent(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  No entanto, a efic√°cia dessa solu√ß√£o diminuir√° radicalmente se o n√∫mero de clientes aguardando o evento aumentar - cada cliente em espera ocupa um encadeamento completo.  Al√©m disso, temos um atraso adicional de 1ms para o acionamento do evento.  Frequentemente, n√£o √© realmente t√£o crucial, mas por que tornamos nosso software pior do que poderia ser?  Por outro lado, se removermos o Thread.Sleep (1), um dos n√∫cleos da CPU ser√° carregado por 100%, sem fazer nada em um ciclo in√∫til.  Com a ajuda do TaskCompletionSource, podemos transformar facilmente nosso c√≥digo para resolver todos os problemas mencionados: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LongPollingApi</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, TaskCompletionSource&lt;Msg&gt;&gt; tasks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Msg&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptMessageAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> duration</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TaskCompletionSource&lt;Msg&gt;(); tasks[userId] = cs; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Task.WhenAny(Task.Delay(duration), cs.Task); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cs.Task.IsCompleted ? cs.Task.Result : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> userId, Msg m</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tasks.TryGetValue(userId, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> completionSource)) completionSource.SetResult(m); } }</code> </pre><br>  <i>Lembre-se de que esse trecho de c√≥digo √© apenas um exemplo e de forma alguma pronto para produ√ß√£o.</i>  <i>Para us√°-lo em casos reais, precisar√≠amos pelo menos adicionar uma maneira de lidar com situa√ß√µes nas quais uma mensagem √© recebida quando nada estava esperando por ela: nesse caso, o m√©todo AcceptMessageAsync deve retornar uma tarefa j√° conclu√≠da.</i>  <i>Se esse for o caso mais comum, podemos considerar o uso da ValueTask.</i> <br><br>  Ao receber uma solicita√ß√£o de mensagem, criamos um TaskCompletionSource, colocamos em um dicion√°rio e aguardamos um dos seguintes eventos: o intervalo de tempo especificado √© gasto ou a mensagem √© recebida. <br><br><a name="ValueTask"></a><br><h4>  ValueTask: Por que e como </h4><br>  Os operadores async / waitit, assim como o operador de retorno de rendimento, geram uma m√°quina de estados finitos a partir de um m√©todo, o que significa criar um novo objeto - isso n√£o importa muito na maioria das vezes, mas ainda pode criar problemas em alguns casos raros.  Um desses casos pode ocorrer com os m√©todos chamados com freq√º√™ncia - estamos falando de dezenas e centenas de milhares de chamadas por segundo.  Se esse m√©todo √© escrito de uma maneira que faz com que ele retorne o resultado, ignorando todos os m√©todos de espera na maioria dos casos, o .NET fornece uma ferramenta de otimiza√ß√£o para isso - a estrutura ValueTask.  Para entender como funciona, vejamos um exemplo.  Suponha que exista um cache que acessamos regularmente.  Se houver algum valor, basta devolv√™-lo;  se n√£o houver valores - tentamos obt√™-los de algumas E / S lentas.  Idealmente, o √∫ltimo deve ser feito de forma ass√≠ncrona, para que todo o m√©todo seja ass√≠ncrono.  Portanto, a maneira mais √≥bvia de implementar esse m√©todo ser√° a seguinte: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> RequestById(id); }</code> </pre><br>  Com o desejo de otimiz√°-lo um pouco e uma preocupa√ß√£o com o que Roslyn gerar√° ao compilar esse c√≥digo, poder√≠amos reescrever o m√©todo assim: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RequestById(id); }</code> </pre><br>  No entanto, a melhor solu√ß√£o nesse caso seria otimizar o atalho - especificamente, obtendo valores de dicion√°rio sem aloca√ß√µes desnecess√°rias e sem carga no GC.  Enquanto isso, nos casos pouco frequentes em que precisamos obter dados de E / S, as coisas permanecer√£o quase as mesmas: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ValueTask&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetById</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache.TryGetValue(id, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> val)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ValueTask&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(RequestById(id)); }</code> </pre><br>  Vamos olhar mais de perto esse fragmento de c√≥digo: se um valor estiver presente no cache, criaremos uma estrutura;  caso contr√°rio, a tarefa real ser√° agrupada em uma ValueTask.  O caminho pelo qual esse c√≥digo √© executado n√£o √© importante para o c√≥digo de chamada: da perspectiva da sintaxe C #, uma ValueTask se comportar√° como uma Tarefa usual. <br><br><a name="TaskScheduler"></a><br><h4>  TaskScheduler: Controlando estrat√©gias de execu√ß√£o de tarefas </h4><br>  A pr√≥xima API da qual gostaria de falar √© a classe <b>TaskScheduler</b> e as derivadas dela.  Eu j√° mencionei que o TPL fornece a capacidade de controlar como exatamente as tarefas est√£o sendo distribu√≠das entre os threads.  Essas estrat√©gias s√£o definidas nas classes herdadas do TaskScheduler.  Quase qualquer estrat√©gia que possamos precisar pode ser encontrada na biblioteca <b>ParallelExtensionsExtras</b> .  Esta biblioteca √© desenvolvida pela Microsoft, mas n√£o faz parte do .NET. Em vez disso, √© distribu√≠da como um pacote Nuget.  Vamos dar uma olhada em algumas das estrat√©gias: <br><br><ul><li>  CurrentThreadTaskScheduler - executa tarefas no thread atual </li><li>  LimitedConcurrencyLevelTaskScheduler - limita o n√∫mero de tarefas executadas simultaneamente usando o par√¢metro N que ele aceita no construtor </li><li>  OrderedTaskScheduler - √© definido como LimitedConcurrencyLevelTaskScheduler (1), para que as tarefas sejam executadas seq√ºencialmente. </li><li>  WorkStealingTaskScheduler - implementa a abordagem de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">roubo</a> de trabalho para execu√ß√£o de tarefas.  Essencialmente, ele pode ser visto como um ThreadPool separado.  Isso ajuda a quest√£o de o ThreadPool ser uma classe est√°tica no .NET - se for sobrecarregado ou usado incorretamente em uma parte do aplicativo, efeitos colaterais desagrad√°veis ‚Äã‚Äãpodem ocorrer em um local diferente.  As causas reais desses defeitos podem ser dif√≠ceis de localizar, portanto, pode ser necess√°rio usar WorkStealingTaskSchedulers separados nas partes do aplicativo em que o uso do ThreadPool pode ser agressivo e imprevis√≠vel. </li><li>  QueuedTaskScheduler - permite executar tarefas com base em uma fila priorizada </li><li>  ThreadPerTaskScheduler - cria um thread separado para cada tarefa executada nele.  Isso pode ser √∫til para tarefas cujo tempo de execu√ß√£o n√£o pode ser estimado. </li></ul><br>  H√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> muito bom sobre os TaskSchedulers no blog da Microsoft, portanto, fique √† vontade para conferir. <br><br>  No Visual Studio, h√° uma janela Tarefas que pode ajudar na depura√ß√£o de tudo relacionado a Tarefas.  Nesta janela, voc√™ pode ver o estado da tarefa e pular para a linha de c√≥digo atualmente executada. <br><br><img src="https://habrastorage.org/webt/tb/fv/3l/tbfv3l-sdz-jw0mpcakbt_-lve8.png"><br><a name="PLinq"></a><br><h4>  PLinq e a classe paralela </h4><br>  Al√©m de Tarefas e tudo relacionado a elas, existem duas ferramentas adicionais no .NET que podemos achar interessantes - <b>PLinq</b> (Linq2Parallel) e a classe <b>Parallel</b> .  O primeiro promete execu√ß√£o paralela de todas as opera√ß√µes do Linq em todos os threads.  O n√∫mero de threads pode ser configurado por um m√©todo de extens√£o WithDegreeOfParallelism.  Infelizmente, na maioria dos casos, o PLinq no modo padr√£o n√£o ter√° informa√ß√µes suficientes sobre a fonte de dados para fornecer um aumento significativo na velocidade.  Por outro lado, o custo da tentativa √© muito baixo: voc√™ s√≥ precisa chamar <b>AsParallel</b> antes da cadeia de m√©todos do Linq e executar testes de desempenho.  Al√©m disso, voc√™ pode passar informa√ß√µes adicionais sobre a natureza da sua fonte de dados para o PLinq usando o mecanismo Partitions.  Voc√™ pode encontrar mais informa√ß√µes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . <br><br>  A classe est√°tica Parallel fornece m√©todos para enumerar cole√ß√µes em paralelo via Foreach, executando o ciclo For e executando v√°rios delegados em paralelo a Invoke.  A execu√ß√£o do encadeamento atual ser√° interrompida at√© que os resultados sejam calculados.  Voc√™ pode configurar o n√∫mero de threads passando ParallelOptions como o √∫ltimo argumento.  TaskScheduler e CancellationToken tamb√©m podem ser configurados com a ajuda de op√ß√µes. <br><br><a name="Summary"></a><br><h3>  Sum√°rio </h3><br>  Quando comecei a escrever este artigo com base na minha tese e no conhecimento que adquiri ao trabalhar depois, n√£o achei que houvesse tanta informa√ß√£o.  Agora, com o editor de texto me dizendo reprovadoramente que escrevi quase 15 p√°ginas, gostaria de tirar uma conclus√£o intermedi√°ria.  Veremos outras t√©cnicas, APIs, ferramentas visuais e riscos ocultos no pr√≥ximo artigo. <br><br>  <b>Conclus√µes:</b> <br><br><ul><li>  Para usar efetivamente os recursos dos PCs modernos, voc√™ precisa conhecer ferramentas para trabalhar com threads, assincronia e paralelismo. </li><li>  Existem muitas ferramentas como esta no .NET </li><li>  Nem todos eles foram criados ao mesmo tempo; portanto, √© poss√≠vel que voc√™ encontre frequentemente algum c√≥digo legado - mas h√° maneiras de transformar APIs antigas com pouco esfor√ßo. </li><li>  No .NET, as classes Thread e ThreadPool s√£o usadas para trabalhar com threads </li><li>  O m√©todo Thread.Abort e Thread.Interrupt, juntamente com a fun√ß√£o de API do Win32 TerminateThread, s√£o perigosos e n√£o s√£o recomendados para uso.  Em vez disso, √© melhor usar CancellationTokens </li><li>  Threads s√£o um recurso valioso e seu n√∫mero √© limitado.  Voc√™ deve evitar os casos em que os segmentos est√£o ocupados aguardando eventos.  A classe TaskCompletionSource pode ajudar a conseguir isso. </li><li>  As tarefas s√£o a ferramenta mais poderosa e robusta que o .NET possui para trabalhar com paralelismo e assincronia. </li><li>  Os operadores C # ass√≠ncronos / esperados implementam o conceito de uma espera sem bloqueio </li><li>  Voc√™ pode controlar como as tarefas s√£o distribu√≠das entre os threads com a ajuda de classes derivadas do TaskScheduler </li><li>  A estrutura ValueTask pode ser usada para otimizar atalhos e tr√°fego de mem√≥ria </li><li>  As janelas Tarefas e Threads no Visual Studio fornecem muitas informa√ß√µes √∫teis para depurar c√≥digo ass√≠ncrono ou multithread </li><li>  O PLinq √© uma ferramenta incr√≠vel, mas pode n√£o ter todas as informa√ß√µes necess√°rias sobre sua fonte de dados - que ainda podem ser corrigidas com o mecanismo de particionamento </li></ul><br>  <i>Para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">continuar</a> ...</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455252/">https://habr.com/ru/post/pt455252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455240/index.html">Usando a taxa de defeitos rejeitados para melhorar o relat√≥rio de erros</a></li>
<li><a href="../pt455244/index.html">Hist√≥ria em quadrinhos "A soldagem √© f√°cil" na vers√£o atualizada (2019)</a></li>
<li><a href="../pt455246/index.html">As inscri√ß√µes para o Customer Experience Day em S√£o Petersburgo est√£o abertas em 20 de junho</a></li>
<li><a href="../pt455248/index.html">Principais erros de desenvolvimento ao trabalhar com o PostgreSQL</a></li>
<li><a href="../pt455250/index.html">Aquele que ressuscitou Duke Nukem: entrevista com Randy Pitchford, m√°gico da Gearbox</a></li>
<li><a href="../pt455256/index.html">Habr Weekly # 4 / Computex, como beta da Apple, Durov est√° morrendo de fome, gato BadComedian, por que a rede neural procurou atores pornogr√°ficos</a></li>
<li><a href="../pt455258/index.html">Come√ßou a vota√ß√£o dos relat√≥rios da se√ß√£o Backend no anivers√°rio do DevConfX, que ser√° realizada de 21 a 22 de junho em Moscou</a></li>
<li><a href="../pt455260/index.html">√Årvore Merkle: enferrujado e r√°pido</a></li>
<li><a href="../pt455264/index.html">Seja como Munch, ou algumas palavras sobre dever t√©cnico</a></li>
<li><a href="../pt455268/index.html">Como tudo come√ßou: displays flex√≠veis e dobr√°veis ‚Äã‚Äã- a hist√≥ria da apar√™ncia e sa√≠da de "pessoas"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>