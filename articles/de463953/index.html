<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👉🏾 📅 🤧 Implementieren des Befehlsentwurfsmusters in Unity 👩🏻‍⚖️ 🏂🏻 📋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie sich jemals gefragt, wie in Spielen wie Super Meat Boy die Wiedergabefunktion implementiert ist? Eine Möglichkeit, dies zu implementieren, b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementieren des Befehlsentwurfsmusters in Unity</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463953/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fef/cfb/edf/fefcfbedf0b2e0711f2e831b0d069ebf.gif" alt="Bild"></div><br>  Haben Sie sich jemals gefragt, wie in Spielen wie <i>Super Meat Boy</i> die Wiedergabefunktion implementiert ist?  Eine Möglichkeit, dies zu implementieren, besteht darin, die Eingabe auf die gleiche Weise wie der Player auszuführen, was wiederum bedeutet, dass die Eingabe irgendwie gespeichert werden muss.  Sie können <em>das Befehlsmuster</em> für dieses und vieles mehr verwenden. <br><br>  Die Befehlsvorlage ist auch nützlich, um Rückgängig- und Wiederherstellungsfunktionen in einem Strategiespiel zu erstellen. <br><br>  In diesem Tutorial implementieren wir die Befehlsvorlage in C # und führen damit den Bot-Charakter durch ein dreidimensionales Labyrinth.  Aus dem Tutorial lernen Sie: <br><br><ul><li>  Die Grundlagen des Befehlsmusters. </li><li>  So implementieren Sie das Befehlsmuster </li><li>  So erstellen Sie eine Warteschlange mit Eingabebefehlen und verzögern deren Ausführung. </li></ul><a name="habracut"></a><br><blockquote>  <em>Hinweis</em> : Es wird davon ausgegangen, dass Sie bereits mit Unity vertraut sind und über durchschnittliche Kenntnisse in C # verfügen.  In diesem Tutorial werden wir mit <em>Unity 2019.1</em> und <em>C # 7 arbeiten</em> . </blockquote><br><h2>  An die Arbeit gehen </h2><br>  Laden Sie zunächst die <a href="">Projektmaterialien</a> herunter.  Entpacken Sie die Datei und öffnen Sie das <em>Starter-</em> Projekt in Unity. <br><br>  Gehen Sie zu <em>RW / Szenen</em> und öffnen Sie die Hauptszene.  Die Szene besteht aus einem Bot und einem Labyrinth sowie einer Terminal-Benutzeroberfläche, die Anweisungen anzeigt.  Das Level-Design wird in Form eines Gitters erstellt, was nützlich ist, wenn wir den Bot visuell durch das Labyrinth bewegen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53b/ab9/660/53bab9660bdd0a5017b570d43a57b2d9.png"></div><br>  Wenn Sie auf <em>Wiedergabe</em> klicken, werden wir feststellen, dass die Anweisungen nicht funktionieren.  Dies ist normal, da wir diese Funktionalität zum Lernprogramm hinzufügen. <br><br>  Der interessanteste Teil der Szene ist der GameObject <em>Bot</em> .  Wählen Sie es im Hierarchiefenster aus, indem Sie darauf klicken. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/187/35e/acf/18735eacfd1f8df8920749ea80a12b8f.png"></div><br>  Im Inspektor können Sie sehen, dass es eine <em>Bot-</em> Komponente gibt.  Wir werden diese Komponente verwenden, indem wir Eingabebefehle ausgeben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a5/2e3/2bc/2a52e32bc7feb6baafae6af958cc4910.png"></div><br><h2>  Wir verstehen die Logik des Bots </h2><br>  Gehen Sie zu <em>RW / Scripts</em> und öffnen Sie das <em>Bot-</em> Skript im Code-Editor.  Sie müssen nicht wissen, was im <em>Bot-</em> Skript passiert.  Schauen Sie sich jedoch zwei Methoden an: <code>Move</code> und <code>Shoot</code> .  Auch hier müssen Sie nicht herausfinden, was in diesen Methoden vor sich geht, aber Sie müssen verstehen, wie Sie sie verwenden. <br><br>  Beachten Sie, dass die <code>Move</code> Methode einen Eingabeparameter <code>CardinalDirection</code> empfängt.  <code>CardinalDirection</code> ist eine Aufzählung.  Ein Aufzählungselement vom Typ <code>CardinalDirection</code> kann <code>Up</code> , <code>Down</code> , <code>Right</code> oder <code>Left</code> .  Abhängig von der ausgewählten <code>CardinalDirection</code> bewegt sich <code>CardinalDirection</code> Bot genau ein Quadrat entlang des Gitters in die entsprechende Richtung. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02c/72e/8ca/02c72e8ca19f987e6e36774558242058.png"></div><br>  Die <code>Shoot</code> Methode zwingt den Bot, Granaten abzufeuern, die die <em>gelben Wände</em> zerstören, aber gegen andere Wände unbrauchbar sind. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b34/f18/2bb/b34f182bb9c0bb682606d0c5a1beb0fd.gif"></div><br>  Schauen Sie sich <code>ResetToLastCheckpoint</code> die <code>ResetToLastCheckpoint</code> Methode an.  Um zu verstehen, was er tut, schauen Sie sich das Labyrinth an.  Im Labyrinth befinden sich Punkte, die als <em>Checkpoint bezeichnet werden</em> .  Um das Labyrinth zu passieren, muss der Bot zum <em>grünen</em> Kontrollpunkt gelangen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e4c/d3b/fc9/e4cd3bfc9d59944e28d9a22206141888.png"></div><br>  Wenn ein Bot einen neuen Kontrollpunkt betritt, wird dies der <em>letzte</em> für ihn.  <code>ResetToLastCheckpoint</code> setzt die Position des Bots zurück und verschiebt ihn zum letzten Kontrollpunkt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/829/617/95a/82961795afe53c9b45f1f8037896783c.gif"></div><br>  Obwohl wir diese Methoden nicht verwenden können, werden wir sie bald beheben.  Um zu beginnen, müssen Sie sich mit dem Entwurfsmuster des <em>Befehls</em> vertraut machen. <br><br><h2>  Was ist das Befehlsentwurfsmuster? </h2><br>  Das Befehlsmuster ist eines von 23 Entwurfsmustern, die im Buch <i>Entwurfsmuster: Elemente wiederverwendbarer objektorientierter Software beschrieben sind,</i> das von der „Viererbande“ von Erich Gamma, Richard Helm, Ralph Johnson und John Vlissides ( <em>GoF</em> , Viererbande) geschrieben wurde. <br><br>  Die Autoren berichten, dass "das Befehlsmuster die Anforderung als Objekt kapselt, sodass wir andere Objekte mit anderen Anforderungen, Warteschlangen- oder Protokollanforderungen parametrisieren und umkehrbare Operationen unterstützen können." <br><br>  Wow!  Es ist wie? <br><br>  Ich verstehe, dass diese Definition nicht sehr einfach ist, also lassen Sie uns sie analysieren. <br><br>  <em>Kapselung</em> bedeutet, dass ein Methodenaufruf als Objekt gekapselt werden kann. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07d/5c3/214/07d5c32142de4fd36bd2cd73c543856a.png" width="50%" height="50%"></div><br>  Die gekapselte Methode kann abhängig vom Eingabeparameter viele Objekte beeinflussen.  Dies wird als <em>Parametrisierung</em> anderer Objekte bezeichnet. <br><br>  Der resultierende „Befehl“ kann zusammen mit anderen Teams gespeichert werden, bis sie ausgeführt werden.  Dies ist die Anforderungswarteschlange. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/035/637/264/0356372640076e0829d2a427cf3552f1.png" width="50%" height="50%"></div><br>  <i>Team-Warteschlange</i> <br><br>  <em>Umkehrbarkeit</em> bedeutet schließlich, dass Vorgänge mit der Rückgängig-Funktion zurückgesetzt werden können. <br><br>  OK, aber wie spiegelt sich das im Code wider? <br><br>  Die <em>Command-</em> Klasse verfügt über eine <em>Execute-</em> Methode, die als Eingabeparameter das Objekt (von dem der Befehl ausgeführt wird) namens <em>Receiver</em> empfängt.  Das heißt, die Execute-Methode wird tatsächlich von der Command-Klasse <em>gekapselt</em> . <br><br>  Viele Instanzen der Command-Klasse können als normale Objekte übergeben werden, dh sie können in Datenstrukturen wie einer Warteschlange, einem Stapel usw. gespeichert werden. <br><br>  Um einen Befehl auszuführen, müssen Sie seine Execute-Methode aufrufen.  Die Klasse, die die Ausführung startet, heißt <em>Invoker</em> . <br><br>  Das Projekt enthält derzeit eine leere Klasse namens <code>BotCommand</code> .  Im nächsten Abschnitt werden wir die Implementierung des oben genannten implementieren, damit der Bot Aktionen mithilfe der Befehlsvorlage ausführen kann. <br><br><h2>  Bewegen Sie den Bot </h2><br><h3>  Implementierung des Befehlsmusters </h3><br>  In diesem Abschnitt implementieren wir das Befehlsmuster.  Es gibt viele Möglichkeiten, dies zu implementieren.  In diesem Tutorial werden wir einen von ihnen behandeln. <br><br>  Gehen Sie zunächst zu <em>RW / Scripts</em> und öffnen Sie das <em>BotCommand-</em> Skript im Editor.  Die <code>BotCommand</code> Klasse <code>BotCommand</code> noch leer, aber nicht lange. <br><br>  Fügen Sie den folgenden Code in die Klasse ein: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private readonly string commandName; //2 public BotCommand(ExecuteCallback executeMethod, string name) { Execute = executeMethod; commandName = name; } //3 public delegate void ExecuteCallback(Bot bot); //4 public ExecuteCallback Execute { get; private set; } //5 public override string ToString() { return commandName; }</span></span></code> </pre> <br>  Was ist hier los? <br><br><ol><li>  Die Variable <code>commandName</code> einfach zum Speichern des für Menschen lesbaren Befehlsnamens verwendet.  Es ist nicht erforderlich, es in der Vorlage zu verwenden, aber wir werden es später im Tutorial benötigen. </li><li>  Der Konstruktor von <code>BotCommand</code> erhält eine Funktion und eine Zeichenfolge.  Dies hilft uns beim Einrichten der <code>Execute</code> Methode des Command-Objekts und seines <code>name</code> . </li><li>  Der <code>ExecuteCallback</code> Delegat definiert den Typ der gekapselten Methode.  Die gekapselte Methode gibt void zurück und akzeptiert als Eingabeparameter ein Objekt vom Typ <code>Bot</code> (Komponente <em>Bot</em> ). </li><li>  Die <code>Execute</code> Eigenschaft bezieht sich auf die gekapselte Methode.  Wir werden es verwenden, um die gekapselte Methode aufzurufen. </li><li>  Die <code>ToString</code> Methode wird überschrieben, um die Zeichenfolge <code>commandName</code> .  Dies ist beispielsweise für die Verwendung in der Benutzeroberfläche praktisch. </li></ol><br>  Speichern Sie die Änderungen und das wars!  Wir haben das Befehlsmuster erfolgreich implementiert. <br><br>  Es bleibt zu benutzen. <br><br><h3>  Teambuilding </h3><br>  Öffnen Sie den <em>BotInputHandler</em> im Ordner <em>RW / Scripts</em> . <br><br>  Hier erstellen wir fünf Instanzen von <code>BotCommand</code> .  Diese Instanzen enthalten Methoden zum Verschieben des GameObject-Bot nach oben, unten, links und rechts sowie zum Schießen. <br><br>  Um dies zu implementieren, fügen Sie Folgendes in diese Klasse ein: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private static readonly BotCommand MoveUp = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Up); }, "moveUp"); //2 private static readonly BotCommand MoveDown = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Down); }, "moveDown"); //3 private static readonly BotCommand MoveLeft = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Left); }, "moveLeft"); //4 private static readonly BotCommand MoveRight = new BotCommand(delegate (Bot bot) { bot.Move(CardinalDirection.Right); }, "moveRight"); //5 private static readonly BotCommand Shoot = new BotCommand(delegate (Bot bot) { bot.Shoot(); }, "shoot");</span></span></code> </pre> <br>  In jedem dieser Fälle wird <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">eine anonyme Methode</a> an den Konstruktor übergeben.  Diese anonyme Methode wird in das entsprechende Befehlsobjekt eingekapselt.  Wie Sie sehen, erfüllt die Signatur jeder der anonymen Methoden die vom <code>ExecuteCallback</code> Delegaten angegebenen Anforderungen. <br><br>  Darüber hinaus ist der zweite Parameter für den Konstruktor eine Zeichenfolge, die den Namen des Befehls angibt.  Dieser Name wird von der <code>ToString</code> Methode der Befehlsinstanz zurückgegeben.  Später werden wir es für die Benutzeroberfläche anwenden. <br><br>  In den ersten vier Fällen rufen anonyme Methoden die <code>Move</code> Methode für das <code>bot</code> Objekt auf.  Ihre Eingabeparameter sind jedoch unterschiedlich. <br><br>  Die <code>MoveUp</code> , <code>MoveDown</code> , <code>MoveLeft</code> und <code>MoveRight</code> übergeben die <code>Move</code> Parameter <code>CardinalDirection.Up</code> , <code>CardinalDirection.Down</code> , <code>CardinalDirection.Left</code> und <code>CardinalDirection.Right</code> .  Wie im Abschnitt <i>Was ist</i> das Befehlsentwurfsmuster erwähnt, geben sie verschiedene Richtungen an, in die sich der GameObject-Bot bewegen soll. <br><br>  In der fünften Instanz ruft die anonyme Methode die <code>Shoot</code> Methode für das <code>bot</code> Objekt auf.  Dank dessen feuert der Bot während der Ausführung des Befehls eine Shell ab. <br><br>  Nachdem wir die Befehle erstellt haben, müssen wir irgendwie darauf zugreifen, wenn der Benutzer eine Eingabe vornimmt. <br><br>  <code>BotInputHandler</code> unmittelbar nach den Befehlsinstanzen <code>BotInputHandler</code> folgenden Code in den <code>BotInputHandler</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> BotCommand </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.W)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveUp; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.S)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveDown; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.D)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveRight; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.A)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MoveLeft; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.F)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Shoot; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Die <code>HandleInput</code> Methode gibt abhängig von der vom Benutzer gedrückten Taste eine Instanz des Befehls zurück.  Speichern Sie Ihre Änderungen, bevor Sie fortfahren. <br><br><h3>  Befehle anwenden </h3><br>  Großartig, jetzt ist es Zeit, die von uns erstellten Teams einzusetzen.  Gehen Sie erneut zu <em>RW / Scripts</em> und öffnen Sie das <em>SceneManager-</em> Skript im Editor.  In dieser Klasse sehen Sie einen Link zu einer <code>uiManager</code> Variablen vom Typ <code>UIManager</code> . <br><br>  Die <code>UIManager</code> Klasse bietet nützliche <code>UIManager</code> für die <em>Terminal-Benutzeroberfläche</em> , die wir in dieser Szene verwenden.  Wenn die Methode von <code>UIManager</code> verwendet wird, wird im Lernprogramm erläutert, was sie tut. Für unsere Zwecke ist es jedoch im Allgemeinen nicht erforderlich, die interne Struktur zu kennen. <br><br>  Darüber hinaus bezieht sich die <code>bot</code> Variable auf die Bot-Komponente, die an den GameObject- <em>Bot</em> angehängt ist. <br><br>  <code>SceneManager</code> Sie nun der <code>SceneManager</code> Klasse den folgenden Code <code>SceneManager</code> und ersetzen Sie ihn durch Kommentar <code>//1</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//1 private List&lt;BotCommand&gt; botCommands = new List&lt;BotCommand&gt;(); private Coroutine executeRoutine; //2 private void Update() { if (Input.GetKeyDown(KeyCode.Return)) { ExecuteCommands(); } else { CheckForBotCommands(); } } //3 private void CheckForBotCommands() { var botCommand = BotInputHandler.HandleInput(); if (botCommand != null &amp;&amp; executeRoutine == null) { AddToCommands(botCommand); } } //4 private void AddToCommands(BotCommand botCommand) { botCommands.Add(botCommand); //5 uiManager.InsertNewText(botCommand.ToString()); } //6 private void ExecuteCommands() { if (executeRoutine != null) { return; } executeRoutine = StartCoroutine(ExecuteCommandsRoutine()); } private IEnumerator ExecuteCommandsRoutine() { Debug.Log("Executing..."); //7 uiManager.ResetScrollToTop(); //8 for (int i = 0, count = botCommands.Count; i &lt; count; i++) { var command = botCommands[i]; command.Execute(bot); //9 uiManager.RemoveFirstTextLine(); yield return new WaitForSeconds(CommandPauseTime); } //10 botCommands.Clear(); bot.ResetToLastCheckpoint(); executeRoutine = null; }</span></span></code> </pre> <br>  Wow, wie viel Code!  Aber mach dir keine Sorgen;  Wir sind endlich bereit für den ersten echten Start des Projekts im Spielfenster. <br><br>  Ich werde den Code später erklären.  Denken Sie daran, die Änderungen zu speichern. <br><br><h3>  Führen Sie das Spiel aus, um die Befehlsvorlage zu testen </h3><br>  Jetzt ist also die Zeit zu bauen;  Klicken Sie im Unity-Editor auf <em>Wiedergabe</em> . <br><br>  Sie sollten in der Lage sein, Bewegungsbefehle mit den <em>WASD-Tasten einzugeben</em> .  Drücken Sie die <em>F-</em> Taste, um den Aufnahmebefehl einzugeben.  Drücken Sie die <em>Eingabetaste,</em> um Befehle auszuführen. <br><br><blockquote>  <em>Hinweis</em> : Bis zum Abschluss des Ausführungsprozesses ist die Eingabe neuer Befehle nicht möglich. </blockquote><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/20b/ef8/483/20bef8483dd70829836bd9234178f5dd.gif"></div><br>  Beachten Sie, dass der Terminal-Benutzeroberfläche Zeilen hinzugefügt werden.  Teams in der Benutzeroberfläche werden durch ihre Namen angezeigt.  Möglich wird dies durch die Variable <code>commandName</code> . <br><br>  Beachten Sie außerdem, wie die Benutzeroberfläche vor der Ausführung einen Bildlauf durchführt und wie die Zeilen während der Ausführung gelöscht werden. <br><br><h3>  Wir studieren die Teams genauer </h3><br>  Es ist Zeit, den Code zu lernen, den wir im Abschnitt "Anwenden von Befehlen" hinzugefügt haben: <br><br><ol><li>  In der Liste <code>botCommands</code> werden Links zu Instanzen von <code>BotCommand</code> .  Denken Sie daran, dass wir zum Speichern von Speicher nur fünf Instanzen von Befehlen erstellen können, es jedoch möglicherweise mehrere Verweise auf einen Befehl gibt.  Darüber hinaus <code>executeCoroutine</code> Variable <code>executeCoroutine</code> auf <code>ExecuteCommandsRoutine</code> , die die Ausführung des Befehls steuert. </li><li>  <code>Update</code> prüft, ob der Benutzer die Eingabetaste gedrückt hat.  In diesem <code>ExecuteCommands</code> wird <code>CheckForBotCommands</code> <code>ExecuteCommands</code> , andernfalls wird <code>CheckForBotCommands</code> . </li><li>  <code>CheckForBotCommands</code> verwendet die statische <code>HandleInput</code> Methode des <code>BotInputHandler</code> , um zu überprüfen, ob der Benutzer die Eingabe abgeschlossen hat. In diesem <code>BotInputHandler</code> wird der Befehl <em>zurückgegeben</em> .  Der zurückgegebene Befehl wird an <code>AddToCommands</code> .  Wenn jedoch die Befehle ausgeführt werden, d.h.  Wenn <code>executeRoutine</code> nicht null ist, wird es zurückgegeben, ohne dass etwas an <code>AddToCommands</code> .  Das heißt, der Benutzer muss bis zum Abschluss warten. </li><li>  <code>AddToCommands</code> fügt der <em>zurückgegebenen</em> Instanz des Befehls in <code>botCommands</code> einen neuen Link <code>botCommands</code> . </li><li>  Die <code>InsertNewText</code> Methode der <code>InsertNewText</code> Klasse fügt der Terminal-Benutzeroberfläche eine neue Textzeile hinzu.  Eine Textzeichenfolge ist eine Zeichenfolge, die als Eingabeparameter übergeben wird.  In diesem Fall übergeben wir den Befehlsnamen. </li><li>  Die <code>ExecuteCommands</code> Methode startet <code>ExecuteCommandsRoutine</code> . </li><li>  <code>ResetScrollToTop</code> vom <code>UIManager</code> scrollt die Benutzeroberfläche des Terminals nach oben.  Dies erfolgt kurz vor Beginn der Ausführung. </li><li>  <code>ExecuteCommandsRoutine</code> enthält eine <code>for</code> Schleife, die die Befehle in der <code>botCommands</code> Liste <code>botCommands</code> und sie <code>botCommands</code> ausführt, wobei das <code>bot</code> Objekt an die von der <code>Execute</code> Eigenschaft zurückgegebene Methode übergeben wird.  Nach jeder Ausführung wird in <code>CommandPauseTime</code> Sekunden eine Pause hinzugefügt. </li><li>  Die <code>RemoveFirstTextLine</code> Methode von <code>UIManager</code> löscht die allererste Textzeile in der Terminal-Benutzeroberfläche, falls vorhanden.  Das heißt, wenn ein Befehl ausgeführt wird, wird sein Name von der Benutzeroberfläche entfernt. </li><li>  Nachdem alle Befehle <code>botCommands</code> gelöscht und der Bot wird mit <code>ResetToLastCheckpoint</code> auf den letzten Haltepunkt <code>ResetToLastCheckpoint</code> .  Am Ende ist <code>executeRoutine</code> <code>null</code> und der Benutzer kann weiterhin Befehle eingeben. </li></ol><br><h2>  Implementieren der Funktionen "Rückgängig" und "Wiederherstellen" </h2><br>  Führen Sie die Szene erneut aus und versuchen Sie, zum grünen Kontrollpunkt zu gelangen. <br><br>  Sie werden feststellen, dass wir den eingegebenen Befehl nicht abbrechen können.  Wenn Sie also einen Fehler machen, können Sie erst zurückkehren, wenn Sie alle eingegebenen Befehle ausgeführt haben.  Sie können dies beheben, indem Sie die Funktionen " <em>Rückgängig"</em> und " <em>Wiederherstellen"</em> hinzufügen. <br><br>  Gehen Sie zurück zu <em>SceneManager.cs</em> und fügen Sie unmittelbar nach der <i>List-</i> Deklaration für <code>botCommands</code> die folgende Variablendeklaration <code>botCommands</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Stack&lt;BotCommand&gt; undoStack = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;BotCommand&gt;();</code> </pre> <br>  Die Variable <code>undoStack</code> ist ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">Stapel</a> (aus der Collections-Familie), in dem alle Verweise auf Befehle gespeichert werden, die rückgängig gemacht werden können. <br><br>  Jetzt fügen wir zwei Methoden <code>UndoCommandEntry</code> und <code>RedoCommandEntry</code> , die Undo und Redo ausführen.  <code>SceneManager</code> in der <code>SceneManager</code> Klasse nach <code>ExecuteCommandsRoutine</code> <code>SceneManager</code> folgenden Code <code>ExecuteCommandsRoutine</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UndoCommandEntry</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 if (executeRoutine != null || botCommands.Count == 0) { return; } undoStack.Push(botCommands[botCommands.Count - 1]); botCommands.RemoveAt(botCommands.Count - 1); //2 uiManager.RemoveLastTextLine(); } private void RedoCommandEntry() { //3 if (undoStack.Count == 0) { return; } var botCommand = undoStack.Pop(); AddToCommands(botCommand); }</span></span></code> </pre> <br>  Lassen Sie uns den Code analysieren: <br><br><ol><li>  Wenn Befehle ausgeführt werden oder die <code>botCommands</code> Liste leer ist, führt die <code>UndoCommandEntry</code> Methode nichts aus.  Andernfalls wird ein Link zum letzten auf dem <code>undoStack</code> Stapel eingegebenen Befehl <code>undoStack</code> .  Dadurch wird auch die Verknüpfung zum Befehl aus der <code>botCommands</code> Liste entfernt. </li><li>  Die <code>RemoveLastTextLine</code> Methode von <code>UIManager</code> entfernt die letzte Textzeile von der Terminal-Benutzeroberfläche, sodass die Benutzeroberfläche mit dem Inhalt von <code>botCommands</code> . </li><li>  Wenn der <code>undoStack</code> Stapel leer ist, führt <code>RedoCommandEntry</code> nichts aus.  Andernfalls wird der letzte Befehl aus dem oberen Bereich von <code>undoStack</code> und mithilfe von <code>AddToCommands</code> wieder zur <code>botCommands</code> Liste <code>AddToCommands</code> . </li></ol><br>  Jetzt werden wir Tastatureingaben hinzufügen, um diese Funktionen zu verwenden.  <code>SceneManager</code> der <code>SceneManager</code> Klasse den Hauptteil der <code>Update</code> Methode durch den folgenden Code: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.Return)) { ExecuteCommands(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(KeyCode.U)) <span class="hljs-comment"><span class="hljs-comment">//1 { UndoCommandEntry(); } else if (Input.GetKeyDown(KeyCode.R)) //2 { RedoCommandEntry(); } else { CheckForBotCommands(); }</span></span></code> </pre> <br><ol><li>  Wenn Sie die <em>U-</em> Taste drücken, wird die <code>UndoCommandEntry</code> Methode <code>UndoCommandEntry</code> . </li><li>  Wenn Sie die Taste <em>R</em> drücken, wird die <code>RedoCommandEntry</code> Methode <code>RedoCommandEntry</code> . </li></ol><br><h3>  Edge Case Handling </h3><br>  Großartig, wir sind fast fertig!  Aber zuerst müssen wir Folgendes tun: <br><br><ol><li>  Bei der Eingabe eines neuen Befehls sollte der <code>undoStack</code> Stapel gelöscht werden. </li><li>  Vor dem Ausführen von Befehlen muss der <code>undoStack</code> Stack gelöscht werden. </li></ol><br>  Um dies zu implementieren, müssen wir <code>SceneManager</code> zunächst eine neue Methode <code>SceneManager</code> .  Fügen Sie nach <code>CheckForBotCommands</code> die folgende Methode <code>CheckForBotCommands</code> : <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BotCommand botCommand</span></span></span><span class="hljs-function">)</span></span> { undoStack.Clear(); AddToCommands(botCommand); }</code> </pre> <br>  Diese Methode löscht <code>undoStack</code> und ruft dann die <code>AddToCommands</code> Methode auf. <br><br>  Ersetzen Sie nun den Aufruf von <code>AddToCommands</code> in <code>CheckForBotCommands</code> durch den folgenden Code: <br><br><pre> <code class="cs hljs"> AddNewCommand(botCommand);</code> </pre> <br>  <code>ExecuteCommands</code> dann die folgende Zeile nach der <code>if</code> in die <code>ExecuteCommands</code> Methode ein, um sie zu löschen, bevor Sie <code>undoStack</code> Befehle ausführen: <br><br><pre> <code class="cs hljs"> undoStack.Clear();</code> </pre> <br>  Und wir sind endlich fertig! <br><br>  Speichern Sie Ihre Arbeit.  Erstellen Sie das Projekt und klicken Sie im <em>Play-</em> Editor.  Geben Sie die Befehle wie zuvor ein.  Drücken Sie <em>U</em> , um die Befehle abzubrechen.  Drücken Sie <em>R</em> , um die abgebrochenen Befehle zu wiederholen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fef/cfb/edf/fefcfbedf0b2e0711f2e831b0d069ebf.gif" width="1024" height="576"></div><br>  Versuchen Sie, zum grünen Kontrollpunkt zu gelangen. <br><br><h2>  Wohin als nächstes? </h2><br>  Um mehr über die in der Spielprogrammierung verwendeten Entwurfsmuster zu erfahren, empfehle ich Ihnen, die Spielprogrammierungsmuster von Robert Nystrom zu studieren. <br><br>  Um mehr über fortgeschrittene C # -Techniken zu erfahren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">, besuchen Sie den</a> Kurs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="noopener">C # -Sammlungen, Lambdas und LINQ</a> . <br><br><h3>  Aufgabe </h3><br>  Versuchen Sie als Aufgabe, zum grünen Kontrollpunkt am Ende des Labyrinths zu gelangen.  Ich habe eine der Lösungen unter dem Spoiler versteckt. <br><br><div class="spoiler">  <b class="spoiler_title">Lösung</b> <div class="spoiler_text"><ul><li>  moveUp × 2 </li><li>  moveRight × 3 </li><li>  moveUp × 2 </li><li>  moveLeft </li><li>  schießen </li><li>  moveLeft × 2 </li><li>  moveUp × 2 </li><li>  moveLeft × 2 </li><li>  moveDown × 5 </li><li>  moveLeft </li><li>  schießen </li><li>  moveLeft </li><li>  moveUp × 3 </li><li>  schießen × 2 </li><li>  moveUp × 5 </li><li>  moveRight × 3 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dab/f9e/05f/dabf9e05f3cb79ab20a6a663108295fe.png"></div></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de463953/">https://habr.com/ru/post/de463953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de463933/index.html">Ein 20-zeiliges Python-Skript, das Eltern jeden Tag über WhatsApp einen guten Morgen wünscht</a></li>
<li><a href="../de463937/index.html">Ich habe nichts zu verbergen</a></li>
<li><a href="../de463939/index.html">SimbirSoft hat eine mobile Lösung für Versicherungsunternehmen veröffentlicht</a></li>
<li><a href="../de463943/index.html">Die Missgeschicke des schwarzen Einhorns</a></li>
<li><a href="../de463951/index.html">c.tech: Cassandra Meetup # 2</a></li>
<li><a href="../de463955/index.html">Wie entwickelt man ein Konzept zur Änderung der IP-Plattform? Gebrauchsanweisung</a></li>
<li><a href="../de463957/index.html">So stellen Sie eine einfach verknüpfte Interviewliste bereit</a></li>
<li><a href="../de463961/index.html">Eigener Mapper oder ein wenig über ExpressionTrees</a></li>
<li><a href="../de463963/index.html">Gesichtserkennung auf einer Baustelle</a></li>
<li><a href="../de463965/index.html">Gesetzte Anwendung in LaTeX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>