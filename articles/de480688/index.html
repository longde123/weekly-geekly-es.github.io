<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí© ‚ùï üëÖ Woher kommen Mojibakes? Grundlagen der Kodierung üò° üí∏ ü§öüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werden die grundlegenden Konzepte der Zeichenkodierung erl√§utert. Anschlie√üend werden die technischen Details von Kodierungssystemen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Woher kommen Mojibakes? Grundlagen der Kodierung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/alconost/blog/480688/"><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/6b/fx/u8/6bfxu80gx8ygam-qemhdptmtsvc.jpeg"></a> </p><br><p>  In diesem Artikel werden die grundlegenden Konzepte der Zeichenkodierung erl√§utert. Anschlie√üend werden die technischen Details von Kodierungssystemen vertieft. </p><br><p>  Wenn Sie nur Grundkenntnisse in der Zeichenkodierung haben und das Wesentliche, die Unterschiede zwischen den Kodierungssystemen, warum wir manchmal Unsinntext erhalten, und die Prinzipien hinter verschiedenen Kodierungssystemarchitekturen besser verstehen m√∂chten, lesen Sie weiter. </p><br><p>  Um die Zeichenkodierung im Detail zu verstehen, ist ein umfangreiches Lesen und ein guter Zeitaufwand erforderlich.  Ich habe versucht, Ihnen einen Teil dieser M√ºhe zu ersparen, indem ich alles an einem Ort zusammengefasst habe und dabei einen meiner Meinung nach recht gr√ºndlichen Hintergrund f√ºr das Thema geboten habe. </p><br><p>  Ich werde √ºber die Funktionsweise von Einzelbyte-Codierungen (ASCII, Windows-1251 usw.), die Entstehungsgeschichte von Unicode, die Unicode-basierten Codierungen UTF-8, UTF-16 und deren Unterschiede nachdenken spezifische Merkmale, Kompatibilit√§t und deren Fehlen zwischen verschiedenen Codierungen, Zeichencodierungsprinzipien und eine praktische Anleitung, wie Zeichen codiert und decodiert werden. </p><a name="habracut"></a><br><p>  Auch wenn die Zeichenkodierung kein aktuelles Thema ist, ist es hilfreich zu verstehen, wie es jetzt funktioniert und wie es in der Vergangenheit funktioniert hat, ohne viel Zeit zu investieren. </p><br><h3 id="history-of-unicode">  Geschichte von Unicode </h3><br><p>  Ich denke, es ist das Beste, unsere Geschichte von einer Zeit an zu beginnen, in der Computer noch l√§ngst nicht so weit fortgeschritten und allt√§glich waren wie heute.  Entwickler und Ingenieure, die zu dieser Zeit versuchten, Standards zu entwickeln, ahnten nicht, dass Computer und das Internet genauso popul√§r und allgegenw√§rtig sein w√ºrden wie sie.  Als das passierte, brauchte die Welt Zeichenkodierungen. </p><br><p>  Aber wie kann ein Computer Zeichen oder Buchstaben speichern, wenn er nur Einsen und Nullen versteht?  Aus diesem Bed√ºrfnis ging die erste 1-Byte-ASCII-Codierung hervor, die zwar nicht unbedingt die erste Codierung ist, jedoch am weitesten verbreitet ist und Ma√üst√§be setzt.  Es ist also ein guter Standard. </p><br><p>  Aber was ist ASCII?  Der ASCII-Code besteht aus 8 Bits.  Eine einfache Arithmetik zeigt, dass dieser Zeichensatz 256 Symbole enth√§lt (acht Bits, Nullen und Einsen 2‚Å∏ = 256). </p><br><p>  Die ersten 7-Bit-128-Symbole (2‚Å∑ = 128) im Satz wurden f√ºr lateinische Buchstaben, Steuerzeichen (wie harte Zeilenumbr√ºche, Tabulatoren usw.) und grammatikalische Symbole verwendet.  Die anderen Teile waren f√ºr Landessprachen.  Auf diese Weise sind die ersten 128 Zeichen immer gleich. Wenn Sie Ihre Muttersprache codieren m√∂chten, helfen Sie sich selbst bei den verbleibenden Symbolen. </p><br><p>  Dies f√ºhrte zu einer Vielzahl nationaler Kodierungen.  Am Ende sieht die Situation so aus: Angenommen, Sie befinden sich in Russland und erstellen eine Textdatei, die standardm√§√üig Windows-1251 (die in Windows verwendete russische Codierung) verwendet.  Und Sie senden Ihr Dokument an jemanden au√üerhalb Russlands, beispielsweise in den USA.  Selbst wenn der Empf√§nger Russisch kann, hat er Pech, wenn er das Dokument auf seinem Computer √∂ffnet (mit einer Textverarbeitungssoftware, die ASCII als Standardcode verwendet), da statt russischer Buchstaben bizarre verst√ºmmelte Zeichen (Mojibake) angezeigt werden .  Genauer gesagt, alle englischen Buchstaben werden einwandfrei angezeigt, da die ersten 128 Symbole in Windows-1251 und ASCII identisch sind. Wenn jedoch russischer Text vorhanden ist, verwendet die Textverarbeitungssoftware des Empf√§ngers die falsche Codierung, es sei denn, der Benutzer hat das richtige Zeichen manuell eingegeben Kodierung. </p><br><p>  Das Problem mit den nationalen Zeichencode-Standards liegt auf der Hand.  Und schlie√ülich begannen sich diese nationalen Codes zu vermehren, das Internet begann zu explodieren, und jeder wollte in seiner Landessprache schreiben, ohne diese nicht entzifferbaren Mojibakes zu produzieren. </p><br><p>  Zu diesem Zeitpunkt gab es zwei M√∂glichkeiten: Verwenden Sie eine Kodierung f√ºr jedes Land oder erstellen Sie eine universelle Zeichentabelle, um alle Zeichen auf dem Planeten darzustellen. </p><br><h3 id="a-short-primer-on-ascii">  Eine kurze Einf√ºhrung in ASCII </h3><br><p>  Es mag √ºberm√§√üig elementar erscheinen, aber wenn wir gr√ºndlich sein wollen, m√ºssen wir alle Grundlagen abdecken. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/az/bt/mw/azbtmwjfkdtsfbvqd_ju-fibbwe.png"></a> </p><br><p>  Die ASCII-Tabelle enth√§lt drei Spaltengruppen: </p><br><ul><li>  der Dezimalwert des Zeichens </li><li>  der hexadezimale Wert des Zeichens </li><li>  die Glyphe f√ºr den Charakter selbst </li></ul><br><p> Angenommen, wir m√∂chten das Wort "ok" in ASCII codieren.  Der Buchstabe "o" hat einen Dezimalwert von 111 und 6F in hexadezimaler Schreibweise.  In der Bin√§rdatei w√§re das - 01101111. Der Buchstabe "k" ist die Position 107 in Dezimal und 6B in Hexadezimal oder - 01101011 in Bin√§rdatei.  Das Wort "OK" in ASCII w√ºrde also wie folgt aussehen: 01101111 01101011. Der Dekodierungsprozess w√§re umgekehrt.  Wir beginnen mit 8 Bits, √ºbersetzen sie in eine Dezimalcodierung und enden mit der Zeichennummer und durchsuchen die Tabelle nach dem entsprechenden Symbol. </p><br><h3 id="unicode">  Unicode </h3><br><p>  Aus dem obigen sollte ziemlich offensichtlich sein, warum eine einzige gemeinsame Zeichentabelle ben√∂tigt wurde.  Aber wie w√ºrde es aussehen?  Die Antwort ist Unicode, eigentlich keine Kodierung, sondern ein Zeichensatz.  Es besteht aus 1.114.112 Positionen oder Codepunkten, von denen die meisten noch leer sind. Daher ist es unwahrscheinlich, dass das Set erweitert werden muss. </p><br><p>  Der Unicode-Standard besteht aus 17 Ebenen mit jeweils 65.536 Codepunkten.  Jede Ebene enth√§lt eine Gruppe von Symbolen.  Die Ebene Null ist die mehrsprachige Grundebene, in der wir die in allen modernen Alphabeten am h√§ufigsten verwendeten Zeichen finden.  Die zweite Ebene enth√§lt Zeichen aus toten Sprachen.  Es gibt sogar zwei Flugzeuge, die f√ºr den privaten Gebrauch reserviert sind.  Die meisten Flugzeuge sind noch leer. </p><br><p>  Unicode hat Codepunkte f√ºr 0 bis 10FFFF (hexadezimal). </p><br><p>  Zeichen werden im Hexadezimalformat mit einem vorangestellten ‚ÄûU +‚Äú codiert.  So enth√§lt beispielsweise die erste Grundebene die Zeichen U + 0000 bis U + FFFF (0 bis 65.535), und der Block 17 enth√§lt U + 100000 bis U + 10FFFF (1.048.576 bis 1.114.111). </p><br><p>  Anstelle einer Menagerie mit zahlreichen Kodierungen haben wir jetzt eine umfassende Tabelle, die alle Symbole und Zeichen kodiert, die wir jemals ben√∂tigen k√∂nnten.  Aber es ist nicht ohne Fehler.  W√§hrend jedes Zeichen zuvor mit einem Byte codiert wurde, kann es jetzt mit einer anderen Anzahl von Bytes codiert werden.  Fr√ºher brauchten Sie nur ein Byte, um alle Buchstaben des englischen Alphabets zu kodieren.  Der lateinische Buchstabe ‚Äûo‚Äú in Unicode lautet beispielsweise U + 006F.  Mit anderen Worten, dieselbe Zahl wie in ASCII - 6F in hexadezimaler Schreibweise und 111 in bin√§rer Schreibweise.  Um das Symbol ‚ÄûU + 103D5‚Äú (die persische Zahl ‚Äû100‚Äú) zu codieren, ben√∂tigen wir 103D5 in hexadezimaler Schreibweise und 66.517 in dezimaler Schreibweise. Jetzt ben√∂tigen wir drei Bytes. </p><br><p>  Dieser Komplexit√§t muss mit Unicode-Codierungen wie UTF-8 und UTF-16 begegnet werden.  Und weiter schauen wir sie uns an. </p><br><h3 id="utf-8">  Utf-8 </h3><br><p>  UTF-8 ist eine Unicode-Codierung des Codierungssystems mit variabler Breite, mit der jedes Unicode-Symbol angezeigt werden kann. </p><br><p>  Was meinen wir, wenn wir von variabler Breite sprechen?  Zun√§chst m√ºssen wir verstehen, dass die strukturelle (atomare) Einheit bei der Codierung ein Byte ist.  Codierung mit variabler Breite bedeutet, dass ein Zeichen mit einer unterschiedlichen Anzahl von Einheiten oder Bytes codiert werden kann.  Beispielsweise werden lateinische Buchstaben mit einem Byte und kyrillische Buchstaben mit zwei Bytes codiert. </p><br><p>  Bevor wir weitermachen, noch etwas zur Kompatibilit√§t zwischen ASCII und UTF. </p><br><p>  Die Tatsache, dass lateinische Buchstaben und Schl√ºssel Steuerzeichen wie Zeilenumbr√ºche, Tabulatoren usw.  Ein Byte enthalten macht die UTF-Codierung mit ASCII kompatibel.  Mit anderen Worten, lateinische Schrift- und Steuerzeichen befinden sich in ASCII und UTF an genau denselben Codepunkten und werden mit jeweils einem Byte codiert und sind daher abw√§rtskompatibel. </p><br><p>  Verwenden wir den Buchstaben "o" aus unserem fr√ºheren ASCII-Beispiel.  Denken Sie daran, dass seine Position in der ASCII-Tabelle 111 oder 01101111 in bin√§rer Form ist.  In der Unicode-Tabelle ist es U + 006F oder 01101111. Und jetzt, da UTF ein Codierungssystem mit variabler Breite ist, w√ºrde "o" ein Byte sein.  Mit anderen Worten, "o" w√ºrde in beiden F√§llen gleich dargestellt.  Dasselbe gilt f√ºr die Zeichen 0 bis 128. Wenn Ihr Dokument also englische Buchstaben enth√§lt, bemerken Sie keinen Unterschied, wenn Sie es mit UTF-8, UTF-16 oder ASCII √∂ffnen, und bemerken einen Unterschied nur, wenn Sie mit der Arbeit beginnen mit nationalen Kodierungen. </p><br><p>  Schauen wir uns an, wie die gemischte englische / russische Phrase ‚ÄûHello world‚Äú in drei verschiedenen Codierungssystemen angezeigt wird: Windows-1251 (russische Codierung), ISO-8859-1 (Codierungssystem f√ºr westeurop√§ische Sprachen), UTF-8 (Unicode) .  Dieses Beispiel ist aussagekr√§ftig, weil wir einen Satz in zwei verschiedenen Sprachen haben. </p><br><p> <a href="https://habrahabr.ru/company/alconost/blog/480688/"><img src="https://habrastorage.org/webt/3c/xa/rk/3cxarky4ifw35kpwa2fhcoslen8.jpeg"></a> </p><br><p>  Betrachten wir nun, wie diese Codierungssysteme funktionieren und wie wir eine Textzeile von einer Codierung in eine andere √ºbersetzen k√∂nnen und was passiert, wenn die Zeichen nicht richtig angezeigt werden oder wenn dies aufgrund der Unterschiede in den Systemen einfach nicht m√∂glich ist. </p><br><p>  Angenommen, unsere urspr√ºngliche Phrase wurde mit Windows-1251-Codierung geschrieben.  Wenn wir uns die obige Tabelle ansehen, k√∂nnen wir durch die √úbersetzung von Dezimalzahl oder Hexadezimalzahl in Dezimalzahl feststellen, dass wir die folgende Codierung in Bin√§rform unter Windows-1251 erhalten. </p><br><p>  01001000 01100101 01101100 01101100 01101111 00100000 11101100 11101000 11110000 </p><br><p>  So, jetzt haben wir die Phrase "Hallo Welt" in Windows-1251-Codierung. </p><br><p>  Stellen Sie sich nun vor, wir haben eine Textdatei, wissen aber nicht, in welchem ‚Äã‚ÄãCodierungssystem der Text gespeichert wurde.  Wir gehen davon aus, dass es in ISO-8859-1 codiert ist, und √∂ffnen es in unserem Textverarbeitungsprogramm mit diesem Codierungssystem.  Wie wir zuvor gesehen haben, scheinen einige der Zeichen in Ordnung zu sein, da sie in diesem Codierungssystem existieren und sich sogar in denselben Codepunkten befinden, aber die Zeichen im russischen Wort "world" funktionieren nicht ganz so gut.  Diese Zeichen sind im Codierungssystem nicht vorhanden, und an ihren Stellen oder Codepunkten finden wir in ISO-8859-1 v√∂llig unterschiedliche Zeichen.  "M" ist also Codepunkt 236, "und" ist 232 und "p" ist 240. In ISO-8859-1 entsprechen diese Codepunkte jedoch "√¨" (236), "√®" (232) und " √∞ ‚Äù(240). </p><br><p>  Unsere in Windows-1251 codierte und in ISO-8859-1 gelesene mehrsprachige Phrase ‚ÄûHello World‚Äú sieht also wie ‚ÄûHello √¨√®√∞‚Äú aus.  Wir sind teilweise kompatibel und k√∂nnen eine in einem System kodierte Phrase in dem anderen nicht richtig anzeigen, da die Symbole, die wir brauchen, in der zweiten Kodierung einfach nicht vorhanden sind. </p><br><p>  Wir ben√∂tigen eine Unicode-Codierung - in unserem Fall verwenden wir UTF-8 als Beispiel.  Wir haben bereits besprochen, dass Zeichen in UTF-8 zwischen 1 und 4 Byte lang sein k√∂nnen. Ein weiterer Vorteil ist, dass UTF im Gegensatz zu den beiden vorherigen Codierungssystemen nicht auf 256 Symbole beschr√§nkt ist, sondern alle Symbole im Unicode-Zeichensatz enth√§lt . </p><br><p>  Es funktioniert ungef√§hr so: Das erste Bit jedes codierten Zeichens entspricht nicht dem Symbol selbst, sondern einem bestimmten Byte.  Wenn also das erste Bit Null ist, wissen wir, dass das codierte Symbol nur ein Byte verwendet - was die Einstellung mit ASCII abw√§rtskompatibel macht.  Wenn wir uns die ASCII-Symboltabelle genau ansehen, sehen wir, dass die ersten 128 Symbole (englisches Alphabet, Steuerzeichen und Interpunktionszeichen) bin√§r ausgedr√ºckt werden. Sie beginnen alle mit einem Bitwert von 0 (beachten Sie, dass Sie Zeichen in √ºbersetzen) bin√§r unter Verwendung eines Online-Konverters oder √Ñhnlichem kann das erste h√∂herwertige Null-Bit verworfen werden, was etwas verwirrend sein kann. </p><br><p>  01001000 - Das erste Bit hat den Wert 0, daher codiert 1 Byte 1 Zeichen -&gt; ‚ÄûH‚Äú. </p><br><p>  01100101 - Das erste Bit hat den Wert 0, daher codiert 1 Byte 1 Zeichen -&gt; "e". </p><br><p>  Wenn der Wert des ersten Bits nicht Null ist, wird das Symbol in mehreren Bytes codiert. </p><br><p>  Eine Zwei-Byte-Codierung hat 110 f√ºr die ersten drei Bitwerte. </p><br><p>  11010000 10111100 - Die Markierungsbits sind 110 und 10, daher verwenden wir 2 Bytes, um 1 Zeichen zu codieren.  Das zweite Byte beginnt in diesem Fall immer mit ‚Äû10‚Äú. Daher lassen wir die Steuerbits (die in Rot und Gr√ºn hervorgehobenen F√ºhrungsbits) aus und sehen uns den Rest des Codes an (10000111100) und konvertieren in Hex (043). -&gt; U + 043C, was uns das russische "m" in Unicode gibt. </p><br><p>  Die Anfangsbits f√ºr ein Drei-Byte-Zeichen sind 1110. </p><br><p>  11101000 10000111 101010101 - Wir addieren alle Bits mit Ausnahme der Steuerbits und stellen fest, dass wir in hex 103B5, U + 103D5 - die alte persische Zahl einhundert (10000001111010101) haben. </p><br><p>  Vier-Byte-Zeichencodierungen beginnen mit den Ableitungsbits 11110. </p><br><p>  11110100 10001111 10111111 10111111 - U + 10FFFF, das letzte verf√ºgbare Zeichen im Unicode-Satz (10000111111111111111111). </p><br><p>  Jetzt k√∂nnen wir unsere mehrsprachige Phrase einfach in UTF-8-Codierung schreiben. </p><br><h3 id="utf-16">  Utf-16 </h3><br><p>  UTF-16 ist eine weitere Codierung mit variabler Breite.  Der Hauptunterschied zwischen UTF-16 und UTF-8 besteht darin, dass UTF-16 2 Bytes (16 Bits) pro Codeeinheit anstelle von 1 Byte (8 Bits) verwendet.  Mit anderen Worten, jedes in UTF-16 codierte Unicode-Zeichen kann aus zwei oder vier Bytes bestehen.  Um die Sache einfach zu halten, werde ich diese beiden Bytes als Code-Einheit bezeichnen.  In UTF-16 kann jedes Zeichen mit einer oder zwei Codeeinheiten dargestellt werden. </p><br><p>  Beginnen wir mit Symbolen, die mit einer Codeeinheit codiert wurden.  Wir k√∂nnen leicht berechnen, dass es 65.535 (216) Zeichen mit einer Codeeinheit gibt, was vollst√§ndig mit der mehrsprachigen Grundebene von Unicode √ºbereinstimmt.  Alle Zeichen in dieser Ebene werden in UTF-16 durch eine Codeeinheit (zwei Bytes) dargestellt. </p><br><p>  Lateinischer Buchstabe "o" - 00000000 01101111. </p><br><p>  Kyrillischer Buchstabe "M" - 00000100 00011100. </p><br><p>  Betrachten wir nun Zeichen au√üerhalb der mehrsprachigen Basisebene.  Diese ben√∂tigen zwei Code-Einheiten (4 Byte) und sind etwas komplizierter codiert. </p><br><p>  Zun√§chst m√ºssen wir das Konzept eines Ersatzpaares definieren.  Ein Ersatzpaar besteht aus zwei Codeeinheiten, die zum Codieren eines einzelnen Zeichens verwendet werden (insgesamt 4 Bytes).  Der Unicode-Zeichensatz reserviert einen speziellen Bereich von D800 bis DFFF f√ºr Ersatzpaare.  Dies bedeutet, dass wir beim Konvertieren eines Ersatzpaares in hexadezimale Bytes einen Codepunkt in diesem Bereich erhalten, der eher ein Ersatzpaar als ein separates Zeichen ist. </p><br><p>  Um ein Symbol im Bereich von 10000 bis 10FFFF zu codieren (d. H. Zeichen, die mehr als eine Codeeinheit erfordern), gehen Sie wie folgt vor: </p><br><ol><li><p>  Subtrahieren Sie 10000 (hex) vom Codepunkt (dies ist der niedrigste Codepunkt im Bereich von 10000 - 10FFFF). </p><br></li><li><p>  Am Ende haben wir eine 20-Bit-Zahl, die nicht gr√∂√üer als FFFF ist. </p><br></li><li><p>  Die 10 h√∂herwertigen Bits, die wir am Ende haben, werden zu D800 hinzugef√ºgt (dem niedrigsten Codepunkt im Bereich der Ersatzpaare in Unicode). </p><br></li><li><p>  Die n√§chsten 10 Bits werden zu DC00 hinzugef√ºgt (ebenfalls aus dem Ersatzpaarbereich). </p><br></li><li><p>  Als n√§chstes erhalten wir 2 Ersatz-16-Bit-Code-Einheiten, deren erste 6 Bits die Einheit als Teil eines Ersatzpaares definieren. </p><br></li><li><p>  Das zehnte Bit in jedem Ersatzzeichen definiert die Reihenfolge des Paares.  Wenn wir eine "1" haben, ist dies das f√ºhrende oder hohe Ersatzzeichen, und wenn wir eine "0" haben, ist dies das nachgestellte oder niedrige Ersatzzeichen. </p><br></li></ol><br><p>  Dies ist etwas sinnvoller, wenn Sie das folgende Beispiel verwenden. </p><br><p>  Codieren und decodieren wir die persische Zahl einhundert (U + 103D5): </p><br><ol><li><p>  103D5 - 10000 = 3D5. </p><br></li><li><p>  3D5 = 0000000000 1111010101 (die oberen 10 Bits sind Null, und wenn wir in hexadezimal konvertiert werden, erhalten wir "0" (die ersten zehn) und 3D5 (die zweiten zehn)). </p><br></li><li><p>  0 + D800 = D800 (1101100000000000) Die ersten 6 Bits geben an, dass dieser Codepunkt in den Bereich der Ersatzpaare f√§llt. Das zehnte Bit (von rechts) hat den Wert "0". Dies ist also der hohe Ersatz. </p><br></li><li><p>  3D5 + DC00 = DFD5 (1101111111010101) Die ersten 6 Bits geben an, dass dieser Codepunkt in den Bereich der Ersatzpaare f√§llt. Das zehnte Bit (von rechts) ist eine ‚Äû1‚Äú. Wir wissen also, dass dies der niedrige Ersatz ist. </p><br></li><li><p>  Das resultierende in UTF-16 codierte Zeichen sieht aus wie - 1101100000000000 1101111111010101. </p><br></li></ol><br><p>  Nun wollen wir den Charakter dekodieren.  Angenommen, wir haben den folgenden Codepunkt - 1101100000100010 1101111010001000: </p><br><ol><li><p>  Wir konvertieren in hexadezimal = D822 DE88 (beide Codepunkte liegen im Bereich der Ersatzpaare, sodass wir wissen, dass es sich um ein Ersatzpaar handelt). </p><br></li><li><p>  1101100000100010 - Das zehnte Bit (von rechts) ist eine ‚Äû0‚Äú, dies ist also der hohe Ersatz. </p><br></li><li><p>  1101111010001000 - Das zehnte Bit (von rechts) ist eine ‚Äû1‚Äú, dies ist also der niedrige Ersatz. </p><br></li><li><p>  Wir ignorieren die 6 Bits, die angeben, dass dies ein Ersatz ist, und verbleiben bei 0000100010 1010001000 (8A88). </p><br></li><li><p>  Wir addieren 10000 (den niedrigsten Codepunkt im Ersatzbereich) 8A88 + 10000 = 18A88. </p><br></li><li><p>  Wir sehen uns die Unicode-Tabelle f√ºr U + 18A88 = Tangut Component-649 an. </p><br></li></ol><br><p>  Ein gro√ües Lob an alle, die so weit gelesen haben! </p><br><p>  Ich hoffe, das war informativ, ohne dass Sie sich zu langweilen. </p><br><p>  <strong>Sie k√∂nnten auch n√ºtzlich finden:</strong> <strong><br></strong> <br>  <a href="https://unicode-table.com/en/">Der Unicode-Zeichensatz</a> </p><br><p>  <a href="https://habr.com/ru/company/alconost/blog/473960/">Strategien zur Lokalisierung von Inhalten: IP- oder browserbasiert</a> <a href="https://habr.com/ru/company/alconost/blog/473960/"><br></a> </p><br><h3 id="about-the-translator">  √úber den √úbersetzer </h3><br><p>  <a href="https://alconost.com/en%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Alconost</a> ist ein globaler Anbieter von <a href="https://alconost.com/en/services/software-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Lokalisierungsdiensten f√ºr Apps</a> , <a href="https://alconost.com/en/services/game-localization%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Spiele</a> , Videos und <a href="https://alconost.com/en/services/website-translation%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Websites</a> in √ºber 70 Sprachen.  Wir bieten √úbersetzungen von muttersprachlichen Linguisten, Sprachtests, Cloud-basierte Workflows, kontinuierliche Lokalisierung, Projektmanagement rund um die Uhr und die Arbeit mit jedem Format von Zeichenkettenressourcen.  Wir machen auch Werbe- und <a href="https://alconost.com/en/services/video-production%3Futm_source%3Dhabr%26utm_medium%3Darticle%26utm_campaign%3Dkrakazyabra">Lehrvideos</a> und -bilder, Teaser, Erkl√§rungen und Trailer f√ºr Google Play und den App Store. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de480688/">https://habr.com/ru/post/de480688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de480672/index.html">Das Paradoxon von Einstein - Podolsky - Rosen an den Fingern und ... was hat der √Ñther damit zu tun</a></li>
<li><a href="../de480674/index.html">Testen von virtuellen Servern von DigitalOcean, Vultr, Linode und Hetzner. Menschliche Verluste: 0.0</a></li>
<li><a href="../de480680/index.html">NGINX Verteidigungsstrategie und Anfrage an Igor Sysoev</a></li>
<li><a href="../de480682/index.html">Intel RealSense LiDAR L515 - Ein weiteres neues RealSense</a></li>
<li><a href="../de480686/index.html">Warum ich plattform√ºbergreifende L√∂sungen in der mobilen Entwicklung abgelehnt habe</a></li>
<li><a href="../de480690/index.html">Zoll-Jalousien verwalten wir g√ºnstig</a></li>
<li><a href="../de480692/index.html">MobX oder Redux: Was ist besser f√ºr das React State Management?</a></li>
<li><a href="../de480694/index.html">K√∂nnen wir aufh√∂ren, UX-Barrierefreiheit und -Bedienbarkeit anzurufen?</a></li>
<li><a href="../de480700/index.html">Wir verwenden console.log () in Chrome vollst√§ndig</a></li>
<li><a href="../de480702/index.html">HR und Talente, Experten und Kreative: Wie war das achte Habraseminar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>