<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚊 👨🏿‍💻 👨🏾‍🚒 Criando um chatbot de conversação simples em python 👨🏿‍🚀 💋 🍰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Você acha que é difícil escrever seu próprio chatbot em Python que possa apoiar a conversa? Acabou sendo muito fácil se você encontrar um bom conjunto...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando um chatbot de conversação simples em python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462333/"> Você acha que é difícil escrever seu próprio chatbot em Python que possa apoiar a conversa?  Acabou sendo muito fácil se você encontrar um bom conjunto de dados.  Além disso, isso pode ser feito mesmo sem redes neurais, embora ainda seja necessária alguma mágica matemática. <br><br>  Iremos em pequenos passos: primeiro, lembre-se de como carregar dados no Python, depois aprenda a contar palavras, conecte gradualmente álgebra linear e teorizador e, no final, criamos um bot para o Telegram a partir do algoritmo de bate-papo resultante. <br><br>  Este tutorial é adequado para quem já tocou um pouco em Python, mas não está particularmente familiarizado com o aprendizado de máquina.  Intencionalmente, não usei nenhuma biblioteca nlp-sh para mostrar que algo funcionando pode ser montado no sklearn. <br><br><img src="https://habrastorage.org/webt/q2/rw/4q/q2rw4qdp5wbuj6pjbl36rqjk-ui.jpeg"><br><br><a name="habracut"></a><br><h3>  Procure uma resposta no conjunto de dados da caixa de diálogo </h3><br>  Um ano atrás, me pediram para mostrar aos caras que não haviam se envolvido anteriormente na análise de dados algum aplicativo inspirador de aprendizado de máquina que você pode criar por conta própria.  Tentei trazer um falador de bot com eles, e realmente o fizemos em uma noite.  Gostamos do processo e do resultado e escrevemos sobre isso no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">meu blog</a> .  E agora eu pensei que Habru seria interessante. <br><br>  Então aqui vamos nós.  Nossa tarefa é criar um algoritmo que dê uma resposta apropriada a qualquer frase.  Por exemplo, em "como você está?"  responda "excelente, e você?".  A maneira mais fácil de conseguir isso é encontrar um banco de dados pronto de perguntas e respostas.  Por exemplo, tire legendas de um grande número de filmes. <br><br>  No entanto, vou agir de forma ainda mais trapaceira e tirar os dados da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">competição Yandex.Algorithm 2018</a> - esses são os mesmos diálogos dos filmes para os quais os funcionários da Toloka marcaram boas e boas sequências.  Yandex coletou esses dados para treinar Alice (artigos sobre suas tripas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">3</a> ).  Na verdade, eu fui inspirado por Alice quando criei esse bot.  A <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tabela do Yandex</a> mostra as três últimas frases e a resposta para elas (resposta), mas usaremos apenas a mais recente (context_0). <br><br>  Com esse banco de dados de diálogos, você pode simplesmente pesquisar cada réplica do usuário e fornecer uma resposta pronta (se houver muitas dessas réplicas, escolha aleatoriamente).  Com "como vai você?"  ficou ótimo, como evidenciado pela captura de tela em anexo.  Este, se é que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">existe</a> algo, é um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloco de anotações jupyter</a> no Python 3. Se você quiser repetir isso sozinho, a maneira mais fácil é instalar o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Anaconda</a> - ele inclui o Python e vários pacotes úteis para ele.  Ou você não pode instalar nada, mas execute um notebook <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em uma nuvem do Google</a> . <br><br><img src="https://habrastorage.org/webt/to/yi/c5/toyic5yjzteeyciixnplj8d9wou.jpeg"><br><br>  O problema com pesquisas textuais é que ele tem baixa cobertura.  Para a frase "como vai você?"  no banco de dados de 40 mil respostas, não houve correspondência exata, embora tenha o mesmo significado.  Portanto, na próxima seção, suplementaremos nosso código usando diferentes matemáticas para implementar uma pesquisa aproximada.  E antes disso, você pode ler sobre a biblioteca do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pandas</a> e descobrir o que cada uma das 6 linhas do código acima faz. <br><br><h3>  Vetorização de texto </h3><br>  Agora, estamos falando sobre como transformar textos em vetores numéricos para realizar uma pesquisa aproximada neles. <br><br>  Já conhecemos a biblioteca de pandas em Python - ela permite carregar tabelas, pesquisar nelas, etc.  Agora, vamos tocar na biblioteca scikit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">-learn</a> (sklearn), que permite manipulação de dados mais complicada - o que é chamado de aprendizado de máquina.  Isso significa que qualquer algoritmo deve primeiro mostrar os dados (ajuste) para que ele aprenda algo importante sobre eles.  Como resultado, o algoritmo "aprende" a fazer algo útil com esses dados - transformá-lo (transformar) ou até prever valores desconhecidos (prever). <br><br>  Nesse caso, queremos converter textos ("perguntas") em vetores numéricos.  Isso é necessário para que seja possível encontrar textos “próximos” um do outro, usando o conceito matemático de distância.  A distância entre dois pontos pode ser calculada pelo teorema de Pitágoras - como a raiz da soma dos quadrados das diferenças de suas coordenadas.  Em matemática, isso é chamado de métrica euclidiana.  Se podemos transformar textos em objetos que possuem coordenadas, podemos calcular a métrica euclidiana e, por exemplo, encontrar no banco de dados uma pergunta que mais se assemelha a “o que você está pensando?”. <br><br>  A maneira mais fácil de especificar as coordenadas do texto é numerar todas as palavras do idioma e dizer que a i-ésima coordenada do texto é igual ao número de ocorrências da i-ésima palavra nele.  Por exemplo, para o texto "Não consigo evitar de chorar", a coordenada da palavra "não" é 2, as coordenadas das palavras "I", "posso" e "choro" são 1 e as coordenadas de todas as outras palavras (dezenas de milhares de quais) são 0. Esta representação perde informações sobre a ordem das palavras, mas ainda funciona muito bem. <br><br>  O problema é que, para as palavras frequentemente encontradas (por exemplo, partículas “e” e “a”), as coordenadas serão desproporcionalmente grandes, embora tenham pouca informação.  Para atenuar esse problema, a coordenada de cada palavra pode ser dividida pelo logaritmo do número de textos em que essa palavra ocorre - isso é chamado tf-idf e também funciona bem. <br><br><img src="https://habrastorage.org/webt/e0/us/xz/e0usxzw2z7i8pdlvi9cw1ox0ss4.jpeg"><br><br>  Existe apenas um problema: em nosso banco de dados de 60 mil “perguntas” textuais, que contêm 14 mil palavras diferentes.  Se você transformar todas as perguntas em vetores, obtém uma matriz de 60k * 14k.  Não é muito legal trabalhar com isso, então falaremos sobre reduzir a dimensão mais tarde. <br><br><h3>  Redução dimensional </h3><br>  Já definimos a tarefa de criar um chatbot de bate-papo, baixar e vetorizar dados para seu treinamento.  Agora temos uma matriz numérica representando réplicas de usuários.  Consiste em 60 mil linhas (havia tantas réplicas no banco de dados de diálogos) e 14 mil colunas (havia tantas palavras diferentes nelas).  Nossa tarefa agora é torná-lo menor.  Por exemplo, para apresentar cada texto não como um vetor 14123-dimensional, mas apenas um vetor 300-dimensional. <br><br>  Isso pode ser conseguido multiplicando nossa matriz de tamanho 60049x14123 por uma matriz de projeção especialmente selecionada de tamanho 14123x300, como resultado, obtemos o resultado 60049x300.  O algoritmo PCA ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">método do componente principal</a> ) seleciona a matriz de projeção para que a matriz original possa ser reconstruída com o menor erro padrão.  No nosso caso, foi possível manter cerca de 44% da matriz original, embora a dimensão tenha sido reduzida em quase 50 vezes. <br><br><img src="https://habrastorage.org/webt/ci/cm/cl/cicmclz2ltbmt8r1-eqav9prnkw.jpeg"><br><br>  O que torna essa compactação eficaz possível?  Lembre-se de que a matriz original contém contadores para mencionar palavras individuais nos textos.  Mas as palavras, em regra, são usadas não independentemente uma da outra, mas no contexto.  Por exemplo, quanto mais vezes a palavra "bloqueio" ocorre no texto das notícias, mais vezes é provável que a palavra "telegramas" também seja encontrada neste texto.  Mas a correlação da palavra "bloqueio", por exemplo, com a palavra "caftan" é negativa - elas são encontradas em diferentes contextos. <br><br>  Assim, verifica-se que o método dos componentes principais lembra não todas as 14 mil palavras, mas 300 contextos típicos pelos quais essas palavras podem ser tentadas para serem restauradas.  As colunas da matriz de projeção correspondentes a palavras sinônimas geralmente são semelhantes entre si, porque essas palavras são frequentemente encontradas no mesmo contexto.  Isso significa que é possível reduzir medições redundantes sem perder informações. <br><br>  Em muitas aplicações modernas, a matriz de projeção de palavras é calculada por redes neurais (por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">word2vec</a> ).  Mas, de fato, a álgebra linear simples já é suficiente para um resultado praticamente útil.  O método dos componentes principais é reduzido computacionalmente para SVD e é para calcular os vetores próprios e os valores próprios da matriz.  No entanto, isso pode ser programado sem ao menos conhecer os detalhes. <br><br><h3>  Procurar vizinhos próximos </h3><br>  Nas seções anteriores, carregamos a caixa de diálogo para python, a vetorizamos e reduzimos a dimensão, e agora queremos finalmente aprender a procurar nossos vizinhos mais próximos em nosso espaço tridimensional e, finalmente, responder a perguntas de maneira significativa. <br><br>  Como aprendemos a mapear perguntas para o espaço euclidiano de dimensão não muito alta, a busca por vizinhos pode ser realizada rapidamente.  Usaremos o algoritmo de busca de vizinhos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BallTree</a> pronto.  Mas escreveremos nosso modelo de invólucro, que escolheria um dos k vizinhos mais próximos e, quanto mais próximo o vizinho, maior a probabilidade de sua escolha.  Pois sempre é chato ter um dos vizinhos mais próximos, mas não é amarrado à semelhança. <br><br>  Portanto, queremos transformar as distâncias encontradas da consulta para os textos de referência na probabilidade de escolher esses textos.  Para fazer isso, você pode usar a função softmax, que muitas vezes ainda fica na saída das redes neurais.  Ela transforma seus argumentos em um conjunto de números não negativos, cuja soma é 1 - exatamente o que precisamos.  Além disso, podemos usar as "probabilidades" obtidas para uma escolha aleatória de resposta. <br><br><img src="https://habrastorage.org/webt/o_/er/qh/o_erqhthdlp0-7xd5jldgbrraqy.jpeg"><br><br>  As frases que o usuário digitará devem ser passadas pelos três algoritmos - o vetorizador, o método do componente principal e o algoritmo de seleção de resposta.  Para escrever menos código, você pode vinculá-los em uma única cadeia (pipeline), aplicando os algoritmos sequencialmente. <br><br>  Como resultado, obtivemos um algoritmo que, na pergunta de um usuário, é capaz de encontrar uma pergunta semelhante a ela e dar uma resposta a ela.  E, às vezes, essas respostas até parecem quase significativas. <br><br><img src="https://habrastorage.org/webt/eo/l4/rb/eol4rbcmho7uomtn56y5bjceg9u.jpeg"><br><br><h3>  Publicando um bot no Telegram </h3><br>  Já descobrimos como criar uma sala de bate-papo do chatbot que daria respostas aproximadamente relevantes às solicitações do usuário.  Agora estou mostrando como lançar um chatbot no Telegram. <br><br>  A maneira mais fácil de usar isso é a API do Telegram do wrapper pronta para python - por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pytelegrambotapi</a> .  Então, instruções passo a passo: <br><br><ol><li>  Registre seu futuro bot com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">@botfather</a> e obtenha um token de acesso, que você precisará inserir no seu código. </li><li>  Execute o comando de instalação uma vez - pip install pytelegrambotapi na linha de comando (ou via! Diretamente no bloco de notas). </li><li>  Execute o código como na captura de tela.  A célula entrará no modo de execução (*) e, enquanto estiver nesse modo, você poderá se comunicar com seu bot o quanto quiser.  Para parar o bot, pressione Ctrl + C.  A triste, mas importante verdade: se você estiver na Rússia, provavelmente antes de iniciar esta célula, será necessário ativar a VPN para evitar erros ao conectar-se a telegramas.  Uma alternativa mais simples à VPN é escrever todo o código não no seu computador local, mas no google colab ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">algo como isto</a> ). </li><li>  Se você deseja que o bot funcione permanentemente, é necessário colocar seu código em algum serviço de nuvem - por exemplo, AWS, Heroku, now.sh ou Yandex.Cloud.  Você pode aprender sobre como executá-los nos mínimos detalhes nos sites desses serviços ou em artigos ali mesmo no Habré.  Por exemplo, um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">nabo</a> com um pequeno exemplo de um bot sendo executado no heroku e colocando logs no mongodb. </li></ol><br><img src="https://habrastorage.org/webt/fn/1p/d2/fn1pd2mnnrx8xzitjovcnd4hbbi.jpeg"><br><br>  Eu não intencionalmente não carrego o código completo do artigo - você terá muito mais prazer e experiência útil ao imprimi-lo e obter um bot funcionando como resultado de seus próprios esforços.  Bem, ou se você estiver com preguiça de fazer isso, você pode conversar com a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">minha versão do</a> bot. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt462333/">https://habr.com/ru/post/pt462333/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt462321/index.html">SEO internacional | Fatores internacionais de classificação de SEO</a></li>
<li><a href="../pt462323/index.html">Obesidade - relaxe e envolva</a></li>
<li><a href="../pt462327/index.html">Ruído de um tumor de câncer: cientistas do NUST “MISiS” desenvolveram um ultra-som a laser para o diagnóstico de câncer</a></li>
<li><a href="../pt462329/index.html">Movendo a fonte de alimentação para a frente do chassi</a></li>
<li><a href="../pt462331/index.html">Brinquedo GAZ-66 no painel de controle. Parte 2</a></li>
<li><a href="../pt462335/index.html">Não leia, releia</a></li>
<li><a href="../pt462337/index.html">Estatísticas do site e seu pequeno repositório</a></li>
<li><a href="../pt462339/index.html">Como o treinamento manual está relacionado aos padrões internos da Amazon e como isso afetou a visão de mundo da empresa?</a></li>
<li><a href="../pt462347/index.html">Os primeiros dez dias entre uma coruja e um madrugador: sono, dieta, dieta e exercício</a></li>
<li><a href="../pt462349/index.html">RESTinio é um servidor HTTP assíncrono. Um exemplo simples da prática: retornando uma grande quantidade de dados em resposta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>