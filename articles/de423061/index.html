<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💛 ⛴️ ⏹️ ref Einheimische und ref kehrt in C # zurück: Leistungsprobleme 🐅 💐 ✴️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Von Anfang an unterstützte C # die Übergabe von Argumenten nach Wert oder Referenz. Vor Version 7 unterstützte der C # -Compiler jedoch nur eine Mögli...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ref Einheimische und ref kehrt in C # zurück: Leistungsprobleme</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/423061/">  Von Anfang an unterstützte C # die Übergabe von Argumenten nach Wert oder Referenz.  Vor Version 7 unterstützte der C # -Compiler jedoch nur eine Möglichkeit, einen Wert von einer Methode (oder Eigenschaft) zurückzugeben - die Rückgabe nach Wert.  In C # 7 hat sich die Situation mit der Einführung von zwei neuen Funktionen geändert: Ref Returns und Ref Locals.  Mehr über sie und ihre Leistung - unter dem Schnitt. <br><br><img src="https://habrastorage.org/webt/gi/7e/dd/gi7eddufiqnmiqtmtby4nrkxclw.jpeg"><a name="habracut"></a><br><br><h2>  Gründe </h2><br>  Es gibt viele Unterschiede zwischen Arrays und anderen Sammlungen hinsichtlich der Laufzeit der gemeinsamen Sprache.  Die CLR unterstützte von Anfang an Arrays und kann als integrierte Funktionalität betrachtet werden.  Die CLR-Umgebung und der JIT-Compiler können mit Arrays arbeiten, und sie haben noch eine weitere Funktion: Der Array-Indexer gibt Elemente als Referenz und nicht nach Wert zurück. <br><br>  Um dies zu demonstrieren, müssen wir uns der verbotenen Methode zuwenden - verwenden Sie den veränderlichen Werttyp: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Mutable { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Mutable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> X =&gt; _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IncrementX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _x++; } } [Test] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutability</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ma = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] {<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)}; ma[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed! Assert.That(ma[0].X, Is.EqualTo(2)); var ml = new List&lt;Mutable&gt; {new Mutable(1)}; ml[0].IncrementX(); // X hasn't been changed! Assert.That(ml[0].X, Is.EqualTo(1)); }</span></span></code> </pre> <br>  Das Testen ist erfolgreich, da sich der Array-Indexer erheblich vom Listen-Indexer unterscheidet. <br><br>  Der C # -Compiler gibt dem Array-Indexer - ldelema - eine spezielle Anweisung, die einen verwalteten Link zu einem Element dieses Arrays zurückgibt.  Im Wesentlichen gibt ein Array-Indexer ein Element als Referenz zurück.  List kann sich jedoch nicht auf die gleiche Weise verhalten, da in C # * kein Alias ​​des internen Status zurückgegeben werden konnte.  Daher gibt der Listenindexer ein Element nach Wert zurück, dh eine Kopie dieses Elements. <br><br>  * Wie wir bald sehen werden, kann der Listenindexer immer noch kein Element als Referenz zurückgeben. <br><br>  Dies bedeutet, dass ma [0] .IncrementX () die Methode aufruft, die das erste Element des Arrays ändert, während ml [0] .IncrementX () die Methode aufruft, die die Kopie des Elements ändert, ohne die ursprüngliche Liste zu beeinflussen. <br><br><h2>  Rückgabewerte und lokale Referenzvariablen: Grundlagen </h2><br>  Die Bedeutung dieser Funktionen ist sehr einfach: Wenn Sie den zurückgegebenen Referenzwert deklarieren, können Sie den Alias ​​einer vorhandenen Variablen zurückgeben, und die lokale Referenzvariable kann einen solchen Alias ​​speichern. <br><br>  1. Ein einfaches Beispiel: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RefLocalsAndRefReturnsBasics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] array = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Capture an alias to the first element into a local ref int first = ref array[0]; first = 42; Assert.That(array[0], Is.EqualTo(42)); // Local function that returns the first element by ref ref int GetByRef(int[] a) =&gt; ref a[0]; // Weird syntax: the result of a function call is assignable GetByRef(array) = -1; Assert.That(array[0], Is.EqualTo(-1)); }</span></span></code> </pre> <br>  2. Zurückgegebene Referenzwerte und schreibgeschützter Modifikator <br><br>  Der zurückgegebene Referenzwert kann den Alias ​​des Instanzfelds zurückgeben. Ab C # Version 7.2 können Sie den Alias ​​zurückgeben, ohne mit dem Modifikator ref readonly in das entsprechende Objekt schreiben zu können: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EncapsulationWentWrong</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Guid _guid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EncapsulationWentWrong</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span> =&gt; _x = x; <span class="hljs-comment"><span class="hljs-comment">// Return an alias to the private field. No encapsulation any more. public ref int X =&gt; ref _x; // Return a readonly alias to the private field. public ref readonly Guid Guid =&gt; ref _guid; } [Test] public void NoEncapsulation() { var instance = new EncapsulationWentWrong(42); instance.X++; Assert.That(instance.X, Is.EqualTo(43)); // Cannot assign to property 'EncapsulationWentWrong.Guid' because it is a readonly variable // instance.Guid = Guid.Empty; }</span></span></code> </pre> <br><ul><li>  Methoden und Eigenschaften können einen „Alias“ des internen Status zurückgeben.  In diesem Fall darf die Taskmethode nicht für die Eigenschaft definiert werden. </li><li>  Die Rückgabe per Referenz unterbricht die Kapselung, da der Client die volle Kontrolle über den internen Status des Objekts erlangt. </li><li>  Durch die Rückgabe über eine schreibgeschützte Verbindung wird vermieden, dass Werttypen unnötig kopiert werden, während der Client den internen Status nicht ändern kann. </li><li>  Schreibgeschützte Links können für Referenztypen verwendet werden, obwohl dies in nicht standardmäßigen Fällen wenig sinnvoll ist. </li></ul><br>  3. Bestehende Einschränkungen.  Das Zurückgeben eines Alias ​​kann gefährlich sein: Die Verwendung eines Alias ​​für eine Variable, die nach Abschluss der Methode auf dem Stapel abgelegt wird, führt zum Absturz der Anwendung.  Um diese Funktion sicher zu machen, wendet der C # -Compiler verschiedene Einschränkungen an: <br><br><ul><li>  Link zur lokalen Variablen kann nicht zurückgegeben werden. </li><li>  In Strukturen kann kein Verweis darauf zurückgegeben werden. </li><li>  Sie können einen Link zu einer Variablen auf dem Heap zurückgeben (z. B. zu einem Klassenmitglied). </li><li>  Sie können einen Link zu den Ref / Out-Parametern zurückgeben. </li></ul><br>  Für weitere Informationen empfehlen wir Ihnen, die ausgezeichnete Veröffentlichung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Safe to return-Regeln für Ref-Rücksendungen zu lesen</a> .  Der Autor des Artikels, Vladimir Sadov, ist der Ersteller der Rückgabereferenzfunktion für den C # -Compiler. <br><br>  Nachdem wir nun eine allgemeine Vorstellung von zurückgegebenen Referenzwerten und referenzierten lokalen Variablen haben, schauen wir uns an, wie sie verwendet werden können. <br><br><h2>  Zurückgegebene Referenzwerte in Indexern verwenden </h2><br>  Um die Auswirkungen dieser Funktionen auf die Leistung zu testen, erstellen wir eine einzigartige, unveränderliche Sammlung mit dem Namen NaiveImmutableList &lt;T&gt; und vergleichen sie mit T [] und List für Strukturen unterschiedlicher Größe (4, 16, 32 und 48). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NaiveImmutableList</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _length; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T[] _data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T[] data</span></span></span><span class="hljs-function">)</span></span> =&gt; (_data, _length) = (data, data.Length); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx] <span class="hljs-comment"><span class="hljs-comment">// R# 2017.3.2 is completely confused with this syntax! // =&gt; ref (idx &gt;= _length ? ref Throw() : ref _data[idx]); { get { // Extracting 'throw' statement into a different // method helps the jitter to inline a property access. if ((uint)idx &gt;= (uint)_length) ThrowIndexOutOfRangeException(); return ref _data[idx]; } } private static void ThrowIndexOutOfRangeException() =&gt; throw new IndexOutOfRangeException(); } struct LargeStruct_48 { public int N { get; } private readonly long l1, l2, l3, l4, l5; public LargeStruct_48(int n) : this() =&gt; N = n; } // Other structs like LargeStruct_16, LargeStruct_32 etc</span></span></code> </pre> <br>  Ein Leistungstest wird für alle Sammlungen durchgeführt und addiert alle N Eigenschaftswerte für jedes Element: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> elementsCount = <span class="hljs-number"><span class="hljs-number">100</span></span>_000; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> LargeStruct_48[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, elementsCount).Select(v =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LargeStruct_48(v)).ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> LargeStruct_48[] _array48 = CreateArray_48(); [BenchmarkCategory(<span class="hljs-string"><span class="hljs-string">"BigStruct_48"</span></span>)] [Benchmark(Baseline = <span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestArray_48</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Using elementsCound but not array.Length to force the bounds check // on each iteration. for (int i = 0; i &lt; elementsCount; i++) { result = _array48[i].N; } return result; }</span></span></code> </pre> <br>  Die Ergebnisse sind wie folgt: <br><br><img src="https://habrastorage.org/webt/2k/5t/6i/2k5t6iq-egji_4h7wp8zgizndws.png"><br><br>  Anscheinend stimmt etwas nicht!  Die Leistung unserer NaiveImmutableList &lt;T&gt; -Sammlung entspricht der Liste.  Was ist passiert? <br><br><h2>  Rückgabewerte mit schreibgeschütztem Modifikator: So funktioniert es </h2><br>  Wie Sie sehen können, gibt der NaiveImmutableList &lt;T&gt; -Indexer mithilfe des Modifikators ref readonly einen schreibgeschützten Link zurück.  Dies ist völlig gerechtfertigt, da wir die Fähigkeit der Kunden einschränken möchten, den zugrunde liegenden Status einer unveränderlichen Sammlung zu ändern.  Die Strukturen, die wir im Leistungstest verwenden, sind jedoch nicht nur lesbar. <br><br>  Dieser Test hilft uns, das grundlegende Verhalten zu verstehen: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckMutabilityForNaiveImmutableList</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ml = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NaiveImmutableList&lt;Mutable&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mutable(<span class="hljs-number"><span class="hljs-number">1</span></span>)); ml[<span class="hljs-number"><span class="hljs-number">0</span></span>].IncrementX(); <span class="hljs-comment"><span class="hljs-comment">// X has been changed, right? Assert.That(ml[0].X, Is.EqualTo(2)); }</span></span></code> </pre> <br>  Der Test ist fehlgeschlagen!  Aber warum?  Da die Struktur von "Nur-Lese-Links" der Struktur von in Modifikatoren und schreibgeschützten Feldern in Bezug auf Strukturen ähnlich ist: Der Compiler generiert bei jeder Verwendung eines Strukturelements eine Schutzkopie.  Dies bedeutet, dass ml [0].  erstellt weiterhin eine Kopie des ersten Elements, dies wird jedoch nicht vom Indexer ausgeführt: Die Kopie wird am Aufrufpunkt erstellt. <br><br>  Dieses Verhalten macht tatsächlich Sinn.  Der C # -Compiler unterstützt die Übergabe von Argumenten nach Wert, Referenz und "Nur-Lese-Link" unter Verwendung des In-Modifikators (Einzelheiten finden Sie unter <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Der In-Modifikator und die schreibgeschützten Strukturen in C #</a> ("Der In-Modifikator und die Nur-Lese-Strukturen in C #") ")).  Jetzt unterstützt der Compiler drei verschiedene Möglichkeiten, einen Wert von einer Methode zurückzugeben: nach Wert, nach Referenz und nach schreibgeschütztem Link. <br><br>  Schreibgeschützte Links sind regulären Links so ähnlich, dass der Compiler dasselbe InAttribute verwendet, um zwischen ihren Rückgabewerten zu unterscheiden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _n; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">ref</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ByReadonlyRef</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _n;</code> </pre> <br>  In diesem Fall wird die ByReadonlyRef-Methode effizient kompiliert in: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">InAttribute</span></span>] [<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>: IsReadOnly] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* ByReadonlyRef() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._n; }</code> </pre> <br>  Die Ähnlichkeit zwischen dem Modifikator in und der schreibgeschützten Verbindung bedeutet, dass diese Funktionen für reguläre Strukturen nicht sehr geeignet sind und Leistungsprobleme verursachen können.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> BigStruct { <span class="hljs-comment"><span class="hljs-comment">// Other fields public int X { get; } public int Y { get; } } private BigStruct _bigStruct; public ref readonly BigStruct GetBigStructByRef() =&gt; ref _bigStruct; ref readonly var bigStruct = ref GetBigStructByRef(); int result = bigStruct.X + bigStruct.Y;</span></span></code> </pre> <br>  Neben der ungewöhnlichen Syntax beim Deklarieren einer Variablen für bigStruct sieht der Code gut aus.  Das Ziel ist klar: BigStruct kehrt aus Leistungsgründen als Referenz zurück.  Da die BigStruct-Struktur beschreibbar ist, wird bei jedem Zugriff auf das Element leider eine Schutzkopie erstellt. <br><br><h2>  Zurückgegebene Referenzwerte in Indexern verwenden.  Versuch Nummer 2 </h2><br>  Versuchen wir die gleichen Tests für schreibgeschützte Strukturen unterschiedlicher Größe: <br><br><img src="https://habrastorage.org/webt/8s/u5/je/8su5je3fe_-dhpjlf4f1bpeqoug.png"><br><br>  Jetzt sind die Ergebnisse viel sinnvoller.  Die Verarbeitungszeit für große Strukturen nimmt immer noch zu, dies wird jedoch erwartet, da die Verarbeitung von mehr als 100.000 größeren Strukturen länger dauert.  Aber jetzt ist die Laufzeit für NaiveimmutableList &lt;T&gt; sehr nahe an der Zeit T [] und viel besser als im Fall von List. <br><br><h2>  Fazit </h2><br><ul><li>  Zurückgegebene Referenzwerte sollten sorgfältig behandelt werden, da sie die Kapselung unterbrechen können. </li><li>  Zurückgegebene Referenzwerte mit schreibgeschütztem Modifikator sind nur für schreibgeschützte Strukturen wirksam.  Bei herkömmlichen Strukturen können Leistungsprobleme auftreten. </li><li>  Bei der Arbeit mit beschreibbaren Strukturen erstellen zurückgegebene Referenzwerte mit dem schreibgeschützten Modifikator bei jeder Verwendung der Variablen eine Schutzkopie, was zu Leistungsproblemen führen kann. </li></ul><br>  Zurückgegebene Referenzwerte und referenzierte lokale Variablen sind nützliche Funktionen für Bibliotheksersteller und Entwickler von Infrastrukturcode.  Die Verwendung im Bibliothekscode ist jedoch sehr gefährlich: Um eine Sammlung zu verwenden, die Elemente mithilfe eines schreibgeschützten Links effektiv zurückgibt, muss sich jeder Bibliotheksbenutzer daran erinnern: Ein schreibgeschützter Link zu einer beschreibbaren Struktur erstellt eine Schutzkopie „am Aufrufpunkt ".  Im besten Fall wird dies eine mögliche Steigerung der Produktivität zunichte machen, und im schlimmsten Fall wird dies zu einer ernsthaften Verschlechterung führen, wenn gleichzeitig eine große Anzahl von Anforderungen an eine lokale Referenzvariable schreibgeschützt gestellt wird. <br><br>  PS Schreibgeschützte Links werden in BCL angezeigt.  Die schreibgeschützten Referenzmethoden für den Zugriff auf Elemente in unveränderlichen Sammlungen wurden in der folgenden Anforderung vorgestellt, um die Änderungen in corefx repo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Implementieren des ItemRef-API-Vorschlags</a> („Vorschlag zum Einschließen der ItemRef-API“)) aufzunehmen.  Daher ist es sehr wichtig, dass jeder die Funktionen dieser Funktionen versteht und weiß, wie und wann sie angewendet werden sollten. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de423061/">https://habr.com/ru/post/de423061/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de423051/index.html">Der Kampf um Ressourcen, Teil 1: Die Grundlagen von Cgroups</a></li>
<li><a href="../de423053/index.html">Struktur und schreibgeschützt: So vermeiden Sie Leistungseinbußen</a></li>
<li><a href="../de423055/index.html">Wall Street Analysten: "Apple hat uns dazu gebracht, unsere Hüte zu essen"</a></li>
<li><a href="../de423057/index.html">Python lehnt auch die Begriffe Master / Slave teilweise ab</a></li>
<li><a href="../de423059/index.html">Besser als sie sagen: Drei Grundlagen für das nächste MacBook als eines der besten Laptops von Apple</a></li>
<li><a href="../de423063/index.html">Epson WorkForce Pro: Chroniken darüber, wie ein Inkjet-Bürodruck eine Decke aus einem Laser gezogen hat und wie es heute dazu kam</a></li>
<li><a href="../de423065/index.html">Der Experte von Positive Technologies entdeckte die Möglichkeit, Verschlüsselungsschlüssel in Intel ME offenzulegen</a></li>
<li><a href="../de423067/index.html">Python Developer Tools von Microsoft. Erste Schritte</a></li>
<li><a href="../de423069/index.html">Apple Special Event, September 2018 [Textübersetzungsarchiv]</a></li>
<li><a href="../de423071/index.html">Ich habe keine Angst vor deiner NDA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>