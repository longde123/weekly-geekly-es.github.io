<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äçüë®‚Äçüëß‚Äçüëß üö∏ ü§üüèΩ Fichas criptogr√°ficas PKCS # 11: ver y exportar certificados, verificar su validez üë©‚Äçüç≥ üëºüèΩ ü¶à</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los comentarios al art√≠culo "Una utilidad multiplataforma de habla inglesa para ver certificados x509 calificados en Rusia", un usuario de Pas dese...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fichas criptogr√°ficas PKCS # 11: ver y exportar certificados, verificar su validez</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443480/"><img src="https://habrastorage.org/webt/jg/xr/s2/jgxrs2y4nfsgsn6ljt8l0wpevgy.png" align="left" alt="imagen">  En los comentarios al art√≠culo "Una utilidad multiplataforma de habla inglesa para ver certificados x509 calificados en Rusia", un usuario de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Pas</a> deseaba no solo "analizar los certificados", sino tambi√©n recibir "cadenas de certificados ra√≠z y llevar a cabo la validaci√≥n PKI, al menos para certificados con tokens con una clave extra√≠ble ".  La obtenci√≥n de una cadena de certificados se describi√≥ en uno de los art√≠culos anteriores.  Es cierto que se trataba de certificados almacenados en archivos, pero prometimos agregar mecanismos para trabajar con certificados almacenados en tokens PKCS # 11.  Y entonces, ¬øqu√© pas√≥ al final? <a name="habracut"></a><br><br><img src="https://habrastorage.org/webt/cg/vd/fw/cgvdfwfqdxc1tbvkkpcec_vzye8.png"><br><br>  La utilidad de an√°lisis y visualizaci√≥n est√° escrita en Tcl / Tk y para agregarle tokens / tarjetas inteligentes PKCS # 11, adem√°s de verificar la validez de los certificados, se requirieron varias tareas: <br><br><ul><li>  determinar el mecanismo para obtener certificados del token / tarjeta inteligente; </li><li>  verificar el certificado con la lista de certificados CRL revocados; </li><li>  verificar el certificado de validez por el mecanismo OCSP. </li></ul><br><h3>  <font color="#0000ff">Acceso a la ficha PKCS # 11</font> </h3><br>  Para acceder al token y los certificados almacenados en √©l, utilizaremos el paquete <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">TclPKCS11</a> .  El paquete se distribuye tanto en binarios como en c√≥digos fuente.  Los c√≥digos fuente ser√°n √∫tiles m√°s adelante cuando agreguemos soporte de tokens con criptograf√≠a rusa al paquete.  Hay dos formas de descargar el paquete TclPKCS11, o usar el comando tcl del formulario: <br><br><pre><code class="plaintext hljs">load &lt; tclpkcs11&gt; Tclpkcs11</code> </pre> <br>  O desc√°rguelo simplemente como el paquete pki :: pkcs11, despu√©s de colocar la biblioteca tclpkcs11 y el archivo pkgIndex.tcl en un directorio conveniente para usted (en nuestro caso, este es el subdirectorio pkcs11 del directorio actual) y agregarlo a la ruta auto_path: <br><br><pre> <code class="plaintext hljs">#lappend auto_path [file dirname [info scrypt]] lappend auto_path pkcs11 package require pki package require pki::pkcs11</code> </pre> <br>  Como estamos interesados ‚Äã‚Äãen tokens principalmente con soporte para la criptograf√≠a rusa, desde el paquete TclPKCS11 usaremos las siguientes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">funciones</a> : <br><blockquote><pre> <code class="plaintext hljs">::pki::pkcs11::loadmodule &lt;filename&gt; -&gt; handle ::pki::pkcs11::unloadmodule &lt;handle&gt; -&gt; true/false ::pki::pkcs11::listslots &lt;handle&gt; -&gt; list: slotId label flags ::pki::pkcs11::listcerts &lt;handle&gt; &lt;slotId&gt; -&gt; list: keylist ::pki::pkcs11::login &lt;handle&gt; &lt;slotId&gt; &lt;password&gt; -&gt; true/false ::pki::pkcs11::logout &lt;handle&gt; &lt;slotId&gt; -&gt; true/false</code> </pre> </blockquote>  Haga inmediatamente una reserva de que las funciones de inicio y cierre de sesi√≥n no se considerar√°n aqu√≠.  Esto se debe al hecho de que en este art√≠culo solo trataremos con certificados, y son objetos de token p√∫blicos.  Para acceder a objetos p√∫blicos no es necesario iniciar sesi√≥n a trav√©s del c√≥digo PIN en el token. <br><br>  La primera funci√≥n :: pki :: pkcs11 :: loadmodule es cargar la biblioteca PKCS # 11, que admite el token / tarjeta inteligente en la que se encuentran los certificados.  Se puede obtener una biblioteca mediante la compra de un token, o descargarse de Internet, o se instal√≥ previamente en una computadora.  En cualquier caso, debe saber qu√© biblioteca admite su token.  La funci√≥n loadmodule devuelve un identificador a la biblioteca cargada: <br><br><pre> <code class="plaintext hljs">set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" set handle [::pki::pkcs11::loadmodule $filelib]</code> </pre> <br>  En consecuencia, hay una funci√≥n para descargar una biblioteca cargada: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::unloadmodule $handle</code> </pre> <br>  Una vez que se ha cargado la biblioteca y tenemos su identificador, puede obtener una lista de ranuras compatibles con esta biblioteca: <br><br><pre> <code class="plaintext hljs">::pki::pkcs11::listslots $handle {0 {ruToken ECP } {TOKEN_PRESENT RNG LOGIN_REQUIRED USER_PIN_INITIALIZED TOKEN_INITIALIZED REMOVABLE_DEVICE HW_SLOT}} {1 { } {REMOVABLE_DEVICE HW_SLOT}} . . . {14 { } {REMOVABLE_D EVICE HW_SLOT}}</code> </pre> <br>  En este ejemplo, la lista contiene 15 (quince de 0 a 14) elementos.  Esa es la cantidad de espacios que la familia de tokens RuToken puede admitir.  A su vez, cada elemento de la lista en s√≠ es una lista de tres elementos: <br><br><pre> <code class="plaintext hljs">{{ } { } {   }}</code> </pre> <br>  El primer elemento de la lista es el n√∫mero de ranura.  El segundo elemento de la lista es la etiqueta ubicada en la ranura del token (32 bytes).  Si la ranura est√° vac√≠a, el segundo elemento contiene 32 espacios.  Y el √∫ltimo, tercer elemento de la lista contiene banderas.  No consideraremos todo el conjunto de banderas.  Lo que nos interesa en estas banderas es la presencia de la bandera TOKEN_PRESENT.  Es esta bandera la que indica que el token est√° en la ranura, y los certificados de inter√©s para nosotros pueden estar en el token.  Las banderas son algo muy √∫til, describen el estado del token, el estado de los c√≥digos PIN, etc.  Seg√∫n el valor de los indicadores, se administran los tokens PKCS # 11: <br><br><img src="https://habrastorage.org/webt/yq/7x/n1/yq7xn1qbusjtjirrudo1ebhjzhc.png"><br><br>  Ahora, nada le impide escribir el procedimiento slots_with_token, que devolver√° una lista de ranuras con las etiquetas de los tokens: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh lappend auto_path pkcs11 package require pki package require pki::pkcs11 #    proc ::slots_with_token {handle} { set slots [pki::pkcs11::listslots $handle] # puts "Slots: $slots" array set listtok [] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set listtok($slotid) $slotlabel } } #     parray listtok return [array get listtok] } set filelib "/usr/local/lib64/librtpkcs11ecp_2.0.so" if {[catch {set handle [::pki::pkcs11::loadmodule $filelib]} res]} { puts "Cannot load library $filelib : $res" exit } #   set listslots {} set listslots [::slots_with_token $handle] #        while {[llength $listslots] == 0} { puts " " after 3000 set listslots [::slots_with_token $handle] } #        foreach {slotid labeltok} $listslots { puts "Number slot: $slotid" puts "Label token: $labeltok" }</code> </pre> <br>  Si ejecuta este script, despu√©s de guardarlo en el archivo slots_with_token.tcl, como resultado obtenemos: <br><br><pre> <code class="bash hljs">$ ./slots_with_token.tcl listtok(0) = ruToken ECP listtok(1) = RuTokenECP20 Number slot: 0 Label token: RuTokenECP20 Number slot: 1 Label token: ruToken ECP $</code> </pre> <br>  De los 15 espacios disponibles para esta biblioteca, solo dos est√°n involucrados, cero y el primero. <br>  Ahora nada impide obtener una lista de certificados ubicados en un token en particular: <br><br><pre> <code class="plaintext hljs">set listcerts [::pki::pkcs11::listcerts $handle $slotid]</code> </pre> <br>  Cada elemento de la lista contiene informaci√≥n sobre un certificado.  Para obtener informaci√≥n del certificado, la funci√≥n :: pki :: pkcs11 :: listcerts utiliza la funci√≥n :: pki :: x509 :: parse_cert del paquete pki.  Pero la funci√≥n :: pki :: pkcs11 :: listcerts complementa esta lista con datos inherentes al protocolo PKCS # 11, a saber: <br><br><ul><li>  elemento etiqueta pkcs11_ (en la terminolog√≠a del atributo PKCS # 11 CKA_LABEL); </li><li>  elemento pkcs11_id (en la terminolog√≠a del atributo PKCS # 11 CKA_ID); </li><li>  elemento pkcs11_handle que contiene una indicaci√≥n de la biblioteca PKCS # 11 cargada; </li><li>  pkcs11_slotid elemento que contiene el n√∫mero de la ranura con el token en el que se encuentra este certificado; </li><li>  un elemento de tipo que contiene el valor pkcs11 para el certificado que est√° en el token. </li></ul><br>  Recuerde que los elementos restantes est√°n determinados principalmente por la funci√≥n pki :: parse_cert. <br>  A continuaci√≥n se muestra el procedimiento para obtener una lista de etiquetas (listCert) de certificados (CKA_LABEL, pkcs11_label) y una matriz de identificadores analizados (:: certs_p11).  La clave para acceder al elemento de la matriz de certificados es la etiqueta del certificado (CKA_LABEL, pkcs11_label): <br><br><pre> <code class="plaintext hljs">#  proc listcerttok {handle token_slotlabel token_slotid} { #     set listCer {} #   array set ::arrayCer [] set ::certs_p11 [pki::pkcs11::listcerts $handle $token_slotid] if {[llength $::certs_p11] == 0} { puts {Certificates are not on the token:$tokenslotlabel} return $listCer } foreach certinfo_list $::certs_p11 { unset -nocomplain certinfo array set certinfo $certinfo_list set certinfo(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $certinfo(cert)] set ::arrayCer($certinfo(pkcs11_label)) $certinfo(cert) lappend listCer $certinfo(pkcs11_label) } return $listCer }</code> </pre> <br>  Y ahora que hemos analizado los certificados, mostramos en silencio una lista de sus etiquetas en el cuadro combinado: <br><br><img src="https://habrastorage.org/webt/wd/7_/si/wd7_siithrzlh1gfwa5tm78rpbg.png"><br><br>  C√≥mo analizar las claves p√∫blicas de GOST que consideramos en el art√≠culo anterior. <br><br>  Dos palabras sobre la exportaci√≥n de certificados.  Los certificados se exportan tanto en codificaci√≥n PEM como en codificaci√≥n DER (botones DER, formato PEM).  El paquete pki tiene una funci√≥n conveniente pki :: _ encode_pem para convertir a formato PEM: <br><br><pre> <code class="plaintext hljs">set bufpem [::pki::_encode_pem &lt;der-buffer&gt; &lt;Headline&gt; &lt;Lastline&gt;]</code> </pre> <br>  por ejemplo: <br><br><pre> <code class="plaintext hljs">set certpem [::pki::encode_pen $cert_der "-----BEGIN CERTIFICATE-----" "-----END CERTIFICATE-----"]</code> </pre> <br>  Al seleccionar la etiqueta del certificado s√©ptico en el cuadro combinado, obtenemos acceso al cuerpo del certificado: <br><br><pre> <code class="plaintext hljs">#    set nick [.saveCert.labExp.listCert get] #        foreach certinfo_list $::certs_p11 { unset -nocomplain cert_parse array set cert_parse $certinfo_list if {$cert_parse(pkcs11_label) == $nick} { #   set cert_parse(pubkeyinfo) [::pki::x509::parse_cert_pubkeyinfo $cert_parse(cert)] break } } #   file|pkcs11 set ::tekcert "pkcs11"</code> </pre> <br>  Un mecanismo adicional para analizar el certificado y mostrarlo se discuti√≥ anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br><h3>  <font color="#0000ff">Validaci√≥n de certificado</font> </h3><br>  Al analizar el certificado, las variables :: notbefore y :: notafter almacenan la fecha a partir de la cual se puede usar el certificado en operaciones criptogr√°ficas (firma, cifrado, etc.) y la fecha de vencimiento del certificado.  El procedimiento para verificar el per√≠odo de validez de un certificado es: <br><br><pre> <code class="plaintext hljs">proc cert_valid_date {} { #       #    set startdate $::notbefore #    set enddate $::notafter #      set now [clock seconds] set isvalid 1 set reason "Certificate is valid" if {$startdate &gt; $now} { set isvalid 0 #      set reason "Certificate is not yet valid" } elseif {$now &gt; $enddate} { set isvalid 0 #    set reason "Certificate has expired" } return [list $isvalid $reason] }</code> </pre> <br>  La lista devuelta contiene dos elementos.  El primer elemento puede contener 0 (cero) o 1 (uno).  Un valor de "1" indica que el certificado es v√°lido y 0 indica que el certificado no es v√°lido.  La raz√≥n por la cual el certificado no es v√°lido se revela en el segundo elemento.  Este elemento puede contener uno de tres valores: <br><br><ul><li>  certificado v√°lido (el primer elemento de la lista es 1): </li><li>  el certificado a√∫n no es v√°lido (el certificado a√∫n no ha caducado) </li><li>  El certificado ha expirado. </li></ul><br>  La validez del certificado est√° determinada no solo por su per√≠odo de validez.  El centro de certificaci√≥n puede suspender o rescindir el certificado, tanto por iniciativa propia como a solicitud del titular del certificado, por ejemplo, en caso de p√©rdida del medio con la clave privada.  En este caso, la autoridad de certificaci√≥n incluye el certificado en la lista de certificados COS / CRL revocados que son distribuidos por la CA.  Por lo general, el punto de distribuci√≥n de CRL se incluye en el certificado.  Es de la lista de certificados revocados que se verifica la validez del certificado. <br><br><h3>  <font color="#0000ff">Validaci√≥n de la validez del certificado por SOS / CRL</font> </h3><br>  El primer paso es obtener el SOS, luego analizarlo y verificar el certificado. <br>  La lista de puntos de emisi√≥n COC / CRL se encuentra en la extensi√≥n del certificado con oid 2.5.29.31 (id-ce-cRLDistributionPoints): <br><br><pre> <code class="plaintext hljs">array set extcert $cert_parse(extensions) set ::crlfile "" if {[info exists extcert(2.5.29.31)]} { set ::crlfile [crlpoints [lindex $extcert(2.5.29.31) 1]] } else { puts "cannot load CRL" }</code> </pre> <br>  En realidad, cargar el archivo con SOS / CRL es el siguiente: <br><br><pre> <code class="plaintext hljs">set filecrl "" set pointcrl "" foreach pointcrl $::crlfile { set filecrl [readca $pointcrl $dir] if {$filecrl != ""} { set f [file join $dir [file tail $pointcrl]] set fd [open $fw] chan configure $fd -translation binary puts -nonewline $fd $filecrl close $fd set filecrl $f break } # CRL  .     CRL } if {$filecrl == ""} { puts "Cannot load CRL" }</code> </pre> <br>  En realidad, el procedimiento de lectura se usa para cargar el COC / CRL: <br><br><pre> <code class="plaintext hljs">proc readca {url dir} { set cer "" #   if { "https://" == [string range $url 0 7]} { #    tls http::register https 443 ::tls::socket } #     if {[catch {set token [http::geturl $url -binary 1] #    set ere [http::status $token] if {$ere == "ok"} { #        set code [http::ncode $token] if {$code == 200} { #      set cer [http::data $token] } elseif {$code == 301 || $code == 302} { #    ,   set newURL [dict get [http::meta $token] Location] #     set cer [readca $newURL $dir] } else { #    set cer "" } } } error]} { #   ,     set cer "" } return $cer }</code> </pre><br>  La variable dir almacena la ruta al directorio en el que se guardar√° el COS / CRL, y la variable url contiene la lista de puntos de distribuci√≥n CRL recibida previamente. <br><br>  Al recibir SOS / CRL, de repente tuve que enfrentar el hecho de que para algunos certificados esta lista ten√≠a que recibirse a trav√©s del protocolo https (tls) en modo an√≥nimo.  Honestamente, esto es sorprendente: la lista de CRL es un documento p√∫blico y su integridad est√° protegida por una firma electr√≥nica y, en mi opini√≥n, tengo acceso a ella a trav√©s de https an√≥nimos.  Pero no hay nada que hacer, debe conectar el paquete tls: el paquete requiere tls. <br><br>  Si SOS / CRL no se pudo descargar, entonces el certificado no se puede verificar si el punto de acceso con el servicio OCSP no se especifica en el certificado.  Pero esto se discutir√° en uno de los siguientes art√≠culos. <br><br>  Entonces, hay un certificado para la verificaci√≥n, hay una lista de SOS / CRL, queda por verificar el certificado.  Desafortunadamente, no hay funciones correspondientes en el paquete pki.  Por lo tanto, tuve que escribir un procedimiento para verificar la validez del certificado (su no revocaci√≥n) de la lista de certificados revocados <br><br><div class="spoiler">  <b class="spoiler_title">validaty_cert_from_crl:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">proc validaty_cert_from_crl {crl sernum issuer} { array set ret [list] if { [string range $crl 0 9 ] == "-----BEGIN" } { array set parsed_crl [::pki::_parse_pem $crl "-----BEGIN X509 CRL-----" "-----END X509 CRL-----"] set crl $parsed_crl(data) } ::asn::asnGetSequence crl crl_seq ::asn::asnGetSequence crl_seq crl_base ::asn::asnPeekByte crl_base peek_tag if {$peek_tag == 0x02} { #   .CRL ::asn::asnGetInteger crl_base ret(version) incr ret(version) } else { set ret(version) 1 } ::asn::asnGetSequence crl_base crl_full ::asn::asnGetObjectIdentifier crl_full ret(signtype) ::::asn::asnGetSequence crl_base crl_issue set ret(issue) [::pki::x509::_dn_to_string $crl_issue] #     /CRL if {$ret(issue) != $issuer } { #/CRL    set ret(error) "Bad Issuer" return [array get ret] } binary scan $crl_issue H* ret(issue_hex) #  ::asn::asnGetUTCTime crl_base ret(publishDate) #   ::asn::asnGetUTCTime crl_base ret(nextDate) #   ::asn::asnPeekByte crl_base peek_tag if {$peek_tag != 0x30} { #    return [array get ret] } ::asn::asnGetSequence crl_base lcert # binary scan $lcert H* ret(lcert) while {$lcert != ""} { ::asn::asnGetSequence lcert lcerti #    ::asn::asnGetBigInteger lcerti ret(sernumrev) set ret(sernumrev) [::math::bignum::tostr $ret(sernumrev)] #      CRL if {$ret(sernumrev) != $sernum} { continue } # .    ::asn::asnGetUTCTime lcerti ret(revokeDate) if {$lcerti != ""} { #   ::asn::asnGetSequence lcerti lcertir ::asn::asnGetSequence lcertir reasone ::asn::asnGetObjectIdentifier reasone ret(reasone) ::asn::asnGetOctetString reasone reasone2 ::asn::asnGetEnumeration reasone2 ret(reasoneData) } break; } return [array get ret] }</code> </pre></div></div><br>  Los par√°metros para esta funci√≥n son la lista de revocaci√≥n de certificados (crl), el n√∫mero de serie del certificado que se verifica (sernum) y su editor (emisor). <br><br>  La lista de revocaci√≥n de certificados (crl) se carga de la siguiente manera: <br><br><pre> <code class="plaintext hljs">set f [open $filecrl r] chan configure $f -translation binary set crl [read $f] close $f</code> </pre> <br>  El n√∫mero de serie del certificado verificado (sernum) y su editor (emisor) se toman del certificado analizado y se almacenan en las variables :: sncert y :: issuercert. <br><br>  Todos los procedimientos se pueden encontrar en el c√≥digo fuente.  El c√≥digo fuente de la utilidad y sus distribuciones para Linux, OS X (macOS) y MS Windows se pueden encontrar aqu√≠. <br><br><div class="spoiler">  <b class="spoiler_title">aqui</b> <div class="spoiler_text"><ul><li>  <a href="">c√≥digo fuente</a> </li><li>  <a href="">Linux32</a> </li><li>  <a href="">Linux64</a> </li><li>  <a href="">OS X</a> </li><li>  <a href="">WIN32</a> </li><li>  <a href="">WIN64</a> </li></ul><br></div></div><br>  La utilidad tambi√©n conserva la capacidad de ver y verificar los certificados almacenados en un archivo: <br><br><img src="https://habrastorage.org/webt/ja/tv/nl/jatvnlolqcsggytw3nn8x51zpls.png"><br><br>  Por cierto, los certificados vistos de los archivos tambi√©n se pueden exportar, as√≠ como los almacenados en el token.  Esto facilita la conversi√≥n de archivos de certificados del formato DER a PEM y viceversa. <br><br>  Ahora tenemos un √∫nico visor para certificados almacenados tanto en archivos como en tokens / tarjetas inteligentes PKCS # 11. <br><br>  S√≠, perd√≠ el punto: para verificar la validez del certificado, haga clic en el bot√≥n "Adicional" y seleccione el elemento de men√∫ "Validaci√≥n por CRL" o presione el bot√≥n derecho del mouse y cuando el cursor est√© en la informaci√≥n principal campo y tambi√©n seleccione el elemento de men√∫ "Validez por CRL": <br><br><img src="https://habrastorage.org/webt/ig/ph/rm/igphrmcbunw9b8jtkdiepfjaqpm.png"><br><br>  Esta captura de pantalla muestra la exploraci√≥n y validaci√≥n de certificados en un token en la nube. <br><br>  En conclusi√≥n, observamos lo siguiente.  En sus comentarios sobre el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo</a> , el usuario de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">Pas</a> not√≥ muy correctamente acerca de los tokens PKCS # 11 que "ellos mismos pueden contar todo".  S√≠, los tokens son en realidad computadoras criptogr√°ficas.  Y en los siguientes art√≠culos hablaremos no solo de c√≥mo se verifican los certificados utilizando el protocolo OCSP, sino tambi√©n de c√≥mo usar mecanismos criptogr√°ficos (estamos hablando, por supuesto, de la criptograf√≠a GOST) de tokens / inteligencia para calcular el hash (GOST R 34-10- 94/2012), la formaci√≥n y verificaci√≥n de firmas, etc. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443480/">https://habr.com/ru/post/443480/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443468/index.html">¬øQu√© herramientas de monitoreo de red se han convertido en l√≠deres en la versi√≥n de Gartner?</a></li>
<li><a href="../443470/index.html">La historia de escribir en el ejemplo de un gran proyecto</a></li>
<li><a href="../443472/index.html">¬øTienes un problema para ir a la nube? 7 consejos sobre c√≥mo no equivocarte</a></li>
<li><a href="../443476/index.html">C√≥mo SimCity inspir√≥ a toda una generaci√≥n de urbanistas</a></li>
<li><a href="../443478/index.html">Datos de prueba sint√©ticos vs reales: pros, contras, trampas</a></li>
<li><a href="../443482/index.html">AIOps en la pr√°ctica: ¬øqu√© puede hacer Huawei FabricInsight?</a></li>
<li><a href="../443484/index.html">6 hombres inesperados de Julia</a></li>
<li><a href="../443486/index.html">ReLEx SMILE: c√≥mo no cometer errores en las previsiones</a></li>
<li><a href="../443488/index.html">Componentes funcionales con ganchos de reacci√≥n. ¬øPor qu√© son mejores?</a></li>
<li><a href="../443490/index.html">¬øPor qu√© estoy reduciendo mi trabajo en Debian?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>