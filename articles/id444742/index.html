<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📦 🐯 🎐 Indeks dalam PostgreSQL - 5 (GiST) 👨‍👧‍👦 ⏲️ 👗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada artikel sebelumnya, kami membahas mesin pengindeksan PostgreSQL, antarmuka metode akses , dan dua metode akses: indeks hash dan B-tree . Pada art...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indeks dalam PostgreSQL - 5 (GiST)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/444742/">  Pada artikel sebelumnya, kami membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mesin pengindeksan</a> PostgreSQL, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka metode akses</a> , dan dua metode akses: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">indeks hash</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">B-tree</a> .  Pada artikel ini, kami akan menjelaskan indeks GiST. <br><br><h1>  Intisari </h1><br>  GiST adalah singkatan dari "pohon pencarian umum".  Ini adalah pohon pencarian seimbang, seperti "b-tree" yang dibahas sebelumnya. <br><br>  Apa bedanya?  "Btree" indeks secara ketat terhubung ke semantik perbandingan: dukungan dari operator "lebih besar", "kurang", dan "sama" adalah semua yang mampu (tetapi sangat mampu!) Namun, database modern menyimpan tipe data yang digunakan operator ini tidak masuk akal: geodata, dokumen teks, gambar, ... <br><br>  Metode indeks GiST membantu kami untuk tipe data ini.  Ini memungkinkan mendefinisikan aturan untuk mendistribusikan data dari tipe arbitrer di pohon seimbang dan metode untuk menggunakan representasi ini untuk akses oleh beberapa operator.  Misalnya, indeks GiST dapat "mengakomodasi" R-tree untuk data spasial dengan dukungan operator posisi relatif (terletak di sebelah kiri, di sebelah kanan, berisi, dll.) Atau RD-tree untuk set dengan dukungan operator persimpangan atau inklusi. <br><br>  Berkat ekstensibilitas, metode yang sama sekali baru dapat dibuat dari awal di PostgreSQL: untuk tujuan ini, antarmuka dengan mesin pengindeksan harus diimplementasikan.  Tetapi ini membutuhkan perencanaan awal tidak hanya logika pengindeksan, tetapi juga memetakan struktur data ke halaman, implementasi kunci yang efisien, dan dukungan log menulis-depan.  Semua ini mengasumsikan keterampilan pengembang yang tinggi dan upaya manusia yang besar.  GiST menyederhanakan tugas dengan mengambil alih masalah tingkat rendah dan menawarkan antarmuka sendiri: beberapa fungsi yang tidak berkaitan dengan teknik, tetapi untuk domain aplikasi.  Dalam hal ini, kita dapat menganggap GiST sebagai kerangka kerja untuk membangun metode akses baru. <br><a name="habracut"></a><br><h2>  Struktur </h2><br>  GiST adalah pohon seimbang tinggi yang terdiri dari halaman simpul.  Node terdiri dari baris indeks. <br><br>  Setiap baris simpul daun (baris daun), secara umum, berisi beberapa <em>predikat</em> (ekspresi boolean) dan referensi ke baris tabel (TID).  Data yang diindeks (kunci) harus memenuhi predikat ini. <br><br>  Setiap baris dari simpul internal (baris internal) juga berisi <em>predikat</em> dan referensi ke simpul anak, dan semua data yang diindeks dari subtree anak harus memenuhi predikat ini.  Dengan kata lain, predikat baris internal <em>mencakup</em> predikat semua baris anak.  Sifat penting dari indeks GiST ini menggantikan pemesanan sederhana B-tree. <br><br>  Pencarian di pohon GiST menggunakan <em>fungsi konsistensi</em> khusus ("konsisten") - salah satu fungsi yang ditentukan oleh antarmuka dan diimplementasikan dengan caranya sendiri untuk setiap keluarga operator yang didukung. <br><br>  Fungsi konsistensi dipanggil untuk baris indeks dan menentukan apakah predikat baris ini konsisten dengan predikat pencarian (ditentukan sebagai " <em>ekspresi operator bidang-bidang yang diindeks</em> ").  Untuk baris internal, fungsi ini benar-benar menentukan apakah diperlukan untuk turun ke subtree yang sesuai, dan untuk baris daun, fungsi menentukan apakah data yang diindeks memenuhi predikat. <br><br>  Pencarian dimulai dengan simpul akar, sebagai pencarian pohon normal.  Fungsi konsistensi memungkinkan untuk mengetahui node anak mana yang masuk akal (mungkin ada beberapa) dan yang tidak.  Algoritma ini kemudian diulang untuk setiap simpul anak yang ditemukan.  Dan jika simpul adalah daun, baris yang dipilih oleh fungsi konsistensi dikembalikan sebagai salah satu hasilnya. <br><br>  Pencariannya adalah kedalaman-pertama: algoritma pertama-tama mencoba mencapai simpul daun.  Ini memungkinkan untuk mengembalikan hasil pertama segera bila memungkinkan (yang mungkin penting jika pengguna hanya tertarik pada beberapa hasil daripada semuanya). <br><br>  Sekali lagi mari kita perhatikan bahwa fungsi konsistensi tidak perlu ada hubungannya dengan operator "lebih besar", "kurang", atau "sama".  Semantik fungsi konsistensi mungkin sangat berbeda dan oleh karena itu, indeks tidak dianggap menghasilkan nilai dalam urutan tertentu. <br><br>  Kami tidak akan membahas algoritma penyisipan dan penghapusan nilai dalam GiST: beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi antarmuka</a> melakukan operasi ini.  Namun ada satu poin penting.  Ketika nilai baru dimasukkan ke dalam indeks, posisi untuk nilai ini di pohon dipilih sehingga predikat baris induknya diperluas sesedikit mungkin (idealnya, tidak diperpanjang sama sekali).  Tetapi ketika nilai dihapus, predikat baris induk tidak berkurang lagi.  Ini hanya terjadi dalam kasus-kasus seperti ini: halaman dipecah menjadi dua (ketika halaman tidak memiliki cukup ruang untuk memasukkan baris indeks baru) atau indeks dibuat kembali dari awal (dengan perintah REINDEX atau VACUUM FULL).  Oleh karena itu, efisiensi indeks GiST untuk data yang sering berubah dapat menurun seiring waktu. <br><br>  Lebih lanjut kami akan mempertimbangkan beberapa contoh indeks untuk berbagai tipe data dan properti berguna GiST: <br><br><ul><li>  Poin (dan entitas geometris lainnya) dan pencarian tetangga terdekat. </li><li>  Interval dan batasan pengecualian. </li><li>  Pencarian teks lengkap. </li></ul><br><h2>  R-tree untuk poin </h2><br>  Kami akan mengilustrasikan contoh di atas dengan contoh indeks untuk titik-titik dalam bidang (kami juga dapat membuat indeks serupa untuk entitas geometris lainnya).  B-tree reguler tidak cocok dengan tipe data data ini karena tidak ada operator pembanding yang ditentukan untuk poin. <br><br>  Gagasan R-tree adalah untuk membagi pesawat menjadi empat persegi panjang yang secara total mencakup semua poin yang diindeks.  Baris indeks menyimpan persegi panjang, dan predikat dapat didefinisikan seperti ini: "titik yang dicari terletak di dalam persegi panjang yang diberikan". <br><br>  Akar R-tree akan berisi beberapa persegi panjang terbesar (mungkin berpotongan).  Node anak akan berisi persegi panjang ukuran lebih kecil yang tertanam di induknya dan secara total mencakup semua titik yang mendasarinya. <br><br>  Secara teori, node daun harus mengandung titik yang diindeks, tetapi tipe data harus sama di semua baris indeks dan oleh karena itu, lagi persegi panjang disimpan, tetapi "diciutkan" menjadi poin. <br><br>  Untuk memvisualisasikan struktur seperti itu, kami menyediakan gambar untuk tiga tingkat R-tree.  Poin adalah koordinat bandara (mirip dengan yang ada di tabel "bandara" dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">database demo</a> , tetapi lebih banyak data dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">openflights.org</a> disediakan). <br><br><img src="https://habrastorage.org/web/492/fd0/a28/492fd0a2883b4ee39d75618f8f501e50.png"><br>  <em>Tingkat satu: dua persegi panjang berpotongan besar terlihat.</em> <br><br><img src="https://habrastorage.org/web/e42/78d/843/e4278d8439a3485e88128182f741b696.png"><br>  <em>Level dua: persegi panjang besar dibagi menjadi area yang lebih kecil.</em> <br><br><img src="https://habrastorage.org/web/60e/c9d/99b/60ec9d99b4fe46c88bed2a9cc65dd0f5.png"><br>  <em>Level tiga: setiap kotak berisi poin sebanyak yang sesuai dengan satu halaman indeks.</em> <br><br>  Sekarang mari kita perhatikan contoh "satu tingkat" yang sangat sederhana: <br><br><img src="https://habrastorage.org/web/d89/478/666/d894786665774a76943e72338aec874c.png"><br><br><pre><code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> points(p <span class="hljs-type"><span class="hljs-type">point</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> points(p) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(1,1)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(3,2)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(6,3)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(5,5)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(7,8)'</span></span>), (<span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(8,6)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(p);</code> </pre> <br>  Dengan pemisahan ini, struktur indeks akan terlihat sebagai berikut: <br><br><img src="https://habrastorage.org/web/caf/919/8a5/caf9198a538d46f48985d42a301a0b2d.png"><br><br>  Indeks yang dibuat dapat digunakan untuk mempercepat kueri berikut, misalnya: "temukan semua titik yang terkandung dalam kotak yang diberikan".  Kondisi ini dapat diformalkan sebagai berikut: <code>p &lt;@ box '(2,1),(6,3)'</code> (operator <code>&lt;@</code> dari "points_ops" keluarga berarti "terkandung dalam"): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> enable_seqscan = <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------- Index Only Scan using points_p_idx on points Index Cond: (p &lt;@ '(7,4),(2,1)'::box) (2 rows)</code> </pre><br>  Fungsi konsistensi operator (" <em>bidang terindeks</em> &lt;@ <em>ekspresi</em> ", di mana <em>bidang berindeks</em> adalah titik dan <em>ekspresi</em> adalah persegi panjang) didefinisikan sebagai berikut.  Untuk baris internal, ia mengembalikan "ya" jika persegi panjangnya bersinggungan dengan persegi panjang yang ditentukan oleh <em>ekspresi</em> .  Untuk baris daun, fungsi mengembalikan "ya" jika titiknya ("runtuh" ​​persegi panjang) terkandung dalam persegi panjang yang ditentukan oleh ekspresi. <br><br><img src="https://habrastorage.org/web/226/f28/493/226f28493e15430193a69781e1600b9f.png"><br><br>  Pencarian dimulai dengan root node.  Persegi panjang (2,1) - (7,4) berpotongan dengan (1,1) - (6,3), tetapi tidak berpotongan dengan (5,5) - (8,8), oleh karena itu, tidak perlu untuk turun ke subtree kedua. <br><br><img src="https://habrastorage.org/web/d52/792/511/d527925110fb46deadb382762561a621.png"><br><br>  Setelah mencapai simpul daun, kita pergi melalui tiga poin yang terkandung di sana dan mengembalikan dua di antaranya sebagai hasilnya: (3.2) dan (6.3). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p &lt;@ <span class="hljs-type"><span class="hljs-type">box</span></span> <span class="hljs-string"><span class="hljs-string">'(2,1),(7,4)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (3,2) (6,3) (2 rows)</code> </pre><br><h3>  Internal </h3><br>  Sayangnya, "pageinspect" biasa tidak memungkinkan melihat indeks GiST.  Tetapi cara lain tersedia: ekstensi "gevel".  Itu tidak termasuk dalam pengiriman standar, jadi lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">instruksi instalasi</a> . <br><br>  Jika semuanya dilakukan dengan benar, tiga fungsi akan tersedia untuk Anda.  Pertama, kita bisa mendapatkan beberapa statistik: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_stat(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_stat ------------------------------------------ Number of levels: 4 + Number of pages: 690 + Number of leaf pages: 625 + Number of tuples: 7873 + Number of invalid tuples: 0 + Number of leaf tuples: 7184 + Total size of tuples: 354692 bytes + Total size of leaf tuples: 323596 bytes + Total size of index: 5652480 bytes+ (1 row)</code> </pre><br>  Jelas bahwa ukuran indeks pada koordinat bandara adalah 690 halaman dan indeks terdiri dari empat tingkat: root dan dua tingkat internal ditunjukkan pada gambar di atas, dan tingkat keempat adalah daun. <br><br>  Sebenarnya, indeks untuk delapan ribu poin akan secara signifikan lebih kecil: di sini dibuat dengan fillfactor 10% untuk kejelasan. <br><br>  Kedua, kita dapat menampilkan pohon indeks: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_tree(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> gist_tree ----------------------------------------------------------------------------------------- 0(l:0) blk: 0 numTuple: 5 free: 7928b(2.84%) rightlink:4294967295 (InvalidBlockNumber) + 1(l:1) blk: 335 numTuple: 15 free: 7488b(8.24%) rightlink:220 (OK) + 1(l:2) blk: 128 numTuple: 9 free: 7752b(5.00%) rightlink:49 (OK) + 1(l:3) blk: 57 numTuple: 12 free: 7620b(6.62%) rightlink:35 (OK) + 2(l:3) blk: 62 numTuple: 9 free: 7752b(5.00%) rightlink:57 (OK) + 3(l:3) blk: 72 numTuple: 7 free: 7840b(3.92%) rightlink:23 (OK) + 4(l:3) blk: 115 numTuple: 17 free: 7400b(9.31%) rightlink:33 (OK) + ...</code> </pre><br>  Dan ketiga, kita bisa menampilkan data yang disimpan dalam baris indeks.  Perhatikan nuansa berikut: hasil fungsi harus dilemparkan ke tipe data yang dibutuhkan.  Dalam situasi kami, tipe ini adalah "kotak" (persegi panjang pembatas).  Misalnya, perhatikan lima baris di tingkat atas: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'airports_coordinates_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">box</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------------------------------- 1 | (47.663586,80.803207),(-39.2938003540039,-90) 1 | (179.951004028,15.6700000762939),(15.2428998947144,-77.9634017944336) 1 | (177.740997314453,73.5178070068359),(15.0664,10.57970047) 1 | (-77.3191986083984,79.9946975708),(-179.876998901,-43.810001373291) 1 | (-39.864200592041,82.5177993774),(-81.254096984863,-64.2382965088) (5 rows)</code> </pre><br>  Sebenarnya, angka-angka yang diberikan di atas dibuat hanya dari data ini. <br><br><h2>  Operator untuk pencarian dan pemesanan </h2><br>  Operator yang dibahas sejauh ini (seperti <code>&lt;@</code> dalam predikat <code>p &lt;@ box '(2,1),(7,4)'</code> ) dapat disebut operator pencarian karena mereka menentukan kondisi pencarian dalam suatu query. <br><br>  Ada juga tipe operator lain: operator pemesanan.  Mereka digunakan untuk spesifikasi urutan sortir dalam klausa ORDER BY alih-alih spesifikasi konvensional nama kolom.  Berikut ini adalah contoh dari permintaan seperti itu: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> p ------- (5,5) (7,8) (2 rows)</code> </pre><br>  <code>p &lt;-&gt; point '(4,7)'</code> sini adalah ekspresi yang menggunakan operator pemesanan <code>&lt;-&gt;</code> , yang menunjukkan jarak dari satu argumen ke argumen lainnya.  Arti dari kueri adalah mengembalikan dua titik terdekat ke titik (4.7).  Pencarian seperti ini dikenal sebagai k-NN - k-tetangga terdekat pencarian. <br><br>  Untuk mendukung pertanyaan semacam ini, metode akses harus menentukan <em>fungsi jarak</em> tambahan, dan operator pemesanan harus dimasukkan dalam kelas operator yang sesuai (misalnya, kelas "points_ops" untuk poin).  Kueri di bawah ini menunjukkan operator, beserta tipenya ("s" - pencarian dan "o" - pemesanan): <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'point_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------+-------------+-------------- &lt;&lt;(point,point) | s | 1 strictly left &gt;&gt;(point,point) | s | 5 strictly right ~=(point,point) | s | 6 coincides &lt;^(point,point) | s | 10 strictly below &gt;^(point,point) | s | 11 strictly above &lt;-&gt;(point,point) | o | 15 distance &lt;@(point,box) | s | 28 contained in rectangle &lt;@(point,polygon) | s | 48 contained in polygon &lt;@(point,circle) | s | 68 contained in circle (9 rows)</code> </pre><br>  Jumlah strategi juga ditampilkan, dengan artinya dijelaskan.  Jelas bahwa ada lebih banyak strategi daripada "btree", hanya beberapa dari mereka yang didukung untuk poin.  Strategi yang berbeda dapat didefinisikan untuk tipe data lainnya. <br><br>  Fungsi jarak dipanggil untuk elemen indeks, dan itu harus menghitung jarak (dengan mempertimbangkan semantik operator) dari nilai yang ditentukan oleh ekspresi ("ekspresi <em>bidang-operator pemesanan-ekspresi</em> ") ke elemen yang diberikan.  Untuk elemen daun, ini hanya jarak ke nilai yang diindeks.  Untuk elemen internal, fungsi harus mengembalikan jarak minimum ke elemen daun anak.  Karena melalui semua baris anak akan sangat mahal, fungsi ini diizinkan untuk meremehkan jarak secara optimis, tetapi dengan mengorbankan mengurangi efisiensi pencarian.  Namun, fungsi ini tidak pernah diizinkan untuk melebih-lebihkan jarak karena ini akan mengganggu pekerjaan indeks. <br><br>  Fungsi jarak dapat mengembalikan nilai jenis apa pun yang dapat diurutkan (untuk memesan nilai, PostgreSQL akan menggunakan semantik perbandingan dari keluarga operator yang sesuai dari metode akses "btree", seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dijelaskan sebelumnya</a> ). <br><br>  Untuk titik-titik dalam sebuah pesawat, jarak ditafsirkan dalam arti yang sangat biasa: nilai <code>(x1,y1) &lt;-&gt; (x2,y2)</code> sama dengan akar kuadrat dari jumlah kuadrat perbedaan abscissas dan ordinat.  Jarak dari suatu titik ke persegi panjang terikat diambil sebagai jarak minimal dari titik ke persegi panjang ini atau nol jika titik tersebut terletak di dalam persegi panjang.  Mudah untuk menghitung nilai ini tanpa berjalan melalui titik anak, dan nilainya pasti tidak lebih besar dari jarak ke titik anak mana pun. <br><br>  Mari pertimbangkan algoritma pencarian untuk kueri di atas. <br><br><img src="https://habrastorage.org/web/84b/56a/075/84b56a075dbd42d6b5d8cc8cb10c4b01.png"><br><br>  Pencarian dimulai dengan root node.  Node berisi dua persegi panjang yang saling terikat.  Jarak ke (1,1) - (6,3) adalah 4,0 dan ke (5,5) - (8,8) adalah 1,0. <br><br>  Simpul anak dilalui dengan urutan yang meningkatkan jarak.  Dengan cara ini, pertama-tama kita turun ke simpul anak terdekat dan menghitung jarak ke titik (kami akan menunjukkan angka dalam gambar untuk visibilitas): <br><br><img src="https://habrastorage.org/web/491/959/f07/491959f070754781b794e0dff01d5aec.png"><br><br>  Informasi ini cukup untuk mengembalikan dua poin pertama, (5,5) dan (7,8).  Karena kita sadar bahwa jarak ke titik-titik yang terletak di dalam persegi panjang (1,1) - (6,3) adalah 4,0 atau lebih besar, kita tidak perlu turun ke simpul anak pertama. <br><br>  Tetapi bagaimana jika kita perlu menemukan <em>tiga</em> poin pertama? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> points <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> p &lt;-&gt; <span class="hljs-type"><span class="hljs-type">point</span></span> <span class="hljs-string"><span class="hljs-string">'(4,7)'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><pre> <code class="pgsql hljs"> p <span class="hljs-comment"><span class="hljs-comment">------- (5,5) (7,8) (8,6) (3 rows)</span></span></code> </pre><br>  Meskipun simpul anak kedua berisi semua titik ini, kami tidak dapat kembali (8,6) tanpa melihat ke simpul anak pertama karena simpul ini dapat mengandung titik yang lebih dekat (sejak 4,0 &lt;4,1). <br><br><img src="https://habrastorage.org/web/9bb/43a/775/9bb43a775fc445769e37af8bb50daae0.png"><br><br>  Untuk baris internal, contoh ini menjelaskan persyaratan untuk fungsi jarak.  Dengan memilih jarak yang lebih kecil (4,0 bukannya 4,5 sebenarnya) untuk baris kedua, kami mengurangi efisiensi (algoritma perlu mulai memeriksa node tambahan), tetapi tidak merusak kebenaran algoritma. <br><br>  Sampai saat ini, GiST adalah satu-satunya metode akses yang mampu menangani operator pemesanan.  Tetapi situasinya telah berubah: metode akses RUM (akan dibahas lebih lanjut) telah bergabung dengan kelompok metode ini, dan bukan tidak mungkin pohon B-tua yang baik akan bergabung dengan mereka: patch yang dikembangkan oleh Nikita Glukhov, kolega kami, sedang dibahas oleh masyarakat. <br><blockquote>  Pada Maret 2019, dukungan k-NN ditambahkan untuk SP-GiST di PostgreSQL 12 mendatang (juga ditulis oleh Nikita).  Patch untuk B-tree masih dalam proses. <br></blockquote><br><h2>  R-tree untuk interval </h2><br>  Contoh lain menggunakan metode akses GiST adalah pengindeksan interval, misalnya, interval waktu (tipe "tsrange").  Semua perbedaannya adalah bahwa node internal akan berisi interval pembatas bukannya persegi panjang pembatas. <br><br>  Mari kita perhatikan contoh sederhana.  Kami akan menyewakan pondok dan menyimpan interval pemesanan dalam sebuah tabel: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations(during <span class="hljs-type"><span class="hljs-type">tsrange</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2016-12-30, 2017-01-09)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-02-23, 2017-02-27)'</span></span>), (<span class="hljs-string"><span class="hljs-string">'[2017-04-29, 2017-05-02)'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during);</code> </pre><br>  Indeks dapat digunakan untuk mempercepat kueri berikut, misalnya: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> during ----------------------------------------------- ["2016-12-30 00:00:00","2017-01-08 00:00:00") ["2017-02-23 00:00:00","2017-02-26 00:00:00") (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> during &amp;&amp; <span class="hljs-string"><span class="hljs-string">'[2017-01-01, 2017-04-01)'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Index Only Scan using reservations_during_idx on reservations Index Cond: (during &amp;&amp; '["2017-01-01 00:00:00","2017-04-01 00:00:00")'::tsrange) (2 rows)</code> </pre><br>  <code>&amp;&amp;</code> operator untuk interval menunjukkan persimpangan;  Oleh karena itu, kueri harus mengembalikan semua interval yang bersinggungan dengan yang diberikan.  Untuk operator seperti itu, fungsi konsistensi menentukan apakah interval yang diberikan berpotongan dengan nilai dalam baris internal atau daun. <br><br>  Perhatikan bahwa ini bukan tentang mendapatkan interval dalam urutan tertentu, meskipun operator perbandingan ditentukan untuk interval.  Kita dapat menggunakan indeks "btree" untuk interval, tetapi dalam kasus ini, kita harus melakukannya tanpa dukungan operasi seperti ini: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> amop.amopopr::<span class="hljs-type"><span class="hljs-type">regoperator</span></span>, amop.amoppurpose, amop.amopstrategy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pg_opclass opc, pg_opfamily opf, pg_am am, pg_amop amop <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> opc.opcname = <span class="hljs-string"><span class="hljs-string">'range_ops'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opf.oid = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.oid = opf.opfmethod <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amopfamily = opc.opcfamily <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> am.amname = <span class="hljs-string"><span class="hljs-string">'gist'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> amop.amoplefttype = opc.opcintype;</code> </pre><pre> <code class="plaintext hljs"> amopopr | amoppurpose | amopstrategy -------------------------+-------------+-------------- @&gt;(anyrange,anyelement) | s | 16 contains element &lt;&lt;(anyrange,anyrange) | s | 1 strictly left &amp;&lt;(anyrange,anyrange) | s | 2 not beyond right boundary &amp;&amp;(anyrange,anyrange) | s | 3 intersects &amp;&gt;(anyrange,anyrange) | s | 4 not beyond left boundary &gt;&gt;(anyrange,anyrange) | s | 5 strictly right -|-(anyrange,anyrange) | s | 6 adjacent @&gt;(anyrange,anyrange) | s | 7 contains interval &lt;@(anyrange,anyrange) | s | 8 contained in interval =(anyrange,anyrange) | s | 18 equals (10 rows)</code> </pre><br>  (Kecuali kesetaraan, yang terkandung dalam kelas operator untuk metode akses "btree".) <br><br><h3>  Internal </h3><br>  Kita bisa melihat ke dalam menggunakan ekstensi "gevel" yang sama.  Kita hanya perlu ingat untuk mengubah tipe data dalam panggilan ke gist_print: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'reservations_during_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a <span class="hljs-type"><span class="hljs-type">tsrange</span></span>);</code> </pre><pre> <code class="plaintext hljs"> level | a -------+----------------------------------------------- 1 | ["2016-12-30 00:00:00","2017-01-09 00:00:00") 1 | ["2017-02-23 00:00:00","2017-02-27 00:00:00") 1 | ["2017-04-29 00:00:00","2017-05-02 00:00:00") (3 rows)</code> </pre><br><h2>  Batasan pengecualian </h2><br>  Indeks GiST dapat digunakan untuk mendukung batasan eksklusi (TERKECUALI). <br><br>  Batasan pengecualian memastikan bidang yang diberikan dari setiap dua baris tabel untuk tidak "berkorespondensi" satu sama lain dalam hal beberapa operator.  Jika operator "equals" dipilih, kami mendapatkan batasan unik: bidang yang diberikan dari dua baris tidak sama satu sama lain. <br><br>  Batasan pengecualian didukung oleh indeks, serta kendala unik.  Kami dapat memilih operator mana saja sehingga: <br><br><ol><li>  Ini didukung oleh metode indeks - properti "can_exclude" (misalnya, "btree", GiST, atau SP-GiST, tetapi tidak GIN). </li><li>  Itu komutatif, yaitu, kondisi terpenuhi: operator b = b operator a. </li></ol><br>  Ini adalah daftar strategi dan contoh operator yang sesuai (operator, seperti yang kita ingat, dapat memiliki nama yang berbeda dan tersedia tidak untuk semua tipe data): <br><br><ul><li>  Untuk "btree": <br><ul><li>  "Setara" <code>=</code> </li></ul></li><li>  Untuk GiST dan SP-GiST: <br><ul><li>  "Persimpangan" <code>&amp;&amp;</code> </li><li>  "Kebetulan" <code>~=</code> </li><li>  Adjacency <code>-|-</code> </li></ul></li></ul><br>  Perhatikan bahwa kita dapat menggunakan operator kesetaraan dalam batasan pengecualian, tetapi tidak praktis: kendala unik akan lebih efisien.  Itulah mengapa kami tidak menyentuh batasan eksklusi ketika kami membahas B-tree. <br><br>  Mari kita berikan contoh menggunakan batasan pengecualian.  Adalah masuk akal untuk tidak mengizinkan reservasi untuk interval yang berpotongan. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;);</code> </pre><br>  Setelah kami membuat batasan pengecualian, kami dapat menambahkan baris: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-06-10, 2017-06-13)'</span></span>);</code> </pre><br>  Tetapi upaya untuk memasukkan interval berpotongan ke dalam tabel akan menghasilkan kesalahan: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_excl" DETAIL: Key (during)=(["2017-05-15 00:00:00","2017-06-15 00:00:00")) conflicts with existing key (during)=(["2017-06-10 00:00:00","2017-06-13 00:00:00")).</code> </pre><br><h3>  Ekstensi "Btree_gist" </h3><br>  Mari kita memperumit masalah.  Kami mengembangkan bisnis kami yang sederhana, dan kami akan menyewakan beberapa pondok: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> house_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  Kita perlu mengubah batasan pengecualian sehingga nomor rumah diperhitungkan.  GiST, bagaimanapun, tidak mendukung operasi kesetaraan untuk bilangan bulat: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> reservations_during_excl; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><pre> <code class="plaintext hljs">ERROR: data type integer has no default operator class for access method "gist" HINT: You must specify an operator class for the index or define a default operator class for the data type.</code> </pre><br>  Dalam hal ini, ekstensi " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">btree_gist</a> " akan membantu, yang menambahkan dukungan GiST terhadap operasi yang melekat pada B-tree.  GiST, pada akhirnya, dapat mendukung operator mana pun, jadi mengapa kita tidak mengajarkannya untuk mendukung operator "lebih besar", "kurang", dan "setara"? <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extension</span></span> btree_gist; postgres=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> reservations <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exclude</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(during <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> &amp;&amp;, house_no <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> =);</code> </pre><br>  Sekarang kami masih belum dapat memesan pondok pertama untuk tanggal yang sama: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs">ERROR: conflicting key value violates exclusion constraint "reservations_during_house_no_excl"</code> </pre><br>  Namun, kami dapat memesan yang kedua: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> reservations(during, house_no) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'[2017-05-15, 2017-06-15)'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Namun ketahuilah bahwa meskipun GiST dapat mendukung operator "lebih besar", "kurang", dan "setara", B-tree masih melakukan ini dengan lebih baik.  Jadi layak menggunakan teknik ini hanya jika indeks GiST pada dasarnya diperlukan, seperti dalam contoh kita. <br><br><h2>  RD-tree untuk pencarian teks lengkap </h2><br><h3>  Tentang pencarian teks lengkap </h3><br>  Mari kita mulai dengan pengantar minimalis untuk pencarian teks lengkap PostgreSQL (jika Anda tahu, Anda dapat melewati bagian ini). <br><br>  Tugas pencarian teks lengkap adalah memilih dari kumpulan dokumen dokumen yang <em>sesuai</em> dengan permintaan pencarian.  (Jika ada banyak dokumen yang cocok, penting untuk menemukan <em>yang cocok</em> , tetapi kami tidak akan mengatakan apa-apa tentang hal ini pada saat ini.) <br><br>  Untuk keperluan pencarian, dokumen dikonversi ke tipe khusus "tsvector", yang berisi <em>leksem</em> dan posisinya dalam dokumen.  Lexeme adalah kata-kata yang dikonversi ke bentuk yang cocok untuk pencarian.  Misalnya, kata-kata biasanya dikonversi menjadi huruf kecil, dan ujung variabel terpotong: <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsvector ----------------------------------------- 'crook':4,10 'man':5 'mile':11 'walk':8 (1 row)</code> </pre><br>  Kita juga dapat melihat bahwa beberapa kata (disebut <em>kata berhenti</em> ) benar-benar dijatuhkan ("di sana", "adalah", "a", "dan", "dia") karena kata-kata itu agaknya sering terjadi sehingga pencarian kata-kata itu tidak masuk akal.  Semua konversi ini tentu saja dapat dikonfigurasi, tapi itu cerita lain. <br><br>  Permintaan pencarian diwakili dengan tipe lain: "tsquery".  Secara kasar, kueri terdiri dari satu atau beberapa leksem yang dihubungkan oleh penghubung: "dan" &amp;, "atau" |, "tidak"! .. Kita juga dapat menggunakan tanda kurung untuk memperjelas prioritas operasi. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> to_tsquery ---------------------------- 'man' &amp; ( 'walk' | 'run' ) (1 row)</code> </pre><br>  Hanya satu operator <code>@@</code> cocok digunakan untuk pencarian teks lengkap. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (walking | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- t (1 row)</code> </pre><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> to_tsvector(<span class="hljs-string"><span class="hljs-string">'There was a crooked man, and he walked a crooked mile'</span></span>) @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'man &amp; (going | running)'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ---------- f (1 row)</code> </pre><br>  Informasi ini cukup untuk saat ini.  Kami akan terjun sedikit lebih dalam ke pencarian teks lengkap di artikel berikutnya yang menampilkan indeks GIN. <br><br><h3>  RD-pohon </h3><br>  Untuk pencarian teks lengkap cepat, pertama, tabel perlu menyimpan kolom tipe "tsvector" (untuk menghindari melakukan konversi yang mahal setiap kali mencari) dan kedua, indeks harus dibangun pada kolom ini.  Salah satu metode akses yang mungkin untuk ini adalah GiST. <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> ts(doc <span class="hljs-type"><span class="hljs-type">text</span></span>, doc_tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(doc_tsv); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> ts(doc) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (<span class="hljs-string"><span class="hljs-string">'Can a sheet slitter slit sheets?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'How many sheets could a sheet slitter slit?'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit a sheet, a sheet I slit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Upon a slitted sheet I sit.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Whoever slit the sheets is a good sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am a sheet slitter.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'I am the sleekest sheet slitter that ever slit sheets.'</span></span>), (<span class="hljs-string"><span class="hljs-string">'She slits the sheet she sits on.'</span></span>); postgres=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> ts <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> doc_tsv = to_tsvector(doc);</code> </pre><br>  Tentu saja nyaman untuk mempercayakan pemicu dengan langkah terakhir (konversi dokumen ke "tsvector"). <br><br><pre> <code class="pgsql hljs">postgres=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ts;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]---------------------------------------------------- doc | Can a sheet slitter slit sheets? doc_tsv | 'sheet':3,6 'slit':5 'slitter':4 -[ RECORD 2 ]---------------------------------------------------- doc | How many sheets could a sheet slitter slit? doc_tsv | 'could':4 'mani':2 'sheet':3,6 'slit':8 'slitter':7 -[ RECORD 3 ]---------------------------------------------------- doc | I slit a sheet, a sheet I slit. doc_tsv | 'sheet':4,6 'slit':2,8 -[ RECORD 4 ]---------------------------------------------------- doc | Upon a slitted sheet I sit. doc_tsv | 'sheet':4 'sit':6 'slit':3 'upon':1 -[ RECORD 5 ]---------------------------------------------------- doc | Whoever slit the sheets is a good sheet slitter. doc_tsv | 'good':7 'sheet':4,8 'slit':2 'slitter':9 'whoever':1 -[ RECORD 6 ]---------------------------------------------------- doc | I am a sheet slitter. doc_tsv | 'sheet':4 'slitter':5 -[ RECORD 7 ]---------------------------------------------------- doc | I slit sheets. doc_tsv | 'sheet':3 'slit':2 -[ RECORD 8 ]---------------------------------------------------- doc | I am the sleekest sheet slitter that ever slit sheets. doc_tsv | 'ever':8 'sheet':5,10 'sleekest':4 'slit':9 'slitter':6 -[ RECORD 9 ]---------------------------------------------------- doc | She slits the sheet she sits on. doc_tsv | 'sheet':4 'sit':6 'slit':2</code> </pre><br>  Bagaimana seharusnya indeks disusun?  Penggunaan R-tree secara langsung bukan merupakan pilihan karena tidak jelas cara mendefinisikan "recting rectangle" untuk dokumen.  Tapi kita bisa menerapkan beberapa modifikasi dari pendekatan ini untuk set, yang disebut RD-tree (RD singkatan dari "Russian Doll").  Suatu himpunan dipahami sebagai himpunan leksem dalam kasus ini, tetapi secara umum, himpunan dapat berupa apa saja. <br><br>  Gagasan RD-tree adalah untuk mengganti persegi panjang pembatas dengan set pembatas, yaitu, set yang berisi semua elemen set anak. <br><br>  Sebuah pertanyaan penting muncul bagaimana merepresentasikan set dalam baris indeks.  Cara yang paling mudah adalah menghitung semua elemen himpunan.  Ini mungkin terlihat sebagai berikut: <br><br><img src="https://habrastorage.org/webt/cp/ul/cx/cpulcxgydwxo8fl0ul0bdlsn3ws.png"><br><br>  Kemudian misalnya, untuk akses dengan syarat <code>doc_tsv @@ to_tsquery('sit')</code> kita hanya bisa turun ke simpul-simpul yang mengandung lexeme "duduk": <br><br><img src="https://habrastorage.org/webt/h9/2g/4j/h92g4jpzw_7wj-x3katxlwrw3ac.png"><br><br>  Representasi ini memiliki masalah yang jelas.  Jumlah leksem dalam sebuah dokumen bisa sangat besar, sehingga baris indeks akan memiliki ukuran besar dan masuk ke TOAST, membuat indeks jauh lebih efisien.  Bahkan jika setiap dokumen memiliki beberapa leksem unik, gabungan set mungkin masih sangat besar: semakin tinggi ke root baris indeks yang lebih besar. <br><br>  Representasi seperti ini kadang-kadang digunakan, tetapi untuk tipe data lainnya.  Dan pencarian teks lengkap menggunakan solusi lain yang lebih ringkas - yang disebut <em>pohon tanda tangan</em> .  Idenya cukup akrab bagi semua yang berurusan dengan filter Bloom. <br><br>  Setiap leksem dapat diwakili dengan <em>tanda tangannya</em> : string bit dengan panjang tertentu di mana semua bit kecuali satu adalah nol.  Posisi bit ini ditentukan oleh nilai fungsi hash dari lexeme (kami membahas internal fungsi hash <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebelumnya</a> ). <br><br>  Tanda tangan dokumen adalah bitwise ATAU dari tanda tangan semua leksem dokumen. <br><br>  Mari kita asumsikan tanda tangan leksem berikut: <br><br><pre> bisa 1.000.000
 pernah 0001000
 bagus 0000010
 mani 0000100
 sheet 0000100
 sleekest 0100000
 duduk 0010000
 celah 0001000
 slitter 0000001
 pada 0000010
 siapapun 0010000
</pre><br>  Maka tanda tangan dokumen adalah seperti ini: <br><br><pre> Bisakah lembaran slitter slit sheet?  0001101
 Berapa banyak lembaran yang bisa memotong lembaran slitter?  1001101
 Saya memotong lembaran, lembaran saya memotong.  0001100
 Di atas selembar slitted saya duduk.  0011110
 Siapa pun yang menggorok lembaran itu adalah pemotong lembaran yang bagus.  0011111
 Saya seorang slitter sheet.  0000101
 Saya memotong lembaran.  0001100
 Saya slitter sheet paling licin yang pernah memotong lembaran.  0101101
 Dia memotong lembaran yang dia duduki.  0011100
</pre><br>  Pohon indeks dapat direpresentasikan sebagai berikut: <br><br><img src="https://habrastorage.org/webt/ou/f9/gz/ouf9gz7l7wgmgmgzi5gik7nrg50.png"><br><br>  Keuntungan dari pendekatan ini jelas: baris indeks memiliki ukuran kecil yang sama, dan indeks tersebut kompak.  Namun kelemahannya juga jelas: akurasi dikorbankan untuk kekompakan. <br><br>  Mari pertimbangkan kondisi yang sama <code>doc_tsv @@ to_tsquery('sit')</code> .  Dan mari kita menghitung tanda tangan dari permintaan pencarian dengan cara yang sama seperti untuk dokumen: 0010000 dalam hal ini.  Fungsi konsistensi harus mengembalikan semua simpul turunan yang tanda tangannya mengandung setidaknya satu bit dari tanda tangan kueri: <br><br><img src="https://habrastorage.org/webt/qi/qm/l4/qiqml4l5yu8_qiyvidk-3j8iqhs.png"><br><br>  Bandingkan dengan gambar di atas: kita dapat melihat bahwa pohon menjadi kuning, yang berarti bahwa false positive terjadi dan node berlebihan dilalui selama pencarian.  Di sini kami mengambil leksem "siapa pun", yang tanda tangannya sayangnya sama dengan tanda tangan leksem "duduk".  Sangat penting bahwa tidak ada negatif palsu dapat terjadi dalam pola, yaitu, kami yakin tidak akan melewatkan nilai yang dibutuhkan. <br><br>  Selain itu, bisa jadi terjadi bahwa dokumen yang berbeda juga akan mendapatkan tanda tangan yang sama: dalam contoh kita, dokumen yang tidak beruntung adalah "Saya memotong lembaran, lembaran saya memotong" dan "Saya memotong lembaran" (keduanya memiliki tanda tangan 0001100).  Dan jika baris indeks daun tidak menyimpan nilai "tsvector", indeks itu sendiri akan memberikan false positive.  Tentu saja, dalam hal ini, metode akan meminta mesin pengindeksan untuk memeriksa kembali hasil dengan tabel, sehingga pengguna tidak akan melihat positif palsu ini.  Tetapi efisiensi pencarian dapat terganggu. <br><br>  Sebenarnya, tanda tangan berukuran 124 byte dalam implementasi saat ini, bukan 7-bit dalam gambar, sehingga masalah di atas jauh lebih kecil kemungkinannya terjadi daripada dalam contoh.  Namun dalam kenyataannya, lebih banyak dokumen yang diindeks juga.  Untuk mengurangi jumlah kesalahan positif dari metode indeks, penerapannya menjadi sedikit rumit: "tsvector" yang diindeks disimpan dalam baris indeks daun, tetapi hanya jika ukurannya tidak besar (sedikit kurang dari 1/16 dari halaman, yaitu sekitar setengah kilobyte untuk halaman 8-KB). <br><br><h3>  Contoh </h3><br>  Untuk melihat bagaimana pengindeksan bekerja pada data aktual, mari kita ambil arsip email "pgsql-hacker".  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Versi yang digunakan dalam contoh</a> berisi 356125 pesan dengan tanggal kirim, subjek, penulis, dan teks: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> sent <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------------------------------------------------------------ id | 1572389 parent_id | 1562808 sent | 1997-06-24 11:31:09 subject | Re: [HACKERS] Array bug is still there.... author | "Thomas G. Lockhart" &lt;Thomas.Lockhart@jpl.nasa.gov&gt; body_plain | Andrew Martin wrote: + | &gt; Just run the regression tests on 6.1 and as I suspected the array bug + | &gt; is still there. The regression test passes because the expected output+ | &gt; has been fixed to the *wrong* output. + | + | OK, I think I understand the current array behavior, which is apparently+ | different than the behavior for v1.0x. + ...</code> </pre><br>  Menambahkan dan mengisi kolom tipe "tsvector" dan membangun indeks.  Di sini kita akan menggabungkan tiga nilai dalam satu vektor (subjek, penulis, dan teks pesan) untuk menunjukkan bahwa dokumen tidak perlu menjadi satu bidang, tetapi dapat terdiri dari bagian-bagian acak yang sama sekali berbeda. <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">alter</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> tsv <span class="hljs-type"><span class="hljs-type">tsvector</span></span>; fts=# <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> tsv = to_tsvector(subject||<span class="hljs-string"><span class="hljs-string">' '</span></span>||author||<span class="hljs-string"><span class="hljs-string">' '</span></span>||body_plain);</code> </pre><pre> <code class="plaintext hljs">NOTICE: word is too long to be indexed DETAIL: Words longer than 2047 characters are ignored. ... UPDATE 356125</code> </pre><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist(tsv);</code> </pre><br>  Seperti yang bisa kita lihat, sejumlah kata dijatuhkan karena ukurannya yang terlalu besar.  Tetapi indeks akhirnya dibuat dan dapat mendukung permintaan pencarian: <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">costs</span></span> <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mail_messages <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> tsv @@ to_tsquery(<span class="hljs-string"><span class="hljs-string">'magic &amp; value'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------- Index Scan using mail_messages_tsv_idx on mail_messages (actual time=0.998..416.335 rows=898 loops=1) Index Cond: (tsv @@ to_tsquery('magic &amp; value'::text)) Rows Removed by Index Recheck: 7859 Planning time: 0.203 ms Execution time: 416.492 ms (5 rows)</code> </pre><br>  Kita dapat melihat bahwa bersama dengan 898 baris yang cocok dengan kondisi tersebut, metode akses mengembalikan 7859 lebih banyak baris yang difilter dengan mengecek ulang dengan tabel.  Ini menunjukkan dampak negatif dari hilangnya akurasi pada efisiensi. <br><br><h3>  Internal </h3><br>  Untuk menganalisis konten indeks, kami akan kembali menggunakan ekstensi "gevel": <br><br><pre> <code class="pgsql hljs">fts=# <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">level</span></span>, a <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gist_print(<span class="hljs-string"><span class="hljs-string">'mail_messages_tsv_idx'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> t(<span class="hljs-keyword"><span class="hljs-keyword">level</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> <span class="hljs-type"><span class="hljs-type">bool</span></span>, a gtsvector) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;</code> </pre><pre> <code class="plaintext hljs"> level | a -------+------------------------------- 1 | 992 true bits, 0 false bits 2 | 988 true bits, 4 false bits 3 | 573 true bits, 419 false bits 4 | 65 unique words 4 | 107 unique words 4 | 64 unique words 4 | 42 unique words ...</code> </pre><br>  Nilai dari tipe khusus "gtsvector" yang disimpan dalam baris indeks sebenarnya adalah tanda tangan plus, mungkin, sumber "tsvector".  Jika vektor tersedia, output berisi jumlah leksem (kata-kata unik), jika tidak, jumlah bit benar dan salah dalam tanda tangan. <br><br>  Jelas bahwa dalam simpul akar, tanda tangan berubah menjadi "semua yang", yaitu, satu tingkat indeks menjadi sama sekali tidak berguna (dan satu lagi menjadi hampir tidak berguna, dengan hanya empat bit salah). <br><br><h2>  Properti </h2><br>  Mari kita lihat sifat-sifat metode akses GiST (pertanyaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">disediakan sebelumnya</a> ): <br><br><pre> <code class="plaintext hljs"> amname | name | pg_indexam_has_property --------+---------------+------------------------- gist | can_order | f gist | can_unique | f gist | can_multi_col | t gist | can_exclude | t</code> </pre><br>  Penyortiran nilai dan batasan unik tidak didukung.  Seperti yang telah kita lihat, indeks dapat dibangun di beberapa kolom dan digunakan dalam batasan pengecualian. <br><br>  Properti lapisan indeks berikut tersedia: <br><br><pre> <code class="plaintext hljs"> name | pg_index_has_property ---------------+----------------------- clusterable | t index_scan | t bitmap_scan | t backward_scan | f</code> </pre><br>  Dan sifat yang paling menarik adalah dari lapisan kolom.  Beberapa properti tidak tergantung pada kelas operator: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ asc | f desc | f nulls_first | f nulls_last | f orderable | f search_array | f search_nulls | t</code> </pre><br>  (Penyortiran tidak didukung; indeks tidak dapat digunakan untuk mencari array; NULL didukung.) <br><br>  Tetapi dua properti yang tersisa, "distance_orderable" dan "returnable", akan tergantung pada kelas operator yang digunakan.  Misalnya, untuk poin kita akan mendapatkan: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | t returnable | t</code> </pre><br>  Properti pertama memberi tahu bahwa operator jarak tersedia untuk mencari tetangga terdekat.  Dan yang kedua memberi tahu bahwa indeks dapat digunakan untuk memindai hanya indeks.  Meskipun baris indeks daun menyimpan persegi panjang daripada titik, metode akses dapat mengembalikan apa yang dibutuhkan. <br><br>  Berikut ini adalah properti untuk interval: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | t</code> </pre><br>  Untuk interval, fungsi jarak tidak ditentukan dan oleh karena itu, pencarian tetangga terdekat tidak dimungkinkan. <br><br>  Dan untuk pencarian teks lengkap, kami mendapatkan: <br><br><pre> <code class="plaintext hljs"> name | pg_index_column_has_property --------------------+------------------------------ distance_orderable | f returnable | f</code> </pre><br>  Dukungan pemindaian hanya indeks telah hilang sejak baris daun hanya dapat berisi tanda tangan tanpa data itu sendiri.  Namun, ini adalah kerugian kecil karena tidak ada yang tertarik pada nilai tipe "tsvector": nilai ini digunakan untuk memilih baris, sementara itu adalah teks sumber yang perlu ditampilkan, tetapi tetap tidak ada dalam indeks. <br><br><h2>  Tipe data lainnya </h2><br>  Terakhir, kami akan menyebutkan beberapa jenis lagi yang saat ini didukung oleh metode akses GiST selain jenis geometris yang telah dibahas (dengan contoh poin), interval, dan jenis pencarian teks lengkap. <br><br>  Dari tipe standar, ini adalah tipe " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">inet</a> " untuk alamat IP.  Semua ditambahkan melalui ekstensi: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kubus</a> menyediakan tipe data "kubus" untuk kubus multi-dimensi.  Untuk tipe ini, seperti halnya tipe geometris dalam pesawat, kelas operator GiST didefinisikan: R-tree, mendukung pencarian tetangga terdekat. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">seg</a> menyediakan tipe data "seg" untuk interval dengan batas yang ditentukan untuk akurasi tertentu dan menambahkan dukungan indeks GiST untuk tipe data ini (R-tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">intarray</a> memperluas fungsi array integer dan menambahkan dukungan GiST untuk mereka.  Dua kelas operator diimplementasikan: "gist__int_ops" (RD-tree dengan representasi penuh kunci dalam baris indeks) dan "gist__bigint_ops" (signature RD-tree).  Kelas pertama dapat digunakan untuk array kecil, dan yang kedua - untuk ukuran yang lebih besar. <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ltree</a> menambahkan tipe data "ltree" untuk struktur seperti pohon dan dukungan GiST untuk tipe data ini (RD-tree). <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pg_trgm</a> menambahkan kelas operator khusus "gist_trgm_ops" untuk penggunaan trigram dalam pencarian teks lengkap.  Tapi ini akan dibahas lebih lanjut, bersama dengan indeks GIN. <br></li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Baca terus</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444742/">https://habr.com/ru/post/id444742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444728/index.html">Ketika saya menulis dan menerbitkan buku tentang Universitas Negeri Moskow, atau 12 kesalahan kritis</a></li>
<li><a href="../id444730/index.html">Mengapa teknologi tanpa server adalah revolusi dalam manajemen produk</a></li>
<li><a href="../id444732/index.html">Apache optimasi kinerja2</a></li>
<li><a href="../id444734/index.html">Habraseminar: kisah nyata tentang pemasaran konten</a></li>
<li><a href="../id444738/index.html">Pixel art: dari draft ke aset game</a></li>
<li><a href="../id444744/index.html">Mengirim email menggunakan PHP</a></li>
<li><a href="../id444746/index.html">Kami mengundang Anda ke MskDotNet Meetup # 34 di Raiffeisenbank upd Broadcast</a></li>
<li><a href="../id444748/index.html">3 kualitas utama dari manajer produk yang sukses: Yuri Golikov, VP of Engineering Wrike</a></li>
<li><a href="../id444752/index.html">Sejarah SXSW: Bagaimana Semuanya Dimulai</a></li>
<li><a href="../id444756/index.html">DARPA akan mengembangkan mesin nuklir roket</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>