<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛄 🦔 🥃 再次进入太空：独角兽恒星如何参观 🍩 📍 〽️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在他们整个生存期间，人们付出了巨大的努力来研究几乎整个星空。 迄今为止，我们已经检查了成千上万的小行星，彗星，星云和恒星，星系和行星。 要亲自看到所有这些美丽，不必离开屋子并自己买望远镜。 您可以在计算机上安装Stellarium（一个虚拟天象仪），并看着舒适地躺在沙发上的夜空……但是舒适吗？ 为了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>再次进入太空：独角兽恒星如何参观</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/432954/"> 在他们整个生存期间，人们付出了巨大的努力来研究几乎整个星空。 迄今为止，我们已经检查了成千上万的小行星，彗星，星云和恒星，星系和行星。 要亲自看到所有这些美丽，不必离开屋子并自己买望远镜。 您可以在计算机上安装Stellarium（一个虚拟天象仪），并看着舒适地躺在沙发上的夜空……但是舒适吗？ 为了找到该问题的答案，我们将检查Stellarium中的计算机代码是否有错误。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/c8b/129/4b8c8b12983537442bfea4700cadca97.png"></div><br><a name="habracut"></a><br><h2> 关于项目的一点点... </h2><br> 根据Wikipedia网站上的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">描述</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Stellarium</a>是可用于Linux，Mac OS X，Microsoft Windows，Symbian，Android和iOS以及MeeGo的开源虚拟天象馆。 该程序使用OpenGL和Qt技术实时创建真实的天空。 使用Stellarium，您可以看到用中型甚至大型望远镜看到的东西。 该程序还提供日食和彗星运动的观测。 <br><br>  Stellarium由法国程序员Fabian Chereau创建，他于2001年夏季启动了该项目。 其他杰出的开发商包括Robert Spearman，Johannes Gadzhozik，Matthew Gates，Timothy Reeves，Bogdan Marinov和Johan Meeris，他们负责艺术品。 <br><br><h2>  ...关于分析仪 </h2><br> 使用PVS-Studio静态代码分析器进行了项目分析。 这是一个用于检测用C，C ++和C＃编写的程序的源代码中的错误和潜在漏洞的工具（Java很快！）。 它可以在Windows，Linux和macOS上运行。 它是为那些需要提高代码质量的人而设计的。 <br><br> 分析非常简单。 首先，我从GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">下载</a>了Stellarium项目，然后安装了组装所需的所有软件包。 由于该项目是使用Qt Creator构建的，因此我使用了编译器启动跟踪系统，该系统内置在分析仪的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">独立</a>版本中。 您可以在那里查看完成的分析报告。 <br><br>  <b><i>Stellarium的</i></b>新读者和用户可能会感到奇怪：为什么独角兽出现在文章标题中，它与代码分析有何关系？ 我回答：我是PVS-Studio的开发商之一，而独角兽是我们最喜欢的顽皮吉祥物。 起来了！ <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bfc/8f2/aab/bfc8f2aaba0bf61f3b40d4d0765dd027.png"></div><br> 我希望感谢本文，使读者能够自己学习一些新东西，而Stellarium开发人员将能够消除一些错误并提高代码质量。 <br><br> 为咖啡配上羊角面包，让自己舒适，因为我们将介绍最有趣的部分-分析结果概述和错误分析！ <br><br><h2> 可疑情况 </h2><br> 为了获得更大的阅读乐趣，我建议不要直接看分析仪的警告，而要自己尝试进一步检查错误。 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QZipReaderPrivate::scanFiles() { .... <span class="hljs-comment"><span class="hljs-comment">// find EndOfDirectory header int i = 0; int start_of_directory = -1; EndOfDirectory eod; while (start_of_directory == -1) { const int pos = device-&gt;size() - int(sizeof(EndOfDirectory)) - i; if (pos &lt; 0 || i &gt; 65535) { qWarning() &lt;&lt; "QZip: EndOfDirectory not found"; return; } device-&gt;seek(pos); device-&gt;read((char *)&amp;eod, sizeof(EndOfDirectory)); if (readUInt(eod.signature) == 0x06054b50) break; ++i; } .... }</span></span></code> </pre> <br>  <b>PVS-Studio</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">警告</a> <b>：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V654循环</a>的条件“ start_of_directory ==-1”始终为true。  qzip.cpp 617 <br><br> 你能找到一个错误吗？ 如果是这样，那就称赞。 <br><br> 错误在于<i>while循环的情况</i> 。 总是如此，因为变量<i>start_of_directory</i>在循环体中不会更改。 循环很可能不会是永恒的，因为它包含<i>return</i>和<i>break</i> ，但是这样的代码看起来很奇怪。 <br><br> 在我看来，他们在代码中忘记了在验证签名的地方进行分配<i>start_of_directory = pos</i> 。 那么<i>break</i>语句可能是多余的。 在这种情况下，可以这样重写代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> start_of_directory = <span class="hljs-number"><span class="hljs-number">-1</span></span>; EndOfDirectory eod; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (start_of_directory == <span class="hljs-number"><span class="hljs-number">-1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos = device-&gt;size() - <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(EndOfDirectory)) - i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || i &gt; <span class="hljs-number"><span class="hljs-number">65535</span></span>) { qWarning() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"QZip: EndOfDirectory not found"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } device-&gt;seek(pos); device-&gt;read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;eod, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(EndOfDirectory)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (readUInt(eod.signature) == <span class="hljs-number"><span class="hljs-number">0x06054b50</span></span>) start_of_directory = pos; ++i; }</code> </pre> <br> 但是，我不确定代码应该是什么样的。 最好项目开发人员自己分析程序的这一部分并进行必要的更改。 <br><br> 另一个奇怪的情况： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StelProjectorCylinder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> StelProjector { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intersectViewportDiscontinuityInternal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Vec3d&amp; capN, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> capD)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">,</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">SphericalCap </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capN, capD)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cap.intersects(cap1) &amp;&amp; cap.intersects(cap2) &amp;&amp; cap.intersects(cap2); } };</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V501</a> '&amp;&amp;'运算符的左侧和右侧有相同的子表达式'cap.intersects（cap2）'。  StelProjectorClasses.hpp 175 <br><br> 您可能已经猜到了，错误出在函数的最后一行：程序员输入了错误，最后发现无论<i>cap3</i>的值如何，函数都会返回结果。 <br><br> 这种错误非常普遍：几乎在每个经过测试的项目中，我们都遇到了与形式<i>name1</i>和<i>name2</i>之类的名称有关的错别字。 通常，此类错误与复制粘贴有关。 <br><br> 此代码实例是另一个常见错误模式的主要示例，对此我们甚至进行了单独的小型研究。 我的同事安德烈·卡尔波夫（Andrei Karpov）将其称为“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">最后一行效果”</a> 。 如果您不熟悉此材料，建议您在浏览器中打开一个选项卡以供日后阅读，但现在让我们继续。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> BottomStelBar::updateText(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> updatePos) { .... updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (location-&gt;text() != newLocation || updatePos) { updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fov-&gt;text() != str) { updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fps-&gt;text() != str) { updatePos = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; .... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (updatePos) { .... } }</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V560</a>条件表达式的一部分始终为true：updatePos。  StelGuiItems.cpp 732 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V547</a>表达式“ updatePos”始终为true。  StelGuiItems.cpp 831 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V763</a>参数'updatePos'始终在使用前在函数体中重写。  StelGuiItems.cpp 690 </li></ul><br> 在使用<i>updatePos</i>参数之前，其值始终会被覆盖，即 无论传递给它的值如何，该函数都将相同。 <br><br> 看起来很奇怪，不是吗？ 在<i>涉及updatePos</i>参数的所有地方，它都是<i>正确的</i> 。 这意味着条件<i>if（location-&gt; text（）！= NewLocation || updatePos）</i>和<i>if（updatePos）</i>将始终为true。 <br><br> 另一个代码段： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LandscapeMgr::onTargetLocationChanged(StelLocation loc) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pl &amp;&amp; flagEnvironmentAutoEnabling) { QSettings* conf = StelApp::getInstance().getSettings(); setFlagAtmosphere(pl-&gt;hasAtmosphere() &amp; conf-&gt;value(<span class="hljs-string"><span class="hljs-string">"landscape/flag_atmosphere"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>).toBool()); setFlagFog(pl-&gt;hasAtmosphere() &amp; conf-&gt;value(<span class="hljs-string"><span class="hljs-string">"landscape/flag_fog"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>).toBool()); setFlagLandscape(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V792</a>不管左操作数的值如何，都将调用位于运算符'＆'右侧的'toBool'函数。 也许，最好使用“ &amp;&amp;”。 景观经理cpp 782 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V792</a>不管左操作数的值如何，都将调用位于运算符'＆'右侧的'toBool'函数。 也许，最好使用“ &amp;&amp;”。 景观经理cpp 783 </li></ul><br> 分析器在<i>setFlagAtmosphere</i>和<i>setFlagFog函数</i>的参数中检测到可疑表达式。 确实：在位运算符的两边， <i>还有</i> <i>bool</i>类型的<i>值</i> 。 应该使用<i>&amp;&amp;</i>运算符代替<i>＆</i>运算符，现在我将解释原因。 <br><br> 是的，此表达式的结果将始终是正确的。 在使用按位“和”之前，两个操作数都将被提升为<i>int</i> 。 在C ++中，这种转换是<a href="">明确的</a> ：将false转换为0，将true转换为1。因此，此表达式的结果将与使用<i>&amp;&amp;</i>运算符相同。 <br><br> 但是有细微差别。 在计算<i>&amp;&amp;</i>运算的结果时，使用了所谓的“惰性计算”。 如果左操作数的值为<i>false</i> ，那么甚至不会计算右值，因为在任何情况下逻辑“和”都将返回<i>false</i> 。 这样做是为了节省计算资源，并允许您编写更复杂的设计。 例如，您可以验证指针是否不为null，如果是，则取消引用该指针以执行其他检查。 示例： <i>if（ptr &amp;&amp; ptr-&gt; foo（））</i> 。 <br><br> 不会使用按位运算符<i>＆来</i>执行这种“惰性计算”：表达式<i>conf-&gt; value（“ ...”，true）.toBool（）</i>每次都会被求值，而与<i>pl-&gt; hasAtmosphere（）</i>的值无关。 <br><br> 在极少数情况下，这是有意为之。 例如，如果计算正确的操作数具有“副作用”，其结果将在以后使用。 这样做也不是一件好事，因为这会使代码的理解复杂化，并使维护复杂化。 另外，未定义计算操作数<i>＆</i>的顺序，因此在某些使用这种“技巧”的情况下，您可以获得不确定的行为。 <br><br> 如果需要保存副作用，请在单独的一行中进行保存，并将结果保存在单独的变量中。 将来将使用此代码的人们将感谢您:) <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/301/5a6/971/3015a69710bc07f948b5233dac04fc87.png"></div><br> 我们继续下一个主题。 <br><br><h2> 错误的内存处理 </h2><br> 让我们从这个片段开始动态内存的主题： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/************ Basic Edge Operations ****************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* __gl_meshMakeEdge creates one edge, * two vertices, and a loop (face). * The loop consists of the two new half-edges. */</span></span> GLUEShalfEdge* __gl_meshMakeEdge(GLUESmesh* mesh) { GLUESvertex* newVertex1 = allocVertex(); GLUESvertex* newVertex2 = allocVertex(); GLUESface* newFace = allocFace(); GLUEShalfEdge* e; <span class="hljs-comment"><span class="hljs-comment">/* if any one is null then all get freed */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( newVertex1 == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || newVertex2 == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> || newFace == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertex1 != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { memFree(newVertex1); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newVertex2 != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { memFree(newVertex2); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newFace != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { memFree(newFace); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } e = MakeEdge(&amp;mesh-&gt;eHead); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } MakeVertex(newVertex1, e, &amp;mesh-&gt;vHead); MakeVertex(newVertex2, e-&gt;Sym, &amp;mesh-&gt;vHead); MakeFace(newFace, e, &amp;mesh-&gt;fHead); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e; }</code> </pre> <br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V773</a>在不释放'newVertex1'指针的情况下退出了该函数。 可能发生内存泄漏。  c.312 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V773</a>在不释放'newVertex2'指针的情况下退出了该函数。 可能发生内存泄漏。  c.312 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V773</a>在不释放'newFace'指针的情况下退出了该函数。 可能发生内存泄漏。  c.312 </li></ul><br> 该函数为几种结构分配内存，并将其传递给指针<i>newVertex1</i> ， <i>newVertex2</i> （有趣的名称，对吗）和<i>newFace指针</i> 。 如果其中之一为零，则释放该函数内部保留的所有内存，然后控制流离开该函数。 <br><br> 如果正确分配了所有三个结构的内存，并且<i>MakeEdge（＆mesh-&gt; eHead）函数</i>返回<i>NULL</i> ，会发生什么情况？ 控制流将到达第二个<i>返回</i> 。 <br><br> 由于指针<i>newVertex1</i> ， <i>newVertex2</i>和<i>newFace</i>是局部变量，因此在退出函数后它们将不再存在。 但是不会释放属于他们的记忆。 它会保留，但我们将不再有权访问它。 <br><br> 这种情况称为内存泄漏。 出现这种错误的典型情况是：随着程序的长时间使用，它开始消耗越来越多的RAM，直到耗尽为止。 <br><br> 应当注意，在此示例中，第三次<i>返回</i>并非错误。  <i>MakeVertex</i>和<i>MakeFace函数</i>将分配的内存的地址传输到其他数据结构，从而委派了对其释放的责任。 <br><br> 下一个缺陷是该方法，需要90行。 为了方便起见，我减少了它，只留下了问题区域。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AstroCalcDialog::drawAngularDistanceGraph() { .... QVector&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; xs, ys; .... }</code> </pre> <br> 仅剩一行。 让我给您一个提示：这是<i>xs</i>和<i>ys</i>对象的唯一提及。 <br><br>  <b>PVS-Studio警告：</b> <br><br><ul><li> 已创建“ QVector”类型的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V808</a> “ xs”对象，但未使用。  AstroCalcDialog.cpp 5329 </li><li> 已创建“ QVector”类型的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V808</a> “ ys”对象，但未使用。  AstroCalcDialog.cpp 5329 </li></ul><br> 向量<i>xs</i>和<i>ys</i>已创建，但未在任何地方使用。 事实证明，每次使用<i>drawAngularDistanceGraph</i>方法时，都会发生一个空容器的额外创建和删除。 我认为此广告在重构后仍保留在代码中。 这当然不是错误，但是您应该删除多余的代码。 <br><br><h2> 奇怪的类型转换 </h2><br> 经过一些格式化后的另一个示例如下所示： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SatellitesDialog::updateSatelliteData() { .... <span class="hljs-comment"><span class="hljs-comment">// set default buttonColor = QColor(0.4, 0.4, 0.4); .... }</span></span></code> </pre> <br> 为了理解错误是什么，您将必须查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Qcolor类构造函数</a>的原型： <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f7d/84e/798/f7d84e79849bca96f7a27016aec0e9d3.png"></div><br>  <b>PVS-Studio警告：</b> <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V674</a>在调用“ QColor”函数时，将“ double”类型的文字“ 0.4”隐式转换为“ int”类型。 检查第一个参数。 卫星对话框.cpp 413 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V674</a>在调用“ QColor”函数时，将“ double”类型的文字“ 0.4”隐式转换为“ int”类型。 检查第二个参数。 卫星对话框.cpp 413 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V674</a>在调用“ QColor”函数时，将“ double”类型的文字“ 0.4”隐式转换为“ int”类型。 检查第三个论点。 卫星对话框.cpp 413 </li></ul><br>  <i>Qcolor</i>类<i>没有</i>接受<i>double</i>类型的构造函数，因此示例中的参数将隐式转换为<i>int</i> 。 这将导致<i>buttonColor</i>对象的字段<i>r</i> ， <i>g</i>和<i>b</i>的值为<i>0</i> 。 <br><br> 如果程序员打算从<i>double</i>类型的值创建对象，则应使用其他构造函数。 <br><br> 例如，您可以通过以下方式使用接受<i>Qrgb</i>的构造函数： <br><br><pre> <code class="cpp hljs">buttonColor = QColor(QColor::fromRgbF(<span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>));</code> </pre> <br> 可以做的不同。  Qt使用[0.0，1.0]范围内的实数值或[0，255]范围内的整数表示RGB颜色。 <br><br> 因此，程序员可以通过如下编写将值从实数转换为整数： <br><br><pre> <code class="cpp hljs">buttonColor = QColor((<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">0.4</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">0.4</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">0.4</span></span>));</code> </pre> <br> 或者只是 <br><br><pre> <code class="cpp hljs">buttonColor = QColor(<span class="hljs-number"><span class="hljs-number">102</span></span>, <span class="hljs-number"><span class="hljs-number">102</span></span>, <span class="hljs-number"><span class="hljs-number">102</span></span>);</code> </pre> <br> 你很无聊吗 别担心：我们面前还有更多有趣的错误。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f18/aa0/297/f18aa02975f89e9e6cc7c661706fc608.png"></div><br>  <font color="#999999"><i>“太空中的独角兽。”</i></font>  <font color="#999999"><i>从恒星的视图。</i></font> <br><br><h2> 其他错误 </h2><br> 最后，我给你留下了一些好吃的:)让我们开始讨论其中之一。 <br><br><pre> <code class="cpp hljs">HipsTile* HipsSurvey::getTile(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> order, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pix) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (order == orderMin &amp;&amp; !allsky.isNull()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbw = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">12</span></span> * <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; (<span class="hljs-number"><span class="hljs-number">2</span></span> * order)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = (pix % nbw) * allsky.width() / nbw; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = (pix / nbw) * allsky.width() / nbw; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s = allsky.width() / nbw; QImage image = allsky.copy(x, y, s, s); .... } .... }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V634</a> '*'操作的优先级高于'&lt;&lt;'操作的优先级。 表达式中可能应使用括号。  StelHips.cpp 271 <br><br> 好吧，您能够检测到该错误吗？ 更详细地考虑表达式<i>（12 * 1 &lt;&lt;（2 *顺序））</i> 。 分析器忆及，运算符<i>*</i>的优先级高于移位运算<i>符&lt;&lt;</i>的优先级。 很容易看出，将<i>12</i>乘以<i>1是</i>没有意义的，不需要<i>2 *阶</i>左右的括号。 <br><br><pre> <code class="cpp hljs"> ,    : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbw = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">12</span></span> * (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span> * order));     &lt;i&gt;<span class="hljs-number"><span class="hljs-number">12</span></span> &lt;/i&gt;     .</code> </pre> <br> 注意事项 另外，我想指出的是，如果右操作数' <i>&lt;&lt;</i> '的值大于或等于左操作数的位数，则结果未定义。 由于数字文字默认情况下是<i>int</i> ，它需要<i>32</i>位，因此<i>order</i>参数的值不应超过<i>15</i> 。 否则，对表达式的求值可能会导致未定义的行为。 <br><br> 我们继续。 下面的方法非常令人困惑，但是我敢肯定，成熟的阅读器可以处理错误检测:) <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* inherits documentation from base class */</span></span> QCPRange QCPStatisticalBox:: getKeyRange(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; foundRange, SignDomain inSignDomain) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inSignDomain == sdBoth) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inSignDomain == sdNegative) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (inSignDomain == sdPositive) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); } } foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); }</code> </pre> <br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V779</a>检测到无法访问的代码。 可能存在错误。  qcustomplot.cpp 19512。 <br><br> 事实是，所有<i>if ... else</i>分支都有<i>回报</i> 。 因此，控制流永远不会到达最后两行。 <br><br> 总的来说，该示例将正常运行并正常工作。 但是，仅存在无法访问的代码是一个信号。 在这种情况下，它表明该方法的结构不正确，从而极大地增加了代码的可读性和可理解性。 <br><br> 该代码片段应进行重构，以在输出端获得更简洁的功能。 例如，像这样： <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* inherits documentation from base class */</span></span> QCPRange QCPStatisticalBox:: getKeyRange(<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&amp; foundRange, SignDomain inSignDomain) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { foundRange = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (inSignDomain) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sdBoth: { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sdNegative: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sdPositive: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey - mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKey &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(mKey, mKey + mWidth * <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } foundRange = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QCPRange(); }</code> </pre> <br> 我们评论中的最后一个是我最喜欢的错误。 故障点代码简短明了： <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br> 您注意到可疑之处吗？ 不是每个人都可以:) <br><br>  <b>PVS-Studio警告：</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">V603</a>已创建对象，但未使用该对象。 如果要调用构造函数，则应使用“ this-&gt; Plane :: Plane（....）”。 平面cpp 29 <br><br> 程序员希望对象的某些字段会在嵌套构造函数中初始化，但结果是这样的：当<i>调用Plane</i>构造函数<i>（Vec3f＆v1，Vec3f＆v2，Vec3f＆v3）时</i> ，将在其中创建未命名的临时对象，该对象立即被删除。 结果，对象的一部分保持未初始化。 <br><br> 为了使代码正常工作，您应该使用C ++ 11的便捷安全功能-委托构造函数： <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f&amp; v1, Vec3f&amp; v2, Vec3f&amp; v3) : Plane(v1, v2, v3, SPolygon::CCW) { distance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; sDistance = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>; }</code> </pre> <br> 但是，如果将编译器用于该语言的旧版本，则可以这样编写： <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Plane::Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br> 大概： <br><br><pre> <code class="cpp hljs">Plane::Plane(Vec3f &amp;v1, Vec3f &amp;v2, Vec3f &amp;v3) : distance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>), sDistance(<span class="hljs-number"><span class="hljs-number">0.0f</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) Plane(v1, v2, v3, SPolygon::CCW); }</code> </pre> <br> 我注意到后两种方法<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">非常危险</a> 。 因此，您应该非常小心并充分了解此类方法的工作方式。 <br><br><h2> 结论 </h2><br> 关于恒星代码的质量可以得出什么结论？ 老实说，没有太多错误。 此外，在整个项目中，我没有发现任何错误将代码与未定义的行为相关联。 对于开源项目，代码质量很高，为此我向开发人员表示敬意。 你们真棒！ 我很高兴也有兴趣审查您的项目。 <br><br> 那天文馆本身呢-我经常使用它。 不幸的是，住在城市里，我很少能享受到晴朗的夜空，而Stellarium可以让我在世界上任何地方都不必起床。 真的很舒服！ <br><br> 我特别喜欢“星座艺术”模式。 奇特的舞蹈中覆盖着整个天空的巨大人物的景色令人叹为观止。 <br><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/3d5/107/6133d51079ac983aa11a017acd1945ee.png"></div><br>  <font color="#999999"><i>“一个奇怪的舞蹈。”</i></font>  <font color="#999999"><i>从恒星的视图。</i></font> <br><br> 世俗的人容易犯错误，而这些错误会泄漏到代码中这一事实并没有什么可耻的。 为此，开发了代码分析工具，例如PVS-Studio。 如果您是其中之一-建议您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">自己下载并尝试一下</a> 。 <br><br> 希望您对阅读我的文章感兴趣，并且对自己有所了解。 希望开发人员及早纠正发现的错误。 <br><br> 订阅我们的频道，并随时关注来自编程领域的新闻！ <br><br><ul><li>  Vk： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvsstudio_rus</a> </li><li> 电报： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvsstudio_rus</a> </li><li>  Instagram的： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvsstudio_rus</a> </li><li> 推特： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@pvsstudio_rus</a> </li><li>  YouTube： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">@PVSStudioTool</a> </li></ul><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br> 如果您想与讲英语的读者分享这篇文章，请使用翻译链接：George Gribkov。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">再次进入太空：独角兽如何拜访恒星</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432954/">https://habr.com/ru/post/zh-CN432954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432940/index.html">50种色调的代币</a></li>
<li><a href="../zh-CN432942/index.html">Kotlin中的Corutin模式和反模式</a></li>
<li><a href="../zh-CN432944/index.html">强制PostgreSQL查询优化</a></li>
<li><a href="../zh-CN432946/index.html">Unity-2D游戏开发的陷阱</a></li>
<li><a href="../zh-CN432948/index.html">智能云，智能企业：人工智能如何改变云计算行业</a></li>
<li><a href="../zh-CN432956/index.html">来自ID的怪物：《毁灭战士》是如何创建的</a></li>
<li><a href="../zh-CN432958/index.html">新的量子悖论阐明了在这种情况下我们关于现实的想法被证明是错误的</a></li>
<li><a href="../zh-CN432960/index.html">为什么消费者不害怕身份盗用</a></li>
<li><a href="../zh-CN432964/index.html">关于强权或无权的权力：俄罗斯联邦的一项新立法倡议</a></li>
<li><a href="../zh-CN432966/index.html">STM32的加密引导程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>