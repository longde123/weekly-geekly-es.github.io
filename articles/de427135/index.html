<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🆓 🤱🏽 🕹️ Implementierung von Zwischensequenzen und Abfolgen von Aktionen in Spielen 👩🏽‍🚀 👵🏿 🅰️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Beitrag werde ich darüber sprechen, wie Sie Sequenzen von Aktionen und Zwischensequenzen in Videospielen implementieren können. Dieser Artik...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung von Zwischensequenzen und Abfolgen von Aktionen in Spielen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427135/"> <i>In diesem Beitrag werde ich darüber sprechen, wie Sie Sequenzen von Aktionen und Zwischensequenzen in Videospielen implementieren können.</i>  <i>Dieser Artikel ist eine Übersetzung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieses Artikels</a> und zu demselben Thema habe ich eine Präsentation bei Lua in Moskau gehalten. Wenn Sie das Video also lieber sehen möchten, können Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">es hier</a> ansehen.</i> <i><br><br></i>  <i>Der Artikelcode ist in Lua geschrieben, kann aber leicht in anderen Sprachen geschrieben werden (mit Ausnahme der Methode, die Coroutinen verwendet, da diese nicht in allen Sprachen verfügbar sind).</i> <i><br></i> <br>  Der Artikel zeigt, wie Sie einen Mechanismus erstellen, mit dem Sie Zwischensequenzen in der folgenden Form schreiben können: <br><br><pre><code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:hasCompleted(quest) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"Please help me"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><h1>  Eintrag </h1><br>  Action-Sequenzen finden sich häufig in Videospielen.  Zum Beispiel in Zwischensequenzen: Der Charakter trifft den Feind, sagt etwas zu ihm, der Feind antwortet und so weiter.  Die Reihenfolge der Aktionen finden Sie im Gameplay.  Schauen Sie sich dieses GIF an: <br><br><img src="https://habrastorage.org/webt/5k/ry/ik/5kryik8wvq-b4ifoa3k3iobvolw.gif"><br><br>  1. Die Tür öffnet sich <br>  2. Der Charakter betritt das Haus <br>  3. Die Tür schließt sich <br>  4. Der Bildschirm wird allmählich dunkler <br>  5. Der Pegel ändert sich <br>  6. Der Bildschirm wird hell ausgeblendet <br>  7. Der Charakter betritt das Café <br><br>  Aktionssequenzen können auch verwendet werden, um das Verhalten von NPCs zu skripten oder um Bosskämpfe zu implementieren, in denen der Boss einige Aktionen nacheinander ausführt. <br><a name="habracut"></a><br><h1>  Das Problem </h1><br>  Die Struktur einer Standardspielschleife erschwert die Implementierung von Aktionssequenzen.  Nehmen wir an, wir haben die folgende Spielschleife: <br><br><img src="https://habrastorage.org/webt/uc/xs/an/ucxsanil2ovbawdzqehjmfjpja4.png" width="240"><br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> game:isRunning() <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> processInput() dt = <span class="hljs-built_in"><span class="hljs-built_in">clock</span></span>.delta() update(dt) render() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Wir wollen die folgende Zwischensequenz implementieren: Der Spieler nähert sich dem NPC, der NPC sagt: "Du hast es geschafft!" Und nach einer kurzen Pause sagt er: "Danke!".  In einer idealen Welt würden wir es so schreiben: <br><br><pre> <code class="lua hljs">player:goTo(npc) npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>)</code> </pre><br>  Und hier stehen wir vor einem Problem.  Es dauert einige Zeit, bis die Schritte abgeschlossen sind.  Einige Aktionen warten möglicherweise sogar auf die Eingabe durch den Player (z. B. um das Dialogfeld zu schließen).  Anstelle der <code>delay</code> können Sie nicht denselben <code>sleep</code> aufrufen - es sieht so aus, als wäre das Spiel eingefroren. <br><br>  Schauen wir uns einige Ansätze zur Lösung des Problems an. <br><br><h1>  Bool, Enum, State Machines </h1><br>  Der naheliegendste Weg, eine Folge von Aktionen zu implementieren, besteht darin, Informationen über den aktuellen Status in Bools, Zeilen oder Aufzählungen zu speichern.  Der Code sieht ungefähr so ​​aus: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> cutsceneState == <span class="hljs-string"><span class="hljs-string">'playerGoingToNpc'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> player:continueGoingTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:closeTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cutsceneState = <span class="hljs-string"><span class="hljs-string">'npcSayingYouDidIt'</span></span> dialogueWindow:show(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> cutsceneState == <span class="hljs-string"><span class="hljs-string">'npcSayingYouDidIt'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dialogueWindow:wasClosed() <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> cutsceneState = <span class="hljs-string"><span class="hljs-string">'delay'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elseif</span></span> ... ... <span class="hljs-comment"><span class="hljs-comment">--   ... end end</span></span></code> </pre><br>  Dieser Ansatz führt leicht zu Spaghetti-Code und langen Ketten von if-else-Ausdrücken. Ich empfehle daher, diese Methode zur Lösung des Problems zu vermeiden. <br><br><h1>  Aktionsliste </h1><br>  Aktionslisten sind Zustandsautomaten sehr ähnlich.  Eine Aktionsliste ist eine Liste von Aktionen, die nacheinander ausgeführt werden.  In der Spielschleife wird die <code>update</code> für die aktuelle Aktion aufgerufen, mit der wir die Eingabe verarbeiten und das Spiel rendern können, auch wenn die Aktion lange dauert.  Nachdem die Aktion abgeschlossen ist, fahren wir mit dem nächsten fort. <br><br>  In der Zwischensequenz, die wir implementieren möchten, müssen wir die folgenden Aktionen implementieren: GoToAction, DialogueAction und DelayAction. <br><br>  Für weitere Beispiele werde ich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Middleclass-</a> Bibliothek für OOP in Lua verwenden. <br><br>  So wird eine <code>DelayAction</code> implementiert: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">--  function DelayAction:initialize(params) self.delay = params.delay self.currentTime = 0 self.isFinished = false end function DelayAction:update(dt) self.currentTime = self.currentTime + dt if self.currentTime &gt; self.delay then self.isFinished = true end end</span></span></code> </pre><br>  Die Funktion <code>ActionList:update</code> sieht folgendermaßen aus: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ActionList:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.isFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.currentAction:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.currentAction.isFinished <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:goToNextAction() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.currentAction <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.isFinished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Und schließlich die Implementierung der Zwischensequenz selbst: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> makeCutsceneActionList(player, npc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ActionList:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { GoToAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = player, target = npc }, SayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = npc, <span class="hljs-type"><span class="hljs-type">text</span></span> = "You did it!" }, DelayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { delay = <span class="hljs-number"><span class="hljs-number">0.5</span></span> }, SayAction:<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> { entity = npc, <span class="hljs-type"><span class="hljs-type">text</span></span> = "Thank you" } } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- ... -    actionList:update(dt)</span></span></code> </pre><br>  <i>Hinweis</i> : In Lua kann ein Aufruf von <code>someFunction({ ... })</code> wie <code>someFunction{...}</code> : <code>someFunction{...}</code> .  Auf diese Weise können Sie <code>DelayAction:new{ delay = 0.5 }</code> anstelle von <code>DelayAction:new({delay = 0.5})</code> schreiben. <br><br>  Es sieht viel besser aus.  Der Code zeigt deutlich die Abfolge der Aktionen.  Wenn wir eine neue Aktion hinzufügen möchten, können wir dies problemlos tun.  Es ist ganz einfach, Klassen wie <code>DelayAction</code> zu <code>DelayAction</code> , um das Schreiben von Zwischensequenzen bequemer zu gestalten. <br><br>  Ich rate Ihnen, die Präsentation von Sean Middleditch über Aktionslisten zu sehen, die komplexere Beispiele enthält. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/o6CaB-hmqoE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Aktionslisten sind im Allgemeinen sehr nützlich.  Ich habe sie für einige Zeit für meine Spiele verwendet und war insgesamt glücklich.  Dieser Ansatz hat jedoch auch Nachteile.  Angenommen, wir möchten eine etwas komplexere Zwischensequenz implementieren: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> player:hasCompleted(quest) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> npc:say(<span class="hljs-string"><span class="hljs-string">"Please help me"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Um eine if / else-Simulation durchzuführen, müssen Sie nichtlineare Listen implementieren.  Dies kann mithilfe von Tags erfolgen.  Einige Aktionen können mit Tags versehen werden. Unter bestimmten Bedingungen können Sie dann, anstatt zur nächsten Aktion überzugehen, zu einer Aktion mit dem gewünschten Tag wechseln.  Es funktioniert, ist jedoch nicht so einfach zu lesen und zu schreiben wie die obige Funktion. <br><br>  Lua Coroutinen verwirklichen diesen Code. <br><br><h1>  Coroutinen </h1><br><h2>  Corua Grundlagen in Lua </h2><br>  Corutin ist eine Funktion, die angehalten und später wieder aufgenommen werden kann.  Coroutinen werden im selben Thread wie das Hauptprogramm ausgeführt.  Für Coroutine werden niemals neue Threads erstellt. <br><br>  Um <code>coroutine.yield</code> , müssen Sie coroutine.yield aufrufen, um fortzufahren - <code>coroutine.resume</code> .  Ein einfaches Beispiel: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"world!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(f) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"uhh..."</span></span>) coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c)</code> </pre><br>  Programmausgabe: <br><br><pre> Hallo
 äh ...
 Welt
</pre><br><br>  So funktioniert es  Zuerst erstellen wir <code>coroutine.create</code> mit <code>coroutine.create</code> .  Nach diesem Aufruf wird Corutin nicht gestartet.  Dazu müssen wir es mit <code>coroutine.resume</code> ausführen.  Dann wird die Funktion <code>f</code> aufgerufen, die „Hallo“ schreibt und sich mit <code>coroutine.yield</code> pausiert.  Dies ähnelt der <code>return</code> , aber wir können <code>f</code> mit <code>coroutine.resume</code> . <br><br>  Wenn Sie beim Aufrufen von <code>coroutine.yield</code> Argumente übergeben, werden diese zu den Rückgabewerten des entsprechenden Aufrufs von <code>coroutine.resume</code> im "Hauptstrom". <br><br>  Zum Beispiel: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-string"><span class="hljs-string">"some text"</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ok, num, text = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(num, text) <span class="hljs-comment"><span class="hljs-comment">-- will print '42 "some text"'</span></span></code> </pre><br>  <code>ok</code> ist eine Variable, mit der wir den Status einer Coroutine ermitteln können.  Wenn <code>ok</code> <code>true</code> , dann ist mit Coroutine alles in Ordnung, es sind keine Fehler im Inneren aufgetreten.  Die darauf folgenden Rückgabewerte ( <code>num</code> , <code>text</code> ) sind dieselben Argumente, die wir übergeben haben, um zu <code>yield</code> . <br><br>  Wenn <code>ok</code> <code>false</code> , ist ein <code>error</code> mit der Coroutine aufgetreten, z. B. wurde die <code>error</code> aufgerufen.  In diesem Fall ist der zweite Rückgabewert eine Fehlermeldung.  Ein Beispiel für eine Coroutine, in der ein Fehler auftritt: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span> + notDefined) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> c = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>(f) ok, msg = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> ok <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"Coroutine failed!"</span></span>, msg) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Fazit: <br><br><pre> Coroutine fehlgeschlagen!  Eingabe: 4: Versuch, eine Arithmetik für einen Nullwert durchzuführen (global 'notDefined')
</pre><br><br>  Der Coroutine-Status kann durch Aufrufen von coroutine.status abgerufen werden.  Corutin kann unter folgenden Bedingungen sein: <br><br><ul><li>  "Laufen" - Coroutine läuft gerade.  <code>coroutine.status</code> wurde von corutin selbst aufgerufen </li><li>  "Suspended" - Corutin wurde angehalten oder noch nie gestartet </li><li>  "Normal" - Corutin ist aktiv, wird aber nicht ausgeführt.  Das heißt, Corutin hat ein weiteres Corutin in sich selbst gestartet </li><li>  "Tot" - Coroutine abgeschlossene Ausführung (dh die Funktion innerhalb der Coroutine abgeschlossen) </li></ul><br>  Mit Hilfe dieses Wissens können wir nun ein System von Abfolgen von Aktionen und Zwischensequenzen implementieren, die auf Coroutinen basieren. <br><br><h2>  Zwischensequenzen mit Corutin erstellen </h2><br>  So sieht die Basis- <code>Action</code> Klasse auf dem neuen System aus: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action:launch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:init() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.finished <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dt = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() self:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self:<span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Der Ansatz ähnelt Aktionslisten: Die <code>update</code> der Aktion wird aufgerufen, bis die Aktion abgeschlossen ist.  Aber hier verwenden wir Coroutinen und geben in jeder Iteration der Spielschleife nach ( <code>Action:launch</code> wird von einer Coroutine aufgerufen).  Irgendwo in der <code>update</code> Spieleschleife setzen wir die Ausführung der aktuellen Zwischensequenz wie folgt fort: <br><br><pre> <code class="lua hljs">coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(c, dt)</code> </pre><br>  Und schließlich eine Zwischensequenz erstellen: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player, npc)</span></span></span></span> player:goTo(npc) npc:say(<span class="hljs-string"><span class="hljs-string">"You did it!"</span></span>) delay(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) npc:say(<span class="hljs-string"><span class="hljs-string">"Thank you"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">-- -  ... local c = coroutine.create(cutscene, player, npc) coroutine.resume(c, dt)</span></span></code> </pre><br>  So wird die <code>delay</code> implementiert: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(time)</span></span></span></span> action = DelayAction:new { delay = <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Das Erstellen solcher Wrapper verbessert die Lesbarkeit des Zwischensequenzcodes erheblich.  <code>DelayAction</code> implementiert: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- Action -   DelayAction local DelayAction = class("DelayAction", Action) function DelayAction:initialize(params) self.delay = params.delay self.currentTime = 0 self.isFinished = false end function DelayAction:update(dt) self.currentTime = self.currentTime + dt if self.currentTime &gt;= self.delayTime then self.finished = true end end</span></span></code> </pre><br>  Diese Implementierung ist identisch mit der, die wir in Aktionslisten verwendet haben!  Werfen wir einen Blick auf die Funktion <code>Action:launch</code> erneut: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Action:launch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self:init() <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.finished <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dt = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">yield</span></span>() <span class="hljs-comment"><span class="hljs-comment">-- the most important part self:update(dt) end self:exit() end</span></span></code> </pre><br>  Die Hauptsache hier ist die <code>while</code> , die ausgeführt wird, bis die Aktion abgeschlossen ist.  Es sieht ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/l3/_n/xw/l3_nxwnzshpxqhho12yqyi-y52o.png"><br><br>  Schauen wir uns nun die <code>goTo</code> Funktion an: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Entity:goTo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> action = GoToAction:new { entity = self, target = target } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToAction:initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GoToAction:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.entity:closeTo(self.target) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-comment"><span class="hljs-comment">--  , AI else self.finished = true end end</span></span></code> </pre><br>  Coroutinen passen gut zu Ereignissen.  Implementieren Sie die <code>WaitForEventAction</code> Klasse: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForEventAction:initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(params)</span></span></span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">false</span></span> eventManager:subscribe { listener = self, eventType = params.eventType, callback = WaitForEventAction.onEvent } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForEventAction:onEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Diese Funktion benötigt keine <code>update</code> .  Es wird ausgeführt (obwohl es nichts tut ...), bis es ein Ereignis mit dem erforderlichen Typ empfängt.  Hier ist die praktische Anwendung dieser Klasse - Implementierung der Funktion <code>say</code> : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Entity:say</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(text)</span></span></span></span> DialogueWindow:show(text) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> action = WaitForEventAction:new { eventType = <span class="hljs-string"><span class="hljs-string">'DialogueWindowClosed'</span></span> } action:launch() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Einfach und lesbar.  Wenn das Dialogfeld geschlossen wird, wird ein Ereignis vom Typ 'DialogueWindowClosed' ausgelöst.  Die Say-Aktion endet und die nächste beginnt mit der Ausführung. <br><br>  Mit Coroutine können Sie ganz einfach nichtlineare Zwischensequenzen und Dialogbäume erstellen: <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">local</span></span> answer = girl:say(<span class="hljs-string"><span class="hljs-string">'do_you_love_lua'</span></span>, { <span class="hljs-string"><span class="hljs-string">'YES'</span></span>, <span class="hljs-string"><span class="hljs-string">'NO'</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> answer == <span class="hljs-string"><span class="hljs-string">'YES'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> girl:setMood(<span class="hljs-string"><span class="hljs-string">'happy'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">'happy_response'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> girl:setMood(<span class="hljs-string"><span class="hljs-string">'angry'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">'angry_response'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><img src="https://habrastorage.org/webt/t4/e-/am/t4e-amhtwligikstvqtgi8bpyzu.gif"><br><br>  In diesem Beispiel ist die Funktion <code>say</code> etwas komplexer als die zuvor gezeigte.  Es gibt die Wahl des Spielers im Dialog zurück, ist jedoch nicht schwer zu implementieren.  Beispielsweise kann <code>WaitForEventAction</code> , wodurch das PlayerChoiceEvent-Ereignis <code>WaitForEventAction</code> und dann die Auswahl des Players zurückgegeben wird, dessen Informationen im Ereignisobjekt enthalten sind. <br><br><h2>  Etwas komplexere Beispiele </h2><br>  Mit Coroutine können Sie ganz einfach Tutorials und kleine Quests erstellen.  Zum Beispiel: <br><br><pre> <code class="lua hljs">girl:say(<span class="hljs-string"><span class="hljs-string">"Kill that monster!"</span></span>) waitForEvent(<span class="hljs-string"><span class="hljs-string">'EnemyKilled'</span></span>) girl:setMood(<span class="hljs-string"><span class="hljs-string">'happy'</span></span>) girl:say(<span class="hljs-string"><span class="hljs-string">"You did it! Thank you!"</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/wx/du/kh/wxdukhci9lald-fph9ypbu5h5fg.gif"><br><br>  Coroutinen können auch für KI verwendet werden.  Sie können beispielsweise eine Funktion festlegen, mit der sich das Monster auf einer bestimmten Flugbahn bewegt: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">followPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(monster, path)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> numberOfPoints = <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>:getNumberOfPoints() <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-comment"><span class="hljs-comment">--      while true do monster:goTo(path:getPoint(i)) if i &lt; numberOfPoints - 1 then i = i + 1 --     else --   i = 0 end end end</span></span></code> </pre><br><img src="https://habrastorage.org/webt/g7/m4/ou/g7m4ouls2l7al6xlovmm-qdbywc.gif"><br><br>  Wenn das Monster den Spieler sieht, können wir einfach aufhören, die Coroutine zu erfüllen und sie entfernen.  Daher ist eine Endlosschleife ( <code>while true</code> ) in <code>followPath</code> nicht wirklich unendlich. <br><br>  Mit corutin können Sie "parallele" Aktionen ausführen.  Die Zwischensequenz fährt erst mit der nächsten Aktion fort, wenn beide Aktionen abgeschlossen sind.  Zum Beispiel machen wir eine Zwischensequenz, in der ein Mädchen und eine Katze mit unterschiedlichen Geschwindigkeiten zum Punkt eines Freundes gehen.  Nachdem sie zu ihr gekommen sind, sagt die Katze "Miau". <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutscene</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cat, girl, meetingPoint)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c1 = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> cat:goTo(meetingPoint) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c2 = coroutine.<span class="hljs-built_in"><span class="hljs-built_in">create</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> girl:goTo(meetingPoint) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) c1.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>() c2.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>() <span class="hljs-comment"><span class="hljs-comment">--  waitForFinish(c1, c2) --    cat:say("meow") ... end</span></span></code> </pre><br>  Der wichtigste Teil hierbei ist die <code>waitForFinish</code> Funktion, ein Wrapper um die <code>WaitForFinishAction</code> Klasse, der wie folgt implementiert werden kann: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitForFinishAction:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c1) == <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c2) == <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.finished = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c1) ~= <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(self.c1, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">status</span></span>(self.c2) ~= <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> coroutine.<span class="hljs-built_in"><span class="hljs-built_in">resume</span></span>(self.c2, dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br>  Sie können diese Klasse leistungsfähiger machen, wenn Sie die Synchronisierung der N-ten Anzahl von Aktionen zulassen. <br><br>  Sie können auch eine Klasse erstellen, die wartet, bis <i>eine</i> der Coroutinen abgeschlossen ist, anstatt darauf zu warten, dass <i>alle</i> Coroutinen die Ausführung abgeschlossen haben.  Zum Beispiel kann es in Renn-Minispielen verwendet werden.  Innerhalb der Coroutine wird gewartet, bis einer der Fahrer die Ziellinie erreicht und dann eine Abfolge von Aktionen ausführt. <br><br><h2>  Vor- und Nachteile von Corutin </h2><br>  Coroutinen sind ein sehr nützlicher Mechanismus.  Mit ihnen können Sie Zwischensequenzen und Gameplay-Code schreiben, der einfach zu lesen und zu ändern ist.  Zwischensequenzen dieser Art können leicht von Moddern oder Personen geschrieben werden, die keine Programmierer sind (z. B. Spiel- oder Leveldesigner). <br><br>  Und all dies wird in einem Thread ausgeführt, sodass es kein Problem mit der Synchronisation oder den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Race-Bedingungen gibt</a> . <br><br>  Der Ansatz hat Nachteile.  Beispielsweise können Probleme beim Speichern auftreten.  Angenommen, in Ihrem Spiel ist ein langes Tutorial mit Coroutine implementiert.  Während dieses Tutorials kann der Player da nicht speichern  Dazu müssen Sie den aktuellen Status der Coroutine (einschließlich des gesamten Stapels und der Werte der darin enthaltenen Variablen) speichern, damit Sie beim weiteren Laden aus dem Speicher das Lernprogramm fortsetzen können. <br><br>  ( <i>Hinweis</i> : Mit der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PlutoLibrary-</a> Bibliothek <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">können</a> Coroutinen serialisiert werden, die Bibliothek funktioniert jedoch nur mit Lua 5.1.) <br><br>  Dieses Problem tritt bei Zwischensequenzen nicht auf  normalerweise ist in Spielen in der Mitte der Zwischensequenz nicht erlaubt. <br><br>  Das Problem mit einem langen Tutorial kann gelöst werden, wenn Sie es in kleine Teile zerlegen.  Angenommen, ein Spieler durchläuft den ersten Teil eines Tutorials und muss in einen anderen Raum gehen, um das Tutorial fortzusetzen.  An diesem Punkt können Sie einen Kontrollpunkt erstellen oder dem Spieler die Möglichkeit zum Speichern geben.  Beim Speichern schreiben wir so etwas wie "Der Spieler hat Teil 1 des Tutorials abgeschlossen".  Als nächstes geht der Spieler den zweiten Teil des Tutorials durch, für den wir bereits eine andere Coroutine verwenden werden.  Und so weiter ... Beim Laden beginnen wir einfach mit der Ausführung der Coroutine, die dem Teil entspricht, den der Spieler durchlaufen muss. <br><br><h1>  Fazit </h1><br>  Wie Sie sehen können, gibt es verschiedene Ansätze zum Implementieren einer Abfolge von Aktionen und Zwischensequenzen.  Es scheint mir, dass der Coroutine-Ansatz sehr leistungsfähig ist und ich freue mich, ihn mit den Entwicklern zu teilen.  Ich hoffe, dass diese Lösung des Problems Ihr Leben leichter macht und es Ihnen ermöglicht, epische Zwischensequenzen in Ihren Spielen zu erstellen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de427135/">https://habr.com/ru/post/de427135/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de427117/index.html">Tagungsräume basierend auf Asterisk</a></li>
<li><a href="../de427123/index.html">Turing Spiel</a></li>
<li><a href="../de427129/index.html">Threat Intelligence - ein moderner Ansatz zur Informationssicherheit</a></li>
<li><a href="../de427131/index.html">Bekanntschaft mit Audiomania: 15 thematische Materialien zu Produktion, Design, Büro und Business</a></li>
<li><a href="../de427133/index.html">Sortiment - klassische Optimierungsaufgabe</a></li>
<li><a href="../de427137/index.html">Statistik der Zentralbank: Die Einnahmen von Hackern aus Cyberangriffen auf Finanzorganisationen im Jahr 2018 gingen um fast das 14-fache zurück</a></li>
<li><a href="../de427139/index.html">[Auswahl] Entwicklung, Gestaltung und Förderung von Websites: 17 nützliche Materialien</a></li>
<li><a href="../de427141/index.html">Sprengendes Telefon</a></li>
<li><a href="../de427143/index.html">Hackadays zweites Retrocomputer-Abzeichen</a></li>
<li><a href="../de427145/index.html">Der beste Weg, um moderne Genetik, Molekularbiologie, Gentechnik und Genomik zu studieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>