<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§≤üèΩ üì≠ „ÄΩÔ∏è RabbitMQ vs. Kafka: Zwei verschiedene Messaging-Ans√§tze ü§òüèæ ü§ôüèø ‚ûï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten beiden Artikeln haben wir √ºber IIoT gesprochen - das industrielle Internet der Dinge -, das eine Architektur zum Empfangen von Daten vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: Zwei verschiedene Messaging-Ans√§tze</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/416629/"><p>  In den letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beiden</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeln haben</a> wir √ºber IIoT gesprochen - das industrielle Internet der Dinge -, das eine Architektur zum Empfangen von Daten von Sensoren erstellt und die Sensoren selbst verl√∂tet hat.  Der Eckpfeiler von IIoT-Architekturen und allen Architekturen, die mit BigData arbeiten, ist die Datenstromverarbeitung.  Es basiert auf dem Konzept von Messaging und Warteschlangen.  Der Standard f√ºr die Arbeit mit Messaging ist jetzt Apache Kafka.  Um jedoch seine Vorteile (und seine Nachteile) zu verstehen, w√§re es gut, die Grundlagen des Betriebs von Warteschlangensystemen als Ganzes, ihre Funktionsmechanismen, Verwendungsmuster und Grundfunktionen zu verstehen. </p><br><p><img src="https://habrastorage.org/webt/-5/p1/rn/-5p1rnrr3yks4ukkp0kyovqykli.png"></p><br><p>  Wir haben eine ausgezeichnete Artikelserie gefunden, die die Funktionalit√§t von Apache Kafka und einem anderen (unverdient ignorierten) Riesen unter den Warteschlangensystemen vergleicht - RabbitMQ.  Wir haben diese Artikelserie √ºbersetzt, kommentiert und erg√§nzt.  Obwohl die Serie im Dezember 2017 geschrieben wurde, ver√§ndert sich die Welt der Messagingsysteme (und insbesondere von Apache Kafka) so schnell, dass sich bis zum Sommer 2018 einige Dinge ge√§ndert haben. </p><a name="habracut"></a><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> </blockquote><br><h2 id="rabbitmq-vs-kafka">  RabbitMQ gegen Kafka </h2><br><p>  Messaging ist der zentrale Teil vieler Architekturen, und die beiden S√§ulen in diesem Bereich sind RabbitMQ und Apache Kafka.  Bis heute hat sich Apache Kafka zu einem fast industriellen Standard in der Datenverarbeitung und -analyse entwickelt. In dieser Reihe werden wir RabbitMQ und Kafka im Zusammenhang mit ihrer Verwendung in Echtzeitinfrastrukturen n√§her betrachten. </p><br><p> Apache Kafka ist jetzt auf dem Vormarsch, aber es scheint, dass sie begonnen haben, RabbitMQ zu vergessen.  Jeder Hype konzentrierte sich auf Kafka, und dies geschieht aus offensichtlichen Gr√ºnden, aber RabbitMQ ist immer noch eine gute Wahl f√ºr Messaging.  Einer der Gr√ºnde, warum Kafka seine Aufmerksamkeit auf sich selbst gelenkt hat, ist seine allgemeine Besessenheit von Skalierbarkeit, und offensichtlich ist Kafka skalierbarer als RabbitMQ, aber die meisten von uns haben keine Bedenken hinsichtlich der Skalen, bei denen RabbitMQ Probleme hat.  Die meisten von uns sind nicht Google oder Facebook.  Die meisten von uns besch√§ftigen sich mit t√§glichen Nachrichtenmengen von Hunderttausenden bis Hunderten von Millionen und nicht mit Mengen von Milliarden bis Billionen (aber es gibt √ºbrigens F√§lle, in denen Menschen RabbitMQ auf Milliarden von t√§glichen Nachrichten skalierten). </p><br><p>  Daher werden wir in unserer Artikelserie nicht √ºber F√§lle sprechen, in denen extreme Skalierbarkeit erforderlich ist (und dies ist das Vorrecht von Kafka), sondern uns auf die einzigartigen Vorteile konzentrieren, die jedes der betrachteten Systeme bietet.  Interessanterweise hat jedes System seine eigenen Vorteile, aber gleichzeitig unterscheiden sie sich erheblich voneinander.  Nat√ºrlich habe ich viel √ºber RabbitMQ geschrieben, aber ich versichere Ihnen, dass ich dem keine besondere Pr√§ferenz gebe.  Ich mag gut gemachte Dinge, und RabbitMQ und Kafka sind beide ziemlich ausgereifte, zuverl√§ssige und, ja, skalierbare Messagingsysteme. </p><br><p>  Wir werden auf der obersten Ebene beginnen und dann beginnen, die verschiedenen Aspekte dieser beiden Technologien zu untersuchen.  Diese Artikelserie richtet sich an Fachleute, die mit der Organisation von Messagingsystemen befasst sind, oder an Architekten / Ingenieure, die die Details der unteren Ebene und ihre Anwendung verstehen m√∂chten.  Wir werden keinen Code schreiben, sondern uns auf die Funktionalit√§t beider Systeme konzentrieren, auf die Messaging-Prozessvorlagen, die jeder von ihnen bietet, und auf die Entscheidungen, die Entwickler und Architekten treffen m√ºssen. </p><br><h2 id="rabbitmq-protiv-kafka-dva-raznyh-podhoda-k-obmenu-soobscheniyami">  RabbitMQ vs. Kafka: Zwei verschiedene Messaging-Ans√§tze </h2><br><p>  In diesem Teil werden wir uns ansehen, was RabbitMQ und Apache Kafka sind und wie sie mit Messaging umgehen.  Beide Systeme n√§hern sich der Messaging-Architektur aus verschiedenen Blickwinkeln, von denen jedes St√§rken und Schw√§chen aufweist.  In diesem Kapitel werden wir keine wichtigen Schlussfolgerungen ziehen. Stattdessen schlagen wir vor, diesen Artikel als Technologiehandbuch f√ºr Anf√§nger zu verwenden, damit wir in den n√§chsten Artikeln der Reihe tiefer eintauchen k√∂nnen. </p><br><h3 id="rabbitmq">  Rabbitmq </h3><br><p>  RabbitMQ ist ein Verwaltungssystem f√ºr verteilte Nachrichtenwarteschlangen.  Verteilt, da es normalerweise als Cluster von Knoten funktioniert, bei denen Warteschlangen auf Knoten verteilt und optional repliziert werden, um fehlerresistent und hochverf√ºgbar zu sein.  Regelm√§√üig implementiert es AMQP 0.9.1 und bietet √ºber zus√§tzliche Module andere Protokolle wie STOMP, MQTT und HTTP an. </p><br><p>  RabbitMQ verwendet sowohl klassische als auch innovative Messaging-Ans√§tze.  Klassisch in dem Sinne, dass es sich auf die Nachrichtenwarteschlange konzentriert und innovativ - in der M√∂glichkeit eines flexiblen Routings.  Diese Routing-Funktion ist ihr einzigartiger Vorteil.  Die Erstellung eines schnellen, skalierbaren und zuverl√§ssigen verteilten Messaging-Systems ist an sich schon eine Errungenschaft, aber die Messaging-Routing-Funktionalit√§t macht es unter vielen Messaging-Technologien wirklich herausragend. </p><br><h3 id="exchangei-i-ocheredi">  Austausch und Warteschlangen </h3><br><p>  Super vereinfachte √úberpr√ºfung: </p><br><ul><li>  Verlage (Verlage) senden Nachrichten an B√∂rsen </li><li>  Exchange'i sendet Nachrichten in Warteschlangen und an andere B√∂rsen </li><li>  RabbitMQ sendet nach Erhalt einer Nachricht Best√§tigungen an die Herausgeber </li><li>  Empf√§nger (Verbraucher) unterhalten dauerhafte TCP-Verbindungen zu RabbitMQ und geben bekannt, welche Warteschlange (n) sie erhalten </li><li>  RabbitMQ sendet Nachrichten an Empf√§nger </li><li>  Empf√§nger senden Erfolgs- / Fehlerbest√§tigungen </li><li>  Nach erfolgreichem Empfang werden Nachrichten aus den Warteschlangen entfernt. </li></ul><br><p>  Diese Liste enth√§lt eine Vielzahl von Entscheidungen, die Entwickler und Administratoren treffen m√ºssen, um die erforderlichen Liefergarantien, Leistungsmerkmale usw. zu erhalten, auf die wir sp√§ter noch eingehen werden. </p><br><p>  Sehen wir uns ein Beispiel f√ºr die Arbeit mit einem Publisher, einem Exchange, einer Warteschlange und einem Empf√§nger an: </p><br><p><img src="https://habrastorage.org/webt/u2/ii/3d/u2ii3dm9jk-nuzly06mpebzac8y.png"><br>  <em>Abb.</em>  <em>1. Ein Verlag und ein Empf√§nger</em> </p><br><p>  Was tun, wenn Sie mehrere Herausgeber desselben haben? <br>  Nachrichten?  Was ist, wenn wir mehrere Empf√§nger haben, von denen jeder alle Nachrichten empfangen m√∂chte? </p><br><p><img src="https://habrastorage.org/webt/ug/tw/3d/ugtw3df8efgqhmwpwfs47b9ivoo.png"><br>  <em>Abb.</em>  <em>2. Mehrere Verlage, mehrere unabh√§ngige Empf√§nger</em> </p><br><p>  Wie Sie sehen k√∂nnen, senden Publisher ihre Nachrichten an denselben Austauscher, der jede Nachricht in drei Warteschlangen sendet, von denen jede einen Empf√§nger hat.  Im Fall von RabbitMQ erm√∂glichen Warteschlangen verschiedenen Empf√§ngern, alle Nachrichten zu empfangen.  Vergleichen Sie mit der folgenden Tabelle: </p><br><p><img src="https://habrastorage.org/webt/2_/dj/vd/2_djvdk1k1tnb9u-z9x3q9k2k6o.png"><br>  <em>Abb.</em>  <em>3. Mehrere Herausgeber, eine Warteschlange mit mehreren konkurrierenden Empf√§ngern</em> <em><br></em> </p><br><p>  In Abbildung 3 sehen wir drei Empf√§nger, die dieselbe Warteschlange verwenden.  Dies sind konkurrierende Empf√§nger, dh sie konkurrieren um den Empfang von Nachrichten aus der Warteschlange.  Somit ist zu erwarten, dass durchschnittlich jeder Empf√§nger ein Drittel der Nachrichten in der Warteschlange empf√§ngt.  Wir verwenden konkurrierende Empf√§nger, um unser Nachrichtenverarbeitungssystem zu skalieren, und mit RabbitMQ ist dies sehr einfach: Hinzuf√ºgen oder Entfernen von Empf√§ngern auf Anfrage.  Unabh√§ngig davon, wie viele konkurrierende Empf√§nger Sie haben, liefert RabbitMQ nur Nachrichten an einen Empf√§nger. </p><br><p>  Wir k√∂nnen Reis kombinieren.  2 und 3, um mehrere S√§tze konkurrierender Empf√§nger zu empfangen, wobei jeder Satz jede Nachricht empf√§ngt. </p><br><p><img src="https://habrastorage.org/webt/gr/g4/pk/grg4pk5gfkbocpagiccsvcd3oro.png"><br>  <em>Abb.</em>  <em>4. Mehrere Verlage, mehrere Warteschlangen mit konkurrierenden Empf√§ngern</em> </p><br><p>  Die Pfeile zwischen Austauschern und Warteschlangen werden als Bindungen bezeichnet, und wir werden ausf√ºhrlicher darauf eingehen. </p><br><h3 id="garantii">  Garantien </h3><br><p>  RabbitMQ gibt Garantien f√ºr "einmalige Lieferung" und "mindestens eine Lieferung", jedoch nicht "genau eine Lieferung". </p><br><p>  <em>Anmerkung des √úbersetzers: Vor Kafka Version 0.11 war die Zustellung von Nachrichten mit genau einmaliger Zustellung nicht verf√ºgbar. Derzeit ist in Kafka eine √§hnliche Funktionalit√§t vorhanden.</em> <em><br></em> </p><br><p>  Nachrichten werden in der Reihenfolge zugestellt, in der sie in der Warteschlange ankommen (schlie√ülich ist dies die Definition der Warteschlange).  Dies garantiert nicht, dass der Abschluss der Nachrichtenverarbeitung mit derselben Reihenfolge √ºbereinstimmt, wenn Sie konkurrierende Empf√§nger haben.  Dies ist kein RabbitMQ-Fehler, sondern die grundlegende Realit√§t der parallelen Verarbeitung eines geordneten Satzes von Nachrichten.  Dieses Problem kann mit Consistent Hashing Exchange gel√∂st werden, wie Sie im n√§chsten Kapitel zu Vorlagen und Topologien sehen werden. </p><br><h3 id="protalkivanie-push-i-predvaritelnaya-vyborka-poluchateley">  Push- und Prefetch-Empf√§nger </h3><br><p>  RabbitMQ sendet Nachrichten an Empf√§nger (es gibt auch eine API zum Abrufen von Nachrichten aus RabbitMQ, aber diese Funktionalit√§t ist derzeit veraltet).  Dies kann die Empf√§nger √ºberfordern, wenn die Nachrichten schneller in der Warteschlange ankommen, als die Empf√§nger sie verarbeiten k√∂nnen.  Um dies zu vermeiden, kann jeder Empf√§nger ein Prefetch-Limit festlegen (auch als QoS-Limit bezeichnet).  Tats√§chlich ist das QoS-Limit ein Limit f√ºr die Anzahl der Nachrichten, die vom akkumulierten Empf√§nger nicht best√§tigt wurden.  Es wirkt wie eine Sicherung, wenn der Empf√§nger zu verz√∂gern beginnt. </p><br><p>  Warum wurde entschieden, dass Nachrichten in der Warteschlange gepusht (Push) und nicht entladen (Pull) werden?  Erstens, weil es weniger Verz√∂gerungszeit gibt.  Zweitens m√∂chten wir im Idealfall, wenn wir konkurrierende Empf√§nger aus derselben Warteschlange haben, die Last gleichm√§√üig auf sie verteilen.  Wenn jeder Empf√§nger Nachrichten anfordert / herunterl√§dt, kann die Arbeitsverteilung je nach Anforderung sehr ungleichm√§√üig werden.  Je ungleichm√§√üiger die Verteilung der Nachrichten ist, desto gr√∂√üer ist die Verz√∂gerung und der weitere Verlust der Reihenfolge der Nachrichten w√§hrend der Verarbeitung.  Diese Faktoren orientieren die RabbitMQ-Architektur an einem Push-Mechanismus f√ºr jeweils eine Nachricht.  Dies ist eine der Einschr√§nkungen bei der Skalierung von RabbitMQ.  Die Einschr√§nkung wird durch die Tatsache gemindert, dass Best√§tigungen gruppiert werden k√∂nnen. </p><br><h3 id="marshrutizaciya">  Routing </h3><br><p>  Exchange sind im Grunde Nachrichtenrouter f√ºr Warteschlangen und / oder andere Austausche.  Damit eine Nachricht vom Austausch in eine Warteschlange oder in einen anderen Austausch verschoben werden kann, ist eine Bindung erforderlich.  Unterschiedlicher Austausch erfordert unterschiedliche Bindungen.  Es gibt vier Arten von Austausch und zugeh√∂rige Bindungen: </p><br><ul><li>  Fanout  Leitet alle Warteschlangen und Austauscher an, die zum Austausch des Standard-Submodells von Pub verpflichtet sind. </li><li>  Direkt (direkt).  Leitet Nachrichten basierend auf dem vom Herausgeber festgelegten Routing-Schl√ºssel weiter, den die Nachricht enth√§lt.  Der Routing-Schl√ºssel ist eine kurze Zeichenfolge.  Direkte Austauscher senden Nachrichten an / Exchange-Warteschlangen mit einem Pairing-Schl√ºssel, der genau mit dem Routing-Schl√ºssel √ºbereinstimmt. </li><li>  Thema (thematisch).  Leitet Nachrichten basierend auf dem Routing-Schl√ºssel weiter, erm√∂glicht jedoch die Verwendung eines unvollst√§ndigen Abgleichs (Platzhalter). </li><li>  Header (Header).  Mit RabbitMQ k√∂nnen Sie Nachrichten Empf√§nger-Header hinzuf√ºgen.  Header-Austausche senden Nachrichten gem√§√ü diesen Header-Werten.  Jede Bindung enth√§lt eine genaue √úbereinstimmung der Header-Werte.  Sie k√∂nnen der Bindung mehrere Werte hinzuf√ºgen, wobei ALLE oder ALLE Werte f√ºr die √úbereinstimmung erforderlich sind. </li><li>  Konsequentes Hashing.  Dies ist ein Austauscher, der entweder einen Routing-Schl√ºssel oder einen Nachrichtenkopf hascht und nur in einer Warteschlange sendet.  Dies ist n√ºtzlich, wenn Sie die Garantien f√ºr die Verarbeitung von Auftr√§gen einhalten und dennoch Empf√§nger skalieren m√ºssen. </li></ul><br><p><img src="https://habrastorage.org/webt/jb/2d/gr/jb2dgryq0qn6bivddj265nvuyeu.png"><br>  <em>Abb.</em>  <em>5. Beispiel f√ºr einen Themenaustausch</em> </p><br><p>  Wir werden auch das Routing genauer betrachten, aber das Beispiel f√ºr den Themenaustausch ist oben angegeben.  In diesem Beispiel ver√∂ffentlichen Publisher Fehlerprotokolle im Routing-Schl√ºsselformat LEVEL (Error Level) .AppName. </p><br><p>  Warteschlange 1 empf√§ngt alle Nachrichten, da eine Platzhalternummer mit mehreren W√∂rtern verwendet wird. </p><br><p>  Warteschlange 2 erh√§lt eine beliebige Stufe der ECommerce.WebUI-Anwendungsprotokollierung.  Es verwendet Platzhalter * und erfasst so die Ebene einer einzelnen Themennamen (ERROR.Ecommerce.WebUI, NOTICE.ECommerce.WebUI usw.). </p><br><p>  In Warteschlange 3 werden alle FEHLERMELDUNGEN einer beliebigen Anwendung angezeigt.  Es verwendet Platzhalter #, um alle Anwendungen abzudecken (ERROR.ECommerce.WebUi, ERROR.SomeApp.SomeSublevel usw.). </p><br><p>  Dank vier Methoden f√ºr das Weiterleiten von Nachrichten und der M√∂glichkeit, Nachrichten auszutauschen, um Nachrichten an andere Vermittlungsstellen zu senden, k√∂nnen Sie mit RabbitMQ einen leistungsstarken und flexiblen Satz von Vorlagen f√ºr den Nachrichtenaustausch verwenden.  Dar√ºber hinaus werden wir √ºber den Austausch mit toten Briefen, √ºber den Austausch und Warteschlangen ohne Daten (kurzlebiger Austausch und Warteschlangen) sprechen, und RabbitMQ wird sein volles Potenzial entfalten. </p><br><h3 id="exchangei-s-nedostavlennymi-soobscheniyami">  Nicht ausgelieferter Austausch </h3><br><p>  <em>Anmerkung des √úbersetzers: Wenn Nachrichten aus der Warteschlange aus dem einen oder anderen Grund nicht empfangen werden k√∂nnen (die Stromversorgung des Verbrauchers reicht nicht aus, Netzwerkprobleme usw.), k√∂nnen sie verz√∂gert und separat verarbeitet werden.</em> </p><br><p>  Wir k√∂nnen Warteschlangen so konfigurieren, dass Nachrichten unter den folgenden Bedingungen zum Austausch gesendet werden: </p><br><ul><li>  Die Warteschlange √ºberschreitet die angegebene Anzahl von Nachrichten. </li><li>  Die Warteschlange √ºberschreitet die angegebene Anzahl von Bytes. </li><li>  Die Nachrichten√ºbertragungszeit (TTL) ist abgelaufen.  Der Herausgeber kann die Nachrichtenlebensdauer festlegen, und die Warteschlange selbst kann auch eine angegebene TTL f√ºr die Nachricht haben.  In diesem Fall wird eine k√ºrzere TTL der beiden verwendet. </li></ul><br><p>  Wir erstellen eine Warteschlange, die an den Austausch mit nicht zugestellten Nachrichten gebunden ist, und diese Nachrichten werden dort gespeichert, bis eine Aktion ausgef√ºhrt wird. </p><br><p>  Wie bei vielen Funktionen von RabbitMQ k√∂nnen beim Austausch mit unzustellbaren Nachrichten Vorlagen verwendet werden, die urspr√ºnglich nicht bereitgestellt wurden.  Wir k√∂nnen TTL-Nachrichten verwenden und mit nicht zugestellten Nachrichten austauschen, um verz√∂gerte Warteschlangen zu implementieren und Warteschlangen erneut zu versuchen. </p><br><h3 id="obmenniki-i-ocheredi-bez-dannyh">  Tauscher und Warteschlangen ohne Daten </h3><br><p>  B√∂rsen und Warteschlangen k√∂nnen dynamisch erstellt werden, und Sie k√∂nnen Kriterien f√ºr ihre automatische Entfernung festlegen.  Dies erm√∂glicht die Verwendung von Mustern wie nachrichtenbasierten RPCs. </p><br><h3 id="dopolnitelnye-moduli">  Zus√§tzliche Module </h3><br><p>  Das erste Plug-In, das Sie wahrscheinlich installieren m√∂chten, ist das Verwaltungs-Plugin, das einen HTTP-Server mit einer Webschnittstelle und einer REST-API bereitstellt.  Es ist sehr einfach zu installieren und hat eine einfach zu bedienende Oberfl√§che.  Das Bereitstellen von Skripten √ºber die REST-API ist ebenfalls sehr einfach. </p><br><p>  Au√üerdem: </p><br><ul><li>  Konsistenter Hashing Exchange, Sharding Exchange und mehr </li><li>  Protokolle wie STOMP und MQTT </li><li>  Web-Hooks </li><li>  zus√§tzliche Arten von W√§rmetauschern </li><li>  SMTP-Integration </li></ul><br><p>  Es gibt viele andere Dinge, die √ºber RabbitMQ gesagt werden k√∂nnen, aber dies ist ein gutes Beispiel, mit dem Sie beschreiben k√∂nnen, was RabbitMQ tun kann.  Jetzt schauen wir uns Kafka an, das einen v√∂llig anderen Messaging-Ansatz verwendet und gleichzeitig seine eigenen charakteristischen Merkmale aufweist. </p><br><h3 id="apache-kafka">  Apache kafka </h3><br><p>  Kafka ist ein verteiltes repliziertes Festschreibungsprotokoll.  Kafka hat kein Konzept f√ºr Warteschlangen, was auf den ersten Blick seltsam erscheinen mag, da es als Nachrichtensystem verwendet wird.  Warteschlangen sind seit langem ein Synonym f√ºr Messagingsysteme.  Schauen wir uns zun√§chst an, was ein "verteiltes, repliziertes √Ñnderungs-Commit-Protokoll" bedeutet: </p><br><ul><li>  Verteilt, weil Kafka als Cluster von Knoten bereitgestellt wird, sowohl aus Gr√ºnden der Fehlertoleranz als auch zur Skalierung </li><li>  Repliziert, da Nachrichten normalerweise auf mehreren Knoten (Servern) repliziert werden. </li><li>  Ein Festschreibungsprotokoll, da Nachrichten in segmentierten Nur-Anh√§ngen-Protokollen gespeichert werden, die als Themen bezeichnet werden.  Dieses Protokollierungskonzept ist der wichtigste einzigartige Vorteil von Kafka. </li></ul><br><p>  Das Verst√§ndnis des Journals (und des Themas) und der Partitionen ist der Schl√ºssel zum Verst√§ndnis von Kafka.  Wie unterscheidet sich ein partitioniertes Protokoll von einer Reihe von Warteschlangen?  Stellen wir uns vor, wie es aussieht. </p><br><p><img src="https://habrastorage.org/webt/sg/r-/lr/sgr-lrlwlvgr-hxciwvo5uk3ix0.png"><br>  <em>Abb.</em>  <em>6 Ein Produzent, ein Segment, ein Empf√§nger</em> </p><br><p>  Anstatt Nachrichten in die FIFO-Warteschlange zu stellen und den Status dieser Nachricht in der Warteschlange zu √ºberwachen, wie es RabbitMQ tut, f√ºgt Kafka sie einfach dem Protokoll hinzu, und das ist alles. </p><br><p>  Die Nachricht bleibt bestehen, unabh√§ngig davon, ob sie einmal oder mehrmals empfangen wurde.  Es wird gem√§√ü der Aufbewahrungsrichtlinie, auch Fensterzeitraum genannt, gel√∂scht.  Wie werden Informationen aus dem Thema entnommen? </p><br><p>  Jeder Empf√§nger verfolgt, wo er sich im Protokoll befindet: Es gibt einen Zeiger auf die zuletzt empfangene Nachricht, und dieser Zeiger wird als Offset-Adresse bezeichnet.  Empf√§nger unterst√ºtzen diese Adresse √ºber Clientbibliotheken. Abh√§ngig von der Version von Kafka wird die Adresse entweder in ZooKeeper oder in Kafka selbst gespeichert. </p><br><p>  Eine Besonderheit des Journaling-Modells besteht darin, dass es viele Schwierigkeiten hinsichtlich des Status der Nachrichten√ºbermittlung sofort beseitigt und es den Empf√§ngern, was noch wichtiger ist, erm√∂glicht, Nachrichten an der vorherigen relativen Adresse zur√ºckzuspulen, zur√ºckzugeben und zu empfangen.  Stellen Sie sich beispielsweise vor, Sie stellen einen Service bereit, der Rechnungen ausstellt, die Bestellungen von Kunden ber√ºcksichtigen.  Der Dienst hat einen Fehler und berechnet nicht alle Rechnungen innerhalb von 24 Stunden korrekt.  Mit RabbitMQ m√ºssen Sie diese Bestellungen bestenfalls nur √ºber den Kontoservice erneut ver√∂ffentlichen.  Mit Kafka verschieben Sie einfach die relative Adresse f√ºr diesen Empf√§nger vor 24 Stunden. </p><br><p>  Schauen wir uns also an, wie es aussieht, wenn es ein Thema gibt, in dem es eine Partition und zwei Empf√§nger gibt, von denen jeder jede Nachricht empfangen soll. </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Abb.</em>  <em>7. Ein Produzent, eine Partition, zwei unabh√§ngige Empf√§nger</em> </p><br><p>  Wie aus dem Diagramm ersichtlich, erhalten zwei unabh√§ngige Empf√§nger dieselbe Partition, lesen jedoch an unterschiedlichen Versatzadressen.  M√∂glicherweise dauert der Abrechnungsdienst l√§nger, um Nachrichten zu verarbeiten, als der Push-Benachrichtigungsdienst.  oder vielleicht war der Abrechnungsservice f√ºr einige Zeit nicht verf√ºgbar und versuchte sp√§ter aufzuholen.  Oder vielleicht lag ein Fehler vor und die Offset-Adresse musste um einige Stunden verschoben werden. </p><br><p>  Angenommen, der Abrechnungsservice muss in drei Teile unterteilt werden, da er nicht mit der Geschwindigkeit der Nachricht Schritt halten kann.  Mit RabbitMQ stellen wir einfach zwei weitere Abrechnungsdienstanwendungen bereit, die aus der Abrechnungswarteschlange stammen.  Kafka unterst√ºtzt jedoch keine konkurrierenden Empf√§nger in derselben Partition, da der Kafka-Parallelit√§tsblock die Partition selbst ist.  Wenn wir also drei Empf√§nger von Rechnungen ben√∂tigen, ben√∂tigen wir mindestens drei Partitionen.  Jetzt haben wir also: </p><br><p><img src="https://habrastorage.org/webt/3k/fn/rd/3kfnrdjpllbt0nqidfaxrveqvfc.png"><br>  <em>Abb.</em>  <em>8. Drei Partitionen und zwei Gruppen von drei Empf√§ngern</em> </p><br><p>  Es versteht sich daher, dass Sie mindestens so viele Partitionen ben√∂tigen wie der am meisten skalierte horizontale Empf√§nger.  Lassen Sie uns ein wenig √ºber Partitionen sprechen. </p><br><h3 id="particii-i-gruppy-poluchateley">  Partitionen und Empf√§ngergruppen </h3><br><p>  Jede Partition ist eine separate Datei, in der die Reihenfolge der Nachrichten garantiert ist.  Dies ist wichtig zu beachten: Die Nachrichtenreihenfolge ist nur in einer Partition garantiert.  In Zukunft kann dies zu einem gewissen Widerspruch zwischen den Anforderungen f√ºr die Nachrichtenwarteschlange und den Anforderungen f√ºr die Leistung f√ºhren, da die Leistung in Kafka auch durch Partitionen skaliert wird.  Die Partition kann keine konkurrierenden Empf√§nger unterst√ºtzen, daher kann unsere Abrechnungsanwendung nur einen Teil f√ºr jeden Abschnitt verwenden. </p><br><p>  Nachrichten k√∂nnen durch einen zyklischen Algorithmus oder √ºber eine Hash-Funktion in Segmente umgeleitet werden: Hash (Nachrichtenschl√ºssel)% Anzahl der Partitionen.      ,      ,     , ,   ,     ,     .            . </p><br><p>       RabbitMQ.                .   ,     RabbitMQ    ,              .  ,                . </p><br><p>   RabbitMQ                    .  Kafka ,      . </p><br><p>  ,   ,    Kafka   ,   RabbitMQ   ‚Äî    . RabbitMQ     ,            . Kafka      ,      . ,        ,  Kafka     ,     . </p><br><p> ,     ,      ,           (  ).       ,          ,     .  ,      ,      ,        . </p><br><p>      RabbitMQ ‚Äî   Consistent Hashing exchange,      .   Kafka'   ,  Kafka      ,             ,   , ,     ,      -.  RabbitMQ      ,     ,    ,    . </p><br><p>     :   ,     ,    Id 1000     ,     Id 1000    .    ,    ,    .   ,      . </p><br><h3 id="protalkivanie-push-protiv-vygruzki-pull">  (push)   (pull) </h3><br><p> RabbitMQ    (push) ,  ,          .                RabbitMQ   .   , Kafka    (pull),         .     ,          , Kafka  long-polling. </p><br><p>   (pull)    Kafka -  .  Kafka        ,           ,       . </p><br><p>       RabbitMQ,             ,     ,       ,      .   Kafka       ,            . </p><br><h3 id="publikaciya-i-podpiska">    </h3><br><p> Kafka    /¬ª    ,   ,       .       ,            . </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Abb.</em> <em>9.     </em> </p><br><p>       ,       ,       Kafka     : </p><br><p>  Abb. 10.  ,         <br> <em><img src="https://habrastorage.org/webt/zl/uu/eu/zluueuxxppnji50tgqnar-pnmfk.png"></em> </p><br><p>           ,   : </p><br><p><img src="https://habrastorage.org/webt/xo/bw/op/xobwopr8b9fey8huqbclx85mh4y.png"><br>  <em>Abb.</em> <em>11.      </em> </p><br><p>         , ,               . </p><br><p> ,     ,  ,     ,  . </p><br><p><img src="https://habrastorage.org/webt/uf/wn/a4/ufwna4h-bmmmr48gp0yo8akk4je.png"><br>  <em>Abb.</em> <em>12.   </em> </p><br><p>          .         . </p><br><p><img src="https://habrastorage.org/webt/ok/vs/ce/okvsce2-xvrnztcupmx-fkbyg5w.png"></p><br><p>      : </p><br><ul><li>      </li><li>      ( ,       ) </li><li>    </li></ul><br><p>           ,               .     ,   ,    . </p><br><p>     Kafka ‚Äì       , , ,     , ,     .    .            ,         .  ,   ,     . </p><br><h3 id="szhatie-zhurnala">   </h3><br><p>     ‚Äî       . ,        50 .        ‚Äì  .   ,   ,         ,  . </p><br><p>  ,    ,     .  ,    ,       .           ,         .  ,    ,      ,    . </p><br><p>                    .   ,  ,        . </p><br><h3 id="podrobnee-ob-uporyadochenii-soobscheniy">     </h3><br><p>  ,           RabbitMQ,    Kafka,   Kafka   .  RabbitMQ           ,    ,   ZooKeeper  Consul. </p><br><p>   RabbitMQ    ,    Kafka.      RabbitMQ,     ,      .  :            . </p><br><p>    .        ,         .     .         ,    .            .       .  ,   ,    -   . </p><br><p>           ,   Kafka,     .     .  ,         ,       . </p><br><p>  ,    . RabbitMQ        ,  Kafka        . </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p> RabbitMQ          ,    .           ,     ,     .    ,           .             ,     ,    . </p><br><p>   Kafka         .               ,         .   Kafka       ,  RabbitMQ    . ,  Kafka    ,  RabbitMQ,         ,       . </p><br><p>              RabbitMQ. </p><br><blockquote> , ,      IoT  ,    . : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">t.me/justiothings</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416629/">https://habr.com/ru/post/de416629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416619/index.html">Offenes Webinar ‚ÄûErstellen einer Website im Yii2-Framework‚Äú</a></li>
<li><a href="../de416621/index.html">Homo Extensis. Erweiterung der menschlichen F√§higkeiten oder Kombination von Mensch und Roboter</a></li>
<li><a href="../de416623/index.html">Die Objektivit√§t der Psychotherapie</a></li>
<li><a href="../de416625/index.html">Das von der Londoner Polizei installierte neue Gesichtserkennungssystem kann niemanden erkennen</a></li>
<li><a href="../de416627/index.html">Management des IT-F√∂rderers oder Hin und zur√ºck</a></li>
<li><a href="../de416633/index.html">QUIC, TLS 1.3, DNS-over-HTTPS, dann √ºberall</a></li>
<li><a href="../de416635/index.html">Von rechts nach links. So drehen Sie die Site-Schnittstelle unter RTL</a></li>
<li><a href="../de416637/index.html">Musik aus Papier und Pappe: eine kurze Geschichte des Variophons und des ‚Äûgezeichneten Klangs‚Äú</a></li>
<li><a href="../de416639/index.html">Interview mit einem Pionier der Verj√ºngung</a></li>
<li><a href="../de416641/index.html">8 Phasen des Prozesses zur Entwicklung einer mobilen Anwendungsschnittstelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>