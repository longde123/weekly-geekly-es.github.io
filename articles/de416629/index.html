<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤲🏽 📭 〽️ RabbitMQ vs. Kafka: Zwei verschiedene Messaging-Ansätze 🤘🏾 🤙🏿 ➕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In den letzten beiden Artikeln haben wir über IIoT gesprochen - das industrielle Internet der Dinge -, das eine Architektur zum Empfangen von Daten vo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RabbitMQ vs. Kafka: Zwei verschiedene Messaging-Ansätze</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/itsumma/blog/416629/"><p>  In den letzten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">beiden</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikeln haben</a> wir über IIoT gesprochen - das industrielle Internet der Dinge -, das eine Architektur zum Empfangen von Daten von Sensoren erstellt und die Sensoren selbst verlötet hat.  Der Eckpfeiler von IIoT-Architekturen und allen Architekturen, die mit BigData arbeiten, ist die Datenstromverarbeitung.  Es basiert auf dem Konzept von Messaging und Warteschlangen.  Der Standard für die Arbeit mit Messaging ist jetzt Apache Kafka.  Um jedoch seine Vorteile (und seine Nachteile) zu verstehen, wäre es gut, die Grundlagen des Betriebs von Warteschlangensystemen als Ganzes, ihre Funktionsmechanismen, Verwendungsmuster und Grundfunktionen zu verstehen. </p><br><p><img src="https://habrastorage.org/webt/-5/p1/rn/-5p1rnrr3yks4ukkp0kyovqykli.png"></p><br><p>  Wir haben eine ausgezeichnete Artikelserie gefunden, die die Funktionalität von Apache Kafka und einem anderen (unverdient ignorierten) Riesen unter den Warteschlangensystemen vergleicht - RabbitMQ.  Wir haben diese Artikelserie übersetzt, kommentiert und ergänzt.  Obwohl die Serie im Dezember 2017 geschrieben wurde, verändert sich die Welt der Messagingsysteme (und insbesondere von Apache Kafka) so schnell, dass sich bis zum Sommer 2018 einige Dinge geändert haben. </p><a name="habracut"></a><br><blockquote>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quelle</a> </blockquote><br><h2 id="rabbitmq-vs-kafka">  RabbitMQ gegen Kafka </h2><br><p>  Messaging ist der zentrale Teil vieler Architekturen, und die beiden Säulen in diesem Bereich sind RabbitMQ und Apache Kafka.  Bis heute hat sich Apache Kafka zu einem fast industriellen Standard in der Datenverarbeitung und -analyse entwickelt. In dieser Reihe werden wir RabbitMQ und Kafka im Zusammenhang mit ihrer Verwendung in Echtzeitinfrastrukturen näher betrachten. </p><br><p> Apache Kafka ist jetzt auf dem Vormarsch, aber es scheint, dass sie begonnen haben, RabbitMQ zu vergessen.  Jeder Hype konzentrierte sich auf Kafka, und dies geschieht aus offensichtlichen Gründen, aber RabbitMQ ist immer noch eine gute Wahl für Messaging.  Einer der Gründe, warum Kafka seine Aufmerksamkeit auf sich selbst gelenkt hat, ist seine allgemeine Besessenheit von Skalierbarkeit, und offensichtlich ist Kafka skalierbarer als RabbitMQ, aber die meisten von uns haben keine Bedenken hinsichtlich der Skalen, bei denen RabbitMQ Probleme hat.  Die meisten von uns sind nicht Google oder Facebook.  Die meisten von uns beschäftigen sich mit täglichen Nachrichtenmengen von Hunderttausenden bis Hunderten von Millionen und nicht mit Mengen von Milliarden bis Billionen (aber es gibt übrigens Fälle, in denen Menschen RabbitMQ auf Milliarden von täglichen Nachrichten skalierten). </p><br><p>  Daher werden wir in unserer Artikelserie nicht über Fälle sprechen, in denen extreme Skalierbarkeit erforderlich ist (und dies ist das Vorrecht von Kafka), sondern uns auf die einzigartigen Vorteile konzentrieren, die jedes der betrachteten Systeme bietet.  Interessanterweise hat jedes System seine eigenen Vorteile, aber gleichzeitig unterscheiden sie sich erheblich voneinander.  Natürlich habe ich viel über RabbitMQ geschrieben, aber ich versichere Ihnen, dass ich dem keine besondere Präferenz gebe.  Ich mag gut gemachte Dinge, und RabbitMQ und Kafka sind beide ziemlich ausgereifte, zuverlässige und, ja, skalierbare Messagingsysteme. </p><br><p>  Wir werden auf der obersten Ebene beginnen und dann beginnen, die verschiedenen Aspekte dieser beiden Technologien zu untersuchen.  Diese Artikelserie richtet sich an Fachleute, die mit der Organisation von Messagingsystemen befasst sind, oder an Architekten / Ingenieure, die die Details der unteren Ebene und ihre Anwendung verstehen möchten.  Wir werden keinen Code schreiben, sondern uns auf die Funktionalität beider Systeme konzentrieren, auf die Messaging-Prozessvorlagen, die jeder von ihnen bietet, und auf die Entscheidungen, die Entwickler und Architekten treffen müssen. </p><br><h2 id="rabbitmq-protiv-kafka-dva-raznyh-podhoda-k-obmenu-soobscheniyami">  RabbitMQ vs. Kafka: Zwei verschiedene Messaging-Ansätze </h2><br><p>  In diesem Teil werden wir uns ansehen, was RabbitMQ und Apache Kafka sind und wie sie mit Messaging umgehen.  Beide Systeme nähern sich der Messaging-Architektur aus verschiedenen Blickwinkeln, von denen jedes Stärken und Schwächen aufweist.  In diesem Kapitel werden wir keine wichtigen Schlussfolgerungen ziehen. Stattdessen schlagen wir vor, diesen Artikel als Technologiehandbuch für Anfänger zu verwenden, damit wir in den nächsten Artikeln der Reihe tiefer eintauchen können. </p><br><h3 id="rabbitmq">  Rabbitmq </h3><br><p>  RabbitMQ ist ein Verwaltungssystem für verteilte Nachrichtenwarteschlangen.  Verteilt, da es normalerweise als Cluster von Knoten funktioniert, bei denen Warteschlangen auf Knoten verteilt und optional repliziert werden, um fehlerresistent und hochverfügbar zu sein.  Regelmäßig implementiert es AMQP 0.9.1 und bietet über zusätzliche Module andere Protokolle wie STOMP, MQTT und HTTP an. </p><br><p>  RabbitMQ verwendet sowohl klassische als auch innovative Messaging-Ansätze.  Klassisch in dem Sinne, dass es sich auf die Nachrichtenwarteschlange konzentriert und innovativ - in der Möglichkeit eines flexiblen Routings.  Diese Routing-Funktion ist ihr einzigartiger Vorteil.  Die Erstellung eines schnellen, skalierbaren und zuverlässigen verteilten Messaging-Systems ist an sich schon eine Errungenschaft, aber die Messaging-Routing-Funktionalität macht es unter vielen Messaging-Technologien wirklich herausragend. </p><br><h3 id="exchangei-i-ocheredi">  Austausch und Warteschlangen </h3><br><p>  Super vereinfachte Überprüfung: </p><br><ul><li>  Verlage (Verlage) senden Nachrichten an Börsen </li><li>  Exchange'i sendet Nachrichten in Warteschlangen und an andere Börsen </li><li>  RabbitMQ sendet nach Erhalt einer Nachricht Bestätigungen an die Herausgeber </li><li>  Empfänger (Verbraucher) unterhalten dauerhafte TCP-Verbindungen zu RabbitMQ und geben bekannt, welche Warteschlange (n) sie erhalten </li><li>  RabbitMQ sendet Nachrichten an Empfänger </li><li>  Empfänger senden Erfolgs- / Fehlerbestätigungen </li><li>  Nach erfolgreichem Empfang werden Nachrichten aus den Warteschlangen entfernt. </li></ul><br><p>  Diese Liste enthält eine Vielzahl von Entscheidungen, die Entwickler und Administratoren treffen müssen, um die erforderlichen Liefergarantien, Leistungsmerkmale usw. zu erhalten, auf die wir später noch eingehen werden. </p><br><p>  Sehen wir uns ein Beispiel für die Arbeit mit einem Publisher, einem Exchange, einer Warteschlange und einem Empfänger an: </p><br><p><img src="https://habrastorage.org/webt/u2/ii/3d/u2ii3dm9jk-nuzly06mpebzac8y.png"><br>  <em>Abb.</em>  <em>1. Ein Verlag und ein Empfänger</em> </p><br><p>  Was tun, wenn Sie mehrere Herausgeber desselben haben? <br>  Nachrichten?  Was ist, wenn wir mehrere Empfänger haben, von denen jeder alle Nachrichten empfangen möchte? </p><br><p><img src="https://habrastorage.org/webt/ug/tw/3d/ugtw3df8efgqhmwpwfs47b9ivoo.png"><br>  <em>Abb.</em>  <em>2. Mehrere Verlage, mehrere unabhängige Empfänger</em> </p><br><p>  Wie Sie sehen können, senden Publisher ihre Nachrichten an denselben Austauscher, der jede Nachricht in drei Warteschlangen sendet, von denen jede einen Empfänger hat.  Im Fall von RabbitMQ ermöglichen Warteschlangen verschiedenen Empfängern, alle Nachrichten zu empfangen.  Vergleichen Sie mit der folgenden Tabelle: </p><br><p><img src="https://habrastorage.org/webt/2_/dj/vd/2_djvdk1k1tnb9u-z9x3q9k2k6o.png"><br>  <em>Abb.</em>  <em>3. Mehrere Herausgeber, eine Warteschlange mit mehreren konkurrierenden Empfängern</em> <em><br></em> </p><br><p>  In Abbildung 3 sehen wir drei Empfänger, die dieselbe Warteschlange verwenden.  Dies sind konkurrierende Empfänger, dh sie konkurrieren um den Empfang von Nachrichten aus der Warteschlange.  Somit ist zu erwarten, dass durchschnittlich jeder Empfänger ein Drittel der Nachrichten in der Warteschlange empfängt.  Wir verwenden konkurrierende Empfänger, um unser Nachrichtenverarbeitungssystem zu skalieren, und mit RabbitMQ ist dies sehr einfach: Hinzufügen oder Entfernen von Empfängern auf Anfrage.  Unabhängig davon, wie viele konkurrierende Empfänger Sie haben, liefert RabbitMQ nur Nachrichten an einen Empfänger. </p><br><p>  Wir können Reis kombinieren.  2 und 3, um mehrere Sätze konkurrierender Empfänger zu empfangen, wobei jeder Satz jede Nachricht empfängt. </p><br><p><img src="https://habrastorage.org/webt/gr/g4/pk/grg4pk5gfkbocpagiccsvcd3oro.png"><br>  <em>Abb.</em>  <em>4. Mehrere Verlage, mehrere Warteschlangen mit konkurrierenden Empfängern</em> </p><br><p>  Die Pfeile zwischen Austauschern und Warteschlangen werden als Bindungen bezeichnet, und wir werden ausführlicher darauf eingehen. </p><br><h3 id="garantii">  Garantien </h3><br><p>  RabbitMQ gibt Garantien für "einmalige Lieferung" und "mindestens eine Lieferung", jedoch nicht "genau eine Lieferung". </p><br><p>  <em>Anmerkung des Übersetzers: Vor Kafka Version 0.11 war die Zustellung von Nachrichten mit genau einmaliger Zustellung nicht verfügbar. Derzeit ist in Kafka eine ähnliche Funktionalität vorhanden.</em> <em><br></em> </p><br><p>  Nachrichten werden in der Reihenfolge zugestellt, in der sie in der Warteschlange ankommen (schließlich ist dies die Definition der Warteschlange).  Dies garantiert nicht, dass der Abschluss der Nachrichtenverarbeitung mit derselben Reihenfolge übereinstimmt, wenn Sie konkurrierende Empfänger haben.  Dies ist kein RabbitMQ-Fehler, sondern die grundlegende Realität der parallelen Verarbeitung eines geordneten Satzes von Nachrichten.  Dieses Problem kann mit Consistent Hashing Exchange gelöst werden, wie Sie im nächsten Kapitel zu Vorlagen und Topologien sehen werden. </p><br><h3 id="protalkivanie-push-i-predvaritelnaya-vyborka-poluchateley">  Push- und Prefetch-Empfänger </h3><br><p>  RabbitMQ sendet Nachrichten an Empfänger (es gibt auch eine API zum Abrufen von Nachrichten aus RabbitMQ, aber diese Funktionalität ist derzeit veraltet).  Dies kann die Empfänger überfordern, wenn die Nachrichten schneller in der Warteschlange ankommen, als die Empfänger sie verarbeiten können.  Um dies zu vermeiden, kann jeder Empfänger ein Prefetch-Limit festlegen (auch als QoS-Limit bezeichnet).  Tatsächlich ist das QoS-Limit ein Limit für die Anzahl der Nachrichten, die vom akkumulierten Empfänger nicht bestätigt wurden.  Es wirkt wie eine Sicherung, wenn der Empfänger zu verzögern beginnt. </p><br><p>  Warum wurde entschieden, dass Nachrichten in der Warteschlange gepusht (Push) und nicht entladen (Pull) werden?  Erstens, weil es weniger Verzögerungszeit gibt.  Zweitens möchten wir im Idealfall, wenn wir konkurrierende Empfänger aus derselben Warteschlange haben, die Last gleichmäßig auf sie verteilen.  Wenn jeder Empfänger Nachrichten anfordert / herunterlädt, kann die Arbeitsverteilung je nach Anforderung sehr ungleichmäßig werden.  Je ungleichmäßiger die Verteilung der Nachrichten ist, desto größer ist die Verzögerung und der weitere Verlust der Reihenfolge der Nachrichten während der Verarbeitung.  Diese Faktoren orientieren die RabbitMQ-Architektur an einem Push-Mechanismus für jeweils eine Nachricht.  Dies ist eine der Einschränkungen bei der Skalierung von RabbitMQ.  Die Einschränkung wird durch die Tatsache gemindert, dass Bestätigungen gruppiert werden können. </p><br><h3 id="marshrutizaciya">  Routing </h3><br><p>  Exchange sind im Grunde Nachrichtenrouter für Warteschlangen und / oder andere Austausche.  Damit eine Nachricht vom Austausch in eine Warteschlange oder in einen anderen Austausch verschoben werden kann, ist eine Bindung erforderlich.  Unterschiedlicher Austausch erfordert unterschiedliche Bindungen.  Es gibt vier Arten von Austausch und zugehörige Bindungen: </p><br><ul><li>  Fanout  Leitet alle Warteschlangen und Austauscher an, die zum Austausch des Standard-Submodells von Pub verpflichtet sind. </li><li>  Direkt (direkt).  Leitet Nachrichten basierend auf dem vom Herausgeber festgelegten Routing-Schlüssel weiter, den die Nachricht enthält.  Der Routing-Schlüssel ist eine kurze Zeichenfolge.  Direkte Austauscher senden Nachrichten an / Exchange-Warteschlangen mit einem Pairing-Schlüssel, der genau mit dem Routing-Schlüssel übereinstimmt. </li><li>  Thema (thematisch).  Leitet Nachrichten basierend auf dem Routing-Schlüssel weiter, ermöglicht jedoch die Verwendung eines unvollständigen Abgleichs (Platzhalter). </li><li>  Header (Header).  Mit RabbitMQ können Sie Nachrichten Empfänger-Header hinzufügen.  Header-Austausche senden Nachrichten gemäß diesen Header-Werten.  Jede Bindung enthält eine genaue Übereinstimmung der Header-Werte.  Sie können der Bindung mehrere Werte hinzufügen, wobei ALLE oder ALLE Werte für die Übereinstimmung erforderlich sind. </li><li>  Konsequentes Hashing.  Dies ist ein Austauscher, der entweder einen Routing-Schlüssel oder einen Nachrichtenkopf hascht und nur in einer Warteschlange sendet.  Dies ist nützlich, wenn Sie die Garantien für die Verarbeitung von Aufträgen einhalten und dennoch Empfänger skalieren müssen. </li></ul><br><p><img src="https://habrastorage.org/webt/jb/2d/gr/jb2dgryq0qn6bivddj265nvuyeu.png"><br>  <em>Abb.</em>  <em>5. Beispiel für einen Themenaustausch</em> </p><br><p>  Wir werden auch das Routing genauer betrachten, aber das Beispiel für den Themenaustausch ist oben angegeben.  In diesem Beispiel veröffentlichen Publisher Fehlerprotokolle im Routing-Schlüsselformat LEVEL (Error Level) .AppName. </p><br><p>  Warteschlange 1 empfängt alle Nachrichten, da eine Platzhalternummer mit mehreren Wörtern verwendet wird. </p><br><p>  Warteschlange 2 erhält eine beliebige Stufe der ECommerce.WebUI-Anwendungsprotokollierung.  Es verwendet Platzhalter * und erfasst so die Ebene einer einzelnen Themennamen (ERROR.Ecommerce.WebUI, NOTICE.ECommerce.WebUI usw.). </p><br><p>  In Warteschlange 3 werden alle FEHLERMELDUNGEN einer beliebigen Anwendung angezeigt.  Es verwendet Platzhalter #, um alle Anwendungen abzudecken (ERROR.ECommerce.WebUi, ERROR.SomeApp.SomeSublevel usw.). </p><br><p>  Dank vier Methoden für das Weiterleiten von Nachrichten und der Möglichkeit, Nachrichten auszutauschen, um Nachrichten an andere Vermittlungsstellen zu senden, können Sie mit RabbitMQ einen leistungsstarken und flexiblen Satz von Vorlagen für den Nachrichtenaustausch verwenden.  Darüber hinaus werden wir über den Austausch mit toten Briefen, über den Austausch und Warteschlangen ohne Daten (kurzlebiger Austausch und Warteschlangen) sprechen, und RabbitMQ wird sein volles Potenzial entfalten. </p><br><h3 id="exchangei-s-nedostavlennymi-soobscheniyami">  Nicht ausgelieferter Austausch </h3><br><p>  <em>Anmerkung des Übersetzers: Wenn Nachrichten aus der Warteschlange aus dem einen oder anderen Grund nicht empfangen werden können (die Stromversorgung des Verbrauchers reicht nicht aus, Netzwerkprobleme usw.), können sie verzögert und separat verarbeitet werden.</em> </p><br><p>  Wir können Warteschlangen so konfigurieren, dass Nachrichten unter den folgenden Bedingungen zum Austausch gesendet werden: </p><br><ul><li>  Die Warteschlange überschreitet die angegebene Anzahl von Nachrichten. </li><li>  Die Warteschlange überschreitet die angegebene Anzahl von Bytes. </li><li>  Die Nachrichtenübertragungszeit (TTL) ist abgelaufen.  Der Herausgeber kann die Nachrichtenlebensdauer festlegen, und die Warteschlange selbst kann auch eine angegebene TTL für die Nachricht haben.  In diesem Fall wird eine kürzere TTL der beiden verwendet. </li></ul><br><p>  Wir erstellen eine Warteschlange, die an den Austausch mit nicht zugestellten Nachrichten gebunden ist, und diese Nachrichten werden dort gespeichert, bis eine Aktion ausgeführt wird. </p><br><p>  Wie bei vielen Funktionen von RabbitMQ können beim Austausch mit unzustellbaren Nachrichten Vorlagen verwendet werden, die ursprünglich nicht bereitgestellt wurden.  Wir können TTL-Nachrichten verwenden und mit nicht zugestellten Nachrichten austauschen, um verzögerte Warteschlangen zu implementieren und Warteschlangen erneut zu versuchen. </p><br><h3 id="obmenniki-i-ocheredi-bez-dannyh">  Tauscher und Warteschlangen ohne Daten </h3><br><p>  Börsen und Warteschlangen können dynamisch erstellt werden, und Sie können Kriterien für ihre automatische Entfernung festlegen.  Dies ermöglicht die Verwendung von Mustern wie nachrichtenbasierten RPCs. </p><br><h3 id="dopolnitelnye-moduli">  Zusätzliche Module </h3><br><p>  Das erste Plug-In, das Sie wahrscheinlich installieren möchten, ist das Verwaltungs-Plugin, das einen HTTP-Server mit einer Webschnittstelle und einer REST-API bereitstellt.  Es ist sehr einfach zu installieren und hat eine einfach zu bedienende Oberfläche.  Das Bereitstellen von Skripten über die REST-API ist ebenfalls sehr einfach. </p><br><p>  Außerdem: </p><br><ul><li>  Konsistenter Hashing Exchange, Sharding Exchange und mehr </li><li>  Protokolle wie STOMP und MQTT </li><li>  Web-Hooks </li><li>  zusätzliche Arten von Wärmetauschern </li><li>  SMTP-Integration </li></ul><br><p>  Es gibt viele andere Dinge, die über RabbitMQ gesagt werden können, aber dies ist ein gutes Beispiel, mit dem Sie beschreiben können, was RabbitMQ tun kann.  Jetzt schauen wir uns Kafka an, das einen völlig anderen Messaging-Ansatz verwendet und gleichzeitig seine eigenen charakteristischen Merkmale aufweist. </p><br><h3 id="apache-kafka">  Apache kafka </h3><br><p>  Kafka ist ein verteiltes repliziertes Festschreibungsprotokoll.  Kafka hat kein Konzept für Warteschlangen, was auf den ersten Blick seltsam erscheinen mag, da es als Nachrichtensystem verwendet wird.  Warteschlangen sind seit langem ein Synonym für Messagingsysteme.  Schauen wir uns zunächst an, was ein "verteiltes, repliziertes Änderungs-Commit-Protokoll" bedeutet: </p><br><ul><li>  Verteilt, weil Kafka als Cluster von Knoten bereitgestellt wird, sowohl aus Gründen der Fehlertoleranz als auch zur Skalierung </li><li>  Repliziert, da Nachrichten normalerweise auf mehreren Knoten (Servern) repliziert werden. </li><li>  Ein Festschreibungsprotokoll, da Nachrichten in segmentierten Nur-Anhängen-Protokollen gespeichert werden, die als Themen bezeichnet werden.  Dieses Protokollierungskonzept ist der wichtigste einzigartige Vorteil von Kafka. </li></ul><br><p>  Das Verständnis des Journals (und des Themas) und der Partitionen ist der Schlüssel zum Verständnis von Kafka.  Wie unterscheidet sich ein partitioniertes Protokoll von einer Reihe von Warteschlangen?  Stellen wir uns vor, wie es aussieht. </p><br><p><img src="https://habrastorage.org/webt/sg/r-/lr/sgr-lrlwlvgr-hxciwvo5uk3ix0.png"><br>  <em>Abb.</em>  <em>6 Ein Produzent, ein Segment, ein Empfänger</em> </p><br><p>  Anstatt Nachrichten in die FIFO-Warteschlange zu stellen und den Status dieser Nachricht in der Warteschlange zu überwachen, wie es RabbitMQ tut, fügt Kafka sie einfach dem Protokoll hinzu, und das ist alles. </p><br><p>  Die Nachricht bleibt bestehen, unabhängig davon, ob sie einmal oder mehrmals empfangen wurde.  Es wird gemäß der Aufbewahrungsrichtlinie, auch Fensterzeitraum genannt, gelöscht.  Wie werden Informationen aus dem Thema entnommen? </p><br><p>  Jeder Empfänger verfolgt, wo er sich im Protokoll befindet: Es gibt einen Zeiger auf die zuletzt empfangene Nachricht, und dieser Zeiger wird als Offset-Adresse bezeichnet.  Empfänger unterstützen diese Adresse über Clientbibliotheken. Abhängig von der Version von Kafka wird die Adresse entweder in ZooKeeper oder in Kafka selbst gespeichert. </p><br><p>  Eine Besonderheit des Journaling-Modells besteht darin, dass es viele Schwierigkeiten hinsichtlich des Status der Nachrichtenübermittlung sofort beseitigt und es den Empfängern, was noch wichtiger ist, ermöglicht, Nachrichten an der vorherigen relativen Adresse zurückzuspulen, zurückzugeben und zu empfangen.  Stellen Sie sich beispielsweise vor, Sie stellen einen Service bereit, der Rechnungen ausstellt, die Bestellungen von Kunden berücksichtigen.  Der Dienst hat einen Fehler und berechnet nicht alle Rechnungen innerhalb von 24 Stunden korrekt.  Mit RabbitMQ müssen Sie diese Bestellungen bestenfalls nur über den Kontoservice erneut veröffentlichen.  Mit Kafka verschieben Sie einfach die relative Adresse für diesen Empfänger vor 24 Stunden. </p><br><p>  Schauen wir uns also an, wie es aussieht, wenn es ein Thema gibt, in dem es eine Partition und zwei Empfänger gibt, von denen jeder jede Nachricht empfangen soll. </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Abb.</em>  <em>7. Ein Produzent, eine Partition, zwei unabhängige Empfänger</em> </p><br><p>  Wie aus dem Diagramm ersichtlich, erhalten zwei unabhängige Empfänger dieselbe Partition, lesen jedoch an unterschiedlichen Versatzadressen.  Möglicherweise dauert der Abrechnungsdienst länger, um Nachrichten zu verarbeiten, als der Push-Benachrichtigungsdienst.  oder vielleicht war der Abrechnungsservice für einige Zeit nicht verfügbar und versuchte später aufzuholen.  Oder vielleicht lag ein Fehler vor und die Offset-Adresse musste um einige Stunden verschoben werden. </p><br><p>  Angenommen, der Abrechnungsservice muss in drei Teile unterteilt werden, da er nicht mit der Geschwindigkeit der Nachricht Schritt halten kann.  Mit RabbitMQ stellen wir einfach zwei weitere Abrechnungsdienstanwendungen bereit, die aus der Abrechnungswarteschlange stammen.  Kafka unterstützt jedoch keine konkurrierenden Empfänger in derselben Partition, da der Kafka-Parallelitätsblock die Partition selbst ist.  Wenn wir also drei Empfänger von Rechnungen benötigen, benötigen wir mindestens drei Partitionen.  Jetzt haben wir also: </p><br><p><img src="https://habrastorage.org/webt/3k/fn/rd/3kfnrdjpllbt0nqidfaxrveqvfc.png"><br>  <em>Abb.</em>  <em>8. Drei Partitionen und zwei Gruppen von drei Empfängern</em> </p><br><p>  Es versteht sich daher, dass Sie mindestens so viele Partitionen benötigen wie der am meisten skalierte horizontale Empfänger.  Lassen Sie uns ein wenig über Partitionen sprechen. </p><br><h3 id="particii-i-gruppy-poluchateley">  Partitionen und Empfängergruppen </h3><br><p>  Jede Partition ist eine separate Datei, in der die Reihenfolge der Nachrichten garantiert ist.  Dies ist wichtig zu beachten: Die Nachrichtenreihenfolge ist nur in einer Partition garantiert.  In Zukunft kann dies zu einem gewissen Widerspruch zwischen den Anforderungen für die Nachrichtenwarteschlange und den Anforderungen für die Leistung führen, da die Leistung in Kafka auch durch Partitionen skaliert wird.  Die Partition kann keine konkurrierenden Empfänger unterstützen, daher kann unsere Abrechnungsanwendung nur einen Teil für jeden Abschnitt verwenden. </p><br><p>  Nachrichten können durch einen zyklischen Algorithmus oder über eine Hash-Funktion in Segmente umgeleitet werden: Hash (Nachrichtenschlüssel)% Anzahl der Partitionen.      ,      ,     , ,   ,     ,     .            . </p><br><p>       RabbitMQ.                .   ,     RabbitMQ    ,              .  ,                . </p><br><p>   RabbitMQ                    .  Kafka ,      . </p><br><p>  ,   ,    Kafka   ,   RabbitMQ   —    . RabbitMQ     ,            . Kafka      ,      . ,        ,  Kafka     ,     . </p><br><p> ,     ,      ,           (  ).       ,          ,     .  ,      ,      ,        . </p><br><p>      RabbitMQ —   Consistent Hashing exchange,      .   Kafka'   ,  Kafka      ,             ,   , ,     ,      -.  RabbitMQ      ,     ,    ,    . </p><br><p>     :   ,     ,    Id 1000     ,     Id 1000    .    ,    ,    .   ,      . </p><br><h3 id="protalkivanie-push-protiv-vygruzki-pull">  (push)   (pull) </h3><br><p> RabbitMQ    (push) ,  ,          .                RabbitMQ   .   , Kafka    (pull),         .     ,          , Kafka  long-polling. </p><br><p>   (pull)    Kafka -  .  Kafka        ,           ,       . </p><br><p>       RabbitMQ,             ,     ,       ,      .   Kafka       ,            . </p><br><h3 id="publikaciya-i-podpiska">    </h3><br><p> Kafka    /»    ,   ,       .       ,            . </p><br><p><img src="https://habrastorage.org/webt/w1/ii/zh/w1iizhiisxgsumup_ufs8rm_dvk.png"><br>  <em>Abb.</em> <em>9.     </em> </p><br><p>       ,       ,       Kafka     : </p><br><p>  Abb. 10.  ,         <br> <em><img src="https://habrastorage.org/webt/zl/uu/eu/zluueuxxppnji50tgqnar-pnmfk.png"></em> </p><br><p>           ,   : </p><br><p><img src="https://habrastorage.org/webt/xo/bw/op/xobwopr8b9fey8huqbclx85mh4y.png"><br>  <em>Abb.</em> <em>11.      </em> </p><br><p>         , ,               . </p><br><p> ,     ,  ,     ,  . </p><br><p><img src="https://habrastorage.org/webt/uf/wn/a4/ufwna4h-bmmmr48gp0yo8akk4je.png"><br>  <em>Abb.</em> <em>12.   </em> </p><br><p>          .         . </p><br><p><img src="https://habrastorage.org/webt/ok/vs/ce/okvsce2-xvrnztcupmx-fkbyg5w.png"></p><br><p>      : </p><br><ul><li>      </li><li>      ( ,       ) </li><li>    </li></ul><br><p>           ,               .     ,   ,    . </p><br><p>     Kafka –       , , ,     , ,     .    .            ,         .  ,   ,     . </p><br><h3 id="szhatie-zhurnala">   </h3><br><p>     —       . ,        50 .        –  .   ,   ,         ,  . </p><br><p>  ,    ,     .  ,    ,       .           ,         .  ,    ,      ,    . </p><br><p>                    .   ,  ,        . </p><br><h3 id="podrobnee-ob-uporyadochenii-soobscheniy">     </h3><br><p>  ,           RabbitMQ,    Kafka,   Kafka   .  RabbitMQ           ,    ,   ZooKeeper  Consul. </p><br><p>   RabbitMQ    ,    Kafka.      RabbitMQ,     ,      .  :            . </p><br><p>    .        ,         .     .         ,    .            .       .  ,   ,    -   . </p><br><p>           ,   Kafka,     .     .  ,         ,       . </p><br><p>  ,    . RabbitMQ        ,  Kafka        . </p><br><h3 id="vyvody">  Schlussfolgerungen </h3><br><p> RabbitMQ          ,    .           ,     ,     .    ,           .             ,     ,    . </p><br><p>   Kafka         .               ,         .   Kafka       ,  RabbitMQ    . ,  Kafka    ,  RabbitMQ,         ,       . </p><br><p>              RabbitMQ. </p><br><blockquote> , ,      IoT  ,    . : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">t.me/justiothings</a> </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de416629/">https://habr.com/ru/post/de416629/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de416619/index.html">Offenes Webinar „Erstellen einer Website im Yii2-Framework“</a></li>
<li><a href="../de416621/index.html">Homo Extensis. Erweiterung der menschlichen Fähigkeiten oder Kombination von Mensch und Roboter</a></li>
<li><a href="../de416623/index.html">Die Objektivität der Psychotherapie</a></li>
<li><a href="../de416625/index.html">Das von der Londoner Polizei installierte neue Gesichtserkennungssystem kann niemanden erkennen</a></li>
<li><a href="../de416627/index.html">Management des IT-Förderers oder Hin und zurück</a></li>
<li><a href="../de416633/index.html">QUIC, TLS 1.3, DNS-over-HTTPS, dann überall</a></li>
<li><a href="../de416635/index.html">Von rechts nach links. So drehen Sie die Site-Schnittstelle unter RTL</a></li>
<li><a href="../de416637/index.html">Musik aus Papier und Pappe: eine kurze Geschichte des Variophons und des „gezeichneten Klangs“</a></li>
<li><a href="../de416639/index.html">Interview mit einem Pionier der Verjüngung</a></li>
<li><a href="../de416641/index.html">8 Phasen des Prozesses zur Entwicklung einer mobilen Anwendungsschnittstelle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>