<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😔 💽 👨🏾‍🎓 Quintett statt Byte - Ansatz zum Speichern und Abrufen von Daten 💪🏻 🙏🏼 🙆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quintett ist eine Möglichkeit, atomare Daten zu präsentieren, die ihre Rolle im Geschäftsbereich angeben. Quintette können jedes Element beschreiben, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quintett statt Byte - Ansatz zum Speichern und Abrufen von Daten</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468927/">  Quintett ist eine Möglichkeit, atomare Daten zu präsentieren, die ihre Rolle im Geschäftsbereich angeben.  Quintette können jedes Element beschreiben, während jedes vollständige Informationen über sich selbst und seine Beziehungen zu anderen Quintetten enthält.  Diese Beschreibung hängt nicht von der verwendeten Plattform ab.  Ziel ist es, die Speicherung von Daten zu vereinfachen und die Sichtbarkeit ihrer Präsentation zu verbessern. <br><br><img src="https://habrastorage.org/webt/em/rc/sj/emrcsj86rsey9wacgmk-uj4i9og.gif"><br><br>  <b>Wir werden einen Ansatz zum Speichern und Verarbeiten von Informationen diskutieren und einige Gedanken zur Schaffung einer Entwicklungsplattform in diesem neuen Paradigma austauschen.</b>  <b>Wofür?</b>  <b>So entwickeln Sie schneller und in kürzeren Iterationen: Skizzieren Sie Ihr Projekt, stellen Sie sicher, dass es Ihren Vorstellungen entspricht, verfeinern Sie es und verfeinern Sie das Ergebnis weiter.</b> <br><br>  Das Quintett hat Eigenschaften: Typ, Wert, Eltern und Reihenfolge unter den Peers.  Somit gibt es 5 Komponenten einschließlich der Kennung.  Dies ist die einfachste universelle Form zum Aufzeichnen von Informationen, ein neuer Standard, der möglicherweise allen Programmieranforderungen gerecht wird.  Quintette werden im Dateisystem der einheitlichen Struktur in einer kontinuierlichen homogenen indizierten Datenmenge gespeichert.  Das Quintett-Datenmodell - ein Datenmodell, das jede Datenstruktur als eine einzige miteinander verbundene Liste von Basistypen und darauf basierenden Begriffen (Metadaten) sowie Instanzen von Objekten beschreibt, die gemäß diesen Metadaten (Daten) gespeichert wurden. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Eine halbe Minute Text</b> <div class="spoiler_text">  Heutzutage gibt es unendlich viele Standards zum Aufzeichnen von Daten, zahlreiche Ansätze und Regeln, deren Kenntnis für die Arbeit mit diesen Aufzeichnungen erforderlich ist.  Standards werden separat beschrieben und beziehen sich nicht direkt auf die entsprechenden Daten.  Bei Quintetten können Sie im Geschäftsbereich des Benutzers relevante Informationen über Art, Eigenschaften und Verarbeitungsregeln abrufen.  Sein Standard ist einheitlich und für alle Bereiche festgelegt.  Das Quintett ist dem Benutzer verborgen - Metadaten und Daten stehen diesem auf allgemein verständliche Weise zur Verfügung. <br><br>  Quintett ist nicht nur Information, es könnte auch ausführbaren Code darstellen.  Vor allem aber möchten Sie die Daten aufzeichnen, speichern und abrufen.  Da Quintette in unserem Fall direkt adressierbar, miteinander verbunden und indiziert sind, speichern wir sie in einer Art Datenbank. </div></div><br><a name="why"></a><br><h3>  Warum Quintett statt Byte? </h3><br>  <b>Kein Bit oder elektronischer Impuls, der den magnetischen Spin ausrichtet.</b> <br><br>  Wir sind es gewohnt, die Daten in Bytes zu messen, unabhängig davon, ob es sich um eine Dokument- oder Fotogröße, eine Internet-Verkehrsbeschränkung oder verfügbaren Speicherplatz auf Ihrem Mobilgerät handelt.  Wir schlagen eine andere Maßnahme vor - Quintett - die keine feste Größe wie Byte hat, sondern eine atomare Datenmenge darstellt, die für den Benutzer von Wert ist. <br><br>  Sie können beispielsweise sagen, dass Ihre Datenbank 119 Megabyte des Speichers belegt, oder Sie können angeben, dass in dieser Datenbank 1,37 Megaquintette gespeichert sind.  Es ist Ihnen egal, was ein Byte in diesem Zusammenhang ist, aber Sie verstehen, dass diese Datenbank 1,37 Millionen Ihrer Begriffsbeschreibungen, Objekte, deren Attribute, Links, Ereignisse, Abfragen mit ihren Details usw. enthält.  1,37 Millionen wertvolle Daten zu besitzen, klingt sexier als 119 Megabyte an Daten. <br><br>  Dies soll also nicht die Art und Weise ersetzen, wie die Informationen auf dem Datenträger gespeichert sind, sondern auf eine andere Abstraktionsebene wechseln. <br><a name="structure"></a><br><h3>  Quintettstruktur </h3><br>  Die Hauptidee dieses Artikels besteht darin, Maschinentypen durch menschliche Begriffe zu ersetzen und Variablen durch Objekte zu ersetzen.  Nicht von Objekten, die einen Konstruktor, Destruktor, Schnittstellen und einen Garbage Collector benötigen, sondern von kristallklaren Informationseinheiten, die ein Kunde verarbeitet.  Das heißt, wenn der Kunde "Kunde" sagt, würde das Speichern des Wesens dieser Aussage auf dem Medium kein Fachwissen eines Programmierers erfordern. <br><br><img src="https://habrastorage.org/webt/e-/ox/u9/e-oxu90oaiouj4zals6mgtnj7zy.png"><br><br>  Es ist sinnvoll, die Aufmerksamkeit des Benutzers nur auf den Wert des Objekts zu richten, während Typ, Eltern, Reihenfolge (unter Gleichen in der Unterordnung) und Kennung aus dem Kontext ersichtlich oder einfach verborgen sein sollten.  Dies bedeutet, dass der Benutzer überhaupt nichts über Quintette weiß, einfach eine Aufgabe ausgibt, sicherstellt, dass sie korrekt akzeptiert wird, und dann mit der Ausführung beginnt. <br><a name="concept"></a><br><h3>  Grundbegriffe </h3><br>  Es gibt eine Reihe von Datentypen, die jeder versteht: Zeichenfolge, Nummer, Datei, Text, Datum usw.  Solch ein einfacher Satz reicht völlig aus, um die Lösung zu skizzieren und zusammen mit den für ihre Implementierung erforderlichen Bedingungen zu "programmieren".  Die durch Quintette dargestellten Grundtypen können folgendermaßen aussehen: <br><br><img src="https://habrastorage.org/webt/ca/zb/7l/cazb7lfkvuldo5anzgnzibqu3oc.png"><br><br>  In diesem Fall werden einige Komponenten des Quintetts nicht verwendet, während das Quintett selbst als Basistyp verwendet wird.  Dies erleichtert die Navigation des Systemkerns beim Sammeln von Metadaten. <br><a name="background"></a><br><h3>  Der Hintergrund </h3><br>  Aufgrund der analytischen Lücke zwischen Benutzer und Programmierer kommt es in der Phase der Projektbeschreibung zu einer erheblichen Verformung der Konzepte.  Das Understatement, die Unverständlichkeit und die unaufgeforderte Initiative machen eine einfache und vernünftige Vorstellung des Kunden oft zu einem logisch unmöglichen Durcheinander, wenn sie aus Sicht des Benutzers bewertet werden. <br><br><img src="https://habrastorage.org/webt/7p/jb/uz/7pjbuzxfddlosktjv3bs-om0v-8.png"><br><br>  Der Wissenstransfer sollte ohne Verlust und Verzerrung erfolgen.  Wenn Sie die Speicherung dieses Wissens organisieren, sollten Sie außerdem die Einschränkungen, die durch das ausgewählte Datenverwaltungssystem auferlegt werden, besser beseitigen. <br><a name="how"></a><br><h3>  Wie wir die Daten jetzt speichern </h3><br>  In der Regel befinden sich viele Datenbanken auf dem Server.  Jedes von ihnen enthält eine Beschreibung des Datenschemas mit einem bestimmten Satz von Details - logisch miteinander verbundene Daten.  Sie werden in einer bestimmten Reihenfolge auf dem Datenträger gespeichert, idealerweise - optimal, um den Abrufaufwand zu verringern. <br>  Das vorgeschlagene Informationsspeichersystem ist ein Kompromiss zwischen verschiedenen bekannten Methoden: spaltenorientiert, relational und NoSQL.  Es wurde entwickelt, um die Aufgaben zu lösen, die normalerweise von einem dieser Ansätze ausgeführt werden. <br><br>  Zum Beispiel sieht die Theorie des spaltenorientierten DBMS gut aus: Wir lesen nur die gewünschte Spalte, aber nicht alle Datensatzzeilen als Ganzes.  In der Praxis ist es jedoch unwahrscheinlich, dass Daten auf dem Medium abgelegt werden, sodass es bequem ist, Dutzende verschiedener Analysedimensionen abzurufen.  Beachten Sie, dass Attribute und analytische Metriken hinzugefügt und entfernt werden können, manchmal schneller als wir unseren Spaltenspeicher neu erstellen können.  Ganz zu schweigen davon, dass die Daten in der Datenbank geändert werden können, was aufgrund der unvermeidlichen Fragmentierung auch die Schönheit des Speicherschemas verletzt. <br><a name="metadata"></a><br><h3>  Metadaten </h3><br>  Wir haben ein Konzept eingeführt - einen Begriff -, um alle Objekte zu beschreiben, mit denen wir arbeiten: Entität, Eigenschaft, Anforderung, Datei usw.  Wir definieren alle Begriffe, die wir in unserem Geschäftsbereich verwenden.  Und mit ihrer Hilfe werden wir alle Entitäten beschreiben, die Details haben, einschließlich der Form der Beziehungen zwischen Entitäten.  Zum Beispiel ein Attribut - ein Link zu einem Statuswörterbucheintrag.  Der Begriff wird als Quintett von Daten geschrieben. <br><br>  Eine Reihe von Begriffsbeschreibungen besteht aus Metadaten, die durch die Struktur von Tabellen und Feldern in einer regulären Datenbank dargestellt werden.  Beispielsweise gibt es die folgende Datenstruktur: eine Serviceanforderung an einem bestimmten Datum mit Inhalt (Anforderungsbeschreibung) und einem Status, zu dem die Teilnehmer eines Produktionsprozesses Kommentare hinzufügen, die das Datum angeben.  In einem herkömmlichen Datenbankkonstruktor sieht es ungefähr so ​​aus: <br><br><img src="https://habrastorage.org/webt/wj/ux/e5/wjuxe5yakm3i0e8-b8qatbsuvv0.png"><br><br>  Da wir beschlossen haben, alle nicht wesentlichen Details, wie z. B. verbindliche IDs, vor dem Benutzer zu verbergen, wird das Schema etwas vereinfacht: Die Erwähnungen von IDs werden entfernt und die Namen von Entitäten und ihre Schlüsselwerte werden kombiniert. <br><br>  Der Benutzer "zeichnet" die Aufgabe: eine Anfrage vom heutigen Datum, die einen Status (Referenzwert) hat und zu der Sie Kommentare hinzufügen können, die das Datum angeben: <br><br><img src="https://habrastorage.org/webt/i7/-e/s0/i7-es0bgiqlj2mjrgaijlsj_nrg.png"><br><br>  Jetzt sehen wir 6 verschiedene Datenfelder anstelle von 9, und das gesamte Schema bietet uns die Möglichkeit, 7 statt 13 Wörter zu lesen und zu verstehen. Obwohl dies natürlich nicht die Hauptsache ist. <br><br>  Die folgenden Quintette werden vom Quintettverarbeitungskern generiert, um diese Struktur zu beschreiben: <br><br><img src="https://habrastorage.org/webt/os/55/ms/os55msg7_8xpt2jkcqpnc1xhnls.png"><br><br>  Zur Verdeutlichung werden Erklärungen anstelle von grau hervorgehobenen Quintettwerten bereitgestellt.  Diese Felder werden nicht ausgefüllt, da alle notwendigen Informationen von den übrigen Komponenten eindeutig bestimmt werden. <br><br><div class="spoiler">  <b class="spoiler_title">Sehen Sie, wie Quintette zusammenhängen</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/he/sh/xu/heshxuxlzau8yljqiznxu2ckd-8.png"><br><br>  Was wir hier haben: <br><br><ul><li>  Die Attribute mit den IDs 80, 81, 83 haben dieselbe übergeordnete Anforderung </li><li>  Quintett # 82 ist das Attribut von Comment, das wiederum ein Attribut von Request ist </li><li>  Attribut Nr. 74 ist eine Referenz auf den vom Quintett Nr. 73 beschriebenen Typ und wird als Attribut Nr. 81 von Request verwendet </li></ul></div></div><br>  Dies mag für Menschen etwas kompliziert aussehen, aber die gute Nachricht ist - ein Mensch wird dies niemals sehen.  Der Kernel repräsentiert die Metadaten als verständliche Diagramme und die Daten als einfache flache Tabellen. <br><a name="userdata"></a><br><h3>  Benutzerdaten </h3><br>  Lassen Sie mich zeigen, wie wir einen solchen Datensatz für die obige Aufgabe speichern: <br><br><img src="https://habrastorage.org/webt/7r/fo/6g/7rfo6gvbnxz2wahg9vq-8x8wdty.png"><br><br>  Die Daten selbst werden gemäß den Metadaten in Quintetten gespeichert.  Wir können sie genauso visualisieren wie oben: <br><br><img src="https://habrastorage.org/webt/lc/p4/15/lcp415pjpig8etl3lykjfi2lqca.png"><br><br>  Wir sehen eine vertraute hierarchische Struktur, die mit der Adjacency List-Methode niedergeschrieben wurde. <br><a name="storage"></a><br><h3>  Physische Speicherung </h3><br>  Die Daten werden als Folge von Quintettelementen in Datenbytes in den Speicher geschrieben.  Um nach Index zu suchen, behandelt der Kernel diese Datenbytes gemäß dem Datentyp, der für sie durch Basistypen definiert ist. <br>  Das war's: eine riesige Liste von fünf Datenelementen. <br><br>  Die Speicherprinzipien unterscheiden sich nicht wesentlich von denen in RDBMS. Dadurch können wir SQL-Abfragen für die Daten erstellen, um Datenabrufe, JOINs, Aggregatfunktionen und andere Dinge, die wir in relationalen Datenbanken mögen, durchzuführen. <br><blockquote>  <b>Um den Prototyp einer Entwicklungsplattform zu testen, die auf dem Quintett-Speichersystem basiert, verwenden wir eine relationale Datenbank.</b> </blockquote><br><a name="performance"></a><h3>  Leistung </h3><br>  Das obige Beispiel ist sehr einfach, aber was wird sein, wenn die Struktur tausendmal komplexer ist und Gigabyte an Daten vorhanden sind? <br><br>  Was wir brauchen: <br><br><ol><li>  Die diskutierte hierarchische Struktur - 1 Stck. </li><li>  B-Baum für die Suche nach ID, Eltern und Typ - 3 Stk. </li></ol><br>  Somit werden alle Datensätze in unserer Datenbank indiziert, einschließlich Daten und Metadaten.  Eine solche Indizierung ist erforderlich, um die Vorteile einer relationalen Datenbank zu nutzen - dem einfachsten und beliebtesten Tool.  Der übergeordnete Index ist tatsächlich zusammengesetzt (übergeordnete ID + Typ).  Der Index nach Typ ist auch zusammengesetzt (Typ + Wert) für die schnelle Suche nach Objekten eines bestimmten Typs. <br><br>  Mit Metadaten können wir die Rekursion beseitigen: Um beispielsweise alle Details eines bestimmten Objekts zu finden, verwenden wir den Index nach übergeordneter ID.  Wenn Sie nach Objekten eines bestimmten Typs suchen müssen, verwenden wir den Index nach Typ-ID.  Typ ist ein Analogon eines Tabellennamens und eines Feldes in einem relationalen DBMS. <br><br><img src="https://habrastorage.org/webt/w0/3y/6_/w03y6_fst_enfkaxmihelbnxjcc.png"><br><br>  In jedem Fall scannen wir nicht den gesamten Datensatz, und selbst bei einer großen Anzahl von Werten eines beliebigen Typs kann der gewünschte Wert in wenigen Schritten gefunden werden. <br><a name="basis"></a><br><h3>  Die Basis für die Entwicklungsplattform </h3><br>  An sich ist eine solche Datenbank für die Anwendungsprogrammierung nicht autark und laut Turing nicht vollständig, wie sie sagen.  Wir sprechen hier jedoch nicht nur über die Datenbank, sondern versuchen, alle Aspekte abzudecken: Objekte sind unter anderem beliebige Steuerungsalgorithmen, die gestartet werden können und funktionieren. <br><br>  Als Ergebnis erhalten wir anstelle komplexer Datenbankstrukturen und separat gespeicherter Quellcode von Steueralgorithmen ein einheitliches Informationsfeld, das durch das Volumen des Speicherplatzes begrenzt und mit Metadaten gesteuert wird.  Die Daten selbst werden dem Benutzer in verständlicher Form präsentiert - die Struktur des Themenbereichs und die entsprechenden Einträge darin.  Der Benutzer ändert die Struktur und die Daten willkürlich, einschließlich Massenoperationen mit ihnen. <br><br><h4>  Wir haben nichts Neues erfunden: Alle Daten sind bereits im Dateisystem gespeichert und die Suche in ihnen erfolgt über B-Bäume, entweder im Dateisystem oder in der Datenbank.  Wir haben gerade die Darstellung der Daten neu organisiert, damit die Arbeit einfacher und klarer wird. </h4><br><br>  Um mit dieser Datendarstellung arbeiten zu können, benötigen Sie eine sehr kompakte Kernel-Software. Unsere Datenbank-Engine ist kleiner als ein Computer-BIOS und kann daher, wenn nicht in Hardware, mindestens genauso schnell und fehlerhaft erstellt werden. kostenlos wie möglich.  Aus Sicherheitsgründen kann es auch schreibgeschützt sein. <br><br>  Wenn Sie einer Assembly in meinem bevorzugten .Net eine neue Klasse hinzufügen, können wir den Verlust von 200-300 MB RAM nur bei der Definition dieser Klasse beobachten.  Diese Megabyte passen nicht in den Cache der richtigen Ebene, was dazu führt, dass das System mit dem gesamten daraus resultierenden Overhead auf der Festplatte ausgetauscht wird.  Eine ähnliche Situation ist bei Java.  Die Beschreibung derselben Klasse mit Quintetten dauert zehn oder Hunderte von Bytes, da die Klasse nur primitive Operationen zum Arbeiten mit Daten verwendet, die der Kernel bereits kennt. <br><br><blockquote><h4>  Sie könnten denken, dass dieser Ansatz bereits viele Male in verschiedenen Anwendungen implementiert ist, aber das ist nicht wahr. </h4><br>  Wir haben sowohl im Internet als auch in den Grundlagen des geistigen Eigentums (Patente) gründlich gesucht, und niemand behauptet, genau dieselbe Lösung zu verwenden, um die Leistungsgrenze von Konstruktoren, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einzeltabellenlösungen</a> und anderen EAV-basierten Systemen zu überschreiten.  Trotzdem haben wir Hunderte von Gigabyte in eine solche Quintettanwendung gesteckt und festgestellt, dass sie recht gut funktioniert.  Wenn Sie Beweise sehen, Ihre eigene Instanz erstellen und testen möchten, können Sie unseren Github-Account besuchen. </blockquote><br>  Der Prototyp der von uns gebauten Plattform besteht aus vier Komponenten: <br><br><ol><li>  Visual <b>Type Editor</b> zum Definieren der Metadaten </li><li>  <b>Datennavigationswerkzeug</b> wie ein einfacher SQL-Navigator </li><li>  Visual <b>Report Designer</b> zum Erstellen von SQL-Abfragen für die Daten </li><li>  Ein <b>Vorlagenprozessor</b> zum Kombinieren von Vorlagen mit Daten, die durch Abfragen abgerufen wurden </li></ol><br><img src="https://habrastorage.org/webt/bc/lu/rq/bclurqpevkemespz7aofusqipps.png"><br><br>  Wie beabsichtigt, würde kein Benutzer bei der Arbeit mit dem Prototyp glauben, dass sich Quintette im Inneren befinden - dies sieht aus wie ein gewöhnlicher Konstruktor. <br><br><div class="spoiler">  <b class="spoiler_title">Umgang mit verschiedenen Formaten: RDBMS, NoSQL, Spaltenbasen</b> <div class="spoiler_text">  Der diskutierte Ansatz deckt zwei Hauptbereiche ab: RDBMS und NoSQL.  Bei der Lösung von Problemen, bei denen Säulendatenbanken zum Einsatz kommen, müssen wir dem Kernel mitteilen, dass bestimmte Objekte gespeichert werden sollen, wobei die Optimierung der Massenabtastung der Werte eines bestimmten Datentyps (unser Begriff) zu berücksichtigen ist.  Daher kann der Kernel Daten auf die rentabelste Weise auf der Festplatte ablegen. <br><br>  Somit können wir für eine Spalten-DB den von Quintetten belegten Platz erheblich einsparen: Verwenden Sie nur eine oder zwei ihrer Komponenten, um nützliche Daten anstelle von fünf zu speichern, und verwenden Sie den Index nur, um den Beginn von Datenketten anzuzeigen.  In vielen Fällen wird nur der Index für die Stichprobe aus unserem Analogon einer Spaltenbasis verwendet, ohne dass auf die Daten der Quintettliste selbst zugegriffen werden muss. <br><br>  Es sollte beachtet werden, dass die Idee nicht alle fortgeschrittenen Entwicklungen aus diesen drei Arten von Datenbanken sammeln soll.  Im Gegenteil, die Engine des neuen Systems wird so weit wie möglich reduziert und enthält nur das erforderliche Minimum an Funktionen - alles, was DDL- und DML-Anforderungen in dem hier beschriebenen Konzept abdeckt. <br></div></div><br><a name="paradigm"></a><br><h3>  Programmierparadigma </h3><br>  Der beschriebene Ansatz beschränkt sich nicht nur auf die Verwendung von Quintetten, sondern fördert ein anderes Paradigma als das, an das Programmierer gewöhnt sind.  Anstelle einer imperativen, deklarativen oder Objektsprache schlagen wir die Abfragesprache als dem Menschen vertrauter vor und ermöglichen es uns, die Aufgabe direkt auf den Computer zu übertragen, wobei Programmierer und die undurchdringliche Schicht bestehender Entwicklungsumgebungen umgangen werden. <br><br>  <b>Natürlich ist in den meisten Fällen immer noch ein Übersetzer von einer Laienbenutzersprache in eine Sprache mit klaren Anforderungen erforderlich.</b> <br><br>  Dieses Thema wird in separaten Artikeln mit Beispielen und bestehenden Entwicklungen ausführlicher beschrieben. <br><br>  In Kürze funktioniert es also wie folgt: <br><br><ol><li>  Wir haben einmal primitive Datentypen mithilfe von Quintetten beschrieben: Zeichenfolge, Nummer, Datei, Text und andere, und den Kernel für die Arbeit mit ihnen geschult.  Training bedeutet die korrekte Darstellung von Daten und die Implementierung einfacher Operationen mit ihnen. </li><li>  Nun beschreiben wir Benutzerbegriffe (Datentypen) - in Form von Metadaten.  In der Beschreibung wird lediglich ein primitiver Datentyp für jeden Benutzertyp angegeben und die Beziehungen bestimmt. </li><li>  Wir geben Datenquintette gemäß der durch Metadaten angegebenen Struktur ein.  Jedes Quintett von Daten enthält einen Link zu seinem Typ und übergeordneten Element, sodass Sie ihn schnell im Datenspeicher finden können. </li><li>  Die Kernel-Aufgaben bestehen darin, Daten abzurufen und einfache Operationen mit ihnen auszuführen, um beliebig komplexe Algorithmen zu implementieren, die vom Benutzer definiert werden. </li><li>  Der Benutzer verwaltet <i>Daten</i> und <i>Algorithmen</i> über eine visuelle Oberfläche, die beide darstellt. </li></ol><br><br>  Die Vollständigkeit des gesamten Systems wird durch die Verkörperung der Grundanforderungen sichergestellt: Der Kernel kann sequentielle Operationen ausführen, bedingt verzweigen, die Daten verarbeiten und die Arbeit einstellen, wenn ein bestimmtes Ergebnis erreicht wird. <br><br>  Für eine Person ist der Vorteil beispielsweise die Einfachheit der Wahrnehmung, anstatt einen Zyklus mit Variablen zu deklarieren <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;length (A); i ++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [i] meets a condition <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something with A [i]</code> </pre> <br><br>  eine verständlichere Form wird verwendet, wie <br><br><pre> <code class="1c hljs">with every A, that match a condition, do something</code> </pre> <br><br>  Wir träumen davon, von den Feinheiten der Informationssysteme auf niedriger Ebene zu abstrahieren: Schleifen, Konstruktoren, Funktionen, Manifeste, Bibliotheken - all dies nimmt im Gehirn eines Programmierers zu viel Platz ein und lässt wenig Raum für kreative Arbeit und Entwicklung. <br><a name="scalability"></a><br><h3>  Skalierbarkeit </h3><br>  Eine Anwendung ist ohne Skalierungsmittel oft unbrauchbar: Eine unbegrenzte Möglichkeit zur Erweiterung der Ladekapazität eines Informationssystems ist erforderlich.  Unter Berücksichtigung der extrem einfachen Datenorganisation stellt sich bei dem beschriebenen Ansatz heraus, dass die Skalierung nicht komplizierter organisiert ist als in vorhandenen Architekturen. <br><br>  Im obigen Beispiel mit den Dienstanforderungen können Sie sie beispielsweise durch ihre ID trennen, wodurch die ID mit festen HIGH-Bytes für verschiedene Server generiert wird.  Das heißt, wenn 32 Bit zum Speichern der ID verwendet werden, geben die linken zwei, drei, vier oder mehr Bits nach Bedarf den Server an, auf dem diese Anwendungen gespeichert sind.  Somit verfügt jeder Server über einen eigenen ID-Pool. <br><br>  Der Kernel eines einzelnen Servers kann unabhängig von anderen Servern funktionieren, ohne etwas darüber zu wissen.  Beim Erstellen eines Objekts erhält der Server mit der Mindestanzahl der verwendeten IDs eine hohe Priorität, um eine gleichmäßige Lastverteilung sicherzustellen. <br><br>  Angesichts einer begrenzten Anzahl möglicher Variationen von Anforderungen und Antworten in einer solchen Datenorganisation benötigen Sie einen relativ kompakten Dispatcher, der Anforderungen auf Server verteilt und deren Ergebnisse aggregiert. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de468927/">https://habr.com/ru/post/de468927/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de468909/index.html">Dank der Zwei-Faktor-Authentifizierung habe ich mein ganzes Geld und drei Jahre Arbeit verloren</a></li>
<li><a href="../de468911/index.html">Hervorragende Fragen und Antworten zu Quantum Excellence</a></li>
<li><a href="../de468913/index.html">Amazon Dash Button: Rückblick</a></li>
<li><a href="../de468915/index.html">Wie überwacht Cisco die Informationssicherheit absorbierter Unternehmen und bietet ihnen Zugriff auf ihre Ressourcen?</a></li>
<li><a href="../de468923/index.html">Ich rufe dich zurück</a></li>
<li><a href="../de468929/index.html">Das Mini-Handbuch zum Einrichten eines Hackintosh ist so einfach und schmerzlos wie möglich</a></li>
<li><a href="../de468931/index.html">Führen Sie systemd im Container aus</a></li>
<li><a href="../de468933/index.html">Stachelig und scharf, wohin Sie auch schauen: der Mechanismus des Selbstschärfens der Zähne von Seeigeln</a></li>
<li><a href="../de468935/index.html">Die Zusammenfassung der Ereignisse für HR-Experten im Bereich IT im Oktober 2019</a></li>
<li><a href="../de468937/index.html">Kontaktlose Bankkartenangriffe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>