<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé≥ üö£üèª üîõ Steal: qui vole le temps processeur des machines virtuelles üë®‚ÄçüöÄ üêÆ üçÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salut Je veux parler en langage simple de la m√©canique de l'√©mergence du vol √† l'int√©rieur des machines virtuelles et de certains artefacts non √©viden...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Steal: qui vole le temps processeur des machines virtuelles</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/449316/"><img src="https://habrastorage.org/getpro/habr/post_images/af7/c70/8aa/af7c708aa619490409ed5cf46d9c96fa.jpg"><br><br>  Salut  Je veux parler en langage simple de la m√©canique de l'√©mergence du vol √† l'int√©rieur des machines virtuelles et de certains artefacts non √©vidents que nous avons pu d√©couvrir lors de ses recherches, dans lesquels j'ai d√ª plonger en tant que conseiller technique de la plateforme cloud <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mail.ru Cloud Solutions</a> .  La plateforme fonctionne sur KVM. <br><br>  Le temps de vol du processeur est le temps pendant lequel la machine virtuelle ne re√ßoit pas les ressources du processeur pour son ex√©cution.  Cette heure n'est prise en compte que dans les syst√®mes d'exploitation invit√©s des environnements de virtualisation.  Les raisons pour lesquelles ces ressources tr√®s allou√©es vont, comme dans la vie, sont tr√®s vagues.  Mais nous avons d√©cid√© de le comprendre, m√™me mis en place toute une s√©rie d'exp√©riences.  Non pas que nous sachions maintenant tout sur le vol, mais nous vous dirons quelque chose d'int√©ressant d√®s maintenant. <br><a name="habracut"></a><br><h2>  1. Qu'est-ce que voler </h2><br>  Ainsi, le vol est une m√©trique qui indique un manque de temps processeur pour les processus √† l'int√©rieur d'une machine virtuelle.  Comme d√©crit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans le correctif du noyau KVM</a> , le vol est le temps pendant lequel l'hyperviseur ex√©cute d'autres processus sur le syst√®me d'exploitation h√¥te, bien qu'il ait mis en file d'attente le processus de la machine virtuelle pour ex√©cution.  C'est-√†-dire que le vol est consid√©r√© comme la diff√©rence entre le moment o√π le processus est pr√™t √† s'ex√©cuter et le moment o√π le processeur se voit allouer le temps. <br><br>  Le noyau du noyau re√ßoit le vol m√©trique de l'hyperviseur.  Dans le m√™me temps, l'hyperviseur ne sp√©cifie pas exactement quels autres processus il ex√©cute, simplement "pendant que je suis occup√©, je ne peux pas vous donner de temps."  Sur KVM, la prise en charge du comptage des vols a √©t√© ajout√©e dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctifs</a> .  Il y a deux points cl√©s ici: <br><br><ul><li>  La machine virtuelle apprend √† voler de l'hyperviseur.  Autrement dit, du point de vue des pertes, pour les processus sur la machine virtuelle elle-m√™me, il s'agit d'une mesure indirecte qui peut √™tre soumise √† diverses distorsions. <br></li><li> L'hyperviseur ne partage pas d'informations avec la machine virtuelle sur ce qu'il fait avec les autres - l'essentiel est qu'il n'y consacre pas de temps.  Pour cette raison, la machine virtuelle elle-m√™me ne peut pas d√©tecter les distorsions dans l'indice de vol, qui pourraient √™tre estim√©es par la nature des processus concurrents. <br></li></ul><br><h2>  2. Ce qui affecte le vol </h2><br><h3>  2.1.  Vol de calcul </h3><br>  En fait, le vol est consid√©r√© √† peu pr√®s comme le temps d'utilisation normal du processeur.  Il n'y a pas beaucoup d'informations sur la fa√ßon dont l'√©limination est envisag√©e.  Probablement parce que la majorit√© consid√®re cette question comme √©vidente.  Mais il y a aussi des √©cueils ici.  Pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vous</a> familiariser avec ce processus, vous pouvez lire l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article de Brendann Gregg</a> : vous en apprendrez sur un tas de nuances dans le calcul de l'utilisation et sur les situations o√π ce calcul sera erron√© pour les raisons suivantes: <br><br><ul><li>  Surchauffe du processeur, pendant laquelle les cycles d'horloge sont saut√©s. <br></li><li>  Activez / d√©sactivez le turbo boost, √† la suite de quoi la fr√©quence d'horloge du processeur change. <br></li><li>  Un changement dans la dur√©e d'un quantum de temps qui se produit lors de l'utilisation de technologies d'√©conomie d'√©nergie de processeur, telles que SpeedStep. <br></li><li>  Le probl√®me du calcul de la moyenne: une estimation de l'utilisation en une minute √† 80% peut masquer une rafale √† court terme √† 100%. <br></li><li>  Le verrouillage cyclique (spin lock) conduit au fait que le processeur est √©limin√©, mais le processus utilisateur ne voit pas de progr√®s dans son ex√©cution.  Par cons√©quent, l'utilisation estim√©e du processeur par le processus sera de cent pour cent, bien que le processus ne consommera pas physiquement de temps processeur. <br></li></ul><br>  Je n'ai pas trouv√© d'article d√©crivant un calcul similaire pour le vol (si vous le savez, partagez les commentaires).  Mais, √† en juger par la source, le m√©canisme de calcul est le m√™me que pour l'√©limination.  C'est juste qu'un autre compteur est ajout√© au noyau, directement pour le processus KVM (processus de machine virtuelle), qui compte la dur√©e pendant laquelle le processus KVM est en veille du temps processeur.  Le compteur prend des informations sur le processeur √† partir de ses sp√©cifications et cherche √† voir si tous ses ticks ont √©t√© utilis√©s par le processus virtuel.  Si c'est tout, alors nous pensons que le processeur n'√©tait engag√© que dans le processus de la machine virtuelle.  Sinon, nous informons que le processeur faisait autre chose, le vol est apparu. <br><br>  Le processus de comptage des vols est soumis aux m√™mes probl√®mes que le comptage de recyclage r√©gulier.  Cela ne veut pas dire que de tels probl√®mes apparaissent fr√©quemment, mais ils semblent d√©courageants. <br><br><h3>  2.2.  Types de virtualisation sur KVM </h3><br>  D'une mani√®re g√©n√©rale, il existe trois types de virtualisation, et tous sont pris en charge par KVM.  Le type de virtualisation peut d√©terminer le m√©canisme par lequel le vol se produit. <br><br>  <b>Diffusion</b>  Dans ce cas, le fonctionnement du syst√®me d'exploitation de la machine virtuelle avec les p√©riph√©riques physiques de l'hyperviseur se produit approximativement comme ceci: <br><br><ol><li>  Le syst√®me d'exploitation invit√© envoie une commande √† son appareil invit√©. <br></li><li>  Le pilote de p√©riph√©rique invit√© accepte la commande, g√©n√®re une demande pour le BIOS du p√©riph√©rique et l'envoie √† l'hyperviseur. <br></li><li>  Le processus de l'hyperviseur traduit une commande en une commande pour un p√©riph√©rique physique, ce qui le rend, entre autres, plus s√ªr. <br></li><li>  Le pilote de p√©riph√©rique physique accepte la commande modifi√©e et l'envoie au p√©riph√©rique physique lui-m√™me. <br></li><li>  Les r√©sultats de l'ex√©cution des commandes remontent le m√™me chemin. <br></li></ol><br>  L'avantage de la traduction est qu'elle vous permet d'√©muler n'importe quel p√©riph√©rique et ne n√©cessite pas de pr√©paration sp√©ciale du noyau du syst√®me d'exploitation.  Mais il faut d'abord le payer avec rapidit√©. <br><br>  <b>Virtualisation mat√©rielle</b> .  Dans ce cas, l'appareil au niveau mat√©riel comprend les commandes du syst√®me d'exploitation.  C'est le moyen le plus rapide et le meilleur.  Mais, malheureusement, il n'est pas pris en charge par tous les p√©riph√©riques physiques, hyperviseurs et syst√®mes d'exploitation invit√©s.  Actuellement, les principaux p√©riph√©riques prenant en charge la virtualisation mat√©rielle sont les processeurs. <br><br>  <b>Paravirtualisation (paravirtualisation)</b> .  La version la plus courante de la virtualisation de p√©riph√©riques sur KVM et g√©n√©ralement le mode de virtualisation le plus courant pour les syst√®mes d'exploitation invit√©s.  Sa particularit√© est que le travail avec certains sous-syst√®mes de l'hyperviseur (par exemple, avec un r√©seau ou une pile de disques) ou l'allocation de pages m√©moire se fait √† l'aide de l'API hyperviseur, sans traduire les commandes de bas niveau.  L'inconv√©nient de cette m√©thode de virtualisation est la n√©cessit√© de modifier le noyau du syst√®me d'exploitation invit√© afin qu'il puisse interagir avec l'hyperviseur √† l'aide de cette API.  Mais g√©n√©ralement, cela est r√©solu en installant des pilotes sp√©ciaux sur le syst√®me d'exploitation invit√©.  Dans KVM, cette API est appel√©e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">API virtio</a> . <br><br>  Avec la paravirtualisation, par rapport √† la traduction, le chemin vers le p√©riph√©rique physique est consid√©rablement r√©duit en envoyant des commandes directement de la machine virtuelle au processus d'hyperviseur h√¥te.  Cela vous permet d'acc√©l√©rer l'ex√©cution de toutes les instructions √† l'int√©rieur de la machine virtuelle.  Dans KVM, l'API virtio en est responsable, ce qui ne fonctionne que pour certains p√©riph√©riques, comme un r√©seau ou un adaptateur de disque.  C'est pourquoi les pilotes virtio sont plac√©s √† l'int√©rieur des machines virtuelles. <br><br>  Le revers de cette acc√©l√©ration est que tous les processus qui s'ex√©cutent √† l'int√©rieur d'une machine virtuelle ne le restent pas.  Cela cr√©e des effets sp√©ciaux qui peuvent entra√Æner l'apparition de vols.  Je recommande de commencer une √©tude d√©taill√©e de ce probl√®me avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une API pour les E / S virtuelles: virtio</a> . <br><br><h3>  2.3.  D√©lib√©ration √©quitable </h3><br>  La virtualisation sur un hyperviseur est, en fait, un processus ordinaire qui ob√©it aux lois de d√©lestage (allocation des ressources entre les processus) dans le noyau Linux, nous allons donc l'examiner plus en d√©tail. <br><br>  Linux utilise le soi-disant CFS, Completely Fair Scheduler, qui est devenu le r√©partiteur par d√©faut depuis le noyau 2.6.23.  Pour comprendre cet algorithme, vous pouvez lire l'architecture ou les sources du noyau Linux.  L'essence de CFS est la r√©partition du temps processeur entre les processus en fonction de la dur√©e de leur ex√©cution.  Plus le processus n√©cessite de temps processeur, moins il re√ßoit de temps.  Cela garantit l'ex√©cution ¬´honn√™te¬ª de tous les processus - de sorte qu'un processus n'occupe pas constamment tous les processeurs et que d'autres processus puissent √©galement √™tre ex√©cut√©s. <br><br>  Parfois, ce paradigme conduit √† des artefacts int√©ressants.  Les utilisateurs de longue date de Linux se souviendront probablement de la d√©coloration d'un √©diteur de texte de bureau normal lors de l'ex√©cution d'applications exigeantes de type compilateur.  Cela s'est produit parce que les t√¢ches non gourmandes en ressources des applications de bureau √©taient en concurrence avec des t√¢ches qui consomment activement des ressources, comme un compilateur.  CFS consid√®re que cela est malhonn√™te, il arr√™te donc p√©riodiquement l'√©diteur de texte et permet au processeur de traiter les t√¢ches du compilateur.  Cela a √©t√© corrig√© en utilisant le m√©canisme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">sched_autogroup</a> , mais de nombreuses autres fonctionnalit√©s de la distribution du temps CPU entre les t√¢ches sont rest√©es.  En fait, cette histoire ne concerne pas la gravit√© des probl√®mes dans CFS, mais une tentative pour attirer l'attention sur le fait qu'une distribution ¬´honn√™te¬ª du temps processeur n'est pas la t√¢che la plus triviale. <br><br>  Un autre point important dans le sheduler est la pr√©emption.  Cela est n√©cessaire pour piloter le processus de ricanement √† partir du processeur et laisser les autres travailler.  Le processus d'exil est appel√© commutation de contexte, commutation de contexte de processeur.  Dans ce cas, tout le contexte de la t√¢che est sauvegard√©: l'√©tat de la pile, des registres, etc., apr√®s quoi le processus va attendre, et un autre prend sa place.  C'est une op√©ration co√ªteuse pour le syst√®me d'exploitation, et elle est rarement utilis√©e, mais en fait il n'y a rien de mal √† cela.  Un changement de contexte fr√©quent peut indiquer un probl√®me dans le syst√®me d'exploitation, mais il se poursuit g√©n√©ralement en continu et n'indique rien de particulier. <br><br>  Une si longue histoire est n√©cessaire pour expliquer un fait: plus un honn√™te sheduler Linux essaie de consommer de ressources processeur, plus il sera arr√™t√© rapidement pour que d'autres processus puissent √©galement fonctionner.  Que ce soit correct ou non est un probl√®me complexe, qui est r√©solu diff√©remment sous diff√©rentes charges.  Sous Windows, jusqu'√† r√©cemment, le sheduler se concentrait sur le traitement prioritaire des applications de bureau, en raison des processus d'arri√®re-plan qui pouvaient se bloquer.  Sun Solaris avait cinq classes diff√©rentes de shedulers.  Lorsqu'ils ont commenc√© la virtualisation, ils ont ajout√© le sixi√®me <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">planificateur de partage √©quitable</a> , car les cinq pr√©c√©dents ne fonctionnaient pas correctement avec la virtualisation des zones Solaris.  Je recommande de commencer une √©tude d√©taill√©e de ce probl√®me avec des livres comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Solaris Internals: Solaris 10 et OpenSolaris Kernel Architecture</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Understanding the Linux Kernel</a> . <br><br><h3>  2.4.  Comment surveiller voler? </h3><br>  La surveillance du vol dans une machine virtuelle, comme toute autre mesure de processeur, est simple: vous pouvez utiliser n'importe quel moyen pour supprimer les mesures de processeur.  L'essentiel est que la machine virtuelle soit sous Linux.  Pour une raison quelconque, Windows ne fournit pas ces informations √† ses utilisateurs.  :( <br><br><img src="https://habrastorage.org/getpro/habr/post_images/804/731/75c/80473175cd23f0ba8721ca61c65fe111.png"><br>  <i>La sortie de la commande sup√©rieure: d√©tails de la charge du processeur, dans la colonne la plus √† droite - voler</i> <br><br>  La difficult√© survient lorsque vous essayez d'obtenir ces informations de l'hyperviseur.  Vous pouvez essayer de pr√©dire le vol sur la machine h√¥te, par exemple, par le param√®tre Load Average (LA) - la valeur moyenne du nombre de processus en attente d'ex√©cution dans la file d'attente.  La m√©thodologie de calcul de ce param√®tre n'est pas simple, mais en g√©n√©ral, si LA, normalis√© par le nombre de threads de processeur, est sup√©rieur √† 1, cela indique que le serveur Linux est quelque peu surcharg√©. <br><br>  Qu'attendent tous ces processus?  La r√©ponse √©vidente est le processeur.  Mais la r√©ponse n'est pas enti√®rement correcte, car parfois le processeur est gratuit et LA se retourne.  Rappelez-vous <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comment NFS tombe et comment LA grandit</a> .  Il peut √™tre √† peu pr√®s la m√™me chose avec un disque et avec d'autres p√©riph√©riques d'entr√©e / sortie.  Mais en fait, les processus peuvent s'attendre √† la fin de tout verrou, √† la fois physique, associ√© √† un p√©riph√©rique d'E / S, et logique, comme un mutex.  Cela inclut √©galement les verrous au niveau mat√©riel (la m√™me r√©ponse du disque) ou la logique (les soi-disant primitives de verrouillage, qui incluent un tas d'entit√©s, mutex adaptative et spin, s√©maphores, variables de condition, verrous rw, verrous ipc ...). <br><br>  Une autre caract√©ristique de LA est qu'elle est consid√©r√©e comme la valeur moyenne du syst√®me d'exploitation.  Par exemple, 100 processus sont en concurrence pour un fichier, puis LA = 50.  Une telle valeur, semble-t-il, sugg√®re que le syst√®me d'exploitation est mauvais.  Mais pour d'autres codes √©crits de mani√®re tordue, cela peut √™tre un √©tat normal, malgr√© le fait qu'il ne soit mauvais que pour lui, et que les autres processus du syst√®me d'exploitation n'en souffrent pas. <br><br>  En raison de cette moyenne (et pas moins d'une minute), d√©terminer quelque chose par l'indicateur LA n'est pas la t√¢che la plus reconnaissante, avec des r√©sultats tr√®s incertains dans des cas sp√©cifiques.  Si vous essayez de le comprendre, vous constaterez que seuls les cas les plus simples sont d√©crits dans les articles Wikipedia et autres ressources disponibles, sans explication approfondie du processus.  J'envoie tous les int√©ress√©s, encore une fois, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici √† Brendann Gregg</a> - plus loin sur les liens.  Pour qui la paresse en anglais est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction de son article populaire sur LA</a> . <br><br><h2>  3. Effets sp√©ciaux </h2><br>  Passons maintenant aux principaux cas de vol que nous avons rencontr√©s.  Je vais vous dire comment ils d√©coulent de ce qui pr√©c√®de et comment ils se rapportent aux indicateurs de l'hyperviseur. <br><br>  <b>Le recyclage</b> .  Le plus simple et le plus fr√©quent: l'hyperviseur est r√©utilis√©.  En effet, il y a beaucoup de machines virtuelles en cours d'ex√©cution, une grande consommation de processeur √† l'int√©rieur, beaucoup de concurrence, l'utilisation de LA est sup√©rieure √† 1 (normalis√©e par les threads de processeur).  Dans tous les virtualoks, tout ralentit.  Le vol transmis par l'hyperviseur augmente √©galement, il est n√©cessaire de redistribuer la charge ou d'√©teindre quelqu'un.  En g√©n√©ral, tout est logique et compr√©hensible. <br><br>  <b>Paravirtualisation versus instances uniques</b> .  Il y a une seule machine virtuelle sur l'hyperviseur, elle en consomme une petite partie, mais elle donne une grande charge en entr√©e / sortie, par exemple, sur un disque.  Et de quelque part, un petit vol appara√Æt, jusqu'√† 10% (comme le montrent plusieurs exp√©riences). <br><br>  L'affaire est int√©ressante.  Le vol appara√Æt ici juste √† cause des verrous au niveau des pilotes paravirtualis√©s.  Une interruption est cr√©√©e √† l'int√©rieur de la machine virtuelle, trait√©e par le pilote, et va √† l'hyperviseur.  En raison du traitement d'interruption sur l'hyperviseur de la machine virtuelle, cela ressemble √† une demande envoy√©e, il est pr√™t √† √™tre ex√©cut√© et en attente du processeur, mais ils ne donnent pas de temps au processeur.  Virtualka pense que ce temps est vol√©. <br><br>  Cela se produit lorsque le tampon est envoy√©, il va dans l'espace noyau de l'hyperviseur et nous commen√ßons √† l'attendre.  Bien que, du point de vue de virtualka, il devrait imm√©diatement revenir.  Par cons√©quent, selon l'algorithme de calcul de vol, ce temps est consid√©r√© comme vol√©.  Tr√®s probablement, dans cette situation, il peut y avoir d'autres m√©canismes (par exemple, le traitement de certains autres appels sys), mais ils ne devraient pas √™tre tr√®s diff√©rents. <br><br>  <b>Sheduler contre les virtualoks lourdement charg√©s</b> .  Lorsqu'une machine virtuelle souffre de voler plus que d'autres, elle est connect√©e pr√©cis√©ment avec le sheduler.  Plus le processus charge le processeur, plus t√¥t le sheduler l'expulsera, afin que les autres puissent √©galement fonctionner.  Si la machine virtuelle consomme un peu, elle ne voit presque pas voler: son processus s'est honn√™tement assis et attendu, il faut lui donner plus de temps.  Si la machine virtuelle produit la charge maximale sur tous ses c≈ìurs, elle est souvent expuls√©e du processeur et essaie de ne pas laisser trop de temps. <br><br>  Pire encore, lorsque les processus √† l'int√©rieur de la machine virtuelle essaient d'obtenir plus de processeur, car ils ne peuvent pas faire face au traitement des donn√©es.  Ensuite, le syst√®me d'exploitation sur l'hyperviseur, en raison d'une optimisation honn√™te, donnera de moins en moins de temps processeur.  Ce processus se d√©roule comme une avalanche, et le vol saute au ciel, bien que d'autres machines virtuelles ne le remarquent presque pas.  Et plus il y a de c≈ìurs, plus la machine tombe sous la distribution.  En bref, les machines virtuelles fortement charg√©es avec de nombreux c≈ìurs souffrent le plus. <br><br>  <b>Faible LA, mais il y a un vol</b> .  Si LA est d'environ 0,7 (c'est-√†-dire que l'hyperviseur semble √™tre sous-charg√©), mais le vol est observ√© √† l'int√©rieur des machines virtuelles individuelles: <br><br><ul><li>  L'option d√©crite ci-dessus avec paravirtualisation.  Une machine virtuelle peut recevoir des m√©triques qui pointent vers le vol, bien que tout va bien avec l'hyperviseur.  Selon les r√©sultats de nos exp√©riences, une telle option de vol ne d√©passe pas 10% et ne devrait pas avoir un impact significatif sur les performances des applications √† l'int√©rieur de la machine virtuelle. <br></li><li>  Le param√®tre LA est incorrectement consid√©r√©.  Plus pr√©cis√©ment, √† chaque instant, elle est consid√©r√©e comme vraie, mais lorsqu'elle est calcul√©e en moyenne pendant une minute, elle se r√©v√®le sous-estim√©e.  Par exemple, si une machine virtuelle consomme tous ses processeurs pendant exactement une demi-minute par tiers de l'hyperviseur, alors LA par minute sera de 0,15 sur l'hyperviseur;  quatre de ces machines virtuelles fonctionnant simultan√©ment donneront 0,6.  Et le fait que pendant une demi-minute sur chacun d'eux il y ait eu un vol sauvage √† 25% √† LA, ne peut plus √™tre retir√©. <br></li><li>  Encore une fois, √† cause du sheduler qui a d√©cid√© que quelqu'un mangeait trop et a laiss√© celui-ci attendre.  En attendant, je change de contexte, je traite les interruptions et je fais d'autres choses importantes sur le syst√®me.  Par cons√©quent, certaines machines virtuelles ne voient aucun probl√®me, tandis que d'autres connaissent une grave d√©gradation des performances. <br></li></ul><br><h2>  4. Autres distorsions </h2><br>  Il existe un autre million de raisons pour fausser le retour honn√™te du temps processeur sur la machine virtuelle.  Par exemple, l'hypertreading et NUMA ajoutent de la complexit√© aux calculs.  Ils confondent compl√®tement le choix du noyau pour ex√©cuter le processus, parce que le sheduler utilise des coefficients - poids, qui lors des changements de contextes rendent le calcul encore plus difficile. <br><br>  Il existe des distorsions dues √† des technologies telles que le turbo boost ou, inversement, le mode d'√©conomie d'√©nergie, qui lors du calcul de l'utilisation peut augmenter ou diminuer artificiellement la fr√©quence ou m√™me la tranche de temps sur le serveur.  L'activation du turbo boost r√©duit les performances d'un thread de processeur en raison des performances accrues d'un autre.  √Ä ce moment, les informations sur la fr√©quence actuelle du processeur ne sont pas transmises √† la machine virtuelle, et elle pense que quelqu'un fixe son temps (par exemple, elle a demand√© 2 GHz, mais elle en a re√ßu la moiti√©). <br><br>  En g√©n√©ral, il peut y avoir de nombreuses causes de distorsion.  Dans un syst√®me particulier, vous pouvez trouver autre chose.  Il vaut mieux commencer par les livres auxquels j'ai donn√© les liens ci-dessus, et prendre les statistiques de l'hyperviseur avec des utilitaires comme perf, sysdig, systemtap, dont il existe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dizaines</a> . <br><br><h2>  5. Conclusions </h2><br><ol><li>  Une certaine quantit√© de vol peut survenir en raison de la paravirtualisation, et elle peut √™tre consid√©r√©e comme normale.  Sur Internet, ils √©crivent que cette valeur peut √™tre de 5 √† 10%.  Cela d√©pend des applications √† l'int√©rieur de la machine virtuelle et du type de charge qu'elle met sur ses p√©riph√©riques physiques.  Il est important de faire attention √† la fa√ßon dont les applications au sein des machines virtuelles se sentent. <br></li><li>  Le rapport de la charge sur l'hyperviseur et le vol √† l'int√©rieur de la machine virtuelle n'est pas toujours interconnect√© sans ambigu√Øt√©, les deux estimations de vol peuvent √™tre erron√©es dans des situations sp√©cifiques √† diff√©rentes charges. <br></li><li>  Le planificateur n'aime pas les processus qui demandent beaucoup.  Il essaie de donner moins √† ceux qui en demandent plus.  Les grosses machines virtuelles sont mauvaises. <br></li><li>  Un petit vol peut √™tre la norme sans paravirtualisation (en tenant compte de la charge √† l'int√©rieur de la machine virtuelle, des caract√©ristiques de la charge des voisins, de la r√©partition de la charge entre les threads et d'autres facteurs). <br></li><li>  Si vous voulez d√©couvrir voler dans un syst√®me sp√©cifique, vous devez rechercher diverses options, collecter des m√©triques, les analyser soigneusement et r√©fl√©chir √† la fa√ßon de r√©partir uniform√©ment la charge.  Des √©carts sont possibles dans tous les cas, qui doivent √™tre confirm√©s exp√©rimentalement ou affich√©s dans le d√©bogueur du noyau. <br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr449316/">https://habr.com/ru/post/fr449316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr449306/index.html">12 mots anglais souvent mal orthographi√©s et mal prononc√©s</a></li>
<li><a href="../fr449308/index.html">Pr√©sentation de Microsoft Azure DevTest Labs</a></li>
<li><a href="../fr449310/index.html">Citymobil - un manuel pour am√©liorer la disponibilit√© au milieu de la croissance des entreprises pour les startups. 2e partie</a></li>
<li><a href="../fr449312/index.html">RAID mat√©riel: fonctionnalit√©s d'utilisation</a></li>
<li><a href="../fr449314/index.html">Immigration en freelance: ce que vous devez savoir</a></li>
<li><a href="../fr449318/index.html">Comment le succ√®s de Fortnite a conduit √† des mois de crise intense √† Epic Games</a></li>
<li><a href="../fr449320/index.html">Comment la s√©curit√© de l'information a chang√© au cours des 20 derni√®res ann√©es</a></li>
<li><a href="../fr449322/index.html">R√©seaux de t√©l√©vision par c√¢ble pour les plus petits. Partie 1: Architecture g√©n√©rale du r√©seau KTV</a></li>
<li><a href="../fr449324/index.html">Charges, smartphones, entreprises g√©antes: programme Heisenbug 2019 Piter</a></li>
<li><a href="../fr449326/index.html">WebRTC et vid√©osurveillance: comment nous avons vaincu le retard de la vid√©o des cam√©ras</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>