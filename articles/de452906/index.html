<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ôãÔ∏è üë©üèº‚Äçü§ù‚Äçüë®üèΩ üé≤ JavaScript-Engines: Wie funktionieren sie? Vom Call-Stack bis zu den Versprechungen (fast) alles, was Sie wissen m√ºssen üñêüèª üöß ‚úàÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Haben Sie sich jemals gefragt, wie Browser JavaScript-Code lesen und ausf√ºhren? Es sieht mysteri√∂s aus, aber in diesem Beitrag k√∂nnen Sie eine Vorstel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Engines: Wie funktionieren sie? Vom Call-Stack bis zu den Versprechungen (fast) alles, was Sie wissen m√ºssen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/452906/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sd/nm/n6/sdnmn6cuvwusvk4fysdkzvnw9rg.jpeg"></div><br>  Haben Sie sich jemals gefragt, wie Browser JavaScript-Code lesen und ausf√ºhren?  Es sieht mysteri√∂s aus, aber in diesem Beitrag k√∂nnen Sie eine Vorstellung davon bekommen, was unter der Haube passiert. <br><br>  Wir beginnen unsere Reise in die Sprache mit einem Ausflug in die wunderbare Welt der JavaScript-Engines. <br><a name="habracut"></a><br>  √ñffnen Sie die Konsole in Chrome und wechseln Sie zur Registerkarte Quellen.  Sie werden mehrere Abschnitte sehen, und einer der interessantesten hei√üt <b>Call Stack</b> (in Firefox sehen Sie Call Stack, wenn Sie einen Haltepunkt in den Code einf√ºgen): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/46f/a81/d3446fa81bf753ff80d32e39bcf5778c.png"><br><br>  Was ist ein Call Stack?  Es scheint viel los zu sein, auch um ein paar Codezeilen auszuf√ºhren.  Tats√§chlich wird JavaScript nicht in jedem Browser mitgeliefert.  Es gibt eine gro√üe Komponente, die unseren JavaScript-Code kompiliert und interpretiert - es ist eine JavaScript-Engine.  Am beliebtesten sind V8, es wird in Google Chrome und Node.js verwendet, SpiderMonkey in Firefox, JavaScriptCore in Safari / WebKit. <br><br>  JavaScript-Engines sind heute hervorragende Beispiele f√ºr Software-Engineering, und es wird fast unm√∂glich sein, √ºber alle Aspekte zu sprechen.  Die Hauptarbeit zur Codeausf√ºhrung wird f√ºr uns jedoch nur von wenigen Komponenten der Engines erledigt: Call Stack (Call Stack), Global Memory (Global Memory) und Execution Context (Ausf√ºhrungskontext).  Bereit sie zu treffen? <br><br>  Inhalt: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Engines und globaler Speicher</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Engines: Wie funktionieren sie?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Globaler Ausf√ºhrungskontext und Aufrufstapel</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript ist Single-Threaded und andere lustige Geschichten</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrones JavaScript, R√ºckrufwarteschlange und Ereignisschleife</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">R√ºckruf H√∂lle und verspricht ES6</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen und Arbeiten mit JavaScript-Versprechen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fehlerbehandlung in ES6-Versprechungen</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ES6 Promise-Kombinatoren: Promise.all, Promise.allSettled, Promise.any und andere</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ES6 verspricht und Mikrotask-Warteschlange</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Engines: Wie funktionieren sie?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Asynchrone Evolution: von Versprechen zu Async / Warten</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">JavaScript-Engines: Wie funktionieren sie?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zusammenfassung</a> <br></li></ol><br><a name="1"></a><h2>  1. JavaScript-Engines und globaler Speicher </h2><br>  Ich sagte, dass JavaScript sowohl eine kompilierte als auch eine interpretierte Sprache ist.  Ob Sie es glauben oder nicht, JavaScript-Engines kompilieren Ihren Code tats√§chlich Mikrosekunden, bevor er ausgef√ºhrt wird. <br><br>  Eine Art Magie, oder?  Diese Magie hei√üt JIT (Just in Time Compilation).  Es allein ist ein gro√ües Diskussionsthema, selbst B√ºcher werden nicht ausreichen, um die Arbeit von JIT zu beschreiben.  Aber jetzt werden wir die Theorie √ºberspringen und uns auf die Ausf√ºhrungsphase konzentrieren, was nicht weniger interessant ist. <br><br>  Schauen Sie sich zun√§chst diesen Code an: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; }</code> </pre> <br>  Angenommen, ich frage Sie, wie dieser Code in einem Browser verarbeitet wird.  Was wirst du antworten?  Sie k√∂nnen sagen: "Der Browser liest den Code" oder "Der Browser f√ºhrt den Code aus".  In Wirklichkeit ist nicht alles so einfach.  Zun√§chst wird der Code nicht vom Browser, sondern von der Engine gelesen.  <b>Die JavaScript-Engine liest den Code</b> und <b>f√ºgt</b> , sobald sie die erste Zeile definiert, einige Links in den <b>globalen Speicher ein</b> . <br><br>  Der globale Speicher (auch Heap genannt) ist der Bereich, in dem die JavaScript-Engine Variablen und Funktionsdeklarationen speichert.  Und wenn er den obigen Code liest, erscheinen zwei Ordner im globalen Speicher: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/0a8/a90/11b0a8a904acef9ee7bde8b84cb76873.png"><br><br>  Auch wenn das Beispiel nur eine Variable und eine Funktion enth√§lt, stellen Sie sich vor, dass Ihr JavaScript-Code in einer gr√∂√üeren Umgebung ausgef√ºhrt wird: in einem Browser oder in Node.js.  In solchen Umgebungen gibt es viele vordefinierte Funktionen und Variablen, die als global bezeichnet werden.  Daher enth√§lt der globale Speicher viel mehr Daten als nur <code>num</code> und <code>pow</code> . <br><br>  Im Moment l√§uft nichts.  Versuchen wir nun, unsere Funktion auszuf√ºhren: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Was wird passieren?  Und etwas Interessantes wird passieren.  Beim Aufrufen der Funktion hebt die JavaScript-Engine zwei Abschnitte hervor: <br><br><ul><li>  Globaler Ausf√ºhrungskontext <br></li><li>  Stapel aufrufen <br></li></ul><br>  Was sind sie? <br><br><a name="2"></a><h2>  2. JavaScript-Engines: Wie funktionieren sie?  Globaler Ausf√ºhrungskontext und Aufrufstapel </h2><br>  Sie haben gelernt, wie die JavaScript-Engine Variablen und Funktionsdeklarationen liest.  Sie fallen in den globalen Speicher (Heap). <br><br>  Aber jetzt f√ºhren wir eine JavaScript-Funktion aus, und die Engine sollte sich darum k√ºmmern.  Auf welche Weise?  Jede JavaScript-Engine verf√ºgt √ºber eine <b>Schl√ºsselkomponente, die als Aufrufstapel bezeichnet wird</b> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dies ist eine gestapelte Datenstruktur</a> : Elemente k√∂nnen von oben hinzugef√ºgt werden, sie k√∂nnen jedoch nicht von der Struktur ausgeschlossen werden, solange sich andere Elemente dar√ºber befinden.  So funktionieren JavaScript-Funktionen.  Bei der Ausf√ºhrung k√∂nnen sie den Aufrufstapel nicht verlassen, wenn eine andere Funktion darin vorhanden ist.  Beachten Sie dies, da dieses Konzept zum Verst√§ndnis der Aussage "JavaScript ist Single-Threaded" beitr√§gt. <br><br>  Aber zur√ºck zu unserem Beispiel.  <b>Wenn eine Funktion aufgerufen wird, sendet die Engine sie an den Aufrufstapel</b> : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b79/118/a43/b79118a430d9daa8af3491138c0cfd2b.png"><br><br>  Ich pr√§sentiere den Call-Stack gerne als Stapel von Pringles-Chips.  Wir k√∂nnen keine Chips vom Boden des Stapels essen, bis wir diejenigen essen, die oben sind.  Gl√ºcklicherweise ist unsere Funktion synchron: Es ist nur eine Multiplikation, die schnell berechnet wird. <br><br>  Gleichzeitig platziert die Engine den <b>globalen Ausf√ºhrungskontext</b> im Speicher. Dies ist die globale Umgebung, in der JavaScript-Code ausgef√ºhrt wird.  So sieht es aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ea8/a33/9c1/ea8a339c120638632b57eb0fb3161254.png"><br><br>  Stellen Sie sich einen globalen Ausf√ºhrungskontext in Form eines Meeres vor, in dem globale JavaScript-Funktionen wie Fische schweben.  Wie s√º√ü!  Dies ist jedoch nur die halbe Wahrheit.  Was ist, wenn unsere Funktion verschachtelte Variablen oder interne Funktionen hat? <br><br>  Selbst im einfachen Fall, wie unten gezeigt, erstellt die JavaScript-Engine einen <b>lokalen Ausf√ºhrungskontext</b> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fixed = <span class="hljs-number"><span class="hljs-number">89</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num);</code> </pre> <br>  Beachten Sie, dass ich die <code>fixed</code> Variable zur <code>pow</code> Funktion hinzugef√ºgt habe.  In diesem Fall enth√§lt der lokale Ausf√ºhrungskontext einen Abschnitt f√ºr <code>fixed</code> .  Ich bin nicht sehr gut darin, kleine Rechtecke in andere kleine Rechtecke zu zeichnen. Verwenden Sie also Ihre Fantasie. <br><br>  Ein lokaler Ausf√ºhrungskontext wird neben <code>pow</code> im gr√ºnen Rechteckbereich im globalen Ausf√ºhrungskontext angezeigt.  Stellen Sie sich auch vor, wie die Engine f√ºr jede verschachtelte Funktion innerhalb der verschachtelten Funktion andere lokale Ausf√ºhrungskontexte erstellt.  Alle diese Rechteckabschnitte erscheinen sehr schnell!  Wie eine Nistpuppe! <br><br>  Kommen wir zur√ºck zur Single-Threaded-Geschichte.  Was bedeutet das? <br><br><a name="3"></a><h2>  3. JavaScript ist Single-Threaded und andere lustige Geschichten </h2><br>  Wir sagen, dass <b>JavaScript Single-Threaded ist, da nur ein Aufrufstapel unsere Funktionen √ºbernimmt</b> .  Ich m√∂chte Sie daran erinnern, dass Funktionen den Aufrufstapel nicht verlassen k√∂nnen, wenn andere Funktionen die Ausf√ºhrung erwarten. <br><br>  Dies ist kein Problem, wenn wir mit synchronem Code arbeiten.  Beispielsweise ist die Addition von zwei Zahlen synchron und wird in Mikrosekunden berechnet.  Was ist mit Netzwerkanrufen und anderen Interaktionen mit der Au√üenwelt? <br><br>  Gl√ºcklicherweise sind <b>JavaScript-Engines standardm√§√üig so konzipiert, dass sie asynchron arbeiten</b> .  Selbst wenn sie jeweils nur eine Funktion ausf√ºhren k√∂nnen, k√∂nnen langsamere Funktionen von einer externen Entit√§t ausgef√ºhrt werden - in unserem Fall handelt es sich um einen Browser.  Wir werden weiter unten dar√ºber sprechen. <br><br>  Gleichzeitig wissen Sie, dass die Engine diesen Code zeilenweise liest und die folgenden Schritte ausf√ºhrt, wenn der Browser eine Art JavaScript-Code l√§dt: <br><br><ul><li>  F√ºgt Variablen und Funktionsdeklarationen in den globalen Speicher (Heap) ein. <br></li><li>  Sendet einen Aufruf an jede Funktion im Aufrufstapel. <br></li><li>  Erstellt einen globalen Ausf√ºhrungskontext, in dem globale Funktionen ausgef√ºhrt werden. <br></li><li>  Erstellt viele kleine lokale Ausf√ºhrungskontexte (wenn interne Variablen oder verschachtelte Funktionen vorhanden sind). <br></li></ul><br>  Sie haben jetzt ein grundlegendes Verst√§ndnis der Synchronisationsmechanik, die allen JavaScript-Engines zugrunde liegt.  Im n√§chsten Kapitel werden wir dar√ºber sprechen, wie asynchroner Code in JavaScript funktioniert und warum dies so funktioniert. <br><br><a name="4"></a><h2>  4. Asynchrones JavaScript, R√ºckrufwarteschlange und Ereignisschleife </h2><br>  Dank des globalen Speichers, des Ausf√ºhrungskontexts und des Aufrufstapels wird synchroner JavaScript-Code in unseren Browsern ausgef√ºhrt.  Aber wir haben etwas vergessen.  Was passiert, wenn Sie eine asynchrone Funktion ausf√ºhren m√ºssen? <br><br>  Mit asynchroner Funktion meine ich jede Interaktion mit der Au√üenwelt, deren Abschluss einige Zeit in Anspruch nehmen kann.  Das Aufrufen der REST-API oder des Timers erfolgt asynchron, da die Ausf√ºhrung Sekunden dauern kann.  Dank der in der Engine verf√ºgbaren Elemente k√∂nnen wir solche Funktionen verarbeiten, ohne den Aufrufstapel und den Browser zu blockieren.  Vergessen Sie nicht, dass der Aufrufstapel jeweils nur eine Funktion ausf√ºhren kann und <b>sogar eine Blockierungsfunktion den Browser buchst√§blich stoppen kann</b> .  Gl√ºcklicherweise sind JavaScript-Engines intelligent und k√∂nnen mit ein wenig Hilfe des Browsers Abhilfe schaffen. <br><br>  Wenn wir eine asynchrone Funktion ausf√ºhren, nimmt der Browser sie und f√ºhrt sie f√ºr uns aus.  Nehmen Sie einen Timer wie diesen: <br><br><pre> <code class="javascript hljs">setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Ich bin mir sicher, dass Sie, obwohl Sie <code>setTimeout</code> hunderte Male gesehen haben, m√∂glicherweise nicht wissen, dass <b>diese Funktion nicht in JavaScript integriert ist</b> .  Als JavaScript <code>setTimeout</code> , war darin keine <code>setTimeout</code> Funktion enthalten.  Tats√§chlich ist es Teil der sogenannten Browser-APIs, einer Sammlung praktischer Tools, die der Browser uns zur Verf√ºgung stellt.  Wunderbar!  Aber was bedeutet das in der Praxis?  Da sich <code>setTimeout</code> auf die Browser-API bezieht, wird diese Funktion vom Browser selbst ausgef√ºhrt (f√ºr einen Moment erscheint sie im Aufrufstapel, wird aber sofort von dort gel√∂scht). <br><br>  Nach 10 Sekunden √ºbernimmt der Browser die R√ºckruffunktion, die wir an ihn √ºbergeben haben, und stellt sie in die <b>R√ºckrufwarteschlange</b> .  Im Moment sind zwei weitere Rechteckabschnitte in der JavaScript-Engine erschienen.  Schauen Sie sich diesen Code an: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> num = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">num</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num * num; } pow(num); setTimeout(callback, <span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">callback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'hello timer!'</span></span>); }</code> </pre> <br>  Jetzt sieht unser Schema so aus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00f/8e2/b33/00f8e2b33a47490117a9e8f6abad23f5.png"><br><br>  <code>setTimeout</code> wird im Browserkontext ausgef√ºhrt.  Nach 10 Sekunden startet der Timer und die R√ºckruffunktion ist zur Ausf√ºhrung bereit.  Aber zuerst muss es die R√ºckrufwarteschlange durchlaufen.  Dies ist eine Datenstruktur in Form einer Warteschlange und, wie der Name schon sagt, eine geordnete Funktionswarteschlange. <br><br>  Jede asynchrone Funktion muss eine R√ºckrufwarteschlange durchlaufen, bevor sie in den Aufrufstapel gelangt.  Aber wer sendet die Funktionen als n√§chstes?  Dadurch wird eine Komponente als <b>Ereignisschleife bezeichnet</b> . <br><br>  Bisher behandelt die Ereignisschleife nur eines: Sie pr√ºft, ob der Aufrufstapel leer ist.  Wenn sich in der R√ºckrufwarteschlange eine Funktion befindet und der Aufrufstapel frei ist, ist es Zeit, einen R√ºckruf an den Aufrufstapel zu senden. <br><br>  Danach gilt die Funktion als ausgef√ºhrt.  Dies ist das allgemeine Schema f√ºr die Verarbeitung von asynchronem und synchronem Code mit der JavaScript-Engine: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eba/ec9/fec/ebaec9fec5dc1931176371fd4a9f3cbd.png"><br><br>  Angenommen, <code>callback()</code> ist zur Ausf√ºhrung bereit.  Wenn <code>pow()</code> <b>der Aufrufstapel freigegeben und die Ereignisschleife sendet</b> <code>callback()</code> .  Und alle!  Obwohl ich die Dinge ein wenig vereinfacht habe, k√∂nnen Sie, wenn Sie das obige Diagramm verstehen, alles JavaScript verstehen. <br><br>  Denken Sie daran: <b>Browserbasierte APIs, R√ºckrufwarteschlangen und Ereignisschleifen sind die S√§ulen von asynchronem JavaScript</b> . <br><br>  Und wenn Sie interessiert sind, k√∂nnen Sie sich das kuriose Video ‚ÄûWas zum Teufel ist die Event-Schleife √ºberhaupt?‚Äú Von Philip Roberts ansehen.  Dies ist eine der besten Erkl√§rungen f√ºr die Ereignisschleife. <br><br>  Das asynchrone JavaScript-Thema ist jedoch noch nicht fertig.  In den folgenden Kapiteln werden wir ES6-Versprechen betrachten. <br><br><a name="5"></a><h2>  5. Callback Hell und ES6 Versprechen </h2><br>  R√ºckruffunktionen werden in JavaScript √ºberall verwendet, sowohl im synchronen als auch im asynchronen Code.  Betrachten Sie diese Methode: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element * <span class="hljs-number"><span class="hljs-number">2</span></span>; } [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>].map(mapper);</code> </pre><br>  <code>mapper</code> ist eine R√ºckruffunktion, die innerhalb der <code>map</code> .  Der obige Code ist synchron.  Betrachten Sie nun dieses Intervall: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runMeEvery</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Ran!'</span></span>); } setInterval(runMeEvery, <span class="hljs-number"><span class="hljs-number">5000</span></span>);</code> </pre> <br>  Dieser Code ist asynchron, da wir in <code>setInterval</code> den runMeEvery-R√ºckruf √ºbergeben.  R√ºckrufe werden in JavaScript verwendet, daher haben wir seit Jahren ein Problem namens "R√ºckrufh√∂lle" - "R√ºckrufh√∂lle". <br><br>  Der Begriff <b>R√ºckrufh√∂lle</b> in JavaScript wird auf den "Programmierstil" angewendet, bei dem R√ºckrufe in andere R√ºckrufe eingebettet sind, die in andere R√ºckrufe eingebettet sind ... Aufgrund der Asynchronit√§t sind JavaScript-Programmierer seit langem in diese Falle geraten. <br><br>  Um ehrlich zu sein, habe ich nie gro√üe Pyramiden von R√ºckrufen geschaffen.  Vielleicht, weil ich lesbaren Code sch√§tze und immer versuche, mich an seine Prinzipien zu halten.  Wenn Sie die Callback-H√∂lle erreichen, bedeutet dies, dass Ihre Funktion zu viel leistet. <br><br>  Ich werde nicht im Detail √ºber die R√ºckrufh√∂lle sprechen. Wenn Sie interessiert sind, gehen Sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">callbackhell.com</a> , wo dieses Problem im Detail untersucht und verschiedene L√∂sungen vorgeschlagen wurden.  Und wir werden √ºber <b>ES6-Versprechen</b> sprechen.  Dies ist ein JavaScript-Addon, das entwickelt wurde, um das Problem des R√ºckrufs zu l√∂sen.  Aber was sind Versprechen? <br><br>  <b>Ein JavaScript-Versprechen ist eine Darstellung eines zuk√ºnftigen Ereignisses</b> .  Ein Versprechen kann erfolgreich enden oder in einem Jargon von Programmierern wird ein Versprechen ‚Äûgel√∂st‚Äú (gel√∂st).  Wenn das Versprechen jedoch mit einem Fehler endet, sagen wir, dass es sich im abgelehnten Zustand befindet.  Versprechen haben auch einen Standardstatus: Jedes neue Versprechen beginnt in einem ausstehenden Status.  Kann ich mein eigenes Versprechen machen?  Ja  Wir werden im n√§chsten Kapitel dar√ºber sprechen. <br><br><a name="6"></a><h2>  6. Erstellen und Arbeiten mit JavaScript-Versprechen </h2><br>  Um ein neues Versprechen zu erstellen, m√ºssen Sie den Konstruktor aufrufen, indem Sie ihm eine R√ºckruffunktion √ºbergeben.  Es k√∂nnen nur zwei Parameter verwendet werden: <code>resolve</code> und <code>reject</code> .  Lassen Sie uns ein neues Versprechen erstellen, das in 5 Sekunden gel√∂st wird (Sie k√∂nnen die Beispiele in der Browserkonsole testen): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Wie Sie sehen k√∂nnen, ist <code>resolve</code> eine Funktion, die wir aufrufen, damit das Versprechen erfolgreich endet.  Und <code>reject</code> schafft ein abgelehntes Versprechen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ reject() }, <span class="hljs-number"><span class="hljs-number">5000</span></span>) });</code> </pre> <br>  Beachten Sie, dass Sie die <code>reject</code> ignorieren k√∂nnen, da dies der zweite Parameter ist.  Wenn Sie jedoch <code>reject</code> , k√∂nnen Sie <b>die <code>resolve</code> nicht ignorieren</b> .  Das hei√üt, der folgende Code funktioniert nicht und endet mit einem zul√§ssigen Versprechen: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Can't omit resolve ! const myPromise = new Promise(function(reject){ setTimeout(function(){ reject() }, 5000) });</span></span></code> </pre> <br>  Versprechen sehen momentan nicht so n√ºtzlich aus, oder?  Diese Beispiele zeigen dem Benutzer nichts an.  F√ºgen wir etwas hinzu.  Und erlaubte, abgelehnte Versprechen k√∂nnen Daten zur√ºckgeben.  Zum Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); });</code> </pre> <br>  Aber wir sehen immer noch nichts.  <b>Um Daten aus einem Versprechen zu extrahieren, m√ºssen Sie das Versprechen der <code>then</code> Methode zuordnen</b> .  Er nimmt einen R√ºckruf entgegen (was f√ºr eine Ironie!), Der die aktuellen Daten erh√§lt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); });</code> </pre> <br>  Als JavaScript-Entwickler und Konsument des Codes anderer Leute interagieren Sie haupts√§chlich mit externen Versprechungen.  Bibliotheksersteller verpacken Legacy-Code am h√§ufigsten wie folgt in einen Promise-Konstruktor: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shinyNewUtil = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// do stuff and resolve // or reject });</span></span></code> </pre> <br>  Bei Bedarf k√∂nnen wir ein Versprechen auch erstellen und aufl√∂sen, indem wir <code>Promise.resolve()</code> aufrufen: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve({ <span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Resolve!'</span></span>}) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(msg));</code> </pre> <br>  Ich m√∂chte Sie daran erinnern: JavaScript-Versprechen sind ein Lesezeichen f√ºr ein Ereignis, das in Zukunft stattfinden wird.  Ein Ereignis beginnt im Status ‚ÄûWarten auf eine Entscheidung‚Äú und kann erfolgreich (zul√§ssig, ausgef√ºhrt) oder erfolglos (abgelehnt) sein.  Ein Versprechen kann Daten zur√ºckgeben, die durch Anh√§ngen abgerufen werden k√∂nnen.  Im n√§chsten Kapitel werden wir diskutieren, wie mit Fehlern aus Versprechungen umgegangen werden kann. <br><br><a name="7"></a><h2>  7. Fehlerbehandlung in ES6-Versprechungen </h2><br>  Der Umgang mit Fehlern in JavaScript war immer einfach, zumindest im synchronen Code.  Schauen Sie sich ein Beispiel an: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { makeAnError(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Das Ergebnis wird sein: <br><br><pre> <code class="javascript hljs">Catching the error! <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate!</code> </pre> <br>  Wie erwartet fiel der Fehler in den <code>catch</code> .  Versuchen Sie nun die asynchrone Funktion: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeAnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { setTimeout(makeAnError, <span class="hljs-number"><span class="hljs-number">5000</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching the error! "</span></span> + error); }</code> </pre> <br>  Dieser Code ist aufgrund von <code>setTimeout</code> asynchron.  Was passiert, wenn wir es ausf√ºhren? <br><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Sorry mate!"</span></span>); ^ <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>: Sorry mate! at Timeout.makeAnError [<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> _onTimeout] (<span class="hljs-regexp"><span class="hljs-regexp">/home/</span></span>valentino/Code/piccolo-javascript/<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>.js:<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span>)</code> </pre> <br>  Jetzt ist das Ergebnis anders.  Der Fehler wurde nicht vom <code>catch</code> abgefangen, sondern stieg frei auf den Stapel.  Der Grund ist, dass <code>try/catch</code> nur mit synchronem Code funktioniert.  Wenn Sie mehr wissen m√∂chten, wird dieses Problem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> ausf√ºhrlich behandelt. <br><br>  Gl√ºcklicherweise k√∂nnen wir mit Versprechungen asynchrone Fehler so behandeln, als w√§ren sie synchron.  Im letzten Kapitel habe ich gesagt, dass das Aufrufen der <code>reject</code> zu einer Ablehnung des Versprechens f√ºhrt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); });</code> </pre> <br>  In diesem Fall k√∂nnen wir Fehler mit dem <code>catch</code> Handler behandeln, indem wir (erneut) einen R√ºckruf abrufen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Um ein Versprechen an der richtigen Stelle zu erstellen und abzulehnen, k√∂nnen Sie au√üerdem <code>Promise.reject()</code> aufrufen: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject({<span class="hljs-attr"><span class="hljs-attr">msg</span></span>: <span class="hljs-string"><span class="hljs-string">'Rejected!'</span></span>}).catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Ich m√∂chte Sie daran erinnern, dass der Then-Handler ausgef√ºhrt wird, wenn das Versprechen ausgef√ºhrt wird, und der <code>catch</code> Handler f√ºr abgelehnte Versprechen ausgef√ºhrt wird.  Dies ist jedoch nicht das Ende der Geschichte.  Unten sehen wir, wie gut <code>async/await</code> mit <code>try/catch</code> funktioniert. <br><br><a name="8"></a><h2>  8. Kombinatoren von ES6-Versprechungen: Promise.all, Promise.allSettled, Promise.any und andere </h2><br>  Versprechen sind nicht dazu gedacht, alleine zu arbeiten.  Die Promise-API bietet eine Reihe von Methoden zum <b>Kombinieren von Versprechen</b> .  Eines der n√ºtzlichsten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist Promise.all</a> , es nimmt ein Array von Versprechungen und gibt ein Versprechen zur√ºck.  Das einzige Problem ist, dass Promise.all abgelehnt wird, wenn mindestens ein Versprechen im Array abgelehnt wird. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Promise.race</a> erlaubt oder lehnt ab, sobald eines der Versprechen im Array den entsprechenden Status erh√§lt. <br><br>  In neueren Versionen von V8 werden au√üerdem zwei neue Kombinatoren eingef√ºhrt: <code>Promise.allSettled</code> und <code>Promise.any</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Promise.any</a> befindet sich noch in einem fr√ºhen Stadium der vorgeschlagenen Funktionalit√§t. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zum</a> Zeitpunkt des Schreibens wird dieser Artikel nicht unterst√ºtzt.  Theoretisch kann er jedoch signalisieren, ob ein Versprechen erf√ºllt wurde.  Der Unterschied zu <code>Promise.race</code> besteht darin, dass <b>Promise.any nicht abgelehnt wird, selbst wenn eines der Versprechen abgelehnt wird</b> . <br><br>  <code>Promise.allSettled</code> noch interessanter.  Er nimmt auch eine Reihe von Versprechungen an, ‚Äûverk√ºrzt‚Äú sich jedoch nicht, wenn eines der Versprechen abgelehnt wird.  Dies ist n√ºtzlich, wenn Sie √ºberpr√ºfen m√ºssen, ob alle Versprechen in einem Array zu einem bestimmten Zeitpunkt √ºbergegangen sind, unabh√§ngig davon, ob abgelehnte Versprechen vorhanden sind.  Es kann als das Gegenteil von <code>Promise.all</code> . <br><br><a name="9"></a><h2>  9. ES6-Versprechen und die Mikrotask-Warteschlange </h2><br>  Wenn Sie sich aus dem vorherigen Kapitel erinnern, befindet sich jede asynchrone R√ºckruffunktion in JavaScript in der R√ºckrufwarteschlange, bevor sie den Aufrufstapel erreicht.  An das Versprechen √ºbergebene R√ºckruffunktionen haben jedoch ein anderes Schicksal: Sie werden eher von der Mikrotask-Warteschlange als von der Task-Warteschlange verarbeitet. <br><br>  Und hier m√ºssen Sie vorsichtig sein: Die <b>Mikrotask-Warteschlange steht vor der Anrufwarteschlange</b> .  R√ºckrufe aus der Mikrotask-Warteschlange haben Vorrang, wenn die Ereignisschleife pr√ºft, ob neue R√ºckrufe f√ºr den Aufrufstapel bereit sind. <br><br>  Diese Mechanik wird von Jake Archibald in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Mikrotasks, Warteschlangen und Zeitpl√§nen</a> ausf√ºhrlicher beschrieben. <br><br><a name="10"></a><h2>  10. JavaScript-Engines: Wie funktionieren sie?  Asynchrone Evolution: von Versprechen zu Async / Warten </h2><br>  JavaScript entwickelt sich rasant weiter und wir verbessern uns jedes Jahr st√§ndig  Versprechen sahen aus wie ein Finale, aber <b>mit ECMAScript 2017 (ES8) erschien eine neue Syntax: <code>async/await</code></b> . <br><br>  <code>async/await</code> ist nur eine stilistische Verbesserung, die wir syntaktischen Zucker nennen.  <code>async/await</code> √§ndert JavaScript in keiner Weise (vergessen Sie nicht, dass die Sprache mit √§lteren Browsern abw√§rtskompatibel sein und vorhandenen Code nicht besch√§digen sollte).  Dies ist nur eine neue Methode, um asynchronen Code basierend auf Versprechungen zu schreiben.  Betrachten Sie ein Beispiel.  Oben haben wir das Versprechen bereits im entsprechenden <code>then</code> gespeichert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); myPromise.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data))</code> </pre> <br>  Jetzt <b>k√∂nnen wir mit <code>async/await</code> den asynchronen Code so verarbeiten, dass der Code f√ºr den Leser unserer Auflistung synchron aussieht</b> .  Anstatt <code>then</code> wir das Versprechen in eine Funktion mit der Bezeichnung <code>async</code> , und dann <code>await</code> wir <code>await</code> Ergebnis: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ resolve([{ <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Chris"</span></span> }]); }); <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); } getData();</code> </pre> <br>  Sieht gut aus, oder?  Es ist lustig, dass eine asynchrone Funktion immer ein Versprechen zur√ºckgibt, und niemand kann es daran hindern: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> data; } getData().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data));</code> </pre> <br>  Was ist mit Fehlern?  Einer der Vorteile von <code>async/await</code> ist, dass wir mit dieser Konstruktion <code><b>try/catch</b></code> .  Lesen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Einf√ºhrung zur Fehlerbehandlung in asynchronen Funktionen und deren Tests</a> . <br><br>  Schauen wir uns noch einmal das Versprechen an, in dem wir Fehler mit dem <code>catch</code> Handler behandeln: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ reject(<span class="hljs-string"><span class="hljs-string">'Errored, sorry!'</span></span>); }); myPromise.catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err));</code> </pre> <br>  Mit asynchronen Funktionen k√∂nnen wir Folgendes umgestalten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> data = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> myPromise; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data); <span class="hljs-comment"><span class="hljs-comment">// or return the data with return data } catch (error) { console.log(error); } } getData();</span></span></code> </pre> <br>  Allerdings hat nicht jeder zu diesem Stil gewechselt.  <code>try/catch</code> kann Ihren Code komplizieren.  Es gibt noch eine Sache zu beachten.  Sehen Sie in diesem Code, wie ein Fehler in diesem <code>try</code> Block auftritt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>));</code> </pre> <br>  Was ist mit den zwei Zeilen, die in der Konsole angezeigt werden?  Denken Sie daran, dass <b><code>try/catch</code> ein synchrones Konstrukt ist und unsere asynchrone Funktion ein Versprechen generiert</b> .  Sie folgen zwei verschiedenen Wegen, wie Z√ºge.  Aber sie werden sich niemals treffen!  ,   <code>throw</code> ,     <code>catch</code>  <code>getData()</code> .      ,     ¬´Catch me if you can¬ª,    ¬´I will run no matter what!¬ª. <br><br>      ,  <code>throw</code>   <code>then</code> .   , ,  <code>Promise.reject()</code>  : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getData</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Catch me if you can"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err.message); } } Now the error will be handled <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> expected: getData() .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"I will NOT run no matter what!"</span></span>)) .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Catching err"</span></span>)); <span class="hljs-string"><span class="hljs-string">"Catching err"</span></span> <span class="hljs-comment"><span class="hljs-comment">// output</span></span></code> </pre> <br>   <code>async/await</code>        JavaScript.         . <br><br>   ,       JS-  <code>async/await</code> .    .     ,       <code>async/await</code> ‚Äî   . <br><br><a name="11"></a><h2> 11. JavaScript-:   ?  </h2><br> JavaScript ‚Äî     ,   ,    .   JS-: V8,   Google Chrome  Node.js; SpiderMonkey,   Firefox; JavaScriptCore,   Safari. <br><br> JavaScript-   ¬´¬ª :  ,  ,  ,   .      ,      . <br><br> JavaScript-  ,         .        JavaScript:  ,     - ,     (, )    . <br><br>       ECMAScript 2015   .  ‚Äî   ,         .      .  2017-  <code>async/await</code> :    ,    ,      . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452906/">https://habr.com/ru/post/de452906/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452892/index.html">Wie kann ein Nicht-Programmierer in die USA ziehen: Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de452894/index.html">Face Anti-Spoofing oder technologisch einen Betr√ºger von tausend Gesichtern erkennen</a></li>
<li><a href="../de452900/index.html">Indizes in PostgreSQL - 9 (BRIN)</a></li>
<li><a href="../de452902/index.html">Nach 4 Jahren Ausbildung zum Programmierer verstehe ich, dass ich weit von einem Programmierer entfernt bin</a></li>
<li><a href="../de452904/index.html">Wie Maschinen kommunizieren - MQTT-Protokoll</a></li>
<li><a href="../de452908/index.html">Selenium WebDriver - Echtzeit-Testmetrik mit Grafana und InfluxDB</a></li>
<li><a href="../de452910/index.html">Hallo Habr! Hallo Tercon</a></li>
<li><a href="../de452914/index.html">ML auf der Scala mit einem L√§cheln f√ºr diejenigen, die keine Angst vor Experimenten haben</a></li>
<li><a href="../de452916/index.html">Steh auf und geh. Wirbels√§ulenchirurgie: Wann, was ist gef√§hrlich?</a></li>
<li><a href="../de452922/index.html">Flexible CSS-Rastertabellen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>