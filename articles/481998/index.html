<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ùï ‚ôøÔ∏è ü•ë M√°quina de Turing, como modelo de programas de aut√≥matas. üë®üèΩ‚Äçüè´ üôçüèº üì©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="M√°quina de Turing, como modelo de programas de aut√≥matas. 
 1. Introducci√≥n 
 La programaci√≥n necesita nuevos modelos algor√≠tmicos universales, y el h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>M√°quina de Turing, como modelo de programas de aut√≥matas.</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/481998/"><h2>  M√°quina de Turing, como modelo de programas de aut√≥matas. </h2><br><h3>  1. Introducci√≥n </h3><br>  La programaci√≥n necesita nuevos modelos algor√≠tmicos universales, y el hardware implementa algoritmos no solo en una forma diferente, sino tambi√©n en base a otro modelo algor√≠tmico: autom√°tico.  Adoptar tecnolog√≠a del campo del desarrollo de hardware es una idea clave de la programaci√≥n automatizada.  Sin embargo, la s√≠ntesis de dispositivos digitales es diferente de la programaci√≥n.  Pero, tomando prestado un modelo, por un lado, no es aconsejable cambiarlo sustancialmente, pero, por otro lado, no se puede ignorar la teor√≠a y la pr√°ctica existentes de la programaci√≥n. <br><br>  A continuaci√≥n, consideraremos la tecnolog√≠a SWITCH para dise√±ar programas automatizados, en los que se encuentre con dichos procesos todo el tiempo.  Por un lado, cambi√≥ tanto el modelo de m√°quina de estado que en realidad lo llev√≥ m√°s all√° del alcance de la teor√≠a de los aut√≥matas.  Y, por otro lado, introduce en la programaci√≥n conceptos que son dif√≠ciles de percibir para los programadores y, a veces, son simplemente superfluos, porque  Hay contrapartes m√°s familiares de la teor√≠a de programas y la pr√°ctica de programaci√≥n. <br><br>  Como base para la discusi√≥n de problemas de programaci√≥n autom√°tica, tomamos la reciente conferencia de A. Shalyto  [1] y sus art√≠culos "program√°ticos" sobre la definici√≥n del paradigma de la programaci√≥n autom√°tica [2, 3]. <br><a name="habracut"></a><br>  <b>1. Objetos automatizados, esquemas de programa.</b> <br><br>  En la conferencia, el logro de la programaci√≥n autom√°tica es la introducci√≥n del concepto de objetos de control automatizado, tomado de la teor√≠a del control autom√°tico (TAU).  Pero recuerde que en TAU consideran no tanto objetos, sino sistemas, entre los cuales se distinguen los siguientes [4]: <br><br><img src="https://habrastorage.org/webt/zx/3w/k7/zx3wk7apg6vumkx6wkrhhorjrpg.jpeg" alt="imagen"><br><br>  En base a esto, ser√≠a m√°s correcto hablar sobre sistemas de control autom√°tico (ACS).  Ahora veamos el diagrama funcional t√≠pico de las armas autopropulsadas que se muestran en la Fig.  1. Si se considera que la cinta de la m√°quina de Turing es el objeto de control, los dispositivos de accionamiento (IS) ser√°n los elementos MT que implementar√°n el cambio en el contenido de la cinta y mover√°n el cabezal, y los dispositivos de medici√≥n (IS) ser√°n los elementos que leer√°n la informaci√≥n de la cinta. <br><br><img src="https://habrastorage.org/webt/mt/ns/y5/mtnsy5l-h2msdra8jmld6l_mn5i.jpeg" alt="imagen"><br>  <i>Fig.1.</i>  <i>Diagrama funcional de ca√±ones autopropulsados</i> <br><br>  Pero, ¬øpor qu√© recurrir a TAU si hay una pr√°ctica m√°s cercana a la programaci√≥n del dise√±o de sistemas inform√°ticos, en la que los dispositivos operativos (OS), que, por supuesto, incluyen MT, se consideran una combinaci√≥n de m√°quinas operativas (OA) y de control (UA).  Y esto est√° m√°s cerca de lo que finalmente buscamos: justificar el poder de la programaci√≥n autom√°tica.  En la fig.  2 muestra una pantalla de texto de una monograf√≠a de Mayorov S.A., Novikov G.I.  La estructura de las computadoras electr√≥nicas [5], en la que los problemas de dise√±o de los amplificadores operacionales se consideran con gran detalle. <br><br><img src="https://habrastorage.org/webt/fv/14/en/fv14ens27xhjytujiwia279csxq.jpeg" alt="imagen"><br>  <i>Fig.2.</i>  <i>El concepto de gerente y operaci√≥n de m√°quinas</i> <br><br>  Pero, si comparamos la teor√≠a del dise√±o por computadora y la teor√≠a de los programas, entonces se puede rastrear una analog√≠a estructural obvia entre ellos.  En teor√≠a de la programaci√≥n, el modelo de cualquier programa a nivel estructural puede representarse como un esquema de programa S = (M, A, C), donde M es el conjunto de elementos de memoria, A es el conjunto de operadores, C es el control [10].  Siguiendo este enfoque, cualquier programa de m√°quina de Turing tambi√©n se puede definir como un esquema de programa en el que el conjunto M est√° representado por celdas de cinta, el conjunto de operadores por acciones de MT asociadas con 1) an√°lisis de celdas, 2) cambio de caracteres en las celdas de cinta y 3) movimiento del cabezal. <br><br>  Por lo tanto, el concepto de un esquema de programa es completamente an√°logo al concepto considerado de aut√≥matas operacionales y de control, donde el modelo de UA es el modelo de la m√°quina de estado finito estructural (SKA) considerado a continuaci√≥n, y OA es una estructura para realizar acciones sobre la informaci√≥n.  En este caso, OA incluye elementos de almacenamiento de datos (arriba es la memoria) y bloques para procesar informaci√≥n que implementa el c√°lculo de condiciones l√≥gicas y la implementaci√≥n de ciertas acciones (arriba - muchos operadores). <br><br>  De lo anterior, puede entenderse que la cinta solo puede considerarse condicionalmente el objeto de control para MT.  Aunque solo sea porque el dispositivo de control de la m√°quina Turing no tiene acceso directo a √©l, porque  Todas las operaciones con celdas se realizan indirectamente por bloques OA.  Adem√°s, parece que no es muy familiar o, si no quiere decir, es extra√±o considerarlo como el objetivo de la gesti√≥n del programa, como sistema de control, un objeto que representa una memoria (cinta). <br>  Por lo tanto, para una definici√≥n formal de una m√°quina de Turing, y en su contexto un lugar para un modelo de m√°quina de estados finitos, los conceptos de teor√≠a de programas son suficientes.  Ahora, en contraste con la definici√≥n muy vaga de los programas de aut√≥matas que se ofrecen en el marco de la tecnolog√≠a SWITCH, podemos decir que un programa de aut√≥matas es un programa que tiene control en forma de un modelo de m√°quina de estados finitos. <br><br>  Cu√°l ser√° el programa en s√≠ mismo, con un comportamiento simple o complejo, cu√°l es su "variedad", con control l√≥gico, "con asignaci√≥n expl√≠cita de estado", etc.  etc.  No importa en absoluto.  Lo principal es el tipo de gesti√≥n.  Los elementos restantes del programa se pueden determinar en una amplia gama, desde los m√°s simples, como, por ejemplo, con una m√°quina de Turing, hasta los m√°s complejos, cualquier forma de operadores, funciones y estructuras de datos de lenguajes de programaci√≥n: ensamblador, lenguaje de alto nivel, etc. <br><br>  Tambi√©n puede recordar que una m√°quina de Turing ha sido considerada durante mucho tiempo alfombra autom√°tica [6] o, en casos extremos, su simple extensi√≥n [7].  Pero debe comprender qu√© tipo de aut√≥mata es, qu√© tipo de extensi√≥n es y si son equivalentes a los modelos de m√°quinas cl√°sicas de estados finitos.  Tratemos de aclarar esto. <br><br>  <b>2. Programaci√≥n de Turing en un entorno de programaci√≥n automatizado.</b> <br><br>  En la fig.  La Figura 3 muestra el aut√≥mata para la funci√≥n de incremento MT de la monograf√≠a [8].  En la forma, esto claramente no es un programa MT, pero ya no es una m√°quina cl√°sica de estados finitos.  En la fig.  La Figura 4 muestra el gr√°fico de la m√°quina cl√°sica de estado finito estructural (SKA) y su implementaci√≥n en el entorno VKPa (el entorno de programaci√≥n automatizada de componentes visuales en C ++ en el marco de la biblioteca Qt y el entorno Qt Creator), que implementa el mismo algoritmo de unidad de control MT. <br><br><img src="https://habrastorage.org/webt/6n/xv/rn/6nxvrne_9pugaykk9zhfxekzvju.jpeg" alt="imagen"><br>  <i>Fig.3.</i>  <i>Aumente el n√∫mero por unidad usando una m√°quina Turing</i> <br><br><img src="https://habrastorage.org/webt/iq/fx/d2/iqfxd2lsiammfthsrdqcl3bkneo.jpeg" alt="imagen"><br>  <i>Fig. 4 Modelo de programa de incremento para MT en forma de SKA</i> <br><br>  Puede ver que la m√°quina estructural tiene cuatro canales de entrada y cinco de salida.  Cada uno de estos canales est√° asociado con una funci√≥n de programa del mismo nombre: un predicado o acci√≥n.  Aqu√≠, los predicados son funciones sin par√°metros que devuelven un valor booleano dependiendo del valor de la celda de cinta que est√°n viendo, y las acciones son funciones sin par√°metros que realizan una u otra acci√≥n para cambiar la celda de cinta y mover el cabezal de la m√°quina Turing. <br><br>  Este SKA tiene el mismo conjunto de estados que el aut√≥mata de la figura 3.  Adem√°s, adem√°s del mapeo del aut√≥mata, presentado por SKA, implementa dos mapeos m√°s: mapeando el conjunto de predicados (x1, ..., xM) al conjunto de canales de entrada de la misma m√°quina, y el conjunto de canales de salida de la m√°quina al conjunto de las mismas acciones: y1, ..., yN.  Por ejemplo, el predicado x3 devolver√° verdadero (valor 1 para la se√±al de entrada del mismo nombre) si hay un 1 en la celda actual, y la acci√≥n y4, que se activar√° cuando la misma se√±al de salida de la m√°quina tome el valor 1, corresponder√° a mover la cabeza hacia la izquierda (L) y etc.  etc. <br><br>  Tenga en cuenta que el SKA no controla directamente la cinta, sino que implementa asignaciones [adicionales], que vinculan las se√±ales del aut√≥mata con las funciones que determinan las muchas operaciones de la m√°quina Turing.  Esto nos convence una vez m√°s de que no es necesario introducir el concepto de un objeto de control automatizado en una situaci√≥n en la que el concepto de mapeo "anticuado" pero matem√°ticamente riguroso es suficiente. <br><br>  Comparando los aut√≥matas en la Fig.  3 y la fig.  4, se puede ver que SKA no utiliza el comando "*" (ver Fig. 1).  En tal situaci√≥n, es suficiente para √©l no dar una se√±al asociada con este comando.  Adem√°s, dos o m√°s se√±ales (tanto de entrada como de salida) en la misma transici√≥n son paralelas.  Por lo tanto, cuando hay un conflicto de acceso a objetos compartidos (por ejemplo, necesita cambiar la celda y mover la cabeza), se utiliza un acuerdo: las acciones en una transici√≥n se realizan secuencialmente en el orden de sus n√∫meros, es decir.  Una acci√≥n con un n√∫mero m√°s alto se realiza despu√©s de una acci√≥n con un n√∫mero m√°s bajo.  Este acuerdo no se aplica a predicados, ya que  No cambian la cinta.  Por lo tanto, hacemos que la m√°quina sea m√°s compacta e intuitiva (no es necesario introducir estados intermedios). <br><br>  En el proceso de probar el programa de incremento, se identificaron situaciones en las que pueden surgir problemas durante la operaci√≥n del MT.  Primero, la cinta real no es infinita e ir m√°s all√° puede hacer que un programa se bloquee.  En segundo lugar, es necesario indicar la posici√≥n inicial de la cabeza.  Sin esto, si, por ejemplo, el n√∫mero est√° en un lugar arbitrario de la cinta, y el estado inicial de la cabeza est√° a la izquierda del n√∫mero y enfrente del espacio, entonces la cabeza comenzar√° a moverse inmediatamente hacia la izquierda.  Luego puede ir m√°s all√° de los l√≠mites de la cinta, provocando que el programa se "bloquee" o, tras moverse un paso hacia la izquierda, escriba en la celda 1 y, colgando, completar√° la operaci√≥n "exitosa".  O, si el n√∫mero contiene 1 en todos los d√≠gitos y est√° escrito desde el principio de la cinta, entonces el intento final de transferir 1 al d√≠gito principal causar√° el mismo "bloqueo". <br><br>  <b>2.1.</b>  <b>Implementaci√≥n de objetos de MT en C ++</b> <br><br>  Considere la implementaci√≥n del software objeto de una m√°quina Turing en C ++ en el entorno VKPa, que implementa cualquier programa para MT, incluido el programa de c√°lculo de incrementos. <br><br>  Para este prop√≥sito, se ha creado una clase base que representa cualquier m√°quina de Turing, que es heredada por los objetos de software que implementan uno u otro programa MT.  Este b√°sico se muestra en el Listado 1, y el programa que implementa la tarea de incremento se muestra en el Listado 2. <br><br>  Listado 1. Implementaci√≥n de software de la clase base MT <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"lfsaappl.h"</span></span></span><span class="hljs-meta"> class FTuringMashine : public LFsaAppl { public: FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL); protected: int x15(); int x16(); void y14(); void y15(); void y16(); void y17(); QString strSrc; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    QString strTape; //  QString strHead; //  int nIndexHead{0}; //   bool bRestart{false}; //   int nHeadPosition{0}; //    }; #include "stdafx.h" #include "FTuringMashine.h" FTuringMashine::FTuringMashine(string strNam, CVarFsaLibrary *pCVFL, LArc* pTBL): LFsaAppl(pTBL, strNam, nullptr, pCVFL) { nHeadPosition = 0; strHead = "________________________________________"; nIndexHead = nHeadPosition; } //============================================================== //  //  ? int FTuringMashine::x15() { return strTape[nIndexHead] == '#'; } // ? int FTuringMashine::x16() { return bRestart; } //============================================================== //  //      void FTuringMashine::y14() { strTape[nIndexHead] = '#'; } //    ( ) void FTuringMashine::y15() { nIndexHead++; } //    ( ) void FTuringMashine::y16() { nIndexHead--; } //     void FTuringMashine::y17() { strTape = strSrc; nIndexHead = 0; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre> <br>  Listado 2. Programa de incremento para una m√°quina Turing <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTIncrement : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTIncrement(nameFsa, pCVarFsaLibrary); } FTIncrement(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); void y1(); void y2(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTIncrement.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TIncrement[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . . , .   , 2- , 2011 ., // .17-18 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= LArc(" ", " ", "^x1", "y15"), LArc(" ", " ", "x1", "y16"), LArc(" ", " ", "x2", "y2y16"), LArc(" ", "", "x1", "y1"), LArc(" ", "", "x3", "y1"), LArc("", " ", "x16", "y17"), LArc() }; FTIncrement::FTIncrement(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TIncrement) { strSrc = "11011110011111 "; strTape = strSrc; } //  int FTIncrement::x1() { return strTape[nIndexHead] == ' '; } int FTIncrement::x2() { return strTape[nIndexHead] == '1'; } int FTIncrement::x3() { return strTape[nIndexHead] == '0'; } //  void FTIncrement::y1() { strTape[nIndexHead] = '1'; } void FTIncrement::y2() { strTape[nIndexHead] = '0'; }</span></span></span></span></code> </pre><br>  <b>2.2.</b>  <b>Ejemplos de programas para MT con implementaci√≥n en C ++</b> <br><br>  Considere un ejemplo de un programa para MT que "act√∫a como un aceptador del lenguaje, es decir  puede reconocer el lenguaje "de [9].  Su funci√≥n de transici√≥n se muestra en la Fig.  5, y el aut√≥mata equivalente en forma de SKA en la Fig.  6) <br><br><pre> <code class="plaintext hljs">Œ¥(1, a) = (2, x, R) Œ¥(1, y) = (4, y, R) Œ¥(2, a) = (2, a, R) Œ¥(2, y) = (2, y, R) Œ¥(2, b) = (3, y, L) Œ¥(3, y) = (3, y, L) Œ¥(3, a) = (3, a, R) Œ¥(3, x) = (1, x, R) Œ¥(4, y) = (4, a, R) Œ¥(4, #) = (F, #, L)</code> </pre> <br>  <i>Fig.</i>  <i>5. La funci√≥n de transici√≥n de la m√°quina Turing, reconociendo el lenguaje {anbn: n‚â•1}</i> <br><br><img src="https://habrastorage.org/webt/z9/ab/hl/z9abhlvacupxhkbuzbfbupsmikq.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>6. Gr√°fico SKA de una m√°quina Turing que reconoce el idioma {anbn: n‚â•1}</i> <br><br>  La unidad de control MT en forma de SKA tiene 6 canales de entrada y 7 de salida.  El programa aceptor tambi√©n incluye el n√∫mero correspondiente de predicados y acciones, que se presentan en la figura a la derecha del gr√°fico del aut√≥mata.  La implementaci√≥n del programa C ++ en el entorno VKPA se muestra en el Listado 3. <br><br>  Listado 3. Programa para una m√°quina de Turing que reconoce el idioma {anbn: n‚â•1} <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> extern LArc TBL_TAcceptor[]; class FTAcceptor : public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTAcceptor(nameFsa, pCVarFsaLibrary); } FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB = TBL_TAcceptor); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y18(); int nState{1}; friend class CDlgTAcceptor; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"stdafx.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTAcceptor.h"</span></span></span><span class="hljs-meta"> LArc TBL_TAcceptor[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// . .Ma  .   . 2013 ., //     , .304 //=====    ============== // f(1,a) = (2,x,R) f(1,y) = (4,y,R) // f(2,a) = (2,x,R) f(2,y) = (2,y,R) // f(2,b) = (2,x,R) f(3,y) = (3,y,L) // f(3,a) = (3,a,R) f(3,x) = (1,x,R) // f(4,y) = (4,a,R) f(4,#) = (F,#,L) //========================================= LArc("1", "2","x1", "y1y15"), // 1,a,2,x,R LArc("1", "4","x3", "y15"), // 1,y,4,R LArc("2", "2","x1", "y15"), // 2,a,2,R LArc("2", "3","x2", "y2y16"), // 2,b,3,y,L LArc("2", "2","x3", "y15"), // 2,y,2,R LArc("3", "3","x1", "y16"), // 3,a,3,L LArc("3", "3","x3", "y16"), // 3,y,3,L LArc("3", "1","x4", "y15"), // 3,x,1,R LArc("4", "4","x3", "y2y15"), // 4,y,4,a,R LArc("4", "F","x15", "-"), // 4,#,F,-,- LArc("F", "1","x16", "y17"), // LArc("1", "1","x16", "y17"), // LArc("2", "1","x16", "y17"), // LArc("3", "1","x16", "y17"), // LArc("4", "1","x16", "y17"), // // LArc("1", "1","--", "y18"), // LArc() }; FTAcceptor::FTAcceptor(string strNam, CVarFsaLibrary *pCVFL, LArc* pTB): FTuringMashine(strNam, pCVFL, pTB) { strSrc = "aaaaaaaaaabbbbbbbbbb#"; strTape = strSrc; } int FTAcceptor::x1() { return strTape[nIndexHead] == 'a'; } int FTAcceptor::x2() { return strTape[nIndexHead] == 'b'; } int FTAcceptor::x3() { return strTape[nIndexHead] == 'y'; } int FTAcceptor::x4() { return strTape[nIndexHead] == 'x'; } void FTAcceptor::y1() { strTape[nIndexHead] = 'x'; } void FTAcceptor::y2() { strTape[nIndexHead] = 'y'; } void FTAcceptor::y3() { strTape[nIndexHead] = 'a'; } void FTAcceptor::y18() { switch(nState) { case 1: if (x1()) { nState = 2; y1(); y5(); break; } if (x3()) { nState = 4; y5(); break; } break; case 2: if (x1()) { nState = 2; y5(); break; } if (x2()) { nState = 3; y2();y6(); break; } if (x3()) { nState = 2; y5(); break; } break; case 3: if (x1()) { nState = 3; y6(); break; } if (x3()) { nState = 3; y6(); break; } if (x4()) { nState = 1; y5(); break; } break; case 4: if (x3()) { nState = 4; y2(); y5(); break; } if (x5()) { nState = 5; break; } break; case 5: if (x6()) { y7(); nState = 1; break; } break; } }</span></span></span></span></code> </pre><br>  En el Listado 3, la acci√≥n y18 representa una variante del programa MT de acuerdo con el enfoque de tecnolog√≠a SWITCH.  Como parte de la implementaci√≥n de la programaci√≥n autom√°tica del entorno VKPA, en este caso, en lugar del aut√≥mata de la Fig.  6, ser√° necesario implementar un aut√≥mata con un estado, que emite una se√±al y18 en el ciclo.  Corresponde a la l√≠nea comentada de la tabla de conversi√≥n en el Listado 3. Para que la m√°quina autom√°tica funcione como SWICH, debe eliminar el comentario de esta l√≠nea y comentar las l√≠neas restantes. <br><br>  Considere otro ejemplo de un programa para una m√°quina de Turing de [7], donde MT se define como "una extensi√≥n muy simple de un modelo de m√°quina de estado finito".  En este caso, el programa para la m√°quina de Turing es una lista finita de cinco de la funci√≥n parcialmente definida de transiciones y salidas Œ¥: S √ó XÔÇÆS √ó X √ó G. <br><br>  El programa MT, que encuentra el mayor divisor com√∫n (MCD) de dos n√∫meros, se muestra en la Fig.  7. El gr√°fico SKA equivalente se presenta en la Fig.  8. Tenga en cuenta que el comando de reescritura tampoco se usa aqu√≠.  La implementaci√≥n de C ++ se muestra en el Listado 4. <br><br><img src="https://habrastorage.org/webt/ce/zf/s_/cezfs_layjwqcyzmvo0vhqupkwk.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>7. El gr√°fico de transici√≥n de una m√°quina de Turing que calcula el MCD de dos n√∫meros y varias de sus configuraciones al procesar un par de n√∫meros &lt;4, 6&gt;</i> <i><br></i> <br><img src="https://habrastorage.org/webt/_p/ai/vl/_paivlzhwtehlewnthhkcrpndba.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>8. El gr√°fico SKA, equivalente al gr√°fico de la Fig.</i>  <i>7 7</i> <br><br>  Listado 4. Programa para una m√°quina de Turing para encontrar el MCD de dos n√∫meros <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTGrCmDiv: public FTuringMashine { public: LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTGrCmDiv(nameFsa, pCVarFsaLibrary); } FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y17(); }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTGrCmDiv.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TGrCmDiv[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//=====     (Greatest Common Divider) ============== // . ..   , - .: , 2003. - 208 . // .194 // .  ..    . .:  , 1974, - 200. // .76, 84-87 LArc("s","s","x1", "y16"), // LArc("s","s","x2", "y16"), // LArc("s","p","x3", "y1"), // LArc("s","r","x15", "y15"), // LArc("p","p","x1", "y15"), // LArc("p","p","x2", "y15"), // LArc("p","s","x3", "y2"), // LArc("p","q","x15", "y16"), // LArc("q","q","x1", "y3y16"), // LArc("q","q","x2", "y14y16"), // LArc("q","s","x3", "y15"), // LArc("q","s","x15", "y15"), // LArc("r","r","x1", "y14y15"), // LArc("r","r","x2", "y3y15"), // LArc("r","s","x3", "y16"), // LArc("r","!","x15", "--"), // LArc("!","s","x16", "y17"), // LArc() }; FTGrCmDiv::FTGrCmDiv(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TGrCmDiv) { nHeadPosition = 4; strSrc = "#1111111111## "; strTape = strSrc; nIndexHead = nHeadPosition; } int FTGrCmDiv::x1() { return strTape[nIndexHead] == 'a'; } int FTGrCmDiv::x2() { return strTape[nIndexHead] == 'b'; } int FTGrCmDiv::x3() { return strTape[nIndexHead] == '1'; } int FTGrCmDiv::x4() { return strTape[nIndexHead] == '#'; } void FTGrCmDiv::y1() { strTape[nIndexHead] = 'a'; } void FTGrCmDiv::y2() { strTape[nIndexHead] = 'b'; } void FTGrCmDiv::y3() { strTape[nIndexHead] = '1'; } void FTGrCmDiv::y17() { strTape = strSrc; nIndexHead = 4; bRestart = false; nIndexHead = nHeadPosition; }</span></span></span></span></code> </pre><br>  En conclusi√≥n, otro programa de MT de los desarrolladores de SWITH-technology, considerado en el art√≠culo [11], que presenta la tarea de reconocer par√©ntesis en dos versiones.  Uno tiene la forma de una m√°quina Miley, el segundo es una m√°quina mixta (respectivamente en la Fig. 9 y la Fig. 11).  Los aut√≥matas estructurales correspondientes a ellos se muestran en la Fig.  10 y la fig.  12. La implementaci√≥n del programa C ++ se muestra en el Listado 5. <br><br><img src="https://habrastorage.org/webt/z4/uk/_t/z4uk_t3un74er2osfmikfgmrhni.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>9. Reconocimiento de par√©ntesis de profundidad arbitraria.</i>  <i>Gr√°fico de conversi√≥n de millas</i> <br><br><img src="https://habrastorage.org/webt/is/s6/mg/iss6mgjxclciek9s1az1t70oomg.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>10. Reconocimiento de par√©ntesis de profundidad arbitraria.</i>  <i>Earl SKA Miles</i> <br><br><img src="https://habrastorage.org/webt/dp/xy/_k/dpxy_kpzxw59qwy2tu0_c_fhpz8.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>11. Reconocimiento de par√©ntesis de profundidad arbitraria.</i>  <i>Gr√°fico de transici√≥n de un aut√≥mata mixto</i> <br><br><img src="https://habrastorage.org/webt/un/ju/2h/unju2hogmmbwqr1zs4rnaxolbj4.jpeg" alt="imagen"><br>  <i>Fig.</i>  <i>12. Reconocimiento de par√©ntesis de profundidad arbitraria.</i>  <i>Gr√°fico SCA de transiciones de un aut√≥mata mixto</i> <br><br>  Listado 5. Programa para una m√°quina de Turing para reconocer par√©ntesis <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../FTuringMashine.h"</span></span></span><span class="hljs-meta"> class FTListing2 : public FTuringMashine { public: void MooreAction(); LFsaAppl* Create(CVarFSA *pCVF) { Q_UNUSED(pCVF)return new FTListing2(nameFsa, pCVarFsaLibrary); } FTListing2(string strNam, CVarFsaLibrary *pCVFL); protected: int x1(); int x2(); int x3(); int x4(); void y1(); void y2(); void y3(); void y4(); void y5(); int i{0}; }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FTListing2.h"</span></span></span><span class="hljs-meta"> static LArc TBL_TListing2[] = { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// .  ..,  ..     , , ‚Ññ2, .144-149 //=====    (. ..   , - .: , 2003. - 208 .) ============== // f(,^` `) = (,`*`,R) // f(,` `) = (,` `,L) // f(,`1`) = (,`0`,L) // f(,` `) = (,`1`,R) // f(,`0`) = (,`1`,R) //========================================= /* //  LArc("0", "1", "x2", "y2"), // '(';  LArc("0", "3", "x3", "--"), // '('; LArc("1", "1", "x2", "y2"), // '(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "3", "^x1x4", "--"), // i!=0;' ';  LArc("1", "3", "x1x3", "--"), // i==0;')';  LArc("1", "2", "x1x4", "--"), // i==0;' ';  LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  */ //* //   - LArc("0", "1", "x2", "y2"), // '(' LArc("0", "3", "x3", "--"), // ')' LArc("1", "1", "x2", "y2"), //'(';  LArc("1", "1", "x3", "y3"), // ')';  LArc("1", "2", "x1x4", "--"), // i==0;' '; LArc("1", "3", "^x1x4", "--"), // i!=0;' '; LArc("1", "3", "x1x3", "--"), // i==0;')'; LArc("2", "0", "x16", "y17"), // bRestart;  LArc("3", "0", "x16", "y17"), // bRestart;  //*/ LArc() }; FTListing2::FTListing2(string strNam, CVarFsaLibrary *pCVFL): FTuringMashine(strNam, pCVFL, TBL_TListing2) { strSrc = "(()()) "; strTape = strSrc; } //  int FTListing2::x1() { return i == 0; } int FTListing2::x2() { return strTape[nIndexHead] == '('; } // int FTListing2::x3() { return strTape[nIndexHead] == ')'; } // int FTListing2::x4() { return strTape[nIndexHead] == ' '; } // //  void FTListing2::y1() { i = 0; } // z1_0 void FTListing2::y2() { i++; } // z1_1 void FTListing2::y3() { i--; } // z1_2 void FTListing2::y4() { strTape = ""; } // z2_0 void FTListing2::y5() { strTape = ""; } // z2_1 void FTListing2::MooreAction() { string strState = FGetState(); if (strState=="0") { y1(); } //   else if (strState=="1") { y15(); } //    else if (strState=="2") { y4(); } //  else if (strState=="3") { y5(); } //  }</span></span></span></span></code> </pre><br>  Desde el aut√≥mata en la Fig.  12 se negaron a trabajar, se decidi√≥ ir a la m√°quina en la Fig.  9. Una m√°quina autom√°tica equivalente a ella en forma de SKA se muestra en la Fig.  10. Es cierto, formalmente, este es tambi√©n un aut√≥mata mixto, desde el cual la se√±al en el estado "0" y la se√±al y15 en el estado "1" se dejaron desde la primera implementaci√≥n (Fig. 12).  La primera es necesaria durante la instalaci√≥n inicial, y la se√±al y15 implementa un desplazamiento de la cabeza hacia la derecha para leer el siguiente car√°cter de la cinta.  El resto del SKA corresponde a la m√°quina Miles en la Fig.  9) <br><br>  Despu√©s del aut√≥mata en la fig.  10 fue probado con √©xito, devuelto a la m√°quina en la Fig.  11. Y qued√≥ claro que la se√±al z1_1 con el estado "1" es superflua (para el aut√≥mata de la Fig. 12 es la se√±al y2).  El problema es que cuando encuentra el "par√©ntesis izquierdo", incrementa el contador en dos unidades, y cuando encuentra el "par√©ntesis izquierdo" no lo cambia en absoluto.  Entonces, cuando se detecta el "corchete izquierdo", se llama dos veces: una en el bucle marcado x2 / y2 y la segunda vez al ingresar al estado.  Y cuando se detecta un "soporte derecho", el contador primero disminuye en el bucle y luego aumenta al ingresar al estado. <br><br>  La raz√≥n de este trabajo del control MT est√° en la interpretaci√≥n incorrecta por parte de los autores del funcionamiento de un aut√≥mata tipo Moore.  Aparentemente, creen que una se√±al con un estado en el aut√≥mata Moore se ejecuta solo cuando ingresa a este estado (vea la transici√≥n del estado ‚Äú0‚Äù a ‚Äú1‚Äù), pero de hecho se emite cada vez que ingresa a este estado.  Incluso al pasar por un bucle.  Por lo tanto, no estamos tratando con un error (¬øqui√©n no se equivoc√≥?), Sino con un problema m√°s serio: una interpretaci√≥n incorrecta dentro del marco de la tecnolog√≠a SWITH de funcionamiento de los aut√≥matas tipo Moore.  Probar el modelo equivalente mostr√≥ esto. <br><br>  <b>3. Conclusi√≥n</b> <br><br>  Para resumir, podemos decir que no hay diferencias formales entre Turing y la programaci√≥n autom√°tica, como  La m√°quina de Turing es un modelo abstracto de programas de aut√≥matas.  Solo en el √∫ltimo caso, se utiliza un conjunto m√°s amplio de operadores y estructuras de datos (memoria).  Ahora podemos responder con confianza la pregunta de c√≥mo la m√°quina Post, como modelo de programas ordinarios, difiere de la m√°quina Turing, el modelo de programas autom√°ticos.  Modelo de gesti√≥n y solo eso, porque  el resto: la memoria y los operadores pueden ser lo mismo. <br>  En consecuencia, la programaci√≥n ordinaria difiere de la programaci√≥n autom√°tica solo en una cosa: el modelo de control.  Por lo tanto, mientras que para la implementaci√≥n de aut√≥matas se utilizan operadores de control ordinarios del tipo de conmutador y no se pueden usar similares, estrictamente hablando, dicha programaci√≥n se considera autom√°tica.  Esto puede ser una imitaci√≥n de aut√≥matas con la p√©rdida de sus propiedades espec√≠ficas y nada m√°s. <br><br>  Entonces, al dar una definici√≥n de los conceptos de un programa de aut√≥matas y la programaci√≥n de aut√≥matas, no necesitamos hablar de "objetos de control automatizado", sino de programas y solo programas que tienen control en forma de una m√°quina de estados finitos cl√°sica. <br>  Y otro hecho interesante sobre el que me gustar√≠a llamar la atenci√≥n.  A principios de la d√©cada de 2000, los autores expresaron su comprensi√≥n de la programaci√≥n autom√°tica para una amplia audiencia.  Sus art√≠culos sobre m√°quinas abstractas fueron publicados en la revista PC World No. 2 de 2002 [11, 12, 13].  Se puede argumentar que a lo largo de los a√±os, las condenas de las partes no se vieron afectadas.  Aunque, quiz√°s esto solo refleja el grado de confianza en las decisiones elegidas. <br><br>  Por ejemplo, en "una nueva conferencia sobre programaci√≥n autom√°tica" A. Shalyto  En comparaci√≥n con la "conferencia con diapositivas" anterior (hace diez a√±os), solo se agreg√≥ un video del ejemplo basado en el "State-of-the-art" paquete Stateflow.  Parece que esto confirma la exactitud de las ideas de A. Shalyto, porque  lo que no se pudo implementar dentro de UniMod (el proyecto parece estar "congelado"), encarnaron los desarrolladores de Stateflow.  Y, probablemente, no es tan importante qui√©n lo hizo ... <br><br>  Sin embargo, en el momento de la publicaci√≥n de los art√≠culos mencionados, los autores de la tecnolog√≠a SWITCH ya sab√≠an que la criticaban.  Esto no fue un secreto desde  estaba disponible en el sitio web de SoftCraft [14].  Tambi√©n cre√≥ secciones dedicadas a la programaci√≥n autom√°tica en general y a la tecnolog√≠a SWITH y a la tecnolog√≠a KA en particular.  Las posiciones de los autores se discutieron en el foro del sitio (estaba abierto en ese momento).  Pero todo segu√≠a sin estar convencido. <br><br>  Los resultados en este momento son los siguientes.  La cr√≠tica expresada con respecto a la tecnolog√≠a SWITH hab√≠a sido relevante y actual.  Tambi√©n se aplica al paquete Stateflow.  En la tecnolog√≠a SWITH, no exist√≠a, y no existe una definici√≥n clara de programaci√≥n autom√°tica, el enfoque para la implementaci√≥n de aut√≥matas no ha cambiado, el modelo en s√≠ no es cl√°sico, no existe un modelo de computaci√≥n paralela, etc.  etc.  Sin eliminar estos problemas, dicha programaci√≥n automatizada en el mejor de los casos reclama un papel bastante limitado. <br><br>  Las razones de los problemas mencionados anteriormente son bastante claras: se ignora la teor√≠a de los programas, se olvida la teor√≠a de los aut√≥matas, aunque se dicen muchas palabras buenas y correctas sobre los aut√≥matas y sus maravillosas propiedades.  Pero, de hecho, estas son otras m√°quinas.  El autor est√° convencido de lo dudoso de los intentos mal concebidos de crear modelos originales.  Se trata de modelos sincr√≥nicos, reactivos y de otro tipo.  Pueden ser convenientes al resolver una clase estrecha de problemas y nada m√°s.  Pero lo m√°s grave es que se caen de la teor√≠a de los aut√≥matas sin tener su propia teor√≠a.  Pero el modelo fuera de la teor√≠a es in√∫til y, por lo tanto, pr√°cticamente sin sentido. <br><br><div class="spoiler">  <b class="spoiler_title">Referencias</b> <div class="spoiler_text">  1. Shalyto A. A. Una nueva conferencia sobre programaci√≥n autom√°tica.  2019, [Recurso electr√≥nico], Modo de acceso: <a href="https://www.youtube.com/watch%3Fv%3DPPWTxceMutk%26feature%3Dyoutu.be" rel="nofollow">www.youtube.com/watch?v=PPWTxceMutk&amp;feature=youtu.be</a> , gratis.  Yaz  Ruso  (fecha de tratamiento 5 de diciembre de 2019). <br>  2. Shalyto A.A.  El paradigma de la programaci√≥n autom√°tica.  Bolet√≠n cient√≠fico y t√©cnico de la Universidad Estatal de San Petersburgo de Tecnolog√≠as de la Informaci√≥n, Mec√°nica y √ìptica.  Vol.  53. Programaci√≥n automatizada.  2008, p.  3-23. <br>  3. Shalyto A.A.  El paradigma de la programaci√≥n autom√°tica.  Actas de la XI Conferencia de Rusia sobre Ciencia y Educaci√≥n Superior "Investigaci√≥n fundamental e innovaci√≥n en universidades t√©cnicas".  SPbSPU.  2007, p.  202‚Äì205., [Recurso electr√≥nico], Modo de acceso: <a href="http://is.ifmo.ru/works/_2007_09_27_shalyto.pdf" rel="nofollow">is.ifmo.ru/works/_2007_09_27_shalyto.pdf</a> , gratis.  Yaz  Ruso  (fecha de tratamiento 5 de diciembre de 2019). <br>  4. Miroshnik I.V.  Teor√≠a del control autom√°tico.  Sistemas lineales.  - San Petersburgo: Peter, 2005 .-- 336 p. <br>  5. Mayorov S.A., Novikov G.I.  La estructura de las computadoras electr√≥nicas.  - L .: Ingenier√≠a, 1979. - 384 p. <br>  6. Minsky M. Computaciones y aut√≥matas.  M .: Mir, 1971. - 364 p. <br>  7. Karpov Yu.G.  Teor√≠a de aut√≥matas.  - San Petersburgo: Peter, 2003 .-- 208 p. <br>  8. Polikarpova N., A. Shalyto A. Programaci√≥n de aut√≥matas.  2¬™ ed., San Petersburgo.: Peter, 2011 .-- 176 p. <br>  9. J. MacConell An√°lisis de algoritmos.  Enfoque de aprendizaje activo.  3a edici√≥n.  - M .: Technosphere, 2013 .-- 415 p. <br>  10. Algoritmos, software y arquitectura de sistemas inform√°ticos multiprocesador.  M .: Nauka, 1982, 336s. <br>  11. Shalyto A.A., Tukkel N.I.  Desde la programaci√≥n de Turing hasta la autom√°tica // MirPK.  No 2.  <a href="http://is.ifmo.ru/%3Fi0%3Dworks%26i1%3Dturing" rel="nofollow">is.ifmo.ru/?i0=works&amp;i1=turing</a> <br>  12. Lyubchenko V.S.  Experimentos en m√°quinas abstractas.  "PC World", n√∫mero 2,3 / 02.  <a href="https://www.osp.ru/pcworld/2002/02/162923/" rel="nofollow">www.osp.ru/pcworld/2002/02/162923</a> , <a href="https://www.osp.ru/pcworld/2002/03/163137/" rel="nofollow">www.osp.ru/pcworld/2002/03/163137</a> <br>  13. Lyubchenko V.S.  De una m√°quina Turing a un autom√≥vil Miley.  "PC World", N¬∫ 8/02.  <a href="http://www.osp.ru/pcworld/2002/08/163856/" rel="nofollow">www.osp.ru/pcworld/2002/08/163856</a> <br>  14. Sitio web de SoftCraft.  Usando la teor√≠a de aut√≥matas en la programaci√≥n.  [Recurso electr√≥nico], Modo de acceso: <a href="http://www.softcraft.ru/auto/" rel="nofollow">www.softcraft.ru/auto</a> , gratis.  Yaz  Ruso  (fecha de tratamiento 5 de diciembre de 2019). <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/481998/">https://habr.com/ru/post/481998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../481980/index.html">C√≥mo optimizamos los scripts en Unity</a></li>
<li><a href="../481988/index.html">¬øPor qu√© Koji es el recurso perfecto para los creadores novatos de aplicaciones KaiOS?</a></li>
<li><a href="../481990/index.html">Diez a√±os de malware: las botnets m√°s grandes de 2010</a></li>
<li><a href="../481992/index.html">Tuber√≠a Tekton - Tuber√≠as nativas de Kubernetes</a></li>
<li><a href="../481996/index.html">Habra detective en el fin de semana 2. Nuevo nivel</a></li>
<li><a href="../482000/index.html">¬øTe gusta tu negocio?</a></li>
<li><a href="../482002/index.html">Escribir un blog de microservicios - Parte 3 "Usuario"</a></li>
<li><a href="../482004/index.html">Probamos 1C en el servidor VPS</a></li>
<li><a href="../482008/index.html">LEGO constructor y cero absoluto</a></li>
<li><a href="../482010/index.html">"Nuevas epopeyas". Para desarrolladores, operaciones y personas curiosas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>